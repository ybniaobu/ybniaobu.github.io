<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity Custom SRP 基础（二） | 鸟布的博客</title><meta name="author" content="鸟布"><meta name="copyright" content="鸟布"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本笔记的主要内容有 XXXXXXXXXXXXXXXXXXXXXX。"><link rel="shortcut icon" href="https://s2.loli.net/2022/09/08/Ygib4lfw6z1khnr.png"><link rel="canonical" href="https://ybniaobu.github.io/2024/12/09/2024-12-09-CustomSRP2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 鸟布","link":"链接: ","source":"来源: 鸟布的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity Custom SRP 基础（二）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-26 22:38:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/wechat%20avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/black.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鸟布的博客"><span class="site-name">鸟布的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity Custom SRP 基础（二）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-09T08:00:29.000Z" title="发表于 2024-12-09 16:00:29">2024-12-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-26T14:38:35.519Z" title="更新于 2024-12-26 22:38:35">2024-12-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/unity/">unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/unity/pipeline/">pipeline</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity Custom SRP 基础（二）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本笔记是关于 Unity 的<strong>自定义可编程渲染管线</strong>的入门基础，即 <strong>SRP (Scriptable Rendering Pipeline)</strong>，主要参考了著名的教程 <a target="_blank" rel="noopener" href="https://catlikecoding.com/">https://catlikecoding.com/</a> 的 Custom SRP Tutorial，以及知乎上各位图形学大神们的文章。  </p>
<p>笔者使用的 Unity 版本是 6000.0.27f1，Core RP Library 的版本是 17.0.3。</p>
</blockquote>
<h1 id="阴影技术知识补充"><a href="#阴影技术知识补充" class="headerlink" title="阴影技术知识补充"></a>阴影技术知识补充</h1><p>在 SRP 中实现方向光阴影之前，先补充一些实时阴影技术的相关基础知识（这里主要参考了《Real-Time Rendering 4th》的 Chapter 7 Shadows）。常见的阴影技术主要包括<strong>平面阴影 planar shadows</strong>、<strong>阴影体算法 shadow volume</strong> 以及最主流的<strong>阴影贴图技术 shadow map</strong>。</p>
<h2 id="阴影的组成"><a href="#阴影的组成" class="headerlink" title="阴影的组成"></a>阴影的组成</h2><p>首先，阴影可被分为两个部分：<strong>本影 umbra</strong> 和<strong>半影 penumbra</strong>，如下图所示：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/16/zhkS4t928eCTGlY.jpg" width = "35%" height = "35%" alt="图8 - umbra and penumbra"/>
</div>

<p><strong>精确光源 punctual light</strong>，即没有面积的光源，只会产生完全被阴影覆盖的区域，即本影区域，这样的阴影也被称为<strong>硬阴影 hard shadows</strong>。如果使用了面光源或者体积光源，那么则会产生<strong>软阴影 soft shadows</strong>。</p>
<p>如果仅仅使用低通滤波来处理硬阴影的边缘来模拟软阴影效果是不太正确的。⼀个正确渲染的软阴影应当有这样的现象：遮挡物 occluder 越靠近接收物 receiver，阴影的边缘就会越清晰。同时，软阴影的本影区域并不等同于由精确光源所产生的硬阴影；相反，软阴影的本影区域会随着光源的变大而减小。如果光源足够大，或者接收物距离遮挡物足够远的话，那么本影区域甚⾄可能会完全消失。</p>
<h2 id="平面阴影"><a href="#平面阴影" class="headerlink" title="平面阴影"></a>平面阴影</h2><p>这是一个比较简单的，应用范围比较窄的平面投射阴影技术，常用于地表是平面的游戏（比如战斗场景切换至某一特定的平面）。在这个方法中，三维物体会被渲染两次，其中第二次用于创建阴影。根据平面的位置，我们可以推导出一个投影矩阵，将物体的坐标变换到平面上去。</p>
<p>①首先一个平面可以用法向量 $\,n\,$ 和平面上已知一点 $\,p_0\,$ 来表示。假设平面任意一点为 $\,p\,$，那么向量 $\,(p - p_0)\,$ 必然正交于平面。于是<strong>平面方程 plane equation</strong> 可以写为：  </p>
<script type="math/tex; mode=display">n \cdot (p - p_0) = 0</script><p>这个方程可以改写为：  </p>
<script type="math/tex; mode=display">n \cdot p - n \cdot p_0 = n \cdot p + d = 0</script><p>其中 $\,d = -n \cdot p_0\,$。若 n 为单位法向量，这个 d 也是原点距离平面的最短距离（因为点乘有个 cos）。若 $\,n = (a, b, c)\,$ 且 $\,p\,$ 为未知点 $\,(x, y, z)\,$，就得到了我们最熟悉的平面方程：  </p>
<script type="math/tex; mode=display">ax + by + cz + d = 0</script><p>②知道了平面方程，就可以推导出投影矩阵了，如下图所示：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/16/d4i86AsMTcrX2US.png" width = "35%" height = "35%" alt="图9 - 阴影投射到任意平面"/>
</div>

<p>物体的任意一点 v 我们是知道的，那么 p 就等于（推导过程就不放了）：  </p>
<script type="math/tex; mode=display">p = l - \cfrac {d + n \cdot l} {n \cdot (v - l)}(v - l)</script><p>而上述方程可以转换为投影矩阵 M，满足 $\,Mv = p\,$：  </p>
<script type="math/tex; mode=display">M = \begin{bmatrix} n \cdot l + d - l_xn_x & -l_xn_y & -l_xn_z & -l_xd \\ -l_yn_x & n \cdot l + d - l_yn_y & -l_yn_z & -l_yd \\ -l_zn_x & -l_zn_y & n \cdot l + d - l_zn_z & -l_zd \\ -n_x & -n_y & -n_z & n \cdot l \end{bmatrix}</script><p>③我们只要将这个矩阵应用到要在平面上投射阴影的物体上，然后再将投影后的物体（即阴影）渲染为深色，并且不接收光照即可。</p>
<p>但是在实践中，阴影可能会被渲染到平面的下面去，简单的解决方案则是对投影平面或者阴影进行偏移。另一种方法则是，先绘制投影平面，然后在关闭 z-buffer 的情况下，再去绘制阴影，最后再渲染投射阴影的物体。如果接受阴影的平面是一个有限的矩形，则阴影有可能会绘制到区域外面，此时可能需要通过 stencil buffer 标记出需要接受阴影的部分作为遮罩，这样就可以只让阴影产生在需要产生的平面上。</p>
<p>当然，也可以将阴影渲染到⼀个纹理中，然后再将其应用到平面上，这个纹理其实是⼀种<strong>光照贴图 light map</strong>。对这个纹理使用卷积（即滤波），可以对硬阴影进行模糊来模拟软阴影效果。我们甚至可以在面光源表面上进行采样，将每个采样点作为⼀个精确光源，并各自渲染一张纹理，将所有的这些图像相加并取平均值，便可以生成地面的阴影纹理，这种方法可以用于获取 ground-truth 图像，以便对其他更快算法的质量进行测试对比。</p>
<h2 id="阴影体算法"><a href="#阴影体算法" class="headerlink" title="阴影体算法"></a>阴影体算法</h2><p>Shadow Volume 这个方法我就大致提一下，其在实际应用中非常少见。它需要利用 stencil buffer 来进行实现。假设从光源沿着模型边缘拉伸至无限远处，在模型下方的部分称为 shadow volume。可以说，位于 shadow volume 内部的物体，在渲染时具有阴影，在 shadow volume 外部的物体，在渲染时没有阴影，如下图：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/16/1CZi25wOozsSUrx.jpg" width = "40%" height = "40%" alt="图10 - Shadow Volume"/>
</div>

<p>假设从视点观察场景，从视点发出射线到与场景物体相交的过程中，每当射线穿过了 shadow volume 的正面（即面向观察者的一面）时，我们就让计数器加 1；也就是说，每当射线进入阴影区域时，计数器就会增加。每当光线穿过 shadow volume 的背面时，我们便将相同的计数器减 1，这代表了光线从阴影区域中射出。我们会一直持续这个过程，增加或者减少计数器的值，直到光线击中了场景中的物体。此时，如果计数器大于 0，则说明该像素位于阴影中；如果计数器为 0，则说明该像素位于阴影之外。</p>
<p>具体实现方法比较麻烦，需要生成 shadow volume 的几何体，利用两个 pass 分别绘制 shadow volume 几何体的正面和背面，最后再渲染整个场景。就不在这里详细地阐述了，想了解可以查询 z-pass、z-fail 算法。</p>
<h2 id="阴影贴图"><a href="#阴影贴图" class="headerlink" title="阴影贴图"></a>阴影贴图</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>这个就是在<a href="https://ybniaobu.github.io/2023/11/22/2023-11-22-UnityShader3/">《Unity Shader入门精要》读书笔记（三）</a> 的第八章的 Unity 的阴影小节中提到的 Shadow Map 技术，也是之后自定义 SRP 中要实现的方法，那里主要介绍的是如何写 Shader，故介绍得比较简单。Shadow Map 的实现方法里面也提到过，分为两步：<br><strong>①</strong>从光源出发，构造出光源空间，渲染整个场景，将产生阴影的物体的深度写入到 z-buffer 中，就可以得到代表了最靠近光源的物体深度值的<strong>阴影贴图 shadow map</strong>。<br><strong>②</strong>然后在渲染时，我们根据渲染物体的世界坐标，变换到上一阶段的光源空间坐标，得到光源空间深度，再计算出该点在 shadow map 中的 uv 坐标，采样得到深度值并进行比较，如果在光源空间的深度比 shadow map 中的深度要大，就说明该点处在阴影中，否则就说明不在阴影中。</p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/16/Q6oJmnNrptLfW2k.jpg" width = "50%" height = "50%" alt="图11 - 存储在纹素 a 处深度值大于点 Va 到光源的深度，因此点 Va 会被照亮；点 Vb 相对于光源的深度要大于存储在纹素 b 处的深度值，因此点 Vb 位于阴影中。"/>
</div>

<p>对于聚光灯而言，其有个天然的<strong>光照视锥体 light frustrum</strong>，故使用透视投影渲染阴影贴图，位于视锥体之外的物体都不会被照亮。但对于方向光（平行光）来说，这个光源的视野无限大，要使用正交投影来渲染阴影贴图，我们需要保证其能够看到场景中的所有物体，即光照视锥体至少要包含整个摄像机视锥体。在实践中，对于方向光会有多个不同等级或不同绘制面积的摄像机，以此实现基于距离的阴影等级划分，从而提高阴影的质量，即<strong>级联阴影 cascade shadow maps，CSM</strong>（后面也会介绍）。如果是点光源，为了能保存各个方向的深度值，一般需要使用 cubemap，其核心问题在于避免在每个面的贴图接缝处出现瑕疵。</p>
<h3 id="Shadow-acne"><a href="#Shadow-acne" class="headerlink" title="Shadow acne"></a>Shadow acne</h3><p>阴影贴图的阴影质量取决于阴影贴图的分辨率以及 zbuffer 的数值精度。在采样阴影贴图时，一个纹素代表着一个小范围区域的深度，从而导致一种交替黑线样式的锯齿问题。这个现象称为<strong>自阴影走样 self-shadow aliasing</strong> 或者<strong>阴影痤疮 shadow acne</strong>，如下图所示：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/17/efnDVCU5Qo7YjcI.jpg" width = "30%" height = "30%" alt="图12 - shadow acne"/>
</div>

<p>产生这个现象的原因是，阴影贴图受限于分辨率，一定范围内不同的点可能会从阴影贴图采样得到同一个值。比如下图中，每个斜坡代表阴影贴图一个单独的纹理像素。可以看到，一个小范围的特定区域都可能采样得到同一个深度值，而这个特定区域的深度一部分比采样得到的深度大，一部分比采样得到的深度小，从而导致了图片中的条纹样式。</p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/17/GrFIpwYK4Z7OT6M.png" width = "50%" height = "50%" alt="图13 - shadow acne 的原因"/>
</div>

<p>常见的解决这个问题的方法是<strong>阴影偏移 shadow bias</strong>，又分为<strong>深度偏移 Constant bias/Depth bias</strong>、<strong>斜率偏移 Slope bias/Slope scaled depth bias</strong>、<strong>法线偏移 Normal bias</strong>：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/17/aCWD5EG27FoyqzT.png" width = "50%" height = "50%" alt="图14 - shadow bias"/>
</div> 

<p><strong><em>①Constant bias/Depth bias</em></strong><br>这个方法就是将阴影贴图的深度添加一个常量（增加深度就是沿着光照方向增加距离），故称为 Constant bias 或 Depth bias。这个方法比较简单，但是仍然可能会在斜平面上产生问题。斜面角度较大，固定的偏移值就越容易产生问题，如下图所示：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/17/KmPMsCqFYgRB1pH.jpg" width = "55%" height = "55%" alt="图15 - 图中的灰色的竖线代表阴影贴图的像素中心。左图中，如果没有添加偏移，那么蓝色和橙色样本将会被错误地认为处于阴影中，因为与对应的阴影贴图深度相比，它们距离光源更远。中图使用了 Depth bias，但是此时蓝色样本仍然会被认为处于阴影中，因为斜率高需要的偏移量更大。右图中，在构建阴影贴图的时候，会根据斜率，对其偏移量进行修正，即 Slope scaled depth bias。"/>
</div> 

<p><strong><em>②Slope bias/Slope scaled depth bias</em></strong><br>如上所说，表面相对于光源的倾斜角度越大，所需要的偏移量也就越大，所以我们可以将偏移量修正为与光源方向和表面法线之间夹角的正切值 $\,tan \theta\,$（即斜率）成正比，公式如下。但是有个问题就是，当表面和光源呈掠射夹角（90°）时，正切值接近于无限大，故需要为偏移值设置一个最大值。</p>
<script type="math/tex; mode=display">offset = \cfrac {frustrumSize} {shadowmapSize} * tan(\theta) * Slope\,\,bias</script><p>frustrumSize 除以 shadowmapSize 就是阴影贴图的一个纹素在世界空间的大小，通常情况下，需要半个纹素的偏移，故可以将 Slope bias 设置为 0.5。</p>
<p><strong><em>③Normal bias</em></strong><br>顾名思义，就是将阴影投射体沿着物体表面的法线偏移，移动的距离与光源方向和表面法线之间夹角的正弦值 $\,sin \theta\,$ 成正比，公式如下。这个操作不仅改变了样本的深度值，还改变了它在阴影贴图上的 uv 值。</p>
<script type="math/tex; mode=display">offset = \cfrac {frustrumSize} {shadowmapSize} * sin(\theta) * Normal\,\,bias</script><blockquote>
<p>Unity 的 HDRP 中使用了 Normal bias + Slope scaled depth bias 的设置，UE5 使用了 Constant bias + Slope scaled depth bias。</p>
</blockquote>
<p>当然，我们的 bias 值也不能设置得过大，否则会出现的<strong>漏光 light leak</strong> 或者 <strong>Peter Panning</strong> 问题，即物体看起来像是悬浮在表⾯上方一样。</p>
<p>Depth bias 和 Slope scaled depth bias 可以通过硬件实现也可以通过软件实现，比如在 DirectX 中可以在合并输出阶段设置这两个参数以及 DepthBiasClamp（允许的最大深度偏移量），计算过程如下：  </p>
<script type="math/tex; mode=display">Bias = (float)DepthBias * r + SlopeScaledDepthBias * MaxDepthSlope</script><p>其中 r 跟深度缓冲区位数有关，比如 24 位，r = 1 / 2^24。</p>
<p>至于 Normal bias 就只能通过软件实现了。添加 bias 可以在生成 shadow map 阶段完成，也可以在阴影计算阶段。生成 shadow map 时，可以在 vertex shader 中通过反向添加 bias 的方式来偏移计算处的 shadow map 深度值，这样在采样阴影时，就无需考虑计算偏移的问题。</p>
<h3 id="Shadow-aliasing"><a href="#Shadow-aliasing" class="headerlink" title="Shadow aliasing"></a>Shadow aliasing</h3><p><strong>阴影走样 Shadow aliasing</strong> 泛指阴影贴图中的纹素覆盖大量像素，从而导致的块状阴影问题，如下图所示：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/17/FkchHlBNsbTE3i8.jpg" width = "30%" height = "30%" alt="图16 - 阴影走样"/>
</div> 

<p>提高阴影贴图的分辨率可以减少块状阴影的出现，但是需要额外的内存开销。其他解决方案有如下一些技术：  </p>
<h4 id="透视变形-perspective-warping"><a href="#透视变形-perspective-warping" class="headerlink" title="透视变形 perspective warping"></a>透视变形 perspective warping</h4><p>这些算法，通过修改光照空间的投影矩阵，试图将光源的采样率与相机的采样率进行更好地匹配，包括透视阴影贴图 perspective shadow map，PSM、梯形阴影贴图 trapezoidal shadow maps，TSM 和光源空间透视阴影贴图 light space perspective shadow map，LiSPSM。这类技术被统称为<strong>透视变形 perspective warping</strong> 方法。这些矩阵扭曲 matrix-warping 算法的一个优点就是，除了对光源的投影矩阵进行修改之外，不需要进行其他额外的工作。</p>
<p>这类方式虽然使用起来简单，但是有很多无法处理的特殊情况，比如观察方向和光照方向完全相同时，这类方式就完全无法发挥作用。而且在摄影机移动时，这种方式非常的不稳定。由于这类方法的应用较少，就不在这里深入讲解相关的原理和实现。</p>
<h4 id="级联阴影-cascade-shadow"><a href="#级联阴影-cascade-shadow" class="headerlink" title="级联阴影 cascade shadow"></a>级联阴影 cascade shadow</h4><p><strong>级联阴影贴图 cascade shadow maps，CSM</strong> 是目前最常见的提高阴影贴图精度的手段。其实现思想是：将视锥体划分成若干个区域，对于每个划分后的视锥体区域，光源都可以生成一个包裹该区域的视锥体，各自生成一个阴影贴图，并用纹理图集 texture atlas 或纹理数组 texture array 将不同区域的阴影贴图打包成一个较大的纹理对象。</p>
<blockquote>
<p>随着 <strong>Virtual Texture</strong> 技术的推广，Virtual Shadow Map 技术很有可能是未来的主流方向，建议去额外了解。</p>
</blockquote>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/17/SzYQgKfjGr2Edoa.jpg" width = "35%" height = "35%" alt="图17 - CSM"/>
</div> 

<p>在不同的阴影贴图之间划分深度的范围的任务，被称为 <strong>z 划分（z-partitioning）</strong>，其中一种方法是使用对数划分方法，从理论上来说是最佳方案，即满足：  </p>
<script type="math/tex; mode=display">r = \sqrt[c] {\cfrac{f}{n}}</script><p>其中 $\,n\,$ 是整个场景视锥体的近裁剪平面，$\,f\,$ 是整个场景视锥体的远裁剪平面；$\,c\,$ 是阴影贴图的数量，$\,r\,$ 是最终生成的比例。比如取 $\,n = 1, f = 1000, c = 3\,$，这样划分出来的三级 CSM 就是 1-10，10-100， 100-1000。但是如果我们这样来划分，最近处 1-10 这个范围的 CSM 划分，物体太少，反而会导致 shadowmap 空间的浪费。因此在实践中，常常会结合对数划分和其他划分手段来使用，或者直接由用户手动设置相应的比例值。</p>
<p>在使用 CSM 时，为了进一步提高算法的效率和质量，可以降低远处 CSM 的更新频率，位于较远处的阴影不需要每帧都进行更新，或者对于静态物体的阴影贴图在帧与帧之间重复使用。比如在原神中，共有八级的 CSM，前四级是每帧都更新的，后四级采用轮流更新的方式，这样相当于每帧更新 5 个等级的 CSM。</p>
<h4 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h4><p>对阴影贴图进行简单的扩展就可以获得质量不错的伪软阴影效果，还有抗锯齿的功能。比如<strong>百分比接近滤波 Percentage-Closer Filtering，PCF</strong> 技术，其原理就是在对阴影贴图采样时，检索 4 个最近的样本，先将它们与表面深度进行比较，然后在对比较的结果 0 或 1 进行插值，这种过滤的结果会产生人为的软阴影。</p>
<p>现在的图形 API 都直接提供周围四点采样的加权 PCF 深度测试，比如 DirectX 的 <code>SampleCmpLevelZero</code> 且采样器选择 Linear 的过滤器。但是硬件的实现只采样 2 × 2 的像素点，仍然不够解决锯齿问题，此时可以再使用软件的实现将采样点范围扩大并增加采样点的个数，一种常见的解决方案是使用一个预先计算好的<strong>泊松分布 Poisson distribution</strong> 来对区域进行采样。为了使结果进一步平滑，还可以对采样点位置进行旋转，这样每两个相邻的像素点，采样的模式都是不同的，可以有效地平滑半影区域。  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/18/1CrZqidpjaoPYUv.png" width = "50%" height = "50%" alt="图18 - 左图展示了 4 × 4 最近邻采样的 PCF 结果；圆盘中展示的是包含了 12 个点的泊松分布，使用这个分布对阴影贴图进行采样，获得第二张图。在第三张图中，采样模式围绕中心进行逐像素的随机旋转。"/>
</div>

<p>PCF 会有如下几个问题：①自阴影问题（阴影痤疮）和漏光问题（Peter Panning）在 PCF 中会变得更加糟糕，需要手动调整各种偏移量；②由于每个采样区域的宽度保持不变，因此阴影会表现出均匀柔和的外观，即所有阴影区域都具有相同的半影宽度。它在某些情况下是可以接受的，但是在遮挡物和接收物相接触的地方，会表现得不太合理。</p>
<h4 id="PCSS"><a href="#PCSS" class="headerlink" title="PCSS"></a>PCSS</h4><p><strong>百分比接近软阴影 percentage-closer soft shadow，PCSS</strong>，是目前比较主流的实时软阴影技术。本质上是 PCF 的扩展，PCF 的阴影区域具有相同的半影宽度，而 PCSS 试图通过计算阴影到遮挡物和光源距离，来决定采样区域的宽度，从而达到可变宽度的软阴影效果，其方程如下：  </p>
<script type="math/tex; mode=display">w_{Penumbra} = w_{Light} \cfrac {d_r - d_o} {d_o}</script><p>这个公式其实就是相似三角形，$\,d_r\,$ 是接受物到光源的距离，$\,d_o\,$ 是遮挡物到光源的平均距离，$\,w_{Light}\,$ 是光源的长度，$\,w_{Penumbra}\,$ 是半影的宽度。计算出采样区域的宽度后，根据它来动态调整采样的数量和滤波核的大小。PCSS 本身解决的问题是使用点光源模拟面光源的效果，因为本身点光源只会产生硬阴影，而使用面光源来生成 Shadow Map 存在着诸多困难。因此这里光源的宽度其实取决于渲染时假想的面光源宽度。</p>
<h4 id="过滤阴影贴图"><a href="#过滤阴影贴图" class="headerlink" title="过滤阴影贴图"></a>过滤阴影贴图</h4><p>这类方法都是对阴影贴图进行预过滤来得到软阴影效果。常见的有如下几种技术：<strong>方差阴影贴图 variance shadow map，VSM</strong>、<strong>卷积阴影贴图 convolution shadow map，CSM</strong>、<strong>指数阴影贴图 Exponential Shadow Map，ESM</strong>。对这些技术有兴趣可以看看这篇文章： <a target="_blank" rel="noopener" href="https://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf">https://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf</a> 。</p>
<p>这些技术的具体实现逻辑就不在这里阐述了。总之，对阴影贴图进行过滤可以被认为是一种廉价形式的 PCF，它只需要很少的样本。与 PCF 一样，这样产生的阴影具有恒定的半影宽度。这些滤波方法还可以与 PCSS 一起使用，从而提供可变宽度的半影效果。</p>
<h4 id="Contact-shadow"><a href="#Contact-shadow" class="headerlink" title="Contact shadow"></a>Contact shadow</h4><p><strong>接触阴影 Contact shadow</strong> 主要是阴影贴图的一个补充，它是一个屏幕空间技术，contact shadow 会 raymarching 采样 depth buffer 一段很小的距离，来补充阴影效果。接触阴影也可以缓解 bias 导致的物体底部漏光问题。</p>
<p>另外一个使用场景是配合视差贴图，使用视差贴图时，阴影贴图没法精确地计算出相应的偏移值，使用 contact shadow 能补充地面的遮挡关系。</p>
<h3 id="屏幕空间阴影贴图"><a href="#屏幕空间阴影贴图" class="headerlink" title="屏幕空间阴影贴图"></a>屏幕空间阴影贴图</h3><p>屏幕空间阴影的实现是延迟渲染里面阴影的常见实现方法。延迟渲染中的光照计算绝大部分都是在屏幕空间里进行的，同样也包括阴影，实现主要有这么几个步骤：<br>①首先得到从当前摄像机处观察到的深度纹理，在延迟渲染里这张深度图本来就有；<br>②然后再从光源出发得到从该光源处观察到的深度纹理，也被称为这个光源的阴影贴图；<br>③然后在屏幕空间做一次阴影收集计算 Shadows Collector，这次计算会得到一张屏幕空间阴影纹理。这个过程概括来说就是把每一个像素根据它在摄像机深度纹理中的深度值得到世界空间坐标，再把它的坐标从世界空间转换到光源空间中，和光源的阴影贴图里面的深度值对比，如果大于，那么就说明光源无法照到，在阴影内；<br>④最后，在正常渲染物体为它计算阴影的时候，只需要按照当前处理的 fragment 在屏幕空间中的位置对屏幕空间阴影图采样就可以了。</p>
<h1 id="方向光阴影"><a href="#方向光阴影" class="headerlink" title="方向光阴影"></a>方向光阴影</h1><p>这里只实现方向光（平行光）的阴影，点光灯和聚光灯在后面的章节。</p>
<h2 id="阴影贴图设置"><a href="#阴影贴图设置" class="headerlink" title="阴影贴图设置"></a>阴影贴图设置</h2><p>教程中使用 texture atlas 来实现 cascade shadow（我会在之后自己的实现中会改为 texture array），就是将一张贴图分为多个 tiles，如下图所示（假设 4 个平行光以及 4 级联级阴影）：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/18/2aSADU1GTNnC9yR.png" width = "35%" height = "35%" alt="图19 - Shadow atlas"/>
</div> 

<p>所以我们要先在 RenderPipelineAsset 中提供相关参数，让我们可以更改阴影贴图的相关设置（阴影质量相关参数在后面的小节里）。这些参数有：最大阴影距离、Shadow atlas 的分辨率、联级阴影的级数以及每级的比例、阴影的淡出、联级阴影的淡出。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> TextureSize </span><br><span class="line">&#123;</span><br><span class="line">    _256 = <span class="number">256</span>, _512 = <span class="number">512</span>, _1024 = <span class="number">1024</span>,</span><br><span class="line">    _2048 = <span class="number">2048</span>, _4096 = <span class="number">4096</span>, _8192 = <span class="number">8192</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Min(0.0f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> maxShadowDistance = <span class="number">100.0f</span>;</span><br><span class="line"><span class="keyword">public</span> TextureSize directionalShadowAtlas = TextureSize._1024;</span><br><span class="line">[<span class="meta">Range(1, 4)</span>] <span class="keyword">public</span> <span class="built_in">int</span> cascadeCount = <span class="number">4</span>;</span><br><span class="line">[<span class="meta">Range(0f, 1f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> spiltRatio1 = <span class="number">0.1f</span>, spiltRatio2 = <span class="number">0.25f</span>, spiltRatio3 = <span class="number">0.5f</span>;</span><br><span class="line">[<span class="meta">Range(0.001f, 1f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> distanceFade = <span class="number">0.1f</span>;</span><br><span class="line">[<span class="meta">Range(0.001f, 1f)</span>] <span class="keyword">public</span> <span class="built_in">float</span> cascadeFade = <span class="number">0.1f</span>;</span><br></pre></td></tr></table></figure>
<p>因为方向光是正交投影，理论上可以看到场景内的所有东西，所以我们需要给它个最大阴影距离来确定正交投影矩阵的大小。而联级阴影的级数就是对最大阴影距离的划分来确定各级的正交投影矩阵。阴影的距离淡出和联级阴影淡出是为了防止阴影在最大阴影距离的时候突然消失而感到突兀。</p>
<p>有了最大阴影距离，我们需要将这个参数传递给 <code>ScriptableCullingParameters</code>，以便让 <code>ScriptableRenderContext.Cull()</code> 执行剔除操作，如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!camera.TryGetCullingParameters(<span class="keyword">out</span> ScriptableCullingParameters cullingParameters)) <span class="keyword">return</span>;</span><br><span class="line">cullingParameters.shadowDistance = Mathf.Min(m_Asset.maxShadowDistance, camera.farClipPlane);</span><br><span class="line">m_Data.cullingResults = m_Data.context.Cull(<span class="keyword">ref</span> cullingParameters);</span><br></pre></td></tr></table></figure>
<p>因为阴影若超过远裁切平面的范围不管怎么样都看不到，故传递进 <code>maxShadowDistance</code> 和 <code>farClipPlane</code> 的较小值。<code>ScriptableCullingParameters</code> 的其他参数建议去官方文档好好看看。</p>
<h2 id="Cascade-Shadow-Maps-的实现"><a href="#Cascade-Shadow-Maps-的实现" class="headerlink" title="Cascade Shadow Maps 的实现"></a>Cascade Shadow Maps 的实现</h2><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>理论上来说，我们要先将摄像头放到方向光源上并计算光源的 view matrix 和 projection matrix，然后在渲染阴影贴图使用光源的 VP 矩阵。渲染完成后，还需要将光源 VP 矩阵传递给 Shader，以便将像素转换至光源空间中，并在阴影贴图采样做对比。但是现在阴影贴图被分为了多个块，采样点需要更改，所以我们需要对光源 VP 矩阵进行修改。</p>
<p>我们可以通过 Unity 的一个黑盒 API <code>CullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives()</code> 计算出来光源的 VP 矩阵，假设它为 $\,m\,$。世界空间像素经过光源空间的 VP 矩阵，得到的是裁切空间的坐标，且 x、y、z 分量范围都是 [-1, 1]，不需要透视除法，因为是正交投影。首先我们要先将裁切空间的坐标，转换至屏幕空间的坐标（阴影贴图的 uv 坐标）以便采样，就是将 x、y、z 值从 [-1, 1] 映射至 [0, 1]，即先乘 0.5 再加上 0.5，本质上就是个缩放加平移矩阵：  </p>
<script type="math/tex; mode=display">\begin{bmatrix} 1 & 0 & 0 & 0.5 \\ 0 & 1 & 0 & 0.5 \\ 0 & 0 & 1 & 0.5 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} 0.5 & 0 & 0 & 0 \\ 0 & 0.5 & 0 & 0 \\ 0 & 0 & 0.5 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} m_{00} & m_{01} & m_{02} & m_{03} \\ m_{10} & m_{11} & m_{12} & m_{13} \\ m_{20} & m_{21} & m_{22} & m_{23} \\ m_{30} & m_{31} & m_{32} & m_{33} \end{bmatrix} = \begin{bmatrix} 0.5m_{00} + 0.5m_{30} & 0.5m_{01} + 0.5m_{31} & 0.5m_{02} + 0.5m_{32} & 0.5m_{03} + 0.5m_{33} \\ 0.5m_{10} + 0.5m_{30} & 0.5m_{11} + 0.5m_{31} & 0.5m_{12} + 0.5m_{32} & 0.5m_{13} + 0.5m_{33} \\ 0.5m_{20} + 0.5m_{30} & 0.5m_{21} + 0.5m_{31} & 0.5m_{22} + 0.5m_{32} & 0.5m_{23} + 0.5m_{33} \\ m_{30} & m_{31} & m_{32} & m_{33} \end{bmatrix}</script><p>我们可以弄一个 Utility 的静态类，专门存储这类函数：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Matrix4x4 <span class="title">GetWorldToDirLightScreenMatrix</span>(<span class="params">Matrix4x4 vp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (SystemInfo.usesReversedZBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        vp.m20 = -vp.m20;</span><br><span class="line">        vp.m21 = -vp.m21;</span><br><span class="line">        vp.m22 = -vp.m22;</span><br><span class="line">        vp.m23 = -vp.m23;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vp.m00 = <span class="number">0.5f</span> * (vp.m00 + vp.m30);</span><br><span class="line">    vp.m01 = <span class="number">0.5f</span> * (vp.m01 + vp.m31);</span><br><span class="line">    vp.m02 = <span class="number">0.5f</span> * (vp.m02 + vp.m32);</span><br><span class="line">    vp.m03 = <span class="number">0.5f</span> * (vp.m03 + vp.m33);</span><br><span class="line">    vp.m10 = <span class="number">0.5f</span> * (vp.m10 + vp.m30);</span><br><span class="line">    vp.m11 = <span class="number">0.5f</span> * (vp.m11 + vp.m31);</span><br><span class="line">    vp.m12 = <span class="number">0.5f</span> * (vp.m12 + vp.m32);</span><br><span class="line">    vp.m13 = <span class="number">0.5f</span> * (vp.m13 + vp.m33);</span><br><span class="line">    vp.m20 = <span class="number">0.5f</span> * (vp.m20 + vp.m30);</span><br><span class="line">    vp.m21 = <span class="number">0.5f</span> * (vp.m21 + vp.m31);</span><br><span class="line">    vp.m22 = <span class="number">0.5f</span> * (vp.m22 + vp.m32);</span><br><span class="line">    vp.m23 = <span class="number">0.5f</span> * (vp.m23 + vp.m33);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，要判断一下是否开启了 Reversed-Z，若开启了需要翻转一下 vp 矩阵的第三列。接下来就是对阴影贴图进行切分，本质上还是进行了一次缩放和平移，我们只对 x、y 值进行缩放和平移，不能改变 z 值，因为不能改变深度：  </p>
<script type="math/tex; mode=display">\begin{bmatrix} scale & 0 & 0 & offset \\ 0 & scale & 0 & offset \\ 0 & 0 & 1 & 0\\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} m_{00} & m_{01} & m_{02} & m_{03} \\ m_{10} & m_{11} & m_{12} & m_{13} \\ m_{20} & m_{21} & m_{22} & m_{23} \\ m_{30} & m_{31} & m_{32} & m_{33} \end{bmatrix} = \begin{bmatrix} scale \times m_{00} + offset \times m_{30} & \cdots & \cdots & scale \times m_{03} + offset \times m_{33} \\ scale \times m_{10} + offset \times m_{30} & \cdots & \cdots & scale \times m_{13} + offset \times m_{33} \\ m_{20} & m_{21} & m_{22} & m_{23} \\ m_{30} & m_{31} & m_{32} & m_{33} \end{bmatrix}</script><p>写成函数如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Matrix4x4 <span class="title">GetWorldToTiledDirLightScreenMatrix</span>(<span class="params">Matrix4x4 vp, Vector2 offset, <span class="built_in">float</span> scale = <span class="number">1.0f</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix4x4 vps = GetWorldToDirLightScreenMatrix(vp);</span><br><span class="line">    </span><br><span class="line">    vps.m00 = vps.m00 * scale + offset.x * vps.m30;</span><br><span class="line">    vps.m01 = vps.m01 * scale + offset.x * vps.m31;</span><br><span class="line">    vps.m02 = vps.m02 * scale + offset.x * vps.m32;</span><br><span class="line">    vps.m03 = vps.m03 * scale + offset.x * vps.m33;</span><br><span class="line">    vps.m10 = vps.m10 * scale + offset.y * vps.m30;</span><br><span class="line">    vps.m11 = vps.m11 * scale + offset.y * vps.m31;</span><br><span class="line">    vps.m12 = vps.m12 * scale + offset.y * vps.m32;</span><br><span class="line">    vps.m13 = vps.m13 * scale + offset.y * vps.m33;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> vps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以计算阴影贴图的各个 tile 的变换矩阵后。接下来就是我们如何切分阴影贴图，并传递相关数据给 Shader ，以便采样 Shadow Atlas，毕竟我们要传递多个矩阵。</p>
<h3 id="CPU-中具体实现"><a href="#CPU-中具体实现" class="headerlink" title="CPU 中具体实现"></a>CPU 中具体实现</h3><p>首先要设定需要有多少个方向光能投射阴影，教程里假设最大方向光数量跟最大能投射阴影的方向光数量是一致的，即 4 个方向光都能投射阴影。再加上最多 4 个联级阴影级数，最大一共 16 个 tiles。故我们需要以下额外的参数以便传递给 Shader：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> m_MaxCascadeCount = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> m_DirLightShadowDataId = Shader.PropertyToID(<span class="string">&quot;_DirectionalLightShadowData&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> m_DirShadowMapID = Shader.PropertyToID(<span class="string">&quot;_DirectionalShadowMap&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> m_DirShadowMatricesID = Shader.PropertyToID(<span class="string">&quot;_DirectionalShadowMatrices&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> m_CascadeCountID = Shader.PropertyToID(<span class="string">&quot;_CascadeCount&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> m_CascadeCullingSpheresID = Shader.PropertyToID(<span class="string">&quot;_CascadeCullingSpheres&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> m_ShadowDistanceFadeID = Shader.PropertyToID(<span class="string">&quot;_ShadowDistanceFade&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Vector4[] m_DirLightShadowData = <span class="keyword">new</span> Vector4[m_MaxDirLightCount];</span><br><span class="line"><span class="keyword">private</span> Matrix4x4[] m_DirShadowMatrices = <span class="keyword">new</span> Matrix4x4[m_MaxDirLightCount * m_MaxCascadeCount];</span><br><span class="line"><span class="keyword">private</span> Vector4[] m_CascadeCullingSpheres = <span class="keyword">new</span> Vector4[m_MaxCascadeCount];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ShadowingDirLight</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> visibleLightIndex;                   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> m_ShadowingDirLightCount;     </span><br><span class="line"><span class="keyword">private</span> ShadowingDirLight[] m_ShadowingDirLights = <span class="keyword">new</span> ShadowingDirLight[m_MaxDirLightCount];</span><br></pre></td></tr></table></figure>
<p>参数说明：<br>①<code>m_MaxCascadeCount</code> 即最大级联阴影级数；<br>②<code>_DirectionalLightShadowData</code> 是个向量数组，记录的是每盏方向光的一些阴影信息，x 记录该盏方向光的阴影强度，y 记录的是它在阴影贴图的 tiles 起始序号，比如说它是第二盏方向光，设定阴影联级级数为 4，那么它的起始位置为 4。zw 暂时没有信息，在阴影质量小节会添加；<br>③<code>_DirectionalShadowMatrices</code> 就是上面提到的修改过的光源 VP 矩阵，一共最多可能要传递 16 个矩阵，一个 tile 一个矩阵；<br>④<code>_CascadeCount</code> 指我们在 Asset 设置的阴影联级级数，和最大级联阴影级数不是一个数字，最大永远是 4；<br>⑤<code>_CascadeCullingSpheres</code> 存放的是每个阴影联级级数的剔除球的中心位置（x、y、z）以及半径（w）。剔除球是 Unity 用来决定每个级数的具体覆盖范围的，也是用来决定采样哪个 tile 的依据，故需要传递至 Shader。之后也会提到；<br>⑥<code>_ShadowDistanceFade</code> 的 x 存放最大阴影距离的倒数，y 存放 distanceFade 的倒数，z 存放 cascadeFade 的一个方程式结果，w 暂时没有信息；<br>⑦<code>m_ShadowingDirLightCount</code> 是用来记录有多少方向光投射阴影，在场景中可能有 3 盏方向光，但只有 2 盏投射阴影。而 <code>ShadowingDirLight</code> 则是记录每盏投射阴影的方向光的一些信息的，包含它在所有可见光中的序号，方便我们索引到方向光的某些参数。其他信息在阴影质量小节会添加。</p>
<p><strong><em>一、首先记录并传递 <code>_DirectionalLightShadowData</code></em></strong><br>我们可以在方向光章节的 <code>SetupDirectionalLights()</code> 函数中做这件事情，上个章节遍历了所有可见光 visibleLights，当可见光为方向光时，记录下来方向光的方向和颜色，然后传递给 Shader。我们同样在遍历可见光的循环内，判断可见光为方向光后，判断可见方向光是否开启了阴影、阴影强度是否不为 0、以及可见光是否能影响到开启了阴影投射的物体。若是，则认为它是投影阴影的方向光 ShadowingDirLight，并记录下它的可见光序号。同时在 m_DirLightShadowData 中，记录它的阴影强度和 tiles 起始序号，如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetupDirectionalLights</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    m_ShadowingDirLightCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; visibleLights.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (visibleLight.lightType == LightType.Directional)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visibleLight.light.shadows != LightShadows.None </span><br><span class="line">                &amp;&amp; visibleLight.light.shadowStrength &gt; <span class="number">0f</span></span><br><span class="line">                &amp;&amp; data.cullingResults.GetShadowCasterBounds(i, <span class="keyword">out</span> Bounds outBounds))</span><br><span class="line">            &#123;</span><br><span class="line">                m_ShadowingDirLights[m_ShadowingDirLightCount] = <span class="keyword">new</span> ShadowingDirLight </span><br><span class="line">                &#123;</span><br><span class="line">                    visibleLightIndex = i</span><br><span class="line">                &#125;;</span><br><span class="line">                </span><br><span class="line">                m_DirLightShadowData[m_DirLightCount] = <span class="keyword">new</span> Vector2(visibleLight.light.shadowStrength, </span><br><span class="line">                    asset.cascadeCount * m_ShadowingDirLightCount);</span><br><span class="line">                m_ShadowingDirLightCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_DirLightShadowData[m_DirLightCount] = Vector2.zero;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    data.buffer.SetGlobalVectorArray(m_DirLightShadowDataId, m_DirLightShadowData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CullingResults.GetShadowCasterBounds()</code> API 判断光源是否影响到了开启了阴影投射的物体，它的输出参数返回包含了所有阴影投射的物体的 AABB 包围盒，我们用不到这个参数。<code>m_DirLightShadowData</code> 里的数据根据方向光的序号保存的，所以在 Shader 里使用时也要根据方向光的序号获取。当方向光没开启阴影等，<code>m_DirLightShadowData</code> 对应的数据都为 0。</p>
<p><strong><em>二、创建 Shadow Atlas：<code>_DirectionalShadowMap</code></em></strong><br>我们要新写一个 <code>RenderToDirShadowMap</code> 函数，并在 RenderPipeline 脚本的 <code>Render()</code> 方法中调用它。在这个函数中我们要先调用 <code>CommandBuffer.GetTemporaryRT()</code> 创建一个临时的 render texture 用于渲染出阴影贴图，然后把它设置为 RenderTarget，设置好后，别忘了 ClearRenderTarget：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RenderToDirShadowMap</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ShadowingDirLightCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        data.buffer.GetTemporaryRT(m_DirShadowMapID, </span><br><span class="line">            asset.directionalShadowAtlas, asset.directionalShadowAtlas, </span><br><span class="line">            <span class="number">32</span>, FilterMode.Bilinear, RenderTextureFormat.Shadowmap);</span><br><span class="line">        </span><br><span class="line">        data.buffer.SetRenderTarget(</span><br><span class="line">            <span class="keyword">new</span> RenderTargetIdentifier(m_DirShadowMapID),</span><br><span class="line">            RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store</span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">        data.buffer.ClearRenderTarget(<span class="literal">true</span>, <span class="literal">false</span>, Color.clear);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这部分可以不要</span></span><br><span class="line">        data.buffer.GetTemporaryRT(m_DirShadowMapID, </span><br><span class="line">            <span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, FilterMode.Bilinear, RenderTextureFormat.Shadowmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中 <code>CommandBuffer.GetTemporaryRT()</code> 传入 shader 参数的 ID 后，会将这个临时的 RT 设置为 ID 对应的 shader 全局变量。参数 32 设置的是深度缓冲的位数（比特），可以设置为 0、16、24、32，我们希望阴影贴图的精度高，所以设置为 32 位。Render Texture 的类型可以设置为 <code>RenderTextureFormat.Shadowmap</code> 或者 <code>RenderTextureFormat.Depth</code>，两者的区别在于 Unity 认为 shadowmap 类型的 Render Texture 只需要比较，不需要获取深度值，因此以 ShadowMap 类型创建的 RT，其采样器会设置为比较采样器（后面会提到），有些显卡可能不支持比较采样器。而且之后做 PCFF 的时候需要获取深度值，所以我认为使用 <code>RenderTextureFormat.Depth</code> 会更好一点。还有就是，临时 RT 虽然会在最终执行完所有 CommandBuffer 自动释放，但是最好还是使用 <code>CommandBuffer.ReleaseTemporaryRT()</code> 函数手动释放资源。</p>
<p>如果场景中没有投射阴影的方向光，理论上我们可以不生成阴影贴图，但是这样做会导致 WebGL 2.0 出问题，因为 WebGL 2.0 将纹理和采样器绑定到了一起，如果加载了 Shader 但是少了一张贴图，而默认的贴图和阴影采样器并不兼容，所以就会产生错误。为了避免错误，可以设置一个 1 × 1 的阴影贴图。如果不需要支持 WebGL 2.0 可以直接去掉这段代码。</p>
<p><code>CommandBuffer.SetRenderTarget()</code> 中的参数 <code>RenderBufferLoadAction</code> 设置的是当 RenderTarget 加载时候的行为，可以选择 Load、Clear、DontCare，我们不在乎 RenderTarget 的初始状态，因为我们之后会立即 ClearRenderTarget，故选择 <code>RenderBufferLoadAction.DontCare</code>；而参数 <code>RenderBufferStoreAction</code> 因为我们需要保留阴影信息，所以选择 <code>RenderBufferStoreAction.Store</code>。至于 <code>CommandBuffer.ClearRenderTarget()</code> 清除深度缓冲即可。</p>
<p><strong><em>三、渲染至 Shadow Atlas</em></strong><br>设置好 Render Target 后，我们要创建并提交绘制指令，因为要对多个方向光的每个 cascade 进行绘制，可以通过一个循环来遍历所有投影阴影的方向光进行多次绘制，如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">data.buffer.ClearRenderTarget(<span class="literal">true</span>, <span class="literal">false</span>, Color.clear);</span><br><span class="line">                </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m_ShadowingDirLightCount; i++) </span><br><span class="line">&#123;</span><br><span class="line">    RenderToDirShadowMapTile(asset,<span class="keyword">ref</span> data, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>RenderToDirShadowMapTile()</code> 这个函数中，我们首先要创建一个 <code>ShadowDrawingSettings</code> 的结构体，以便在后面传递给 <code>ScriptableRenderContext.CreateShadowRendererList()</code> 方法，之后再利用一个循环遍历设定的阴影联级级数，调用 <code>CullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives()</code> 对每个级数计算对应的光照空间下的 VP 矩阵以及阴影联级对视锥体的一个划分数据 <code>ShadowSplitData</code>。之后就是计算并设置绘制区域，传递给 Shader 数据，将计算出来的 VP 矩阵设置好后调用渲染指令 <code>DrawRendererList</code>，代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RenderToDirShadowMapTile</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data, <span class="built_in">int</span> shadowingDirLightIndex</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ShadowingDirLight shadowingDirLight = m_ShadowingDirLights[shadowingDirLightIndex];</span><br><span class="line">    ShadowDrawingSettings shadowDrawingSettings = </span><br><span class="line">        <span class="keyword">new</span> ShadowDrawingSettings(data.cullingResults, shadowingDirLight.visibleLightIndex);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> tilesCount = asset.cascadeCount * m_ShadowingDirLightCount;</span><br><span class="line">    <span class="built_in">int</span> split = tilesCount &lt;= <span class="number">1</span> ? <span class="number">1</span> : tilesCount &lt;= <span class="number">4</span> ? <span class="number">2</span> : <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">int</span> tileSize = asset.directionalShadowAtlas / split;</span><br><span class="line">    <span class="built_in">int</span> cascadeCount = asset.cascadeCount;</span><br><span class="line">    Vector3 ratios = asset.SpiltRatios;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; cascadeCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data.cullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(</span><br><span class="line">            shadowingDirLight.visibleLightIndex, i, cascadeCount, ratios, tileSize, <span class="number">0f</span>,</span><br><span class="line">            <span class="keyword">out</span> Matrix4x4 viewMatrix, <span class="keyword">out</span> Matrix4x4 projectionMatrix, <span class="keyword">out</span> ShadowSplitData splitData);</span><br><span class="line">        shadowDrawingSettings.splitData = splitData;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shadowingDirLightIndex == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector4 cullingSphere = splitData.cullingSphere;</span><br><span class="line">            cullingSphere.w *= cullingSphere.w;</span><br><span class="line">            m_CascadeCullingSpheres[i] = cullingSphere;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> tileIndex = shadowingDirLightIndex * cascadeCount + i;</span><br><span class="line">        Vector2 tileOffset = <span class="keyword">new</span> Vector2(tileIndex % split, tileIndex / split);</span><br><span class="line">        data.buffer.SetViewport(<span class="keyword">new</span> Rect(</span><br><span class="line">            tileOffset.x * tileSize, tileOffset.y * tileSize, tileSize, tileSize</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        m_DirShadowMatrices[tileIndex] = ShadowUtility.GetWorldToTiledDirLightScreenMatrix(</span><br><span class="line">            projectionMatrix * viewMatrix, tileOffset / split, <span class="number">1.0f</span> / split);</span><br><span class="line">        </span><br><span class="line">        data.buffer.SetViewProjectionMatrices(viewMatrix, projectionMatrix);</span><br><span class="line">        RendererList shadowRendererList = data.context.CreateShadowRendererList(<span class="keyword">ref</span> shadowDrawingSettings);</span><br><span class="line">        data.buffer.DrawRendererList(shadowRendererList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①<code>ShadowDrawingSettings</code> 描述了使用哪个阴影划分的数据或者设置（splitData）来渲染哪个投射阴影的方向光（visibleLightIndex）。<code>splitData</code> 在遍历阴影联级的循环中赋值。这个 <code>ShadowDrawingSettings.splitData</code> API 在 Unity 6 中已经被废弃了，虽然仍然可以使用，但 Unity 6 中建议使用 <code>ScriptableRenderContext.CullShadowCasters()</code>，之所以换 API 是因为上面的代码阴影剔除（划分）和阴影绘制的工作是在一起的，而新 API 将这两个工作分开进行了。我会在之后自己的实现中修改这部分代码；<br>②<code>tilesCount</code> 就是 Shadow Atlas 中 tiles 的总数，根据 tiles 的总数判断需要将 Shadow Atlas 划分几次，即 <code>split</code>。然后计算出每个 tile 的分辨率 <code>tileSize</code>；<br>③<code>CullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives()</code> 的主要工作就是对视锥体进行划分，因为方向光是正交投影，它使用多个级数的正交投影的裁切空间立方体对视锥体进行划分，并返回指定级数的裁切空间立方体的相关数据，比如 VP 矩阵，和阴影划分数据 <code>ShadowSplitData</code>。这个函数需要的参数我就不详细说明了，具体查看官方文档；<br>④我们在 Shader 中通过 <code>ShadowSplitData</code> 中的 <code>cullingSphere</code> 数据来判断具体采样 Shadow Atlas 的哪个 tile。利用像素点距离球心的距离，跟 cullingSphere.w 球的半径做比较，所以在这里将球的半径平方处理，以减少 Shader 中开平方的性能消耗。<code>cullingSphere</code> 就是包含在不同级联阴影级数的裁切空间立方体内的球体，主要目的就是让我们区分采样的范围，如下图；  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/25/8DBFRQ2VIP7AXYJ.png" width = "30%" height = "30%" alt="图20 - Shadow Culling/Split Sphere"/>
</div> 

<p>⑤接下来就是通过 <code>CommandBuffer.SetViewport()</code> 来设置每个 tile 在 Shadow Atlas 上的具体渲染区域，<code>tileIndex</code> 是每个 tile 的序号，通过序号可以算出每个 tile 的偏移位置，即 <code>tileOffset</code>；<br>⑥<code>m_DirShadowMatrices</code> 就是在实现原理中所说的对矩阵的平移和缩放，调用我们自己写的方法即可；<br>⑦最后就是设置渲染矩阵，创建 shadowRendererList 并渲染。这样子经过多次投射阴影方向光的多次 tile 的绘制，就能绘制出整张 Shadow Atlas 了。</p>
<p>渲染指令都处理完毕后，要在 <code>RenderToDirShadowMap</code> 函数的最后，传递数据给 Shader:  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">data.buffer.SetGlobalInt(m_CascadeCountID, asset.cascadeCount);</span><br><span class="line">data.buffer.SetGlobalVectorArray(m_CascadeCullingSpheresID, m_CascadeCullingSpheres);</span><br><span class="line">data.buffer.SetGlobalMatrixArray(m_DirShadowMatricesID, m_DirShadowMatrices);</span><br></pre></td></tr></table></figure>
<h3 id="GPU-中具体实现"><a href="#GPU-中具体实现" class="headerlink" title="GPU 中具体实现"></a>GPU 中具体实现</h3><p><strong><em>一、ShadowCaster Pass</em></strong><br>因为 <code>DrawRendererList(shadowRendererList)</code> 只会将拥有 ShadowCaster Pass 的物体渲染进阴影贴图，所以我们需要定义这个 pass。在这个 pass 中只需要将深度信息渲染进阴影贴图，所以只需要在顶点着色器做坐标变换即可。像素着色器不用返回任何东西，因为我们不用输出颜色，所以也不需要 SV_TARGET 语义。一个最简单的 ShadowCaster Pass 如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> YPIPELINE_SHADOW_CASTER_PASS_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YPIPELINE_SHADOW_CASTER_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../ShaderLibrary/Core/YPipelineCore.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionOS   : POSITION;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionHCS  : SV_POSITION;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Varyings <span class="title function_">ShadowCasterVert</span><span class="params">(Attributes IN)</span></span><br><span class="line">&#123;</span><br><span class="line">    Varyings OUT;</span><br><span class="line">    OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);</span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShadowCasterFrag</span><span class="params">(Varyings input)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>同时在 Shader 中要设置其 light mode 为 ShadowCaster：</p>
<pre><code>Pass
&#123;
    Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;

    ColorMask 0

    HLSLPROGRAM
    #pragma target 3.5

    #pragma vertex ShadowCasterVert
    #pragma fragment ShadowCasterFrag

    #include &quot;../ShaderPass/ShadowCasterPass.hlsl&quot;
    ENDHLSL
&#125;
</code></pre><p><strong><em>二、Shadow sampling</em></strong><br>我们在 ShaderLibrary 中创建一个 ShadowsLibrary.hlsl 的文件，用于存放采样阴影贴图、计算阴影衰减等函数，方便我们在计算光照时使用。首先我们得在 YPipelineInput.hlsl 中定义几个变量和 CPU 传入的参数匹配：  </p>
<pre><code>define MAX_CASCADE_COUNT 4

TEXTURE2D_SHADOW(_DirectionalShadowMap);
SAMPLER_CMP(sampler_linear_clamp_compare_DirectionalShadowMap);

CBUFFER_START(Shadows)
    float4 _DirectionalLightShadowData[MAX_DIRECTIONAL_LIGHT_COUNT];
    float4 _CascadeCullingSpheres[MAX_CASCADE_COUNT];
    float4x4 _DirectionalShadowMatrices[MAX_DIRECTIONAL_LIGHT_COUNT * MAX_CASCADE_COUNT];
    float4 _ShadowDistanceFade;
    int _CascadeCount;
CBUFFER_END
</code></pre><p>CBuffer 中的参数之前都有提到过就不重复说明了。这里定义了一张阴影贴图和对应的比较采样器，<code>TEXTURE2D_SHADOW</code> 宏在大部分平台上都是 Texture2D，<code>SAMPLER_CMP</code> 则是创建 <code>SamplerComparisonState</code> 采样器的宏，比较采样器则是用于比较采样，即 <code>SampleCmp</code> 或 <code>SampleCmpLevelZero</code> 。这两个方法将采样一块纹素区域，对于每个纹素，将其采样出来的深度值与给定比较值进行比较，返回 0 或者 1，最后将这些纹素的每个 0 或 1 结果通过设定的纹理过滤模式混合在一起返回给着色器。比如我们设定的 linear，就是检索 4 个最近的样本进行插值混合，之前的阴影技术知识补充的 PCF 中也有提到过。</p>
<p>接下来在 ShadowsLibrary.hlsl 定义几个函数，首先是坐标变换函数，根据所在 tile 的序号将世界坐标转换到指定 tile 的阴影贴图坐标：  </p>
<pre><code>float3 TransformWorldToTiledShadowCoord(float3 positionWS, int tileIndex)
&#123;
    float3 positionTSS = mul(_DirectionalShadowMatrices[tileIndex], float4(positionWS, 1.0)).xyz;
    return positionTSS;
&#125;
</code></pre><p>拿到 Tiled Shadow Space（TSS）的坐标后就可以采样阴影贴图了，使用宏 <code>SAMPLE_TEXTURE2D_SHADOW</code>，它在大部分平台中等价于 <code>_DirectionalShadowMap.SampleCmpLevelZero(sampler, positionTSS.xy, positionTSS.z)</code>，即拿 positionTSS.xy 采样阴影贴图得到深度值，跟计算出来的光源空间的深度值 positionTSS.z 做比较，返回 0 或者 1。函数如下：  </p>
<blockquote>
<p>directX 中可以对 SamplerComparisonState 设置比较函数，通常设置为 LESS_EQUAL，即第三个参数 &lt;= 采样值时返回 1。Unity 的默认情况下也是如此，即 positionTSS.z 小于等于采样阴影贴图得到的深度值时返回 1，即没有阴影，此时 shadowAttenuation 应为 1.0，即没有衰减。</p>
</blockquote>
<pre><code>float SampleShadowMap(float3 positionTSS)
&#123;
    float shadowAttenuation = SAMPLE_TEXTURE2D_SHADOW(_DirectionalShadowMap, sampler_linear_clamp_compare_DirectionalShadowMap, positionTSS);
    return shadowAttenuation;
&#125;
</code></pre><p>然后就是计算 tileIndex 了，首先方向光在阴影贴图的 tiles 的起始序号是由 <code>_DirectionalLightShadowData.y</code> 传递进来的，所以我们只需要根据传递进来的 <code>_CascadeCullingSpheres</code> 去判断像素所在的 CascadeIndex，这样就可以得到 tileIndex 了，从而采样出阴影值，代码如下：  </p>
<pre><code>float ComputeCascadeIndex(float3 positionWS)
&#123;
    float3 vector0 = positionWS - _CascadeCullingSpheres[0].xyz;
    float3 vector1 = positionWS - _CascadeCullingSpheres[1].xyz;
    float3 vector2 = positionWS - _CascadeCullingSpheres[2].xyz;
    float3 vector3 = positionWS - _CascadeCullingSpheres[3].xyz;
    float4 distanceSquare = float4(dot(vector0, vector0), dot(vector1, vector1), dot(vector2, vector2), dot(vector3, vector3));
    float4 radiusSquare = float4(_CascadeCullingSpheres[0].w, _CascadeCullingSpheres[1].w, _CascadeCullingSpheres[2].w, _CascadeCullingSpheres[3].w);

    float4 indexes = float4(distanceSquare &lt; radiusSquare);
    indexes.yzw = saturate(indexes.yzw - indexes.xyz);
    return 4.0 - dot(indexes, float4(4, 3, 2, 1));
&#125;
</code></pre><p>catlikecoding 教程中是用 for 循环来计算 CascadeIndex 的，我觉得不太好，所以看了看 URP 的阴影实现，就发现了上述不需要 for 循环的计算方式。首先计算像素世界坐标和原点的距离，跟球半径做比较。比如距离比第一个球半径长，比第二个球半径短，那么 indexes 就是 [0, 1, 1, 1]，而我们要获取的 CascadeIndex 应该是 1，即第二个球。使用的方法就是错位相减 [0, 1, 1, 1] - [0, 0, 1, 1] = [0, 1, 0, 0]。那么为什么最后 return 的时候计算 CascadeIndex，不直接 [0, 1, 0, 0] 和 float4(0, 1, 2, 3) 点乘，这样不是可以直接算出 1 吗？是因为若距离比所有球半径大的话，错位相减得到的是 [0, 0, 0, 0]，这样和 float4(0, 1, 2, 3) 点乘算出 0，就会采样到第一个球内了。</p>
<p>得到 CascadeIndex 就可以计算阴影值了，使用传递进来的阴影强度 <code>_DirectionalLightShadowData.x</code> 对采样值做插值，如下：  </p>
<pre><code>float GetDirShadowFalloff(int dirLightIndex, float3 positionWS)
&#123;
    float shadowStrength = _DirectionalLightShadowData[dirLightIndex].x;

    float cascadeIndex = ComputeCascadeIndex(positionWS);
    float tileIndex = _DirectionalLightShadowData[dirLightIndex].y + cascadeIndex;
    float3 positionTSS = TransformWorldToTiledShadowCoord(positionWS, tileIndex);
    float shadowAttenuation = SampleShadowMap(positionTSS);

    return lerp(1.0, shadowAttenuation, shadowStrength);
&#125;
</code></pre><p>计算好了，将阴影值结果乘在计算灯光 Irradiance 的函数中，就可以得到如下的阴影：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/25/DLSjfiwuapI2kQd.png" width = "35%" height = "35%" alt="图21 - 单个方向光的阴影效果"/>
</div> 

<p>可以看到阴影质量非常差，自阴影和阴影走样同时存在，这在接下来的阴影质量小节中解决。最远处的黑色区域，是因为超过了级联阴影最大级数，计算出来的 CascadeIndex 为 4，导致采样超出范围，在下面解决。</p>
<h3 id="Shadow-Fade"><a href="#Shadow-Fade" class="headerlink" title="Shadow Fade"></a>Shadow Fade</h3><p><strong><em>一、剔除超出级联阴影范围区域</em></strong><br>当像素点距离超过所有的级联阴影的 culling sphere 时，此时 CascadeIndex 计算出来为 4，这样在计算阴影坐标时会得到一个错误的矩阵。为了避免这个问题，可以使用 <code>step()</code> 函数，让 <code>cascadeIndex</code> 和传入的设定的级联阴影级数 <code>_CascadeCount</code> 比较：  </p>
<pre><code>float GetDirShadowFalloff(int dirLightIndex, float3 positionWS)
&#123;
    float cascadeIndex = ComputeCascadeIndex(positionWS);
    float shadowStrength = _DirectionalLightShadowData[dirLightIndex].x;
    shadowStrength *= 1 - step(_CascadeCount, cascadeIndex);
    ···
&#125;
</code></pre><p><code>step(a, b)</code> 是 a &lt;= b 时为 1，当 _CascadeCount &lt;= cascadeIndex 时，让阴影强度为 0，这样黑色区域就会被剔除。</p>
<p><strong><em>二、Distance Fade</em></strong><br>当在级联阴影最大级数的 culling sphere 边缘时，有时候阴影会瞬间消失，即使在最后一级的 culling sphere 内部。这是因为最后一级的 culling sphere 会有一小部分超出我们设定的最大阴影距离 <code>maxShadowDistance</code>。我们可以通过计算像素深度和最大阴影距离做比较，超过最大阴影距离则让阴影强度为 0，效果如下图：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/25/cEGMwpFDUAv4Iha.png" width = "45%" height = "45%" alt="图22 - 裁切超出最大阴影距离部分的 culling sphere"/>
</div> 

<p>可以看到超出最大阴影距离的部分还是很大的，整体效果看起来也比较突兀。所以我们需要一个渐变效果，取名为 Distance Fade，若最大阴影距离为 m，像素深度为 d，Distance Fade 为 f，则渐变阴影强度为：  </p>
<script type="math/tex; mode=display">\cfrac {1 - \cfrac {d} {m}} {f}</script><p>即当深度超过 (1 - f)m 时，开始线性衰减。如果不想要线性可以加个平方什么的。我们通过 <code>_ShadowDistanceFade</code> 传递 maxShadowDistance 和 distanceFade 值，如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">data.buffer.SetGlobalVector(m_ShadowDistanceFadeID, <span class="keyword">new</span> Vector4(<span class="number">1.0f</span> / asset.maxShadowDistance, <span class="number">1.0f</span> / asset.distanceFade));</span><br></pre></td></tr></table></figure>
<p>再在 ShadowsLibrary.hlsl 中的 <code>GetDirShadowFalloff</code> 计算渐变阴影强度：  </p>
<pre><code>float GetDirShadowFalloff(int dirLightIndex, float3 positionWS)
&#123;
    ...
    float depth = -TransformWorldToView(positionWS).z;
    float distanceFade = saturate((1 - depth * _ShadowDistanceFade.x) * _ShadowDistanceFade.y);
    shadowStrength *= distanceFade;
    ...
&#125;
</code></pre><div  align="center">  
<img src="https://s2.loli.net/2024/12/25/mlbOVzrGWfM4pS1.png" width = "45%" height = "45%" alt="图23 - Distance Fade 效果"/>
</div> 

<p><strong><em>三、Cascade Fade</em></strong><br>最后一级的 culling sphere 的边缘也比较硬，也可以软化渐变一下，方法和上面是一样的，只不过这次是距离最后一级 culling sphere 球心和半径做比值来计算，如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">data.buffer.SetGlobalVector(m_ShadowDistanceFadeID, <span class="keyword">new</span> Vector4(<span class="number">1.0f</span> / asset.maxShadowDistance, <span class="number">1.0f</span> / asset.distanceFade, <span class="number">1.0f</span> / asset.cascadeFade));</span><br></pre></td></tr></table></figure>
<pre><code>float GetDirShadowFalloff(int dirLightIndex, float3 positionWS)
&#123;
    ...
    float isInLastSphere = cascadeIndex == _CascadeCount - 1;
    float3 distanceVector = positionWS - _CascadeCullingSpheres[_CascadeCount - 1].xyz;
    float distanceSquare = dot(distanceVector, distanceVector);
    float cascadeFade = saturate((1 - distanceSquare * 1.0f / _CascadeCullingSpheres[_CascadeCount - 1].w) * _ShadowDistanceFade.z);
    shadowStrength *= lerp(1, cascadeFade, isInLastSphere);
    ...
&#125;
</code></pre><div  align="center">  
<img src="https://s2.loli.net/2024/12/25/SGCBEWrmHNXpaZy.png" width = "40%" height = "40%" alt="图24 - Cascade Fade 效果"/>
</div> 

<h2 id="阴影质量"><a href="#阴影质量" class="headerlink" title="阴影质量"></a>阴影质量</h2><h3 id="处理-Shadow-acne"><a href="#处理-Shadow-acne" class="headerlink" title="处理 Shadow acne"></a>处理 Shadow acne</h3><h4 id="Depth-and-Slope-Bias"><a href="#Depth-and-Slope-Bias" class="headerlink" title="Depth and Slope Bias"></a>Depth and Slope Bias</h4><p>之前在阴影技术知识补充有提到过，Depth and Slope Bias 可以通过硬件实现也可以通过软件实现，软件实现又分为在绘制 Shadow Map 时实现和采样 Shadow Map 时实现。</p>
<p><strong><em>一、硬件实现</em></strong><br>Unity 提供了 <code>CommandBuffer.SetGlobalDepthBias(float bias, float slopeBias)</code> API 在硬件实现这两个 bias，在教程中，也是直接使用了这个 API，在绘制阴影贴图前调用，绘制阴影贴图后设置回 0 如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">data.buffer.SetGlobalDepthBias(asset.depthBias * <span class="number">10000</span>, asset.slopeScaledDepthBias);</span><br><span class="line">RenderToDirShadowMap(asset, <span class="keyword">ref</span> data);</span><br><span class="line">data.buffer.SetGlobalDepthBias(<span class="number">0</span>, <span class="number">0f</span>); </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Depth Bias 会被乘以一个非常小的值，所以额外乘了 10000，具体效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/12/26/cGKPr5a9OUvYmEk.png" width = "40%" height = "40%" alt="图25 - SetGlobalDepthBias API 实现的 Depth and Slope Bias 效果"/>
</div>

<p>我将 depthBias 和 slopeScaledDepthBias 分别设置为 2，可以看到立方体的阴影已经略微有 Peter Panning 问题了，但是圆柱体上方仍然存在些许的 shadow acne。继续加大这两个 bias 会使 Peter Panning 问题更加严重，仅靠这两个 bias 取得的效果不是很令人满意，最好还是同时实现 Normal Bias。</p>
<p><strong><em>二、软件实现</em></strong><br>Unity URP 中的实现就是在绘制 Shadow Map 时进行偏移，URP 在 ShadowCasterPass 中在顶点着色器对世界空间顶点使用了 <code>ApplyShadowBias()</code> 函数。该函数在 URP 的 Shadows.hlsl 中定义，如下：  </p>
<pre><code>float3 ApplyShadowBias(float3 positionWS, float3 normalWS, float3 lightDirection)
&#123;
    float invNdotL = 1.0 - saturate(dot(lightDirection, normalWS));
    float scale = invNdotL * _ShadowBias.y;

    // normal bias is negative since we want to apply an inset normal offset
    positionWS = lightDirection * _ShadowBias.xxx + positionWS;
    positionWS = normalWS * scale.xxx + positionWS;
    return positionWS;
&#125;
</code></pre><p>URP 支持 Depth Bias 和 Normal Bias，<code>_ShadowBias.x</code> 传递进来的就是 Depth Bias，<code>_ShadowBias.y</code> 传递进来的是 Normal Bias。</p>
<p>在绘制 Shadow Map 时进行偏移的问题就是，我们需要在绘制阴影贴图时知道光照方向，需要将其传递至 ShadowCasterPass，我们无法使用每帧传递进来的方向光方向数组，因为在采样阴影贴图的计算中，我们是遍历所有的方向光方向数组进行计算的。而在 ShadowCasterPass 中无法知道绘制阴影贴图时具体是哪一个光源，所以需要每次绘制阴影贴图时（每帧多次），额外传递数据让 ShadowCasterPass 辨别是那盏灯、是什么灯在绘制阴影贴图，才能计算光照方向。在 URP 中，传递的是 <code>_LightDirection</code> 、 <code>_LightPosition</code>，分别是方向光方向和 Punctual Light 的位置，用于计算光照方向；以及关键字 <code>_CASTING_PUNCTUAL_LIGHT_SHADOW</code> 用于判断什么类型的灯。</p>
<blockquote>
<p>我发现网上不同资料对于 Punctual Light 的定义不同，有些资料中 Punctual Light 包含 Directional Light，有些则不包含。我博客中不同的文章的 Punctual Light 的定义范围也是不同的，要根据上下文判断一下包不包含 Directional Light。</p>
</blockquote>
<p>而在阴影采样时偏移就相对容易一点，我们可以在计算阴影空间坐标时，对 positionWS 进行偏移：  </p>
<h4 id="Normal-Bias"><a href="#Normal-Bias" class="headerlink" title="Normal Bias"></a>Normal Bias</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io">鸟布</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io/2024/12/09/2024-12-09-CustomSRP2/">https://ybniaobu.github.io/2024/12/09/2024-12-09-CustomSRP2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ybniaobu.github.io" target="_blank">鸟布的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/unity/">unity</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/12/09/paBhbkD6Vd9CIsy.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src="/images/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/11/26/2024-11-26-CustomSRP1/" title="Unity Custom SRP 基础（一）"><img class="cover" src="https://s2.loli.net/2024/12/09/SGVnTxOM6BURAJI.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity Custom SRP 基础（一）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/15/2023-09-15-UnityShader1/" title="《Unity Shader入门精要》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2023/09/19/cDvdURBPhjwkOsY.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-15</div><div class="title">《Unity Shader入门精要》读书笔记（一）</div></div></a></div><div><a href="/2023/12/19/2023-12-19-UnityShader4/" title="《Unity Shader入门精要》读书笔记（四）"><img class="cover" src="https://s2.loli.net/2023/12/20/9Ah5ugiIpONK1cX.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-19</div><div class="title">《Unity Shader入门精要》读书笔记（四）</div></div></a></div><div><a href="/2023/10/13/2023-10-13-UnityShader2/" title="《Unity Shader入门精要》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2023/10/15/RZftaNSscWoLH1u.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-13</div><div class="title">《Unity Shader入门精要》读书笔记（二）</div></div></a></div><div><a href="/2023/11/22/2023-11-22-UnityShader3/" title="《Unity Shader入门精要》读书笔记（三）"><img class="cover" src="https://s2.loli.net/2023/11/23/L3ts4WnThMlDN9d.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-22</div><div class="title">《Unity Shader入门精要》读书笔记（三）</div></div></a></div><div><a href="/2023/12/30/2023-12-30-UnityShader5/" title="《Unity Shader入门精要》读书笔记（五）"><img class="cover" src="https://s2.loli.net/2023/12/30/hc2s7BS45l1wUdQ.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-30</div><div class="title">《Unity Shader入门精要》读书笔记（五）</div></div></a></div><div><a href="/2024/02/23/2024-02-23-URP%E5%9F%BA%E7%A1%80/" title="Unity URP 基础"><img class="cover" src="https://s2.loli.net/2024/02/18/pMAzYioaFZEkS8I.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-23</div><div class="title">Unity URP 基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/wechat%20avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鸟布</div><div class="author-info__description">教练，我想学技术</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://niaobu.notion.site/787824630ea6480e944c1ae5ae7f4792"><i class="fa-solid fa-book"></i><span>My Notion</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ybniaobu/ybniaobu.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:niaobubob@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为了蒂法！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.</span> <span class="toc-text">阴影技术知识补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.1.</span> <span class="toc-text">阴影的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E9%98%B4%E5%BD%B1"><span class="toc-number">1.2.</span> <span class="toc-text">平面阴影</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E4%BD%93%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">阴影体算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.4.</span> <span class="toc-text">阴影贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shadow-acne"><span class="toc-number">1.4.2.</span> <span class="toc-text">Shadow acne</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shadow-aliasing"><span class="toc-number">1.4.3.</span> <span class="toc-text">Shadow aliasing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E8%A7%86%E5%8F%98%E5%BD%A2-perspective-warping"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">透视变形 perspective warping</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E9%98%B4%E5%BD%B1-cascade-shadow"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">级联阴影 cascade shadow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PCF"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">PCF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PCSS"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">PCSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">过滤阴影贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Contact-shadow"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">Contact shadow</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.4.4.</span> <span class="toc-text">屏幕空间阴影贴图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E5%90%91%E5%85%89%E9%98%B4%E5%BD%B1"><span class="toc-number">2.</span> <span class="toc-text">方向光阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.1.</span> <span class="toc-text">阴影贴图设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cascade-Shadow-Maps-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">Cascade Shadow Maps 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E4%B8%AD%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">CPU 中具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPU-%E4%B8%AD%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">GPU 中具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shadow-Fade"><span class="toc-number">2.2.4.</span> <span class="toc-text">Shadow Fade</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E8%B4%A8%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">阴影质量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86-Shadow-acne"><span class="toc-number">2.3.1.</span> <span class="toc-text">处理 Shadow acne</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Depth-and-Slope-Bias"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">Depth and Slope Bias</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Normal-Bias"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">Normal Bias</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/09/2024-12-09-CustomSRP2/" title="Unity Custom SRP 基础（二）"><img src="https://s2.loli.net/2024/12/09/paBhbkD6Vd9CIsy.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（二）"/></a><div class="content"><a class="title" href="/2024/12/09/2024-12-09-CustomSRP2/" title="Unity Custom SRP 基础（二）">Unity Custom SRP 基础（二）</a><time datetime="2024-12-09T08:00:29.000Z" title="发表于 2024-12-09 16:00:29">2024-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/26/2024-11-26-CustomSRP1/" title="Unity Custom SRP 基础（一）"><img src="https://s2.loli.net/2024/12/09/SGVnTxOM6BURAJI.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（一）"/></a><div class="content"><a class="title" href="/2024/11/26/2024-11-26-CustomSRP1/" title="Unity Custom SRP 基础（一）">Unity Custom SRP 基础（一）</a><time datetime="2024-11-26T04:43:30.000Z" title="发表于 2024-11-26 12:43:30">2024-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/2024-10-22-BetterPBR1/" title="Custom Better PBR in Unity"><img src="https://s2.loli.net/2024/10/22/x6Xp3JjS4k5PO2W.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Custom Better PBR in Unity"/></a><div class="content"><a class="title" href="/2024/10/22/2024-10-22-BetterPBR1/" title="Custom Better PBR in Unity">Custom Better PBR in Unity</a><time datetime="2024-10-22T03:13:12.000Z" title="发表于 2024-10-22 11:13:12">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/16/2024-08-16-IBL_Basics2/" title="IBL 基于图像的光照（二）"><img src="https://s2.loli.net/2024/08/16/KQGyA6zfCW74dYw.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IBL 基于图像的光照（二）"/></a><div class="content"><a class="title" href="/2024/08/16/2024-08-16-IBL_Basics2/" title="IBL 基于图像的光照（二）">IBL 基于图像的光照（二）</a><time datetime="2024-08-16T04:43:39.000Z" title="发表于 2024-08-16 12:43:39">2024-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/09/2024-07-09-IBL_Basics1/" title="IBL 基于图像的光照（一）"><img src="https://s2.loli.net/2024/07/22/nD1y67NcRpQOHbS.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IBL 基于图像的光照（一）"/></a><div class="content"><a class="title" href="/2024/07/09/2024-07-09-IBL_Basics1/" title="IBL 基于图像的光照（一）">IBL 基于图像的光照（一）</a><time datetime="2024-07-09T07:25:54.000Z" title="发表于 2024-07-09 15:25:54">2024-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 鸟布</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Your time is limited, so don't waste it living someone else's life.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>