<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity URP 基础 | 鸟布的博客</title><meta name="author" content="鸟布"><meta name="copyright" content="鸟布"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="主要内容有 Unity SRP 介绍、URP 相关基础知识点、URP shader 代码的大致框架、URP 透明度测试和透明度混合、 GPU Instancing 以及光照和阴影。"><link rel="shortcut icon" href="https://s2.loli.net/2022/09/08/Ygib4lfw6z1khnr.png"><link rel="canonical" href="https://ybniaobu.github.io/2024/02/23/2024-02-23-URP%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 鸟布","link":"链接: ","source":"来源: 鸟布的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity URP 基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-07 22:10:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/wechat%20avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/black.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鸟布的博客"><span class="site-name">鸟布的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity URP 基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-23T06:03:56.000Z" title="发表于 2024-02-23 14:03:56">2024-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-07T14:10:17.752Z" title="更新于 2024-03-07 22:10:17">2024-03-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/unity/">unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/unity/unity-shader/">unity shader</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity URP 基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>之前的《Unity Shader入门精要》是以 Unity 内置渲染管线为基础的，以 Cg 语言为主，但当使用 URP 和 HDRP 时，使用的是 HLSL 语言；<br>本文介绍 URP 相关基础知识，主要关注 URP 的 Shader 代码基础框架，充当备忘录的功能。<br>本人写这篇文章的 Unity 版本为 2022.3.12f1，URP 版本为 14.0.9。<br>本文参考了 <a target="_blank" rel="noopener" href="https://catlikecoding.com/">https://catlikecoding.com/</a> 的 tutorials for Unity 的部分内容。</p>
</blockquote>
<h1 id="Unity-SRP"><a href="#Unity-SRP" class="headerlink" title="Unity SRP"></a>Unity SRP</h1><p><strong>SRP</strong>，<strong>Scriptable Render Pipeline</strong>，即<strong>可编程渲染管线</strong>。Unity 当前提供两个预先构建的 SRP： ①<strong>URP</strong>，<strong>Universal Render Pipeline</strong>，即<strong>通用渲染管线</strong>；②<strong>HDRP</strong>，<strong>High Definition Render Pipeline</strong>，即<strong>高清渲染管线</strong>。SRP 可以理解为是一个 API 层，允许使用 C# 脚本来调度和配置渲染命令。Unity 将这些命令传递给它的低级图形架构，后者随后将指令发送给图形 API。</p>
<p>①<strong>Universal Render Pipleline</strong> 前身为 Lightweight Render Pipeline，即 LWRP 轻量级渲染管线，专注于性能，它被设计为能够在任何平台上都能提供最好的性能，所以除非有特殊需求只能在 HDRP 或者 SRP 解决的，其他都应该选择 URP，不管是移动端、主机、PC 等，URP 都能提供高性能的渲染，目前 URP 能做的也非常多，它拥有很多 HDRP 相同的功能，但为了在所有平台达到更好的性能，其做了一定的缩减。2D 光照和阴影是 URP 独占的，所以如果需要做 2D 游戏，就选 URP。</p>
<p>②<strong>High Definition Render Pipleline</strong> 专注于高端图形渲染，针对高端硬件配置，像 PC、XBox 和 Playstation，其面向高逼真度的游戏、图形 demo 和建筑渲染、超写实效果，以及所需的最佳图形效果。同时针对高端图形处理时，它要比内置渲染器要快得多；但要想得到完成利用 HDRP 的完美表现能力，需要大量的贴图，漫反射贴图、高光贴图、金属贴图、平滑贴图、AO 贴图、法线贴图、凹凸贴图、高度贴图；HDRP 同时提供高级和丰富的光照功能，比如实时全局光照 RealTime GI ，能够模拟光线反射、体积光、能模拟光穿过空气中的粒子，还有光线跟踪。HDRP 提供一系列高端的 shader 特效，例如高度、细节和 parallax Maps，分别用于纹理的位移、细节和深度模拟，它还支持子面散射，用于模拟光线穿过很薄的物体，比如皮肤和衣物，它提供了高级的 shader，能够让你同时使用多个材质的属性，比如子面散射、彩虹色、各向异性和模糊参数化。</p>
<p>URP 和 HDRP 都可以使用 <strong>Shader Graph</strong> 来编写 Shader，同时都支持 Visual Effect Graph，但是手写 Shader 在性能方面有很大的优势，因此在项目中前期建议直接使用 Shader Graph 来编写 Shader，因为 Shader Graph 可视化更加便捷，在得到想要的效果后，在项目后期改成手写 Shader 来提高性能。</p>
<h2 id="SRP-和内置管线的不同"><a href="#SRP-和内置管线的不同" class="headerlink" title="SRP 和内置管线的不同"></a>SRP 和内置管线的不同</h2><p>在 SRP 中手写 Shader 仍然使用的是 Shader Lab，和内置渲染管线相比，结构并没有太大的变化，主要的几点不同如下：<br><strong>①</strong>使用 <strong>HLSL</strong> 而不是 Cg 语言，尽管这不是强制的，但是 HLSL 是官方推荐的。Cg 语言已经不再更新。官方的 URP 的自带的 Shader 都是 HLSL 编写的，URP Shader 代码中会调用 URP Shader Library 中的 Shader 代码（在名为 Universal RP 的 Packages 中）；<br><strong>②</strong>SubShader 的 Tags 中需要指定 <strong>RenderPipeline</strong>，例如：<code>&quot;RenderPipeline&quot; = &quot;UniversalPipeline&quot;</code>表示这是一个 URP 的 Shader；<br><strong>③</strong>Pass 的 Tags 中的 <strong>LightMode</strong> 和内置渲染管线不同，在内置管线中，LightMode 表示了这个 Pass 处于管线中处理光照的哪个步骤，例如 <code>ForwardBase</code>，<code>ForwardAdd</code>分别是前向流水线中的主光照 pass 和附加逐像素光照 pass。而 URP 中，我们经常使用的有 <code>UniversalForward</code>，<code>ShadowCaster</code>，<code>DepthNormalsOnly</code>，<code>DepthOnly</code>，<code>SRPDefaultUnlit</code> 等 pass；<br><strong>④</strong>为了兼容 <strong>SRP Batcher</strong>，Shader 需要采用一些特殊的写法。简单来说，就是对于 Properties 中的属性，需要放到特定的 <strong>CBuffer</strong> 中，这个 CBuffer 的名字为 <strong>UnityPerMaterial</strong>。另外对于 Unity 的内置属性，比如一些内置矩阵，要放到 <strong>UnityPerDraw</strong> 的 CBuffer 中；<br><strong>⑤</strong>如果要支持 <strong>GPU Instancing</strong>，Shader 代码还要使用另外的一组宏来修改，使得可以支持 GPU Instancing。</p>
<h2 id="Universal-Render-Pipeline-Asset"><a href="#Universal-Render-Pipeline-Asset" class="headerlink" title="Universal Render Pipeline Asset"></a>Universal Render Pipeline Asset</h2><p>每个 Unity URP 项目都需要一个 URP Asset 来配置 URP 相关设置。如果使用了 URP 模板创建了 URP 项目，Unity 会自动在 Settings 的文件夹中创建 URP Asset，并将其分配至 Project Settings 当中。URP Asset 是一个继承自 RenderPipelineAsset 的 scriptable object。一个项目可以拥有多个 URP Asset，可以进行切换以获取不同的效果。</p>
<blockquote>
<p>自定义渲染管线资产不在这里说明，日后有更高的需求详见官方文档和 <a target="_blank" rel="noopener" href="https://catlikecoding.com/unity/tutorials/custom-srp/custom-render-pipeline/">https://catlikecoding.com/unity/tutorials/custom-srp/custom-render-pipeline/</a></p>
</blockquote>
<h1 id="URP-基础语法"><a href="#URP-基础语法" class="headerlink" title="URP 基础语法"></a>URP 基础语法</h1><h2 id="常用的材质属性的特性"><a href="#常用的材质属性的特性" class="headerlink" title="常用的材质属性的特性"></a>常用的材质属性的特性</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[Gamma]</td>
<td style="text-align:left">当使用 Linear color space 时，材质的颜色属性提供的是 sRGB 色彩，但是当传递给 shader 时会被自动转换为线性值，为了线性插值计算更合理。但是对于材质的 Float 或 Vector 属性，不会自动进行色彩空间转换，因此对于一些跟色彩相关的 Float 或 Vector 属性，比如金属度，需要把它们指定到 sRGB 空间，此时可以添加 [Gamma] 特性。</td>
</tr>
<tr>
<td style="text-align:left">[HDR]</td>
<td style="text-align:left">指定颜色或纹理属性使用 HDR 值。</td>
</tr>
<tr>
<td style="text-align:left">[HideInInspector]</td>
<td style="text-align:left">在 Inspector 面板隐藏属性。</td>
</tr>
<tr>
<td style="text-align:left">[MainTexture]</td>
<td style="text-align:left">设置材质的主纹理，可以在脚本通过 <code>Material.mainTexture</code> 获取或设置。默认情况下，Unity 会把 _MainTex 作为主纹理，此时不用添加 [MainTexture] 特性。</td>
</tr>
<tr>
<td style="text-align:left">[MainColor]</td>
<td style="text-align:left">设置材质的主颜色，可以在脚本通过 <code>Material.color</code> 获取或设置。默认情况下，Unity 会把 _Color 作为主纹理，此时不用添加 [MainColor] 特性。</td>
</tr>
<tr>
<td style="text-align:left">[NoScaleOffset]</td>
<td style="text-align:left">让材质面板的纹理属性隐藏 tiling 和 offset 选项。</td>
</tr>
<tr>
<td style="text-align:left">[Normal]</td>
<td style="text-align:left">指明当前纹理属性希望得到一个 normal map，如果不是会报错。</td>
</tr>
<tr>
<td style="text-align:left">[PerRendererData]</td>
<td style="text-align:left">指明当前纹理属性作为 MaterialPropertyBlock 的 per-renderer data，即 per-instance data。材质面板会将添加该特性的属性显示为只读</td>
</tr>
<tr>
<td style="text-align:left">[Toggle(XXX)] <br> [ToggleOff(XXX)]</td>
<td style="text-align:left">括号及内部关键字名称可以没有，若有关键字名称，若材质面板勾选，Unity 会激活全为大写的该关键字。若没有关键字名称，若材质面板勾选，Unity 会激活全为大写的名称为材质属性名称的关键字。[ToggleOff] 和 [Toggle] 相反，若勾选，则不激活。</td>
</tr>
<tr>
<td style="text-align:left">[KeywordEnum(XXX, XXX, …)]</td>
<td style="text-align:left">关键字枚举，允许我们在下拉菜单中选择一个关键字启用，最多支持 9 个关键字</td>
</tr>
<tr>
<td style="text-align:left">[Enum(XXX)]</td>
<td style="text-align:left">为 float 属性提供下拉菜单，最多可指定 7 个名称。常规用法有：<code>[Enum(UnityEngine.Rendering.BlendOp)] _BlendOp (&quot;BlendOp&quot;, Float) = 0</code>，<br> <code>[Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (&quot;SrcBlend&quot;, Float) = 1</code>，<br> <code>[Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (&quot;DstBlend&quot;, Float) = 0</code>，<br> <code>[Enum(Off, 0, On, 1)] _ZWriteMode (&quot;ZWriteMode&quot;, float) = 1</code>，<br> <code>[Enum(UnityEngine.Rendering.CullMode)]_CullMode (&quot;CullMode&quot;, float) = 2</code>，<br> <code>[Enum(UnityEngine.Rendering.CompareFunction)]_ZTestMode (&quot;ZTestMode&quot;, Float) = 4</code>，<br> <code>[Enum(UnityEngine.Rendering.ColorWriteMask)]_ColorMask (&quot;ColorMask&quot;, Float) = 15</code>，<br> <code>[Enum(UnityEngine.Rendering.CompareFunction)]_StencilComp (&quot;Stencil Comparison&quot;, Float) = 8</code>，<br> <code>[Enum(UnityEngine.Rendering.StencilOp)] _StencilPass (&quot;Stencil Pass&quot;, Float) = 0</code>，<br> <code>[Enum(UnityEngine.Rendering.StencilOp)] _StencilFail (&quot;Stencil Fail&quot;, Float) = 0</code>，<br> <code>[Enum(UnityEngine.Rendering.StencilOp)] _StencilZFail (&quot;Stencil ZFail&quot;, Float) = 0</code></td>
</tr>
<tr>
<td style="text-align:left">[PowerSlider(3.0)]</td>
<td style="text-align:left">和 Range 属性一起使用，显示一个非线性响应的滑动条。意思就是，让 Range 滑杆更加方便调整细微的值。以 [PowerSlider(1.0)] 为分界，当值为 1.0 时，效果与 range 一致。当值 &lt; 1.0 时，值越大可调整的范围越大。当值 &gt; 1.0 时，值越小可调整的范围越大。可以更精细地在这些区间进行微调。</td>
</tr>
<tr>
<td style="text-align:left">[IntRange]</td>
<td style="text-align:left">显示一个适用于 Range 着色器属性的整数滑动条。</td>
</tr>
<tr>
<td style="text-align:left">[Space(XXX)]</td>
<td style="text-align:left">[Space] 在材质面板中增加空行，[Space(50)] 可以在后面添加数值增加更多空行。</td>
</tr>
<tr>
<td style="text-align:left">[Header(XXX)]</td>
<td style="text-align:left">在材质面板中显示标题。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="URP-支持的-HLSL-变量"><a href="#URP-支持的-HLSL-变量" class="headerlink" title="URP 支持的 HLSL 变量"></a>URP 支持的 HLSL 变量</h2><blockquote>
<p>URP 的 HLSL 和 HLSL 存在细微差别。想对 HLSL 了解更深可以查阅微软的文档：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl。">https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl。</a></p>
</blockquote>
<p>在 HLSL 中，有几种不同的变量类型，其中在 URP 中常用的是标量、向量和矩阵，还有一些特殊类型，比如纹理 Texture 类型、采样器 Sampler 类型。</p>
<p>常用的数值类型：<br>①中等精度 <strong>half</strong> ：16-bit floating point value，常用于方向、模型坐标、HDR 颜色等。部分平台可能不支持，会变为 float；<br>②高精度 <strong>float</strong> ：32-bit floating point value，常用于世界坐标、纹理坐标等；<br>③<strong>real</strong> ：Unity 定义的精度修饰符，在 URP/HDRP 中使用，如果是移动平台或者是 SWITCH 平台，real 用 half 来代替，否则用 float 来代替。它在 Core RP 下的 Common.hlsl 中定义，ShaderLibrary 中的许多常用数学函数使用此类型；<br>④<strong>fixed</strong>：HLSL 不支持。<br>⑤<strong>int</strong>：32-bit integer，部分平台和 GPU 不支持整数类型。</p>
<h2 id="ShaderLab-SubShader-tags"><a href="#ShaderLab-SubShader-tags" class="headerlink" title="ShaderLab SubShader tags"></a>ShaderLab SubShader tags</h2><p>SubShader 支持的 Tags：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">SubShader 标签名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">RenderPipeline</td>
<td style="text-align:left">指定渲染管线。</td>
</tr>
<tr>
<td style="text-align:left">Queue</td>
<td style="text-align:left">指明渲染队列，表示 shader 在渲染中的顺序，值越小越优先。Background：值为 1000，一般有与远处的背景及天空盒等；Geometry：值为 2000，不透明物体的渲染队列；AlphaTest：值为 2450，需要进行透明度测试的 shader 队列；Transparent：值为 3000，半透明物体渲染队列；Overlay：值为 4000，覆盖屏幕的渲染队列。</td>
</tr>
<tr>
<td style="text-align:left">RenderType</td>
<td style="text-align:left">对着色器进行分类，主要用于 shader 替换功能。内置的 RenderType 标签有 Opaque、Transparent、TransparentCutout、Background、Overlay、TreeOpaque、TreeTransparentCutout、TreeBillboard、Grass、GrassBillboard。</td>
</tr>
<tr>
<td style="text-align:left">DisableBatching</td>
<td style="text-align:left">指明 SubShader 是否使用批处理。</td>
</tr>
<tr>
<td style="text-align:left">ForceNoShadowCasting</td>
<td style="text-align:left">强制不投射阴影。</td>
</tr>
<tr>
<td style="text-align:left">IgnoreProjector</td>
<td style="text-align:left">指明是否受 Projectors 的影响，Projectors 是 Unity 的一个组件，用于创造一些视觉效果，比如在墙壁上投射涂鸦等等。</td>
</tr>
<tr>
<td style="text-align:left">PreviewType</td>
<td style="text-align:left">指明材质面板该如何预览材质，默认材质预览为球体，可以设置为 Sphere、Plane、Skybox</td>
</tr>
<tr>
<td style="text-align:left">CanUseSpriteAtlas</td>
<td style="text-align:left">为 false 时，将不会对进入图集的精灵图片进行绘制</td>
</tr>
<tr>
<td style="text-align:left">UniversalMaterialType</td>
<td style="text-align:left">仅延迟渲染中使用，标识 shader 类型，默认 Lit。可以设置为 Lit、Unlit、SimpleLit、ComplexLit，不知道有什么具体作用，没有找到说明，待补充。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="URP-ShaderLab-Pass-tags"><a href="#URP-ShaderLab-Pass-tags" class="headerlink" title="URP ShaderLab Pass tags"></a>URP ShaderLab Pass tags</h2><p>URP 不支持以下的 LightMode 标签：Always, ForwardAdd, PrepassBase, PrepassFinal, Vertex, VertexLMRGBM, VertexLM。</p>
<p>如果没有在 Pass 中指定 LightMode 标签，URP 会为该 Pass 默认使用 <code>SRPDefaultUnlit</code>。</p>
<p>下表给出了所有的 LightMode 标签：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">LightMode 标签名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">UniversalForward</td>
<td style="text-align:left">渲染物体并计算所有光线贡献，在前向渲染路径中使用</td>
</tr>
<tr>
<td style="text-align:left">UniversalGBuffer</td>
<td style="text-align:left">渲染 G 缓冲，延迟渲染路径中使用，照明在路径的后续的 Pass 中处理</td>
</tr>
<tr>
<td style="text-align:left">UniversalForwardOnly</td>
<td style="text-align:left">类似于 UniversalForward，计算光照，可以在前向渲染路径和延迟渲染路径中使用。如果在 URP 使用延迟渲染路径时某个通道必须使用前向渲染路径来渲染对象，请使用该标签</td>
</tr>
<tr>
<td style="text-align:left">DepthNormalsOnly</td>
<td style="text-align:left">与延迟渲染路径中的 UniversalForwardOnly 结合使用。在延迟渲染路径中，如果缺少具有 DepthNormalsOnly 标签值的通道，则 Unity 不会在网格周围生成环境光遮挡。</td>
</tr>
<tr>
<td style="text-align:left">Universal2D</td>
<td style="text-align:left">在 2D 渲染中使用该标签</td>
</tr>
<tr>
<td style="text-align:left">ShadowCaster</td>
<td style="text-align:left">将对象深度渲染到阴影贴图或深度纹理中</td>
</tr>
<tr>
<td style="text-align:left">DepthOnly</td>
<td style="text-align:left">从摄像机的角度将深度信息渲染到深度纹理中</td>
</tr>
<tr>
<td style="text-align:left">Meta</td>
<td style="text-align:left">Unity 仅在 Unity 编辑器中烘焙光照贴图时执行该通道。Unity 在构建播放器时会从着色器中剥离该通道</td>
</tr>
<tr>
<td style="text-align:left">SRPDefaultUnlit</td>
<td style="text-align:left">前向渲染路径和延迟渲染路径，Unity 使用该标签作为默认值，使用此标签绘制额外的 Pass，比如绘制对象轮廓线</td>
</tr>
<tr>
<td style="text-align:left">MotionVectors</td>
<td style="text-align:left">使用该标签添加 motion vector 支持</td>
</tr>
</tbody>
</table>
</div>
<h2 id="渲染状态设置命令"><a href="#渲染状态设置命令" class="headerlink" title="渲染状态设置命令"></a>渲染状态设置命令</h2><p>在 Pass 代码块中使用这些命令可为该 Pass 设置渲染状态，或者在 SubShader 代码块中使用这些命令可为该 SubShader 以及其中的所有 Pass 设置渲染状态：  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AlphaToMask</td>
<td style="text-align:left">设置 alpha-to-coverage 模式，该模式可以减少将多样本抗锯齿 (MSAA multisample anti-aliasing) 与使用 Alpha 测试的着色器（如植被着色器）一起使用时出现的过度锯齿。它根据片元着色器结果输出中的 Alpha 值按比例修改多样本覆盖率遮罩。此命令需要与 MSAA 一起使用</td>
</tr>
<tr>
<td style="text-align:left">Blend</td>
<td style="text-align:left">设置颜色混合类型（混合因子）</td>
</tr>
<tr>
<td style="text-align:left">BlendOp</td>
<td style="text-align:left">设置颜色混合操作的运算符</td>
</tr>
<tr>
<td style="text-align:left">ColorMask</td>
<td style="text-align:left">设置颜色通道写入遮罩，默认情况下，GPU 写入所有通道 RGBA，对于某些效果可能希望不修改某些通道，比如禁用颜色渲染来渲染无色阴影</td>
</tr>
<tr>
<td style="text-align:left">Conservative</td>
<td style="text-align:left">启用或禁用保守光栅化 conservative rasterization，保守光栅化是指 GPU 对被三角形部分覆盖的像素进行光栅化，即使只被三角形覆盖一部分。这在需要确定性时很有用，例如在执行遮挡剔除、GPU 上的碰撞检测或可见性检测时。保守光栅化意味着 GPU 在三角形边上生成更多的片元；这会导致更多片元着色器调用，从而导致 GPU 帧时间增加。</td>
</tr>
<tr>
<td style="text-align:left">Cull</td>
<td style="text-align:left">设置剔除模式，默认背面剔除</td>
</tr>
<tr>
<td style="text-align:left">Offset</td>
<td style="text-align:left">设置深度缓存的偏移量。调整深度偏差有时可以帮助避免不需要的视觉效果</td>
</tr>
<tr>
<td style="text-align:left">Stencil</td>
<td style="text-align:left">配置与 GPU 上的模板缓冲区相关的设置。模板缓冲区为帧缓冲区中的每个像素存储一个 8 位整数值。为给定像素执行片元着色器之前，GPU 可以将模板缓冲区中的当前值与给定参考值进行比较。这称为模板测试。如果模板测试通过，则 GPU 会执行深度测试。如果模板测试失败，则 GPU 会跳过对该像素的其余处理。这意味着可以使用模板缓冲区作为遮罩来告知 GPU 要绘制的像素以及要丢弃的像素。</td>
</tr>
<tr>
<td style="text-align:left">ZClip</td>
<td style="text-align:left">设置深度裁切模式，默认为 True，即裁切比近平面更近的片元和比远平面更远的片元。False 为钳制模式，比近平面更近的片元正好在近平面，而比远平面更远的片元正好在远平面</td>
</tr>
<tr>
<td style="text-align:left">ZTest</td>
<td style="text-align:left">设置深度测试的条件，深度测试可使具有 “Early-Z” 功能的 GPU 在管线早期拒绝几何体，并确保几何体的正确排序。默认值为 LEqual，即绘制位于现有几何体前面或相同距离的几何体，不绘制位于现有几何体后面的几何体。</td>
</tr>
<tr>
<td style="text-align:left">ZWrite</td>
<td style="text-align:left">设置深度缓冲写入状态</td>
</tr>
</tbody>
</table>
</div>
<h1 id="URP-shader-基础框架"><a href="#URP-shader-基础框架" class="headerlink" title="URP shader 基础框架"></a>URP shader 基础框架</h1><p>下面通过一个非常基础的 URP shader 代码介绍 URP shader 的基础框架：</p>
<blockquote>
<p>不要管代码块标注的 c，只是为了让代码高亮</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Example/URPUnlitShaderBasic&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        [MainColor] _BaseColor(<span class="string">&quot;Base Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        [MainTexture] _BaseMap(<span class="string">&quot;Base Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">//SubShader Tags 定义何时以及在何种条件下执行某个 SubShader 代码块或某个 Pass。</span></span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalPipeline&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">//声明 Pass 名称，方便调用与识别</span></span><br><span class="line">            Name <span class="string">&quot;ForwardUnlit&quot;</span> </span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Core.hlsl 文件包含常用的 HLSL 宏和函数的定义，还包含对其他 HLSL 文件（例如Common.hlsl、SpaceTransforms.hlsl 等）的 #include 引用。</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> Attributes &#123;</span><br><span class="line">                <span class="comment">//positionOS 即 position in object space</span></span><br><span class="line">                float4 positionOS   : POSITION;</span><br><span class="line">                float2 uv           : TEXCOORD0;</span><br><span class="line">                half3 normal        : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span> &#123;</span></span><br><span class="line">                <span class="comment">//positionHCS 即 position in homogeneous clip space 齐次裁剪空间</span></span><br><span class="line">                float4 positionHCS  : SV_POSITION;</span><br><span class="line">                float2 uv           : TEXCOORD0;</span><br><span class="line">                half3 normal        : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//材质单独声明，使用 DX 风格的新采样方法，下面两个宏都在 Core.hlsl 里面</span></span><br><span class="line">            <span class="comment">//此宏将 _BaseMap 声明为 Texture2D 对象。</span></span><br><span class="line">            TEXTURE2D(_BaseMap);</span><br><span class="line">            <span class="comment">//此宏声明采样器</span></span><br><span class="line">            SAMPLER(sampler_BaseMap);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//要使 Unity 着色器 SRP Batcher 兼容，请在名为 UnityPerMaterial 的单个 CBUFFER 代码块中声明与材质相关的所有属性。</span></span><br><span class="line">            CBUFFER_START(UnityPerMaterial)</span><br><span class="line">                half4 _BaseColor;</span><br><span class="line">                float4 _BaseMap_ST;</span><br><span class="line">            CBUFFER_END</span><br><span class="line"></span><br><span class="line">            Varyings <span class="title function_">vert</span><span class="params">(Attributes IN)</span> &#123;</span><br><span class="line">                Varyings OUT;</span><br><span class="line">                OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);</span><br><span class="line">                <span class="comment">//TRANSFORM_TEX 宏在 Macros.hlsl 定义，用于应用纹理偏移缩放</span></span><br><span class="line">                OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);</span><br><span class="line">                OUT.normal = TransformObjectToWorldNormal(IN.normal);</span><br><span class="line">                <span class="keyword">return</span> OUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            half4 <span class="title function_">frag</span><span class="params">(Varyings IN)</span> : SV_Target &#123;</span><br><span class="line">                <span class="comment">//SAMPLE_TEXTURE2D 宏用于纹理采样</span></span><br><span class="line">                half4 color = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);</span><br><span class="line">                color *= _BaseColor;</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="URP-Shader-目录结构"><a href="#URP-Shader-目录结构" class="headerlink" title="URP Shader 目录结构"></a>URP Shader 目录结构</h2><p>我们观察一下 URP 源码的目录结构（在 项目/Liabrary/PackageCache/<strong>com.unity.render-pipelines.universal</strong> 目录下面），可以看到 Shader 代码位于 Shader 目录以及 ShaderLibrary 目录中，其中 Shader 代码主要放在 Shader 目录，HLSL 文件主要放在 ShaderLibrary 目录中。在 Pass 中可以直接插入 HLSL 文件中的代码，下面会详细介绍。</p>
<p>另外，URP 的 Shader 还会引用 SRP Core 这个包中的 ShaderLibrary（在 项目/Liabrary/PackageCache/<strong>com.unity.render-pipelines.core</strong> 目录下面）。这个 SRP Core 提供了 URP/HDRP 共享的一些功能的实现，如果需要自定义一个 SRP，使用这个库也可以大大简化工作。其 ShaderLibrary 中包含了很多基础和核心 Shader 函数以及宏定义。</p>
<p>我们也可以采用官方的目录结构，将主要的 HLSL 的 Pass 代码放置在 ShaderLibrary 文件夹中，然后在 shader 代码中添加 <code>#include</code> 指令以及 HLSL 文件的相对地址来插入 HLSL 代码，如下：</p>
<pre><code>    HLSLPROGRAM
    #pragma vertex UnlitPassVertex
    #pragma fragment UnlitPassFragment
    #include &quot;UnlitPass.hlsl&quot;
    ENDHLSL
</code></pre><h2 id="include-指令保护"><a href="#include-指令保护" class="headerlink" title="include 指令保护"></a>include 指令保护</h2><p><code>#include</code> HLSL 文件和 using 命名空间不同，它直接在指令的位置插入整个文件的内容。有可能会 <code>#include</code> 同样的文件两次，从而导致编译错误，为了防止上述情况发生，可以在 HLSL 文件开头添加 include 指令保护：  </p>
<pre><code>    #ifndef CUSTOM_UNLIT_PASS_INCLUDED
    #define CUSTOM_UNLIT_PASS_INCLUDED
    #endif
</code></pre><p><code>#define</code> 指令理论上可以定义任意标识符 identifier。使用 <code>#ifndef</code> 指令来判断代码是否被定义，因为我们只想在没被定义的情况下插入代码。所有在 <code>#ifndef</code> 和 <code>#endif</code> 之间的代码块会被跳过并且不会被编译，如果该宏已经被定义的话。</p>
<p>我们可以将函数代码放在上述代码块之间，HLSL 文件的简易代码框架如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line">CBUFFER_START(UnityPerMaterial) <span class="comment">//见下面 Optimizing draw calls</span></span><br><span class="line">float4 _BaseColor;</span><br><span class="line">CBUFFER_END</span><br><span class="line"></span><br><span class="line">float4 <span class="title function_">UnlitPassVertex</span><span class="params">(float3 positionOS : POSITION)</span> : SV_POSITION &#123;</span><br><span class="line">    float3 positionWS = TransformObjectToWorld(positionOS.xyz);</span><br><span class="line">    <span class="keyword">return</span> TransformWorldToHClip(positionWS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 <span class="title function_">UnlitPassFragment</span> <span class="params">()</span> : SV_TARGET &#123;</span><br><span class="line">    <span class="keyword">return</span> _BaseColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Optimizing-draw-calls"><a href="#Optimizing-draw-calls" class="headerlink" title="Optimizing draw calls"></a>Optimizing draw calls</h2><blockquote>
<p>这里只是简单介绍一下，详见官方文档：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/2022.3/Documentation/Manual/optimizing-draw-calls.html">https://docs.unity3d.com/2022.3/Documentation/Manual/optimizing-draw-calls.html</a> ，本文重点关注 URP 代码，故下面主要关注对 shader 代码的影响。</p>
</blockquote>
<p>优化 draw call 主要有四个方法：<br>①<strong>Draw call batching</strong>：对于使用相同材质的物体，合并 mesh 从而减少 draw call 的一种方式，包括下面两种内置的 draw call batching 方式：<br>&emsp;&emsp; - <strong>Static batching</strong>：将静态物体合并为一个大网格；<br>&emsp;&emsp; - <strong>Dynamic batching</strong>：在运行时 Unity 自动把符合条件的多个模型网格合并为一个；<br>②<strong>SRP Batcher</strong>：对于使用相同 shader 的材质球，减少 CPU 在不同的 draw call 之间的准备工作；<br>③<strong>GPU instancing</strong>：对于使用同个材质的多个物体进行一次 draw call 的一种方式。</p>
<p>上述 4 个优化方法的<strong>优先级</strong>是：<strong>SRP Batcher and static batching &gt; GPU instancing &gt; Dynamic batching</strong>。Unity 只会使用优先级最高的方法，除了 SRP Batcher 和 static batching 可以同时使用。</p>
<h3 id="Dynamic-batching"><a href="#Dynamic-batching" class="headerlink" title="Dynamic batching"></a>Dynamic batching</h3><p>动态批处理是为老的低端设备而设计的。只有当动态批处理产生的 CPU 开销小于 Draw Call 的开销，动态批处理才具有优化性能的效果。而在如今的电子设备上，动态批处理产生的 CPU 开销反而有可能大于 DrawCall 的开销，影响性能。比如，对于 Apple Metal 来说，Draw Call 的开销非常低，所以动态批处理并不能提供性能。</p>
<p>动态批处理对 HDRP 不兼容，其他都兼容。</p>
<p>动态批处理是满足一定条件自动开启的，在运行时 Unity 自动把每一帧画面里符合条件的多个模型网格合并为一个，在 CPU 中将所有顶点转换到世界空间。</p>
<p>其他可能需了解的内容的关键词如下，详见官方文档：<br>①MaterialPropertyBlock：一种使用相同材质但是不同材质属性的方法，不影响批处理，但是不与 SRP Batcher 兼容；<br>②如果物体使用相同材质但是不同的纹理贴图，可以使用纹理图集 Texture atlases 技术将不同纹理合并为一个更大的纹理，从而使用一个材质；<br>③通过 C# 脚本修改材质，请使用 Renderer.sharedMaterial 以保持批处理，Renderer.material 创建材质的复制；<br>④可以使用 Mesh.CombineMeshes 手动合并网格；<br>⑤对于不同材质的相同的 shadows caster pass，Unity 可以使用动态批处理。</p>
<h3 id="Static-batching"><a href="#Static-batching" class="headerlink" title="Static batching"></a>Static batching</h3><p>静态批处理将静态物体合并为一个大网格，只使用一个 draw call 画出所有合并的网格。静态批处理比动态批处理效率更高，因为它不需要在 CPU 上转换顶点，但是需要占据更多的 CPU 内存。这段话虽然是官方文档说法，但是不太准确，下面更加准确：</p>
<p>静态批处理不一定减少 DrawCall，但是会让 CPU 在“设置渲染状态-提交 Draw Call”上更高效；Unity 将静态物体合并为一个(或多个)大网格，这个(或这些)大网格以 vertex buffers 和 index buffers 的形式存储在 GPU 上；Unity 按顺序绘制场景中的物体时，如果两个物体的数据属于同一块 buffer，且在 vertex buffer 和 index buffer 上连续，那么这两个物体仅产生 1 次 DrawCall；如果它们不连续，那么将产生 2 次 DrawCall(specify different regions of this buffer)；但是由于它们属于同一块 buffer，因此这 2 次 DrawCall 之间的 GPU 状态不发生改变，它们构成 1 次 StaticBatch；虽然没有降低 DrawCall 次数，但是避免了重复的 “buffer binding”。</p>
<p>静态批处理对内置管线、URP、HDRP 和自定义 SRP 都兼容。</p>
<h3 id="SRP-Batcher"><a href="#SRP-Batcher" class="headerlink" title="SRP Batcher"></a>SRP Batcher</h3><p>SRP Batcher 适用于使用不同材质的物体，但这些材质使用相同的 Shader（确切地说是 Shader Variant）。</p>
<p>顾名思义 SRP 才支持。在 URP 项目中，这一项是默认开启的，可以找到 URP Asset，可以看到 SRP Batcher 的选项是默认开启的，默认情况下该选项是被隐藏的，可以在 Edit -&gt; Preferences -&gt; Core Render Pipeline 中把 Visibility 改为 All Visible。</p>
<p>被渲染的物体需要满足兼容性：<br>①被渲染的物体必须是 mesh 或 skinned mesh，不可以是 particle；<br>②被渲染的物体不能使用 MaterialPropertyBlock 修改属性，MaterialPropertyBlock 不支持 SRP Batcher；<br>③Shader 需要支持 SRP Batcher，见下面。</p>
<p>要想 Shader 使用 SRP Batcher 必须满足 SRP Batcher compatibility 条件：<br>①在一个名为 <strong>UnityPerDraw</strong> 的 <strong>CBuffer</strong> (constant buffer) 中声明所有内置属性，比如 unity_ObjectToWorld；<br>②在一个名为 <strong>UnityPerMaterial</strong> 的 <strong>CBuffer</strong> (constant buffer) 中声明所有材质属性。<br>可以在 Shader 的 Inspector 面板中，看到 SRP Batcher 的兼容性状态。</p>
<blockquote>
<p>UnityPerDraw 这部分内容 URP 的 Core.hlsl 都帮我们做好了，若引入了 Core.hlsl 理论上不用关心这部分内容，只需要在自己的 Shader 里关心 UnityPerMaterial 这部分就行。若要编写自己的 Custom SRP，则需要自己加入 UnityPerDraw，即对一些内置的 Unity 自动更新的矩阵进行定义（比如 unity_ObjectToWorld，这些矩阵每次 draw call 都会被 GPU 设置），可以参考 URP 的 Core.hlsl -&gt; Input.hlsl -&gt; UnityInput.hlsl。</p>
</blockquote>
<pre><code>CBUFFER_START(UnityPerDraw)
float4x4 unity_ObjectToWorld;
float4x4 unity_WorldToObject;
float4 unity_LODFade;
real4 unity_WorldTransformParams;
CBUFFER_END

CBUFFER_START(UnityPerMaterial)
float4 _BaseColor;
CBUFFER_END
</code></pre><p>SRP Batcher 主要减少不同 draw call 之间的渲染状态转换。原本，CPU 每次提交 Draw Call 前都要 Set up Cbuffer - Upload Cbuffer，但是在 SRP Batcher 里，所有材质球在显存里占有固定的 CBuffer，如果材质球的内容不发生改变，CPU 就不需要 Set Up - Upload，从而降低了 CPU 渲染时间。</p>
<h3 id="GPU-instancing"><a href="#GPU-instancing" class="headerlink" title="GPU instancing"></a>GPU instancing</h3><p>GPU instancing 适用于处理大量相同物体（同一 Mesh 和同一 Material），比如建筑物/树/草等重复出现的物体。注意 GPU instancing 和 SRP Batcher 不兼容。若要使用 GPU instancing 需要移除 SRP Batcher 兼容性，否则根据优先级，Unity 会自动选择 SRP Batcher。</p>
<p>要想使用 GPU instancing 需要满足以下条件：<br>①材质的 Shader 需要支持 GPU instancing，见后面；<br>②网格必须有一个 MeshRenderer 组件，或是由 Graphics.DrawMesh 产生，或是由 Graphics.DrawMeshInstanced、Graphics.DrawMeshIndirect 产生。不支持 SkinnedMeshRenderer；  </p>
<p>GPU instancing 允许实例物体具有不同的 Transform，但如果想要创建更多的变体，比如不同颜色的变体，你需要修改 shader 添加 pre-instance 属性。自定义的 shader 没有 pre-instance 的数据，需要使用 <code>UNITY_SETUP_INSTANCE_ID</code> 添加一个实例 ID，表面着色器会自动创建实例 ID，然后在脚本中通过 MaterialPropertyBlock 修改实例的颜色。</p>
<p>创建支持 GPU instancing 的 Shader 的步骤如下：<br><strong>①</strong>第一步在 shader 的顶点和片元着色器的指令前添加 <code>#pragma multi_compile_instancing</code></p>
<pre><code>    #pragma multi_compile_instancing
    #pragma vertex UnlitPassVertex
    #pragma fragment UnlitPassFragment
</code></pre><p>这会让 Unity 生成两个 shader 变体，一个支持 GPU instancing 一个不支持，我们可以在材质的 inspector 面板中选择是否 <strong>Enable GPU instancing</strong> 让材质使用相应的 shader。</p>
<p><strong>②</strong>支持 GPU instancing 需要引入 core shader library 的 UnityInstancing.hlsl 文件，但是若引入 URP 的 Core.hlsl，则不需要再重复引入了，因为 Core.hlsl 都帮我们处理好了，可以在 Core.hlsl 引入的 Input.hlsl 最下面看到以下代码：  </p>
<pre><code>    #define UNITY_MATRIX_M unity_ObjectToWorld
    ...

    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/UnityInput.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl&quot;

    ...

    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl&quot;
</code></pre><p><strong>③</strong>UnityInstancing.hlsl 的工作包括对矩阵相关宏进行重定义使其可以被替换为 instanced data arrays。但是为了让其工作，还需知道当前渲染物体的索引，因为不同实例的变换矩阵不同，这些索引需要在顶点着色器的输入结构中被提供，我们只需将 <code>UNITY_VERTEX_INPUT_INSTANCE_ID</code> 放在 Attributes 结构中，如下：  </p>
<pre><code>    struct Attributes &#123;
        float3 positionOS : POSITION;
        UNITY_VERTEX_INPUT_INSTANCE_ID
    &#125;;
</code></pre><p><strong>④</strong>然后在定制着色器函数的开头添加 <code>UNITY_SETUP_INSTANCE_ID(input);</code>，这会提取 input 中的索引并把它存储为一个全局静态变量，让其他 instancing 的宏使用它，如下：  </p>
<pre><code>    float4 UnlitPassVertex (Attributes input) : SV_POSITION &#123;
        UNITY_SETUP_INSTANCE_ID(input);
        float3 positionWS = TransformObjectToWorld(input.positionOS);
        return TransformWorldToHClip(positionWS);
    &#125;
</code></pre><p><strong>⑤</strong>为了取消 SRP batcher 兼容性，我们还需要修改 CBUFFER，替换为 <code>UNITY_INSTANCING_BUFFER_START</code> 和 <code>UNITY_INSTANCING_BUFFER_END</code>，从而支持  per-instance material data。还要替换属性声明，比如 _BaseColor 替换为 <code>UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)</code> ：   </p>
<pre><code>    UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)
        UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)
    UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)
</code></pre><p><strong>⑥</strong>接下来是为了让片元着色器也能获取到实例索引，我们需要在顶点着色器的输出结构添加 <code>UNITY_VERTEX_INPUT_INSTANCE_ID</code>，并且在顶点着色器中使用 <code>UNITY_TRANSFER_INSTANCE_ID(input, output);</code> 来复制索引：  </p>
<pre><code>    struct Varyings &#123;
        float4 positionCS : SV_POSITION;
        UNITY_VERTEX_INPUT_INSTANCE_ID
    &#125;;

    Varyings UnlitPassVertex (Attributes input) &#123;
        Varyings output;
        UNITY_SETUP_INSTANCE_ID(input);
        UNITY_TRANSFER_INSTANCE_ID(input, output);
        float3 positionWS = TransformObjectToWorld(input.positionOS);
        output.positionCS = TransformWorldToHClip(positionWS);
        return output;
    &#125;
</code></pre><p><strong>⑦</strong>最后，在片元着色器中使用 <code>UNITY_SETUP_INSTANCE_ID(input);</code> 让索引可用。材质的属性现在需要通过 <code>UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor);</code> 获取：  </p>
<pre><code>    float4 UnlitPassFragment (Varyings input) : SV_TARGET &#123;
        UNITY_SETUP_INSTANCE_ID(input);
        return UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor);
    &#125;
</code></pre><h1 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h1><h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>首先在 SubShader 的 Tags 里把渲染队列设为 Transparent：<code>&quot;Queue&quot; = &quot;Transparent&quot;</code>。可以在材质添加 _SrcBlend 和 _DstBlend 属性，以及深度写入 Zwrite 的开关属性，如下：  </p>
<pre><code>    Properties &#123;
        _BaseColor(&quot;Color&quot;, Color) = (1.0, 1.0, 1.0, 1.0)
        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (&quot;Src Blend&quot;, Float) = 1
        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (&quot;Dst Blend&quot;, Float) = 0
        [Enum(Off, 0, On, 1)] _ZWrite (&quot;Z Write&quot;, Float) = 1
    &#125;
</code></pre><p><code>[Enum(UnityEngine.Rendering.BlendMode)]</code> 特性可以让我们在材质面板中选择混合模式，不透明的 _SrcBlend 为 1，_DstBlend 为 0；一般透明度混合，_SrcBlend 为 ScrAlpha，_DstBlend 为 OneMinusSrcAlpha。详见 Unity Shader 入门精要。</p>
<p>然后在 Pass 中添加混合命令，以及深度写入开关命令：  </p>
<pre><code>    Blend [_SrcBlend] [_DstBlend]
    ZWrite [_ZWrite]
</code></pre><h2 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h2><p>添加 _Cutoff 阈值属性：  </p>
<pre><code>    _Cutoff (&quot;Alpha Cutoff&quot;, Range(0.0, 1.0)) = 0.5
</code></pre><p>别忘了在 CBuffer 里声明属性。接下来在片元着色器用 Clip 函数进行裁切：  </p>
<pre><code>    clip(_BaseColor.a - _Cutoff)
</code></pre><p>我们可以在材质属性中添加 <code>Toggle</code> 特性来控制一个 _CLIPPING 关键字，该特性让我们可以选择是否开启透明度测试：  </p>
<pre><code>    [Toggle(_CLIPPING)] _Clipping (&quot;Alpha Clipping&quot;, Float) = 0
</code></pre><p>如果在材质面板中开启了透明度测试，就会自动添加 _CLIPPING 关键字到材质的激活的关键字表里，关闭就去除。我们可以根据关键字是否被定义，来告诉 Unity 编写不同的 shader。首先我们需要在 Pass 中添加 <code>#pragma shader_feature _CLIPPING</code> 指令：  </p>
<pre><code>    #pragma shader_feature _CLIPPING
</code></pre><p>这样 Unity 就可以根据 _CLIPPING 是否被定义来编译 shader 代码，然后修改 Clip 函数：  </p>
<pre><code>    #if defined(_CLIPPING)
        clip(_BaseColor.a -  _Cutoff);
    #endif
</code></pre><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>①新建一个名为 Transparency.shader 的 shader 文件，代码如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/Transparency&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [Header(Base)] <span class="comment">//在材质面板中插入标题</span></span><br><span class="line">        [Space(<span class="number">12</span>)] <span class="comment">//在材质面板中插入多行空行</span></span><br><span class="line">        _BaseColor(<span class="string">&quot;Base Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _BaseMap(<span class="string">&quot;Base Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        [Header(Transparency)] <span class="comment">//在材质面板中插入标题</span></span><br><span class="line">        [Space(<span class="number">12</span>)] <span class="comment">//在材质面板中插入多行空行</span></span><br><span class="line">        [Toggle(_CLIPPING)] _Clipping (<span class="string">&quot;Alpha Clipping&quot;</span>, Float) = <span class="number">0</span> <span class="comment">//开关透明度测试</span></span><br><span class="line">        _Cutoff(<span class="string">&quot;Alpha CutOff&quot;</span>, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.5</span> <span class="comment">//裁切阈值</span></span><br><span class="line">        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (<span class="string">&quot;Src Blend&quot;</span>, Float) = <span class="number">1</span> <span class="comment">//混合因子</span></span><br><span class="line">        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (<span class="string">&quot;Dst Blend&quot;</span>, Float) = <span class="number">0</span> <span class="comment">//混合因子</span></span><br><span class="line">        [Enum(Off, <span class="number">0</span>, On, <span class="number">1</span>)] _ZWrite (<span class="string">&quot;Z Write&quot;</span>, Float) = <span class="number">1</span> <span class="comment">//开关深度写入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalPipeline&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span> &#125; <span class="comment">//渲染队列为 Transparent</span></span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;TransparencyForwardUnlit&quot;</span> <span class="comment">//Pass 命名</span></span><br><span class="line">            </span><br><span class="line">            Blend [_SrcBlend] [_DstBlend] <span class="comment">//混合命令</span></span><br><span class="line">            ZWrite [_ZWrite] <span class="comment">//深度写入开关</span></span><br><span class="line">            </span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> shader_feature _CLIPPING <span class="comment">//控制 shader 变体</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Assets/ShaderLibrary/TransparencyPass.hlsl&quot;</span> <span class="comment">//引入 HLSL 文件，见下面</span></span></span><br><span class="line">            </span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②在 ShaderLibrary 创建名为 TransparencyPass.hlsl 的 HLSL 文件，代码如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionOS   : POSITION;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionHCS  : SV_POSITION;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEXTURE2D(_BaseMap);</span><br><span class="line">SAMPLER(sampler_BaseMap);</span><br><span class="line"></span><br><span class="line">CBUFFER_START(UnityPerMaterial)</span><br><span class="line">half4 _BaseColor;</span><br><span class="line">float4 _BaseMap_ST;  <span class="comment">//别忘了这个</span></span><br><span class="line"><span class="type">float</span> _Cutoff;</span><br><span class="line">CBUFFER_END</span><br><span class="line"></span><br><span class="line">Varyings <span class="title function_">vert</span><span class="params">(Attributes IN)</span> &#123;</span><br><span class="line">    Varyings OUT;</span><br><span class="line">    OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);</span><br><span class="line">    OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);</span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 <span class="title function_">frag</span><span class="params">(Varyings IN)</span> : SV_Target &#123;</span><br><span class="line">    half4 color = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv); <span class="comment">//纹理采样</span></span><br><span class="line">    color *= _BaseColor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(_CLIPPING)</span></span><br><span class="line">        clip(color.r -  _Cutoff); <span class="comment">//这里选择 r 是因为希望根据纹理的颜色来裁切</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这样就得到了一个包含了透明度混合和透明度测试的 Shader，材质面板如下图：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/02/24/fFWhj2K1R7vkYCL.jpg" width = "60%" height = "60%" alt="图1 - 包含透明度混合和透明度测试的材质"/>
</div>

<p>我选择的是一张<strong>高斯噪声纹理 Gaussian Noise</strong>，我让纹理颜色与基础颜色相乘后若小于 0.85 则被裁切掉，透明度混合是基础的 ScrAlpha 和 OneMinusScrAlpha 即根据 Alpha 值混合，关闭深度写入防止渲染错误，效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/02/24/GFzAeuNrxDbgOyo.png" width = "70%" height = "70%" alt="图2 - 透明度混合和透明度测试的效果"/>
</div>

<h1 id="GPU-instancing-实践"><a href="#GPU-instancing-实践" class="headerlink" title="GPU instancing 实践"></a>GPU instancing 实践</h1><p>接下来根据上面的实践的 shader，改造为使用 GPU instancing 的 shader。TransparencyGPUInstancing.shader 的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/TransparencyGPUInstaning&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [Header(Base)]</span><br><span class="line">        [Space(<span class="number">12</span>)]</span><br><span class="line">        _BaseColor(<span class="string">&quot;Base Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _BaseMap(<span class="string">&quot;Base Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        [Header(Transparency)]</span><br><span class="line">        [Space(<span class="number">12</span>)]</span><br><span class="line">        [Toggle(_CLIPPING)] _Clipping (<span class="string">&quot;Alpha Clipping&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">        _Cutoff(<span class="string">&quot;Alpha CutOff&quot;</span>, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.5</span></span><br><span class="line">        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (<span class="string">&quot;Src Blend&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (<span class="string">&quot;Dst Blend&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">        [Enum(Off, <span class="number">0</span>, On, <span class="number">1</span>)] _ZWrite (<span class="string">&quot;Z Write&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalPipeline&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;TransparencyGPUInstaningForwardUnlit&quot;</span></span><br><span class="line">            </span><br><span class="line">            Blend [_SrcBlend] [_DstBlend]</span><br><span class="line">            ZWrite [_ZWrite]</span><br><span class="line">            </span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> shader_feature _CLIPPING</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_instancing <span class="comment">//生成支持或不支持 GPU instancing 的 shader 变体</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../ShaderLibrary/TransparencyGPUInstaningPass.hlsl&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述 Shader 中引入的 TransparencyGPUInstaningPass.hlsl 代码如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入 Core.hlsl 了就不需要重复引入 UnityInstancing.hlsl 了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionOS   : POSITION;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID <span class="comment">//为顶点着色器的输入输出结构定义 instance ID</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionHCS  : SV_POSITION;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID <span class="comment">//使用这个是为了在片元着色器获取 instanced 属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEXTURE2D(_BaseMap);</span><br><span class="line">SAMPLER(sampler_BaseMap);</span><br><span class="line"></span><br><span class="line">UNITY_INSTANCING_BUFFER_START(UnityPerMaterial) <span class="comment">//声明 per-instance 的 CBuffer</span></span><br><span class="line">    UNITY_DEFINE_INSTANCED_PROP(half4, _BaseColor) <span class="comment">//定义 per-instance 的属性</span></span><br><span class="line">    UNITY_DEFINE_INSTANCED_PROP(float4, _BaseMap_ST)</span><br><span class="line">    UNITY_DEFINE_INSTANCED_PROP(<span class="type">float</span>, _Cutoff)</span><br><span class="line">UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)</span><br><span class="line"></span><br><span class="line">Varyings <span class="title function_">vert</span><span class="params">(Attributes IN)</span> &#123;</span><br><span class="line">    Varyings OUT;</span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(IN); <span class="comment">//允许着色器函数获取 instance ID</span></span><br><span class="line">    UNITY_TRANSFER_INSTANCE_ID(IN, OUT); <span class="comment">//从输入结构复制 instance ID 到输出结构</span></span><br><span class="line">    OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);</span><br><span class="line">    float4 baseST = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseMap_ST); <span class="comment">//获取 per-instance 属性</span></span><br><span class="line">    OUT.uv = IN.uv * baseST.xy + baseST.zw;</span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 <span class="title function_">frag</span><span class="params">(Varyings IN)</span> : SV_Target &#123;</span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(IN); <span class="comment">//允许着色器函数获取 instance ID</span></span><br><span class="line">    half4 mapColor = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);</span><br><span class="line">    half4 baseColor = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor); <span class="comment">//获取 per-instance 属性</span></span><br><span class="line">    half4 color = half4(mapColor.rgb * baseColor.rgb, baseColor.a);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(_CLIPPING)</span></span><br><span class="line">    clip(mapColor.r -  UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Cutoff)); <span class="comment">//获取 per-instance 属性</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这样子材质部分就准备好了，接下来为了方便生成大量的物体，并生成不同的颜色，使用了下面的脚本代码（MeshBall.cs）：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MeshBall</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> baseColorId = Shader.PropertyToID(<span class="string">&quot;_BaseColor&quot;</span>); <span class="comment">//找到 _BaseColor 材质属性的 ID，每个 shader 属性都有个独特的数字 ID，并在游戏中保持不变。</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Mesh mesh; <span class="comment">//要生成的 mesh</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Material material; <span class="comment">//要生成的 mesh 的材质</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了生成 1023 个实例，我们需要告诉 Unity 它们的变换矩阵和颜色</span></span><br><span class="line">    <span class="keyword">private</span> Matrix4x4[] matrices = <span class="keyword">new</span> Matrix4x4[<span class="number">1023</span>];</span><br><span class="line">    <span class="keyword">private</span> Vector4[] baseColors = <span class="keyword">new</span> Vector4[<span class="number">1023</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//MaterialPropertyBlock 适用于需要画出使用相同材质但不同材质属性的多个物体，传递给 Graphics.RenderMesh 或 Renderer.SetPropertyBlock 时会被复制，所以创建一个 block 一直复用最佳。我们使用它来传递颜色数组。</span></span><br><span class="line">    <span class="keyword">private</span> MaterialPropertyBlock block;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; matrices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用 Matrix4x4.TRS 创建了一个在半径十米的球内的随机位置的，无旋转和缩放的变换矩阵</span></span><br><span class="line">            matrices[i] = Matrix4x4.TRS(Random.insideUnitSphere * <span class="number">10f</span>, Quaternion.identity, Vector3.one ); </span><br><span class="line">            <span class="comment">//随机颜色</span></span><br><span class="line">            baseColors[i] = <span class="keyword">new</span> Vector4(Random.<span class="keyword">value</span>, Random.<span class="keyword">value</span>, Random.<span class="keyword">value</span>, Random.<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (block == <span class="literal">null</span>) &#123;</span><br><span class="line">            block = <span class="keyword">new</span> MaterialPropertyBlock();</span><br><span class="line">            block.SetVectorArray(baseColorId, baseColors); <span class="comment">//设置颜色到 block</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//画出使用 GPU Instancing 的大量相同 mesh，并赋予材质、变换矩阵、数量以及材质属性块</span></span><br><span class="line">        Graphics.DrawMeshInstanced(mesh, <span class="number">0</span>, material, matrices, <span class="number">1023</span>, block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把该代码赋给任意空物体上，如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/02/25/FXb9O6YrP34jem7.jpg" width = "70%" height = "70%" alt="图3 - 附上 mesh 和材质后的 MeshBall.cs"/>
</div>

<p>在材质上别忘了开启 GPU Instancing：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/02/25/btBDClwi64aYVq7.jpg" width = "70%" height = "70%" alt="图4 - 勾选 Enable GPU Instancing"/>
</div>

<p>运行游戏效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2024/02/25/4PqBzvnHjCu2pNO.png" width = "90%" height = "90%" alt="图5 - 1023 个透明球体"/>
</div>

<div  align="center">  
<img src="https://s2.loli.net/2024/02/25/evZMxzK3yJQbm24.jpg" width = "50%" height = "50%" alt="图6 - 画这些透明物体只使用了 3 个 draw call"/>
</div>


<h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1><h2 id="URP-光照机制"><a href="#URP-光照机制" class="headerlink" title="URP 光照机制"></a>URP 光照机制</h2><p>在 URP 中，<strong>主光源 Main Light</strong> 和<strong>附加光源 Additional Lights</strong> 模式替代了之前内置渲染管线的 Important 和 Not Important 的光源。我们可以在 Universal Render Pipeline Asset -&gt; Lighting 里看到 Main Light 和 Additional Lights 的设置。</p>
<p>URP 的默认渲染路径为前向渲染路径 Forward Rendering Path，可以在 Universal Renderer Data （也在 Settings 文件夹）里修改渲染路径，支持<strong>前向渲染路径 Forward Rendering Path</strong>、<strong>前向+ 渲染路径 Forward+ Rendering Path</strong>、<strong>延迟渲染路径 Deferred Rendering Path</strong>。</p>
<p>前向渲染路径默认每个物体最多支持 9 个实时光照，其中包括 1 个主光源（默认为最亮的平行光）、8 个额外的光源，其中额外的光源受到渲染管线资产里的 Per Object Limit 的限制。这些光源默认都是逐像素光源，当然也可以在渲染管线资产里设置。而 Forward+ 和 Deferred 渲染路径不受 Per Object Limit 的限制，即理论上可以支持无限数量的光照，但是受到 per-Camera limit 的限制，per-Camera limit 根据平台不同而不同。</p>
<p>在 URP 中主光源和附加光源都可以在一个 Pass 中完成，即 <code>Tags &#123;&quot;LightMode&quot; = &quot;UniversalForward&quot;&#125;</code>，而不像在内置渲染管线中，需要使用多个 Pass。</p>
<h2 id="主光源处理"><a href="#主光源处理" class="headerlink" title="主光源处理"></a>主光源处理</h2><p>光照渲染的本质就是，让 Shader 拿到光照的数据，根据光照数据来计算片元的颜色，最后输出结果。URP 渲染管线中 Unity 会通过 CPU 把光源数据传递给 GPU，Unity 把这些工作都封装好了，我们只要在我们的 Shader 中获取 URP 内置的光照变量即可。</p>
<p>为了获取到光照变量，使用一些内置的光照和阴影（阴影后面讲）函数，我们需要在 Pass 中引入 URP 的 Lighting.hlsl 文件：  </p>
<pre><code>    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;
    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot; //包含了光照和阴影相关变量和函数
</code></pre><p>打开 Lighting.hlsl 引入的 RealtimeLights.hlsl 文件，我们可以看到光照变量的结构体：  </p>
<pre><code>    struct Light
    &#123;
        half3   direction;
        half3   color;
        float   distanceAttenuation;
        half    shadowAttenuation;
        uint    layerMask;
    &#125;;
</code></pre><p>以及一个获取光照变量的重要函数 <code>GetMainLight()</code>：  </p>
<pre><code>    Light GetMainLight()
    &#123;
        Light light;
        light.direction = half3(_MainLightPosition.xyz);
    #if USE_FORWARD_PLUS
    #if defined(LIGHTMAP_ON) &amp;&amp; defined(LIGHTMAP_SHADOW_MIXING)
        light.distanceAttenuation = _MainLightColor.a;
    #else
        light.distanceAttenuation = 1.0;
    #endif
    #else
        light.distanceAttenuation = unity_LightData.z; // unity_LightData.z is 1 when not culled by the culling mask, otherwise 0.
    #endif
        light.shadowAttenuation = 1.0;
        light.color = _MainLightColor.rgb;

        light.layerMask = _MainLightLayerMask;

        return light;
    &#125;
</code></pre><p>所以要渲染主光源，可以在自己的 Shader 里声明 Light 结构体然后使用 <code>GetMainLight()</code> 获取光照变量。</p>
<hr>
<p>接下来是实践内容，制作一个漫反射为 Lambert，高光为 Blinn-Phong 的简单光照 Shader。<br>①新建一个名为 LambertBlinnPhongLit.shader 的 Shader 文件：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shader <span class="string">&quot;Custom/LambertBlinnPhongLit&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [Header(Base Color)] [Space(<span class="number">10</span>)]</span><br><span class="line">        [MainColor] _BaseColor (<span class="string">&quot;Base Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        [MainTexture] _BaseMap (<span class="string">&quot;Base Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        [Header(Specular)] [Space(<span class="number">10</span>)]</span><br><span class="line">        _Gloss(<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">512.0</span>)) = <span class="number">10</span></span><br><span class="line">        _SpecColor(<span class="string">&quot;Specular Color&quot;</span>, Color) = (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> </span><br><span class="line">            <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalPipeline&quot;</span> </span><br><span class="line">            <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Geometry&quot;</span></span><br><span class="line">            <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;True&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;LambertBlinnPhongForwardLit&quot;</span></span><br><span class="line">            </span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;UniversalForward&quot;</span> &#125; <span class="comment">//必须写上这个</span></span><br><span class="line">            </span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex LambertBlinnPhongVert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment LambertBlinnPhongFrag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Assets/ShaderLibrary/LambertBlinnPhongLitPass.hlsl&quot;</span></span></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>② LambertBlinnPhongLitPass.hlsl 的代码如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #pragma once 和 #ifndef 都是用于避免头文件被重复包含的预处理指令。</span></span><br><span class="line"><span class="comment">// 编译器在读到 #pragma once 行时就略过这个文件的解析，这样可以提高预处理的速度。</span></span><br><span class="line"><span class="comment">// 但是 #pragma once 不是标准的 C/C++ 语法，不一定在所有编译器中都被支持。需要 Unity2020 以上</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionOS   : POSITION;</span><br><span class="line">    float3 normalOS      : NORMAL;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionHCS  : SV_POSITION;</span><br><span class="line">    float3 positionWS   : TEXCOORD0;</span><br><span class="line">    float3 normalWS      : TEXCOORD1;</span><br><span class="line">    float2 uv           : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEXTURE2D(_BaseMap);</span><br><span class="line">SAMPLER(sampler_BaseMap);</span><br><span class="line"></span><br><span class="line">CBUFFER_START(UnityPerMaterial)</span><br><span class="line">half4 _BaseColor;</span><br><span class="line">float4 _BaseMap_ST;</span><br><span class="line"><span class="type">float</span> _Gloss;</span><br><span class="line">half3 _SpecColor;</span><br><span class="line">CBUFFER_END</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Surface</span> //包含一些片元着色器中需要用于光照计算的参数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    half3 albedo;</span><br><span class="line">    float3 normalWS;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Varyings <span class="title function_">LambertBlinnPhongVert</span><span class="params">(Attributes IN)</span></span><br><span class="line">&#123;</span><br><span class="line">    Varyings OUT;</span><br><span class="line">    OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);</span><br><span class="line">    OUT.positionWS = TransformObjectToWorld(IN.positionOS.xyz);</span><br><span class="line">    OUT.normalWS = TransformObjectToWorldNormal(IN.normalOS); <span class="comment">//该函数做了 normalize</span></span><br><span class="line">    OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);</span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 <span class="title function_">LambertBlinnPhongFrag</span><span class="params">(Varyings IN)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    虽然法线在顶点着色器中已经被归一化了，但是从顶点着色器到片元着色器的线性插值过程中，会导致长度变化，所以在片元着色器中也要归一化一次。</span></span><br><span class="line"><span class="comment">    可以使用下面代码来验证：</span></span><br><span class="line"><span class="comment">    half3 color = abs(length(normalize(IN.normalWS)) - 1.0) * 10.0;</span></span><br><span class="line"><span class="comment">    return half4(color, 1.0);</span></span><br><span class="line"><span class="comment">    去掉 normalize 会出现黑白相间的球体，不去掉则全黑</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    Light mainLight; <span class="comment">//声明 Light 结构体</span></span><br><span class="line">    mainLight = GetMainLight(); <span class="comment">//获取光照信息</span></span><br><span class="line">    Surface surface; <span class="comment">//声明 Surface 结构体</span></span><br><span class="line"></span><br><span class="line">    surface.albedo = _BaseColor.rgb * SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv).rgb;</span><br><span class="line">    surface.normalWS = normalize(IN.normalWS); <span class="comment">//一定要归一化</span></span><br><span class="line">    </span><br><span class="line">    float3 lightDirWS = normalize(mainLight.direction);</span><br><span class="line">    float3 viewDirWS = normalize(GetWorldSpaceViewDir(IN.positionWS));</span><br><span class="line">    float3 halfDirWS = normalize(lightDirWS + viewDirWS);</span><br><span class="line">    </span><br><span class="line">    half3 ambient = _GlossyEnvironmentColor.rgb * surface.albedo; <span class="comment">//环境光颜色变量 _GlossyEnvironmentColor，在 Lighting.hlsl -&gt; RealtimeLights.hlsl -&gt; Input.hlsl 里定义</span></span><br><span class="line">    half3 diffuse = mainLight.color * surface.albedo * saturate(dot(surface.normalWS, lightDirWS)); <span class="comment">//Lambert</span></span><br><span class="line">    half3 specular = mainLight.color * _SpecColor * <span class="built_in">pow</span>(saturate(dot(surface.normalWS, halfDirWS)), _Gloss); <span class="comment">//Blinn-Phong</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> half4(ambient + diffuse + specular, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多光源处理"><a href="#多光源处理" class="headerlink" title="多光源处理"></a>多光源处理</h2><p>多光源逻辑和主光源类似，就是一个一个获取 Additional Lights 的光照的数据，并把计算得到的漫反射和高光反射累加到输出结果上去。Unity 同样在 Lighting.hlsl 中提供了相关函数，至于在 CPU 计算光照并传递给 GPU 的工作，Unity 也都帮我们处理好了，可以在 Universal RP -&gt; Runtime -&gt; ForwardLights.cs 里看到相关代码。有关获取 Additional Lights 光照信息的主要函数（都在 Lighting.hlsl 引入的 RealtimeLights.hlsl 文件中定义）有：  </p>
<p>①<code>GetAdditionalLightsCount()</code>：</p>
<pre><code>    int GetAdditionalLightsCount()
    &#123;
    #if USE_FORWARD_PLUS
        return 0;
    #else
        return int(min(_AdditionalLightsCount.x, unity_LightData.y));
    #endif
    &#125;
</code></pre><p>②<code>GetAdditionalLight()</code>，这个函数调用了 <code>GetPerObjectLightIndex()</code> 和 <code>GetAdditionalPerObjectLight()</code>。<code>GetPerObjectLightIndex()</code> 根据循环中的 i （即 0, 1, 2…）来获取灯的 per-object index，8 个额外光索引存储在 <code>unity_LightIndices[2]</code> 里；<code>GetAdditionalPerObjectLight()</code> 根据获取的灯索引来获取该附加光源的光照信息，它返回 Light 结构体。<code>GetPerObjectLightIndex()</code> 和 <code>GetAdditionalPerObjectLight()</code> 的代码不在这里展示了，详见 RealtimeLights.hlsl：</p>
<pre><code>    Light GetAdditionalLight(uint i, float3 positionWS)
    &#123;
    #if USE_FORWARD_PLUS
        int lightIndex = i;
    #else
        int lightIndex = GetPerObjectLightIndex(i);
    #endif
        return GetAdditionalPerObjectLight(lightIndex, positionWS);
    &#125;
</code></pre><p>接下来就可以通过循环结构，一个一个计算附加光源对物体光照产生的颜色，并累加。但在此之前，我们最好在我们的 Shader 里添加一个预处理指令： <code>#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HLSLPROGRAM</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> vertex LambertBlinnPhongVert</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> fragment LambertBlinnPhongFrag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Assets/ShaderLibrary/LambertBlinnPhongLitPass.hlsl&quot;</span></span></span><br><span class="line">ENDHLSL</span><br></pre></td></tr></table></figure>
<p><strong>multi_compile</strong> 和 <strong>shader_feature</strong> 编译指令类似，都是用于生成 Shader 变体的。multi_compile 主要功能是指定一个 keyword 生效，并生成相应变体，这样的好处是可以省略 if 语句。注意，该预处理指令中的那个单独的 <code>_</code> 不能省去，它相对于所有关键字都不生效，也就是该指令能生成 3 个变体，一个包含 _ADDITIONAL_LIGHTS_VERTEX，一个包含 _ADDITIONAL_LIGHTS，一个两个都不包含。这个预处理指令对应的就是 Universal Render Pipeline Asset 里 Lightings 的 Additional Lights 的逐顶点和逐像素设置：<strong>Disabled</strong> 对应 <code>_</code>，<strong>Per Vertex</strong> 对应 <code>_ADDITIONAL_LIGHTS_VERTEX</code>，<strong>Per Pixel</strong> 对应 <code>_ADDITIONAL_LIGHTS</code>。如果选择了 Per Vertex 或 Disabled，下面的 <code>#ifdef _ADDITIONAL_LIGHTS</code> 代码块就会失效。</p>
<p>Pass 里的片元着色器里增加的代码如下，使用 for 循环体，或者 Unity 定义的宏 <code>LIGHT_LOOP_BEGIN(pixelLightCount)</code>，本质上是一样的：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">half3 mainColor = half3(ambient + diffuse + specular); <span class="comment">//汇总主光源计算结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面为其他光源的计算</span></span><br><span class="line">half3 additionalColorSum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _ADDITIONAL_LIGHTS</span></span><br><span class="line"><span class="type">int</span> additionalLightsCount = GetAdditionalLightsCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; additionalLightsCount; ++i) <span class="comment">//i++ 和 ++i 在 for 循环里没本质区别</span></span><br><span class="line">&#123;</span><br><span class="line">    Light additionalLight = GetAdditionalLight(i, IN.positionWS);</span><br><span class="line">    float3 additionalLightDirWS = normalize(additionalLight.direction); <span class="comment">//不 normalize 也可以，官方的 Lit Shader 里没 normalize，应该获取到的就是单位向量</span></span><br><span class="line">    float3 additionalHalfDirWS = normalize(additionalLightDirWS + viewDirWS);</span><br><span class="line"></span><br><span class="line">    half3 additionalDiffuse = additionalLight.color * surface.albedo * saturate(dot(surface.normalWS, additionalLightDirWS)); <span class="comment">//Lambert</span></span><br><span class="line">    half3 additionalSpecular = additionalLight.color * _SpecColor * <span class="built_in">pow</span>(saturate(dot(surface.normalWS, additionalHalfDirWS)), _Gloss); <span class="comment">//Blinn-Phong</span></span><br><span class="line">    additionalColorSum += additionalDiffuse;</span><br><span class="line">    additionalColorSum += additionalSpecular;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> half4(mainColor + additionalColorSum, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>
<h2 id="投射阴影"><a href="#投射阴影" class="headerlink" title="投射阴影"></a>投射阴影</h2><p>主光源和附加光源投射阴影就放在一起讲了。当开启了光源的阴影后，底层渲染会首先调用 <code>&quot;LightMode&quot; = &quot;ShadowCaster&quot;</code> 的 Pass，这个 Pass 的渲染目标是一张 Shadowmap。Unity 会首先把摄像机放置到光源上，然后调用该 Pass，通过对顶点变换后得到光源空间下的位置（所以光源也有一个 Near Plane 要设置，为了近平面裁切），并据此来输出深度信息到 Shadowmap 中。对于平行光来说，阴影用正交投影渲染，因为光是平行的。</p>
<p>根据上面说的原理，对于 ShadowCaster Pass，只需要知道物体在裁切空间下的位置，所以在 ShadowCaster 的 Pass 中，我们可以把之前顶点着色器的代码完全抄过来不改变（当然多光源情况下需要修改点细节）。而片元着色器里几乎不用做任何事情，只要返回 0 就好，因为渲染目标不是帧缓存（唯一的例外是，如果有透明度测试，我们需要在片元着色器做 <code>Clip()</code> 处理）。在我使用的版本中（URP 14.0），ShadowCaster 这样就可以同时处理主光源和附加光源了。</p>
<p>URP 中默认（使用的版本为 URP 14.0）不会使用屏幕空间的阴影纹理技术 Screen Space Shadow Texture，若忘记了详见《Unity Shader 入门精要》读书笔记。若要使用该技术，可以在 Universal Renderer Data（URP asset 旁边的文件）添加一个 Unity 预制的 Renderer Features：Screen Space Shadows Renderer Feature。这个技术开启后未必对性能有优化，需要测试。</p>
<hr>
<p>在 ShadowCaster Pass 中，还需要注意一个事项，即 <strong>Depth Bias</strong> 和 <strong>Normal Bias</strong>，可以在 URP Asset -&gt; Shadows 下面设置，这两个参数主要是为了防止一个名为 <strong>Shadow Acne</strong> 的现象，即阴影出现条纹状态，具体详见百度。为了应用上述两个 Shadow Bias，我们需要知道光照的方向，光照的方向需要考虑是 <strong>directional light</strong> 还是 <strong>punctual light</strong>（精准光，包括点光源和聚光灯），因为精准光方向跟光与物体相对坐标有关，而平行光无关。</p>
<p>为了获取主光源的方向或附加光源的坐标，我们需要在 ShadowCaster Pass 中声明两个变量：<code>_LightDirection</code> 和 <code>_LightPosition</code>。我们不需要把它们放在 CBuffer 里，因为它们不是 per material uniform。这两个参数会被 UnityEngine.Rendering.Universal.ShadowUtils.SetupShadowCasterConstantBuffer 设置，详见 Runtime -&gt; ShadowUtils.cs。</p>
<p>因为我们要区分平行光还是精确光，我们还需要在 Shader 中增加一个编译指令：<code>#pragma multi_compile_vertex _ _CASTING_PUNCTUAL_LIGHT_SHADOW</code>。然后在顶点着色器中通过 <code>_CASTING_PUNCTUAL_LIGHT_SHADOW</code> 关键字获取不同的光照方向，同时使用 <code>ApplyShadowBias()</code> 函数应用阴影偏离，该函数会影响计算出的裁切空间的位置坐标，在 Lighting.hlsl -&gt; RealtimeLights.hlsl -&gt; Shadows.hlsl 中定义。</p>
<p>在 LambertBlinnPhongLit.shader 里的 SubShader 里增加 ShadowCaster Pass：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Name <span class="string">&quot;ShadowCaster&quot;</span></span><br><span class="line">            </span><br><span class="line">    Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ShadowCaster&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> vertex ShadowCasterVert</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> fragment ShadowCasterFrag</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> multi_compile_vertex _ _CASTING_PUNCTUAL_LIGHT_SHADOW</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Assets/ShaderLibrary/ShadowCasterPass.hlsl&quot;</span></span></span><br><span class="line">    ENDHLSL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建 ShadowCasterPass.hlsl，代码如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line">float3 _LightDirection; <span class="comment">//平行光使用该参数</span></span><br><span class="line">float3 _LightPosition; <span class="comment">//精准光使用该参数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionOS   : POSITION;</span><br><span class="line">    float3 normalOS      : NORMAL;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionHCS  : SV_POSITION;</span><br><span class="line">    float3 positionWS   : TEXCOORD0;</span><br><span class="line">    float3 normalWS      : TEXCOORD1;</span><br><span class="line">    float2 uv           : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEXTURE2D(_BaseMap);</span><br><span class="line">SAMPLER(sampler_BaseMap);</span><br><span class="line"></span><br><span class="line">CBUFFER_START(UnityPerMaterial)</span><br><span class="line">half4 _BaseColor;</span><br><span class="line">float4 _BaseMap_ST;</span><br><span class="line"><span class="type">float</span> _Gloss;</span><br><span class="line">half3 _SpecColor;</span><br><span class="line">CBUFFER_END</span><br><span class="line"></span><br><span class="line">Varyings <span class="title function_">ShadowCasterVert</span><span class="params">(Attributes IN)</span></span><br><span class="line">&#123;</span><br><span class="line">    Varyings OUT;</span><br><span class="line"></span><br><span class="line">    OUT.positionWS = TransformObjectToWorld(IN.positionOS.xyz);</span><br><span class="line">    OUT.normalWS = TransformObjectToWorldNormal(IN.normalOS); <span class="comment">//该函数做了 normalize</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> _CASTING_PUNCTUAL_LIGHT_SHADOW <span class="comment">//区分精准光和平行光</span></span></span><br><span class="line">        float3 lightDirectionWS = normalize(_LightPosition - OUT.positionWS);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        float3 lightDirectionWS = _LightDirection;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    float4 positionCS = TransformWorldToHClip(ApplyShadowBias(OUT.positionWS, OUT.normalWS, lightDirectionWS)); <span class="comment">//ApplyShadowBias 得到偏移过的世界坐标，再转换到裁切空间</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> UNITY_REVERSED_Z</span></span><br><span class="line">    positionCS.z = min(positionCS.z, UNITY_NEAR_CLIP_VALUE);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    positionCS.z = max(positionCS.z, UNITY_NEAR_CLIP_VALUE);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    OUT.positionHCS = positionCS;</span><br><span class="line">    OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);</span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 <span class="title function_">ShadowCasterFrag</span><span class="params">(Varyings IN)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//若需要裁切，则在此之前做裁切。片元着色器直接 void 也可以，这样就不用写 return 了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们其实可以把 ShadowCasterPass.hlsl 和 LambertBlinnPhongLitPass.hlsl 合并在一个文件中，我们可以让 UniversalForward 和 ShadowCaster 使用同一个顶点着色器，然后在 ShadowCaster 添加一个关键字，比如 <code>#define APPLY_SHADOW_BIAS_FIX</code>，然后在顶点着色器根据该关键字添加 #ifdef 相关代码。</p>
<h2 id="主光源接受阴影"><a href="#主光源接受阴影" class="headerlink" title="主光源接受阴影"></a>主光源接受阴影</h2><p>投射阴影的工作把物体产生的阴影计算进 ShadowmapTexture，而接受阴影的工作就是，使用转换到阴影空间的坐标 shadowCoord 对 ShadowmapTexture 进行采样，然后把采样后的结果，即 <strong>shadowAttenuation</strong>，和光照结果相乘，这样就能产生阴影效果。</p>
<blockquote>
<p>这样得到的阴影效果比较“硬”，日常生活的阴影常有渐变效果，即 Shadow Fade out，Shadows.hlsl 里有定义相关函数，可以额外去了解。包括混合光照模式的阴影遮罩模式等相关内容也不在本篇文章中说明，有需要额外去了解。</p>
</blockquote>
<p>顺便提一句，之前主光源处理和多光源处理，都没有处理光照衰减问题。光照衰减主要跟距离 <strong>DistanceAttenuation</strong> 有关，但是对于平行光来说，距离衰减恒为 1。聚光灯 Spot light 比较特殊，除了距离衰减，还有角度衰减 <strong>AngleAttenuation</strong>，即离聚光灯中心直射方向的角度越大，衰减越强。这两个光照衰减都在后面的附加光源接受阴影小节介绍，因为平行光距离衰减恒为 1，这里就简单提一下。</p>
<hr>
<p>根据上面说的，首先我们要获取阴影空间的坐标，可以使用 <code>TransformWorldToShadowCoord(positionWS)</code> 函数（在 Lighting.hlsl -&gt; RealtimeLights.hlsl -&gt; Shadows.hlsl 里定义），并传递进物体的世界坐标。</p>
<pre><code>    float4 TransformWorldToShadowCoord(float3 positionWS)
    &#123;
    #ifdef _MAIN_LIGHT_SHADOWS_CASCADE
        half cascadeIndex = ComputeCascadeIndex(positionWS);
    #else
        half cascadeIndex = half(0.0);
    #endif

        float4 shadowCoord = mul(_MainLightWorldToShadow[cascadeIndex], float4(positionWS, 1.0));

        return float4(shadowCoord.xyz, 0);
    &#125;
</code></pre><blockquote>
<p>【扩展知识】<strong>Shadow Cascades 阴影级联</strong>：阴影级联可以在 URP Asset -&gt; Shadows 里设置，URP 最多可以支持 4 个级联。使用阴影级联可以增加阴影质量：使用阴影贴图通常会有透视走样的问题。透视走样指的是阴影越靠近相机，边缘的锯齿化越严重。因为阴影贴图的分辨率是固定的，同样大小的一个阴影所对应的阴影贴图中纹素大小也是固定的。如果使用透视相机，其效果是近大远小，在渲染时，阴影越靠近相机，越容易出现多个片元从阴影贴图的同一纹素进行采样的情况，这几个片元得到的时相同的阴影值，从而产生锯齿边。而阴影级联根据对象到观察者的距离提供不同尺寸但相同分辨率的深度纹理来解决上述问题。上面代码就是根据级联个数获取不同的变换矩阵将物体世界坐标转到阴影坐标。</p>
</blockquote>
<p>接下来就需要通过 <code>GetMainLight()</code> 函数的一个重载来获取光源和阴影信息：  </p>
<pre><code>    Light GetMainLight(float4 shadowCoord)
    &#123;
        Light light = GetMainLight();
        light.shadowAttenuation = MainLightRealtimeShadow(shadowCoord);
        return light;
    &#125;
</code></pre><p>该重载调用了 <code>GetMainLight()</code> 函数，也就是我们在主光源处理中有摘抄的函数，可以回去看看。可以看到它设置了 distanceAttenuation 值为 1，shadowAttenuation 的默认值也为 1。虽然 shadowAttenuation 的值会被 <code>MainLightRealtimeShadow(shadowCoord)</code> 函数的结果替代，该函数也是在 Shadows.hlsl 里被定义：  </p>
<pre><code>    half MainLightRealtimeShadow(float4 shadowCoord)
    &#123;
        #if !defined(MAIN_LIGHT_CALCULATE_SHADOWS)
            return half(1.0);
        #elif defined(_MAIN_LIGHT_SHADOWS_SCREEN) &amp;&amp; !defined(_SURFACE_TYPE_TRANSPARENT)
            return SampleScreenSpaceShadowmap(shadowCoord);
        #else
            ShadowSamplingData shadowSamplingData = GetMainLightShadowSamplingData();
            half4 shadowParams = GetMainLightShadowParams();
            return SampleShadowmap(TEXTURE2D_ARGS(_MainLightShadowmapTexture, sampler_LinearClampCompare), shadowCoord, shadowSamplingData, shadowParams, false);
        #endif
    &#125;
</code></pre><p>该函数主要工作就是对阴影纹理进行采样。如果没有开启主光源阴影，则返回 1；若使用了屏幕阴影纹理技术，返回对屏幕阴影纹理的采样结果；都不是则返回对阴影纹理的采样结果。</p>
<p>接下来就是把 distanceAttenuation 和 shadowAttenuation 计算进我们的 diffuse 和 specular 颜色。我们可以先计算衰减后的光照颜色：<code>half3 attenuatedMainLightColor = mainLight.color * (mainLight.distanceAttenuation * mainLight.shadowAttenuation);</code>，然后用 attenuatedMainLightColor 去替代漫反射和高光计算中的 mainLight.color。全部代码在附加光源接受阴影小节中展示。</p>
<hr>
<p>最后别忘了添加使用的函数需要的编译指令 <code>#pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN</code> 和 <code>#pragma multi_compile_fragment _ _SHADOWS_SOFT _SHADOWS_SOFT_LOW _SHADOWS_SOFT_MEDIUM _SHADOWS_SOFT_HIGH</code>：  </p>
<pre><code>    #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN
    #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
    #pragma multi_compile_fragment _ _SHADOWS_SOFT _SHADOWS_SOFT_LOW _SHADOWS_SOFT_MEDIUM _SHADOWS_SOFT_HIGH
</code></pre><p>这些 Shader 关键字的开启和关闭都是受到 URP Asset 的设置的控制。至于 <code>MAIN_LIGHT_CALCULATE_SHADOWS</code> 关键字在 Shadows.hlsl 里被定义：  </p>
<pre><code>    #if !defined(_RECEIVE_SHADOWS_OFF)
        #if defined(_MAIN_LIGHT_SHADOWS) || defined(_MAIN_LIGHT_SHADOWS_CASCADE) || defined(_MAIN_LIGHT_SHADOWS_SCREEN)
            #define MAIN_LIGHT_CALCULATE_SHADOWS

            #if defined(_MAIN_LIGHT_SHADOWS) || (defined(_MAIN_LIGHT_SHADOWS_SCREEN) &amp;amp;&amp;amp; !defined(_SURFACE_TYPE_TRANSPARENT))
                #define REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR
            #endif
        #endif

        #if defined(_ADDITIONAL_LIGHT_SHADOWS)
            #define ADDITIONAL_LIGHT_CALCULATE_SHADOWS
        #endif
    #endif
</code></pre><blockquote>
<p>Unity 官方人员在官方答疑论坛对上面的一些关键字的说法：详见 <a target="_blank" rel="noopener" href="https://forum.unity.com/threads/shadow-cascades-weird-since-7-2-0.828453/#post-5516425">https://forum.unity.com/threads/shadow-cascades-weird-since-7-2-0.828453/#post-5516425</a><br><strong>MAIN_LIGHT_CALCULATE_SHADOWS</strong>：Defined when shadows on main light are enabled and shadows enabled in the material.<br><strong>ADDITIONAL_LIGHT_CALCULATE_SHADOWS</strong>：Defined when shadows on additional lights are enabled and shadows enabled in the material.<br><strong>REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR</strong>：Defined when shadows on main light are enabled, shadows enabled in the material and cascades set to none. Used to determine whether shadow coordinates need to be passed from the vertex shader to fragment shader.<br><strong>REQUIRES_WORLD_SPACE_POS_INTERPOLATOR</strong>：Defined when shadows there are additional lights or shadow cascades set to two or four. Used to determine whether the world space position needs to be passed from the vertex shader to fragment shader.​</p>
</blockquote>
<h2 id="附加光源接受阴影"><a href="#附加光源接受阴影" class="headerlink" title="附加光源接受阴影"></a>附加光源接受阴影</h2><p>附加光源接受阴影跟主光源接受阴影处理类似，但是我们还要考虑光照衰减的距离衰减和角度衰减，之前多光源处理中没有考虑。Unity 在 <code>GetAdditionalLight()</code> 调用的 <code>GetAdditionalPerObjectLight()</code> 函数中有调用计算距离衰减和角度衰减的公式：<code>float attenuation = DistanceAttenuation(distanceSqr, distanceAndSpotAttenuation.xy) * AngleAttenuation(spotDirection.xyz, lightDirection, distanceAndSpotAttenuation.zw);</code> 并把 attenuation 赋值给了 Light 结构体的 distanceAttenuation，也就是 light.distanceAttenuation 包含了距离衰减和角度衰减，不要搞错了。</p>
<h3 id="距离衰减"><a href="#距离衰减" class="headerlink" title="距离衰减"></a>距离衰减</h3><p>我们首先来介绍一下<strong>距离衰减</strong>的计算，<code>DistanceAttenuation()</code> 函数如下：  </p>
<pre><code>    float DistanceAttenuation(float distanceSqr, half2 distanceAttenuation)
    &#123;
        // We use a shared distance attenuation for additional directional and puctual lights
        // for directional lights attenuation will be 1
        float lightAtten = rcp(distanceSqr); //rcp 即 reciprocal 倒数
        float2 distanceAttenuationFloat = float2(distanceAttenuation);

        // Use the smoothing factor also used in the Unity lightmapper.
        half factor = half(distanceSqr * distanceAttenuationFloat.x);
        half smoothFactor = saturate(half(1.0) - factor * factor);
        smoothFactor = smoothFactor * smoothFactor;

        return lightAtten * smoothFactor;
    &#125;
</code></pre><p><code>DistanceAttenuation()</code> 函数传入的<strong>第一个参数 distanceSqr</strong> 就是光离物体距离的平方，<code>GetAdditionalPerObjectLight()</code> 函数中计算如下：  </p>
<pre><code>    float4 lightPositionWS = _AdditionalLightsPosition[perObjectLightIndex];
    ···
    float3 lightVector = lightPositionWS.xyz - positionWS * lightPositionWS.w;
    float distanceSqr = max(dot(lightVector, lightVector), HALF_MIN);
    half3 lightDirection = half3(lightVector * rsqrt(distanceSqr));
</code></pre><p>我们可以在 Unity 的 Frame Debugger 里观察到 _AdditionalLightsPosition 的 xyz 值记录的就是 punctual light 的世界坐标，w 则都是 1。对于 _MainLightPosition 来说 xyz 值记录的是归一化后平行光的方向，w 值为 0，所以它的距离平方为 1。所以 lightVector 就是 punctual light 的未归一化的方向向量，distanceSqr 就是光离物体距离的平方，但是给了个最小值 HALF_MIN（2^-14）防止取倒数的时候出问题。lightDirection 就是归一化后的 lightVector，<code>rsqrt()</code> 返回平方根的倒数。</p>
<p><strong>第二个参数 distanceAndSpotAttenuation.xy</strong> 也是 CPU 传递进来的：<code>half4 distanceAndSpotAttenuation = _AdditionalLightsAttenuation[perObjectLightIndex];</code>。可以在 Unity 的 Frame Debugger 里观察到，点光的 _AdditionalLightsAttenuation 的 zw 统一为 0、1。而聚光灯的 _AdditionalLightsAttenuation 的 zw 有特殊数值。这也是为什么 <code>DistanceAttenuation()</code> 函数传递进 distanceAndSpotAttenuation.xy，而 <code>AngleAttenuation()</code> 函数传递进 distanceAndSpotAttenuation.zw。xy 记录的是距离衰减相关信息、zw 记录的是角度衰减相关信息。</p>
<p>那么 <code>_AdditionalLightsAttenuation</code> 的 x、y 值在 C# 脚本中是如何计算得来得？我们可以在 ForwardLights.cs 脚本中调用的 UniversalRenderPipelineCore.cs 的 <code>InitializeLightConstants_Common()</code> 函数调用的 <code>GetPunctualLightDistanceAttenuation()</code> 函数中找到相关距离衰减的计算，建议看看源码。_AdditionalLightsAttenuation 的默认值为 (0, 1, 0, 1)。该函数返回 _AdditionalLightsAttenuation 的 x、y 值，对于点光源、聚光灯 x、y 值都是该函数相同的计算而得的：</p>
<p><strong>_AdditionalLightsAttenuation 的 x 值为灯光设置的 Range 的平方的倒数</strong>，即 1/LightRangeSqr。而 _AdditionalLightsAttenuation 的 y 值为 1/0.36 = 2.777778，它等于 LightRangeSqr / fadeRangeSqr，来源于 fadeStartDistanceSqr = 0.8f ∗ 0.8f ∗ lightRangeSqr，意思是 80% 开始 fade ，而 fadeRangeSqr = LightRangeSqr - fadeStartDistanceSqr = 0.36 * lightRangeSqr。但是 <code>DistanceAttenuation()</code> 并没有使用 y 值，因为 Unity 老版本区分了移动平台，老的移动平台的计算公式有使用到，已经被舍弃了。</p>
<p>我们将 <code>DistanceAttenuation()</code> 函数传入的参数合并起来可以得到的 <strong>smoothFactor</strong> 的公式为：  </p>
<script type="math/tex; mode=display">smoothFactor = (saturate(1 - (\frac {distanceSqr} {lightRangeSqr})^2))^2</script><p>总之该函数在灯光的 Range 处以及更远处使衰减值为 0。再乘上 lightAtten 即 distanceSqr 的倒数，就可以得到 DistanceAttenuation 的值了。</p>
<h3 id="角度衰减"><a href="#角度衰减" class="headerlink" title="角度衰减"></a>角度衰减</h3><p><strong>角度衰减</strong>只适用于聚光灯。我们来看 <code>AngleAttenuation()</code> 函数：  </p>
<pre><code>    half AngleAttenuation(half3 spotDirection, half3 lightDirection, half2 spotAttenuation)
    &#123;
        // Spot Attenuation with a linear falloff can be defined as
        // (SdotL - cosOuterAngle) / (cosInnerAngle - cosOuterAngle)
        // This can be rewritten as
        // invAngleRange = 1.0 / (cosInnerAngle - cosOuterAngle)
        // SdotL * invAngleRange + (-cosOuterAngle * invAngleRange)
        // SdotL * spotAttenuation.x + spotAttenuation.y

        // If we precompute the terms in a MAD instruction
        half SdotL = dot(spotDirection, lightDirection);
        half atten = saturate(SdotL * spotAttenuation.x + spotAttenuation.y);
        return atten * atten;
    &#125;
</code></pre><p>该函数传入的<strong>第一个参数 spotDirection.xyz</strong> 来源于 <code>half4 spotDirection = _AdditionalLightsSpotDir[perObjectLightIndex];</code>。_AdditionalLightsSpotDir 的默认值为 (0, 0, 1, 0)。它也在 C# 脚本的 <code>InitializeLightConstants_Common()</code> 函数中被设置：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lightType == LightType.Spot)</span><br><span class="line">&#123;</span><br><span class="line">    GetSpotAngleAttenuation(lightData.spotAngle, light?.innerSpotAngle, <span class="keyword">ref</span> lightAttenuation);</span><br><span class="line">    GetSpotDirection(<span class="keyword">ref</span> lightLocalToWorld, <span class="keyword">out</span> lightSpotDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GetSpotDirection()</code> 函数返回 _AdditionalLightsSpotDir 的值，如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetSpotDirection</span>(<span class="params"><span class="keyword">ref</span> Matrix4x4 lightLocalToWorldMatrix, <span class="keyword">out</span> Vector4 lightSpotDir</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector4 dir = lightLocalToWorldMatrix.GetColumn(<span class="number">2</span>);</span><br><span class="line">    lightSpotDir = <span class="keyword">new</span> Vector4(-dir.x, -dir.y, -dir.z, <span class="number">0.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始看到这个函数我是不能理解的，为什么从模型空间到世界空间的矩阵的第三列能得到光的方向，简直匪夷所思。经过一系列查询，原来 Spot Light 有个默认照明方向，朝着 z 轴正方向照明，我们可以把 Spot Light 的 Rotation 清零，就可以发现这点了。因为位移是齐次坐标下的第 4 列处理的，前三列不需要关心，而且灯也不需要考虑缩放问题。于是在灯模型空间下，光照方向可以被定义为 $\,\begin{bmatrix} 0 &amp; 0 &amp; 1 \end{bmatrix}\,$。于是我们的变换矩阵 M 乘上方向：</p>
<script type="math/tex; mode=display">\begin{bmatrix} m_{00} & m_{01} & m_{02} & m_{03} \\ m_{10} & m_{11} & m_{12} & m_{13} \\ m_{20} & m_{21} & m_{22} & m_{23} \\ m_{30} & m_{31} & m_{32} & m_{33} \end{bmatrix} \begin{bmatrix} 0 \\ 0 \\ 1 \\ 0 \end{bmatrix} = \begin{bmatrix} m_{02} \\ m_{12} \\ m_{22} \\ m_{32} \end{bmatrix}</script><p>这实际上就是取矩阵的第三列，也就是聚光灯光照的直射方向。同理可得，光照方向的右方向为 GetColumn(0)，上方向为 GetColumn(1)。</p>
<p>至于为什么取反，是因为这样子计算，光照的直射方向是远离灯的，而 lightDirection 是物体指向光源位置的方向，为了 <code>half SdotL = dot(spotDirection, lightDirection);</code> 的点乘计算正确，将 spotDirection 取反获取指向灯的方向。</p>
<p><code>AngleAttenuation()</code> 函数的<strong>第二个参数为 lightDirection</strong> 不用再提了。<strong>第三个参数为 distanceAndSpotAttenuation.zw</strong> 之前讲过它的 xy 值是怎么来的，它的 zw 来自 <code>GetSpotAngleAttenuation()</code> 函数，源码不在这里放出了。大致理解如下：首先我们可以看到 Spot Light 的 Shape 设置中有个 Inner Angle 和 Outer Angle，聚光灯的角度衰减是从 Inner Angle 开始的，并在 Outer Angle 处光照强度降为 0。我们看我们摘抄的 <code>AngleAttenuation()</code> 函数的注释：  </p>
<script type="math/tex; mode=display">angleAttenuation = saturate(\cfrac {SdotL - cosOuterAngle} {cosInnerAngle - cosOuterAngle})</script><p>若 invAngleRange = 1.0 / (cosInnerAngle - cosOuterAngle)，上述公式可以写为：  </p>
<script type="math/tex; mode=display">angleAttenuation = SdotL * invAngleRange + (-cosOuterAngle * invAngleRange)</script><p>而 <code>_AdditionalLightsAttenuation</code> 的 z 值记录的就是 invAngleRange，w 值记录的是 -cosOuterAngle * invAngleRange。</p>
<blockquote>
<p><code>GetSpotAngleAttenuation()</code> 函数的计算中，将 Inner Angle 和 Outer Angle 都除以了 2，是因为 Unity 编辑器里的角度是聚光灯边缘到边缘的大角度，我们需要的是边缘到直射方向的角度，所以除以 2。</p>
</blockquote>
<p>看 angleAttenuation 的公式，注意 cos 是角度越小越大，所以当 SdotL 也就是射向物体光离直射方向的角度的 cos 值。当该 cos 值比 cosInnerAngle 大时，也就是离聚光灯中心更近时，angleAttenuation 为 1；离聚光灯中心越远，接触到 InnerAngle 开始衰减，一直到 OuterAngle 变为 0，再远还是为 0。</p>
<p>Unity 在 <code>AngleAttenuation()</code> 函数的最后还做了平方处理：<code>return atten * atten;</code>，加强了角度衰减效果。</p>
<h3 id="接受阴影"><a href="#接受阴影" class="headerlink" title="接受阴影"></a>接受阴影</h3><p><code>GetAdditionalLight()</code> 函数的重载必须要把 shadowMask 传递进去：<code>Light GetAdditionalLight(uint i, float3 positionWS, half4 shadowMask)</code>。它没有只考虑其他光源实时阴影，不考虑 shadowMask 且不考虑 shadow fade 的重载，这两个内容不在本篇文章范围内。所以我们先使用最简单的 <code>Light GetAdditionalLight(uint i, float3 positionWS)</code> 获取附加光源光照信息，忘记了见多光源处理小节。因为 lightIndex 需要重复使用，我们把 GetAdditionalLight 函数也拆分了。然后调用 <code>AdditionalLightRealtimeShadow()</code> 函数来计算附加光源 shadowAttenuation，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> lightIndex = GetPerObjectLightIndex(i);</span><br><span class="line">Light additionalLight = GetAdditionalPerObjectLight(lightIndex, IN.positionWS);</span><br><span class="line">additionalLight.shadowAttenuation = AdditionalLightRealtimeShadow(lightIndex, IN.positionWS, additionalLight.direction);</span><br><span class="line">half3 attenuatedAdditionalLightColor = additionalLight.color * (additionalLight.distanceAttenuation * additionalLight.shadowAttenuation);</span><br></pre></td></tr></table></figure>
<p>原理不再解释，有问题详见源码。之后用 attenuatedAdditionalLightColor 替换其他光源的 diffuse 和 specular 的计算。</p>
<p>最后别忘了加上预处理指令：<code>#pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS</code>。否则 <code>AdditionalLightRealtimeShadow()</code> 函数恒返回 1。</p>
<h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><p>LambertBlinnPhongLit.shader 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shader <span class="string">&quot;Custom/LambertBlinnPhongLit&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [Header(Base Color)] [Space(<span class="number">10</span>)]</span><br><span class="line">        [MainColor] _BaseColor (<span class="string">&quot;Base Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        [MainTexture] _BaseMap (<span class="string">&quot;Base Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        [Header(Specular)] [Space(<span class="number">10</span>)]</span><br><span class="line">        _Gloss(<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">512.0</span>)) = <span class="number">10</span></span><br><span class="line">        _SpecColor(<span class="string">&quot;Specular Color&quot;</span>, Color) = (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> </span><br><span class="line">            <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalPipeline&quot;</span> </span><br><span class="line">            <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Geometry&quot;</span></span><br><span class="line">            <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;True&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;LambertBlinnPhongForwardLit&quot;</span></span><br><span class="line">            </span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;UniversalForward&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex LambertBlinnPhongVert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment LambertBlinnPhongFrag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fragment _ _SHADOWS_SOFT _SHADOWS_SOFT_LOW _SHADOWS_SOFT_MEDIUM _SHADOWS_SOFT_HIGH</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Assets/ShaderLibrary/LambertBlinnPhongLitPass.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;ShadowCaster&quot;</span></span><br><span class="line">            </span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ShadowCaster&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex ShadowCasterVert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment ShadowCasterFrag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_vertex _ _CASTING_PUNCTUAL_LIGHT_SHADOW</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Assets/ShaderLibrary/ShadowCasterPass.hlsl&quot;</span></span></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LambertBlinnPhongLitPass.hlsl 如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionOS   : POSITION;</span><br><span class="line">    float3 normalOS     : NORMAL;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionHCS  : SV_POSITION;</span><br><span class="line">    float3 positionWS   : TEXCOORD0;</span><br><span class="line">    float3 normalWS     : TEXCOORD1;</span><br><span class="line">    float2 uv           : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEXTURE2D(_BaseMap);</span><br><span class="line">SAMPLER(sampler_BaseMap);</span><br><span class="line"></span><br><span class="line">CBUFFER_START(UnityPerMaterial)</span><br><span class="line">half4 _BaseColor;</span><br><span class="line">float4 _BaseMap_ST;</span><br><span class="line"><span class="type">float</span> _Gloss;</span><br><span class="line">half3 _SpecColor;</span><br><span class="line">CBUFFER_END</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Surface</span> //包含一些片元着色器中需要用于光照计算的参数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    half3 albedo;</span><br><span class="line">    float3 normalWS;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Varyings <span class="title function_">LambertBlinnPhongVert</span><span class="params">(Attributes IN)</span></span><br><span class="line">&#123;</span><br><span class="line">    Varyings OUT;</span><br><span class="line">    OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);</span><br><span class="line">    OUT.positionWS = TransformObjectToWorld(IN.positionOS.xyz);</span><br><span class="line">    OUT.normalWS = TransformObjectToWorldNormal(IN.normalOS);</span><br><span class="line">    OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);</span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 <span class="title function_">LambertBlinnPhongFrag</span><span class="params">(Varyings IN)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    Light mainLight;</span><br><span class="line">    float4 shadowCoord = TransformWorldToShadowCoord(IN.positionWS);</span><br><span class="line">    mainLight = GetMainLight(shadowCoord);</span><br><span class="line">    half3 attenuatedMainLightColor = mainLight.color * (mainLight.distanceAttenuation * mainLight.shadowAttenuation);</span><br><span class="line">    </span><br><span class="line">    Surface surface;</span><br><span class="line">    surface.albedo = _BaseColor.rgb * SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv).rgb;</span><br><span class="line">    surface.normalWS = normalize(IN.normalWS);</span><br><span class="line">    </span><br><span class="line">    float3 lightDirWS = normalize(mainLight.direction); <span class="comment">//不 normalize 也可以</span></span><br><span class="line">    float3 viewDirWS = normalize(GetWorldSpaceViewDir(IN.positionWS));</span><br><span class="line">    float3 halfDirWS = normalize(lightDirWS + viewDirWS);</span><br><span class="line">    </span><br><span class="line">    half3 ambient = _GlossyEnvironmentColor.rgb * surface.albedo; </span><br><span class="line">    half3 diffuse = attenuatedMainLightColor * surface.albedo * saturate(dot(surface.normalWS, lightDirWS));</span><br><span class="line">    half3 specular = attenuatedMainLightColor * _SpecColor * <span class="built_in">pow</span>(saturate(dot(surface.normalWS, halfDirWS)), _Gloss);</span><br><span class="line">    </span><br><span class="line">    half3 mainColor = half3(ambient + diffuse + specular);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他光源</span></span><br><span class="line">    half3 additionalColorSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _ADDITIONAL_LIGHTS</span></span><br><span class="line">    <span class="type">int</span> additionalLightsCount = GetAdditionalLightsCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &amp;lt; additionalLightsCount; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> lightIndex = GetPerObjectLightIndex(i);</span><br><span class="line">        Light additionalLight = GetAdditionalPerObjectLight(lightIndex, IN.positionWS);</span><br><span class="line">        additionalLight.shadowAttenuation = AdditionalLightRealtimeShadow(lightIndex, IN.positionWS, additionalLight.direction);</span><br><span class="line">        half3 attenuatedAdditionalLightColor = additionalLight.color * (additionalLight.distanceAttenuation * additionalLight.shadowAttenuation);</span><br><span class="line">        </span><br><span class="line">        float3 additionalLightDirWS = normalize(additionalLight.direction); <span class="comment">//不 normalize 也可以</span></span><br><span class="line">        float3 additionalHalfDirWS = normalize(additionalLightDirWS + viewDirWS);</span><br><span class="line"></span><br><span class="line">        half3 additionalDiffuse = attenuatedAdditionalLightColor * surface.albedo * saturate(dot(surface.normalWS, additionalLightDirWS));</span><br><span class="line">        half3 additionalSpecular = attenuatedAdditionalLightColor * _SpecColor * <span class="built_in">pow</span>(saturate(dot(surface.normalWS, additionalHalfDirWS)), _Gloss);</span><br><span class="line">        additionalColorSum += additionalDiffuse;</span><br><span class="line">        additionalColorSum += additionalSpecular;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> half4(mainColor + additionalColorSum, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ShadowCasterPass.hlsl 如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line">float3 _LightDirection;</span><br><span class="line">float3 _LightPosition;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionOS   : POSITION;</span><br><span class="line">    float3 normalOS      : NORMAL;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionHCS  : SV_POSITION;</span><br><span class="line">    float3 positionWS   : TEXCOORD0;</span><br><span class="line">    float3 normalWS      : TEXCOORD1;</span><br><span class="line">    float2 uv           : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEXTURE2D(_BaseMap);</span><br><span class="line">SAMPLER(sampler_BaseMap);</span><br><span class="line"></span><br><span class="line">CBUFFER_START(UnityPerMaterial)</span><br><span class="line">half4 _BaseColor;</span><br><span class="line">float4 _BaseMap_ST;</span><br><span class="line"><span class="type">float</span> _Gloss;</span><br><span class="line">half3 _SpecColor;</span><br><span class="line">CBUFFER_END</span><br><span class="line"></span><br><span class="line">Varyings <span class="title function_">ShadowCasterVert</span><span class="params">(Attributes IN)</span></span><br><span class="line">&#123;</span><br><span class="line">    Varyings OUT;</span><br><span class="line"></span><br><span class="line">    OUT.positionWS = TransformObjectToWorld(IN.positionOS.xyz);</span><br><span class="line">    OUT.normalWS = TransformObjectToWorldNormal(IN.normalOS); <span class="comment">//该函数做了 normalize</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> _CASTING_PUNCTUAL_LIGHT_SHADOW</span></span><br><span class="line">        float3 lightDirectionWS = normalize(_LightPosition - OUT.positionWS);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        float3 lightDirectionWS = _LightDirection;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    float4 positionCS = TransformWorldToHClip(ApplyShadowBias(OUT.positionWS, OUT.normalWS, lightDirectionWS));</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> UNITY_REVERSED_Z</span></span><br><span class="line">    positionCS.z = min(positionCS.z, UNITY_NEAR_CLIP_VALUE);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    positionCS.z = max(positionCS.z, UNITY_NEAR_CLIP_VALUE);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    OUT.positionHCS = positionCS;</span><br><span class="line">    OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);</span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 <span class="title function_">ShadowCasterFrag</span><span class="params">(Varyings IN)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>URP 基础部分完结撒花。URP 实现的更复杂的效果详见其他文章，本文主要是打个基础以及备忘。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io">鸟布</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io/2024/02/23/2024-02-23-URP%E5%9F%BA%E7%A1%80/">https://ybniaobu.github.io/2024/02/23/2024-02-23-URP%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ybniaobu.github.io" target="_blank">鸟布的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/unity/">unity</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/02/18/pMAzYioaFZEkS8I.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src="/images/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/20/2024-03-20-NPR_StarRail1/" title="基于星穹铁道的卡通渲染（一）"><img class="cover" src="https://s2.loli.net/2024/03/26/dZTwsApi59CSUal.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基于星穹铁道的卡通渲染（一）</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/22/2024-02-22-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%803/" title="MIT 线性代数公开课笔记（三）"><img class="cover" src="https://s2.loli.net/2024/02/18/NjAQJ5diwBHTKzc.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MIT 线性代数公开课笔记（三）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/15/2023-09-15-UnityShader1/" title="《Unity Shader入门精要》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2023/09/19/cDvdURBPhjwkOsY.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-15</div><div class="title">《Unity Shader入门精要》读书笔记（一）</div></div></a></div><div><a href="/2023/10/13/2023-10-13-UnityShader2/" title="《Unity Shader入门精要》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2023/10/15/RZftaNSscWoLH1u.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-13</div><div class="title">《Unity Shader入门精要》读书笔记（二）</div></div></a></div><div><a href="/2023/11/22/2023-11-22-UnityShader3/" title="《Unity Shader入门精要》读书笔记（三）"><img class="cover" src="https://s2.loli.net/2023/11/23/L3ts4WnThMlDN9d.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-22</div><div class="title">《Unity Shader入门精要》读书笔记（三）</div></div></a></div><div><a href="/2023/12/19/2023-12-19-UnityShader4/" title="《Unity Shader入门精要》读书笔记（四）"><img class="cover" src="https://s2.loli.net/2023/12/20/9Ah5ugiIpONK1cX.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-19</div><div class="title">《Unity Shader入门精要》读书笔记（四）</div></div></a></div><div><a href="/2023/12/30/2023-12-30-UnityShader5/" title="《Unity Shader入门精要》读书笔记（五）"><img class="cover" src="https://s2.loli.net/2023/12/30/hc2s7BS45l1wUdQ.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-30</div><div class="title">《Unity Shader入门精要》读书笔记（五）</div></div></a></div><div><a href="/2024/03/20/2024-03-20-NPR_StarRail1/" title="基于星穹铁道的卡通渲染（一）"><img class="cover" src="https://s2.loli.net/2024/03/26/dZTwsApi59CSUal.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="title">基于星穹铁道的卡通渲染（一）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/wechat%20avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鸟布</div><div class="author-info__description">教练，我想学技术</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://niaobu.notion.site/787824630ea6480e944c1ae5ae7f4792"><i class="fa-solid fa-book"></i><span>My Notion</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ybniaobu/ybniaobu.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:niaobubob@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为了蒂法！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity-SRP"><span class="toc-number">1.</span> <span class="toc-text">Unity SRP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SRP-%E5%92%8C%E5%86%85%E7%BD%AE%E7%AE%A1%E7%BA%BF%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">1.1.</span> <span class="toc-text">SRP 和内置管线的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Universal-Render-Pipeline-Asset"><span class="toc-number">1.2.</span> <span class="toc-text">Universal Render Pipeline Asset</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#URP-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">URP 基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9D%90%E8%B4%A8%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">常用的材质属性的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URP-%E6%94%AF%E6%8C%81%E7%9A%84-HLSL-%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">URP 支持的 HLSL 变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ShaderLab-SubShader-tags"><span class="toc-number">2.3.</span> <span class="toc-text">ShaderLab SubShader tags</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URP-ShaderLab-Pass-tags"><span class="toc-number">2.4.</span> <span class="toc-text">URP ShaderLab Pass tags</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%8A%B6%E6%80%81%E8%AE%BE%E7%BD%AE%E5%91%BD%E4%BB%A4"><span class="toc-number">2.5.</span> <span class="toc-text">渲染状态设置命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#URP-shader-%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6"><span class="toc-number">3.</span> <span class="toc-text">URP shader 基础框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#URP-Shader-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">URP Shader 目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#include-%E6%8C%87%E4%BB%A4%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.2.</span> <span class="toc-text">include 指令保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Optimizing-draw-calls"><span class="toc-number">3.3.</span> <span class="toc-text">Optimizing draw calls</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic-batching"><span class="toc-number">3.3.1.</span> <span class="toc-text">Dynamic batching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Static-batching"><span class="toc-number">3.3.2.</span> <span class="toc-text">Static batching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SRP-Batcher"><span class="toc-number">3.3.3.</span> <span class="toc-text">SRP Batcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPU-instancing"><span class="toc-number">3.3.4.</span> <span class="toc-text">GPU instancing</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">4.</span> <span class="toc-text">透明效果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88"><span class="toc-number">4.1.</span> <span class="toc-text">透明度混合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="toc-number">4.2.</span> <span class="toc-text">透明度测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.3.</span> <span class="toc-text">实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GPU-instancing-%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.</span> <span class="toc-text">GPU instancing 实践</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%89%E7%85%A7"><span class="toc-number">6.</span> <span class="toc-text">光照</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#URP-%E5%85%89%E7%85%A7%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.</span> <span class="toc-text">URP 光照机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%85%89%E6%BA%90%E5%A4%84%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">主光源处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%85%89%E6%BA%90%E5%A4%84%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">多光源处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%95%E5%B0%84%E9%98%B4%E5%BD%B1"><span class="toc-number">6.4.</span> <span class="toc-text">投射阴影</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%85%89%E6%BA%90%E6%8E%A5%E5%8F%97%E9%98%B4%E5%BD%B1"><span class="toc-number">6.5.</span> <span class="toc-text">主光源接受阴影</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E5%85%89%E6%BA%90%E6%8E%A5%E5%8F%97%E9%98%B4%E5%BD%B1"><span class="toc-number">6.6.</span> <span class="toc-text">附加光源接受阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB%E8%A1%B0%E5%87%8F"><span class="toc-number">6.6.1.</span> <span class="toc-text">距离衰减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%92%E5%BA%A6%E8%A1%B0%E5%87%8F"><span class="toc-number">6.6.2.</span> <span class="toc-text">角度衰减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E9%98%B4%E5%BD%B1"><span class="toc-number">6.6.3.</span> <span class="toc-text">接受阴影</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">6.7.</span> <span class="toc-text">全部代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">7.</span> <span class="toc-text">后记</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/09/2024-07-09-IBL_Basics1/" title="IBL 基于图像的光照（一）"><img src="https://s2.loli.net/2024/07/22/nD1y67NcRpQOHbS.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IBL 基于图像的光照（一）"/></a><div class="content"><a class="title" href="/2024/07/09/2024-07-09-IBL_Basics1/" title="IBL 基于图像的光照（一）">IBL 基于图像的光照（一）</a><time datetime="2024-07-09T07:25:54.000Z" title="发表于 2024-07-09 15:25:54">2024-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/04/2024-06-04-PBR_Theory2/" title="PBR 理论基础（BRDF）（二）"><img src="https://s2.loli.net/2024/06/04/nouFeJyYMt179RE.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PBR 理论基础（BRDF）（二）"/></a><div class="content"><a class="title" href="/2024/06/04/2024-06-04-PBR_Theory2/" title="PBR 理论基础（BRDF）（二）">PBR 理论基础（BRDF）（二）</a><time datetime="2024-06-04T07:56:47.000Z" title="发表于 2024-06-04 15:56:47">2024-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/21/2024-05-21-PBR_Theory1/" title="PBR 理论基础（BRDF）（一）"><img src="https://s2.loli.net/2024/05/21/6QnAbYhwJX4Bavl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PBR 理论基础（BRDF）（一）"/></a><div class="content"><a class="title" href="/2024/05/21/2024-05-21-PBR_Theory1/" title="PBR 理论基础（BRDF）（一）">PBR 理论基础（BRDF）（一）</a><time datetime="2024-05-21T06:20:48.000Z" title="发表于 2024-05-21 14:20:48">2024-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/23/2024-04-23-GAMES_101_2/" title="GAMES101-图形学入门公开课笔记（二）"><img src="https://s2.loli.net/2024/04/23/AnT1Gf8cdqDa69b.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAMES101-图形学入门公开课笔记（二）"/></a><div class="content"><a class="title" href="/2024/04/23/2024-04-23-GAMES_101_2/" title="GAMES101-图形学入门公开课笔记（二）">GAMES101-图形学入门公开课笔记（二）</a><time datetime="2024-04-23T13:53:41.000Z" title="发表于 2024-04-23 21:53:41">2024-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/05/2024-04-05-GAMES_101_1/" title="GAMES101-图形学入门公开课笔记（一）"><img src="https://s2.loli.net/2024/04/05/bQhEat4gmx9UWIX.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GAMES101-图形学入门公开课笔记（一）"/></a><div class="content"><a class="title" href="/2024/04/05/2024-04-05-GAMES_101_1/" title="GAMES101-图形学入门公开课笔记（一）">GAMES101-图形学入门公开课笔记（一）</a><time datetime="2024-04-05T11:16:20.000Z" title="发表于 2024-04-05 19:16:20">2024-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 鸟布</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Your time is limited, so don't waste it living someone else's life.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>