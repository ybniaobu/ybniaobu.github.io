<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《C#图解教程》读书笔记（二） | 鸟布的博客</title><meta name="author" content="鸟布"><meta name="copyright" content="鸟布"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本篇主要内容为：表达式与运算符；语句；结构；枚举；数组；委托；事件。读书笔记仅为知识的记录，方便后续查找。学习完成日期为2023年07月29日。          第九章 表达式和运算符表达式 Expressions运算符 operator 是一个符号，表示返回单个结果的操作。操作数 operan"><link rel="shortcut icon" href="https://s2.loli.net/2022/09/08/Ygib4lfw6z1khnr.png"><link rel="canonical" href="https://ybniaobu.github.io/2022/12/06/2022-12-06-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 鸟布","link":"链接: ","source":"来源: 鸟布的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《C#图解教程》读书笔记（二）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-29 20:14:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/wechat%20avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/black.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鸟布的博客"><span class="site-name">鸟布的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《C#图解教程》读书笔记（二）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-06T08:34:24.000Z" title="发表于 2022-12-06 16:34:24">2022-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-29T12:14:38.000Z" title="更新于 2023-07-29 20:14:38">2023-07-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C#</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">C#读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>89分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《C#图解教程》读书笔记（二）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本篇主要内容为：表达式与运算符；语句；结构；枚举；数组；委托；事件。<br>读书笔记仅为知识的记录，方便后续查找。<br>学习完成日期为2023年07月29日。  </p>
</blockquote>
<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

<h1 id="第九章-表达式和运算符"><a href="#第九章-表达式和运算符" class="headerlink" title="第九章 表达式和运算符"></a>第九章 表达式和运算符</h1><h2 id="表达式-Expressions"><a href="#表达式-Expressions" class="headerlink" title="表达式 Expressions"></a>表达式 Expressions</h2><p><strong>运算符 operator</strong> 是一个符号，表示返回单个结果的操作。<strong>操作数 operand</strong> 指作为运算符输入的数据元素。<strong>表达式 expression</strong> 是运算符和操作数的字符串。比如 <code>a + b + c + d</code> 有3个运算符和4个操作数。</p>
<p><strong>表达式求值 Evaluating an expression</strong> 是将每个运算符以适当的顺序应用到它的操作数以产生一个值的过程。值被返回到表达式求值的位置。除了返回值，一些表达式可能还会在内存中设置一个值。</p>
<h2 id="字面量-Literals"><a href="#字面量-Literals" class="headerlink" title="字面量 Literals"></a>字面量 Literals</h2><p><strong>字面量</strong>是源代码中键入的数字或字符串。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="number">1024</span>); <span class="comment">//整数字面量</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="number">3.1416</span>); <span class="comment">//双精度型字面量</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="number">3.1416F</span>); <span class="comment">//浮点型字面量</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="literal">true</span>); <span class="comment">//布尔型字面量</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">//字符型字面量</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="string">&quot;Hi there&quot;</span>); <span class="comment">//字符串字面量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>① bool 有两个字面量：true 和 false ，注意和所有 C# 关键字一样，它们都是小写。<br>② 对于引用类型变量，字面量 null 表示变量没有指向内存中的数据。</p>
<h3 id="整数字面量-Integer-Literals"><a href="#整数字面量-Integer-Literals" class="headerlink" title="整数字面量 Integer Literals"></a>整数字面量 Integer Literals</h3><p>整数字面量被书写为十进制数字序列，没有小数点，带有可选的后缀，指明整数的类型。</p>
<p>比如以下四个字面量：<br><code>236 //整数</code><br><code>236L //长整数</code><br><code>236U //无符号整数</code><br><code>236UL //无符号长整数</code>  </p>
<p>整数类型字面量还可以写成十六进制 hex 形式，以 0x 或 0X 为前缀，实际数据类型用后缀指定。也可以写成二进制记法，以 0b 或 0B 为前缀，实际数据类型用后缀指定。</p>
<p>若没有后缀，编译器会把数字字符串解释为能表示该值而不丢失数据的相应类型的最小类型，比如236和5000000000都没有后缀，236会被解释为一个 int ，5000000000会被解释为一个 long 。</p>
<p>可以在数字字面量插入分隔符：<code>5_000_000_000</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">后缀</th>
<th style="text-align:left">整数类型</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">无</td>
<td style="text-align:left">int, uint, long, ulong</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">U, u</td>
<td style="text-align:left">uint, ulong</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">L, l</td>
<td style="text-align:left">long, ulong</td>
<td style="text-align:left">不推荐使用小写字母l，会和数字1混淆</td>
</tr>
<tr>
<td style="text-align:left">ul, uL, Ul, UL, lu, Lu, lU, LU</td>
<td style="text-align:left">ulong</td>
<td style="text-align:left">不推荐使用小写字母l，会和数字1混淆</td>
</tr>
</tbody>
</table>
</div>
<h3 id="实数字面量-Real-Literals"><a href="#实数字面量-Real-Literals" class="headerlink" title="实数字面量 Real Literals"></a>实数字面量 Real Literals</h3><p>C# 有三种实数数据类型：float、double 和 decimal ，分别对应32位、64位和128位精度，都是浮点数据类型，实际使用中，double 最常用。</p>
<p>实数字面量包括十进制数字；一个可选的小数点；一个可选的指数部分 E 或 e ；一个可选的后缀：<br><code>float f1 = 236F;</code><br><code>double d1 = 236.714;</code><br><code>double d2 = .35192;</code><br><code>double d3 = 6.338e-26;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">后缀</th>
<th style="text-align:left">实数类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">无</td>
<td style="text-align:left">double</td>
</tr>
<tr>
<td style="text-align:left">F, f</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">D, d</td>
<td style="text-align:left">double</td>
</tr>
<tr>
<td style="text-align:left">M, m</td>
<td style="text-align:left">decimal</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意：无后缀的实数字面量是 double 类型，而不是 float 类型！！！</p>
</blockquote>
<h3 id="字符字面量-Character-Literals"><a href="#字符字面量-Character-Literals" class="headerlink" title="字符字面量 Character Literals"></a>字符字面量 Character Literals</h3><p><strong>字符字面量</strong>由<strong>两个单引号</strong>内的字符组成，用于表示单个字符(a)、非打印字符(\n换行符)或者执行特殊任务的字符，比如转义 escape (\)。</p>
<p>尽管可能需要多个字符来表示一个字符字面量，但是每个字符字面量只表示一个字符，要引入多个字符，必须使用字符串字面量。</p>
<p>字符字面量可以是以下任意一种：<br><code>char c1 = &#39;d&#39;; //单个字符</code><br><code>char c2 = &#39;\n&#39;; //简单转义序列</code><br><code>char c3 = &#39;\x0061&#39;; //十六进制转义序列</code><br><code>char c4 = &#39;\u005a&#39;; //Unicode转义序列</code>  </p>
<p>①字符字面量的类型是 <strong>char</strong> ；<br>②简单转义序列是一个反斜杠后面跟着单个字符；<br>③十六进制转义序列是一个反斜杠后面跟着 X 或 x，后面4个十六进制数字；<br>④Unicode 转义序列是一个反斜杠后面跟着 U 或 u，后面4个十六进制数字。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">转义序列</th>
<th style="text-align:left">十六进制编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">空字符 Null</td>
<td style="text-align:left">\0</td>
<td style="text-align:left">0x0000</td>
</tr>
<tr>
<td style="text-align:left">警告 Alert</td>
<td style="text-align:left">\a</td>
<td style="text-align:left">0x0007</td>
</tr>
<tr>
<td style="text-align:left">退格符 Backspace</td>
<td style="text-align:left">\b</td>
<td style="text-align:left">0x0008</td>
</tr>
<tr>
<td style="text-align:left">水平制表符 Horizontal tab</td>
<td style="text-align:left">\t</td>
<td style="text-align:left">0x0009</td>
</tr>
<tr>
<td style="text-align:left">换行符 New line</td>
<td style="text-align:left">\n</td>
<td style="text-align:left">0x000A</td>
</tr>
<tr>
<td style="text-align:left">垂直制表符 Vertical tab</td>
<td style="text-align:left">\v</td>
<td style="text-align:left">0x000B</td>
</tr>
<tr>
<td style="text-align:left">换页符 Form feed</td>
<td style="text-align:left">\f</td>
<td style="text-align:left">0x000C</td>
</tr>
<tr>
<td style="text-align:left">回车符 Carriage return</td>
<td style="text-align:left">\r</td>
<td style="text-align:left">0x000D</td>
</tr>
<tr>
<td style="text-align:left">双引号 Double quote</td>
<td style="text-align:left">\”</td>
<td style="text-align:left">0x0022</td>
</tr>
<tr>
<td style="text-align:left">单引号 Single quote</td>
<td style="text-align:left">\’</td>
<td style="text-align:left">0x0027</td>
</tr>
<tr>
<td style="text-align:left">反斜杠 Backslash</td>
<td style="text-align:left">\\</td>
<td style="text-align:left">0x005C</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符串字面量-String-Literals"><a href="#字符串字面量-String-Literals" class="headerlink" title="字符串字面量 String Literals"></a>字符串字面量 String Literals</h3><p><strong>字符串字面量</strong>使用<strong>双引号</strong>标记，不同于字符字面量使用单引号。</p>
<p>字符串字面量有两种类型：①<strong>常规字符串字面量 Regular string literals</strong>；②<strong>逐字字符串字面量 Verbatim string literals</strong>。</p>
<p>常规字符串字面量可以包含：字符、简单转义序列、十六进制转义序列和Unicode转义序列。例如：<br><code>string st1 = &quot;Hi there!&quot;;</code><br><code>string st2 = &quot;Val1\t5, Val2\t10&quot;;</code><br><code>string st3 = &quot;Add\x000ASome\u0007Interest&quot;;</code></p>
<p>逐字字符串字面量是以 @ 字符为前缀的常规字符串字面量，逐字字符串字面量中字符串不会被转义。逐字字符串字面量的唯一例外就是相邻的双引号组，被解释为单个双引号字符。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> rst1 = <span class="string">&quot;Hi there!&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> vst1 = <span class="string">@&quot;Hi there!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> rst2 = <span class="string">&quot;It started, \&quot;Four score and seven...\&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> vst2 = <span class="string">@&quot;It started, &quot;&quot;Four score and seven...&quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> rst3 = <span class="string">&quot;Value 1 \t 5, Val2 \t 10&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> vst3 = <span class="string">@&quot;Value 1 \t 5, Val2 \t 10&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> rst4 = <span class="string">&quot;C:\\Program Files\\Microsoft\\&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> vst4 = <span class="string">@&quot;C:\Program Files\Microsoft\&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> rst5 = <span class="string">&quot; Print \x000A Multiple \u000A Lines&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> vst5 = <span class="string">@&quot; Print</span></span><br><span class="line"><span class="string">Multiple</span></span><br><span class="line"><span class="string">Lines&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>打印这些字符串会产生以下输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Hi there!</span><br><span class="line">Hi there!</span><br><span class="line"></span><br><span class="line">It started, &quot;Four score and seven...&quot;</span><br><span class="line">It started, &quot;Four score and seven...&quot;</span><br><span class="line"></span><br><span class="line">Value 1 5, Val2 10</span><br><span class="line">Value 1 \t 5, Val2 \t 10</span><br><span class="line"></span><br><span class="line">C:\Program Files\Microsoft\</span><br><span class="line">C:\Program Files\Microsoft\</span><br><span class="line"></span><br><span class="line">Print</span><br><span class="line">Multiple</span><br><span class="line">Lines</span><br><span class="line"></span><br><span class="line">Print</span><br><span class="line">Multiple</span><br><span class="line">Lines</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器让相同的字符串字面量共享堆中同一内存位置以节约内存。</p>
</blockquote>
<h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>表达式可以有很多嵌套的子表达式构成，求值顺序可以是表达式最终值发生变化。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>优先级从高到低如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">初级运算符 <font face= "Arial"> Primary </font></td>
<td style="text-align:left"><font face= "Arial"> a.x, f(x), a[x], x + +, x - -, new, typeof, checked, unchecked </font></td>
</tr>
<tr>
<td style="text-align:left">一元运算符 <font face= "Arial">Unary</font></td>
<td style="text-align:left"><font face= "Arial">+, -, !, ~, + + x, - - x, (T)x</font></td>
</tr>
<tr>
<td style="text-align:left">乘法 <font face= "Arial">Multiplicative</font></td>
<td style="text-align:left"><font face= "Arial"> *, /, % </font></td>
</tr>
<tr>
<td style="text-align:left">加法 <font face= "Arial">Additive</font></td>
<td style="text-align:left"><font face= "Arial">+, -</font></td>
</tr>
<tr>
<td style="text-align:left">移位 <font face= "Arial">Shift</font></td>
<td style="text-align:left"><font face= "Arial">&lt;&lt;, &gt;&gt;</font></td>
</tr>
<tr>
<td style="text-align:left">关系和类型 <font face= "Arial">Relational and type</font></td>
<td style="text-align:left"><font face= "Arial">&lt;, &gt;, &lt;=, &gt;=, is, as</font></td>
</tr>
<tr>
<td style="text-align:left">相等 <font face= "Arial">Equality</font></td>
<td style="text-align:left"><font face= "Arial">==, !=</font></td>
</tr>
<tr>
<td style="text-align:left">位与 <font face= "Arial">Logical AND</font></td>
<td style="text-align:left"><font face= "Arial">&amp;</font></td>
</tr>
<tr>
<td style="text-align:left">位异或 <font face= "Arial">Logical XOR</font></td>
<td style="text-align:left"><font face= "Arial">^</font></td>
</tr>
<tr>
<td style="text-align:left">位或 <font face= "Arial">Logical OR</font></td>
<td style="text-align:left"><font face= "Arial">&#124;</font></td>
</tr>
<tr>
<td style="text-align:left">条件与 <font face= "Arial">Conditional AND</font></td>
<td style="text-align:left"><font face= "Arial">&amp;&amp;</font></td>
</tr>
<tr>
<td style="text-align:left">条件或 <font face= "Arial">Conditional OR</font></td>
<td style="text-align:left"><font face= "Arial">&#124;&#124;</font></td>
</tr>
<tr>
<td style="text-align:left">条件选择 <font face= "Arial">Conditional</font></td>
<td style="text-align:left"><font face= "Arial">?:</font></td>
</tr>
<tr>
<td style="text-align:left">赋值运算符 <font face= "Arial">Assignment</font></td>
<td style="text-align:left"><font face= "Arial">=, *=, /=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=, &#124;=</font></td>
</tr>
</tbody>
</table>
</div>
<h3 id="结合性-Associativity"><a href="#结合性-Associativity" class="headerlink" title="结合性 Associativity"></a>结合性 Associativity</h3><p>如果有连续的运算符有相同的优先级别，求值顺序由<strong>操作结合性 operator associativity</strong> 决定，比如 <code>2/6*4</code> 求值顺序有2种。</p>
<p>运算符结合性重要特征：①左结合运算符从左至右求值；②右结合运算符从右至左求值；  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符类型</th>
<th style="text-align:left">结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">赋值运算符</td>
<td style="text-align:left">右结合</td>
</tr>
<tr>
<td style="text-align:left">其他二元运算符</td>
<td style="text-align:left">左结合</td>
</tr>
<tr>
<td style="text-align:left">条件运算符</td>
<td style="text-align:left">右结合</td>
</tr>
</tbody>
</table>
</div>
<p>所以 <code>2/6*4</code> 应该是从左到右，得到 4/3 。</p>
<p>可以直接使用<strong>圆括号</strong>来显式地设定子表达式求值顺序，并覆盖优先级和结合性规则。</p>
<h2 id="简单算术运算符"><a href="#简单算术运算符" class="headerlink" title="简单算术运算符"></a>简单算术运算符</h2><p>简单算术运算符包括 <code>+</code> 、<code>-</code> 、<code>*</code> 、<code>/</code> 。这些运算符都是二元左结合运算符。对于除法，要注意整数除法，直接截取整数部分。</p>
<h2 id="求余运算符-The-Remainder-Operator"><a href="#求余运算符-The-Remainder-Operator" class="headerlink" title="求余运算符 The Remainder Operator"></a>求余运算符 The Remainder Operator</h2><p>求余运算符 <code>%</code> ，返回余数。</p>
<p>求余运算符还可以用于实数以得到实余数 real remainders。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;0.0f % 1.5f is &#123;0&#125;&quot;</span> , <span class="number">0.0f</span> % <span class="number">1.5f</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;0.5f % 1.5f is &#123;0&#125;&quot;</span> , <span class="number">0.5f</span> % <span class="number">1.5f</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;1.0f % 1.5f is &#123;0&#125;&quot;</span> , <span class="number">1.0f</span> % <span class="number">1.5f</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;1.5f % 1.5f is &#123;0&#125;&quot;</span> , <span class="number">1.5f</span> % <span class="number">1.5f</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;2.0f % 1.5f is &#123;0&#125;&quot;</span> , <span class="number">2.0f</span> % <span class="number">1.5f</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;2.5f % 1.5f is &#123;0&#125;&quot;</span> , <span class="number">2.5f</span> % <span class="number">1.5f</span>);</span><br></pre></td></tr></table></figure>
<p>得到：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">0.0f % 1.5f is 0 </span><br><span class="line">0.5f % 1.5f is 0.5 </span><br><span class="line">1.0f % 1.5f is 1 </span><br><span class="line">1.5f % 1.5f is 0 </span><br><span class="line">2.0f % 1.5f is 0.5 </span><br><span class="line">2.5f % 1.5f is 1 </span><br></pre></td></tr></table></figure>
<h2 id="关系比较运算符和相等比较运算符"><a href="#关系比较运算符和相等比较运算符" class="headerlink" title="关系比较运算符和相等比较运算符"></a>关系比较运算符和相等比较运算符</h2><p>关系比较运算符和相等比较运算符是二元运算符，比较它们的操作数并返回 bool 型值，它们都是左结合运算符。包括 <code>&lt;</code> , <code>&gt;</code> , <code>&lt;=</code> , <code>&gt;=</code> , <code>==</code> , <code>!=</code> 。</p>
<blockquote>
<p>与 C 和 C++ 不同，<strong>在 C# 中数字不具有布尔意义</strong>。</p>
</blockquote>
<h3 id="比较操作和相等性操作"><a href="#比较操作和相等性操作" class="headerlink" title="比较操作和相等性操作"></a>比较操作和相等性操作</h3><p>对于大多数引用类型来说，比较它们的相等性时，只比较它们的引用。<br>①如果引用相等，即指向内存中相同的对象，那么相等性比较为 true，否则为 false 。这称为<strong>浅比较 shallow comparison</strong> 。<br>② string 类型对象也是引用类型，但是比较字符串的相等性时，若两个字符串有相同的长度和内容（区分大小写），则返回 true ，即使它们占有不同的内存区域。这称为<strong>深比较 deep comparison</strong> 。</p>
<p>委托也是深比较，见第14章，若两个委托都是 null ，或两者的调用列表中有相同数目的成员，并且调用列表相匹配，则比较返回 true 。</p>
<p>比较数值表达式时，比较类型和值；比较 enum 类型，比较操作数的实际值，枚举见第12章。</p>
<h2 id="递增运算符和递减运算符-Increment-and-Decrement-Operators"><a href="#递增运算符和递减运算符-Increment-and-Decrement-Operators" class="headerlink" title="递增运算符和递减运算符 Increment and Decrement Operators"></a>递增运算符和递减运算符 Increment and Decrement Operators</h2><p>递增运算符和递减运算符是一元的，有2种形式，<strong>前置</strong>形式和<strong>后置</strong>形式，产生不同效果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><font face= "Arial">++</font></td>
<td style="text-align:left">前置递增 <font face= "Arial">++var</font></td>
<td style="text-align:left">变量的值加1并保存，返回变量的新值</td>
</tr>
<tr>
<td style="text-align:left"><font face= "Arial">++</font></td>
<td style="text-align:left">后置递增 <font face= "Arial">var++</font></td>
<td style="text-align:left">变量的值加1并保存，返回变量递增之前的旧值</td>
</tr>
<tr>
<td style="text-align:left"><font face= "Arial">--</font></td>
<td style="text-align:left">前置递减 <font face= "Arial">--var</font></td>
<td style="text-align:left">变量的值减1并保存，返回变量的新值</td>
</tr>
<tr>
<td style="text-align:left"><font face= "Arial">--</font></td>
<td style="text-align:left">后置递减 <font face= "Arial">var--</font></td>
<td style="text-align:left">变量的值减1并保存，返回变量递增之前的旧值</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">表达式：x=10</th>
<th style="text-align:left">返回给表达式的值</th>
<th style="text-align:left">计算后变量的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">前置递增</td>
<td style="text-align:left"><font face= "Arial">++x</font></td>
<td style="text-align:left">11</td>
<td style="text-align:left">11</td>
</tr>
<tr>
<td style="text-align:left">后置递增</td>
<td style="text-align:left"><font face= "Arial">x++</font></td>
<td style="text-align:left">10</td>
<td style="text-align:left">11</td>
</tr>
<tr>
<td style="text-align:left">前置递减</td>
<td style="text-align:left"><font face= "Arial">--x</font></td>
<td style="text-align:left">9</td>
<td style="text-align:left">9</td>
</tr>
<tr>
<td style="text-align:left">后置递减</td>
<td style="text-align:left"><font face= "Arial">x--</font></td>
<td style="text-align:left">10</td>
<td style="text-align:left">9</td>
</tr>
</tbody>
</table>
</div>
<h2 id="条件逻辑运算符-Conditional-Logical-Operators"><a href="#条件逻辑运算符-Conditional-Logical-Operators" class="headerlink" title="条件逻辑运算符 Conditional Logical Operators"></a>条件逻辑运算符 Conditional Logical Operators</h2><p>逻辑运算符包括逻辑与 AND 、逻辑或 OR 、逻辑非 NOT 。逻辑与和逻辑或运算符是二元左结合运算符。逻辑非是一元运算符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;&amp;</td>
<td style="text-align:left">与</td>
<td style="text-align:left">如果两个操作数都是true，结果为true；否则为false</td>
</tr>
<tr>
<td style="text-align:left">&#124;&#124;</td>
<td style="text-align:left">或</td>
<td style="text-align:left">如果至少一个操作数是true，结果为true；否则为false</td>
</tr>
<tr>
<td style="text-align:left">!</td>
<td style="text-align:left">非</td>
<td style="text-align:left">如果操作数是false，结果为true；否则为false</td>
</tr>
</tbody>
</table>
</div>
<p>条件逻辑运算符使用 <strong>“短路” short-circuit</strong> 模式操作，即若计算第一个操作数之后就能确定值，就会跳过第二个操作数的计算。比如下面代码，变量 iVal 的后置递增不会被执行，因为执行了第一个子表达式后，可以确定返回值是 false 。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> bVal; <span class="built_in">int</span> iVal = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    bVal = (<span class="number">1</span> == <span class="number">2</span>) &amp;&amp; (<span class="number">9</span> == iVal++); <span class="comment">//结果：bVal = False, iVal = 10</span></span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算符-Logical-Operators"><a href="#逻辑运算符-Logical-Operators" class="headerlink" title="逻辑运算符 Logical Operators"></a>逻辑运算符 Logical Operators</h2><p>按位逻辑运算符如下表，除按位非运算符以外，这些运算符都是二元左结合运算符，按位非运算符是一元运算符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">位与 Bitwise AND</td>
<td style="text-align:left">仅当两个操作数都为1时，位的结果为1</td>
</tr>
<tr>
<td style="text-align:left">&#124;</td>
<td style="text-align:left">位或 Bitwise OR</td>
<td style="text-align:left">只要任意一个操作数为1时，位的结果为1</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">位异或 Bitwise XOR</td>
<td style="text-align:left">仅当一个而不是两个操作数为1时，位的结果为1</td>
</tr>
<tr>
<td style="text-align:left">~</td>
<td style="text-align:left">位非 Bitwise negation</td>
<td style="text-align:left">得到操作数的二进制反码</td>
</tr>
</tbody>
</table>
</div>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/05/I7cKHLZrNB9sbn4.png" width = "60%" height = "60%" alt="图46 - 按位逻辑操作示例"/>
</div>

<h2 id="移位运算符-Shift-Operators"><a href="#移位运算符-Shift-Operators" class="headerlink" title="移位运算符 Shift Operators"></a>移位运算符 Shift Operators</h2><p>移位运算符是二元左结合运算符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&lt;&lt;</td>
<td style="text-align:left">左移</td>
<td style="text-align:left">将位组向左移动给定数目个位置。位从左边移出并丢失，右边的位位置用0填充</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;</td>
<td style="text-align:left">右移</td>
<td style="text-align:left">将位组向右移动给定数目个位置。位从右边移出并丢失</td>
</tr>
</tbody>
</table>
</div>
<p>底层硬件使用二进制补码 two’s complement 的形式表示有符号二进制数。在二进制补码表示法中，负数最左侧的位位置是1，正数的补码和原码一致，负数的补码是原码的基础上对各个位取反后加1。所以要把一个正数转换成负数，要把这个数按位取反再加1，反之亦然。</p>
<p>位移有符号的数字，左移一位的结果与把它乘以2的结果相同，右移一位的结果和除以2相同。然而如果右移一个负数，最左边位用0填充，会让数字变成正数，为了应对这种情形，当操作数是有符号的整数时，如果操作数最左边的位是1，在左边移开的位位置用1而不是0填充，这保持了正确的二进制补码表示法。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/05/Gf4H6V7msDu5pvt.png" width = "65%" height = "65%" alt="图47 - 移位"/>
</div>

<h2 id="赋值运算符-Assignment-Operators"><a href="#赋值运算符-Assignment-Operators" class="headerlink" title="赋值运算符 Assignment Operators"></a>赋值运算符 Assignment Operators</h2><p>赋值运算符先将运算符右侧的表达式求值，并用该值设置运算符左边的变量的值，故赋值运算符是二元右结合运算符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">简单赋值; 计算右边表达式的值，并把返回值赋给左边的变量或表达式</td>
</tr>
<tr>
<td style="text-align:left">*=</td>
<td style="text-align:left">复合赋值; var *= expr 等价于 var = var * (expr)</td>
</tr>
<tr>
<td style="text-align:left">/=</td>
<td style="text-align:left">复合赋值; var /= expr 等价于 var = var / (expr)</td>
</tr>
<tr>
<td style="text-align:left">%=</td>
<td style="text-align:left">复合赋值; var %= expr 等价于 var= var % (expr)</td>
</tr>
<tr>
<td style="text-align:left">+=</td>
<td style="text-align:left">复合赋值; var += expr 等价于 var = var + (expr)</td>
</tr>
<tr>
<td style="text-align:left">-=</td>
<td style="text-align:left">复合赋值; var -= expr 等价于 var = var- (expr)</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;=</td>
<td style="text-align:left">复合赋值; var &lt;&lt;= expr 等价于 var = var &lt;&lt; (expr)</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;=</td>
<td style="text-align:left">复合赋值; var &gt;&gt;= expr 等价于 var = var &gt;&gt; (expr)</td>
</tr>
<tr>
<td style="text-align:left">&amp;=</td>
<td style="text-align:left">复合赋值; var &amp;= expr 等价于 var = var &amp; (expr)</td>
</tr>
<tr>
<td style="text-align:left">^=</td>
<td style="text-align:left">复合赋值; var ^= expr 等价于 var = var ^ (expr)</td>
</tr>
<tr>
<td style="text-align:left">&#124;=</td>
<td style="text-align:left">复合赋值; var &#124;= expr 等价于 var = var &#124; (expr)</td>
</tr>
</tbody>
</table>
</div>
<p>对于复合赋值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">x += y – z; <span class="comment">//等价于 x = x + (y – z);</span></span><br><span class="line">x *= y – z; <span class="comment">//等价于 x = x * (y – z);</span></span><br><span class="line">x /= y – z; <span class="comment">//等价于 x = x / (y – z);</span></span><br></pre></td></tr></table></figure>
<h2 id="条件运算符-The-Conditional-Operator"><a href="#条件运算符-The-Conditional-Operator" class="headerlink" title="条件运算符 The Conditional Operator"></a>条件运算符 The Conditional Operator</h2><p>条件运算符是三元运算符，语法如下：<code>Condition ? Expression1 : Expression2</code>，包含一个测试表达式和两个结果表达式：<br>① Condition 必须返回一个 bool 类型的值；<br>② 如果 Condition 求值为 true ，那么对 Expression1 求值并返回，否则，对 Expression2 求值并返回；</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( x &lt; y )</span><br><span class="line">    intVar = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    intVar = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>上述代码等价于 <code>intVar = x &lt; y ? 5 : 10;</code>，或者如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">intVar = x &lt; y</span><br><span class="line">        ? <span class="number">5</span></span><br><span class="line">        : <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h2 id="一元算术运算符-Unary-Arithmetic-Operators"><a href="#一元算术运算符-Unary-Arithmetic-Operators" class="headerlink" title="一元算术运算符 Unary Arithmetic Operators"></a>一元算术运算符 Unary Arithmetic Operators</h2><p>就是数学的正负号，比如 <code>int x = +10;</code> <code>int y = -x;</code></p>
<h2 id="用户定义的类型转换"><a href="#用户定义的类型转换" class="headerlink" title="用户定义的类型转换"></a>用户定义的类型转换</h2><p>用户定义的类型转换详见第17章，这里提一下是因为它们是运算符：</p>
<p>可以为自己的类和结构定义隐式转换和显式转换：<br>①对于隐式转换，编译器会根据特定上下文决定使用特定的类型，并进行自动转换；<br>②对于显式转换，编译器只在使用显式转换运算符时才执行转换。</p>
<p>声明隐式转换的语法如下，public 和 static 修饰符是必需的，TargetType 为目标类型，SourceType Identifier 为源数据：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">TargetType</span> (<span class="params"> SourceType Identifier </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ObjectOfTargetType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显式转换语法相同，但用 explicit 替换 implicit 。</p>
<p>隐式转换示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">LimitedInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MaxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MinValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">int</span> (<span class="params">LimitedInt li</span>) <span class="comment">//将LimitedInt转换为int</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> li.TheValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">LimitedInt</span> (<span class="params"><span class="built_in">int</span> x</span>) <span class="comment">//将int转换为LimitedInt</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        LimitedInt li = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        li.TheValue = x;</span><br><span class="line">        <span class="keyword">return</span> li;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> mTheValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TheValue &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> mTheValue; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &lt; MinValue)</span><br><span class="line">                mTheValue = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mTheValue = <span class="keyword">value</span> &gt; MaxValue</span><br><span class="line">                                ? MaxValue</span><br><span class="line">                                : <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LimitedInt li = <span class="number">500</span>; <span class="comment">//将500转换为LimitedInt</span></span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = li; <span class="comment">//将LimitedInt转换为int</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;li: <span class="subst">&#123; li.TheValue &#125;</span>, value: <span class="subst">&#123; <span class="keyword">value</span> &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">li: 100, value: 100</span><br></pre></td></tr></table></figure>
<h3 id="显式转换和转换运算符-Explicit-Conversion-and-the-Cast-Operator"><a href="#显式转换和转换运算符-Explicit-Conversion-and-the-Cast-Operator" class="headerlink" title="显式转换和转换运算符 Explicit Conversion and the Cast Operator"></a>显式转换和转换运算符 Explicit Conversion and the Cast Operator</h3><p>将上述代码改为 explicit ，并且在实现转换时显式使用转换运算符。<strong>转换运算符 cast operator</strong> 由想要把表达式转换成的目标类型的名称组成，放在一对圆括号内：<code>LimitedInt li = (LimitedInt) 500;</code>。改变的部分代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">LimitedInt li</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> li.TheValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">LimitedInt</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LimitedInt li = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">    li.TheValue = x;</span><br><span class="line">    <span class="keyword">return</span> li;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    LimitedInt li = (LimitedInt) <span class="number">500</span>;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">value</span> = (<span class="built_in">int</span>) li;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;li: <span class="subst">&#123; li.TheValue &#125;</span>, value: <span class="subst">&#123; <span class="keyword">value</span> &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">li: 100, value: 100</span><br></pre></td></tr></table></figure>
<blockquote>
<p>is 和 as 运算符接受一种类型的值，并返回另一种不同的、指定类型的值。详见第17章。</p>
</blockquote>
<h2 id="运算符重载-Operator-Overloading"><a href="#运算符重载-Operator-Overloading" class="headerlink" title="运算符重载 Operator Overloading"></a>运算符重载 Operator Overloading</h2><p>C# 运算符被定义为使用预定义类型作为操作数，而<strong>运算符重载</strong>允许定义 C# 运算符应该如何操作自定义类型的操作数。<br>①运算符重载只能用于类和结构；<br>②为类或结构重载一个运算符 x ，可以声明一个名称为 operate x 的方法并实现它的行为：<br>&emsp;&emsp;- 一元运算符的重载方法带有一个单独的 class 或 struct 类型的参数；<br>&emsp;&emsp;- 二元运算符的重载方法带两个参数，其中至少有一个必须是class 或 struct 类型。<br>③运算符重载的方法声明必须同时使用 static 和 public 的修饰符，且运算符必须是要操作的类或结构的成员。  </p>
<h3 id="运算符重载的示例"><a href="#运算符重载的示例" class="headerlink" title="运算符重载的示例"></a>运算符重载的示例</h3><p>以下代码展示了3个运算符的重载：负数、减法和加法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">LimitedInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MaxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MinValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LimitedInt <span class="keyword">operator</span> -(LimitedInt x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取一个值的负数等于0</span></span><br><span class="line">        LimitedInt li = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        li.TheValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> li;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LimitedInt <span class="keyword">operator</span> -(LimitedInt x, LimitedInt y)</span><br><span class="line">    &#123;</span><br><span class="line">        LimitedInt li = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        li.TheValue = x.TheValue - y.TheValue;</span><br><span class="line">        <span class="keyword">return</span> li;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LimitedInt <span class="keyword">operator</span> +(LimitedInt x, <span class="built_in">double</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        LimitedInt li = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        li.TheValue = x.TheValue + (<span class="built_in">int</span>)y;</span><br><span class="line">        <span class="keyword">return</span> li;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _theValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TheValue</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _theValue; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &lt; MinValue)</span><br><span class="line">                _theValue = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                _theValue = <span class="keyword">value</span> &gt; MaxValue</span><br><span class="line">                                ? MaxValue</span><br><span class="line">                                : <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LimitedInt li1 = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        LimitedInt li2 = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        LimitedInt li3 = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        li1.TheValue = <span class="number">10</span>; li2.TheValue = <span class="number">26</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot; li1: <span class="subst">&#123; li1.TheValue &#125;</span>, li2: <span class="subst">&#123; li2.TheValue &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        li3 = -li1;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;-<span class="subst">&#123; li1.TheValue &#125;</span> = <span class="subst">&#123; li3.TheValue &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        li3 = li2 - li1;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot; <span class="subst">&#123; li2.TheValue &#125;</span> - <span class="subst">&#123; li1.TheValue &#125;</span> = <span class="subst">&#123; li3.TheValue &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        li3 = li1 - li2;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot; <span class="subst">&#123; li1.TheValue &#125;</span> - <span class="subst">&#123; li2.TheValue &#125;</span> = <span class="subst">&#123; li3.TheValue &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"> li1: 10, li2: 26</span><br><span class="line">-10 = 0</span><br><span class="line"> 26 - 10 = 16</span><br><span class="line"> 10 - 26 = 0</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载的限制"><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h3><p>不是所有的运算符都能被重载：<br>①可重载的一元运算符：+ , - , ! , ~ , ++ , -- , true , false<br>②可重载的二元运算符：+ , - , * , / , % , &amp; , | , ^ , &lt;&lt; , &gt;&gt; , == , != , &gt; , &lt; , &gt;= , &lt;=</p>
<p>运算符重载不能创建新运算符；不能改变运算符语法；不能重新定义如何处理预定义类型；不能改变运算符的优先级和结合性。</p>
<p>递增运算符和递减运算符也可以重载：<br>①在运行时，代码对对象执行前置操作（递增或递减）时，会发生以下行为：<br>&emsp;&emsp;- 在对象上执行递增或递减代码；<br>&emsp;&emsp;- 返回对象。<br>②在运行时，代码对对象执行后置操作（递增或递减）时，会发生以下行为：<br>&emsp;&emsp;- 如果对象是值对象，则系统会复制该对象；如果对象是引用类型，则引用会被复制；<br>&emsp;&emsp;- 在对象上执行递增或递减代码；<br>&emsp;&emsp;- 返回保存的操作数。</p>
<p>对于引用类型的对象，前置操作没问题。但是对于后置操作，因为保存的副本是引用的副本，即指向同一对象，当执行到第二步操作时，递增或递减代码影响了对象，会导致保存的引用指向的对象不是起始状态。</p>
<p>示例如下，可以运行以下代码2次，第二次将 MyType 的类型改为类，会得到不同结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyType <span class="comment">//运行两次，一个是结构体，一次是类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyType</span>(<span class="params"> <span class="built_in">int</span> x </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyType <span class="keyword">operator</span> ++( MyType m )</span><br><span class="line">    &#123;</span><br><span class="line">        m.X++;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"> <span class="built_in">string</span> message, MyType tv </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WriteLine( <span class="string">$&quot;<span class="subst">&#123;message&#125;</span> <span class="subst">&#123;tv.X&#125;</span>&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyType tv = <span class="keyword">new</span> MyType( <span class="number">10</span> );</span><br><span class="line">        WriteLine( <span class="string">&quot;Pre-increment&quot;</span> );</span><br><span class="line">        Show( <span class="string">&quot;Before &quot;</span>, tv );</span><br><span class="line">        Show( <span class="string">&quot;Returned &quot;</span>, ++tv );</span><br><span class="line">        Show( <span class="string">&quot;After &quot;</span>, tv );</span><br><span class="line">        WriteLine();</span><br><span class="line"></span><br><span class="line">        tv = <span class="keyword">new</span> MyType( <span class="number">10</span> );</span><br><span class="line">        WriteLine( <span class="string">&quot;Post-increment&quot;</span> );</span><br><span class="line">        Show( <span class="string">&quot;Before &quot;</span>, tv );</span><br><span class="line">        Show( <span class="string">&quot;Returned &quot;</span>, tv++ );</span><br><span class="line">        Show( <span class="string">&quot;After &quot;</span>, tv );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Pre-increment</span><br><span class="line">Before  10</span><br><span class="line">Returned  11</span><br><span class="line">After  11</span><br><span class="line"></span><br><span class="line">Post-increment</span><br><span class="line">Before  10</span><br><span class="line">Returned  10</span><br><span class="line">After  11</span><br></pre></td></tr></table></figure>
<p>如果将 MyType 改为类，运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Pre-increment</span><br><span class="line">Before  10</span><br><span class="line">Returned  11</span><br><span class="line">After  11</span><br><span class="line"></span><br><span class="line">Post-increment</span><br><span class="line">Before  10</span><br><span class="line">Returned  11</span><br><span class="line">After  11</span><br></pre></td></tr></table></figure>
<h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><p><strong>typeof 运算符</strong>返回作为其参数的任何类型的 System.Type 对象。通过这个对象可以了解类型的特征。typeof 运算符是一元运算符。</p>
<p>下面是 typeof 运算符语法的示例，Type 是 System 命名空间中的一个类，代码使用了 typeof 运算符以获取 SomeClass 类的信息，并打印出公有字段和方法的名称：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Reflection; <span class="comment">//使用反射命名空间来全面利用检测类型信息的功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Field1;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Field2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Method2</span>()</span> &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type t = <span class="keyword">typeof</span>(SomeClass);</span><br><span class="line">        FieldInfo[] fi = t.GetFields();</span><br><span class="line">        MethodInfo[] mi = t.GetMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (FieldInfo f <span class="keyword">in</span> fi)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Field : <span class="subst">&#123; f.Name &#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (MethodInfo m <span class="keyword">in</span> mi)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Method: <span class="subst">&#123; m.Name &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Field : Field1</span><br><span class="line">Field : Field2</span><br><span class="line">Method: Method1</span><br><span class="line">Method: Method2</span><br><span class="line">Method: GetType</span><br><span class="line">Method: ToString</span><br><span class="line">Method: Equals</span><br><span class="line">Method: GetHashCode</span><br></pre></td></tr></table></figure>
<p><strong>GetType</strong> 方法也会调用 typeof 运算符，该方法对每个类型的每个对象都有效，示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SomeClass s = <span class="keyword">new</span> SomeClass();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Type s: <span class="subst">&#123; s.GetType().Name &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Type s: SomeClass</span><br></pre></td></tr></table></figure>
<h2 id="nameof-运算符"><a href="#nameof-运算符" class="headerlink" title="nameof 运算符"></a>nameof 运算符</h2><p><strong>nameof 运算符</strong>返回一个表示传入参数的字符串，以下示例展示了可以作为参数传递给 nameof 运算符的不同项，注释的括号里是每个语句的输出：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> var1 = <span class="string">&quot;Local Variable&quot;</span>;</span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (var1)); <span class="comment">//局部变量(&quot;var1&quot;)</span></span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (MyClass)); <span class="comment">//类(&quot;MyClass&quot;)</span></span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (MyClass.Method1)); <span class="comment">//公有方法(&quot;Method1&quot;)</span></span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (parameter1)); <span class="comment">//方法参数(&quot;parameter1&quot;)</span></span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (MyClass.Property1)); <span class="comment">//公有属性(&quot;Property1&quot;)</span></span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (MyClass.Field1)); <span class="comment">//公有字段(&quot;Field1&quot;)</span></span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (MyStruct)); <span class="comment">//结构体(&quot;MyStruct &quot;)</span></span><br></pre></td></tr></table></figure>
<p>即使参数使用完全限定名，nameof 运算符也只返回其参数的非限定名称。</p>
<p>nameof 运算符主要用于代码名称会变更的时候。</p>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p>以上介绍的运算符都是内置类型的标准运算符，后面还有一些特殊用法的运算符。</p>
<h1 id="第十章-语句"><a href="#第十章-语句" class="headerlink" title="第十章 语句"></a>第十章 语句</h1><h2 id="什么是语句"><a href="#什么是语句" class="headerlink" title="什么是语句"></a>什么是语句</h2><p><strong>语句 statement</strong> 是描述某个类型或让程序执行某个动作的源代码指令。语句主要有3种类型：<br>①<strong>声明语句 Declaration statements</strong> ：声明类型或变量；<br>②<strong>嵌入语句 Embedded statements</strong> ：执行动作或管理控制流；<br>③<strong>标签语句 Labeled statements</strong> ：控制跳转。</p>
<p><strong>块</strong>是由一对大括号括起来的语句序列，括起来的语句可以包括：声明语句、嵌入语句、标签语句和嵌套块。块在语法上算作一个单条嵌入语句。任何语法上需要一个嵌入语句的地方，都可以使用块。</p>
<p><strong>简单语句</strong>由一个表达式和后面跟着的分号组成。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">10</span>; <span class="comment">//简单声明</span></span><br><span class="line"><span class="built_in">int</span> z; <span class="comment">//简单声明</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">//块</span></span><br><span class="line">    <span class="built_in">int</span> y = <span class="number">20</span>; <span class="comment">//简单声明</span></span><br><span class="line">    z = x + y; <span class="comment">//嵌入语句</span></span><br><span class="line">top: y = <span class="number">30</span>; <span class="comment">//标签语句</span></span><br><span class="line">        ...</span><br><span class="line">    &#123; <span class="comment">//嵌套块</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="comment">//结束嵌套块</span></span><br><span class="line">&#125; <span class="comment">//结束外部块</span></span><br></pre></td></tr></table></figure>
<p><strong>空语句</strong>仅由一个分号组成，一般用在语法需要一条嵌入语句，但又不需要它有任何动作，示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( x &lt; y )</span><br><span class="line">    ; <span class="comment">//空语句</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    z = a + b; <span class="comment">//简单语句</span></span><br></pre></td></tr></table></figure>
<h2 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h2><p>可以在表达式后面放置语句终结符（分号）来从一个表达式创建一条语句，表达式返回的任何值都会被丢弃。比如：<code>x = 10;</code> 该表达式把运算符右边的值赋给变量 x 引用的内存位置，设置了 x 的值后，表达式返回 x 的新值，然后因为没有东西接受该值，该值被忽略。</p>
<h2 id="控制流语句-Flow-of-Control-Statements"><a href="#控制流语句-Flow-of-Control-Statements" class="headerlink" title="控制流语句 Flow-of-Control Statements"></a>控制流语句 Flow-of-Control Statements</h2><p><strong>条件执行语句 Conditional execution statements</strong> 包括：<code>if</code> , <code>if...else</code> , <code>switch</code> ;<br><strong>循环语句 Looping statements</strong> 包括：<code>while</code> , <code>do</code> , <code>for</code> , <code>foreach</code> ;<br><strong>跳转语句 Jump statements</strong> 包括：<code>break</code> , <code>continue</code> , <code>return</code> , <code>goto</code> , <code>throw</code> ;</p>
<blockquote>
<p>与 C 和 C++ 不同，数字在 C# 没有布尔意义。</p>
</blockquote>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p><strong>if 语句</strong>实现按条件执行：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( TestExpr )</span><br><span class="line">    Statement</span><br></pre></td></tr></table></figure>
<p>①TestExpr 必须计算成 bool 型值；<br>②如果 TestExpr 求值为 true ，执行 Statement ；<br>③如果求值为 false ，则跳过 Statement 。</p>
<p>示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单语句</span></span><br><span class="line"><span class="keyword">if</span>( x &lt;= <span class="number">10</span> )</span><br><span class="line">    z = x – <span class="number">1</span>; <span class="comment">//简单语句不需要大括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//块</span></span><br><span class="line"><span class="keyword">if</span>( x &gt;= <span class="number">20</span> )</span><br><span class="line">&#123;</span><br><span class="line">    x = x – <span class="number">5</span>; <span class="comment">//块需要大括号</span></span><br><span class="line">    y = x + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>( x ) <span class="comment">//错误：表达式必须是bool型，而不是int型</span></span><br><span class="line">&#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a>if…else 语句</h2><p><strong>if…else 语句</strong>实现双路分支：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( TestExpr )</span><br><span class="line">    Statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Statement2</span><br></pre></td></tr></table></figure>
<p>①如果 TestExpr 求值为 true，执行 Statement1 。<br>②如果求值为 false，执行 Statement2 .</p>
<p>示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( x &lt;= <span class="number">10</span> )</span><br><span class="line">    z = x – <span class="number">1</span>; <span class="comment">//简单语句</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    x = x – <span class="number">5</span>; <span class="comment">//多条语句组成的语句块</span></span><br><span class="line">    y = x + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Statement1 和 Statement2 可以嵌套 if 或 if…else 语句。当 Statement2 是 if 或 if…else 语句，常常会格式化为下面的形式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( TestExpr1 )</span><br><span class="line">    <span class="function">Statement1</span></span><br><span class="line"><span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params"> TestExpr2 </span>)</span></span><br><span class="line"><span class="function">    Statement2</span></span><br><span class="line"><span class="function"><span class="keyword">else</span></span></span><br><span class="line"><span class="function">    Statement3</span></span><br></pre></td></tr></table></figure>
<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p><strong>while 循环</strong>是一种简单循环结构，其测试表达式在循环顶部执行：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( TestExpr )</span><br><span class="line">    Statement</span><br></pre></td></tr></table></figure>
<p>①若 TestExpr 求值为 true 时，执行 Statement，并且再次对 TestExpr 求值，直到 TestExpr 求值为 false ；<br>②若 TestExpr 求值为 false，执行在 while 循环结尾之后的语句。</p>
<p>示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;x: <span class="subst">&#123; x &#125;</span>&quot;</span>);</span><br><span class="line">    x--;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Out of loop&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="do-循环"><a href="#do-循环" class="headerlink" title="do 循环"></a>do 循环</h2><p><strong>do 循环</strong>是一种简单循环结构，其测试表达式在循环底部执行：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">    Statement</span></span><br><span class="line"><span class="function"><span class="title">while</span>(<span class="params"> TestExpr </span>)</span>; <span class="comment">//结束do循环，别忘了分号</span></span><br></pre></td></tr></table></figure>
<p>①首先执行 Statement ；<br>②然后，对 TestExpr 求值。若为 true，再次执行 Statement，再重复，直到返回 false ，控制传递到循环结构结尾之后的语句。</p>
<p>示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;x is <span class="subst">&#123;x++ &#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (x&lt;<span class="number">3</span>); <span class="comment">//分号是必需的，别忘了</span></span><br></pre></td></tr></table></figure>
<h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>只要测试表达式在循环体顶端计算时返回 true，for循环结构就会执行循环体：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( Initializer ; TestExpr ; IterationExpr )</span><br><span class="line">    Statement</span><br></pre></td></tr></table></figure>
<p>①在 for 循环开始时，执行一次 Initializer 。Initializer 只执行一次，常用于声明和初始化循环中使用的局部变量；<br>②然后对 TestExpr 求值，若为 true ，执行 Statement ，接着执行 IterationExpr 。接着控制回到循环顶端，再次对 TestExpr 求值，重复步骤，直到返回 false ，执行循环之后的语句；<br>③ Initializer 、TestExpr 和 IterationExpr 都是可选的。若 TestExpr 为空，测试返回 true ，会进入无限循环，需要有退出该语句的方法。作为字段分隔符，两个分号是必须的，即使省略了上述部分。</p>
<p>示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行3次for循环体</span></span><br><span class="line"><span class="keyword">for</span>( <span class="built_in">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">3</span> ; i++ )</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Inside loop. i: <span class="subst">&#123; i &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Out of Loop&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="for-语句中变量的作用域"><a href="#for-语句中变量的作用域" class="headerlink" title="for 语句中变量的作用域"></a>for 语句中变量的作用域</h3><p>任何声明在 initializer 中的变量只在该 for 语句的内部可见，和 C 和 C++ 不同。</p>
<blockquote>
<p>循环变量常常使用标识符 i、j、k 。</p>
</blockquote>
<h3 id="初始化和迭代表达式中的多表达式"><a href="#初始化和迭代表达式中的多表达式" class="headerlink" title="初始化和迭代表达式中的多表达式"></a>初始化和迭代表达式中的多表达式</h3><p>初始化表达式和迭代表达式都可以包含多个表达式，只需要用逗号隔开，示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MaxI = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, j = <span class="number">10</span>; i &lt; MaxI; i++, j += <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; i &#125;</span>, <span class="subst">&#123; j &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><p>switch 语句实现多路分支：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>( TestExpr )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> Expr1:</span><br><span class="line">        StatementList</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ···</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> ExprN:</span><br><span class="line">        StatementList</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">        StatementList</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①switch 语句有一个被称为<strong>测试表达式</strong>或<strong>匹配表达式</strong>的参数，C# 7.0 后允许测试表达式为任何类型；<br>②switch 语句包含0个或多个<strong>分支块 switch sections</strong> ；<br>③每个分支块都以一个或多个<strong>分支标签 switch labels</strong>开头，switch 标签形式：<code>case PatternExpression:</code> ，case 为关键字，冒号为分支标签结束符。每个分支标签后面跟着一个模式表达式，该模式表达式与测试表达式比较。如果模式表达式和测试表达式都是整数类型，使用 C# 的相对运算符 == 进行比较。在所有其他情况下，则使用静态方法 Object.Equals(test, pattern) 进行比较，即对于非整数类型，C# 使用深度比较。在 C# 7.0 之前，case 后面的表达式必须是常量表达式ConstantExpression，必须在编译时被编译器计算，现在这个约束不适用。<br>④每个分支块遵循“不穿过规则”，即表达语句不能到达终点并且进入下一个分支，一般使用<strong>跳转语句</strong>来结束表达语句列表，包括 break 、return 、continue 、goto 和 throw 。goto 跳转语句不能与非常量 switch 表达式一起使用。<br>⑤分支块会按顺序执行。如果其中一个分支块与测试表达式的值匹配，则执行这个分支块，然后控制流会跳转到该分支块中使用的跳转语句指定的位置。由于 break 语句是最常用的跳转语句，所以通常控制流会跳转到 switch 语句结束后的代码。<br>⑥一个switch 语句可以有任意数目的分支，也可以没有分支。default 分支是可选的，若包括了，也要以一条跳转语句结束。拥有 default 是好习惯，因为它可以捕获潜在错误。</p>
<h3 id="分支示例"><a href="#分支示例" class="headerlink" title="分支示例"></a>分支示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="built_in">int</span> x=<span class="number">1</span>; x&lt;<span class="number">6</span>; x++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>( x ) <span class="comment">//计算变量x的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//如果x=2</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;x is <span class="subst">&#123; x &#125;</span> -- In Case 2&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//结束switch语句</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">//如果x=5</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;x is <span class="subst">&#123; x &#125;</span> -- In Case 5&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//结束switch语句</span></span><br><span class="line">        </span><br><span class="line">        <span class="literal">default</span>: <span class="comment">//如果x既不等于2也不等于5</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;x is <span class="subst">&#123; x &#125;</span> -- In Default case&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//结束switch语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他类型的模式表达式"><a href="#其他类型的模式表达式" class="headerlink" title="其他类型的模式表达式"></a>其他类型的模式表达式</h3><p><strong>case 标签</strong>由<strong>关键字 case</strong> 和其后面的模式构成，模式可以是简单的值，或者表达式，也可以是一个类型。模式也可以使用<strong>关键字 when</strong> 来包含一个过滤器。</p>
<p>示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Square</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Side &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Radius &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Triangle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Height &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> shapes = <span class="keyword">new</span> List&lt;Shape&gt;();</span><br><span class="line">        shapes.Add(<span class="keyword">new</span> Circle() &#123; Radius = <span class="number">7</span> &#125;);</span><br><span class="line">        shapes.Add(<span class="keyword">new</span> Square() &#123; Side = <span class="number">5</span> &#125;);</span><br><span class="line">        shapes.Add(<span class="keyword">new</span> Triangle() &#123; Height = <span class="number">4</span> &#125;);</span><br><span class="line">        <span class="keyword">var</span> nullSquare = (Square)<span class="literal">null</span>;</span><br><span class="line">        shapes.Add(nullSquare);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> shape <span class="keyword">in</span> shapes )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>( shape ) <span class="comment">//判断类型或者shape变量的值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> Circle circle: <span class="comment">//等价于 if(shape is Circle)</span></span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;This shape is a circle of radius <span class="subst">&#123; circle.Radius &#125;</span>&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Square square <span class="keyword">when</span> square.Side &gt; <span class="number">10</span>: <span class="comment">//仅仅匹配一部分Square</span></span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;This shape is a large square of side <span class="subst">&#123; square.Side &#125;</span>&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Square square:</span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;This shape is a square of side <span class="subst">&#123; square.Side &#125;</span>&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Triangle triangle: <span class="comment">//等价于 if(shape is Triangle)</span></span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;This shape is a triangle of side <span class="subst">&#123; triangle.Height &#125;</span>&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//case Triangle triangle when triangle.Height &lt; 5: //编译错误</span></span><br><span class="line">                    <span class="comment">//Console.WriteLine($&quot;This shape is a triangle of side &#123; triangle.Height &#125;&quot;);</span></span><br><span class="line">                    <span class="comment">//break;</span></span><br><span class="line">                <span class="keyword">case</span> <span class="literal">null</span>:</span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;This shape could be a Square, Circle or a Triangle&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(</span><br><span class="line">                        message: <span class="string">&quot;shape is not a recognized shape&quot;</span>,</span><br><span class="line">                        paramName: <span class="keyword">nameof</span>(shape));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">This shape is a circle of radius 7</span><br><span class="line">This shape is a square of side 5</span><br><span class="line">This shape is a triangle of side 4</span><br><span class="line">This shape could be a Square, Circle or a Triangle</span><br></pre></td></tr></table></figure>
<p>上面注释掉的代码会导致编译错误，因为永远到达不了这个case，它是前一个一般 case 的受限的 case 。</p>
<h3 id="switch-语句的补充"><a href="#switch-语句的补充" class="headerlink" title="switch 语句的补充"></a>switch 语句的补充</h3><p>C# 允许把多个分支标签附加到任意分支，只要这些分支标签之间没有插入可执行语句。示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>( x )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//可接受的</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//如果x等于1、2、3，则执行该代码</span></span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        y = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//因为没有break，所以不可以接受</span></span><br><span class="line">        ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果在同一分支存在多个模式，因为无法确定匹配的是哪个模式，所以不能在构成该块的语句中使用这些变量，可能会导致空引用异常，比如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> Square s:</span><br><span class="line"><span class="keyword">case</span> Circle c:</span><br><span class="line">    Console.WriteLine($“Square has dimensions: &#123; s.Side &#125; x &#123; s.Side &#125;”);</span><br><span class="line">    Console.WriteLine($“Found a Circle of radius &#123; c.Radius &#125;”);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>还有就是虽然结束分支块的最常用方法是使用5个跳转语句中的一个，但是也可以不用，当某个结构可以使语句列表满足“不穿过规则”时，即不直接进入下一个分支块，编译器是可以检测到的。</p>
<h2 id="跳转语句-Jump-Statements"><a href="#跳转语句-Jump-Statements" class="headerlink" title="跳转语句 Jump Statements"></a>跳转语句 Jump Statements</h2><p>当控制流到达<strong>跳转语句</strong>时，程序执行被无条件地转移至程序的另一部分，包括：<code>break</code> , <code>continue</code> , <code>return</code> , <code>goto</code> , <code>throw</code> 。throw 语句详见第23章。</p>
<h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><p><strong>break 语句</strong>可以被用在 switch 、for 、foreach 、while 、do 语句中。在这些语句体中，break 会导致执行跳出<strong>最内层封装语句 the innermost enclosing loop</strong> 。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( <span class="literal">true</span> )</span><br><span class="line">&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">if</span>( x &gt;= <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h2><p><strong>continue 语句</strong>可以被用在 for 、foreach 、while 、do 语句中。在这些语句体中，continue 会导致执行转到<strong>最内层封装语句 the innermost enclosing loop</strong> 的顶端。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="built_in">int</span> x=<span class="number">0</span>; x&lt;<span class="number">5</span>; x++ ) <span class="comment">//执行循环5次</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( x &lt; <span class="number">3</span> ) <span class="comment">//先执行3次</span></span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">//直接回到循环开始处</span></span><br><span class="line">    <span class="comment">//当x&gt;=3时执行下面语句</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Value of x is <span class="subst">&#123; x &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标签语句-Labeled-Statements"><a href="#标签语句-Labeled-Statements" class="headerlink" title="标签语句 Labeled Statements"></a>标签语句 Labeled Statements</h2><p><strong>标签语句</strong>由一个标识符后面跟着一个冒号和语句组成：<code>Identifier: Statement</code> 。</p>
<p>标签语句的执行如同标签不存在一样，仅执行 Statement 部分：<br>①给语句增加一个标签允许控制从代码的其他部分转移到该语句；<br>②标签语句只允许用在块内部。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>标签有自己的命名空间，标签语句的标识符可以是任何有效的标识符，包括局部变量或参数名。但标识符不能是关键字，也不能在重叠范围内和另一个标签标识符相同。</p>
<p>下面代码展示了标签的有效使用，该标签和一个局部变量有相同的标识符：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> xyz = <span class="number">0</span>; <span class="comment">//变量xyz</span></span><br><span class="line">        ...</span><br><span class="line">    xyz: Console.WriteLine(<span class="string">&quot;No problem.&quot;</span>); <span class="comment">//标签xyz</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标签语句的作用域"><a href="#标签语句的作用域" class="headerlink" title="标签语句的作用域"></a>标签语句的作用域</h3><p>标签语句的作用域为：它声明所在的块；任何嵌套在该块内部的块。标签语句在其声明所在块的外部不可见或不可访问。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123; <span class="comment">//作用域A</span></span><br><span class="line">    &#123; <span class="comment">//作用域B</span></span><br><span class="line">        increment: x++;</span><br><span class="line">        &#123; <span class="comment">//作用域C</span></span><br><span class="line"></span><br><span class="line">            &#123; <span class="comment">//作用域D</span></span><br><span class="line">                ···</span><br><span class="line">            &#125;</span><br><span class="line">            &#123; <span class="comment">//作用域E</span></span><br><span class="line">                ···</span><br><span class="line">            &#125;</span><br><span class="line">            ···</span><br><span class="line">        &#125;</span><br><span class="line">        end: Console.WriteLine(<span class="string">&quot;Exiting&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①2个标签语句的有效代码区域为作用域B及以内；<br>②作用域B和所有嵌套块中的代码都能看到并访问标签语句；<br>③从作用域内部的任何位置，代码都能跳出到标签语句；<br>④作用域A的代码不能跳入到标签语句的块中。</p>
<h2 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h2><p><strong>goto 语句</strong>无条件地将控制转移到一个<strong>标签语句</strong>，一般形式：<code>goto Identifier ;</code> ，其中 Identifier 是标签语句的标识符。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> thingsAreFine;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    thingsAreFine = GetNuclearReactorCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( thingsAreFine )</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Things are fine.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> NotSoGood;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NotSoGood: Console.WriteLine(<span class="string">&quot;We have a problem.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>goto 语句必须在标签语句的作用域之内：<br>①goto 语句可以跳到它所在块内的任何标签语句，或跳出到任何嵌套它的块内的标签语句；<br>②goto 语句不能跳入嵌套在其所在块内部的任何块。</p>
<blockquote>
<p>尽量不使用 goto 语句，它会导致弱结构化、难以调试和维护的代码。</p>
</blockquote>
<h3 id="switch-语句内部的-goto-语句"><a href="#switch-语句内部的-goto-语句" class="headerlink" title="switch 语句内部的 goto 语句"></a>switch 语句内部的 goto 语句</h3><p>goto 语句也可以把控制转到 switch 语句内部的分支标签，但是 goto 标签只能引用编译时常量，如同 C# 7.0 之前的 switch 语句一样。形式如下：</p>
<p><code>goto case ConstantExpression;</code><br><code>goto default;</code><br><code>goto case PatternExpression; //编译错误</code></p>
<h2 id="using-语句"><a href="#using-语句" class="headerlink" title="using 语句"></a>using 语句</h2><p>某些类型的非托管对象有数量限制或很耗费系统资源，在代码适用完它们后，尽快释放它们很重要。<strong>using 语句</strong>有助于简化该过程并确保这些资源被适当地处置。</p>
<p><strong>资源</strong>是指实现了 System.IDisposable 接口的类或结构，接口详见第16章，简单来说，接口就是未实现的函数成员的集合，类和结构可以选择去实现它们。IDisposable 接口含有单独一个名称为 Dispose 的方法。</p>
<p>使用资源的阶段如下图，包括分配资源；使用资源；处置资源：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/07/Vb2FD1TpHiBUE9G.png" width = "55%" height = "55%" alt="图48 - 使用资源的阶段"/>
</div>

<blockquote>
<p>区分 using 语句和 using 指令（比如使用 System.Math;），using 指令见第22章。</p>
</blockquote>
<h3 id="包装资源的使用"><a href="#包装资源的使用" class="headerlink" title="包装资源的使用"></a>包装资源的使用</h3><p>using 语句帮助减少意外的运行时错误（即异常，见第23章）带来的潜在问题，整洁地包装了资源的使用。有两种形式的 using 语句。</p>
<p>第一种形式：<code>using ( ResourceType Identifier = Expression ) Statement</code><br>①圆括号内的代码分配资源；<br>②Statement 是使用资源的代码；<br>③using 语句隐式地产生处置资源的代码。</p>
<p>处理可能的异常的标准方法是把可能导致异常的代码放入一个 try 块里，并把任何无论有没有异常都执行的代码放进一个 finally 块中。这种形式的 using 语句就是这么做的，先分配资源，再把 Statement 放进 try 块，最后创建资源的 Dispose 方法的调用，并放进 finally 块，见下图：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/07/DXOR5fV387KYo2W.png" width = "70%" height = "70%" alt="图49 - using语句的效果"/>
</div>

<h3 id="using-语句的示例"><a href="#using-语句的示例" class="headerlink" title="using 语句的示例"></a>using 语句的示例</h3><p>TextWriter 和 TextReader 的类，来自 System.IO 命名空间，都实现了 IDisposable 接口，这是 using 语句的要求：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System; <span class="comment">//using指令，不是using语句</span></span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UsingStatement</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (TextWriter tw = File.CreateText(<span class="string">&quot;Lincoln.txt&quot;</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">            tw.WriteLine(<span class="string">&quot;Four score and seven years ago, ...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (TextReader tr = File.OpenText(<span class="string">&quot;Lincoln.txt&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> InputString;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">null</span> != (InputString = tr.ReadLine()))</span><br><span class="line">                Console.WriteLine(InputString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Four score and seven years ago, ...</span><br></pre></td></tr></table></figure>
<h3 id="多个资源和嵌套"><a href="#多个资源和嵌套" class="headerlink" title="多个资源和嵌套"></a>多个资源和嵌套</h3><p>using 语句可以使用相同类型的多个资源，资源声明用逗号隔开：<code>using ( ResourceType Id1 = Expr1, Id2 = Expr2, ... ) EmbeddedStatement</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (TextWriter tw1 = File.CreateText(<span class="string">&quot;Lincoln.txt&quot;</span>),</span><br><span class="line">                      tw2 = File.CreateText(<span class="string">&quot;Franklin.txt&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        tw1.WriteLine(<span class="string">&quot;Four score and seven years ago, ...&quot;</span>);</span><br><span class="line">        tw2.WriteLine(<span class="string">&quot;Early to bed; Early to rise ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (TextReader tr1 = File.OpenText(<span class="string">&quot;Lincoln.txt&quot;</span>),</span><br><span class="line">                      tr2 = File.OpenText(<span class="string">&quot;Franklin.txt&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> InputString;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">null</span> != (InputString = tr1.ReadLine()))</span><br><span class="line">            Console.WriteLine(InputString);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">null</span> != (InputString = tr2.ReadLine()))</span><br><span class="line">            Console.WriteLine(InputString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using 语句还可以嵌套：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ( TextWriter tw1 = File.CreateText(<span class="string">&quot;Lincoln.txt&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    tw1.WriteLine(<span class="string">&quot;Four score and seven years ago, ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ( TextWriter tw2 = File.CreateText(<span class="string">&quot;Franklin.txt&quot;</span>) ) <span class="comment">//嵌套语句</span></span><br><span class="line">        tw2.WriteLine(<span class="string">&quot;Early to bed; Early to rise ...&quot;</span>); <span class="comment">//简单语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="using-语句的另外一种形式"><a href="#using-语句的另外一种形式" class="headerlink" title="using 语句的另外一种形式"></a>using 语句的另外一种形式</h3><p>语法：<code>using ( Expression ) EmbeddedStatement</code>，在这种形式中，资源在 using 语句之前声明。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">TextWriter tw = File.CreateText(<span class="string">&quot;Lincoln.txt&quot;</span>); <span class="comment">//声明资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ( tw )</span><br><span class="line">    tw.WriteLine(<span class="string">&quot;Four score and seven years ago, ...&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这种形式不推荐，见下图：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/07/xXTcoYRzK7fOi9d.png" width = "70%" height = "70%" alt="图50 - 资源声明在using语句之前"/>
</div>

<h2 id="其他语句"><a href="#其他语句" class="headerlink" title="其他语句"></a>其他语句</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语句</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">相关章节</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">checked, unchecked</td>
<td style="text-align:left">控制溢出检查上下文</td>
<td style="text-align:left">第17章</td>
</tr>
<tr>
<td style="text-align:left">foreach</td>
<td style="text-align:left">遍历一个集合的每个成员</td>
<td style="text-align:left">第13和19章</td>
</tr>
<tr>
<td style="text-align:left">try, throw, finally</td>
<td style="text-align:left">处理异常</td>
<td style="text-align:left">第23章</td>
</tr>
<tr>
<td style="text-align:left">return</td>
<td style="text-align:left">将控制返回到调用函数的成员，而且还能返回一个值</td>
<td style="text-align:left">第6章</td>
</tr>
<tr>
<td style="text-align:left">yield</td>
<td style="text-align:left">用于迭代</td>
<td style="text-align:left">第19章</td>
</tr>
</tbody>
</table>
</div>
<h1 id="第十一章-结构"><a href="#第十一章-结构" class="headerlink" title="第十一章 结构"></a>第十一章 结构</h1><h2 id="什么是结构"><a href="#什么是结构" class="headerlink" title="什么是结构"></a>什么是结构</h2><p><strong>结构 struct</strong> 是用户定义的数据类型，跟类类似，也有数据成员和函数成员，与类的最重要区别包括：<br>①类是引用类型，而结构是值类型；<br>②结构是隐式密封的，即不能从它们派生其他结构。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Point first, second, third;</span><br><span class="line"></span><br><span class="line">        first.X = <span class="number">10</span>; first.Y = <span class="number">10</span>;</span><br><span class="line">        second.X = <span class="number">20</span>; second.Y = <span class="number">20</span>;</span><br><span class="line">        third.X = first.X + second.X;</span><br><span class="line">        third.Y = first.Y + second.Y;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;first: <span class="subst">&#123; first.X &#125;</span>, <span class="subst">&#123; first.Y &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;second: <span class="subst">&#123; second.X &#125;</span>, <span class="subst">&#123; second.Y &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;third: <span class="subst">&#123; third.X &#125;</span>, <span class="subst">&#123; third.Y &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构是值类型"><a href="#结构是值类型" class="headerlink" title="结构是值类型"></a>结构是值类型</h2><p>因为结构是值类型，因此：<br>①结构类型的变量不能为 null ；<br>②两个结构变量不能引用同一对象。</p>
<p>以下示例和图展示了类变量和结构变量的内存安排：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CSimple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Simple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CSimple cs = <span class="keyword">new</span> CSimple();</span><br><span class="line">        Simple ss = <span class="keyword">new</span> Simple();</span><br><span class="line">            ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/09/aVAIuwlSvWsLTYi.png" width = "50%" height = "50%" alt="图51 - 类与结构的内存安排"/>
</div>

<h2 id="对结构赋值"><a href="#对结构赋值" class="headerlink" title="对结构赋值"></a>对结构赋值</h2><p>把一个结构赋值给另一个结构，就是将一个结构的值复制给另一个结构。这和复制类变量不同，复制类变量时只复制引用。示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CSimple</span></span><br><span class="line">&#123; <span class="keyword">public</span> <span class="built_in">int</span> X; <span class="keyword">public</span> <span class="built_in">int</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Simple</span><br><span class="line">&#123; <span class="keyword">public</span> <span class="built_in">int</span> X; <span class="keyword">public</span> <span class="built_in">int</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CSimple cs1 = <span class="keyword">new</span> CSimple(), cs2 = <span class="literal">null</span>; <span class="comment">//类实例</span></span><br><span class="line">        Simple ss1 = <span class="keyword">new</span> Simple(), ss2 = <span class="keyword">new</span> Simple(); <span class="comment">//结构实例</span></span><br><span class="line"></span><br><span class="line">        cs1.X = ss1.X = <span class="number">5</span>; <span class="comment">//将5赋值ss1.X和cs1.X</span></span><br><span class="line">        cs1.Y = ss1.Y = <span class="number">10</span>; <span class="comment">//将10赋值ss1.Y和cs1.Y</span></span><br><span class="line"></span><br><span class="line">        cs2 = cs1; <span class="comment">//赋值类实例</span></span><br><span class="line">        ss2 = ss1; <span class="comment">//赋值结构实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/09/ybqUXVh7xHSclgw.png" width = "70%" height = "70%" alt="图52 - 类变量和结构变量赋值"/>
</div>

<h2 id="构造函数和析构函数-Constructors-and-Destructors"><a href="#构造函数和析构函数-Constructors-and-Destructors" class="headerlink" title="构造函数和析构函数 Constructors and Destructors"></a>构造函数和析构函数 Constructors and Destructors</h2><p>结构可以有实例构造函数和静态构造函数，但不允许有析构函数。</p>
<h3 id="实例构造函数-Instance-Constructors"><a href="#实例构造函数-Instance-Constructors" class="headerlink" title="实例构造函数 Instance Constructors"></a>实例构造函数 Instance Constructors</h3><p>语言隐式地为每个结构提供一个无参数的结构函数，这个构造函数把结构的每个成员设置为该类型的默认值，即值成员设置为它们的默认值，引用成员设置为 null 。</p>
<p>对于每个结构，都存在预定义的无参数构造函数，可以创建另外的构造函数，只要有参数。这和类不同，对于类，编译器只在没有声明其他构造函数时提供隐式的无参数构造函数。</p>
<p>调用构造函数，包括隐式无参数构造函数，要使用 new 运算符，即使不从堆中分配内存。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Simple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Simple</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>) <span class="comment">//带有参数的构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        X = a;</span><br><span class="line">        Y = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Simple s1 = <span class="keyword">new</span> Simple(); <span class="comment">//调用隐式构造函数</span></span><br><span class="line">        Simple s2 = <span class="keyword">new</span> Simple(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">//调用构造函数</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; s1.X &#125;</span>,<span class="subst">&#123; s1.Y &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; s2.X &#125;</span>,<span class="subst">&#123; s2.Y &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">0,0</span><br><span class="line">5,10</span><br></pre></td></tr></table></figure>
<p>也可以不使用 new 运算符创建结构的实例，但是：<br>①在显示地设置数据成员后，才能使用它们的值；<br>②在对所有数据成员赋值之后，才能调用结构的函数成员。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Simple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Simple s1, s2; <span class="comment">//没有调用构造函数</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>, s1.X, s1.Y); <span class="comment">//因为没有赋值，所以编译错误</span></span><br><span class="line"></span><br><span class="line">        s2.X = <span class="number">5</span>;</span><br><span class="line">        s2.Y = <span class="number">10</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; s2.X &#125;</span>,<span class="subst">&#123; s2.Y &#125;</span>&quot;</span>); <span class="comment">//没问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态构造函数-Static-Constructors"><a href="#静态构造函数-Static-Constructors" class="headerlink" title="静态构造函数 Static Constructors"></a>静态构造函数 Static Constructors</h3><p>与类相似，结构的静态构造函数创建并初始化静态数据成员，而且不能引用实例成员。结构的静态构造函数与类类似，但允许有不带参数的静态构造函数。</p>
<p>以下行为，任意一种发生前，会调用静态构造函数：<br>①调用显式声明的构造函数；<br>②引用结构的静态成员。</p>
<h3 id="构造函数和析构函数小结"><a href="#构造函数和析构函数小结" class="headerlink" title="构造函数和析构函数小结"></a>构造函数和析构函数小结</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">实例构造函数（无参数）</td>
<td style="text-align:left">不能在程序中声明。系统为所有结构提供一个隐式的构造函数，不能被程序删除或重定义</td>
</tr>
<tr>
<td style="text-align:left">实例构造函数（有参数）</td>
<td style="text-align:left">可以在程序中声明</td>
</tr>
<tr>
<td style="text-align:left">静态构造函数</td>
<td style="text-align:left">可以在程序中声明</td>
</tr>
<tr>
<td style="text-align:left">析构函数</td>
<td style="text-align:left">不能在程序中声明。不允许声明析构函数</td>
</tr>
</tbody>
</table>
</div>
<h2 id="属性和字段初始化语句"><a href="#属性和字段初始化语句" class="headerlink" title="属性和字段初始化语句"></a>属性和字段初始化语句</h2><p>在声明结构体时，不允许使用实例属性和字段初始化语句。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Simple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x = <span class="number">0</span>; <span class="comment">//不允许，编译错误</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> y = <span class="number">10</span>; <span class="comment">//不允许，编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> prop1 &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125; = <span class="number">5</span>; <span class="comment">//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是结构体的静态属性和静态字段都可以在声明结构体时进行初始化，即使结构体本身不是静态的。</p>
<h2 id="结构是密封的"><a href="#结构是密封的" class="headerlink" title="结构是密封的"></a>结构是密封的</h2><p>结构总是隐式密封的，不能从它们派生其他结构。</p>
<p>不能用于结构的修饰符：protected 、protected internal 、abstract 、virtual 、sealed 。</p>
<p>结构本身派生自 System.ValueType ，而 System.ValueType 派生自 object 。</p>
<h2 id="装箱和拆箱-Boxing-and-Unboxing"><a href="#装箱和拆箱-Boxing-and-Unboxing" class="headerlink" title="装箱和拆箱 Boxing and Unboxing"></a>装箱和拆箱 Boxing and Unboxing</h2><p>装箱和拆箱详见第17章。因为结构实例是值类型数据，要作为引用类型对象，必须创建装箱的副本。装箱的过程就是制作值类型变量的引用类型副本。</p>
<h2 id="结构作为返回值和参数"><a href="#结构作为返回值和参数" class="headerlink" title="结构作为返回值和参数"></a>结构作为返回值和参数</h2><p>①当结构作为返回值，将创建它的副本并从函数成员返回；<br>②当结构被用作值参数，将创建实参结构的副本，用于方法的执行中；<br>③如果把一个结构用作 ref 和 out 参数，传入方法的是该结构的一个引用，这样就可以修改其数据成员。</p>
<h2 id="关于结构的更多内容"><a href="#关于结构的更多内容" class="headerlink" title="关于结构的更多内容"></a>关于结构的更多内容</h2><p>对结构进行分配的开销比创建类实例小，但要注意装箱和拆箱的高昂代价。</p>
<p>其他事项：<br>①预定义类型（比如 int 、short 、long 等等），尽管是原始类型，但实际上在 .NET 都实现为结构；<br>②可以使用与声明分部类相同的方法声明分结构，见第7章；<br>③结构和类一样，都能实现接口，见第16章。</p>
<h1 id="第十二章-枚举"><a href="#第十二章-枚举" class="headerlink" title="第十二章 枚举"></a>第十二章 枚举</h1><h2 id="枚举-Enumerations"><a href="#枚举-Enumerations" class="headerlink" title="枚举 Enumerations"></a>枚举 Enumerations</h2><p><strong>枚举 enumeration</strong> 也是用户定义的类型。枚举是值类型，只有一种类型的成员：命名的整数值常量。</p>
<p>示例如下，注意成员声明列表是逗号分隔的，在枚举声明中没有分号：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> TrafficLight</span><br><span class="line">&#123;</span><br><span class="line">    Green,</span><br><span class="line">    Yellow,</span><br><span class="line">    Red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个枚举类型都有一个底层整数类型，默认为 int ：每个枚举成员都被赋予一个底层类型的常量值，默认情况下，第一个成员赋值为0，第二个为1，以此类推。</p>
<p>即在上面示例的 TrafficLight 类型中，编译器把 int 值0、1、2分别赋值给了 Green 、Yellow 和 Red 。<em>在代码输出中，需要把他们转换为类型 int ，才能看到底层的成员值，否则成员名被当作字符串打印。</em></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">TrafficLight t1 = TrafficLight.Green;</span><br><span class="line">TrafficLight t2 = TrafficLight.Yellow;</span><br><span class="line">TrafficLight t3 = TrafficLight.Red;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; t1 &#125;</span>,\t<span class="subst">&#123;(<span class="built_in">int</span>) t1 &#125;</span>&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; t2 &#125;</span>,\t<span class="subst">&#123;(<span class="built_in">int</span>) t2 &#125;</span>&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; t3 &#125;</span>,\t<span class="subst">&#123;(<span class="built_in">int</span>) t3 &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Green,  0</span><br><span class="line">Yellow, 1</span><br><span class="line">Red,    2</span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/10/7ydJ1cPGXUWwR9H.png" width = "65%" height = "65%" alt="图53 - 枚举的成员常量表示为底层整数值"/>
</div>

<h3 id="设置底层类型和显式值"><a href="#设置底层类型和显式值" class="headerlink" title="设置底层类型和显式值"></a>设置底层类型和显式值</h3><p>可以把冒号和类型名放在枚举名之后，把枚举设置为任何整数类型，所有枚举成员常量都为该类型：<code>enum TrafficLight : ulong</code></p>
<p>可以显式地设置一个成员常量的值，即在枚举声明中的变量名之后使用初始化表达式。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> TrafficLight : <span class="built_in">long</span></span><br><span class="line">&#123;</span><br><span class="line">    Green = <span class="number">10L</span>,</span><br><span class="line">    Yellow = <span class="number">15L</span>,</span><br><span class="line">    Red = <span class="number">15L</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="隐式成员编号"><a href="#隐式成员编号" class="headerlink" title="隐式成员编号"></a>隐式成员编号</h3><p>如果不初始化成员常量，编译器会隐式地给它赋值，并且比前一个成员常量大1：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> CardSuit &#123;</span><br><span class="line">    Hearts, <span class="comment">//0</span></span><br><span class="line">    Clubs, <span class="comment">//1</span></span><br><span class="line">    Diamonds, <span class="comment">//2</span></span><br><span class="line">    Spades, <span class="comment">//3</span></span><br><span class="line">    MaxSuits <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> FaceCards &#123;</span><br><span class="line">    Jack = <span class="number">11</span>, <span class="comment">//11，显式设置</span></span><br><span class="line">    Queen, <span class="comment">//12，比之前大1</span></span><br><span class="line">    King, <span class="comment">//13</span></span><br><span class="line">    Ace, <span class="comment">//14</span></span><br><span class="line">    NumberOfFaceCards = <span class="number">4</span>, <span class="comment">//4，显式设置</span></span><br><span class="line">    SomeOtherValue, <span class="comment">//5</span></span><br><span class="line">    HighestFaceCard = Ace <span class="comment">//14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="位标志-Bit-Flags"><a href="#位标志-Bit-Flags" class="headerlink" title="位标志 Bit Flags"></a>位标志 Bit Flags</h2><p>程序员长期使用单个字的不同位作为表示一组开关标志的方法，即<strong>标志字 flag word</strong> 。枚举可以实现它，一般步骤如下：<br>①确定需要多少个位标志，选择一种足够多位的无符号类型来保存它；<br>②确定每个位位置代表什么，并给它们名称。声明一个选中的整数类型的枚举，每个成员由一个位位置表示；<br>③使用按位或 OR 运算符在持有该位标志的字中设置适当的位；<br>④使用按位与 AND 运算符或 HasFlag 方法检查是否设置了特定位标志。</p>
<p>步骤2示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="built_in">enum</span> CardDeckSettings : <span class="built_in">uint</span></span><br><span class="line">&#123;</span><br><span class="line">    SingleDeck = <span class="number">0x01</span>, <span class="comment">//位0</span></span><br><span class="line">    LargePictures = <span class="number">0x02</span>, <span class="comment">//位1</span></span><br><span class="line">    FancyNumbers = <span class="number">0x04</span>, <span class="comment">//位2</span></span><br><span class="line">    Animation = <span class="number">0x08</span> <span class="comment">//位3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Flags 特性 attribute 装饰枚举不是必需的，但是可以带来额外的便利，详见第25章。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/10/mrRg62fGHvcVzux.png" width = "70%" height = "70%" alt="图54 - 标志位的定义（左）和它们各自代表的值（右）"/>
</div>

<p>步骤3：要创建一个带有适当的位标志的字，需要声明一个该枚举类型的变量，并使用按位或运算符设置需要的位，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">CardDeckSettings ops = CardDeckSettings.SingleDeck</span><br><span class="line">                    | CardDeckSettings.FancyNumbers</span><br><span class="line">                    | CardDeckSettings.Animation ;</span><br></pre></td></tr></table></figure>
<p>步骤4：要判断标志字是否包含特定的位标志集，可以使用枚举类型的 HasFlag 布尔方法。在标志字上调用 HasFlag 方法，并将要检查的位标志作为参数，如果设置了指定的位标志，HasFlag 返回 true，否则返回 false 。如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> useFancyNumbers = ops.HasFlag(CardDeckSettings.FancyNumbers);</span><br></pre></td></tr></table></figure>
<p>HasFlag 方法还可以检测多个位标志，可以创建一个测试字，并用 HasFlag 检测是否测试字中的所有标志都在 ops 标志字中进行了设置。如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">CardDeckSettings testFlags = CardDeckSettings.Animation | CardDeckSettings.FancyNumbers; </span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> useAnimationAndFancyNumbers = ops.HasFlag( testFlags );</span><br></pre></td></tr></table></figure>
<p>另一种判断是否设置了一个或多个指定位的方法是使用按位与运算符：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> useFancyNumbers = (ops &amp; CardDeckSettings.FancyNumbers) == CardDeckSettings.FancyNumbers;</span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/11/BSh8D37ApQc5Lyr.png" width = "50%" height = "50%" alt="图55 - 生成一个标志字并检查一个特定的位标志"/>
</div>

<h3 id="Flags-特性"><a href="#Flags-特性" class="headerlink" title="Flags 特性"></a>Flags 特性</h3><p>Flags 特性通知编译器，该枚举的成员不仅可以用作单独的值，还可以组合成位标志。其次，它允许枚举的 ToString 方法为位标志的值提供更多的格式化信息。ToString 方法以一个枚举值为参数，将其与枚举的常量成员相比较，若匹配，ToString 返回该成员的字符串名称。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> CardDeckSettings : <span class="built_in">uint</span></span><br><span class="line">&#123;</span><br><span class="line">    SingleDeck = <span class="number">0x01</span>, <span class="comment">//位0</span></span><br><span class="line">    LargePictures = <span class="number">0x02</span>, <span class="comment">//位1</span></span><br><span class="line">    FancyNumbers = <span class="number">0x04</span>, <span class="comment">//位2</span></span><br><span class="line">    Animation = <span class="number">0x08</span> <span class="comment">//位3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">        CardDeckSettings ops;</span><br><span class="line">        ops = CardDeckSettings.FancyNumbers; <span class="comment">//设置一个标志</span></span><br><span class="line">        Console.WriteLine( ops.ToString() );</span><br><span class="line">                                             <span class="comment">//设置两个标志</span></span><br><span class="line">        ops = CardDeckSettings.FancyNumbers | CardDeckSettings.Animation;</span><br><span class="line">        Console.WriteLine( ops.ToString() ); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">FancyNumbers</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>该枚举没有 Flags 特性，第二次赋值的结果是12，是因为 ToString 方法会查找哪个枚举成员具有12，由于没找到，返回了12。然而，如果在枚举声明前加上 Flags 特性，ToString 方法就可以发现12对应两个分开的位标志成员，即 FancyNumbers 和 Animation 。运行包含 Flags 特性的代码，结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">FancyNumbers</span><br><span class="line">FancyNumbers, Animation</span><br></pre></td></tr></table></figure>
<h3 id="使用位标志的示例"><a href="#使用位标志的示例" class="headerlink" title="使用位标志的示例"></a>使用位标志的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="built_in">enum</span> CardDeckSettings : <span class="built_in">uint</span></span><br><span class="line">&#123;</span><br><span class="line">    SingleDeck = <span class="number">0x01</span>, <span class="comment">//位0</span></span><br><span class="line">    LargePictures = <span class="number">0x02</span>, <span class="comment">//位1</span></span><br><span class="line">    FancyNumbers = <span class="number">0x04</span>, <span class="comment">//位2</span></span><br><span class="line">    Animation = <span class="number">0x08</span> <span class="comment">//位3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> UseSingleDeck = <span class="literal">false</span>,</span><br><span class="line">         UseBigPics = <span class="literal">false</span>,</span><br><span class="line">         UseFancyNumbers = <span class="literal">false</span>,</span><br><span class="line">         UseAnimation = <span class="literal">false</span>,</span><br><span class="line">         UseAnimationAndFancyNumbers = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetOptions</span>(<span class="params"> CardDeckSettings ops </span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        UseSingleDeck = ops.HasFlag( CardDeckSettings.SingleDeck );</span><br><span class="line">        UseBigPics = ops.HasFlag( CardDeckSettings.LargePictures );</span><br><span class="line">        UseFancyNumbers = ops.HasFlag( CardDeckSettings.FancyNumbers );</span><br><span class="line">        UseAnimation = ops.HasFlag( CardDeckSettings.Animation );</span><br><span class="line"></span><br><span class="line">        CardDeckSettings testFlags =</span><br><span class="line">                        CardDeckSettings.Animation | CardDeckSettings.FancyNumbers;</span><br><span class="line">        UseAnimationAndFancyNumbers = ops.HasFlag( testFlags );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOptions</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine( <span class="string">&quot;Option settings:&quot;</span> );</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot; Use Single Deck - <span class="subst">&#123; UseSingleDeck &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot; Use Large Pictures - <span class="subst">&#123; UseBigPics &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot; Use Fancy Numbers - <span class="subst">&#123; UseFancyNumbers &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot; Show Animation - <span class="subst">&#123; UseAnimation &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine( <span class="string">&quot; Show Animation and FancyNumbers – &#123;0&#125;&quot;</span>,</span><br><span class="line">                    UseAnimationAndFancyNumbers );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass( );</span><br><span class="line">        CardDeckSettings ops = CardDeckSettings.SingleDeck</span><br><span class="line">                            | CardDeckSettings.FancyNumbers</span><br><span class="line">                            | CardDeckSettings.Animation;</span><br><span class="line">        mc.SetOptions( ops );</span><br><span class="line">        mc.PrintOptions( );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Option settings:</span><br><span class="line"> Use Single Deck - True</span><br><span class="line"> Use Large Pictures - False</span><br><span class="line"> Use Fancy Numbers - True</span><br><span class="line"> Show Animation - True</span><br><span class="line"> Show Animation and FancyNumbers – True</span><br></pre></td></tr></table></figure>
<h2 id="关于枚举的更多内容"><a href="#关于枚举的更多内容" class="headerlink" title="关于枚举的更多内容"></a>关于枚举的更多内容</h2><p>枚举只有单一的成员类型：声明的成员常量<br>①不能对成员使用修饰符，它们都隐式地具有和枚举相同的可访问性；<br>②由于成员是静态的，即使没有枚举变量也可以访问它们；<br>③比较不同枚举类型的成员会导致编译时错误，即使两个枚举具有完全相同的结构和成员名。同一枚举不同成员可以比较；  </p>
<p>.NET Enum 类型（enum 就是基于该类型的）还包含一些有用的静态方法：<br>①GetName 方法以一个枚举类型对象和一个整数为参数，返回相应的枚举成员名称；<br>②GetNames 方法以一个枚举类型对象为参数，返回该枚举中所有成员的名称。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> TrafficLight</span><br><span class="line">&#123;</span><br><span class="line">    Green,</span><br><span class="line">    Yellow,</span><br><span class="line">    Red</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Second member of TrafficLight is &#123;0&#125;\n&quot;</span>,</span><br><span class="line">                            Enum.GetName( <span class="keyword">typeof</span>( TrafficLight ), <span class="number">1</span> ) );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span> ( <span class="keyword">var</span> name <span class="keyword">in</span> Enum.GetNames( <span class="keyword">typeof</span>( TrafficLight ) ) )</span><br><span class="line">            Console.WriteLine( name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Second member of TrafficLight is Yellow</span><br><span class="line"></span><br><span class="line">Green</span><br><span class="line">Yellow</span><br><span class="line">Red</span><br></pre></td></tr></table></figure>
<h1 id="第十三章-数组"><a href="#第十三章-数组" class="headerlink" title="第十三章 数组"></a>第十三章 数组</h1><h2 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组 Arrays"></a>数组 Arrays</h2><p>数组是由一个变量名称表示的一组同类型的数据元素。每个元素通过变量名称和方括号中的一个或多个索引来访问：<code>MyArray[4]</code> 。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>①<strong>元素 Elements</strong>：数组的独立数据项称为元素，所有元素必须是相同类型或者继承自相同的类型；<br>②<strong>秩/维度 Rank/dimensions</strong>：数组的维度数可以为任何正数，数组的维度数称作秩；<br>③<strong>维度长度 Dimension length</strong>：数组的每一个维度有长度，就是这个方向的位置个数；<br>④<strong>数组长度 Array length</strong>：数组的所有维度中的元素总数称为数组的长度。</p>
<h3 id="重要细节"><a href="#重要细节" class="headerlink" title="重要细节"></a>重要细节</h3><p>①数组一旦被创建，大小就固定了，C# 不支持动态数组；<br>②数组索引号是从0开始。</p>
<p>一维数组：<code>int[5]</code>，秩=1，数组长度=5；二维数组：<code>int[3,6]</code>，秩=2，数组长度=18。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/11/6QH7RTnq19eDaIp.png" width = "60%" height = "60%" alt="图56 - 维度和大小"/>
</div>

<h2 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h2><p>①<strong>一维数组</strong>可以认为是单行元素或元素向量；<br>②<strong>多维数组</strong>是由主向量中的位置组成的，每个位置本身又是一个数组，称为子数组 subarray 。子数组向量中的位置本身又是一个子数组。</p>
<p>有两种类型的多维数组：<strong>矩形数组 rectangular array</strong> 和<strong>交错数组 jagged array</strong> ：<br>①矩阵数组的某个维度的所有子数组具有相同长度，只有一组方括号：<code>myArray2[4, 6, 1]</code> ；<br>②交错数组的每一个子数组都是独立数组，子数组可以不同长度，每个维度都使用一组方括号：<code>jagArray1[2][7][4]</code> 。</p>
<h2 id="数组是对象"><a href="#数组是对象" class="headerlink" title="数组是对象"></a>数组是对象</h2><p>数据实例是从 System.Array 继承类型的对象。数组从 BCL 基类派生而来，它们也继承了 BCL 基类很多的成员，比如 Rank 返回数组维度数，Length 返回数组长度，如下图：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/12/ALG15WS2PdqjZTu.png" width = "70%" height = "70%" alt="图57 - 数组的结构"/>
</div>

<p>数组是引用类型，引用在栈或堆上，而数组对象本身总是在堆上。尽管数组是引用类型，数组的元素可以是值类型或者引用类型。若存储的元素是值类型，数组被称作<strong>值类型数组 value type array</strong> ；若存储的元素是引用类型，数组被称作<strong>引用类型数组 reference type array</strong> 。</p>
<h2 id="一维数组和矩形数组"><a href="#一维数组和矩形数组" class="headerlink" title="一维数组和矩形数组"></a>一维数组和矩形数组</h2><p>要声明一维数组和矩形数组，要在类型和变量名之间使用一组方括号。</p>
<p>方括号内的<strong>逗号</strong>就是<strong>秩说明符 rank specifiers</strong>，指明了数组的维度数，没有逗号代表一维数组，一个逗号代表二维数组。</p>
<p>基类型和秩说明符构成了数组类型：<br>①可以使用多个秩说明符；<br>②不能在数组类型区域中放数组维度长度。秩是数组类型的一部分，而维度长度不是；<br>③数组声明后，维度数就是固定的，维度长度要等实例化时才确定。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[,,] firstArray; <span class="comment">//数组类型：三维整数数组  </span></span><br><span class="line"><span class="built_in">int</span>[,] arr1; <span class="comment">//数组类型：二维整数数组</span></span><br><span class="line"><span class="built_in">long</span>[,,] arr3; <span class="comment">//数组类型：三维long数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">long</span>[<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>] SecondArray; <span class="comment">//不允许添加维度长度，编译错误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>与 C 和 C++ 不同，方括号在基类型之后，而不是变量名称后。</p>
</blockquote>
<h2 id="实例化一维数组或矩形数组"><a href="#实例化一维数组或矩形数组" class="headerlink" title="实例化一维数组或矩形数组"></a>实例化一维数组或矩形数组</h2><p><strong>数组创建表达式 array-creation expression</strong>由 new 运算符构成，后面是基类名称和一组方括号。方括号中以逗号分隔每一个维度长度。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>]; <span class="comment">//包含4个int的一维数组</span></span><br><span class="line">MyClass[] mcArr = <span class="keyword">new</span> MyClass[<span class="number">4</span>]; <span class="comment">//包含4个MyClass引用的一维数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[,,] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>]; <span class="comment">//三维数组，数组长度3*6*2=36</span></span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/12/KFJ4MufzRmohBNw.png" width = "65%" height = "65%" alt="图58 - 声明和实例化数组"/>
</div>

<blockquote>
<p>与对象创建表达式不同，数组创建表达式不包含圆括号。</p>
</blockquote>
<h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>在数组中使用整数值作为索引来访问数组元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] intArr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">15</span>]; <span class="comment">//声明一维数组</span></span><br><span class="line">intArr1[<span class="number">2</span>] = <span class="number">10</span>; <span class="comment">//向第3个元素写入值</span></span><br><span class="line"><span class="built_in">int</span> var1 = intArr1[<span class="number">2</span>]; <span class="comment">//从第3个元素读取值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[,] intArr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>,<span class="number">10</span>]; <span class="comment">//声明二维数组</span></span><br><span class="line">intArr2[<span class="number">2</span>,<span class="number">3</span>] = <span class="number">7</span>; <span class="comment">//向数组写入值</span></span><br><span class="line"><span class="built_in">int</span> var2 = intArr2[<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">//从数组读取值</span></span><br></pre></td></tr></table></figure>
<h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><p>当数组被创建之后，每一个元素被自动初始化为类型的默认值。整数默认值为0，浮点型的默认值为0.0，布尔型的默认值为 false ，而引用类型的默认值为 null 。</p>
<h3 id="显式初始化一维数组"><a href="#显式初始化一维数组" class="headerlink" title="显式初始化一维数组"></a>显式初始化一维数组</h3><p>对于一维数组，若要设置显式初始值，可以在数组实例化的数组创建表达式之后加上一个<strong>初始化列表 initialization list</strong> ：<code>int[] intArr = new int[] &#123; 10, 20, 30, 40 &#125;;</code>，大括号及以内即初始化列表，初始值必须以逗号分隔。</p>
<p><em>注意：显式初始化可以不输入维度长度，因为编译器可以通过初始化值的个数来推断长度。</em></p>
<h3 id="显式初始化矩形数组"><a href="#显式初始化矩形数组" class="headerlink" title="显式初始化矩形数组"></a>显式初始化矩形数组</h3><p><code>int[,] intArray2 = new int[,] &#123; &#123;10, 1&#125;, &#123;2, 10&#125;, &#123;11, 9&#125; &#125;;</code></p>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/12/kgSJKUNMA1wRxFQ.png" width = "45%" height = "45%" alt="图59 - 初始化矩形数组"/>
</div>

<h3 id="初始化矩形数组的语法点"><a href="#初始化矩形数组的语法点" class="headerlink" title="初始化矩形数组的语法点"></a>初始化矩形数组的语法点</h3><p>矩形数组使用嵌套的、逗号分隔的初始化列表进行初始化：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[,,] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>] &#123;</span><br><span class="line">                                    &#123; &#123;<span class="number">8</span>, <span class="number">6</span>&#125;, &#123;<span class="number">5</span>, <span class="number">2</span>&#125;, &#123;<span class="number">12</span>, <span class="number">9</span>&#125; &#125;,</span><br><span class="line">                                    &#123; &#123;<span class="number">6</span>, <span class="number">4</span>&#125;, &#123;<span class="number">13</span>, <span class="number">9</span>&#125;, &#123;<span class="number">18</span>, <span class="number">4</span>&#125; &#125;,</span><br><span class="line">                                    &#123; &#123;<span class="number">7</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">13</span>&#125;, &#123;<span class="number">9</span>, <span class="number">3</span>&#125; &#125;,</span><br><span class="line">                                    &#123; &#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">23</span>, <span class="number">8</span>&#125; &#125;</span><br><span class="line">                                  &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="快捷语法"><a href="#快捷语法" class="headerlink" title="快捷语法"></a>快捷语法</h3><p>在一条语句中使用声明、数组创建表达式和初始化列表时，可以省略语法的数组创建表达式部分：</p>
<p>比如，下面2个语句等价：<br><code>int[] arr1 = new int[3] &#123;10, 20, 30&#125;;</code><br><code>int[] arr1 =            &#123;10, 20, 30&#125;;</code><br>又比如：<br><code>int[,] arr = new int[2,3] &#123;&#123;0, 1, 2&#125;,&#123;10, 11, 12&#125;&#125;;</code><br><code>int[,] arr =              &#123;&#123;0, 1, 2&#125;,&#123;10, 11, 12&#125;&#125;;</code>  </p>
<h3 id="隐式类型数组"><a href="#隐式类型数组" class="headerlink" title="隐式类型数组"></a>隐式类型数组</h3><p>当初始化数组时，可以使用 var 关键字让编译器根据初始化语句的类型来推断数组类型。只有所有初始化语句能隐式转换为单个类型，才能这么做。如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> [] intArr1 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"><span class="keyword">var</span>    intArr2 = <span class="keyword">new</span>    [] &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;; <span class="comment">//第二个int可以省略也可以不省略</span></span><br><span class="line"><span class="keyword">var</span>    intArr2 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[,] intArr3 = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">10</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">10</span> &#125;, &#123; <span class="number">11</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span>    intArr4 = <span class="keyword">new</span>    [,] &#123; &#123; <span class="number">10</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">10</span> &#125;, &#123; <span class="number">11</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span>    intArr4 = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">10</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">10</span> &#125;, &#123; <span class="number">11</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>[] sArr1 = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;life&quot;</span>, <span class="string">&quot;liberty&quot;</span>, <span class="string">&quot;pursuit of happiness&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span>      sArr2 = <span class="keyword">new</span>       [] &#123; <span class="string">&quot;life&quot;</span>, <span class="string">&quot;liberty&quot;</span>, <span class="string">&quot;pursuit of happiness&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span>      sArr2 = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;life&quot;</span>, <span class="string">&quot;liberty&quot;</span>, <span class="string">&quot;pursuit of happiness&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="综合内容"><a href="#综合内容" class="headerlink" title="综合内容"></a>综合内容</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++ )</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++ )</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Element [<span class="subst">&#123; i &#125;</span>,<span class="subst">&#123; j &#125;</span>] is <span class="subst">&#123; arr[i,j] &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Element [0,0] is 0</span><br><span class="line">Element [0,1] is 1</span><br><span class="line">Element [0,2] is 2</span><br><span class="line">Element [1,0] is 10</span><br><span class="line">Element [1,1] is 11</span><br><span class="line">Element [1,2] is 12</span><br></pre></td></tr></table></figure>
<h2 id="交错数组-Jagged-Arrays"><a href="#交错数组-Jagged-Arrays" class="headerlink" title="交错数组 Jagged Arrays"></a>交错数组 Jagged Arrays</h2><p>交错数组是数组的数组，交错数组的子数组的元素个数可以不同。</p>
<p>例如，如下代码声明了一个二维交错数组：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] jagArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][]; <span class="comment">//声明并创建顶层数组</span></span><br><span class="line">    ···                        <span class="comment">//声明并创建子数组</span></span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/12/GN9bHxc1KhkVP4B.png" width = "45%" height = "45%" alt="图60 - 交错数组是数组的数组"/>
</div>

<h3 id="声明交错数组"><a href="#声明交错数组" class="headerlink" title="声明交错数组"></a>声明交错数组</h3><p>交错数组的声明语法要求每一个维度都有独立的方括号，方括号的数量即数组的秩。和矩形数组一样，维度长度不能包含在数组类型声明部分。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] SomeArr;  <span class="comment">//秩=2</span></span><br><span class="line"><span class="built_in">int</span>[][][] OtherArr;  <span class="comment">//秩=3</span></span><br></pre></td></tr></table></figure>
<h3 id="实例化顶层数组"><a href="#实例化顶层数组" class="headerlink" title="实例化顶层数组"></a>实例化顶层数组</h3><p>可以使用数组创建表达式创建顶层数组，但是不能在声明语句中初始化顶层数组以外的数组：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] jagArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][]; <span class="comment">//3个子数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[][] jagArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">//不允许，编译错误</span></span><br></pre></td></tr></table></figure>
<h3 id="实例化交错数组"><a href="#实例化交错数组" class="headerlink" title="实例化交错数组"></a>实例化交错数组</h3><p>交错数组的初始化不能在一个步骤里完成，每个数组必须独立创建，步骤包括：<br>①实例化顶层数组；<br>②分别实例化每一个子数组，把新建数组的引用赋给它们所属数组的合适元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] Arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][]; <span class="comment">//实例化顶层数组</span></span><br><span class="line"></span><br><span class="line">Arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">//实例化子数组</span></span><br><span class="line">Arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>&#125;; <span class="comment">//实例化子数组</span></span><br><span class="line">Arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">110</span>, <span class="number">120</span>&#125;; <span class="comment">//实例化子数组</span></span><br></pre></td></tr></table></figure>
<h3 id="交错数组中的子数组"><a href="#交错数组中的子数组" class="headerlink" title="交错数组中的子数组"></a>交错数组中的子数组</h3><p>由于交错数组中的子数组本身就是数组，因此子数组也可能是矩形数组。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[][,] Arr; <span class="comment">//带有二维数组的交错数组</span></span><br><span class="line">Arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][,]; <span class="comment">//实例化带有3个二维数组的交错数组</span></span><br><span class="line"></span><br><span class="line">Arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">10</span>,  <span class="number">20</span>  &#125;,</span><br><span class="line">                      &#123; <span class="number">100</span>, <span class="number">200</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">Arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">30</span>,  <span class="number">40</span>,  <span class="number">50</span>  &#125;,</span><br><span class="line">                      &#123; <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">Arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">60</span>,  <span class="number">70</span>,  <span class="number">80</span>,  <span class="number">90</span>  &#125;,</span><br><span class="line">                      &#123; <span class="number">600</span>, <span class="number">700</span>, <span class="number">800</span>, <span class="number">900</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Arr.GetLength(<span class="number">0</span>); i++) <span class="comment">//GetLength获取Arr维度0的长度</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; Arr[i].GetLength(<span class="number">0</span>); j++) <span class="comment">//GetLength获取Arr[i]维度0的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; Arr[i].GetLength(<span class="number">1</span>); k++) <span class="comment">//GetLength获取Arr[i]维度1的长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;[<span class="subst">&#123; i &#125;</span>][<span class="subst">&#123; j &#125;</span>,<span class="subst">&#123; k &#125;</span>] = <span class="subst">&#123; Arr[i][j,k] &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：  </p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[0][0,0] = 10</span><br><span class="line">[0][0,1] = 20</span><br><span class="line"></span><br><span class="line">[0][1,0] = 100</span><br><span class="line">[0][1,1] = 200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[1][0,0] = 30</span><br><span class="line">[1][0,1] = 40</span><br><span class="line">[1][0,2] = 50</span><br><span class="line"></span><br><span class="line">[1][1,0] = 300</span><br><span class="line">[1][1,1] = 400</span><br><span class="line">[1][1,2] = 500</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[2][0,0] = 60</span><br><span class="line">[2][0,1] = 70</span><br><span class="line">[2][0,2] = 80</span><br><span class="line">[2][0,3] = 90</span><br><span class="line"></span><br><span class="line">[2][1,0] = 600</span><br><span class="line">[2][1,1] = 700</span><br><span class="line">[2][1,2] = 800</span><br><span class="line">[2][1,3] = 900</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="比较矩形数组和交错数组"><a href="#比较矩形数组和交错数组" class="headerlink" title="比较矩形数组和交错数组"></a>比较矩形数组和交错数组</h2><p>矩形数组和交错数组的结构区别很大，一个3×3的矩形数组，和一个由3个长度为3的一维数组组成的交错数组，都保存了9个数据，但矩形数组只有单个数组对象，而交错数组有4个数组对象。</p>
<p>在 CIL 中，一维数组有特定的性能优化指令。因此有时一维数组的交错数组比矩形数组更加高效。另一方面，矩形数组的编程复杂度低，因为是一个单元而不是数组的数组。</p>
<h2 id="foreach-语句"><a href="#foreach-语句" class="headerlink" title="foreach 语句"></a>foreach 语句</h2><p><strong>foreach 语句</strong>允许我们连续访问数组中的每一个元素。也可以和其他集合类型一起使用，见第19章。</p>
<p>foreach 语句语法如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>( Type Identifier <span class="keyword">in</span> ArrayName ) <span class="comment">//显式类型迭代变量声明</span></span><br><span class="line">    <span class="function">Statement</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">foreach</span>(<span class="params"> <span class="keyword">var</span> Identifier <span class="keyword">in</span> ArrayName </span>) <span class="comment">//隐式类型迭代变量声明</span></span></span><br><span class="line"><span class="function">    Statement</span></span><br></pre></td></tr></table></figure>
<p>①<strong>迭代变量 iteration variable</strong>是临时的，并且和数组中的元素类型相同。foreach 语句使用迭代变量来相继表示数组中的每个元素；<br>②Type 是数组中元素的类型。可以显式提供它的类型，也可以使用 var 让编译器来推断，因为编译器知道数组的类型；<br>③Identifier 是迭代变量的名字；<br>④ArrayName 是要处理的数组的名字；<br>⑤Statement 是为数组每个元素执行一次的语句或语句块。</p>
<p>示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr1 = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>( <span class="built_in">int</span> item <span class="keyword">in</span> arr1 )</span><br><span class="line">    Console.WriteLine( <span class="string">$&quot;Item Value: <span class="subst">&#123; item &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="迭代变量是只读的"><a href="#迭代变量是只读的" class="headerlink" title="迭代变量是只读的"></a>迭代变量是只读的</h3><p>由于迭代变量是只读的，它不能被改变，但是对于值类型数组和引用类型数组的效果不一样。</p>
<p>对于值类型数组，在用迭代变量来表示数组元素时，不能改变它们，如下，尝试改变迭代变量的数据会产生编译时错误：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr1 = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>( <span class="built_in">int</span> item <span class="keyword">in</span> arr1 )</span><br><span class="line">    item++; <span class="comment">//编译错误，不得改变变量值</span></span><br></pre></td></tr></table></figure>
<p>对于引用类型数组，虽然不能改变迭代变量，但是迭代变量只是数据的引用，所以可以改变数据：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MyField = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        MyClass[] mcArray = <span class="keyword">new</span> MyClass[<span class="number">4</span>]; <span class="comment">//创建数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mcArray[i] = <span class="keyword">new</span> MyClass(); <span class="comment">//创建类对象</span></span><br><span class="line">            mcArray[i].MyField = i; <span class="comment">//设置字段</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> (MyClass item <span class="keyword">in</span> mcArray)</span><br><span class="line">            item.MyField += <span class="number">10</span>; <span class="comment">//改变数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (MyClass item <span class="keyword">in</span> mcArray)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; item.MyField &#125;</span>&quot;</span>); <span class="comment">//读取改变的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td></tr></table></figure>
<h3 id="foreach-语句和多维数组"><a href="#foreach-语句和多维数组" class="headerlink" title="foreach 语句和多维数组"></a>foreach 语句和多维数组</h3><p>矩形数组的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span>[,] arr1 = &#123; &#123;<span class="number">10</span>, <span class="number">11</span>&#125;, &#123;<span class="number">12</span>, <span class="number">13</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>( <span class="keyword">var</span> element <span class="keyword">in</span> arr1 )</span><br><span class="line">        &#123;</span><br><span class="line">            total += element;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Element: <span class="subst">&#123; element &#125;</span>, Current Total: <span class="subst">&#123; total &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Element: 10, Current Total: 10</span><br><span class="line">Element: 11, Current Total: 21</span><br><span class="line">Element: 12, Current Total: 33</span><br><span class="line">Element: 13, Current Total: 46</span><br></pre></td></tr></table></figure>
<p>交错数组的示例，由于交错数组是数组的数组，所以需要为每个维度都使用独立的 foreach 语句，foreach 语句必须嵌套以确保每一个嵌套数组都被正确处理：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span>[][] arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>][];</span><br><span class="line">        arr1[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">11</span> &#125;;</span><br><span class="line">        arr1[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span>[] array <span class="keyword">in</span> arr1) <span class="comment">//处理顶层数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Starting new array&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> array) <span class="comment">//处理第二层数组</span></span><br><span class="line">            &#123;</span><br><span class="line">                total += item;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot; Item: <span class="subst">&#123; item &#125;</span>, Current Total: <span class="subst">&#123; total &#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Starting new array</span><br><span class="line"> Item: 10, Current Total: 10</span><br><span class="line"> Item: 11, Current Total: 21</span><br><span class="line">Starting new array</span><br><span class="line"> Item: 12, Current Total: 33</span><br><span class="line"> Item: 13, Current Total: 46</span><br><span class="line"> Item: 14, Current Total: 60</span><br></pre></td></tr></table></figure>
<h2 id="数组协变-Array-Covariance"><a href="#数组协变-Array-Covariance" class="headerlink" title="数组协变 Array Covariance"></a>数组协变 Array Covariance</h2><p>在某些情况下，即使某个对象不是数组的基类型，也可以把它赋值给数组元素，即<strong>数组协变</strong>。在下列情况下可以使用数组协变：<br>①数组是引用类型数组；<br>②在赋值的对象类型和数组的基类型之间有隐式或显式转换。</p>
<p>由于在派生类和基类之间总是有隐式转换，因此总是可以将一个派生类的对象赋值给为基类声明的数组：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="comment">//两个A[]类型的数组</span></span><br><span class="line">        A[] AArray1 = <span class="keyword">new</span> A[<span class="number">3</span>]; </span><br><span class="line">        A[] AArray2 = <span class="keyword">new</span> A[<span class="number">3</span>]; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通：将A类型的对象赋值给A类型的数组</span></span><br><span class="line">        AArray1[<span class="number">0</span>] = <span class="keyword">new</span> A(); AArray1[<span class="number">1</span>] = <span class="keyword">new</span> A(); AArray1[<span class="number">2</span>] = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协变：将B类型的对象赋值给A类型的数组</span></span><br><span class="line">        AArray2[<span class="number">0</span>] = <span class="keyword">new</span> B(); AArray2[<span class="number">1</span>] = <span class="keyword">new</span> B(); AArray2[<span class="number">2</span>] = <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值类型数组没有协变。</p>
</blockquote>
<h2 id="数组继承的有用成员"><a href="#数组继承的有用成员" class="headerlink" title="数组继承的有用成员"></a>数组继承的有用成员</h2><p>C# 数组派生自 System.Array 类，继承了很多有用的属性和方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">成员</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">生存期</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Rank</td>
<td style="text-align:left">属性</td>
<td style="text-align:left">实例</td>
<td style="text-align:left">获取数组的维度数</td>
</tr>
<tr>
<td style="text-align:left">Length</td>
<td style="text-align:left">属性</td>
<td style="text-align:left">实例</td>
<td style="text-align:left">获取数组中所有维度的元素总数</td>
</tr>
<tr>
<td style="text-align:left">GetLength</td>
<td style="text-align:left">方法</td>
<td style="text-align:left">实例</td>
<td style="text-align:left">返回数组的指定维度的长度</td>
</tr>
<tr>
<td style="text-align:left">Clear</td>
<td style="text-align:left">方法</td>
<td style="text-align:left">静态</td>
<td style="text-align:left">将某一范围内的元素设置为0或null</td>
</tr>
<tr>
<td style="text-align:left">Sort</td>
<td style="text-align:left">方法</td>
<td style="text-align:left">静态</td>
<td style="text-align:left">在一维数组中对元素进行排序</td>
</tr>
<tr>
<td style="text-align:left">BinarySearch</td>
<td style="text-align:left">方法</td>
<td style="text-align:left">静态</td>
<td style="text-align:left">使用二进制搜索，搜索一维数组中的值</td>
</tr>
<tr>
<td style="text-align:left">Clone</td>
<td style="text-align:left">方法</td>
<td style="text-align:left">实例</td>
<td style="text-align:left">进行数组的浅复制 —— 对于值类型数组和引用类型数组，都只复制元素</td>
</tr>
<tr>
<td style="text-align:left">IndexOf</td>
<td style="text-align:left">方法</td>
<td style="text-align:left">静态</td>
<td style="text-align:left">返回一维数组中遇到的第一个值</td>
</tr>
<tr>
<td style="text-align:left">Reverse</td>
<td style="text-align:left">方法</td>
<td style="text-align:left">静态</td>
<td style="text-align:left">反转一维数组中某个范围内的元素</td>
</tr>
<tr>
<td style="text-align:left">GetUpperBound</td>
<td style="text-align:left">方法</td>
<td style="text-align:left">实例</td>
<td style="text-align:left">获取指定维度的上限</td>
</tr>
</tbody>
</table>
</div>
<p>部分示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintArray</span>(<span class="params"><span class="built_in">int</span>[] a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> a)</span><br><span class="line">        Console.Write(<span class="string">$&quot;<span class="subst">&#123; x &#125;</span> &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">15</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    PrintArray(arr);</span><br><span class="line"></span><br><span class="line">    Array.Sort(arr);</span><br><span class="line">    PrintArray(arr);</span><br><span class="line"></span><br><span class="line">    Array.Reverse(arr);</span><br><span class="line">    PrintArray(arr);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Rank = <span class="subst">&#123; arr.Rank &#125;</span>, Length = <span class="subst">&#123; arr.Length &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;GetLength(0) = <span class="subst">&#123; arr.GetLength(<span class="number">0</span>) &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;GetType() = <span class="subst">&#123; arr.GetType() &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">15 20 5 25 10 </span><br><span class="line">5 10 15 20 25</span><br><span class="line">25 20 15 10 5</span><br><span class="line"></span><br><span class="line">Rank = 1, Length = 5</span><br><span class="line">GetLength(0) = 5</span><br><span class="line">GetType() = System.Int32[]</span><br></pre></td></tr></table></figure>
<h3 id="Clone-方法"><a href="#Clone-方法" class="headerlink" title="Clone 方法"></a>Clone 方法</h3><p>Clone 方法为数组进行浅复制，即只创建了数组本身的克隆：<br>①克隆值类型数组会产生两个独立的数组；<br>②克隆引用类型数组会产生指向相同对象的两个数组；<br>③Clone 方法返回 object 类型的引用，它必须被强制转换为数组类型。</p>
<p>克隆值类型数组的示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] intArr1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="built_in">int</span>[] intArr2 = (<span class="built_in">int</span>[]) intArr1.Clone(); <span class="comment">//因为返回object，所以要转换为数组</span></span><br><span class="line"></span><br><span class="line">    intArr2[<span class="number">0</span>] = <span class="number">100</span>; intArr2[<span class="number">1</span>] = <span class="number">200</span>; intArr2[<span class="number">2</span>] = <span class="number">300</span>; <span class="comment">//intArr1为&#123;1,2,3&#125;，intArr2为&#123;100,200,300&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>克隆引用类型的示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        A[] AArray1 = <span class="keyword">new</span> A[<span class="number">3</span>] &#123; <span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A() &#125;;</span><br><span class="line">        A[] AArray2 = (A[]) AArray1.Clone();</span><br><span class="line"></span><br><span class="line">        AArray2[<span class="number">0</span>].Value = <span class="number">100</span>;</span><br><span class="line">        AArray2[<span class="number">1</span>].Value = <span class="number">200</span>;</span><br><span class="line">        AArray2[<span class="number">2</span>].Value = <span class="number">300</span>;</span><br><span class="line">        <span class="comment">//AArray1和AArray2都引用&#123;100,200,300&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组与-ref-返回和-ref-局部变量"><a href="#数组与-ref-返回和-ref-局部变量" class="headerlink" title="数组与 ref 返回和 ref 局部变量"></a>数组与 ref 返回和 ref 局部变量</h2><p>第6章介绍了 ref 返回和 ref 局部变量，利用 ref 返回功能，可以把一个引用作为返回值传到方法体之外，而利用 ref 局部变量，可以在调用域内使用这个引用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">ref</span> <span class="built_in">int</span> <span class="title">PointerToHighestPositive</span>(<span class="params"><span class="built_in">int</span>[] numbers</span>) <span class="comment">//接受一个数组为参数，并且返回对该数组元素的引用</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> highest = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> indexOfHighest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numbers.Length; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i] &gt; highest)</span><br><span class="line">                &#123;</span><br><span class="line">                    indexOfHighest = i;</span><br><span class="line">                    highest = numbers[indexOfHighest];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">ref</span> numbers[indexOfHighest];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] scores = &#123; <span class="number">5</span>, <span class="number">80</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Before: <span class="subst">&#123;scores[<span class="number">0</span>]&#125;</span>, <span class="subst">&#123;scores[<span class="number">1</span>]&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">ref</span> <span class="built_in">int</span> locationOfHigher = <span class="function"><span class="keyword">ref</span> <span class="title">PointerToHighestPositive</span>(<span class="params">scores</span>)</span>;</span><br><span class="line"></span><br><span class="line">        locationOfHigher = <span class="number">0</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After : <span class="subst">&#123;scores[<span class="number">0</span>]&#125;</span>, <span class="subst">&#123;scores[<span class="number">1</span>]&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Before: 5, 80</span><br><span class="line">After : 5, 0</span><br></pre></td></tr></table></figure>
<h1 id="第十四章-委托"><a href="#第十四章-委托" class="headerlink" title="第十四章 委托"></a>第十四章 委托</h1><h2 id="什么是委托"><a href="#什么是委托" class="headerlink" title="什么是委托"></a>什么是委托</h2><p><strong>委托 delegate</strong> 是持有一个或多个方法的对象。示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span>; <span class="comment">//声明委托类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintLow</span>(<span class="params"> <span class="built_in">int</span> <span class="keyword">value</span> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; <span class="keyword">value</span> &#125;</span> - Low Value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintHigh</span>(<span class="params"> <span class="built_in">int</span> <span class="keyword">value</span> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; <span class="keyword">value</span> &#125;</span> - High Value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line"></span><br><span class="line">        MyDel del; <span class="comment">//声明委托变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建随机整数生成器对象，并得到0到99之间的一个随机数</span></span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="built_in">int</span> randomValue = rand.Next( <span class="number">99</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个包含PrintLow或PrintHigh的委托对象并将其复制给del变量</span></span><br><span class="line">        del = randomValue &lt; <span class="number">50</span></span><br><span class="line">                ? <span class="keyword">new</span> MyDel( program.PrintLow )</span><br><span class="line">                : <span class="keyword">new</span> MyDel( program.PrintHigh );</span><br><span class="line"></span><br><span class="line">        del( randomValue ); <span class="comment">//执行委托</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="委托概述"><a href="#委托概述" class="headerlink" title="委托概述"></a>委托概述</h2><p>委托和类一样是一种用户定义类型。类表示是数据和方法的集合，委托则持有一个或多个方法，以及一系列预定义操作。可以通过以下步骤来使用委托：<br>①声明一个委托类型，委托类型没有实现主体（块）；<br>②使用该委托类型声明一个委托变量；<br>③创建一个委托类型的对象，并赋值给委托变量。新的委托对象包含指向某个方法的引用，这个方法的签名和返回类型必须和第一步定义的委托类型一致；<br>④可以选择为委托对象添加其他方法。这些方法的签名和返回类型要与第一步定义的委托类型相同；<br>⑤调用委托时，其包含的每一个方法都会被执行。</p>
<p>可以把 delegate 看作一个包含有序方法的列表，这些方法拥有相同的签名和返回类型：<br>①方法的列表被称为<strong>调用列表 invocation list</strong> ；<br>②委托持有的方法可以来自任何类和结构，只有能与委托的返回类型和签名匹配；<br>③调用列表的方法可以是实例方法也可以是静态方法；<br>④调用委托时，会执行其调用列表中的所有方法。</p>
<h2 id="声明委托类型"><a href="#声明委托类型" class="headerlink" title="声明委托类型"></a>声明委托类型</h2><p>声明语法：<code>delegate void MyDel( int x );</code> ，委托类型的声明看上去和方法的声明类似，有返回类型和签名。返回类型和签名指定了委托接受的方法的形式，比如该 MyDel 委托，只接受无返回值的并且有单个 int 参数的方法。</p>
<p>委托类型声明没有方法主体。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/16/pTVtcDSKRi2f38M.png" width = "70%" height = "70%" alt="图61 - 委托类型和对象"/>
</div>

<h2 id="创建委托对象"><a href="#创建委托对象" class="headerlink" title="创建委托对象"></a>创建委托对象</h2><p>委托是引用类型，在类型声明后，要声明变量并创建类型的对象。</p>
<p><strong>委托类型变量的声明</strong>语法：<code>MyDel delVar;</code></p>
<p>有两种<strong>创建委托对象</strong>的方法，第一种是使用带 new 运算符的对象创建表达式，包括委托类型名，和圆括号内的作为调用列表的第一个成员的方法的名称，该方法可以是实例方法或静态方法，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">delVar = <span class="keyword">new</span> MyDel( myInstObj.MyM1 ); <span class="comment">//创建委托并保持引用，实例方法</span></span><br><span class="line">dVar = <span class="keyword">new</span> MyDel( SClass.OtherM2 ); <span class="comment">//创建委托并保持引用，静态方法</span></span><br></pre></td></tr></table></figure>
<p>第二种创建委托对象的方式为快捷语法，仅由方法说明符构成。这种快捷语法可以工作是因为方法名称和相应的委托类型之间存在隐式转换，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">delVar = myInstObj.MyM1; <span class="comment">//创建委托并保持引用，实例方法</span></span><br><span class="line">dVar = SClass.OtherM2; <span class="comment">//创建委托并保持引用，静态方法</span></span><br></pre></td></tr></table></figure>
<p>将声明委托类型、声明委托变量、创建委托对象合并的示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>; <span class="comment">//声明委托类型</span></span><br><span class="line">MyDel delVar, dVar; <span class="comment">//创建两个委托变量</span></span><br><span class="line"></span><br><span class="line">delVar = <span class="keyword">new</span> MyDel( myInstObj.MyM1 ); <span class="comment">//创建委托并保存引用</span></span><br><span class="line">dVar = <span class="keyword">new</span> MyDel( SClass.OtherM2 ); <span class="comment">//创建委托并保存引用</span></span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/29/ZE3i2n5mRuGjQcr.png" width = "60%" height = "60%" alt="图62 - 初始化委托"/>
</div>

<p>除了为委托分配内存，创建委托对象还会把第一个方法放入委托的调用列表。</p>
<h2 id="给委托赋值"><a href="#给委托赋值" class="headerlink" title="给委托赋值"></a>给委托赋值</h2><p>由于委托是引用类型，可以通过给它赋值来改变包含在委托变量中的引用。旧委托对象会被垃圾回收器回收。</p>
<p>委托是恒定的，委托对象被创建后不能被改变，但是可以改变变量的引用。</p>
<h2 id="组合委托-Combining-Delegates"><a href="#组合委托-Combining-Delegates" class="headerlink" title="组合委托 Combining Delegates"></a>组合委托 Combining Delegates</h2><p>委托可以使用额外的运算符来组合，这个运算会创建一个新的委托，其调用列表连接了作为操作数的两个委托的调用列表副本，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDel delA = myInstObj.MyM1;</span><br><span class="line">MyDel delB = SClass.OtherM2;</span><br><span class="line"></span><br><span class="line">MyDel delC = delA + delB; <span class="comment">//组合调用列表</span></span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/29/G5M46l2Be31rTP9.png" width = "65%" height = "65%" alt="图63 - 组合委托"/>
</div>

<h2 id="为委托添加方法"><a href="#为委托添加方法" class="headerlink" title="为委托添加方法"></a>为委托添加方法</h2><p>使用 <strong>+=</strong> 运算符，可以为委托“添加”方法，方法加在了调用列表的底部。使用 += 运算符，实际上是创建了一个新的委托，然后将这个委托赋值给了原名称，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDel delVar = inst.MyM1; <span class="comment">//创建并初始化</span></span><br><span class="line">delVar += SCl.m3; <span class="comment">//增加方法</span></span><br><span class="line">delVar += X.Act; <span class="comment">//增加方法</span></span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/29/Ve93Cgcd5xFBuRm.png" width = "50%" height = "50%" alt="图64 - 由于委托是不可变的，所以为委托的调用列表添加3个方法后的结果其实是变量指向的一个全新的委托"/>
</div>

<h2 id="从委托移除方法"><a href="#从委托移除方法" class="headerlink" title="从委托移除方法"></a>从委托移除方法</h2><p>使用 <strong>-=</strong> 运算符，可以为委托“移除”方法。与为委托添加方法一样，其实是创建了一个新的委托，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">delVar -= SCl.m3; <span class="comment">//从委托移除方法</span></span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/29/4Tadl6vA8C5yZzx.png" width = "50%" height = "50%" alt="图65 - 从委托移除方法"/>
</div>


<p>其他注意事项：<br>①如果在调用列表中的有多个同名方法，-= 运算符从列表底部开始搜索，并且移除第一个与方法匹配的实例；<br>②试图删除委托中不存在的方法将无效；<br>③试图调用空委托会抛出异常。可以通过将委托和 null 进行比较来判断委托的调用列表是否为空。如果调用列表为空，则委托是 null 。</p>
<h2 id="调用委托-Invoking-a-Delegate"><a href="#调用委托-Invoking-a-Delegate" class="headerlink" title="调用委托 Invoking a Delegate"></a>调用委托 Invoking a Delegate</h2><p>①可以通过两种方式调用委托，一种是像调用方法一样调用委托，另一种是使用委托的 Invoke 方法；<br>②可以将参数放在调用的圆括号之内。用于调用委托的参数作用于调用列表中的每个方法，除非其中一个参数是输出参数，见后面；<br>③如果一个方法在调用列表中多次出现，则在调用委托时，每次在列表中遇到该方法时都会调用它；<br>④调用时委托不能为空 null ，否则会引发异常。可以使用 if 语句或者使用<strong>空条件运算符</strong>和 Invoke 方法去检查。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDel delVar = inst.MyM1;</span><br><span class="line">delVar += SCl.m3;</span><br><span class="line">delVar += X.Act;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (delVar != <span class="literal">null</span>)</span><br><span class="line">    &#123; delVar(<span class="number">55</span>); &#125; <span class="comment">//调用委托</span></span><br><span class="line">delVar?.Invoke(<span class="number">65</span>); <span class="comment">//使用Invoke和空条件运算符</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/01/29/4RD9hkBjc7Oysnl.png" width = "60%" height = "60%" alt="图66 - 在调用委托时，它使用相同的参数来执行调用列表中的每一个方法"/>
</div>

<h2 id="委托的示例"><a href="#委托的示例" class="headerlink" title="委托的示例"></a>委托的示例</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个没有返回值和参数的委托类型</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">PrintFunction</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print1</span>()</span></span><br><span class="line">    &#123; Console.WriteLine(<span class="string">&quot;Print1 -- instance&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print2</span>()</span></span><br><span class="line">    &#123; Console.WriteLine(<span class="string">&quot;Print2 -- static&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test(); <span class="comment">//创建类示例</span></span><br><span class="line">        PrintFunction pf; <span class="comment">//创建一个空委托</span></span><br><span class="line"></span><br><span class="line">        pf = t.Print1; <span class="comment">//实例化并初始化该委托</span></span><br><span class="line"></span><br><span class="line">        pf += Test.Print2;</span><br><span class="line">        pf += t.Print1;</span><br><span class="line">        pf += Test.Print2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">null</span> != pf) <span class="comment">//确认委托有方法</span></span><br><span class="line">            pf(); <span class="comment">//调用委托</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Delegate is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Print1 -- instance</span><br><span class="line">Print2 -- static</span><br><span class="line">Print1 -- instance</span><br><span class="line">Print2 -- static</span><br></pre></td></tr></table></figure>
<h2 id="调用带返回值的委托"><a href="#调用带返回值的委托" class="headerlink" title="调用带返回值的委托"></a>调用带返回值的委托</h2><p>如果委托有返回值并且在调用列表中有一个以上的方法，则：<br>①调用列表中最后一个方法返回的值就是委托调用返回的值；<br>②调用列表中其他方法的返回值就会被忽略。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDel</span>(<span class="params"> </span>)</span>; <span class="comment">//声明有返回值的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> IntValue = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add2</span>()</span> &#123; IntValue += <span class="number">2</span>; <span class="keyword">return</span> IntValue;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add3</span>()</span> &#123; IntValue += <span class="number">3</span>; <span class="keyword">return</span> IntValue;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass(); </span><br><span class="line">        MyDel mDel = mc.Add2; <span class="comment">//创建并初始化委托</span></span><br><span class="line">        mDel += mc.Add3; <span class="comment">//增加方法</span></span><br><span class="line">        mDel += mc.Add2; <span class="comment">//增加方法</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Value: <span class="subst">&#123; mDel() &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Value: 12</span><br></pre></td></tr></table></figure>
<h2 id="调用带引用参数的委托"><a href="#调用带引用参数的委托" class="headerlink" title="调用带引用参数的委托"></a>调用带引用参数的委托</h2><p>如果委托有引用参数，参数值会根据调用列表中的一个或多个方法而改变。在调用委托列表中的下一个方法时，参数的新值会传给下一个方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"> <span class="keyword">ref</span> <span class="built_in">int</span> X </span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add2</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x</span>)</span> &#123; x += <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add3</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x</span>)</span> &#123; x += <span class="number">3</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        MyDel mDel = mc.Add2;</span><br><span class="line">        mDel += mc.Add3;</span><br><span class="line">        mDel += mc.Add2;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">5</span>;</span><br><span class="line">        mDel(<span class="keyword">ref</span> x);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Value: <span class="subst">&#123; x &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Value: 12</span><br></pre></td></tr></table></figure>
<p>如果没有 ref 关键字，则每个方法的参数都为5，所以上述案例的输出也为5。</p>
<h2 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h2><p><strong>匿名方法 anonymous method</strong>是在实例化委托时内联(inline)声明的方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具名方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add20</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">OtherDel</span>(<span class="params"><span class="built_in">int</span> InParam</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OtherDel del = Add20;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, del(<span class="number">5</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, del(<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">OtherDel</span>(<span class="params"><span class="built_in">int</span> InParam</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OtherDel del = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">return</span> x + <span class="number">20</span>;</span><br><span class="line">                        &#125;;</span><br><span class="line">        </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, del(<span class="number">5</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, del(<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述两组代码输入都是：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">25</span><br><span class="line">26</span><br></pre></td></tr></table></figure>
<h3 id="使用匿名方法"><a href="#使用匿名方法" class="headerlink" title="使用匿名方法"></a>使用匿名方法</h3><p>我们可以在以下地方使用匿名方法：<br>①声明委托变量时作为初始化表达式；<br>②组合委托时在赋值语句的右边；<br>③为委托增加事件时，在赋值语句的右边。见第15章。</p>
<h3 id="匿名方法的语法"><a href="#匿名方法的语法" class="headerlink" title="匿名方法的语法"></a>匿名方法的语法</h3><p>匿名方法表达式的语法包含如下组成部分：<br>① delegate 类型关键字；<br>②参数列表，若语句块没有使用任何参数可以省略；<br>③语句块，包含匿名方法的代码。</p>
<p>格式：<code>delegate ( Parameters ) &#123; ImplementationCode &#125;</code></p>
<p><strong><em>1、返回类型</em></strong><br>匿名方法不会显式声明返回值，但是必须返回一个与委托的返回值类型相同的值。如果委托是 void 类型的返回值，则匿名方法不能返回值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">OtherDel</span>(<span class="params"><span class="built_in">int</span> InParam</span>)</span>; <span class="comment">//委托类型的返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    OtherDel del = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> x + <span class="number">20</span> ; <span class="comment">//返回一个整数型</span></span><br><span class="line">                &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>2、参数</em></strong><br>除了数组参数，匿名方法的参数列表必须在这几个方面与委托匹配：参数数量；参数的类型以及位置；修饰符。</p>
<p>可以使用空括号或者省略括号，但是需要满足2个条件：①委托的参数列表不包含任何 out 参数；②匿名方法不使用任何参数。如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">SomeDel</span> (<span class="params"> <span class="built_in">int</span> X </span>)</span>; <span class="comment">//声明委托类型</span></span><br><span class="line"></span><br><span class="line">SomeDel SDel = <span class="built_in">delegate</span> <span class="comment">//省略参数列表，因为不使用参数</span></span><br><span class="line">            &#123;</span><br><span class="line">                PrintMessage();</span><br><span class="line">                Cleanup();</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>3、params 参数</em></strong><br>如果委托声明的参数列表包含了 params 参数，那么匿名方法的参数列表将忽略 params 关键字。如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">SomeDel</span>(<span class="params"> <span class="built_in">int</span> X, <span class="keyword">params</span> <span class="built_in">int</span>[] Y</span>)</span>; <span class="comment">//委托类型声明中使用params关键字</span></span><br><span class="line"></span><br><span class="line">SomeDel mDel = <span class="built_in">delegate</span> (<span class="built_in">int</span> X, <span class="built_in">int</span>[] Y) <span class="comment">//在匹配的匿名方法中省略关键字</span></span><br><span class="line">            &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="变量和参数的作用域"><a href="#变量和参数的作用域" class="headerlink" title="变量和参数的作用域"></a>变量和参数的作用域</h3><p>参数以及声明在匿名方法内部的局部变量的作用域限制在实现代码的主体中。</p>
<p>如下，匿名方法定义的参数 y 和局部变量 z 。在匿名方法主体结束之后，y 和 z 就不在作用域之内。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"> <span class="built_in">int</span> x</span>)</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">MyDel mDel = <span class="built_in">delegate</span> (<span class="built_in">int</span> y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> z = <span class="number">10</span>;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>, y, z);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>, y, z); <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<p><strong><em>1、外部变量</em></strong><br>匿名方法可以访问它们外围作用域的局部变量和环境。外围作用域的变量叫做<strong>外部变量 outer variable</strong>。用在匿名方法实现代码中的外部变量称为被方法<strong>捕获</strong>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">5</span>; <span class="comment">//变量x定义在匿名方法作用域的前面</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">MyDel mDel = <span class="built_in">delegate</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, x); <span class="comment">//变量x可以在匿名方法作用域内使用</span></span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>
<p><strong><em>2、捕获变量的生命周期的扩展</em></strong><br>如下，局部变量x在块中声明并初始化，然后委托 mDel 用匿名方法初始化，该匿名方法捕获了外部变量x。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"> </span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyDel mDel;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">5</span>; <span class="comment">//变量x定义在外部块里，在匿名方法之外</span></span><br><span class="line"></span><br><span class="line">        mDel = <span class="built_in">delegate</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;Value of x: &#123;0&#125;&quot;</span>, x); <span class="comment">//变量x被匿名方法捕获</span></span><br><span class="line">                &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Console.WriteLine(&quot;Value of x: &#123;0&#125;&quot;, x); 变量x离开了作用域并且会导致编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != mDel)</span><br><span class="line">        mDel(); <span class="comment">//而这里在匿名方法内部使用了x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Value of x: 5</span><br></pre></td></tr></table></figure>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p><strong>Lambda 表达式</strong>简化了匿名方法的语法。在匿名方法中，delegate 有点多余，我们可以通过①删除 delegate 关键字，和②在参数列表和匿名方法主体之间放置 <strong>Lambda 运算符 =&gt;</strong> 来把匿名方法转换为 Lambda 表达式。Lambda 运算符读做“goes to”。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDel del = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)    &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125; ; <span class="comment">//匿名方法</span></span><br><span class="line">MyDel le1 =         (<span class="built_in">int</span> x) =&gt; &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125; ; <span class="comment">//Lambda表达式</span></span><br></pre></td></tr></table></figure>
<p>①因为编译器还可以从委托的声明中知道委托参数的类型，因此 Lambda 表达式允许省略类型参数；<br>②如果只有一个隐式类型参数，可以省略括号；<br>③Lambda 表达式允许表达式的主体是语句块或表达式。如果语句块包含了一个返回语句，可以将语句块替换为 return 关键字后的表达式。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDel le1 =         (<span class="built_in">int</span> x) =&gt; &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125; ; <span class="comment">//Lambda表达式</span></span><br><span class="line">MyDel le2 =             (x) =&gt; &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125; ; <span class="comment">//Lambda表达式</span></span><br><span class="line">MyDel le3 =              x  =&gt; &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125; ; <span class="comment">//Lambda表达式</span></span><br><span class="line">MyDel le4 =              x  =&gt;          x + <span class="number">1</span>    ; <span class="comment">//Lambda表达式</span></span><br></pre></td></tr></table></figure>
<p>Lambda 表达式的参数列表的要点如下：<br>①Lambda 表达式参数列表中的参数必须在参数数量、类型和位置上与委托相匹配；<br>②表达式的参数列表中的参数不一定需要包含类型（隐式类型），除非委托有 ref 和 out 参数，则必须注明类型（显式类型）；<br>③如果只有一个参数，并且是隐式类型，则括号可以省略；<br>④如果没有参数必须使用一组空的圆括号。</p>
<h1 id="第十五章-事件"><a href="#第十五章-事件" class="headerlink" title="第十五章 事件"></a>第十五章 事件</h1><h2 id="发布者和订阅者"><a href="#发布者和订阅者" class="headerlink" title="发布者和订阅者"></a>发布者和订阅者</h2><p>很多程序需要当某一特定的程序事件发生时，程序的其他部分可以得到该事件已经发生的通知。<strong>发布者/订阅者模式 publisher / subscriber pattern</strong> 可以满足这个需求。在这种模式下，<strong>发布者类</strong>定义了一系列事件成员。其他类可以“注册”，以便这些事件发生时收到通知。这些<strong>订阅者类</strong>通过向发布者提供一个方法来“注册”以获取通知。当事件发生时，发布者“触发事件”，然后执行订阅者提交的所有事件。由订阅者提供的方法称为<strong>回调方法 callback methods</strong>，因为发布者通过执行订阅者的方法“calls the subscribers back”。也可以称为<strong>事件处理程序 event handlers</strong>。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/03/GvWbIk84gY7MpsT.png" width = "80%" height = "80%" alt="图67 - 发布者和订阅者"/>
</div>

<p>①<strong>发布者 publisher</strong> ：发布某个事件的类或结构；<br>②<strong>订阅者 subscriber</strong> ：注册并在事件发生时得到通知的类或结构；<br>③<strong>事件处理程序 event handler</strong> ：订阅者注册到事件的方法，在发布者触发事件时执行。事件处理程序方法可以定义在事件所在的类或结构里，也可以定义在不同的类或结构里；<br>④<strong>触发事件 Raising an event</strong> ：当调用 invoke 或触发 fire 事件，所有注册到它的方法都会被依次调用。</p>
<p><strong>事件</strong>和委托类似，实际上事件包含了一个私有委托，如下图：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/03/hGtlFfVYb8DjeB5.png" width = "50%" height = "50%" alt="图68 - 事件有被封装的委托"/>
</div>

<p>事件的私有委托的重要事项如下：<br>①事件提供了对它私有控制的委托的结构化方法，即无法直接访问委托；<br>②事件中可用的操作比委托少，对于事件只可以添加、删除或调用事件处理程序；<br>③事件被触发时，它调用委托来依次调用调用列表中的方法。</p>
<p>下图演示了一个叫做 Incrementer 的类：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/03/qHBh6jzQoIwYAnR.png" width = "70%" height = "70%" alt="图69 - 具有一个事件的类的结构和术语"/>
</div>

<h2 id="源代码组件概览"><a href="#源代码组件概览" class="headerlink" title="源代码组件概览"></a>源代码组件概览</h2><p>需要在事件中使用的代码有5部分：<br>①<strong>委托类型声明</strong>：事件和事件处理程序必须有共同的签名和返回类型；<br>②<strong>事件处理程序声明</strong>：订阅者类中会在事件触发时执行的方法的声明，可以是匿名方法或者是 Lambda 表达式；<br>③<strong>事件声明</strong>：发布者类必须声明一个订阅者类可以注册的事件成员。当类声明的事件为 public 时，称为发布了事件；<br>④<strong>事件注册</strong>：订阅者必须注册事件才能在事件被触发时得到通知，这是将事件处理程序与事件相连的代码；<br>⑤<strong>触发事件的代码</strong>：发布者类中触发事件并导致调用注册的所有事件处理程序的代码。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/03/IsnQ2Wdi8bY4Tt1.png" width = "50%" height = "50%" alt="图70 - 使用事件时的5个源代码组件"/>
</div>

<h2 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h2><p>发布者类必须提供<strong>事件对象</strong>。事件声明在一个类中，它需要委托类型的名称，任何附加在事件（如注册）的处理程序都必须与委托类型的签名和返回类型匹配。事件需声明为 public ，这样其他的类和结构可以在它上面注册事件处理程序。不能使用对象创建表达式，即 new，来创建事件对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Incrementer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CountedADozen; <span class="comment">//EventHandler为委托类型，CountedADozen为事件名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent1, MyEvent2, OtherEvent; <span class="comment">//可以通过逗号分隔来声明一个以上的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> EventHandler CountedADozen; <span class="comment">//可以使用 static 关键字让事件变成静态的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>事件是成员</strong>，和方法、属性一样，是类或结构的成员：<br>①由于事件是成员，不能在一段可执行代码中声明事件，它必须声明在类或结构中；<br>②事件成员被隐式自动初始化为 null。</p>
<p>BCL 声明了一个叫作 EventHandler 的委托，专门用于系统事件，见后面。</p>
<h2 id="订阅事件"><a href="#订阅事件" class="headerlink" title="订阅事件"></a>订阅事件</h2><p>订阅者向事件添加事件处理程序，其必须具有与事件委托相同的返回类型和签名。使用 += 运算符为事件添加事件处理程序，可以是实例方法、静态方法、匿名方法和 Lambda 表达式。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//incrementer为类，CountedADozen为类的事件成员</span></span><br><span class="line">incrementer.CountedADozen += IncrementDozensCount; <span class="comment">//实例方法</span></span><br><span class="line">incrementer.CountedADozen += ClassB.CounterHandlerB; <span class="comment">//静态方法</span></span><br><span class="line"></span><br><span class="line">mc.CountedADozen += <span class="keyword">new</span> EventHandler(cc.CounterHandlerC); <span class="comment">//委托形式的实例方法</span></span><br><span class="line"></span><br><span class="line">incrementer.CountedADozen += () =&gt; DozensCount++; <span class="comment">//Lambda表达式</span></span><br><span class="line"></span><br><span class="line">incrementer.CountedADozen += <span class="built_in">delegate</span> &#123; DozensCount++; &#125;; <span class="comment">//匿名方法</span></span><br></pre></td></tr></table></figure>
<h2 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h2><p>事件成员本身只保存了需要被调用的事件处理程序，需要在合适的时候触发事件，代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CountedADozen != <span class="literal">null</span>) <span class="comment">//确定有方法可以执行</span></span><br><span class="line">    CountedADozen (source, args); <span class="comment">//触发事件，包括事件名称和参数列表，参数列表必须与事件的委托类型相匹配</span></span><br></pre></td></tr></table></figure>
<p>把事件声明和触发事件的代码合并，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Incrementer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CountedADozen; <span class="comment">//声明事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoCount</span>(<span class="params"><span class="built_in">object</span> source, EventArgs args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="built_in">int</span> i=<span class="number">1</span>; i &lt; <span class="number">100</span>; i++ )</span><br><span class="line">            <span class="keyword">if</span>( i % <span class="number">12</span> == <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">if</span> (CountedADozen != <span class="literal">null</span>)</span><br><span class="line">                    CountedADozen(source, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下展示了整个程序，包含发布者类 Incrementer 和订阅者类 Dozens：<br>①在构造函数内，Dozens 类订阅事件，将 IncrementDozensCount 作为事件处理程序；<br>②在 Incrementer 类的 DoCount 方法中，每增加12个计数就触发 CountedADozen 事件。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Handler</span>()</span>; <span class="comment">//声明委托</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发布者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Incrementer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Handler CountedADozen; <span class="comment">//创建事件并发布</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoCount</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++ )</span><br><span class="line">            <span class="keyword">if</span> ( i % <span class="number">12</span> == <span class="number">0</span> &amp;&amp; CountedADozen != <span class="literal">null</span> )</span><br><span class="line">                CountedADozen(); <span class="comment">//每增加12个计数触发事件一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dozens</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> DozensCount &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dozens</span>(<span class="params"> Incrementer incrementer </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DozensCount = <span class="number">0</span>;</span><br><span class="line">        incrementer.CountedADozen += IncrementDozensCount; <span class="comment">//订阅事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IncrementDozensCount</span>() <span class="comment">//声明事件处理程序</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        DozensCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Incrementer incrementer = <span class="keyword">new</span> Incrementer();</span><br><span class="line">        Dozens dozensCounter = <span class="keyword">new</span> Dozens( incrementer );</span><br><span class="line"></span><br><span class="line">        incrementer.DoCount();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Number of dozens = &#123;0&#125;&quot;</span>, dozensCounter.DozensCount );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Number of dozens = 8</span><br></pre></td></tr></table></figure>
<h2 id="标准事件的用法"><a href="#标准事件的用法" class="headerlink" title="标准事件的用法"></a>标准事件的用法</h2><p>GUI 编程是事件驱动的，即程序运行时可以被事件打断，比如按钮点击或系统定时器。程序事件的异步 asynchronous 处理是使用 C# 事件的绝佳场景。.NET 框架提供一个标准模式，其基础就是 System 命名空间中声明的 <strong>EventHandler 委托类型</strong>。</p>
<p>EventHandler 委托类型的声明代码：<code>public delegate void EventHandler(object sender, EventArgs e);</code><br>①第一个参数用来保存触发事件的对象的引用，由于是 object 类型，可以匹配任何类型的实例；<br>②第二个参数用来保存状态信息，指明什么类型适用于该应用程序；<br>③返回类型为 void 。</p>
<p>EventHandler 委托类型的第二个参数是 <strong>EventArgs 类</strong>的对象，它声明在 System 命名空间中：<br>① EventArgs 不能传递任何数据，它用于不需要传递数据的事件处理程序；<br>②如果要传递数据，必须声明一个派生自 EventArgs 的类，并使用合适的字段来保存需要传递的数据。</p>
<p>EventArgs 类是使用 EventHandler 委托模式的重要部分。不管参数的实际类型是什么，object 和 EventArgs 类型的参数总是基类。这样 EventHandler 就能提供一个对所有事件和事件处理器都通用的签名，让所有事件都正好有两个参数。</p>
<p>以下代码修改了之前的 Incrementer，让它使用 EventHandler 委托，触发事件的代码在调用事件时必须使用适当的参数类型的对象：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发布者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Incrementer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CountedADozen; <span class="comment">//使用系统定义的EventHandler委托</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoCount</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++ )</span><br><span class="line">            <span class="keyword">if</span> ( i % <span class="number">12</span> == <span class="number">0</span> &amp;&amp; CountedADozen != <span class="literal">null</span> )</span><br><span class="line">                CountedADozen(<span class="keyword">this</span>, <span class="literal">null</span>); <span class="comment">//触发事件时使用EventHandler的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dozens</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> DozensCount &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dozens</span>(<span class="params"> Incrementer incrementer </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DozensCount = <span class="number">0</span>;</span><br><span class="line">        incrementer.CountedADozen += IncrementDozensCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IncrementDozensCount</span>(<span class="params"><span class="built_in">object</span> source, EventArgs e</span>) <span class="comment">//签名与委托的签名匹配</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        DozensCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Incrementer incrementer = <span class="keyword">new</span> Incrementer();</span><br><span class="line">        Dozens dozensCounter = <span class="keyword">new</span> Dozens( incrementer );</span><br><span class="line"></span><br><span class="line">        incrementer.DoCount();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Number of dozens = &#123;0&#125;&quot;</span>, dozensCounter.DozensCount );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过扩展-EventArgs-来传递数据"><a href="#通过扩展-EventArgs-来传递数据" class="headerlink" title="通过扩展 EventArgs 来传递数据"></a>通过扩展 EventArgs 来传递数据</h3><p>为了向自己的事件处理程序的第二个参数传入数据，需要声明一个派生自 EventArgs 的自定义类，用于保存我们需要传入的数据。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IncrementerEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> IterationCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//存储一个整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了一个自定义类，可以向事件处理程序的第二个参数传递数据，但需要一个使用新自定义类的委托类型，可以使用<strong>泛型版本的委托 generic version of delegate</strong>：EventHandler&lt;&gt;。详见第18章。要使用泛型委托，要将自定义类的名称放在尖括号内：<code>public event EventHandler&lt;IncrementerEventArgs&gt; CountedADozen;</code></p>
<p>以下代码更新了 Incrementer，使用了自定义类和泛型委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IncrementerEventArgs</span> : <span class="title">EventArgs</span> <span class="comment">//自定义类派生自EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> IterationCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//存储一个整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Incrementer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;IncrementerEventArgs&gt; CountedADozen;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoCount</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IncrementerEventArgs args = <span class="keyword">new</span> IncrementerEventArgs(); <span class="comment">//创建自定义类实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++ )</span><br><span class="line">            <span class="keyword">if</span> ( i % <span class="number">12</span> == <span class="number">0</span> &amp;&amp; CountedADozen != <span class="literal">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                args.IterationCount = i;</span><br><span class="line">                CountedADozen( <span class="keyword">this</span>, args ); <span class="comment">//在触发事件时传递参数</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dozens</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> DozensCount &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dozens</span>(<span class="params"> Incrementer incrementer </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DozensCount = <span class="number">0</span>;</span><br><span class="line">        incrementer.CountedADozen += IncrementDozensCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IncrementDozensCount</span>(<span class="params"> <span class="built_in">object</span> source, IncrementerEventArgs e </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Incremented at iteration: <span class="subst">&#123; e.IterationCount &#125;</span> in <span class="subst">&#123; source.ToString() &#125;</span>&quot;</span>);</span><br><span class="line">        DozensCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Incrementer incrementer = <span class="keyword">new</span> Incrementer();</span><br><span class="line">        Dozens dozensCounter = <span class="keyword">new</span> Dozens( incrementer );</span><br><span class="line"></span><br><span class="line">        incrementer.DoCount();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Number of dozens = <span class="subst">&#123; dozensCounter.DozensCount &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下，Counter.Incrementer 的 Counter 是命名空间的名称：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Incremented at iteration: 12 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 24 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 36 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 48 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 60 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 72 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 84 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 96 in Counter.Incrementer</span><br><span class="line">Number of dozens = 8</span><br></pre></td></tr></table></figure>
<h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><p>可以利用 -= 运算符把事件处理程序从事件移除：<code>p.SimpleEvent -= s.MethodB;</code></p>
<p>实例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler SimpleEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseTheEvent</span>()</span> &#123; SimpleEvent( <span class="keyword">this</span>, <span class="literal">null</span> ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodA</span>(<span class="params"> <span class="built_in">object</span> o, EventArgs e </span>)</span> &#123; Console.WriteLine( <span class="string">&quot;AAA&quot;</span> ); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodB</span>(<span class="params"> <span class="built_in">object</span> o, EventArgs e </span>)</span> &#123; Console.WriteLine( <span class="string">&quot;BBB&quot;</span> ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Publisher p = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Subscriber s = <span class="keyword">new</span> Subscriber();</span><br><span class="line"></span><br><span class="line">        p.SimpleEvent += s.MethodA;</span><br><span class="line">        p.SimpleEvent += s.MethodB;</span><br><span class="line">        p.RaiseTheEvent();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine( <span class="string">&quot;\r\nRemove MethodB&quot;</span> );</span><br><span class="line">        p.SimpleEvent -= s.MethodB;</span><br><span class="line">        p.RaiseTheEvent();</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">AAA</span><br><span class="line">BBB</span><br><span class="line"></span><br><span class="line">Remove MethodB</span><br><span class="line">AAA</span><br></pre></td></tr></table></figure>
<h2 id="事件访问器-Event-Accessors"><a href="#事件访问器-Event-Accessors" class="headerlink" title="事件访问器 Event Accessors"></a>事件访问器 Event Accessors</h2><p>事件只允许 += 和 -= 运算符，但是我们可以修改这两个运算符的行为，让事件执行自定义的代码。由于是高级主题，这里只简单介绍。</p>
<p>要改变这两个运算符的操作，必须为事件定义<strong>事件访问器</strong>：<br>①有两个访问器：add 和 remove；<br>②声明事件的访问器看上去和声明属性差不多；</p>
<p>示例如下，两个访问器都有叫做 value 的隐式值参数，接受实例或静态方法的引用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler CountedADozen</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">add</span></span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">//执行+=运算符的代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">remove</span></span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">//执行-=运算符的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明了事件访问器之后，事件不包含任何内嵌委托对象。必须实现自己的机制来存储和移除事件注册的方法。事件访问器表现为 void 方法，不能使用 return 语句返回值。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io">鸟布</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io/2022/12/06/2022-12-06-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B2/">https://ybniaobu.github.io/2022/12/06/2022-12-06-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ybniaobu.github.io" target="_blank">鸟布的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><a class="post-meta__tags" href="/tags/net/">.net</a><a class="post-meta__tags" href="/tags/C/">C#</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src="/images/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/03/2023-02-03-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B3/" title="《C#图解教程》读书笔记（三）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《C#图解教程》读书笔记（三）</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/24/2022-11-24-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B1/" title="《C#图解教程》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《C#图解教程》读书笔记（一）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/24/2022-11-24-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B1/" title="《C#图解教程》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-24</div><div class="title">《C#图解教程》读书笔记（一）</div></div></a></div><div><a href="/2023/02/03/2023-02-03-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B3/" title="《C#图解教程》读书笔记（三）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-03</div><div class="title">《C#图解教程》读书笔记（三）</div></div></a></div><div><a href="/2023/07/07/2023-07-07-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B5/" title="《C#图解教程》读书笔记（五）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">《C#图解教程》读书笔记（五）</div></div></a></div><div><a href="/2023/03/24/2023-03-24-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B4/" title="《C#图解教程》读书笔记（四）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-24</div><div class="title">《C#图解教程》读书笔记（四）</div></div></a></div><div><a href="/2022/09/09/2022-09-09-Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="《Python编程从入门到实践》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2022/11/27/h9RxCDEfGAM53j4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-09</div><div class="title">《Python编程从入门到实践》读书笔记（一）</div></div></a></div><div><a href="/2022/09/12/2022-09-12-Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" title="《Python编程从入门到实践》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2022/11/27/h9RxCDEfGAM53j4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">《Python编程从入门到实践》读书笔记（二）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/wechat%20avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鸟布</div><div class="author-info__description">教练，我想学技术</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://niaobu.notion.site/787824630ea6480e944c1ae5ae7f4792"><i class="fa-solid fa-book"></i><span>My Notion</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ybniaobu/ybniaobu.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:niaobubob@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为了蒂法！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.</span> <span class="toc-text">第九章 表达式和运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F-Expressions"><span class="toc-number">1.1.</span> <span class="toc-text">表达式 Expressions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F-Literals"><span class="toc-number">1.2.</span> <span class="toc-text">字面量 Literals</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F-Integer-Literals"><span class="toc-number">1.2.1.</span> <span class="toc-text">整数字面量 Integer Literals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F-Real-Literals"><span class="toc-number">1.2.2.</span> <span class="toc-text">实数字面量 Real Literals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%AD%97%E9%9D%A2%E9%87%8F-Character-Literals"><span class="toc-number">1.2.3.</span> <span class="toc-text">字符字面量 Character Literals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F-String-Literals"><span class="toc-number">1.2.4.</span> <span class="toc-text">字符串字面量 String Literals</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">求值顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.3.1.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E6%80%A7-Associativity"><span class="toc-number">1.3.2.</span> <span class="toc-text">结合性 Associativity</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">简单算术运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E4%BD%99%E8%BF%90%E7%AE%97%E7%AC%A6-The-Remainder-Operator"><span class="toc-number">1.5.</span> <span class="toc-text">求余运算符 The Remainder Operator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text">关系比较运算符和相等比较运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E5%92%8C%E7%9B%B8%E7%AD%89%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.1.</span> <span class="toc-text">比较操作和相等性操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6-Increment-and-Decrement-Operators"><span class="toc-number">1.7.</span> <span class="toc-text">递增运算符和递减运算符 Increment and Decrement Operators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-Conditional-Logical-Operators"><span class="toc-number">1.8.</span> <span class="toc-text">条件逻辑运算符 Conditional Logical Operators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-Logical-Operators"><span class="toc-number">1.9.</span> <span class="toc-text">逻辑运算符 Logical Operators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6-Shift-Operators"><span class="toc-number">1.10.</span> <span class="toc-text">移位运算符 Shift Operators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-Assignment-Operators"><span class="toc-number">1.11.</span> <span class="toc-text">赋值运算符 Assignment Operators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6-The-Conditional-Operator"><span class="toc-number">1.12.</span> <span class="toc-text">条件运算符 The Conditional Operator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6-Unary-Arithmetic-Operators"><span class="toc-number">1.13.</span> <span class="toc-text">一元算术运算符 Unary Arithmetic Operators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.14.</span> <span class="toc-text">用户定义的类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6-Explicit-Conversion-and-the-Cast-Operator"><span class="toc-number">1.14.1.</span> <span class="toc-text">显式转换和转换运算符 Explicit Conversion and the Cast Operator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-Operator-Overloading"><span class="toc-number">1.15.</span> <span class="toc-text">运算符重载 Operator Overloading</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.15.1.</span> <span class="toc-text">运算符重载的示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.15.2.</span> <span class="toc-text">运算符重载的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.16.</span> <span class="toc-text">typeof 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nameof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.17.</span> <span class="toc-text">nameof 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.18.</span> <span class="toc-text">其他运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.</span> <span class="toc-text">第十章 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.1.</span> <span class="toc-text">什么是语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.</span> <span class="toc-text">表达式语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5-Flow-of-Control-Statements"><span class="toc-number">2.3.</span> <span class="toc-text">控制流语句 Flow-of-Control Statements</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.4.</span> <span class="toc-text">if 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if%E2%80%A6else-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.5.</span> <span class="toc-text">if…else 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.6.</span> <span class="toc-text">while 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do-%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.7.</span> <span class="toc-text">do 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.8.</span> <span class="toc-text">for 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.8.1.</span> <span class="toc-text">for 语句中变量的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%BF%AD%E4%BB%A3%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.8.2.</span> <span class="toc-text">初始化和迭代表达式中的多表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.9.</span> <span class="toc-text">switch 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.9.1.</span> <span class="toc-text">分支示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E5%BC%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.9.2.</span> <span class="toc-text">其他类型的模式表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%A1%A5%E5%85%85"><span class="toc-number">2.9.3.</span> <span class="toc-text">switch 语句的补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5-Jump-Statements"><span class="toc-number">2.10.</span> <span class="toc-text">跳转语句 Jump Statements</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.11.</span> <span class="toc-text">break 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#continue-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.12.</span> <span class="toc-text">continue 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5-Labeled-Statements"><span class="toc-number">2.13.</span> <span class="toc-text">标签语句 Labeled Statements</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE"><span class="toc-number">2.13.1.</span> <span class="toc-text">标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.13.2.</span> <span class="toc-text">标签语句的作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#goto-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.14.</span> <span class="toc-text">goto 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-%E8%AF%AD%E5%8F%A5%E5%86%85%E9%83%A8%E7%9A%84-goto-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.14.1.</span> <span class="toc-text">switch 语句内部的 goto 语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.15.</span> <span class="toc-text">using 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E8%B5%84%E6%BA%90%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.15.1.</span> <span class="toc-text">包装资源的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using-%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.15.2.</span> <span class="toc-text">using 语句的示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%E5%92%8C%E5%B5%8C%E5%A5%97"><span class="toc-number">2.15.3.</span> <span class="toc-text">多个资源和嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using-%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.15.4.</span> <span class="toc-text">using 语句的另外一种形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.16.</span> <span class="toc-text">其他语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">第十一章 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">什么是结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">结构是值类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">3.3.</span> <span class="toc-text">对结构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-Constructors-and-Destructors"><span class="toc-number">3.4.</span> <span class="toc-text">构造函数和析构函数 Constructors and Destructors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-Instance-Constructors"><span class="toc-number">3.4.1.</span> <span class="toc-text">实例构造函数 Instance Constructors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-Static-Constructors"><span class="toc-number">3.4.2.</span> <span class="toc-text">静态构造函数 Static Constructors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93"><span class="toc-number">3.4.3.</span> <span class="toc-text">构造函数和析构函数小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AD%97%E6%AE%B5%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.5.</span> <span class="toc-text">属性和字段初始化语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%98%AF%E5%AF%86%E5%B0%81%E7%9A%84"><span class="toc-number">3.6.</span> <span class="toc-text">结构是密封的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1-Boxing-and-Unboxing"><span class="toc-number">3.7.</span> <span class="toc-text">装箱和拆箱 Boxing and Unboxing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0"><span class="toc-number">3.8.</span> <span class="toc-text">结构作为返回值和参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%BB%93%E6%9E%84%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9"><span class="toc-number">3.9.</span> <span class="toc-text">关于结构的更多内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.</span> <span class="toc-text">第十二章 枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE-Enumerations"><span class="toc-number">4.1.</span> <span class="toc-text">枚举 Enumerations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%BA%95%E5%B1%82%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%98%BE%E5%BC%8F%E5%80%BC"><span class="toc-number">4.1.1.</span> <span class="toc-text">设置底层类型和显式值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%88%90%E5%91%98%E7%BC%96%E5%8F%B7"><span class="toc-number">4.1.2.</span> <span class="toc-text">隐式成员编号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E6%A0%87%E5%BF%97-Bit-Flags"><span class="toc-number">4.2.</span> <span class="toc-text">位标志 Bit Flags</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flags-%E7%89%B9%E6%80%A7"><span class="toc-number">4.2.1.</span> <span class="toc-text">Flags 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BD%8D%E6%A0%87%E5%BF%97%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">使用位标志的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9"><span class="toc-number">4.3.</span> <span class="toc-text">关于枚举的更多内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-number">5.</span> <span class="toc-text">第十三章 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-Arrays"><span class="toc-number">5.1.</span> <span class="toc-text">数组 Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%BB%86%E8%8A%82"><span class="toc-number">5.1.2.</span> <span class="toc-text">重要细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">数组的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.</span> <span class="toc-text">数组是对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%BB%84"><span class="toc-number">5.4.</span> <span class="toc-text">一维数组和矩形数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%88%96%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%BB%84"><span class="toc-number">5.5.</span> <span class="toc-text">实例化一维数组或矩形数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">5.6.</span> <span class="toc-text">访问数组元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">5.7.</span> <span class="toc-text">初始化数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">5.7.1.</span> <span class="toc-text">显式初始化一维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%BB%84"><span class="toc-number">5.7.2.</span> <span class="toc-text">显式初始化矩形数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%BB%84%E7%9A%84%E8%AF%AD%E6%B3%95%E7%82%B9"><span class="toc-number">5.7.3.</span> <span class="toc-text">初始化矩形数组的语法点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E8%AF%AD%E6%B3%95"><span class="toc-number">5.7.4.</span> <span class="toc-text">快捷语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">5.7.5.</span> <span class="toc-text">隐式类型数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%86%85%E5%AE%B9"><span class="toc-number">5.7.6.</span> <span class="toc-text">综合内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84-Jagged-Arrays"><span class="toc-number">5.8.</span> <span class="toc-text">交错数组 Jagged Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84"><span class="toc-number">5.8.1.</span> <span class="toc-text">声明交错数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%A1%B6%E5%B1%82%E6%95%B0%E7%BB%84"><span class="toc-number">5.8.2.</span> <span class="toc-text">实例化顶层数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84"><span class="toc-number">5.8.3.</span> <span class="toc-text">实例化交错数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">5.8.4.</span> <span class="toc-text">交错数组中的子数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%BB%84%E5%92%8C%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84"><span class="toc-number">5.9.</span> <span class="toc-text">比较矩形数组和交错数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#foreach-%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.10.</span> <span class="toc-text">foreach 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%8F%98%E9%87%8F%E6%98%AF%E5%8F%AA%E8%AF%BB%E7%9A%84"><span class="toc-number">5.10.1.</span> <span class="toc-text">迭代变量是只读的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach-%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">5.10.2.</span> <span class="toc-text">foreach 语句和多维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8D%8F%E5%8F%98-Array-Covariance"><span class="toc-number">5.11.</span> <span class="toc-text">数组协变 Array Covariance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9C%89%E7%94%A8%E6%88%90%E5%91%98"><span class="toc-number">5.12.</span> <span class="toc-text">数组继承的有用成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Clone-%E6%96%B9%E6%B3%95"><span class="toc-number">5.12.1.</span> <span class="toc-text">Clone 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E-ref-%E8%BF%94%E5%9B%9E%E5%92%8C-ref-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">5.13.</span> <span class="toc-text">数组与 ref 返回和 ref 局部变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%A7%94%E6%89%98"><span class="toc-number">6.</span> <span class="toc-text">第十四章 委托</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A7%94%E6%89%98"><span class="toc-number">6.1.</span> <span class="toc-text">什么是委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%A6%82%E8%BF%B0"><span class="toc-number">6.2.</span> <span class="toc-text">委托概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%A7%94%E6%89%98%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">声明委托类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A7%94%E6%89%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.4.</span> <span class="toc-text">创建委托对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E5%A7%94%E6%89%98%E8%B5%8B%E5%80%BC"><span class="toc-number">6.5.</span> <span class="toc-text">给委托赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%A7%94%E6%89%98-Combining-Delegates"><span class="toc-number">6.6.</span> <span class="toc-text">组合委托 Combining Delegates</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E5%A7%94%E6%89%98%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-number">6.7.</span> <span class="toc-text">为委托添加方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%A7%94%E6%89%98%E7%A7%BB%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">6.8.</span> <span class="toc-text">从委托移除方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%A7%94%E6%89%98-Invoking-a-Delegate"><span class="toc-number">6.9.</span> <span class="toc-text">调用委托 Invoking a Delegate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.10.</span> <span class="toc-text">委托的示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A7%94%E6%89%98"><span class="toc-number">6.11.</span> <span class="toc-text">调用带返回值的委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%B8%A6%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E7%9A%84%E5%A7%94%E6%89%98"><span class="toc-number">6.12.</span> <span class="toc-text">调用带引用参数的委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-number">6.13.</span> <span class="toc-text">匿名方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-number">6.13.1.</span> <span class="toc-text">使用匿名方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">6.13.2.</span> <span class="toc-text">匿名方法的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">6.13.3.</span> <span class="toc-text">变量和参数的作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.14.</span> <span class="toc-text">Lambda 表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">第十五章 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E8%AE%A2%E9%98%85%E8%80%85"><span class="toc-number">7.1.</span> <span class="toc-text">发布者和订阅者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%84%E4%BB%B6%E6%A6%82%E8%A7%88"><span class="toc-number">7.2.</span> <span class="toc-text">源代码组件概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.3.</span> <span class="toc-text">声明事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.4.</span> <span class="toc-text">订阅事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.5.</span> <span class="toc-text">触发事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">7.6.</span> <span class="toc-text">标准事件的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%89%A9%E5%B1%95-EventArgs-%E6%9D%A5%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">7.6.1.</span> <span class="toc-text">通过扩展 EventArgs 来传递数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.6.2.</span> <span class="toc-text">移除事件处理程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%99%A8-Event-Accessors"><span class="toc-number">7.7.</span> <span class="toc-text">事件访问器 Event Accessors</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/09/2024-12-09-CustomSRP2/" title="Unity Custom SRP 基础（二）"><img src="https://s2.loli.net/2024/12/09/paBhbkD6Vd9CIsy.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（二）"/></a><div class="content"><a class="title" href="/2024/12/09/2024-12-09-CustomSRP2/" title="Unity Custom SRP 基础（二）">Unity Custom SRP 基础（二）</a><time datetime="2024-12-09T08:00:29.000Z" title="发表于 2024-12-09 16:00:29">2024-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/26/2024-11-26-CustomSRP1/" title="Unity Custom SRP 基础（一）"><img src="https://s2.loli.net/2024/12/09/SGVnTxOM6BURAJI.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（一）"/></a><div class="content"><a class="title" href="/2024/11/26/2024-11-26-CustomSRP1/" title="Unity Custom SRP 基础（一）">Unity Custom SRP 基础（一）</a><time datetime="2024-11-26T04:43:30.000Z" title="发表于 2024-11-26 12:43:30">2024-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/2024-10-22-BetterPBR1/" title="Custom Better PBR in Unity"><img src="https://s2.loli.net/2024/10/22/x6Xp3JjS4k5PO2W.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Custom Better PBR in Unity"/></a><div class="content"><a class="title" href="/2024/10/22/2024-10-22-BetterPBR1/" title="Custom Better PBR in Unity">Custom Better PBR in Unity</a><time datetime="2024-10-22T03:13:12.000Z" title="发表于 2024-10-22 11:13:12">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/16/2024-08-16-IBL_Basics2/" title="IBL 基于图像的光照（二）"><img src="https://s2.loli.net/2024/08/16/KQGyA6zfCW74dYw.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IBL 基于图像的光照（二）"/></a><div class="content"><a class="title" href="/2024/08/16/2024-08-16-IBL_Basics2/" title="IBL 基于图像的光照（二）">IBL 基于图像的光照（二）</a><time datetime="2024-08-16T04:43:39.000Z" title="发表于 2024-08-16 12:43:39">2024-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/09/2024-07-09-IBL_Basics1/" title="IBL 基于图像的光照（一）"><img src="https://s2.loli.net/2024/07/22/nD1y67NcRpQOHbS.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IBL 基于图像的光照（一）"/></a><div class="content"><a class="title" href="/2024/07/09/2024-07-09-IBL_Basics1/" title="IBL 基于图像的光照（一）">IBL 基于图像的光照（一）</a><time datetime="2024-07-09T07:25:54.000Z" title="发表于 2024-07-09 15:25:54">2024-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 鸟布</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Your time is limited, so don't waste it living someone else's life.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>