<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《Learning Python》读书笔记（四） | 鸟布的博客</title><meta name="author" content="鸟布"><meta name="copyright" content="鸟布"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="该笔记为 《Learning Python》 的读书笔记，由于是早期未搞熟博客系统时所写，笔记结构较为混乱；该书涉及的内容可能过于啰嗦，但包含一些python背后的逻辑和机制，可以粗略过一遍，但若仔细阅读就是在坑自己；该笔记内容过多，所以不展示部分代码的结果，需复制到编辑器中查看；学习完成日期为2"><link rel="shortcut icon" href="https://s2.loli.net/2022/09/08/Ygib4lfw6z1khnr.png"><link rel="canonical" href="https://ybniaobu.github.io/2022/10/27/2022-10-27-Learning-python4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 鸟布","link":"链接: ","source":"来源: 鸟布的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《Learning Python》读书笔记（四）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 20:49:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/wechat%20avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/black.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鸟布的博客"><span class="site-name">鸟布的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《Learning Python》读书笔记（四）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-27T11:09:10.000Z" title="发表于 2022-10-27 19:09:10">2022-10-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T12:49:36.000Z" title="更新于 2022-11-27 20:49:36">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/">python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">python读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>83分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《Learning Python》读书笔记（四）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>该笔记为 <strong>《Learning Python》</strong> 的读书笔记，由于是早期未搞熟博客系统时所写，笔记结构较为混乱；<br>该书涉及的内容可能过于啰嗦，但包含一些python背后的逻辑和机制，可以粗略过一遍，但若仔细阅读就是在坑自己；<br>该笔记内容过多，所以不展示部分代码的结果，需复制到编辑器中查看；<br>学习完成日期为2022年10月20日。<br>本篇主要内容为：第7部分异常和第8部分高级主题：unicode编码、字节字符串、被管理的属性、装饰器、元类。</p>
</blockquote>
<div  align="center">  
<img src="https://s2.loli.net/2022/09/17/ri9Ue6nguJdq1Ca.jpg" width = "80%" height = "80%" alt="Learning Python"/>
</div>


<p><strong><font size=5>PART VII Exceptions and Tools</font></strong></p>
<h2 id="Chapter-33-Exception-Basics"><a href="#Chapter-33-Exception-Basics" class="headerlink" title="Chapter 33 Exception Basics"></a>Chapter 33 Exception Basics</h2><h3 id="一、Exception-Basics"><a href="#一、Exception-Basics" class="headerlink" title="一、Exception Basics"></a>一、Exception Basics</h3><p><strong>1、异常的5类语句</strong><br>① <code>try/except</code>：捕捉异常并从中恢复；<br>② <code>try/finally</code>：无论异常是否发生，执行清理行为；<br>③ <code>raise</code>：手动在代码中触发异常；<br>④ <code>assert</code>：有条件地在代码中触发异常；<br>⑤ <code>with/as</code>：实现环境管理器，见下一章。  </p>
<p><strong>2、异常的作用</strong><br>错误处理；事件通知；特殊情况处理；终止行为；非常规控制流程</p>
<p><strong>3、捕获异常</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fetcher</span>(<span class="params">obj, index</span>):</span><br><span class="line">    <span class="keyword">return</span> obj[index]</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;spam&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fetcher(x, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">except</span> IndexError: <span class="comment"># Catch and recover</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;got exception&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>4、引发异常： <code>raise</code> 语句</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> IndexError <span class="comment"># Trigger exception manually</span></span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;got exception&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>5、用户定义的异常</strong><br>用户定义的异常通过类来编写，它们继承自一个<strong>内置异常类 Exception</strong> ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AlreadyGotOne</span>(<span class="title class_ inherited__">Exception</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grail</span>():</span><br><span class="line">    <span class="keyword">raise</span> AlreadyGotOne() <span class="comment"># Raise an instance</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    grail()</span><br><span class="line"><span class="keyword">except</span> AlreadyGotOne:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;got exception&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>可以定制出错信息文本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Career</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="string">&#x27;So I became a waiter...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">raise</span> Career()</span><br></pre></td></tr></table></figure>
<p><strong>6、终止动作</strong><br><code>try/finally</code>组合指明结束时一定会执行的终止动作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fetcher(x, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;after fetch&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>触发异常也会执行 <code>finally</code> 代码块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">after</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fetcher(x, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;after fetch&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;after try?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">after()</span><br></pre></td></tr></table></figure>
<h2 id="Chapter-34-Exception-Coding-Details"><a href="#Chapter-34-Exception-Coding-Details" class="headerlink" title="Chapter 34 Exception Coding Details"></a>Chapter 34 Exception Coding Details</h2><h3 id="一、The-try-except-else-Statement"><a href="#一、The-try-except-else-Statement" class="headerlink" title="一、The try/except/else Statement"></a>一、The try/except/else Statement</h3><p><strong>1、 <code>try/except/else</code> 语句</strong><br>① <code>except</code>: 捕捉所有异常类型；<br>② <code>except name</code>: 只捕捉指定的异常；<br>③ <code>except name as value</code>: 捕捉所列异常并将该异常实例赋值给名称 value ；<br>④ <code>except (name1, name2)</code>: 捕捉任何列出的异常；<br>⑤ <code>except (name1, name2) as value</code>: 捕捉任何列出的异常，并将该异常实例元组赋值给名称 value ；<br>⑥ <code>else</code>: 如果没有引发异常，就会运行；<br>⑦ <code>finally</code>: 总是在退出 try 语句时运行此代码块；  </p>
<p>可以这么理解：尝试一个可能会出错的语句，除了（except）XX 错误，运行定制的语句，若没有（else）错误，运行没发生异常要执行的程序；如果 try 后面的语句执行时引发了异常，python 会回到 try 并搜索第一个与异常名称匹配的 except。</p>
<p>python会从上到下以及由左至右地检测 except 分句。</p>
<p><strong>2、合并 try 语句的语法</strong><br><code>try</code> 语句必须至少有一个 except 或一个 finally ，顺序为 <em>try -&gt; except -&gt; else -&gt; finally</em> ；如果要有 else ，必须有至少一个 except ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sep = <span class="string">&#x27;-&#x27;</span> * <span class="number">45</span> + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sep + <span class="string">&#x27;EXCEPTION RAISED AND CAUGHT&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="string">&#x27;spam&#x27;</span>[<span class="number">99</span>]</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except run&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally run&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;after run&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sep + <span class="string">&#x27;NO EXCEPTION RAISED&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="string">&#x27;spam&#x27;</span>[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except run&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally run&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;after run&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sep + <span class="string">&#x27;NO EXCEPTION RAISED, WITH ELSE&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="string">&#x27;spam&#x27;</span>[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except run&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;else run&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally run&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;after run&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sep + <span class="string">&#x27;EXCEPTION RAISED BUT NOT CAUGHT&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except run&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally run&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;after run&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="二、The-raise-Statement"><a href="#二、The-raise-Statement" class="headerlink" title="二、The raise Statement"></a>二、The raise Statement</h3><p><strong>1、引发异常</strong><br>① <code>raise instance</code><br>② <code>raise class</code><br>异常总是类的实例，如果传入一个类，python 会创建被引发的一个异常实例：即 <code>raise IndexError</code> 等价于 <code>raise IndexError()</code>；</p>
<p>如果 try 中包含了 <code>except name as X</code> ，那么 raise 中的异常实例会赋值给变量 X 。</p>
<p><strong>2、作用域和 <code>try except</code> 变量</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> X:</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br></pre></td></tr></table></figure>
<p>X 会被局限在 except 块中，而且该变量 X 会在 except 块退出后被移除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">99</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> X:</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X) <span class="comment"># 会出错：NameError: name &#x27;X&#x27; is not defined</span></span><br></pre></td></tr></table></figure>
<p>若要在 try 语句后引用该异常实例，需要赋值给另一个变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> X:</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line">    Saveit = X</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Saveit)</span><br></pre></td></tr></table></figure>
<p><strong>3、异常链：<code>raise from</code></strong><br><code>raise newexception from otherexception</code><br>from 后面跟的表达式指定了另一个异常类或实例，该异常会附加到 newexception 的 <code>__cause__</code> 属性；如果 newexception 没有被捕获，那么 python 会把2个异常都作为标准出错消息打印出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> E:</span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Bad&#x27;</span>) <span class="keyword">from</span> E</span><br></pre></td></tr></table></figure>
<p>当异常处理程序内部，程序错误地引发一个异常，一个相似的过程会自动发生：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    badname</span><br></pre></td></tr></table></figure>
<h3 id="三、The-assert-Statement"><a href="#三、The-assert-Statement" class="headerlink" title="三、The assert Statement"></a>三、The assert Statement</h3><p><strong>1、assert 可视为条件式的 raise 语句</strong><br><code>assert test, data</code><br>如果 test 为假， python 就引发异常 data 项：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">assert</span> x &lt; <span class="number">0</span>, <span class="string">&#x27;x must be negative&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>) <span class="comment"># 出现错误：AssertionError: x must be negative</span></span><br></pre></td></tr></table></figure>
<p>assert 语句中 data 是可选的；<br>assert 几乎是用来捕捉用户定义的约束条件，而不是捕捉实际的程序设计错误；<br>因为 python 会自行捕获错误，通常没必要写 assert 去捕捉：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reciprocal</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">assert</span> x != <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / x</span><br><span class="line"><span class="comment"># 上述的assert一般都是多余的</span></span><br></pre></td></tr></table></figure>
<h3 id="四、with-as-Context-Managers"><a href="#四、with-as-Context-Managers" class="headerlink" title="四、with/as Context Managers"></a>四、with/as Context Managers</h3><p><strong>1、基本用法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> expression [<span class="keyword">as</span> variable]:</span><br><span class="line">    <span class="keyword">with</span>-block</span><br></pre></td></tr></table></figure>
<p>这里的 expression 要返回一个支持上下文管理协议的对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;C:\misc\data&#x27;</span>) <span class="keyword">as</span> myfile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> myfile:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>try/finally</code> 语句来实现类似的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myfile = <span class="built_in">open</span>(<span class="string">r&#x27;C:\misc\data&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> myfile:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    myfile.close()</span><br></pre></td></tr></table></figure>
<p><strong>2、上下文管理协议</strong><br>可以自己编写一个上下文管理器（未摘抄，有兴趣再查阅）</p>
<h2 id="Chapter-35-Exception-Objects"><a href="#Chapter-35-Exception-Objects" class="headerlink" title="Chapter 35 Exception Objects"></a>Chapter 35 Exception Objects</h2><h3 id="一、Class-Based-Exceptions"><a href="#一、Class-Based-Exceptions" class="headerlink" title="一、Class-Based Exceptions"></a>一、Class-Based Exceptions</h3><p><strong>1、编写异常类</strong><br>异常类拥有状态信息和行为，支持继承：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">General</span>(<span class="title class_ inherited__">Exception</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Specific1</span>(<span class="title class_ inherited__">General</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Specific2</span>(<span class="title class_ inherited__">General</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raiser0</span>():</span><br><span class="line">    X = General()</span><br><span class="line">    <span class="keyword">raise</span> X </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raiser1</span>():</span><br><span class="line">    X = Specific1()</span><br><span class="line">    <span class="keyword">raise</span> X</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raiser2</span>():</span><br><span class="line">    X = Specific2()</span><br><span class="line">    <span class="keyword">raise</span> X</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> (raiser0, raiser1, raiser2):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">except</span> General:</span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;caught: %s&#x27;</span> % sys.exc_info()[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p><code>sys.exc_info</code> 用于抓取最近发生的异常，它的结果第一个元素是被引发的异常类，第二个元素是实际被引发的实例。</p>
<h3 id="二、Built-in-Exception-Classes"><a href="#二、Built-in-Exception-Classes" class="headerlink" title="二、Built-in Exception Classes"></a>二、Built-in Exception Classes</h3><p><strong>1、Python 能够引发的所有内置异常都是预定义的类对象，可通过 builtin 模块中的内置名称使用</strong><br>① <code>BaseException</code>：异常的顶层根父类，该类不应由用户定义的类直接继承，它提供了子类可继承的默认打印和状态保持行为；<br>② <code>Exception</code>：用户定义的异常的根父类，它是 BaseException 类的一个直接子类，并且是除系统退出事件类外，所有其他内置异常的父类；<br>③ <code>ArithmeticError</code>：Exception 的子类，数字错误的根父类，它的子类包括 <code>OverflowError</code> ,  <code>ZeroDivisionError</code> 和 <code>Floating PointError</code> ；<br>④ <code>LookupError</code>：Exception 的子类，索引错误的根父类，它的子类包括 <code>IndexError</code> ,  <code>KeyError</code> 等等。  </p>
<p><strong>2、默认打印和状态</strong><br>传递给内置异常类的参数，都会被自动保存在实例的 args 元组属性中，并且在打印该实例的时候自动显示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> IndexError</span><br><span class="line"><span class="keyword">raise</span> IndexError(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">I = IndexError(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(I.args)</span><br><span class="line"><span class="built_in">print</span>(I)</span><br></pre></td></tr></table></figure>
<p>用户定义的异常类同样如此：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>(<span class="title class_ inherited__">Exception</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">raise</span> E</span><br><span class="line"><span class="keyword">raise</span> E(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">I = E(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(I.args)</span><br><span class="line"><span class="built_in">print</span>(I)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> E(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> E <span class="keyword">as</span> X:</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line">    <span class="built_in">print</span>(X.args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(X))</span><br></pre></td></tr></table></figure>
<p><strong>3、定制的打印显示</strong><br>除了像上面传递参数来定制显示，也可以定义 <code>__str__</code> 或 <code>__repr__</code> 来返回希望显示的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBad</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Always look on the bright side of life...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyBad()</span><br><span class="line"><span class="keyword">except</span> MyBad <span class="keyword">as</span> X:</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">raise</span> MyBad()</span><br></pre></td></tr></table></figure>
<h3 id="三、Custom-Data-and-Behavior"><a href="#三、Custom-Data-and-Behavior" class="headerlink" title="三、Custom Data and Behavior"></a>三、Custom Data and Behavior</h3><p><strong>1、内置异常父类提供了一个默认的构造函数，把构造函数参数自动存储到了一个名为 args 的实例元组属性中</strong>  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FormatError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, line, file</span>):</span><br><span class="line">        self.line = line</span><br><span class="line">        self.file = file</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parser</span>():</span><br><span class="line">    <span class="keyword">raise</span> FormatError(<span class="number">42</span>, file=<span class="string">&#x27;spam.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    parser()</span><br><span class="line"><span class="keyword">except</span> FormatError <span class="keyword">as</span> X:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error at: %s %s&#x27;</span> % (X.file, X.line))</span><br></pre></td></tr></table></figure>
<p><strong>2、提供异常方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FormatError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    logfile = <span class="string">&#x27;formaterror.txt&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, line, file</span>):</span><br><span class="line">        self.line = line</span><br><span class="line">        self.file = file</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">logerror</span>(<span class="params">self</span>):</span><br><span class="line">        log = <span class="built_in">open</span>(self.logfile, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error at:&#x27;</span>, self.file, self.line, file=log)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parser</span>():</span><br><span class="line">    <span class="keyword">raise</span> FormatError(<span class="number">40</span>, <span class="string">&#x27;spam.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    parser()</span><br><span class="line"><span class="keyword">except</span> FormatError <span class="keyword">as</span> exc:</span><br><span class="line">    exc.logerror()</span><br></pre></td></tr></table></figure>
<h2 id="Chapter-36-Designing-with-Exceptions"><a href="#Chapter-36-Designing-with-Exceptions" class="headerlink" title="Chapter 36 Designing with Exceptions"></a>Chapter 36 Designing with Exceptions</h2><h3 id="一、Nesting-Exception-Handlers"><a href="#一、Nesting-Exception-Handlers" class="headerlink" title="一、Nesting Exception Handlers"></a>一、Nesting Exception Handlers</h3><p><strong>嵌套异常：</strong><br>①示例：控制流嵌套：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">action2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span> + []) <span class="comment"># Generate TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">action1</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        action2()</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;inner try&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    action1()</span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;outer try&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>②示例：语法嵌套化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">raise1</span>(): <span class="keyword">raise</span> IndexError</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">noraise</span>(): <span class="keyword">return</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raise2</span>(): <span class="keyword">raise</span> SyntaxError</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> (raise1, noraise, raise2):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&lt;%s&gt;&#x27;</span> % func.__name__)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            func()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;caught IndexError&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;finally run&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;...&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="二、Exception-Idioms"><a href="#二、Exception-Idioms" class="headerlink" title="二、Exception Idioms"></a>二、Exception Idioms</h3><p><strong>跳出多重循环嵌套</strong><br>可以用 raise 来跳出循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exitloop</span>(<span class="title class_ inherited__">Exception</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">3</span>: <span class="keyword">raise</span> Exitloop</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;loop3: %s&#x27;</span> % i)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;loop2&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;loop1&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exitloop:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;continuing&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果 raise 换成 break ，会无线循环，因为只是跳出了 for 循环，没有跳出 while 循环。</p>
<p><strong><font size=5>PART VIII Advanced Topics</font></strong></p>
<h2 id="Chapter-37-Unicode-and-Byte-Strings"><a href="#Chapter-37-Unicode-and-Byte-Strings" class="headerlink" title="Chapter 37 Unicode and Byte Strings"></a>Chapter 37 Unicode and Byte Strings</h2><h3 id="一、String-Basics"><a href="#一、String-Basics" class="headerlink" title="一、String Basics"></a>一、String Basics</h3><p><strong>1、python 3.X 中的字符串修改</strong><br>python 2.X的 str 和 unicode 类型以及融入了python 3.X的 bytes 和 str 类型，而且新增了 bytearray 可变类型：<br>①如果使用 ASCII 或 UTF-8 ，普通的字符串 str 对象和文本文件能够应对；<br>②处理非 ASCII 的 Unicode 文本，3.X 比 2.X 对其的支持更直接好用；<br>③处理二进制数据，例如图像或音频文件，需要理解 bytes 对象。</p>
<p><strong>2、字符编码方案</strong><br><strong>ASCII 标准</strong>定义了从0到127的字符编码，并且允许每个字符存储在一个8位的字节中，实际上只有7位被用到（2^7=128)；</p>
<p><code>ord</code> 函数返回字符的二进制识别值（Unicode码点序数），<code>chr</code> 函数返回给定整数编码值的对应字符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;啊&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">97</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">97</span>))</span><br></pre></td></tr></table></figure>
<p>各种符号和重音字符并不在 ASCII 所定义的字符范围内。为了容纳特殊字符，一些标准使用一个8位字节所有可能的值（0到255），并把 ASCII 范围以外的128-255分配给特殊字符，其中一个标准叫 <strong>Latin-1 字符集</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">196</span>))</span><br></pre></td></tr></table></figure>
<p><strong>Unicode 文本</strong>用以表示欧洲、亚洲和其他非英语的字符集，拥有比8位字节更多的字符；</p>
<p>字节和字符串之间的转换由2个术语定义：<br>①<strong>编码 Encoding</strong> ：把字符串翻译为原始字节形式的过程；<br>②<strong>解码 Decoding</strong> ：把一个原始字符串翻译为字符串的过程。  </p>
<p><strong>UTF-8 编码</strong>，采用可变的字节数 byte（8 bit 比特、位）来表示众多字符：<br>小于128的字符码为1个字节；128和 0x7ff (2047)之间的字符码转换为两个字节，其中每个字节的值都位于128-255之间， 0x7ff 以上的代码转换为3个或4个字节序列，序列每个字节的值都位于128-255之间。</p>
<p>ASCII 是 Latin-1 和 UTF-8 的子集，即 ASCII 字符串也是有效的 Latin-1 和 UTF-8 编码字符串；ASCII 、Latin-1 、UTF-8 以及很多其他的编码，都被认为是 Unicode ；</p>
<p><strong>UTF-16</strong> 和 <strong>UTF-32</strong> 分别按照每字符固定大小的2个和4个字节来格式化文本。<br>2个字符的 ASCII 字符串是2个字节，但是在 UTF-16 和 UTF-32 中它会更宽，并包含头部的字节：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;ni&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;ascii&#x27;</span>), S.encode(<span class="string">&#x27;latin1&#x27;</span>), S.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf16&#x27;</span>), <span class="built_in">len</span>(S.encode(<span class="string">&#x27;utf16&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf32&#x27;</span>), <span class="built_in">len</span>(S.encode(<span class="string">&#x27;utf32&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<p><strong>3、Python 如何在内存中存储字符串的</strong><br>Python 3.3 以后，在内存中 python 为每个字符分配1、2或4个字节。</p>
<p><strong>4、Python 的字符串类型</strong><br>Python 3.X 带有3中字符串对象类型：<br>① <code>str</code> 表示解码的 Unicode 文本（包括 ASCII ）；<br>② <code>bytes</code> 表示二进制数据（包括编码的文本）；<br>③ <code>bytearray</code>，一种可变的 bytes 类型。  </p>
<p><strong>5、文本和二进制文件</strong><br><strong>文本文件</strong>：当一个文件以文本模式打开时，读取其数据会自动将内容解码，并且将解码的内容返回为一个 <strong>str</strong> ：写入内容需要一个 <strong>str</strong> ，并且将其传输到文件之前自动编码它；<br><strong>二进制文件</strong>：通过内置 <code>open</code> 函数的模式字符串参数添加一个 <strong>b</strong> ，就能以二进制模式打开文件，此时读取其数据不会解码它，而是将其作为一个 <strong>bytes</strong> 对象；写入同理，接受 <strong>bytes</strong> 对象。  </p>
<p>如果处理图像文件、经网络传输的数据、必须解压的打包二进制数据等等，使用 bytes 和二进制模式文件处理合适；<br>如果要处理的内容本质是文本化的，例如程序输出、 HTML 、电子邮件内容或 CSV 或 XML 文件，使用 str 和文本模式合适。</p>
<h3 id="二、Coding-Basic-Strings"><a href="#二、Coding-Basic-Strings" class="headerlink" title="二、Coding Basic Strings"></a>二、Coding Basic Strings</h3><p><strong>1、字符串字面量</strong><br><code>&#39;xxx&#39;</code>、<code>&quot;xxx&quot;</code>、<code>&#39;&#39;&#39;xxx&#39;&#39;&#39;</code>都会产生一个 str ；在它们任何一个前面添加一个 b 或 B ，则会创建一个 bytes ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = <span class="string">b&#x27;spam&#x27;</span></span><br><span class="line">S = <span class="string">&#x27;eggs&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(B), <span class="built_in">type</span>(S))</span><br></pre></td></tr></table></figure>
<p>bytes 对象实际上是一个<strong>短整数序列</strong>，但它尽可能地将自己打印为字符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(B[<span class="number">0</span>], B[<span class="number">1</span>:], <span class="built_in">list</span>(B))</span><br></pre></td></tr></table></figure>
<p>bytes 对象也是<strong>不可修改</strong>的。</p>
<p><strong>2、Unicode 字面量，它们被当作普通的 str 字符串（为了兼容2.X而存在）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">U = <span class="string">u&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(U))</span><br><span class="line"><span class="built_in">print</span>(U)</span><br></pre></td></tr></table></figure>
<p><strong>3、字符串类型转换</strong><br>① <code>str.encode()</code> 和 <code>bytes(S, encoding)</code> 把字符串转换为其原始字节形式；<br>② <code>bytes.decode()</code> 和 <code>str(B, encoding)</code> 把原始字节转换为其字符串形式。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;eggs&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.encode())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(S, encoding=<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">B = <span class="string">b&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(B.decode())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(B, encoding=<span class="string">&#x27;ascii&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>encode 和 decode 方法根据使用者的平台使用默认编码名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.platform)</span><br><span class="line"><span class="built_in">print</span>(sys.getdefaultencoding())</span><br></pre></td></tr></table></figure>
<p>str 可以省略编码名称参数，但是不带编码名称的 str 会直接返回 bytes 对象的打印字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(B))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(B)))</span><br></pre></td></tr></table></figure>
<h3 id="三、Coding-Unicode-Strings"><a href="#三、Coding-Unicode-Strings" class="headerlink" title="三、Coding Unicode Strings"></a>三、Coding Unicode Strings</h3><p><strong>1、Python的字符串字面量支持 “\xNN” 十六进制字节值转义以及 “\uNNNN” 和 “\UNNNNNNNN” Unicode 转义</strong><br>在 Unicode 转义中，第一种形式用4位十六进制数编码2字节字符码点，第二种形式用8位十六进制数编码4字节码点。</p>
<p><strong>2、编写 ASCII 文本</strong><br>ASCII 文本是一个简单的 Unicode 类型，作为字节值序列存储：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;X&#x27;</span>))</span><br><span class="line">S = <span class="string">&#x27;XYZ&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;ascii&#x27;</span>)) <span class="comment"># Values 0..127 in 1 byte (7 bits) each</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;latin-1&#x27;</span>)) <span class="comment"># Values 0..255 in 1 byte (8 bits) each</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># Values 0..127 in 1 byte, 128..2047 in 2, others 3 or 4</span></span><br></pre></td></tr></table></figure>
<p><strong>3、编写非 ASCII 文本</strong><br>①在 str 里，通过十六进制转义或者 Unicode 转义( escapes )；<br>②在 byte 中，通过十六进制转义。</p>
<p>十六进制转义 x 要求2个16进制数位，而 Unicode 转义的 u 和 U 分别为4个和8个十六进制数位，例如：十六进制值 0xCD 和 0xE8 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">0xc4</span>), <span class="built_in">chr</span>(<span class="number">0xe8</span>))</span><br><span class="line">S = <span class="string">&#x27;\xc4\xe8&#x27;</span> <span class="comment"># Single 8-bit value hex escapes: two digits，16^2即2^8，即8位</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line">S = <span class="string">&#x27;\u00c4\u00e8&#x27;</span> <span class="comment"># 16-bit Unicode escapes: four digits each，16^4即2^16，即16位</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line">S = <span class="string">&#x27;\U000000c4\U000000e8&#x27;</span> <span class="comment"># 32-bit Unicode escapes: eight digits each，16^8即2^32，即32位</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure>
<p><strong>4、编码和解码非 ASCII 文本</strong><br>①编码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;\u00c4\u00e8&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;latin-1&#x27;</span>)) <span class="comment"># 1 byte per character when encoded</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 2 bytes per character when encoded</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(S.encode(<span class="string">&#x27;latin-1&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(S.encode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<p>②解码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = <span class="string">b&#x27;\xc4\xe8&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(B)) <span class="comment"># 2 raw bytes, two encoded characters</span></span><br><span class="line"><span class="built_in">print</span>(B.decode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br><span class="line"></span><br><span class="line">B = <span class="string">b&#x27;\xc3\x84\xc3\xa8&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(B))</span><br><span class="line"><span class="built_in">print</span>(B.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><strong>5、混用非 ASCII 字符和 ASCII 字符</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;A\u00c4B\U000000e8C&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(S.encode(<span class="string">&#x27;latin-1&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(S.encode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<p>对于 UTF-16 和 UTF-32 ，使用每字符2字节和4字节方案，并有着相同大小的编码头：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf-16&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf-32&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><strong>6、byte 字节串的转义</strong><br>Python 允许特殊字符以十六进制和 Unicode 转义的方式编码到 str 字符串中，但只能以十六进制转义的方式编码到 bytes 字符串中。</p>
<p>在 bytes 中，Unicode 转义序列会被当作字符处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = <span class="string">b&#x27;A\xC4B\xE8C&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line">B = <span class="string">b&#x27;A\u00C4B\U000000E8C&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(B)</span><br></pre></td></tr></table></figure>
<p>字节串的字面量要求字符是 ASCII 字符， str 字符串允许字面量包含任何字符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;AÄBèC&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line">B = <span class="string">b&#x27;AÄBèC&#x27;</span> <span class="comment"># 会出错：SyntaxError: bytes can only contain ASCII literal characters</span></span><br><span class="line">B = <span class="string">b&#x27;A\xC4B\xE8C&#x27;</span> <span class="comment"># Chars must be ASCII, or escapes</span></span><br><span class="line"><span class="built_in">print</span>(B.decode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="四、Using-bytes-Objects"><a href="#四、Using-bytes-Objects" class="headerlink" title="四、Using bytes Objects"></a>四、Using bytes Objects</h3><p><strong>1、<code>Bytes</code> 对象是一个小整数序列，每个整数在0到255之间，显示时打印为 ASCII 字符</strong><br>它支持序列操作以及 str 对象上可用的大多数方法，但不支持格式化方法或 % 格式化表达式。与 str 一样，是不可改变对象。</p>
<p><strong>2、方法调用</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="string">&#x27;abc&#x27;</span>)) - <span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="string">b&#x27;abc&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="string">b&#x27;abc&#x27;</span>)) - <span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="string">&#x27;abc&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<p>bytes 的方法需要 bytes 类型的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = <span class="string">b&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(B.find(<span class="string">b&#x27;pa&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(B.replace(<span class="string">b&#x27;pa&#x27;</span>, <span class="string">b&#x27;XY&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(B.split(<span class="string">b&#x27;pa&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><strong>3、序列运算</strong><br>bytes 是一个8位的序列，对其索引会返回表示其二进制值的整数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = <span class="string">b&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">0</span>], B[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(B[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(B))</span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">1</span>:], B[:-<span class="number">1</span>], <span class="built_in">len</span>(B), B + <span class="string">b&#x27;lmn&#x27;</span>, B * <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p><strong>4、创建 bytes 对象的其他方式</strong><br>bytes 构造函数，可以传递 str 和编码名称参数，也可以传递一系列整数的可迭代对象作为参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = <span class="built_in">bytes</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line">B = <span class="built_in">bytes</span>([<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>])</span><br><span class="line"><span class="built_in">print</span>(B)</span><br></pre></td></tr></table></figure>
<h3 id="五、Using-bytearray-Objects"><a href="#五、Using-bytearray-Objects" class="headerlink" title="五、Using bytearray Objects"></a>五、Using bytearray Objects</h3><p><strong>1、<code>bytearray</code> ，是范围0到255之间的整数的一个可变序列，是 bytes 的可变的变体</strong><br>它支持和 bytes 相同的字符串方法和序列操作，并且支持和列表同样多的可变的原位置修改操作。</p>
<p><strong>2、bytearray 内置函数来创建 bytearray 对象</strong><br>需要传入编码名称和 str 字符串，或者直接传入字节串 bytes ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">C = <span class="built_in">bytearray</span>(S, <span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"></span><br><span class="line">B = <span class="string">b&#x27;spam&#x27;</span></span><br><span class="line">C = <span class="built_in">bytearray</span>(B)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br></pre></td></tr></table></figure>
<p>bytearry 对象也是小整数序列，像列表一样可以修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(C))</span><br><span class="line"><span class="built_in">print</span>(C[<span class="number">0</span>])</span><br><span class="line">C[<span class="number">0</span>] = <span class="built_in">ord</span>(<span class="string">&#x27;x&#x27;</span>) <span class="comment"># 索引复制要提供一个整数</span></span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line">C[<span class="number">1</span>] = <span class="string">b&#x27;Y&#x27;</span>[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(C)</span><br></pre></td></tr></table></figure>
<p>可以用列表的方法来原处修改 bytearray ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C.append(<span class="built_in">ord</span>(<span class="string">&#x27;L&#x27;</span>)) <span class="comment"># 接受的也是数字</span></span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line">C.extend(<span class="string">b&#x27;MNO&#x27;</span>) <span class="comment"># extend接受可迭代对象</span></span><br><span class="line"><span class="built_in">print</span>(C)</span><br></pre></td></tr></table></figure>
<p>序列操作和字符串方法也在 bytearray 上有效：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(C + <span class="string">b&#x27;!#&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(C))</span><br><span class="line">C.replace(<span class="string">b&#x27;xY&#x27;</span>, <span class="string">b&#x27;sp&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"><span class="built_in">print</span>(C * <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h3 id="六、Using-Text-and-Binary-Files"><a href="#六、Using-Text-and-Binary-Files" class="headerlink" title="六、Using Text and Binary Files"></a>六、Using Text and Binary Files</h3><p><strong>1、文本模式意味着 str 对象，而二进制模式意味着 bytes 对象</strong><br>①<strong>文本模式文件 Text-mode files</strong> 根据 Unicode 编码来解释文件内容，要么是平台的默认编码名，要么是传递进的编码名；<br>②<strong>二进制模式文件 Binary-mode files</strong> 返回原始的文件内容，作为表示字节值的一个整数序列。  </p>
<p>open 内置函数的第二个参数决定了要处理文本文件还是二进制文件，比如 rb 就是读取二进制文件，默认模式是 rt ，等同于 r ；文本文件返回一个 str 供读取，需要 str 来写入；二进制文件返回 bytes 供读取，需要一个 bytes 或 bytearray 供写入。</p>
<p><strong>2、文本文件基础</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">size = file.write(<span class="string">&#x27;abc\n&#x27;</span>)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>)</span><br><span class="line">text = file.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure>
<p><strong>3、文本和二进制模式</strong><br>写入时提供 str ，并根据 open 的模式，读取是获得 str 或 bytes ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;w&#x27;</span>).write(<span class="string">&#x27;abc\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p>文本模式在输出时把 \n 转换为 \r\n ，在输入时把 \r\n 转换回 \n ，但二进制模式不会这么做。  </p>
<p>使用二进制文件，运行类似代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(<span class="string">b&#x27;abc\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p>二进制模式在输出中，\n 没有扩展为 \r\n 。</p>
<p>\x00 是二进制0字节并且不是一个可打印的字符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(<span class="string">b&#x27;a\x00c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p>二进制模式文件用 bytes 对象返回其内容，但接受一个 bytes 或 bytearray 对象写入；<br>大多数 python API 接受 bytes 的同时也会接受 bytearray ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BA = <span class="built_in">bytearray</span>(<span class="string">b&#x27;\x01\x02\x03&#x27;</span>)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(BA)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p>以文本模式读取默认字符集以外的二进制数据会出现 UnicodeDecodeError 。</p>
<p>因为文本模式的输入文件必须能够依据 Unicode 编码来解码内容，所以没有办法在文本模式下读取真正的二进制内容（区分 Unicode 码点和字节值）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(<span class="string">b&#x27;\xFF\xFE\xFD&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p>所以最好文本文件以文本模式读取，二进制文件以二进制模式读取。</p>
<h3 id="七、Using-Unicode-Files"><a href="#七、Using-Unicode-Files" class="headerlink" title="七、Using Unicode Files"></a>七、Using Unicode Files</h3><p><strong>1、open 内置函数接受一个编码名称，可以自动解码和编码</strong></p>
<p><strong>2、读写 Unicode 文件</strong><br>把字符串以特定编码写入一个文本文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;A\xc4B\xe8C&#x27;</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;latindata&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;latin-1&#x27;</span>).write(S)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;utf8data&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).write(S)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;latindata&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;utf8data&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p>以特定编码读取文本文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;latindata&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;latin-1&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;utf8data&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p>手动解码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="built_in">open</span>(<span class="string">&#x27;latindata&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(X.decode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br><span class="line">X = <span class="built_in">open</span>(<span class="string">&#x27;utf8data&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(X.decode())</span><br></pre></td></tr></table></figure>
<p><strong>3、处理 BOM</strong><br>一些编码方式在文件开始处存储了一个特殊的<strong>字节顺序标记（BOM，byte order marker）</strong>序列，来指定数据的大小尾方式 endianness (which end of a string of bits is most significant to its value)，或者声明编码类型。</p>
<p>如果编码名暗示了 BOM ，python 在输入时会忽略该标记，在输出时写入该标记；例如，在 UTF-16 和 UTF-32 中，BOM 指定大尾或小尾格式；一个 UTF-8 文本可能也会包含一个 BOM ，通常只是申明 UTF-8 格式：<br>①在 UTF-16 中，总是对 utf-16 进行 BOM 处理，而更为特定的编码名称 “utf-16-le” 标示小尾格式；<br>②在 UTF-8 中，更为特定的编程名称 “utf-8-sig” 迫使 python 在输入和输出时分别跳过和写入 BOM ，但是常用的 “utf-8” 不会这样做。</p>
<p>小尾 Little Endian 方式：低位字节放在内存的低地址处，高位字节放在高地址处；<br>大尾 Big Endian 方式：低位字节放在内存的高地址处，高位字节放在低地址处。</p>
<p><strong>4、记事本 BOM 示例</strong><br>如果 spam.txt 保存为 UTF-8 模式（默认模式）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getdefaultencoding())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p>如果 spam.txt 保存为 UTF-8 BOM 模式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p>如果 spam.txt 保存为 UTF-16 BE（大尾）模式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-16&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-16-be&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p><strong>5、用 Python 代码让 UTF-8 带有 BOM（使用 utf-8-sig ）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).write(<span class="string">&#x27;spam\nSPAM\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>).write(<span class="string">&#x27;spam\nSPAM\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).read()) <span class="comment"># Keeps BOM</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>).read()) <span class="comment"># Skips BOM</span></span><br></pre></td></tr></table></figure>
<p>对于 UTF-16 ，BOM 被自动处理：在输出时，数据以平台本地的大小尾方式书写，并且 BOM 总是存在；</p>
<p>在输入时，数据根据 BOM 解码，并且总是去掉 BOM ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.byteorder) <span class="comment"># 显示little</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-16&#x27;</span>).write(<span class="string">&#x27;spam\nSPAM\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-16&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p>UTF-16 编码名称可以指定不同的大小尾：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-16-be&#x27;</span>).write(<span class="string">&#x27;\ufeffspam\nSPAM\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-16&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-16-be&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<h3 id="八、Other-String-Tool"><a href="#八、Other-String-Tool" class="headerlink" title="八、Other String Tool"></a>八、Other String Tool</h3><p>本节内容较为简单，需额外查阅其他资料。</p>
<p><strong>1、re 模式匹配模块 re Pattern-Matching Module（正则表达式）</strong><br>这里介绍得太简单了，详见菜鸟教程。</p>
<p>re 模块使 Python 语言拥有全部的正则表达式功能，可用于 str 、 bytes 和 bytearray ；<code>re.match</code>函数；在模式字符串中，(.*)表示任意除换行符（\n、\r）之外字符，(.)重复0或多次(*)，并作为匹配的子字符串单独保存；groups() 方法返回一个包含所有小组字符串的元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">S = <span class="string">&#x27;Bugger all down here on earth!&#x27;</span></span><br><span class="line">B = <span class="string">b&#x27;Bugger all down here on earth!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(re.<span class="keyword">match</span>(<span class="string">&#x27;(.*) down (.*) on (.*)&#x27;</span>, S).groups())</span><br><span class="line"><span class="built_in">print</span>(re.<span class="keyword">match</span>(<span class="string">b&#x27;(.*) down (.*) on (.*)&#x27;</span>, B).groups())</span><br></pre></td></tr></table></figure>
<p><strong>2、struct 二进制数据模块</strong><br>struct 模块用来从字符串中创建和提取打包的二进制数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">B = struct.pack(<span class="string">&#x27;&gt;i4sh&#x27;</span>, <span class="number">7</span>, <span class="string">b&#x27;spam&#x27;</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line">vals = struct.unpack(<span class="string">&#x27;&gt;i4sh&#x27;</span>, B)</span><br></pre></td></tr></table></figure>
<p>也可以创建和读取二进制文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F = <span class="built_in">open</span>(<span class="string">&#x27;data.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">data = struct.pack(<span class="string">&#x27;&gt;i4sh&#x27;</span>, <span class="number">7</span>, <span class="string">b&#x27;spam&#x27;</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">F.write(data)</span><br><span class="line">F.close()</span><br><span class="line"></span><br><span class="line">F = <span class="built_in">open</span>(<span class="string">&#x27;data.bin&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">data = F.read()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">values = struct.unpack(<span class="string">&#x27;&gt;i4sh&#x27;</span>, data)</span><br><span class="line"><span class="built_in">print</span>(values)</span><br></pre></td></tr></table></figure>
<p><strong>3、pickle 对象序列化模块</strong><br>pickle 总是创建一个 bytes 对象（不管传入的协议），使用该模块的 dumps 调用来返回对象的pickle 字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="built_in">print</span>(pickle.dumps([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment"># default protocol=3=binary</span></span><br><span class="line"><span class="built_in">print</span>(pickle.dumps([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], protocol=<span class="number">0</span>)) <span class="comment"># ASCII protocol 0</span></span><br></pre></td></tr></table></figure>
<p>存储 pickle 化对象的文件必须总是以二进制模式打开：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.dump([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(pickle.load(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br></pre></td></tr></table></figure>
<p><strong>4、XML 解析工具 Parsing Tools</strong><br>XML 是一种基于标签的语言，用于定义结构化信息，通常用来定义通过Web传输的文档和数据；Python 自身附带一个完整的 XML 解析工具包，支持 SAX 和 DOM 解析模式。</p>
<p>不抄写，学了 XML 后可以再来了解。</p>
<h2 id="Chapter-38-Managed-Attributes"><a href="#Chapter-38-Managed-Attributes" class="headerlink" title="Chapter 38 Managed Attributes"></a>Chapter 38 Managed Attributes</h2><h3 id="一、Why-Manage-Attributes"><a href="#一、Why-Manage-Attributes" class="headerlink" title="一、Why Manage Attributes"></a>一、Why Manage Attributes</h3><p><strong>1、为什么使用被管理的属性</strong><br>对工具构建者来说，被管理属性的访问是灵活的 API 的一个重要部分；</p>
<p>在整个程序对使用了某名称的所有地方都进行修改，不是个小任务，可以选择编写方法来管理对属性值的访问。</p>
<p><strong>2、属性访问器 attribute accessor</strong><br>四种访问器技术：<br>① <code>__getattr__</code> 和 <code>__setattr__</code> 方法，用于把未定义的属性获取和所有属性赋值路由到通用的处理方法；<br>② <code>__getattribute__</code> 方法，用于把所有属性获取都路由到一个泛化的处理方法；<br>③ <code>property</code> 内置函数，用于把特定属性访问路由到 <code>get</code> 和 <code>set</code> 函数；<br>④描述符协议，用于把特定属性访问路由到具有任意访问和修改处理方法的类的实例，是 <code>property</code> 和 <code>slot</code> 工具的基础。  </p>
<p>这4中属性拦截技术都用于把任意属性路由到被包装对象的、基于委托的代理类。</p>
<h3 id="二、Properties"><a href="#二、Properties" class="headerlink" title="二、Properties"></a>二、Properties</h3><p><strong>property</strong> 协议允许我们把一个特定属性的获取、设置和修改操作指向我们所提供的函数或方法，使得我们能够插入在属性访问时自动运行的代码，或是拦截属性的删除；</p>
<p>property 内置函数可以创建 property 并将其赋值给类属性，跟方法函数一样；同时也是可以被子类和实例继承的属性；<br>property 的访问拦截函数带有 self 实例参数，可以在主体实例上访问状态信息和类属性；<br>一个 property 管理一个单一的、特定的属性；<br>property 就是描述符 descriptors 的一种受限制的形式。</p>
<p><strong>1、基础知识</strong><br>将 property 赋值给类属性：<code>attribute = property(fget, fset, fdel, doc)</code>  </p>
<p>参数都不是必需的：<br>① <code>fget</code> 传入函数（或类方法）用于拦截属性访问；<br>② <code>fset</code>（或类方法）传入函数用于属性赋值；<br>③ <code>fdel</code>（或类方法）传入函数用于属性删除；<br>④ <code>fget</code> 函数返回被计算好的属性值，<code>fset</code> 和 <code>fdel</code> 返回 None ；<br>⑤ <code>doc</code> 参数接受该属性的一个文档字符串。</p>
<p>property 函数返回一个 property 对象，将其赋予要被管理的类属性名称，它又被类的所有实例继承。</p>
<p><strong>2、第一个示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self._name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;fetch...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setName</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;change...&#x27;</span>)</span><br><span class="line">        self._name = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;remove...&#x27;</span>)</span><br><span class="line">        <span class="keyword">del</span> self._name</span><br><span class="line">    name = <span class="built_in">property</span>(getName, setName, delName, <span class="string">&quot;name property docs&quot;</span>)</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name) <span class="comment"># 属性访问Runs getName</span></span><br><span class="line">bob.name = <span class="string">&#x27;Robert Smith&#x27;</span> <span class="comment"># 属性赋值Runs setName，打印出change...</span></span><br><span class="line"><span class="built_in">print</span>(bob.name) <span class="comment"># 属性访问Runs getName</span></span><br><span class="line"><span class="keyword">del</span> bob.name <span class="comment"># 属性删除Runs delName</span></span><br><span class="line"></span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sue.name)</span><br><span class="line"><span class="built_in">print</span>(Person.name.__doc__)</span><br></pre></td></tr></table></figure>
<p><strong>3、动态地计算属性的值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PropSquare</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start</span>):</span><br><span class="line">        self.value = start</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getX</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setX</span>(<span class="params">self, value</span>): </span><br><span class="line">        self.value = value</span><br><span class="line">    X = <span class="built_in">property</span>(getX, setX)</span><br><span class="line"></span><br><span class="line">P = PropSquare(<span class="number">3</span>)</span><br><span class="line">Q = PropSquare(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(P.X)</span><br><span class="line">P.X = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(P.X)</span><br><span class="line"><span class="built_in">print</span>(Q.X)</span><br></pre></td></tr></table></figure>
<p><strong>4、使用装饰器编写 property</strong><br>property 对象也有 getter 、 setter 和 deleter 方法，这些方法赋值了相应的 property 访问器方法，并且返回了 property 自身的副本。</p>
<p>可以通过装饰器来指定这些组件，getter 组件由创建 property 自身的行为来自动填充：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self._name = name</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property </span><span class="comment"># name = property(name)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;name property docs&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;fetch...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter </span><span class="comment"># name = name.setter(name)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;change...&#x27;</span>)</span><br><span class="line">        self._name = value</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @name.deleter </span><span class="comment"># name = name.deleter(name)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;remove...&#x27;</span>)</span><br><span class="line">        <span class="keyword">del</span> self._name</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line">bob.name = <span class="string">&#x27;Robert Smith&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line"><span class="keyword">del</span> bob.name</span><br></pre></td></tr></table></figure>
<h3 id="三、Descriptors"><a href="#三、Descriptors" class="headerlink" title="三、Descriptors"></a>三、Descriptors</h3><p><strong>描述符</strong>协议允许把一个特定的属性的获取、设置和删除操作指向一个单独类对象的方法； property 是描述符的一种。</p>
<p>描述符编写成独立的类，它们就像方法函数一样赋值给类属性，会被子类和实例继承；通过为描述符自身提供一个 self ，或通过让客户类实例的属性引用描述符对象。因此它们可以保留和使用自身的状态信息，以及主体实例的状态信息。</p>
<p>描述符也管理一个单一的、指定的属性。</p>
<p><strong>1、基础知识</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Descriptor</span>:</span><br><span class="line">    <span class="string">&quot;docstring goes here&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self, instance</span>): ...</span><br></pre></td></tr></table></figure>
<p>所有带有这些方法（ <code>__get__</code> 、 <code>__set__</code> 和 <code>__delete__</code> ）的类都可以看作描述符。</p>
<p>与 property 不同，省略了 <code>__set__</code> 意味着允许被管理的属性通过赋值重新定义，这样就会隐藏描述符；要使一个属性是只读的，必须定义 <code>__set__</code> 来捕获赋值并引发一个异常；带有 <code>__set__</code> 的描述符被称为数据描述符 data descriptor ，相比于其他正常继承规则而定位的属性拥有优先权。</p>
<p>区分描述符的 <code>__delete__</code> 方法和常见的 <code>__del__</code> 方法，前者会在试图删除被管理属性的名称时被调用；而后者是通用的实例析构函数方法，会在任何类的实例将要进行垃圾回收时被调用。</p>
<p><strong>2、描述符方法参数</strong><br><code>__get__</code> 访问方法额外接受一个 owner 参数，指定了描述符实例所依附的类；instance 参数要么是被访问属性的实例，要么当访问的属性是类属性的时候是 None 。</p>
<p>属性获取自动传递到 <code>__get__</code> 方法中的参数，<code>X.attr -&gt; Descriptor.__get__(Subject.attr, X, Subject)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Descriptor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(self, instance, owner, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>:</span><br><span class="line">    attr = Descriptor()</span><br><span class="line"></span><br><span class="line">X = Subject()</span><br><span class="line">X.attr</span><br><span class="line">Subject.attr</span><br></pre></td></tr></table></figure>
<p><strong>3、只读描述符 Read-only descriptors</strong><br>在描述符类中捕获赋值操作并引发一个异常来阻止属性赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">*args</span>): <span class="built_in">print</span>(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">*args</span>): <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;cannot set&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    a = D()</span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line">X.a</span><br><span class="line">X.a = <span class="number">99</span> <span class="comment"># 会出错：AttributeError: cannot set</span></span><br></pre></td></tr></table></figure>
<p><strong>4、第一个示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span>:</span><br><span class="line">    <span class="string">&quot;name descriptor docs&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;fetch...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> instance._name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;change...&#x27;</span>)</span><br><span class="line">        instance._name = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self, instance</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;remove...&#x27;</span>)</span><br><span class="line">        <span class="keyword">del</span> instance._name</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self._name = name</span><br><span class="line">    name = Name()</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name) <span class="comment"># Runs Name.__get__</span></span><br><span class="line">bob.name = <span class="string">&#x27;Robert Smith&#x27;</span> <span class="comment"># Runs Name.__set__</span></span><br><span class="line"><span class="built_in">print</span>(bob.name) <span class="comment"># Runs Name.__get__</span></span><br><span class="line"><span class="keyword">del</span> bob.name <span class="comment"># Runs Name.__delete__</span></span><br><span class="line"></span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sue.name)</span><br><span class="line"><span class="built_in">print</span>(Name.__doc__)</span><br></pre></td></tr></table></figure>
<p>描述符的 <code>__get__</code>方法里，self 是 Name 类实例，instance 是 Person 类实例，owner 是 Person 类。描述符类实例是一个类的属性，因此被客户类和所有实例和子类继承。</p>
<p><strong>5、动态地计算属性的值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DescSquare</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start</span>):</span><br><span class="line">        self.value = start</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client1</span>:</span><br><span class="line">    X = DescSquare(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client2</span>:</span><br><span class="line">    X = DescSquare(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">c1 = Client1()</span><br><span class="line">c2 = Client2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c1.X)</span><br><span class="line">c1.X = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(c1.X)</span><br><span class="line"><span class="built_in">print</span>(c2.X)</span><br></pre></td></tr></table></figure>
<p><strong>6、在描述符中使用状态信息</strong><br>在上面2个描述符的例子中，第一个例子（ name 属性）使用了存储在客户实例中的数据，第二个例子（属性平方）使用了附加到描述符对象本身的数据；</p>
<p>描述符可以使用实例状态和描述符状态，或者二者的任意组合：<br>①描述符状态用于管理描述符内部使用的数据，或是横跨所有实例的数据；<br>②实例状态记录了和客户类相关、或是被客户类创建的信息。  </p>
<p>描述符状态基于描述符的数据，实例状态基于客户类实例的数据。</p>
<p>下面的描述符把信息附加到了它自己的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DescState</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;DescState get&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.value * <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;DescState set&#x27;</span>)</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalcAttrs</span>:</span><br><span class="line">    X = DescState(<span class="number">2</span>)</span><br><span class="line">    Y = <span class="number">3</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.Z = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">obj = CalcAttrs()</span><br><span class="line"><span class="built_in">print</span>(obj.X, obj.Y, obj.Z)</span><br><span class="line">obj.X = <span class="number">5</span></span><br><span class="line">CalcAttrs.Y = <span class="number">6</span></span><br><span class="line">obj.Z = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(obj.X, obj.Y, obj.Z)</span><br><span class="line"></span><br><span class="line">obj2 = CalcAttrs()</span><br><span class="line"><span class="built_in">print</span>(obj2.X, obj2.Y, obj2.Z)</span><br></pre></td></tr></table></figure>
<p>这段代码的内部 value 信息仅存在于描述符之中；这里只管理了描述符的属性，即对 X 的获取和设置访问被拦截，对 Y 和 Z 的访问没被拦截。</p>
<p>对描述符存储或使用附加到客户类实例中的一个属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InstState</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;InstState get&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> instance._X * <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;InstState set&#x27;</span>)</span><br><span class="line">        instance._X = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalcAttrs</span>:</span><br><span class="line">    X = InstState()</span><br><span class="line">    Y = <span class="number">3</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._X = <span class="number">2</span></span><br><span class="line">        self.Z = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">obj = CalcAttrs()</span><br><span class="line"><span class="built_in">print</span>(obj.X, obj.Y, obj.Z)</span><br><span class="line">obj.X = <span class="number">5</span></span><br><span class="line">CalcAttrs.Y = <span class="number">6</span></span><br><span class="line">obj.Z = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(obj.X, obj.Y, obj.Z)</span><br><span class="line"></span><br><span class="line">obj2 = CalcAttrs()</span><br><span class="line"><span class="built_in">print</span>(obj2.X, obj2.Y, obj2.Z)</span><br></pre></td></tr></table></figure>
<p>可以同时使用这2种状态信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DescBoth</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s, %s&#x27;</span> % (self.data, instance.data)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        instance.data = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">    managed = DescBoth(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"></span><br><span class="line">I = Client(<span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(I.managed)</span><br><span class="line">I.managed = <span class="string">&#x27;SPAM&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(I.managed)</span><br><span class="line"><span class="built_in">print</span>(I.data)</span><br></pre></td></tr></table></figure>
<h3 id="四、-getattr-and-getattribute"><a href="#四、-getattr-and-getattribute" class="headerlink" title="四、__getattr__ and __getattribute__"></a>四、__getattr__ and __getattribute__</h3><p>① <code>__getattr__</code> 针对未定义的属性运行，只能为不存储在实例中或是不继承自它的类的属性运行；<br>② <code>__getattribute__</code> 针对所有的属性运行，要避免把属性访问传递给父类而导致递归循环。</p>
<p>这两个方法更加通用，更适合基于委托 delegation-based 的编码模式：用于实现包装器 wrapper （或代理 proxy ）来管理对一个内嵌对象的所有属性访问。</p>
<p>这两种方法拦截属性获取；<code>__setattr__</code> 方法捕获赋值对属性的更改；<code>__delattr__</code> 方法拦截属性删除。</p>
<p><strong>1、基础知识</strong><br>① <code>def __getattr__(self, name):</code> On undefined attribute fetch [obj.name]<br>② <code>def __getattribute__(self, name):</code> On all attribute fetch [obj.name]<br>③ <code>def __setattr__(self, name, value):</code> On all attribute assignment [obj.name=value]<br>④ <code>def __delattr__(self, name):</code> On all attribute deletion [del obj.name]<br>2个 get 方法返回属性的值，另外2个返回 None 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Catcher</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Get: %s&#x27;</span> % name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Set: %s %s&#x27;</span> % (name, value))</span><br><span class="line"></span><br><span class="line">X = Catcher()</span><br><span class="line">X.job</span><br><span class="line">X.pay</span><br><span class="line">X.pay = <span class="number">99</span></span><br></pre></td></tr></table></figure>
<p><strong>2、避免属性拦截方法的循环</strong><br>由于 <code>__getattribute__</code> 和 <code>__setattr__</code> 针对所有的属性运行，要避免自己调用自己而触发递归循环 recursive loop 。</p>
<p>①比如在 <code>__getattribute__</code> 方法内的属性获取，会再次触发 <code>__getaatribute__</code> ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, name</span>):</span><br><span class="line">    x = self.other</span><br></pre></td></tr></table></figure>
<p>当属性访问被编写在 <code>__getattribute__</code> 自身中，要避免循环，就需要另外把获取指向更高的父类，从而跳过这个层级的版本。因为object类总是新式类的父类，选择它比较好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, name</span>):</span><br><span class="line">    x = <span class="built_in">object</span>.__getattribute__(self, <span class="string">&#x27;other&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>②在 <code>__setattr__</code> 方法内赋值任何属性，都会再次触发 <code>__setattr__</code> ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">    self.other = value</span><br></pre></td></tr></table></figure>
<p>为解决这个问题，可以把属性赋值为实例的 <code>__dict__</code> 命名空间字典中的一个键赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">    self.__dict__[<span class="string">&#x27;other&#x27;</span>] = value</span><br></pre></td></tr></table></figure>
<p>也可以把自己属性赋值传递给一个更高的父类而避免循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">    <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;other&#x27;</span>, value)</span><br></pre></td></tr></table></figure>
<p><strong>3、第一个示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self._name = name <span class="comment"># Triggers __setattr__！！</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get: &#x27;</span> + attr)</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;name&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self._name</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(attr)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, attr, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;set: &#x27;</span> + attr)</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;name&#x27;</span>:</span><br><span class="line">            attr = <span class="string">&#x27;_name&#x27;</span></span><br><span class="line">        self.__dict__[attr] = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;del: &#x27;</span> + attr)</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;name&#x27;</span>:</span><br><span class="line">            attr = <span class="string">&#x27;_name&#x27;</span></span><br><span class="line">        <span class="keyword">del</span> self.__dict__[attr]</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name) <span class="comment"># Runs __getattr__</span></span><br><span class="line">bob.name = <span class="string">&#x27;Robert Smith&#x27;</span> <span class="comment"># Runs __setattr__</span></span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line"><span class="keyword">del</span> bob.name <span class="comment"># Runs __delattr__</span></span><br><span class="line"></span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sue.name)</span><br></pre></td></tr></table></figure>
<p><strong>4、使用 <code>__getattribute__</code></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, attr</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;get: &#x27;</span> + attr)</span><br><span class="line">    <span class="keyword">if</span> attr == <span class="string">&#x27;name&#x27;</span>:</span><br><span class="line">        attr = <span class="string">&#x27;_name&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self, attr)</span><br></pre></td></tr></table></figure>
<p>把 <code>__getattr__</code> 替换为这个，结果是类似的，但是在 <code>__setattr__</code> 的获取中会触发一次额外的 <code>__getattribute__</code> 调用。</p>
<p><strong>5、计算出的属性</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AttrSquare</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start</span>):</span><br><span class="line">        self.value = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.value ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(attr)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, attr, value</span>):</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">            attr = <span class="string">&#x27;value&#x27;</span></span><br><span class="line">        self.__dict__[attr] = value</span><br><span class="line">    </span><br><span class="line">A = AttrSquare(<span class="number">3</span>)</span><br><span class="line">B = AttrSquare(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.X)</span><br><span class="line">A.X = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(A.X)</span><br><span class="line"><span class="built_in">print</span>(B.X)</span><br></pre></td></tr></table></figure>
<p><strong>6、__getattr__和__getattribute__的区别</strong><br>attr1 是一个类属性，attr2 是一个实例属性，attr3 是一个在获取时被管理的属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GetAttr</span>:</span><br><span class="line">    attr1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.attr2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get: &#x27;</span> + attr)</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;attr3&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(attr)</span><br><span class="line"></span><br><span class="line">X = GetAttr()</span><br><span class="line"><span class="built_in">print</span>(X.attr1)</span><br><span class="line"><span class="built_in">print</span>(X.attr2)</span><br><span class="line"><span class="built_in">print</span>(X.attr3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetAttribute</span>:</span><br><span class="line">    attr1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.attr2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get: &#x27;</span> + attr)</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;attr3&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self, attr)</span><br><span class="line"></span><br><span class="line">X = GetAttribute()</span><br><span class="line"><span class="built_in">print</span>(X.attr1)</span><br><span class="line"><span class="built_in">print</span>(X.attr2)</span><br><span class="line"><span class="built_in">print</span>(X.attr3)</span><br></pre></td></tr></table></figure>
<p><code>__getattr__</code> 只拦截 attr3 的访问，因为 attr3 是未定义的。</p>
<h2 id="Chapter-39-Decorators"><a href="#Chapter-39-Decorators" class="headerlink" title="Chapter 39 Decorators"></a>Chapter 39 Decorators</h2><h3 id="一、The-Basics"><a href="#一、The-Basics" class="headerlink" title="一、The Basics"></a>一、The Basics</h3><p><strong>装饰 Decoration</strong> 是一种为函数和类指定管理或扩增代码的一种方式；即分为<strong>函数装饰器 Function decorators</strong>和<strong>类装饰器 Class decorators</strong> 。</p>
<p><strong>1、函数装饰器</strong></p>
<p>①用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">arg</span>):</span><br><span class="line">    ...</span><br><span class="line">F(<span class="number">99</span>)</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">arg</span>):</span><br><span class="line">    ...</span><br><span class="line">F = decorator(F)</span><br><span class="line">F(<span class="number">99</span>)</span><br></pre></td></tr></table></figure>
<p>②实现：<br>装饰器自身是一个返回可调用对象的可调用对象（函数和类的任何组合都可以使用）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">F</span>):</span><br><span class="line">    <span class="keyword">return</span> F</span><br></pre></td></tr></table></figure>
<p>可以用一个装饰器返回和最初函数不同的一个对象；</p>
<p>用类来实现类似的装饰器，可以重载调用操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">decorator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args</span>):</span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y</span>)</span><br></pre></td></tr></table></figure>
<p>③支持方法装饰：<br>对类的方法进行装饰，上面的方式就不行了，用嵌套函数会更好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">F</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y</span>):</span><br><span class="line">    ...</span><br><span class="line">func(<span class="number">6</span>, <span class="number">7</span>) <span class="comment"># calls wrapper(6, 7)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line"><span class="meta">    @decorator</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line">X.method(<span class="number">6</span>, <span class="number">7</span>) <span class="comment"># calls wrapper(X, 6, 7)</span></span><br></pre></td></tr></table></figure>
<p>这样子 wrapper 在其第一个参数里接收了 C 类的实例。</p>
<p><strong>2、类装饰器</strong><br>类装饰器是管理类的一种方法，或是使用额外逻辑来完成实例构造调用的一种方式：</p>
<p>①用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    ...</span><br><span class="line">x = C(<span class="number">99</span>)</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    ...</span><br><span class="line">C = decorator(C)</span><br><span class="line">x = C(<span class="number">99</span>)</span><br></pre></td></tr></table></figure>
<p>之后用类名调用创建一个实例时，最终会触发装饰器返回的可调用对象。</p>
<p>②实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">C</span>):</span><br><span class="line">    <span class="comment"># Save or use class C；Return a different callable: nested def, class with __call__, etc.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: ...</span><br></pre></td></tr></table></figure>
<p>这样一个类装饰器返回的可调用对象，通常创建并返回最初类的一个新实例，并以某种方式扩展以管理接口。</p>
<p>比如下面的装饰器插入一个对象来拦截类实例的未定义属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Wrapper</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args</span>):</span><br><span class="line">            self.wrapped = cls(*args) <span class="comment"># self.wrapped = C(6, 7)即一个实例</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, name)</span><br><span class="line">    <span class="keyword">return</span> Wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>): <span class="comment"># Run by Wrapper.__init__</span></span><br><span class="line">        self.attr = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"></span><br><span class="line">x = C(<span class="number">6</span>, <span class="number">7</span>) <span class="comment"># Really calls Wrapper(6, 7)</span></span><br><span class="line"><span class="built_in">print</span>(x.attr) <span class="comment"># Runs Wrapper.__getattr__, 返回了self.wrapped.attr，由于self.wrapped为C类的实例，所以prints &quot;spam&quot;</span></span><br></pre></td></tr></table></figure>
<p>类装饰器通常可以编写为一个创建并返回可调用对象的工厂函数，或是创建并返回类的工厂函数，使用 <code>__init__</code> 或 <code>__call__</code> 方法来拦截调用操作。</p>
<p>工厂函数通常在外层作用域引用中保持状态，而类在属性中保持状态。</p>
<p><strong>3、装饰器嵌套</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@A</span></span><br><span class="line"><span class="meta">@B</span></span><br><span class="line"><span class="meta">@C</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">...</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">...</span>):</span><br><span class="line">    ...</span><br><span class="line">f = A(B(C(f)))</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">d1</span>(<span class="params">F</span>): <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="string">&#x27;X&#x27;</span> + F()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">d2</span>(<span class="params">F</span>): <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="string">&#x27;Y&#x27;</span> + F()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">d3</span>(<span class="params">F</span>): <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="string">&#x27;Z&#x27;</span> + F()</span><br><span class="line"></span><br><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="meta">@d3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(): <span class="comment"># func = d1(d2(d3(func)))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func())</span><br></pre></td></tr></table></figure>
<p><strong>4、装饰器参数</strong><br>函数装饰器和类装饰器都能接受参数，这些参数传递给了返回装饰器的装饰器，而装饰器再返回可调用对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator(<span class="params">A, B</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">arg</span>):</span><br><span class="line">    ...</span><br><span class="line">F(<span class="number">99</span>)</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">arg</span>):</span><br><span class="line">    ...</span><br><span class="line">F = decorator(A, B)(F)</span><br><span class="line">F(<span class="number">99</span>)</span><br></pre></td></tr></table></figure>
<p>例子中的装饰器函数的例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">A, B</span>):</span><br><span class="line">    <span class="comment"># Save or use A, B</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">actualDecorator</span>(<span class="params">F</span>):</span><br><span class="line">        <span class="comment"># Save or use function F</span></span><br><span class="line">        <span class="comment"># Return a callable: nested def, class with __call__, etc.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">callable</span></span><br><span class="line">    <span class="keyword">return</span> actualDecorator</span><br></pre></td></tr></table></figure>
<h3 id="二、Coding-Function-Decorators"><a href="#二、Coding-Function-Decorators" class="headerlink" title="二、Coding Function Decorators"></a>二、Coding Function Decorators</h3><p>编写函数装饰器的示例：</p>
<p><strong>1、跟踪调用</strong><br>使用一个函数装饰器，统计被装饰函数的调用次数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.calls = <span class="number">0</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        self.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (self.calls, self.func.__name__))</span><br><span class="line">        self.func(*args)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer </span><span class="comment"># 在def末尾触发tracer的__init__，创建了实例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment"># 触发tracer的__call__</span></span><br><span class="line">spam(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(spam.calls)</span><br><span class="line"><span class="built_in">print</span>(spam)</span><br></pre></td></tr></table></figure>
<p><strong>2、装饰器状态保持方案</strong><br>实例属性、全局变量、非局部闭包变量和函数属性，都可以用于保持状态：</p>
<p>①类实例属性<br>上个例子的扩展版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>): </span><br><span class="line">        self.calls = <span class="number">0</span> <span class="comment"># 类实例属性保存状态</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        self.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (self.calls, self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eggs</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x ** y)</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">spam(a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">eggs(<span class="number">2</span>, <span class="number">16</span>)</span><br><span class="line">eggs(<span class="number">4</span>, y=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>②外层作用域和全局变量<br>闭包函数（带有外围def作用域引用和嵌套的def）可以实现同样的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">calls = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tracer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">global</span> calls</span><br><span class="line">        calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (calls, func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eggs</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x ** y)</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">spam(a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">eggs(<span class="number">2</span>, <span class="number">16</span>)</span><br><span class="line">eggs(<span class="number">4</span>, y=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>上面的方案因为计数器是全局变量，意味着被每个被包装函数所共享，对于任何函数调用，计数器都会累计，而不是各自独立计数。</p>
<p>③外层作用域和非局部变量<br>修改上面方案，改为外层作用域的非局部变量，允许拥有各自的状态：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tracer</span>(<span class="params">func</span>):</span><br><span class="line">    calls = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> calls</span><br><span class="line">        calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (calls, func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eggs</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x ** y)</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">spam(a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">eggs(<span class="number">2</span>, <span class="number">16</span>)</span><br><span class="line">eggs(<span class="number">4</span>, y=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>④函数属性<br>使用 <code>func.attr = value</code> 也可以实现于 nonlocal 版本一样的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tracer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        wrapper.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (wrapper.calls, func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    wrapper.calls = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eggs</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x ** y)</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">spam(a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">eggs(<span class="number">2</span>, <span class="number">16</span>)</span><br><span class="line">eggs(<span class="number">4</span>, y=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>⑤错误：对方法进行装饰<br>最上面跟踪调用的例子无法对类方法进行装饰，会发生错误；<br>根源在于 tracer 的 <code>__call__</code> 方法的 self 参数，是一个 tracer 的实例，而并未在参数列表传递被装饰的类的主体。<br>被装饰的主体类的实例没有包括在 *args 中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.calls = <span class="number">0</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        self.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (self.calls, self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, pay</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.pay = pay</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @tracer</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent</span>):</span><br><span class="line">        self.pay *= (<span class="number">1.0</span> + percent)</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>, <span class="number">50000</span>)</span><br><span class="line">bob.giveRaise(<span class="number">.25</span>) <span class="comment"># 会出错，因为tracer(giveRaise)(bob, .25)中的bob不会被*args接收</span></span><br></pre></td></tr></table></figure>
<p>⑥使用嵌套函数装饰方法<br>可以在简单函数和类级别的方法上都能工作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tracer</span>(<span class="params">func</span>):</span><br><span class="line">    calls = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onCall</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> calls</span><br><span class="line">        calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (calls, func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> onCall</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eggs</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> ** N</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">spam(a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(eggs(<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, pay</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.pay = pay</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @tracer</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent</span>): <span class="comment"># giveRaise = tracer(giveRaise)，调用时返回onCall(sue, .10)</span></span><br><span class="line">        self.pay *= (<span class="number">1.0</span> + percent)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @tracer</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name.split()[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;methods...&#x27;</span>)</span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>, <span class="number">50000</span>)</span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name, sue.name)</span><br><span class="line">sue.giveRaise(<span class="number">.10</span>) <span class="comment"># Runs onCall(sue, .10)，返回了giveRaise(sue, .10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(sue.pay))</span><br><span class="line"><span class="built_in">print</span>(bob.lastName(), sue.lastName())</span><br></pre></td></tr></table></figure>
<p>⑦使用描述符装饰方法<br>由于描述符的 <code>__get__</code> 方法在调用时接受描述符类实例和主体类实例，非常适合装饰类方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.calls = <span class="number">0</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        self.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (self.calls, self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> wrapper(self, instance)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wrapper</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, desc, subj</span>): <span class="comment"># save了主体类实例和装饰器（描述符）实例</span></span><br><span class="line">        self.desc = desc <span class="comment"># 装饰器（描述符）实例</span></span><br><span class="line">        self.subj = subj <span class="comment"># 主体实例</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> self.desc(self.subj, *args, **kwargs) <span class="comment"># Runs tracer.__call__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c) <span class="comment"># Uses __call__ only</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, pay</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.pay = pay</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @tracer</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent</span>):</span><br><span class="line">        self.pay *= (<span class="number">1.0</span> + percent)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @tracer</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name.split()[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">spam(a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;methods...&#x27;</span>)</span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>, <span class="number">50000</span>)</span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name, sue.name)</span><br><span class="line">sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(sue.pay))</span><br><span class="line"><span class="built_in">print</span>(bob.lastName(), sue.lastName())</span><br></pre></td></tr></table></figure>
<p>上面的理解：<br>①被装饰的函数（ spam ）只调用 tracer 类的 <code>__call__</code> ，而不会调用其 <code>__get__</code> ；<br>②被装饰的类方法（ giveRaise 、 lastName ）首先调用 tracer 类的 <code>__get__</code> 来解析方法名获取，返回 wrapper 实例调用，触发了 wrapper 对象的 <code>__call__</code> 方法，转而调用了 <code>tracer.__call__</code> ；<br>③比如 <code>sue.giveRaise(.10)</code> ，首先运行 <code>tracer.__get__</code> ，返回 <code>wrapper(tracer(giveRaise), sue)(sue, .10)</code> ，然后因为调用返回 <code>wrapper.__call__</code> ，即 <code>tracer(giveRaise)(sue, .10)</code> ，因为 sue 不会被 *args 接收，所以不会重复 sue ，见v、错误：对方法进行装饰。最后调用 <code>tracer.__call__</code> ，返回了 <code>giveRaise(sue, .10)</code> 。</p>
<p>下面的版本和上面的效果一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tracer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.calls = <span class="number">0</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        self.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (self.calls, self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">return</span> self(instance, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<h3 id="三、Coding-Function-Decorators-2"><a href="#三、Coding-Function-Decorators-2" class="headerlink" title="三、Coding Function Decorators 2"></a>三、Coding Function Decorators 2</h3><p><strong>1、函数装饰器的第二个例子：调用计时</strong><br>包括单次调用计时，也包括全部调用总时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">timer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.alltime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kargs</span>):</span><br><span class="line">        start = time.perf_counter()</span><br><span class="line">        result = self.func(*args, **kargs)</span><br><span class="line">        elapsed = time.perf_counter() - start</span><br><span class="line">        self.alltime += elapsed</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %.5f, %.5f&#x27;</span> % (self.func.__name__, elapsed, self.alltime))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listcomp</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">return</span> [x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mapcall</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>((<span class="keyword">lambda</span> x: x * <span class="number">2</span>), <span class="built_in">range</span>(N)))</span><br><span class="line"></span><br><span class="line">result = listcomp(<span class="number">5</span>)</span><br><span class="line">listcomp(<span class="number">50000</span>)</span><br><span class="line">listcomp(<span class="number">500000</span>)</span><br><span class="line">listcomp(<span class="number">1000000</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;allTime = %s&#x27;</span> % listcomp.alltime) <span class="comment"># listcomp是timer的实例</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">result = mapcall(<span class="number">5</span>)</span><br><span class="line">mapcall(<span class="number">50000</span>)</span><br><span class="line">mapcall(<span class="number">500000</span>)</span><br><span class="line">mapcall(<span class="number">1000000</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;allTime = %s&#x27;</span> % mapcall.alltime)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n**map/comp = %s&#x27;</span> % <span class="built_in">round</span>(mapcall.alltime / listcomp.alltime, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>实际上如果 map 没有将其包装在一个 list 调用中迫使结果生成， map 测试在 Python 中几乎不花时间，它返回一个可迭代对象而没有进行迭代。</p>
<p><strong>2、添加装饰器参数</strong><br>提供一个输出标签并且可以打开或关闭跟踪消息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">label=<span class="string">&#x27;&#x27;</span>, trace=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Timer</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">            self.func = func</span><br><span class="line">            self.alltime = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kargs</span>):</span><br><span class="line">            start = time.perf_counter()</span><br><span class="line">            result = self.func(*args, **kargs)</span><br><span class="line">            elapsed = time.perf_counter() - start</span><br><span class="line">            self.alltime += elapsed</span><br><span class="line">            <span class="keyword">if</span> trace:</span><br><span class="line">                <span class="built_in">format</span> = <span class="string">&#x27;%s %s: %.5f, %.5f&#x27;</span></span><br><span class="line">                values = (label, self.func.__name__, elapsed, self.alltime)</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">format</span> % values)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外层的 timer 函数，返回 Timer 类作为实际的装饰器。装饰时，它记住了被装饰的函数自身，还能访问位于外围函数作用域中的装饰器参数（ label 和 trace ）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params">label=<span class="string">&#x27;[CCC]==&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listcomp</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">return</span> [x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params">trace=<span class="literal">True</span>, label=<span class="string">&#x27;[MMM]==&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mapcall</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>((<span class="keyword">lambda</span> x: x * <span class="number">2</span>), <span class="built_in">range</span>(N)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> (listcomp, mapcall):</span><br><span class="line">    result = func(<span class="number">5</span>)</span><br><span class="line">    func(<span class="number">50000</span>)</span><br><span class="line">    func(<span class="number">500000</span>)</span><br><span class="line">    func(<span class="number">1000000</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;allTime = %s\n&#x27;</span> % func.alltime)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;**map/comp = %s&#x27;</span> % <span class="built_in">round</span>(mapcall.alltime / listcomp.alltime, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h3 id="四、Coding-Class-Decorators"><a href="#四、Coding-Class-Decorators" class="headerlink" title="四、Coding Class Decorators"></a>四、Coding Class Decorators</h3><p>类装饰器可以用于管理类自身，或者用来拦截实例创建调用以管理实例。</p>
<p><strong>1、单例类 Singleton Classes</strong><br>下面的代码实现了传统的单例编程模式 classic singleton coding pattern ，其中每个类最多只有一个实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">aClass</span>): <span class="comment"># 接受被包装类，并保留状态信息，返回onCall</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onCall</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> aClass <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[aClass] = aClass(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instances[aClass]</span><br><span class="line">    <span class="keyword">return</span> onCall</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>: <span class="comment"># Person = singleton(Person) = onCall，onCall再接受实例参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, hours, rate</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.hours = hours</span><br><span class="line">        self.rate = rate</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.hours * self.rate</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.attr = val</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">40</span>, <span class="number">10</span>) <span class="comment"># 即onCall(&#x27;Bob&#x27;, 40, 10)，并返回Person实例</span></span><br><span class="line"><span class="built_in">print</span>(bob.name, bob.pay())</span><br><span class="line"></span><br><span class="line">sue = Person(<span class="string">&#x27;Sue&#x27;</span>, <span class="number">50</span>, <span class="number">20</span>) <span class="comment"># 无法再创建新的实例，所以sue仍然是bob实例</span></span><br><span class="line"><span class="built_in">print</span>(sue.name, sue.pay())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(instances)</span><br><span class="line"></span><br><span class="line">X = Spam(val=<span class="number">42</span>)</span><br><span class="line">Y = Spam(<span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(X.attr, Y.attr)</span><br></pre></td></tr></table></figure>
<p><strong>2、编写替代方案</strong><br>①使用 nonlocal 语句改写上面例子，并实现了同样效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">aClass</span>):</span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onCall</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> instance</span><br><span class="line">        <span class="keyword">if</span> instance == <span class="literal">None</span>:</span><br><span class="line">            instance = aClass(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    <span class="keyword">return</span> onCall</span><br></pre></td></tr></table></figure>
<p>②使用函数属性，效果同上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">aClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onCall</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> onCall.instance == <span class="literal">None</span>:</span><br><span class="line">            onCall.instance = aClass(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> onCall.instance</span><br><span class="line">    onCall.instance = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> onCall</span><br></pre></td></tr></table></figure>
<p>③使用类，为每次装饰使用一个实例，效果同上，这个例子会在后面看到一个常见的装饰器类错误。这里只想要一个实例，实际不是这样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">singleton</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, aClass</span>):</span><br><span class="line">        self.aClass = aClass</span><br><span class="line">        self.instance = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> self.instance == <span class="literal">None</span>:</span><br><span class="line">            self.instance = self.aClass(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> self.instance</span><br></pre></td></tr></table></figure>
<p><strong>3、跟踪对象接口</strong><br>类装饰器的另一个常用场景是为每个生成的实例扩展接口；<br>类装饰器可以在实例上安装一个包装器 wrapper 和代理 proxy 逻辑层。</p>
<p>①非装饰器版的委托示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">object</span></span>):</span><br><span class="line">        self.wrapped = <span class="built_in">object</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attrname</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Trace:&#x27;</span>, attrname)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, attrname)</span><br><span class="line"></span><br><span class="line">x = Wrapper([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">x.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(x.wrapped)</span><br><span class="line"></span><br><span class="line">x = Wrapper(&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(x.keys()))</span><br></pre></td></tr></table></figure>
<p>②类装饰器版：<br>上面的类示例可以编写为一个类装饰器，能够触发被包装实例的创建；<br>通过拦截实例创建调用，下面的类装饰器允许跟踪整个对象接口（即跟踪对任何属性的访问）；<br>每个实例都会生成一个新的 Wrapper 实例，并拥有自己的访问计数器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Tracer</span>(<span class="params">aClass</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Wrapper</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kargs</span>):</span><br><span class="line">            self.fetches = <span class="number">0</span></span><br><span class="line">            self.wrapped = aClass(*args, **kargs)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attrname</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Trace: &#x27;</span> + attrname)</span><br><span class="line">            self.fetches += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, attrname)</span><br><span class="line">    <span class="keyword">return</span> Wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tracer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Spam!&#x27;</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tracer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, hours, rate</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.hours = hours</span><br><span class="line">        self.rate = rate</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.hours * self.rate</span><br><span class="line"></span><br><span class="line">food = Spam()</span><br><span class="line">food.display()</span><br><span class="line"><span class="built_in">print</span>([food.fetches])</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line"><span class="built_in">print</span>(bob.pay())</span><br><span class="line"></span><br><span class="line">sue = Person(<span class="string">&#x27;Sue&#x27;</span>, rate=<span class="number">100</span>, hours=<span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(sue.name)</span><br><span class="line"><span class="built_in">print</span>(sue.pay())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line"><span class="built_in">print</span>(bob.pay())</span><br><span class="line"><span class="built_in">print</span>([bob.fetches, sue.fetches])</span><br></pre></td></tr></table></figure>
<p><strong>4、类错误二：保持多个实例</strong><br>修改上面例子，使用装饰器类来装饰类，而不是装饰器函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, aClass</span>):</span><br><span class="line">        self.aClass = aClass</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        self.wrapped = self.aClass(*args)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attrname</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Trace: &#x27;</span> + attrname)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, attrname)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tracer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Spam!&#x27;</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">food = Spam() <span class="comment"># Triggers __init__</span></span><br><span class="line">food.display() <span class="comment"># Triggers __getattr__</span></span><br></pre></td></tr></table></figure>
<p>上面不能处理给定类的多个实例：每个实例构建调用都会触发 <code>__call__</code> ，会覆盖前面的实例，所以 Tracer 只能保存最后创建的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Tracer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line">Sue = Person(<span class="string">&#x27;Sue&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sue.name) <span class="comment"># sue overwrites bob</span></span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br></pre></td></tr></table></figure>
<h3 id="五、Managing-Functions-and-Classes-Directly"><a href="#五、Managing-Functions-and-Classes-Directly" class="headerlink" title="五、Managing Functions and Classes Directly"></a>五、Managing Functions and Classes Directly</h3><p><strong>1、 之前的示例，都设计来拦截函数和实例创建调用；下面的示例用于管理函数和类本身</strong><br>下面定义了一个装饰器，把函数或类对象添加到一个基于字典的注册表，并返回对象本身：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">registry = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">obj</span>):</span><br><span class="line">    registry[obj.__name__] = obj</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span>(x ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ham</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span>(x ** <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.data = x ** <span class="number">4</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Registry:&#x27;</span>) </span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> registry:</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, registry[name], <span class="built_in">type</span>(registry[name]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nManual calls:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(spam(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(ham(<span class="number">2</span>))</span><br><span class="line">X = Eggs(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nRegistry calls:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> registry:</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, registry[name](<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p><strong>2、函数装饰器也能用来处理函数属性，并且类装饰器可以动态地插入新的类属性或方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):</span><br><span class="line">    func.marked = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(spam.marked)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">annotate</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):</span><br><span class="line">        func.label = text</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="meta">@annotate(<span class="params"><span class="string">&#x27;spam data&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(spam(<span class="number">1</span>, <span class="number">2</span>), spam.label)</span><br></pre></td></tr></table></figure>
<h3 id="六、“Private”-and-“Public”-Attributes"><a href="#六、“Private”-and-“Public”-Attributes" class="headerlink" title="六、“Private” and “Public” Attributes"></a>六、“Private” and “Public” Attributes</h3><p><strong>1、实现私有属性</strong><br>下面的类装饰器实现一个用于类实例属性的 Private 声明；</p>
<p>不接受被装饰类的外部对属性的获取或修改访问，但仍允许类自身在自己的方法中自由地访问这些名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Privacy for attributes fetched from class instances.</span></span><br><span class="line"><span class="string">See self-test code at end of file for a usage example.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Decorator same as: Doubler = Private(&#x27;data&#x27;, &#x27;size&#x27;)(Doubler).</span></span><br><span class="line"><span class="string">Private returns onDecorator, onDecorator returns onInstance,</span></span><br><span class="line"><span class="string">and each onInstance instance embeds a Doubler instance.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">traceMe = <span class="literal">False</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">if</span> traceMe: <span class="built_in">print</span>(<span class="string">&#x27;[&#x27;</span> + <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, args)) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Private</span>(<span class="params">*privates</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onDecorator</span>(<span class="params">aClass</span>):</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">onInstance</span>:</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kargs</span>):</span><br><span class="line">                self.wrapped = aClass(*args, **kargs)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">                trace(<span class="string">&#x27;get:&#x27;</span>, attr)</span><br><span class="line">                <span class="keyword">if</span> attr <span class="keyword">in</span> privates:</span><br><span class="line">                    <span class="keyword">raise</span> TypeError(<span class="string">&#x27;private attribute fetch: &#x27;</span> + attr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, attr)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, attr, value</span>):</span><br><span class="line">                trace(<span class="string">&#x27;set:&#x27;</span>, attr, value)</span><br><span class="line">                <span class="keyword">if</span> attr == <span class="string">&#x27;wrapped&#x27;</span>:</span><br><span class="line">                    self.__dict__[attr] = value <span class="comment"># Avoid looping</span></span><br><span class="line">                <span class="keyword">elif</span> attr <span class="keyword">in</span> privates:</span><br><span class="line">                    <span class="keyword">raise</span> TypeError(<span class="string">&#x27;private attribute change: &#x27;</span> + attr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">setattr</span>(self.wrapped, attr, value)</span><br><span class="line">        <span class="keyword">return</span> onInstance</span><br><span class="line">    <span class="keyword">return</span> onDecorator</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    traceMe = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @Private(<span class="params"><span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;size&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Doubler</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, label, start</span>):</span><br><span class="line">            self.label = label</span><br><span class="line">            self.data = start</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.size()):</span><br><span class="line">                self.data[i] = self.data[i] * <span class="number">2</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s =&gt; %s&#x27;</span> % (self.label, self.data))</span><br><span class="line">    </span><br><span class="line">X = Doubler(<span class="string">&#x27;X is&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># self.wrapped = aClass(*args, **kargs)触发了__setattr__方法</span></span><br><span class="line">Y = Doubler(<span class="string">&#x27;Y is&#x27;</span>, [-<span class="number">10</span>, -<span class="number">20</span>, -<span class="number">30</span>]) <span class="comment"># 同上</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X.label)</span><br><span class="line">X.display(); X.double(); X.display()</span><br><span class="line"><span class="built_in">print</span>(Y.label)</span><br><span class="line">Y.display(); Y.double()</span><br><span class="line">Y.label = <span class="string">&#x27;Spam&#x27;</span></span><br><span class="line">Y.display()</span><br></pre></td></tr></table></figure>
<p>下面都会出现错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(X.size()) <span class="comment"># prints &quot;TypeError: private attribute fetch: size&quot;</span></span><br><span class="line"><span class="built_in">print</span>(X.data)</span><br><span class="line">X.data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">X.size = <span class="keyword">lambda</span> S: <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(Y.data)</span><br><span class="line"><span class="built_in">print</span>(Y.size())</span><br></pre></td></tr></table></figure>
<p>在上述代码，用到了三个层面的状态保存：<br>①传递给 Private 的参数在装饰发生前，作为一个外层作用域保持，供 onDecorator 和 onInstance 使用；<br>② onDecorator 的类参数在装饰时，作为一个外层作用域保持，供实例构建时使用；<br>③被包装的实例对象保存为 onInstance 代理对象中的一个实例属性，以便从类外部访问属性。</p>
<p><strong>2、公有声明</strong><br>Public 声明一个类的实例属性，可以从任何地方自由地访问，而没有声明为 Public 的任何名称，不能从类的外部访问。</p>
<p>当使用了 Private ，所有未声明的名称就是 Public ；当使用了 Public ，所有未声明的名称就是 Private 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Class decorator with Private and Public attribute declarations.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Controls external access to attributes stored on an instance, or</span></span><br><span class="line"><span class="string">Inherited by it from its classes. Private declares attribute names</span></span><br><span class="line"><span class="string">that cannot be fetched or assigned outside the decorated class,</span></span><br><span class="line"><span class="string">and Public declares all the names that can.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Caveat: this works in 3.X for explicitly named attributes only: __X__</span></span><br><span class="line"><span class="string">operator overloading methods implicitly run for built-in operations</span></span><br><span class="line"><span class="string">do not trigger either __getattr__ or __getattribute__ in new-style</span></span><br><span class="line"><span class="string">classes. Add __X__ methods here to intercept and delegate built-ins.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">traceMe = <span class="literal">False</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">if</span> traceMe: <span class="built_in">print</span>(<span class="string">&#x27;[&#x27;</span> + <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, args)) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accessControl</span>(<span class="params">failIf</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onDecorator</span>(<span class="params">aClass</span>):</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">onInstance</span>:</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kargs</span>):</span><br><span class="line">                self.__wrapped = aClass(*args, **kargs)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">                trace(<span class="string">&#x27;get:&#x27;</span>, attr)</span><br><span class="line">                <span class="keyword">if</span> failIf(attr):</span><br><span class="line">                    <span class="keyword">raise</span> TypeError(<span class="string">&#x27;private attribute fetch: &#x27;</span> + attr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">getattr</span>(self.__wrapped, attr)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, attr, value</span>):</span><br><span class="line">                trace(<span class="string">&#x27;set:&#x27;</span>, attr, value)</span><br><span class="line">                <span class="keyword">if</span> attr == <span class="string">&#x27;_onInstance__wrapped&#x27;</span>: <span class="comment"># 见31-2伪私有属性，__wrapped变成了_onInstance__wrapped</span></span><br><span class="line">                    self.__dict__[attr] = value</span><br><span class="line">                <span class="keyword">elif</span> failIf(attr):</span><br><span class="line">                    <span class="keyword">raise</span> TypeError(<span class="string">&#x27;private attribute change: &#x27;</span> + attr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">setattr</span>(self.__wrapped, attr, value)</span><br><span class="line">        <span class="keyword">return</span> onInstance</span><br><span class="line">    <span class="keyword">return</span> onDecorator</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Private</span>(<span class="params">*attributes</span>):</span><br><span class="line">    <span class="keyword">return</span> accessControl(failIf=(<span class="keyword">lambda</span> attr: attr <span class="keyword">in</span> attributes))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Public</span>(<span class="params">*attributes</span>):</span><br><span class="line">    <span class="keyword">return</span> accessControl(failIf=(<span class="keyword">lambda</span> attr: attr <span class="keyword">not</span> <span class="keyword">in</span> attributes))</span><br><span class="line"></span><br><span class="line"><span class="meta">@Private(<span class="params"><span class="string">&#x27;age&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">X = Person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(X.name)</span><br><span class="line">X.name = <span class="string">&#x27;Sue&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(X.name)</span><br><span class="line"><span class="comment"># X.age # TypeError: private attribute fetch: age</span></span><br><span class="line"><span class="comment"># X.age = &#x27;Tom&#x27; # TypeError: private attribute change: age</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Public(<span class="params"><span class="string">&#x27;name&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">X = Person(<span class="string">&#x27;bob&#x27;</span>, <span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(X.name)</span><br><span class="line">X.name = <span class="string">&#x27;Sue&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(X.name)</span><br><span class="line">X.age <span class="comment"># TypeError: private attribute fetch: age</span></span><br><span class="line">X.age = <span class="string">&#x27;Tom&#x27;</span> <span class="comment"># TypeError: private attribute change: age</span></span><br></pre></td></tr></table></figure>
<p>虽然控制了对实例及类属性的访问控制，但是仍然可以显示地调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(X._onInstance__wrapped.age)</span><br></pre></td></tr></table></figure>
<p>内置操作隐式运行地 <code>__X__</code> 运算符重载方法不会在新式类触发 <code>__getattr__</code> 或 <code>__getattribute__</code> ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Private(<span class="params"><span class="string">&#x27;age&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.age = <span class="number">42</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Person: &#x27;</span> + <span class="built_in">str</span>(self.age)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, yrs</span>):</span><br><span class="line">        self.age += yrs</span><br><span class="line"></span><br><span class="line">X = Person()</span><br><span class="line"><span class="built_in">print</span>(X.age) <span class="comment"># TypeError: private attribute fetch: age</span></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">X + <span class="number">10</span> <span class="comment"># TypeError: unsupported operand type(s) for +: &#x27;onInstance&#x27; and &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="Chapter-40-Metaclasses"><a href="#Chapter-40-Metaclasses" class="headerlink" title="Chapter 40 Metaclasses"></a>Chapter 40 Metaclasses</h2><h3 id="一、Metaclass-Basics"><a href="#一、Metaclass-Basics" class="headerlink" title="一、Metaclass Basics"></a>一、Metaclass Basics</h3><p><strong>元类</strong>是创建类的类。  </p>
<p>某种程度上来说，元类只是扩展了装饰器的代码插入模型，元类允许拦截并扩展类的创建，提供了一种在 class 语句结束时运行插入额外逻辑的 API 。元类主要由构建API工具的程序员使用。  </p>
<p>类装饰器在被装饰类创建完成之后运行；而元类在类创建过程中就运行，创建并返回新的客户类。</p>
<p><strong>1、类是类型的实例</strong><br>用户定义的类对象是名为 <strong>type</strong> 的对象的实例，<strong>type</strong> 本身是一个类；<br>类继承自 <strong>object</strong> ， <strong>object</strong> 是 <strong>type</strong> 的一个子类；  </p>
<p>内置类型的实例的类型是内置的类型，例如列表的实例的类型是 list ，而列表类型的类型是 type 本身。</p>
<p><strong>类即类型，类型即类</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>([]), <span class="built_in">type</span>(<span class="built_in">type</span>([])))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">list</span>), <span class="built_in">type</span>(<span class="built_in">type</span>))</span><br></pre></td></tr></table></figure>
<p>用户定义的类是产生它们自己的实例的类型；</p>
<p>类有链接到 type 的一个 <code>__class__</code> 属性，就像实例有链接到创建它的类的 <code>__class__</code> 一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">pass</span></span><br><span class="line">X = C()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(X))</span><br><span class="line"><span class="built_in">print</span>(X.__class__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(C))</span><br><span class="line"><span class="built_in">print</span>(C.__class__)</span><br></pre></td></tr></table></figure>
<p><strong>2、元类是 Type 的子类</strong><br>因为类是 type 类的实例，所以从 type 的定制的子类创建类允许我们实现各种定制的类；</p>
<p>①元类是 type 类的子类；<br>②类对象是 type 类的实例或子类；</p>
<p>为了控制创建类以及扩展其行为的方式，可以指定一个用户定义的类创建自一个用户定义的元类，而不是常规的 type 类。</p>
<p>主要上面的类型实例关系与继承不同，但不会暴露在正常的继承搜索中，即不出现在类的 <code>__bases__</code> 元组中，见后面。</p>
<p><strong>3、class 语句协议</strong><br>在一条 class 语句的末尾，Python 遵循一个标准协议，运行了所有内嵌的代码后，python 会调用 type 对象来创建 class 对象：<br><code>class = type(classname, superclasses, attributedict)</code>  </p>
<p>type 对象定义了一个 <code>__call__</code> 运算符重载方法，当 type 被调用时，该方法运行2个其他方法：<br>① <code>type.__new__(typeclass, classname, superclasses, attributedict)</code><br>② <code>type.__init__(class, classname, superclasses, attributedict)</code><br><code>__new__</code> 方法创建并返回新的 class 对象，然后 <code>__init__</code> 方法初始化新创建的对象。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>: ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(<span class="title class_ inherited__">Eggs</span>):</span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br></pre></td></tr></table></figure>
<p>这里会在 class 语句末尾调用 type 对象来产生 class 对象：<br><code>Spam = type(&#39;Spam&#39;, (Eggs,), &#123;&#39;data&#39;: 1, &#39;meth&#39;: meth, &#39;__module__&#39;: &#39;__main__&#39;&#125;)</code></p>
<p>也可以显示地调用 type 来动态地创建一个类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">type</span>(<span class="string">&#x27;Spam&#x27;</span>, (), &#123;<span class="string">&#x27;data&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;meth&#x27;</span>: (<span class="keyword">lambda</span> x, y: x.data + y)&#125;) <span class="comment"># 空的父类元组会自动添加object父类</span></span><br><span class="line">i = x()</span><br><span class="line"><span class="built_in">print</span>(x, i)</span><br><span class="line"><span class="built_in">print</span>(i.data, i.meth(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(x.__bases__)</span><br></pre></td></tr></table></figure>
<p><strong>4、声明元类</strong><br>在类头部把想要使用的元类作为关键字参数列出来：<br><code>class Spam(metaclass=Meta):</code><br>与继承的父类同时列在头部，父类必须列在元类之前：<br><code>class Spam(Eggs, metaclass=Meta):</code></p>
<p>当一个特定的元类按照上面的语法声明时，运行在 class 语句末尾来创建 class 对象的调用被修改为了调用元类而不是默认的 type ：<code>class = Meta(classname, superclasses, attributedict)</code></p>
<p>因为元类是 type 的一个子类，所以如果元类定义了 <code>__new__</code> 和 <code>__init__</code> 方法的话，那么 type 的 <code>__call__</code> 会把创建和初始化新的 class 对象的调用委托给元类：<br><code>Meta.__new__(Meta, classname, superclasses, attributedict)</code><br><code>Meta.__init__(class, classname, superclasses, attributedict)</code></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=Meta):</span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br></pre></td></tr></table></figure>
<p>在 class 语句末尾，python 内部会自动运行如下代码：<br><code>Spam = Meta(&#39;Spam&#39;, (Eggs,), &#123;&#39;data&#39;: 1, &#39;meth&#39;: meth, &#39;__module__&#39;: &#39;__main__&#39;&#125;)</code></p>
<p>如果元类定义了自己的 <code>__new__</code> 或 <code>__init__</code> ，在调用期间，它们会依次由所继承的 type 类的 <code>__call__</code> 方法调用，以创建并初始化新类。</p>
<h3 id="二、Coding-Metaclasses"><a href="#二、Coding-Metaclasses" class="headerlink" title="二、Coding Metaclasses"></a>二、Coding Metaclasses</h3><p><strong>1、一个基础的元类</strong><br>简单的示例：一个带有 <code>__new__</code> 方法的 type 的子类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Meta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run by inherited type.__call__&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(meta, classname, supers, classdict)</span><br></pre></td></tr></table></figure>
<p>元类的 <code>__new__</code> 方法通常执行所需的定制并且调用 type 父类的 <code>__new__</code> 方法来创建并返回新的类对象。</p>
<p>稍微复杂的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetaOne</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaOne.new:&#x27;</span>, meta, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(meta, classname, supers, classdict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=MetaOne):</span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making instance&#x27;</span>)</span><br><span class="line">X = Spam()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>, X.data, X.meth(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>在 class 语句末尾调用元类，Spam 继承自 Eggs 并且是 Metaone 的一个实例，X 是 Spam 的一个实例并且继承自 Spam 。</p>
<p><strong>2、定制构建和初始化</strong><br><code>__new__</code> 创建并返回了类对象，而 <code>__init__</code> 初始化了作为参数被传入的已经创建的类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetaTwo</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaTwo.new: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(meta, classname, supers, classdict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">Class, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaTwo.init:&#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;...init class object:&#x27;</span>, <span class="built_in">list</span>(Class.__dict__.keys()))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=MetaTwo):</span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making instance&#x27;</span>)</span><br><span class="line">X = Spam()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>, X.data, X.meth(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>类初始化方法（ <code>__init__</code> ）在类构建方法（ <code>__new__</code> ）之后运行；<br>Spam 的 <code>__init__</code> 会在实例创建的时候运行，而不会被元类的 <code>__init__</code> 影响。</p>
<p><strong>3、其他元类编写技巧</strong><br>①使用工厂函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">MetaFunc</span>(<span class="params">classname, supers, classdict</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;In MetaFunc: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(classname, supers, classdict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=MetaFunc):</span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making instance&#x27;</span>)</span><br><span class="line">X = Spam()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>, X.data, X.meth(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>②用普通类重载类创建调用<br>下面的类没有继承自 type ，而是提供了一个 <code>__call__</code> 方法；<br><code>__new__</code> 和 <code>__init__</code> 要重新命名为其他名称（比如下面的 __New__ 和 __Init__ ），否则会在 Meta 实例创建时运行，而不是之后在元类的角色中被调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetaObj</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaObj.call: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        Class = self.__New__(classname, supers, classdict)</span><br><span class="line">        self.__Init__(Class, classname, supers, classdict)</span><br><span class="line">        <span class="keyword">return</span> Class</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__New__</span>(<span class="params">self, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaObj.new: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(classname, supers, classdict)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Init__</span>(<span class="params">self, Class, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaObj.init:&#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;...init class object:&#x27;</span>, <span class="built_in">list</span>(Class.__dict__.keys()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=MetaObj()): <span class="comment"># MetaObj是一个类实例</span></span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making instance&#x27;</span>)</span><br><span class="line">X = Spam()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>, X.data, X.meth(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>三个方法通过正常实例继承来的 <code>__call__</code> 方法被分发。</p>
<p>使用父类继承来扮演 type 类似的角色：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMetaObj</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SuperMetaObj.call: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        Class = self.__New__(classname, supers, classdict)</span><br><span class="line">        self.__Init__(Class, classname, supers, classdict)</span><br><span class="line">        <span class="keyword">return</span> Class</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubMetaObj</span>(<span class="title class_ inherited__">SuperMetaObj</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__New__</span>(<span class="params">self, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SubMetaObj.new: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(classname, supers, classdict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Init__</span>(<span class="params">self, Class, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SubMetaObj.init:&#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;...init class object:&#x27;</span>, <span class="built_in">list</span>(Class.__dict__.keys()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=SubMetaObj()):</span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making instance&#x27;</span>)</span><br><span class="line">X = Spam()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>, X.data, X.meth(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>③用元类重载 <code>__call__</code><br>对 <code>__new__</code> 和 <code>__call__</code> 的重载需调用 type 来启动：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SuperMeta.call: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__call__(meta, classname, supers, classdict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">Class, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SuperMeta init:&#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;...init class object:&#x27;</span>, <span class="built_in">list</span>(Class.__dict__.keys()))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making metaclass&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubMeta</span>(<span class="built_in">type</span>, metaclass=SuperMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SubMeta.new: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(meta, classname, supers, classdict)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">Class, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SubMeta init:&#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;...init class object:&#x27;</span>, <span class="built_in">list</span>(Class.__dict__.keys()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=SubMeta): <span class="comment"># Invoke SubMeta, via SuperMeta.__call__</span></span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making instance&#x27;</span>)</span><br><span class="line">X = Spam()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>, X.data, X.meth(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>元类用于创造类对象，但是只在作为一个元类角色被调用的时候才产生它们的实例；<br>元类也可以从其他元类继承名称，元类间的继承只适用于显式的名称获取，而不能作用于内置操作的调用的隐式名称查找；<br>内置操作的调用的隐式名称可以在它的 <code>__class__</code> 中找到，要么是默认的 type ，要么是一个元类。</p>
<p>SubMeta 中的 metaclass 是必要的；<br>SuperMeta 的 <code>__call__</code> 方法不会运行在 SubMeta 创建时的 SuperMeta 调用，而是会运行在 Spam 创建时的 SubMeta 调用；<br>SubMeta 的创建会路由到 type 。</p>
<p>如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SuperMeta.call:&#x27;</span>, classname)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__call__(meta, classname, supers, classdict)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubMeta</span>(<span class="title class_ inherited__">SuperMeta</span>): <span class="comment"># Created by type default，普通的父类被内置操作跳过，但显式的获取调用不会跳过</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">Class, classname, supers, classdict</span>): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SubMeta init:&#x27;</span>, classname)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(SubMeta.__class__)</span><br><span class="line"><span class="built_in">print</span>([n.__name__ <span class="keyword">for</span> n <span class="keyword">in</span> SubMeta.__mro__])</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(SubMeta.__call__) <span class="comment"># 显式调用</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">SubMeta.__call__(SubMeta, <span class="string">&#x27;xxx&#x27;</span>, (), &#123;&#125;) <span class="comment"># 显式调用：运行了SuperMeta的__call__，元类继承</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">SubMeta(<span class="string">&#x27;yyy&#x27;</span>, (), &#123;&#125;) <span class="comment"># 隐式内置调用：没运行SuperMeta的__call__，元类的类是type</span></span><br></pre></td></tr></table></figure>
<p>更深刻的理解见后面。</p>
<h3 id="三、Inheritance-and-Instance"><a href="#三、Inheritance-and-Instance" class="headerlink" title="三、Inheritance and Instance"></a>三、Inheritance and Instance</h3><p><strong>1、元类和父类继承</strong><br>区分元类的指定方式和父类继承，相似但不一样。</p>
<p>①元类继承自 type 类<br>元类通常重新定义 type 类的 <code>__new__</code> 和 <code>__init__</code> 方法，也可以重新定义 <code>__call__</code> （不常见，而且会出现上一节中看到的复杂性）</p>
<p>②元类声明会被子类继承<br><code>metaclass=M</code> 会被该类的普通子类继承，继承了该声明的类的构建都会运行该元类。</p>
<p>③元类属性不会被类实例继承<br>因为类是元类的实例，所以元类中定义的行为适用于类，但不适用于类的实例；<br>实例从类和父类获取行为，但不会从元类获取行为；<br>普通实例属性继承通常只查找该实例、对应的类、所有父类的 <code>__dict__</code> 字典；不包括元类。</p>
<p>④元类属性会被类获取<br>类能通过继承关系从元类获得方法；<br>类通过类的 <code>__class__</code> 链接来获取元类属性，这跟普通实例从它们的类获取名称是一样的，但是通过 <code>__dict__</code> 继承的名称会被优先搜索；<br>当同一名称同时出现在元类和父类，父类的版本（通过继承）会被优先使用，而元类（作为元类的实例）会被忽略；<br>而类的 <code>__class__</code> 不会被它本身的实例所继承。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetaOne</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaOne.new:&#x27;</span>, classname)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(meta, classname, supers, classdict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">toast</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;toast&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>(metaclass=MetaOne):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Super</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eggs</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;eggs&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码运行时，元类会同时处理2个客户类的构建，并且实例继承类属性而不是元类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = Sub()</span><br><span class="line"><span class="built_in">print</span>(X.eggs(), X.spam())</span><br><span class="line"><span class="built_in">print</span>(X.toast()) <span class="comment"># 会出错：AttributeError: &#x27;Sub&#x27; object has no attribute &#x27;toast&#x27;</span></span><br></pre></td></tr></table></figure>
<p>但类可以从父类继承名字，也可以从元类获取名字；<br>从元类获取的方法被绑定到了主体类上，从普通类获取的方法通过类获取是非绑定的，而通过实例获取是绑定的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(Sub.eggs(X), Sub.spam(X))</span><br><span class="line"><span class="built_in">print</span>(Sub.toast())</span><br><span class="line"><span class="built_in">print</span>(Sub.toast)</span><br><span class="line"><span class="built_in">print</span>(Sub.spam)</span><br><span class="line"><span class="built_in">print</span>(X.spam)</span><br></pre></td></tr></table></figure>
<p><strong>2、元类 vs 父类</strong><br>简单地来说，类作为元类的实例继承了元类的属性，但是这个属性不能被类自己的实例继承：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">type</span>): attr = <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(metaclass=A): <span class="keyword">pass</span></span><br><span class="line">I = B()</span><br><span class="line"><span class="built_in">print</span>(B.attr)</span><br><span class="line"><span class="built_in">print</span>(I.attr) <span class="comment"># 出现错误：AttributeError: &#x27;B&#x27; object has no attribute &#x27;attr&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> B.__dict__, <span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> A.__dict__)</span><br></pre></td></tr></table></figure>
<p>把 A 从元类改为父类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: attr = <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line">I = B()</span><br><span class="line"><span class="built_in">print</span>(B.attr)</span><br><span class="line"><span class="built_in">print</span>(I.attr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> B.__dict__, <span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> A.__dict__)</span><br></pre></td></tr></table></figure>
<p>同一名称出现在父类和元类中的情形：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">M</span>(<span class="title class_ inherited__">type</span>): attr = <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: attr = <span class="number">2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(A, metaclass=M): <span class="keyword">pass</span></span><br><span class="line">I = B()</span><br><span class="line"><span class="built_in">print</span>(B.attr, I.attr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> B.__dict__, <span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> A.__dict__, <span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> M.__dict__)</span><br></pre></td></tr></table></figure>
<p>python 会优先通过 MRO （通过继承）检查每个类的 <code>__dict__</code> ，之后再到元类（作为实例）中获取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">M</span>(<span class="title class_ inherited__">type</span>): attr = <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: attr = <span class="number">2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(B, metaclass=M): <span class="keyword">pass</span></span><br><span class="line">I = C()</span><br><span class="line"><span class="built_in">print</span>(I.attr, C.attr)</span><br><span class="line"><span class="built_in">print</span>([x.__name__ <span class="keyword">for</span> x <span class="keyword">in</span> C.__mro__])</span><br></pre></td></tr></table></figure>
<p>类通过自身的 <code>__class__</code> 链接来获取元类属性（即实例通过 <code>__class__</code> 获取类属性的方式）；<br>但是实例继承是将其作用域限制在 MRO 顺序搜索到的每一个类的 <code>__dict__</code> 中，即跟随每个类的 <code>__bases__</code> ，而且只使用实例的 <code>__class__</code> 链接一次：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(I.__class__)</span><br><span class="line"><span class="built_in">print</span>(C.__bases__)</span><br><span class="line"><span class="built_in">print</span>(C.__class__)</span><br><span class="line"><span class="built_in">print</span>(C.__class__.attr)</span><br></pre></td></tr></table></figure>
<p><strong>3、继承：完整的例子</strong><br>①实例从它的类继承；类则从类和元类继承；元类从父元类继承：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">M1</span>(<span class="title class_ inherited__">type</span>): attr1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M2</span>(<span class="title class_ inherited__">M1</span>): attr2 = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>: attr3 = <span class="number">3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>(C1,metaclass=M2): attr4 = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">I = C2()</span><br><span class="line"><span class="built_in">print</span>(I.attr3, I.attr4)</span><br><span class="line"><span class="built_in">print</span>(C2.attr1, C2.attr2, C2.attr3, C2.attr4)</span><br><span class="line"><span class="built_in">print</span>(M2.attr1, M2.attr2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(I.__class__, C2.__bases__)</span><br><span class="line"><span class="built_in">print</span>(C2.__class__, M2.__bases__)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(M2.__class__)</span><br><span class="line"><span class="built_in">print</span>([x.__name__ <span class="keyword">for</span> x <span class="keyword">in</span> C2.__mro__]) <span class="comment"># __bases__ tree from I.__class__</span></span><br><span class="line"><span class="built_in">print</span>([x.__name__ <span class="keyword">for</span> x <span class="keyword">in</span> M2.__mro__]) <span class="comment"># __bases__ tree from C2.__class__</span></span><br></pre></td></tr></table></figure>
<p>综上所述，继承会在利用 <code>__class__</code> 之前先利用 <code>__bases__</code> ，因为 <code>__bases__</code> 被用于创造类的时候建立 <code>__mro__</code> 顺序，而继承基于 MRO 。<br>普通实例没有 <code>__bases__</code> ；而类二者都有，包括类和元类。</p>
<p>②继承算法顺序  </p>
<ul>
<li>从实例 I 出发，先搜索该实例，再搜索它的类，之后搜索所有父类：  <ul>
<li>实例 I 的 <code>__dict__</code>；   </li>
<li>所有在 I 的 <code>__class__</code> 中的 <code>__mro__</code> 找到的类的 <code>__dict__</code>。  </li>
</ul>
</li>
<li>从类 C 出发，先搜索该类，再搜索它的所有父类，之后搜索它的元类树：  <ul>
<li>所有 C 的 <code>__mro__</code> 中的类的 <code>__dict__</code> ； </li>
<li>所有在 C 的 <code>__class__</code> 中的 <code>__mro__</code> 找到的类的 <code>__dict__</code> ；  </li>
</ul>
</li>
<li>步骤 b 出现的数据描述符具有优先权；</li>
<li>内置操作跳过步骤 a ，从步骤 b 开始搜索。</li>
</ul>
<p>③描述符特例  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>): <span class="built_in">print</span>(<span class="string">&#x27;__get__&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>): <span class="built_in">print</span>(<span class="string">&#x27;__set__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: d = D() <span class="comment"># Data descriptor attribute</span></span><br><span class="line">I = C()</span><br><span class="line">I.d</span><br><span class="line">I.d = <span class="number">1</span></span><br><span class="line">I.__dict__[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">I.d <span class="comment"># 命名空间的d不会覆盖数据描述符</span></span><br></pre></td></tr></table></figure>
<p>④内置操作特例<br>实例和类都会跳过内置操作；<br>比如，str 是内置操作，<code>__str__</code> 是它等价的显式名称，实例在内置操作的搜索被跳过：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    attr = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="keyword">return</span>(<span class="string">&#x27;class&#x27;</span>)</span><br><span class="line"></span><br><span class="line">I = C()</span><br><span class="line"><span class="built_in">print</span>(I.__str__(), <span class="built_in">str</span>(I)) <span class="comment"># 都来自类C</span></span><br><span class="line"></span><br><span class="line">I.__str__ = <span class="keyword">lambda</span>: <span class="string">&#x27;instance&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(I.__str__(), <span class="built_in">str</span>(I)) <span class="comment"># 前者来自实例的命名空间，后者来自C的命名空间，即显式调用来自实例，内置操作来自类</span></span><br></pre></td></tr></table></figure>
<p>同样规则也适用于类与元类，显式名称搜索从类开始，内置操作从类的类开始，即元类（默认是 type ）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="keyword">return</span>(<span class="string">&#x27;D class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">D</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(C.__str__(C), <span class="built_in">str</span>(C)) <span class="comment"># C的元类是type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">D</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="keyword">return</span>(<span class="string">&#x27;C class&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(C.__str__(C), <span class="built_in">str</span>(C))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(metaclass=D):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="keyword">return</span>(<span class="string">&#x27;C class&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(C.__str__(C), <span class="built_in">str</span>(C))</span><br></pre></td></tr></table></figure>
<p>所有的类也继承自 object ，包括默认的 type 元类。</p>
<p>比如下面，C 按照继承（ MRO ）从 object 获取了默认的 <code>__str__</code> ，而非从元类中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(metaclass=D):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(C.__str__(C), <span class="built_in">str</span>(C))</span><br><span class="line"><span class="built_in">print</span>(C.__str__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> (C, C.__class__, <span class="built_in">type</span>): <span class="built_in">print</span>([x.__name__ <span class="keyword">for</span> x <span class="keyword">in</span> k.__mro__])</span><br></pre></td></tr></table></figure>
<h3 id="四、Metaclass-Methods"><a href="#四、Metaclass-Methods" class="headerlink" title="四、Metaclass Methods"></a>四、Metaclass Methods</h3><p><strong>1、元类方法</strong><br>元类方法能够处理对应的实例类，不是普通实例对象 self ，而是类本身：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">cls</span>): <span class="built_in">print</span>(<span class="string">&#x27;ax&#x27;</span>, cls) <span class="comment"># 注意：不是self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">y</span>(<span class="params">cls</span>): <span class="built_in">print</span>(<span class="string">&#x27;ay&#x27;</span>, cls)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(metaclass=A):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">y</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;by&#x27;</span>, self)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">z</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;bz&#x27;</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(B.x, B.y, B.z)</span><br><span class="line">B.x()</span><br><span class="line"></span><br><span class="line">I = B()</span><br><span class="line">I.y()</span><br><span class="line">I.z()</span><br><span class="line">I.x() <span class="comment"># 出现错误：AttributeError: &#x27;B&#x27; object has no attribute &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>2、元类方法中的运算符重载</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">cls, name</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(cls.data, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(metaclass=A):</span><br><span class="line">    data = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(B.upper())</span><br><span class="line"><span class="built_in">print</span>(B.upper)</span><br><span class="line"><span class="built_in">print</span>(B.__getattr__)</span><br><span class="line">I = B()</span><br><span class="line">I.upper <span class="comment"># 出现错误：AttributeError: &#x27;B&#x27; object has no attribute &#x27;upper&#x27;</span></span><br><span class="line">I.__getattr__ <span class="comment"># 出现错误：AttributeError: &#x27;B&#x27; object has no attribute &#x27;__getattr__&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="五、Examples"><a href="#五、Examples" class="headerlink" title="五、Examples"></a>五、Examples</h3><p><strong>1、实例：向类添加方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">eggsfunc</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">return</span> obj.value * <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hamfunc</span>(<span class="params">obj, value</span>):</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&#x27;ham&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Extender</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        classdict[<span class="string">&#x27;eggs&#x27;</span>] = eggsfunc</span><br><span class="line">        classdict[<span class="string">&#x27;ham&#x27;</span>] = hamfunc</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(meta, classname, supers, classdict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client1</span>(metaclass=Extender):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client2</span>(metaclass=Extender):</span><br><span class="line">    value = <span class="string">&#x27;ni?&#x27;</span></span><br><span class="line"></span><br><span class="line">X = Client1(<span class="string">&#x27;Ni!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(X.spam())</span><br><span class="line"><span class="built_in">print</span>(X.eggs())</span><br><span class="line"><span class="built_in">print</span>(X.ham(<span class="string">&#x27;bacon&#x27;</span>))</span><br><span class="line"></span><br><span class="line">Y = Client2()</span><br><span class="line"><span class="built_in">print</span>(Y.eggs())</span><br><span class="line"><span class="built_in">print</span>(Y.ham(<span class="string">&#x27;bacon&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>上述示例中的元类把2个已知的方法添加到了声明了元类的每个类中。</p>
<p><strong>2、基于装饰器的上述代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">eggsfunc</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">return</span> obj.value * <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hamfunc</span>(<span class="params">obj, value</span>):</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&#x27;ham&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Extender</span>(<span class="params">aClass</span>):</span><br><span class="line">    aClass.eggs = eggsfunc</span><br><span class="line">    aClass.ham = hamfunc</span><br><span class="line">    <span class="keyword">return</span> aClass</span><br><span class="line"></span><br><span class="line"><span class="meta">@Extender</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Extender</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client2</span>:</span><br><span class="line">    value = <span class="string">&#x27;ni?&#x27;</span></span><br><span class="line"></span><br><span class="line">X = Client1(<span class="string">&#x27;Ni!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(X.spam())</span><br><span class="line"><span class="built_in">print</span>(X.eggs())</span><br><span class="line"><span class="built_in">print</span>(X.ham(<span class="string">&#x27;bacon&#x27;</span>))</span><br><span class="line"></span><br><span class="line">Y = Client2()</span><br><span class="line"><span class="built_in">print</span>(Y.eggs())</span><br><span class="line"><span class="built_in">print</span>(Y.ham(<span class="string">&#x27;bacon&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><strong>3、元类 vs 类装饰器</strong><br>①类装饰器可以管理类和实例，但是通常不能创建类，需要额外步骤来创建新的类；<br>②元类可以管理类和实例，但是管理实例需要一些额外的工作； </p>
<p>类装饰器在 class 语句末尾，把类名绑定到装饰器函数或类的结果；<br>元类通过一条 class 语句末尾把类对象的创建路由到一个对象，从而创建新的类。</p>
<p>本章后面有元类和类装饰器比较以及结合的例子，因为暂无学习的必要性，未作摘抄，大致了解即可，之后面向需求学习。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io">鸟布</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io/2022/10/27/2022-10-27-Learning-python4/">https://ybniaobu.github.io/2022/10/27/2022-10-27-Learning-python4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ybniaobu.github.io" target="_blank">鸟布的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/11/27/R9htYK5LyFuEGTk.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src="/images/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/04/2022-11-04-hexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" title="Hexo博客教程"><img class="cover" src="https://s2.loli.net/2022/10/22/e5ijADhmQ1SRcnN.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hexo博客教程</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/24/2022-10-24-Learning-python3/" title="《Learning Python》读书笔记（三）"><img class="cover" src="https://s2.loli.net/2022/11/27/R9htYK5LyFuEGTk.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《Learning Python》读书笔记（三）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/09/09/2022-09-09-Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="《Python编程从入门到实践》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2022/11/27/h9RxCDEfGAM53j4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-09</div><div class="title">《Python编程从入门到实践》读书笔记（一）</div></div></a></div><div><a href="/2022/09/12/2022-09-12-Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" title="《Python编程从入门到实践》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2022/11/27/h9RxCDEfGAM53j4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">《Python编程从入门到实践》读书笔记（二）</div></div></a></div><div><a href="/2022/10/21/2022-10-21-Learning-python2/" title="《Learning Python》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2022/11/27/R9htYK5LyFuEGTk.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-21</div><div class="title">《Learning Python》读书笔记（二）</div></div></a></div><div><a href="/2022/09/17/2022-09-17-Learning-python1/" title="《Learning Python》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2022/11/27/R9htYK5LyFuEGTk.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-17</div><div class="title">《Learning Python》读书笔记（一）</div></div></a></div><div><a href="/2022/10/24/2022-10-24-Learning-python3/" title="《Learning Python》读书笔记（三）"><img class="cover" src="https://s2.loli.net/2022/11/27/R9htYK5LyFuEGTk.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-24</div><div class="title">《Learning Python》读书笔记（三）</div></div></a></div><div><a href="/2022/12/06/2022-12-06-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B2/" title="《C#图解教程》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-06</div><div class="title">《C#图解教程》读书笔记（二）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/wechat%20avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鸟布</div><div class="author-info__description">教练，我想学技术</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://niaobu.notion.site/787824630ea6480e944c1ae5ae7f4792"><i class="fa-solid fa-book"></i><span>My Notion</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ybniaobu/ybniaobu.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:niaobubob@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为了蒂法！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-33-Exception-Basics"><span class="toc-number">1.</span> <span class="toc-text">Chapter 33 Exception Basics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Exception-Basics"><span class="toc-number">1.1.</span> <span class="toc-text">一、Exception Basics</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-34-Exception-Coding-Details"><span class="toc-number">2.</span> <span class="toc-text">Chapter 34 Exception Coding Details</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81The-try-except-else-Statement"><span class="toc-number">2.1.</span> <span class="toc-text">一、The try&#x2F;except&#x2F;else Statement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81The-raise-Statement"><span class="toc-number">2.2.</span> <span class="toc-text">二、The raise Statement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81The-assert-Statement"><span class="toc-number">2.3.</span> <span class="toc-text">三、The assert Statement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81with-as-Context-Managers"><span class="toc-number">2.4.</span> <span class="toc-text">四、with&#x2F;as Context Managers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-35-Exception-Objects"><span class="toc-number">3.</span> <span class="toc-text">Chapter 35 Exception Objects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Class-Based-Exceptions"><span class="toc-number">3.1.</span> <span class="toc-text">一、Class-Based Exceptions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Built-in-Exception-Classes"><span class="toc-number">3.2.</span> <span class="toc-text">二、Built-in Exception Classes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Custom-Data-and-Behavior"><span class="toc-number">3.3.</span> <span class="toc-text">三、Custom Data and Behavior</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-36-Designing-with-Exceptions"><span class="toc-number">4.</span> <span class="toc-text">Chapter 36 Designing with Exceptions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Nesting-Exception-Handlers"><span class="toc-number">4.1.</span> <span class="toc-text">一、Nesting Exception Handlers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Exception-Idioms"><span class="toc-number">4.2.</span> <span class="toc-text">二、Exception Idioms</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-37-Unicode-and-Byte-Strings"><span class="toc-number">5.</span> <span class="toc-text">Chapter 37 Unicode and Byte Strings</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81String-Basics"><span class="toc-number">5.1.</span> <span class="toc-text">一、String Basics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Coding-Basic-Strings"><span class="toc-number">5.2.</span> <span class="toc-text">二、Coding Basic Strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Coding-Unicode-Strings"><span class="toc-number">5.3.</span> <span class="toc-text">三、Coding Unicode Strings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Using-bytes-Objects"><span class="toc-number">5.4.</span> <span class="toc-text">四、Using bytes Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81Using-bytearray-Objects"><span class="toc-number">5.5.</span> <span class="toc-text">五、Using bytearray Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81Using-Text-and-Binary-Files"><span class="toc-number">5.6.</span> <span class="toc-text">六、Using Text and Binary Files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81Using-Unicode-Files"><span class="toc-number">5.7.</span> <span class="toc-text">七、Using Unicode Files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81Other-String-Tool"><span class="toc-number">5.8.</span> <span class="toc-text">八、Other String Tool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-38-Managed-Attributes"><span class="toc-number">6.</span> <span class="toc-text">Chapter 38 Managed Attributes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Why-Manage-Attributes"><span class="toc-number">6.1.</span> <span class="toc-text">一、Why Manage Attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Properties"><span class="toc-number">6.2.</span> <span class="toc-text">二、Properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Descriptors"><span class="toc-number">6.3.</span> <span class="toc-text">三、Descriptors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-getattr-and-getattribute"><span class="toc-number">6.4.</span> <span class="toc-text">四、__getattr__ and __getattribute__</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-39-Decorators"><span class="toc-number">7.</span> <span class="toc-text">Chapter 39 Decorators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81The-Basics"><span class="toc-number">7.1.</span> <span class="toc-text">一、The Basics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Coding-Function-Decorators"><span class="toc-number">7.2.</span> <span class="toc-text">二、Coding Function Decorators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Coding-Function-Decorators-2"><span class="toc-number">7.3.</span> <span class="toc-text">三、Coding Function Decorators 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Coding-Class-Decorators"><span class="toc-number">7.4.</span> <span class="toc-text">四、Coding Class Decorators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81Managing-Functions-and-Classes-Directly"><span class="toc-number">7.5.</span> <span class="toc-text">五、Managing Functions and Classes Directly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E2%80%9CPrivate%E2%80%9D-and-%E2%80%9CPublic%E2%80%9D-Attributes"><span class="toc-number">7.6.</span> <span class="toc-text">六、“Private” and “Public” Attributes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-40-Metaclasses"><span class="toc-number">8.</span> <span class="toc-text">Chapter 40 Metaclasses</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Metaclass-Basics"><span class="toc-number">8.1.</span> <span class="toc-text">一、Metaclass Basics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Coding-Metaclasses"><span class="toc-number">8.2.</span> <span class="toc-text">二、Coding Metaclasses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Inheritance-and-Instance"><span class="toc-number">8.3.</span> <span class="toc-text">三、Inheritance and Instance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Metaclass-Methods"><span class="toc-number">8.4.</span> <span class="toc-text">四、Metaclass Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81Examples"><span class="toc-number">8.5.</span> <span class="toc-text">五、Examples</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/09/2024-12-09-CustomSRP2/" title="Unity Custom SRP 基础（二）"><img src="https://s2.loli.net/2024/12/09/paBhbkD6Vd9CIsy.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（二）"/></a><div class="content"><a class="title" href="/2024/12/09/2024-12-09-CustomSRP2/" title="Unity Custom SRP 基础（二）">Unity Custom SRP 基础（二）</a><time datetime="2024-12-09T08:00:29.000Z" title="发表于 2024-12-09 16:00:29">2024-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/26/2024-11-26-CustomSRP1/" title="Unity Custom SRP 基础（一）"><img src="https://s2.loli.net/2024/12/09/SGVnTxOM6BURAJI.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（一）"/></a><div class="content"><a class="title" href="/2024/11/26/2024-11-26-CustomSRP1/" title="Unity Custom SRP 基础（一）">Unity Custom SRP 基础（一）</a><time datetime="2024-11-26T04:43:30.000Z" title="发表于 2024-11-26 12:43:30">2024-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/2024-10-22-BetterPBR1/" title="Custom Better PBR in Unity"><img src="https://s2.loli.net/2024/10/22/x6Xp3JjS4k5PO2W.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Custom Better PBR in Unity"/></a><div class="content"><a class="title" href="/2024/10/22/2024-10-22-BetterPBR1/" title="Custom Better PBR in Unity">Custom Better PBR in Unity</a><time datetime="2024-10-22T03:13:12.000Z" title="发表于 2024-10-22 11:13:12">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/16/2024-08-16-IBL_Basics2/" title="IBL 基于图像的光照（二）"><img src="https://s2.loli.net/2024/08/16/KQGyA6zfCW74dYw.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IBL 基于图像的光照（二）"/></a><div class="content"><a class="title" href="/2024/08/16/2024-08-16-IBL_Basics2/" title="IBL 基于图像的光照（二）">IBL 基于图像的光照（二）</a><time datetime="2024-08-16T04:43:39.000Z" title="发表于 2024-08-16 12:43:39">2024-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/09/2024-07-09-IBL_Basics1/" title="IBL 基于图像的光照（一）"><img src="https://s2.loli.net/2024/07/22/nD1y67NcRpQOHbS.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IBL 基于图像的光照（一）"/></a><div class="content"><a class="title" href="/2024/07/09/2024-07-09-IBL_Basics1/" title="IBL 基于图像的光照（一）">IBL 基于图像的光照（一）</a><time datetime="2024-07-09T07:25:54.000Z" title="发表于 2024-07-09 15:25:54">2024-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 鸟布</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Your time is limited, so don't waste it living someone else's life.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>