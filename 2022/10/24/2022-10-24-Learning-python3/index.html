<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《Learning Python》读书笔记（三） | 鸟布的博客</title><meta name="author" content="鸟布"><meta name="copyright" content="鸟布"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="该笔记为 《Learning Python》 的读书笔记，由于是早期未搞熟博客系统时所写，笔记结构较为混乱；该书涉及的内容可能过于啰嗦，但包含一些python背后的逻辑和机制，可以粗略过一遍，但若仔细阅读就是在坑自己；该笔记内容过多，所以不展示部分代码的结果，需复制到编辑器中查看；学习完成日期为2"><link rel="shortcut icon" href="https://s2.loli.net/2022/09/08/Ygib4lfw6z1khnr.png"><link rel="canonical" href="https://ybniaobu.github.io/2022/10/24/2022-10-24-Learning-python3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 鸟布","link":"链接: ","source":"来源: 鸟布的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《Learning Python》读书笔记（三）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 20:49:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/wechat%20avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/black.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鸟布的博客"><span class="site-name">鸟布的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《Learning Python》读书笔记（三）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-24T05:30:33.000Z" title="发表于 2022-10-24 13:30:33">2022-10-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T12:49:28.000Z" title="更新于 2022-11-27 20:49:28">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/">python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">python读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">25.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>100分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《Learning Python》读书笔记（三）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>该笔记为 <strong>《Learning Python》</strong> 的读书笔记，由于是早期未搞熟博客系统时所写，笔记结构较为混乱；<br>该书涉及的内容可能过于啰嗦，但包含一些python背后的逻辑和机制，可以粗略过一遍，但若仔细阅读就是在坑自己；<br>该笔记内容过多，所以不展示部分代码的结果，需复制到编辑器中查看；<br>学习完成日期为2022年10月20日。<br>本篇主要内容为：Python解释器；Python对象类型的初步介绍；数值类型。</p>
</blockquote>
<div  align="center">  
<img src="https://s2.loli.net/2022/09/17/ri9Ue6nguJdq1Ca.jpg" width = "80%" height = "80%" alt="Learning Python"/>
</div>

<h1 id="PART-V-Modules-and-Packages"><a href="#PART-V-Modules-and-Packages" class="headerlink" title="PART V Modules and Packages"></a>PART V Modules and Packages</h1><h2 id="chapter-22-Modules-The-Big-Picture"><a href="#chapter-22-Modules-The-Big-Picture" class="headerlink" title="chapter 22 Modules: The Big Picture"></a>chapter 22 Modules: The Big Picture</h2><h3 id="一、Python-Program-Architecture"><a href="#一、Python-Program-Architecture" class="headerlink" title="一、Python Program Architecture"></a>一、Python Program Architecture</h3><ol>
<li><p>一个模块文件顶层定义的所有变量都变成了被导入的模块对象的属性。</p>
</li>
<li><p>Python Program Architecture程序架构</p>
<ul>
<li>一个python拥有一个主体的顶层文件，辅以数个被称为模块的支持文件；</li>
<li>顶层文件包含了程序的主要控制流程：即用来启动应用程序的文件；</li>
<li>模块文件是工具库。</li>
</ul>
</li>
<li><p>Imports and Attributes导入与属性</p>
<ul>
<li><code>import语句</code>会逐行运行在目标文档中对的语句从而构建其中对象，使其变成模块的属性即<code>module.attribute</code>。</li>
</ul>
</li>
<li><p>How Imports Work导入语句如何工作</p>
<ul>
<li>导入会执行3个步骤：找到模块文件；编译成字节码；执行模块的代码来创建其所定义的对象；</li>
<li>这3步骤只会在程序第一次导入才会进行，之后导入相同的模块时，会跳过这3个步骤，只提取内存中已加载的模块对象；</li>
<li>python会把载入的模块存储在一个叫sys.modules的表中，每次导入操作先检查该表，不存在，则启动上述3个步骤。</li>
<li>Python使用标准模块搜索路径来找出import语句所对应的模块文件，详见第24章；</li>
<li>python会把模块编译为字节码，如果发现字节码文件比源代码旧，则会自动生成新的字节代码。字节码被存在<strong>pycache</strong>子目录里，只有被导入的文件才会在机器上留下.pyc字节码文件，顶层文件的字节码在内部使用后就丢弃了；</li>
<li>import的最后步骤就是执行，文件中的语句会从头到尾被执行。</li>
</ul>
</li>
</ol>
<h3 id="二、The-Module-Search-Path"><a href="#二、The-Module-Search-Path" class="headerlink" title="二、The Module Search Path"></a>二、The Module Search Path</h3><ol>
<li><p>模块搜索路径</p>
<ul>
<li>多数情况下，我们可以依赖模块导入搜索路径的自动特性，完全不需要配置这些路径；</li>
<li>python的模块搜索路径是下面这些主要组件拼接的结果，其中有些需要自定义：<ul>
<li>程序的主目录；（自动的）<br>即包含程序的顶层脚本文件所在的目录；这个目录总是会优先被搜索，所以会覆盖其他目录中相同名称的模块。</li>
<li>PYTHONPATH目录（可配置的configurable）；<br>python会从左到右搜索PYTHONPATH环境变量设置中罗列出的所有目录；PYTHONPATH是设置包含python程序文件的目录列表，可以把想导入的目录都加进来。</li>
<li>标准库目录（自动的）；</li>
<li>任何.pth文件中的内容（可配置的）；<br>不常用，python允许用户把需要的目录写在后缀名为.pth的文本文件中一行一行列出来，作为PYTHONPATH设置的一种替代方案；可以把文件放在python安装目录的顶层（C:\Python33）或者标准库所在位置的sitepackages子目录（C:\Python33\Lib\site-packages）。</li>
<li>第三方扩展应用的site-packages主目录（自动的）；<br>python会自动将标准库的site-packages子目录添加到模块搜索路径。</li>
<li>以上5个组件组合成了<code>sys.path</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>Configuring the Search Path配置搜索路径</p>
<ul>
<li>可以通过【我的电脑】-【属性】-【高级系统设置】-【环境变量】-【新建】，变量名写PYTHONPATH，变量值就是你要导入模块的路径；或者在python安装目录下创建.pth文本文件。</li>
<li>上面的方法是永久设置模块的搜索路径。</li>
</ul>
</li>
<li><p>sys.path列表</p>
<ul>
<li>暂时设置模块的搜索路径；</li>
<li>Python在程序启动时配置sys.path，自动将上述5个目录合并，形成一个列表；</li>
<li>这个列表提供一种让脚本手动定制其搜索路径的方式，这种修改只在脚本执行时保持，可以采用<code>sys.path.append</code>或<code>sys.path.insert</code>来改变列表：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br><span class="line">sys.path.append(<span class="string">r&#x27;XXXX&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>模块文件选择</p>
<ul>
<li>python会在搜索路径中选择第一个能够匹配导入名称的文件；</li>
<li>导入语句的本质是外部组件暴露的接口，包括以下类型：源代码文件b.py; 字节码文件b.pyc; 优化字节码文件b.pyo（不常见）; 目录b（对于包导入而言，见24章）；编译拓展模块（c或c++编写），导入时使用动态链接；用c编写的编译好的内置模块，变被静态链接至python；ZIP文件组件，导入时自动解压缩（标准库路径就是一个.zip文件）</li>
<li>更多细节参考Python标准库手册中的内置<strong>import</strong>函数的说明，这个函数是import语句的可定制工具。</li>
</ul>
</li>
</ol>
<h2 id="chapter-23-Module-Coding-Basics"><a href="#chapter-23-Module-Coding-Basics" class="headerlink" title="chapter 23 Module Coding Basics"></a>chapter 23 Module Coding Basics</h2><h3 id="一、Module-Creation-and-Usage"><a href="#一、Module-Creation-and-Usage" class="headerlink" title="一、Module Creation and Usage"></a>一、Module Creation and Usage</h3><ol>
<li><p><code>import语句</code>和<code>from语句</code></p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module</span><br><span class="line">module.method()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> method</span><br><span class="line">method()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>from*语句</code></p>
<ul>
<li>当我们使用*代替特定名称时，会取得模块顶层被赋值的所有名称的副本：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> *</span><br><span class="line">method()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Imports Happen Only Once导入只发生一次</p>
<ul>
<li>simple.py如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">spam = <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>导入执行从头到尾执行一次module文件：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> simple <span class="comment"># 执行了代码，打印了hello</span></span><br><span class="line"><span class="built_in">print</span>(simple.spam)</span><br></pre></td></tr></table></figure></li>
<li>第二次导入并不会重新执行该模块的代码，只是从内部模块表取出已创建的模块对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">simple.spam = <span class="number">2</span></span><br><span class="line"><span class="keyword">import</span> simple</span><br><span class="line"><span class="built_in">print</span>(simple.spam)</span><br></pre></td></tr></table></figure></li>
<li>如果需要再一次运行，需要内置函数<code>reload</code>，见后面。</li>
</ul>
</li>
<li><p>import和from是赋值语句</p>
<ul>
<li>import和from是可执行语句，可以被嵌套在if测试里，在def里等等；</li>
<li>import和from是隐式的赋值语句；</li>
<li><em>import将整个模块对象赋值给一个单独名称</em>；</li>
<li><em>from将一个或多个名称赋值给另一个模块中的同名对象</em>；</li>
<li><em>以from复制的名称会变成对共享对象的引用，所以要小心共享的可变对象</em>：</li>
<li>比如small.py，如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
导入small.py：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> small <span class="keyword">import</span> x, y</span><br><span class="line">x = <span class="number">42</span> <span class="comment"># Changes local x only</span></span><br><span class="line">y[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line"><span class="keyword">import</span> small</span><br><span class="line"><span class="built_in">print</span>(small.x)</span><br><span class="line"><span class="built_in">print</span>(small.y)</span><br></pre></td></tr></table></figure></li>
<li>若想修改另一文件的全局变量名，必须用import：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> small</span><br><span class="line">small.x = <span class="number">42</span> <span class="comment"># Changes x in other module</span></span><br><span class="line"><span class="built_in">print</span>(small.x)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>import and from Equivalence等价性</p>
<ul>
<li>from只是把名称从一个模块复制到另一个模块，但是不会对模块名本身进行赋值；</li>
<li>所以从概念上来说，以下2段代码是等价的<ul>
<li><code>from module import name1, name2</code>；</li>
<li>import module<br>  name1 = module.name1<br>  name2 = module.name2<br>  del module</li>
</ul>
</li>
<li>跟所有赋值语句一样，from语句会在导入者中创建新的变量，而这些变量在初始化时引用了被导入文件中的同名对象，不过，只复制了名称，没复制引用的对象。</li>
</ul>
</li>
<li><p>Potential Pitfalls潜在陷阱 of the from Statement</p>
<ul>
<li>因为from语句会让变量的位置更隐式和模糊，所以推荐使用import而不是from，虽然使用from也没什么太多可怕的后果。</li>
</ul>
</li>
</ol>
<h3 id="二、Module-Namespaces"><a href="#二、Module-Namespaces" class="headerlink" title="二、Module Namespaces"></a>二、Module Namespaces</h3><ol>
<li><p>模块命名空间</p>
<ul>
<li>理解模块的一种方式就是把它看作名称的封装；</li>
<li>模块就是命名空间，存在于一个模块内的名称被称为模块对象的属性。<ul>
<li>模块语句会在首次导入时执行：模块被导入时，python会建立空的模块对象，并逐一执行该模块文件内的语句；</li>
<li>顶层的赋值语句会创建模块属性：在导入时，文件顶层（即不在def与class之内）的赋值名称语句会建立对象的属性，存储在模块的命名空间里；</li>
<li>模块的命名空间可以通过属性<strong>dict</strong>会dir(M)获取；</li>
<li>模块是一个独立的作用域：模块文件的作用域在模块导入后就成为模块对象属性的命名空间。</li>
</ul>
</li>
<li>模块在首次导入，从头到尾执行语句：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># module2.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;starting to load...&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">name = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">klass</span>: <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;done loading.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module2</span><br></pre></td></tr></table></figure></li>
<li>模块被加载后，它的作用域就变成了返回的模块对象的一个属性命名空间：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(module2.sys)</span><br><span class="line"><span class="built_in">print</span>(module2.name)</span><br><span class="line"><span class="built_in">print</span>(module2.func)</span><br><span class="line"><span class="built_in">print</span>(module2.klass)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>命名空间字典：<strong>dict</strong></p>
<ul>
<li>在内部，模块命名空间被存储为字典对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(module2.__dict__.keys()))</span><br></pre></td></tr></table></figure></li>
<li>里面的<strong>file</strong>指明模块是从哪个文件加载，<strong>name</strong>指明导入者的名称。</li>
</ul>
</li>
<li><p>Attribute Name Qualification属性名称的点号运算<br><strong>qualification点号运算</strong> (a.k.a. attribute fetch属性获取) syntax object.attribute</p>
</li>
<li><p>导入vs作用域</p>
<ul>
<li>moda.py：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">88</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">global</span> X</span><br><span class="line">    X = <span class="number">99</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> moda </span><br><span class="line">moda.f() </span><br><span class="line"><span class="built_in">print</span>(X, moda.X)</span><br></pre></td></tr></table></figure></li>
<li>moda.f()修改了moda中的X，而不是这个文件的X。moda.f的全局作用域一定是所在文件；</li>
<li>一段代码的作用域完全由该代码在文件中所处的实际位置决定。作用域绝不会被函数调用或模块导入影响。</li>
</ul>
</li>
<li><p>命名空间的嵌套Namespace Nesting</p>
<ul>
<li>虽然导入不会使命名空间发送向上的嵌套，但确实会发生向下的嵌套。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mod3.py</span></span><br><span class="line">X = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mod2.py</span></span><br><span class="line">X = <span class="number">2</span></span><br><span class="line"><span class="keyword">import</span> mod3</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(mod3.X)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">1</span></span><br><span class="line"><span class="keyword">import</span> mod2 <span class="comment"># 打印出2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X, end=<span class="string">&#x27; &#x27;</span>) <span class="comment"># 打印1</span></span><br><span class="line"><span class="built_in">print</span>(mod2.X, end=<span class="string">&#x27; &#x27;</span>) <span class="comment"># 打印2</span></span><br><span class="line"><span class="built_in">print</span>(mod2.mod3.X) <span class="comment"># 打印3</span></span><br></pre></td></tr></table></figure></li>
<li>无法编写<code>import mod2.mod3</code>。这会启用包导入，在下一章介绍。</li>
</ul>
</li>
</ol>
<h3 id="三、Reloading-Modules"><a href="#三、Reloading-Modules" class="headerlink" title="三、Reloading Modules"></a>三、Reloading Modules</h3><ol>
<li><p>Reloading Modules</p>
<ul>
<li>要强制使模块代码重新载入并重新运行，要调用<code>reload内置函数</code>。</li>
</ul>
</li>
<li><p>reload基础</p>
<ul>
<li>reload是函数，不是语句；reload传入的参数是一个存在的模块对象；reload在python 3.X中位于模块之中，需要导入才能使用；</li>
<li>一般的用法是导入一个模块，在文本编辑器内修改其代码，然后将其重新加载；</li>
<li>当调用reload时，Python会重读模块文件的源代码，重新执行其顶层语句；</li>
<li>reload会在原位置修改模块对象，reload并不会删除并重新创建模块对象。<ul>
<li>reload会在模块当前命名空间内执行模块文件的新代码：覆盖其现有命名空间而不是删除重建；</li>
<li>文件中顶层赋值语句会将名称替换为新的值；</li>
<li>重新加载只会对以后使用from的用户程序造成影响，之前使用from来读取属性的程序不会受到重新加载影响；</li>
<li>重新加载会影响所以使用import读取了模块的用户程序；</li>
<li>重新加载只适用于单一的模块。</li>
</ul>
</li>
</ul>
</li>
<li><p>reload示例</p>
<ul>
<li>要用python解释器演示，上述函数打印出来后，不要关掉解释器，此时修改changer.py文件的代码，然后调用reload：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># changer.py</span></span><br><span class="line">message = <span class="string">&quot;First version&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printer</span>():</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> changer</span><br><span class="line">changer.printer()</span><br></pre></td></tr></table></figure>
修改后：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> reload</span><br><span class="line">reload(changer) <span class="comment"># reload会返回模块对象&lt;module &#x27;changer&#x27; from XXXXXXXXXX&gt;</span></span><br><span class="line">changer.printer() <span class="comment"># 这时候会显示修改后的结果</span></span><br></pre></td></tr></table></figure></li>
<li>除了在交互式命令行下重新加载模块外，模块重新加载在较大程序也十分有用，重新加载使程序能够提供高度动态的接口。</li>
</ul>
</li>
</ol>
<h2 id="chapter-24-Module-Packages"><a href="#chapter-24-Module-Packages" class="headerlink" title="chapter 24 Module Packages"></a>chapter 24 Module Packages</h2><h3 id="一、Package-Import-Basics"><a href="#一、Package-Import-Basics" class="headerlink" title="一、Package Import Basics"></a>一、Package Import Basics</h3><p>1、除了模块名之外，导入还可以指定目录路径</p>
<ul>
<li>Python代码的目录被称为<strong>包 package</strong>；</li>
<li>包导入是把目录变成Python命名空间，其属性对应目录中所包含的子目录和模块文件。</li>
</ul>
<p>2、包导入基础</p>
<ul>
<li><code>import dir1.dir2.mod</code> 或 <code>from dir1.dir2.mod import x</code></li>
<li>上述语句表明了dir1里有子目录dir2，dir2里包含mod.py</li>
</ul>
<p>3、包和搜索路径设置</p>
<ul>
<li>import语句中的目录路径只能是以点号间隔的变量，不能import C:\mycode\dir1\dir2\mod。</li>
</ul>
<p>4、__init__.py包文件</p>
<ul>
<li>如果选择使用包导入，包导入语句的路径中的<em>每个目录</em>都必须有__init__.py这个文件，否则包导入会失败；</li>
<li>也就是说上面dir1和dir2里都必须包含__init__.py文件，而容器目录dir0不需要__init__.py文件，dir0必须在模块搜索路径的sys.path列表中；</li>
<li>即dir0\dir1\dir2\mod.py 对应 import dir1.dir2.mod</li>
<li>__init__.py可以包含代码，也可以是空的；</li>
<li>它们的代码将在python第一次导入一个路径的时候被自动运行，所以可以被作为执行包的初始化的钩子。</li>
</ul>
<p>5、Package initialization file roles包初始化文件的角色</p>
<ul>
<li>__init__.py文件用作包初始化的钩子hook，将目录声明成一个Python包，替目录生成一个模块命名空间以及在目录导入时实现from* 语句</li>
<li>包的初始化：python在首次导入目录时，会自动执行该目录下__init__.py文件中的代码；</li>
<li>模块使用的声明：包的__init__.py文件即声明一个路径是Python的包；</li>
<li>模块命名空间的初始化：导入表达式dir1.dir2运行后，会返回一个模块对象，该对象的命名空间包含了dir2的__init__.py文件中赋值的所有名称；</li>
<li>from* 语句的行为：可以在__init__.py文件内定义__all__列表来规定目录以from*语句形式导入什么。__all__列表指包名称使用from*时，应该导入的子模块的名称清单。如果没有设定__all__，from*语句不会自动加载嵌套于该目录内的子模块。__init__.py可以是空白，但必须存在。</li>
</ul>
<h3 id="二、Package-Import-Example"><a href="#二、Package-Import-Example" class="headerlink" title="二、Package Import Example"></a>二、Package Import Example</h3><p>1、包导入示例</p>
<ul>
<li>在dir1和dir2文件夹里设置__init__.py文件：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dir1\__init__.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;dir1 init&#x27;</span>)</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dir1\dir2\__init__.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;dir2 init&#x27;</span>)</span><br><span class="line">y = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dir1\dir2\mod.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;in mod.py&#x27;</span>)</span><br><span class="line">z = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dir1.dir2.mod</span><br><span class="line"><span class="keyword">import</span> dir1.dir2.mod <span class="comment"># 第二次import不再执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> reload</span><br><span class="line">reload(dir1)</span><br><span class="line">reload(dir1.dir2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dir1)</span><br><span class="line"><span class="built_in">print</span>(dir1.dir2)</span><br><span class="line"><span class="built_in">print</span>(dir1.dir2.mod)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dir1.x)</span><br><span class="line"><span class="built_in">print</span>(dir1.dir2.y)</span><br><span class="line"><span class="built_in">print</span>(dir1.dir2.mod.z)</span><br></pre></td></tr></table></figure>
<p>2、包的from语句 vs 包的import语句<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dir1.dir2 <span class="keyword">import</span> mod</span><br><span class="line"><span class="built_in">print</span>(mod.z)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dir1.dir2.mod <span class="keyword">import</span> z</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dir1.dir2.mod <span class="keyword">as</span> mod</span><br><span class="line"><span class="built_in">print</span>(mod.z)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dir1.dir2.mod <span class="keyword">import</span> z <span class="keyword">as</span> modz</span><br><span class="line"><span class="built_in">print</span>(modz)</span><br></pre></td></tr></table></figure></p>
<p>3、 为什么使用包导入</p>
<ul>
<li>包导入提供了程序文件的目录信息；</li>
<li>包导入也可以简化PYTHONPATH和.pth文件搜索路径设置；</li>
<li>包能解决多个同名文件安装在同一个机器上所引发的模糊性。</li>
</ul>
<h3 id="三、Package-Relative-Imports"><a href="#三、Package-Relative-Imports" class="headerlink" title="三、Package Relative Imports"></a>三、Package Relative Imports</h3><p>1、包相对导入</p>
<ul>
<li>包内部导入同一个包中的内容时，可以使用和外部导入相同的完整路径语法，也可以利用特殊的包内搜索规则来简化import语句：</li>
<li>对于包中导入：<ul>
<li>默认跳过包自己的目录。导入只检查sys.path列表中的搜索路径。称为<strong>绝对导入</strong>：<code>import XX</code>；</li>
<li>from语句允许显式地要求导入只搜索包的目录（以点号开始）。称为<strong>相对导入</strong>：<code>from . import XX</code>。</li>
</ul>
</li>
</ul>
<p>2、相对导入基础知识</p>
<ul>
<li>from语句可以使用以点号开头的子句来导入位于同一包中的模块（包相对导入），而不是位于模块导入搜索路径上某处的模块（绝对导入）；</li>
<li>比如：<code>from . import spam</code> 即将文件相同包路径中名为spam的一个模块导入；</li>
<li>类似：<code>from .spam import name</code> 在文件所位于的包内，找到spam的模块并导入其中变量name；</li>
<li>而import string则总是在sys.path上的某处查找一个string模块，而不会查找该包中的同名模块，即绝对导入。</li>
<li>例：在一个名为mypkg的包目录下的一个模块文件：<ul>
<li><code>from .string import name1, name2</code> 即Imports names from mypkg.string；</li>
<li><code>from . import string</code> 即Imports mypkg.string；</li>
<li><code>from .. import string</code> 即从mypkg的父目录导入string模块。</li>
</ul>
</li>
<li><em>相对导入中的 “.” 用来表示包含当前文件的包目录；“..” 表示当前包的父目录的相对导入。</em><ul>
<li><code>from . import D</code> 即 Imports A.B.D (. means A.B)</li>
<li><code>from .. import E</code> 即 Imports A.E (.. means A)</li>
<li><code>from .D import X</code> 即 Imports A.B.D.X (. means A.B)</li>
<li><code>from ..E import X</code> 即 Imports A.E.X (.. means A)</li>
</ul>
</li>
</ul>
<p>3、相对导入的实际应用</p>
<ul>
<li>包外导入  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="built_in">print</span>(string)</span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码，如果当前工作目录下，没有string.py，则会导入标准库的string模块；</li>
<li>但是因为模块搜索路径的第一项就是当前工作目录（current working directory，CWD）。</li>
</ul>
</li>
<li>包内导入<ul>
<li>在pkg文件夹下设置空的__init__.py：  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># code\pkg\spam.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> eggs  <span class="comment"># import eggs会出错，因为import是绝对导入，会查找该包中的模块</span></span><br><span class="line"><span class="built_in">print</span>(eggs.X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># code\pkg\eggs.py</span></span><br><span class="line">X = <span class="number">99999</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="built_in">print</span>(string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pkg.spam</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>4、包相对导入的陷阱</p>
<ul>
<li>不能随意使用from . 的相对导入语法，除非发起导入的文件本身是包的一部分；</li>
<li>导入不会搜索一个包模块自身的路径，除非使用from . 的相对导入语法；</li>
<li>最好能使用完整包路径导入，即<code>from system.section.mypkg import mod</code>，来替代包相对导入或简单导入（import mode）</li>
<li>详见书720-724</li>
</ul>
<p>5、__name__ == “__main__“</p>
<ul>
<li>当一个模块作为顶级脚本被运行时，它的__name__属性的值是“__main__”字符串，但当它被导入却不是；</li>
<li>即<code>if __name__ == &quot;__main__&quot;</code>后的语句在被导入后不被执行。</li>
</ul>
<h3 id="四、Namespace-Packages"><a href="#四、Namespace-Packages" class="headerlink" title="四、Namespace Packages"></a>四、Namespace Packages</h3><p>1、命名空间包</p>
<ul>
<li>4种导入模型：<ul>
<li><strong>基础模块导入</strong>：<code>import mod</code>, <code>from mod import attr</code></li>
<li><strong>包导入</strong>：<code>import dir1.dir2.mod</code>, <code>from dir1.mod import attr</code></li>
<li><strong>包相对导入</strong>：<code>from . import mod</code> (相对), <code>import mod</code> (绝对)</li>
<li><strong>命名空间包</strong>：<code>import splitdir.mod</code>：运行包横跨多个目录，不需要<strong>init</strong>.py初始化文件。</li>
</ul>
</li>
<li>两种风格的包：<ul>
<li>原始的模型，现在称为<strong>常规包regular packages</strong>；</li>
<li>可选的模型，称为<strong>命名空间包namespace packages</strong>。</li>
</ul>
</li>
<li>命名空间包模型常常被作为一种后备选项进行使用。</li>
</ul>
<p>2、命名空间包的语义</p>
<ul>
<li>常规包必须拥有一个<strong>init</strong>.py文件，而且必须位于一个独立的目录里；</li>
<li>命名空间包可以横跨多个路径，这些路径在被导入时被收集；</li>
<li>所有能够成为一个命名空间包组成部分的目录都不能包含一个<strong>init</strong>.py文件，但是可以被嵌套在里面当作一个单独的包。</li>
</ul>
<p>3、命名空间包导入算法</p>
<ul>
<li>当对每个模块搜索路径中的directory搜索名为spam的被导入包时，python会按照下面的顺序测试一系列匹配条件：<ul>
<li>如果找到directory\spam\__init__.py，便会导入一个常规包并返回；</li>
<li>如果找到directory\spam.{py, pyc, or other module extension}，便会导入一个简单模块并返回；</li>
<li>如果找到文件夹directory\spam，便把它记录下来，而扫描将从搜索路径中的下一个目录继续；</li>
<li>如果上述的所有都没找到，扫描将从搜索路径中的下一个目录继续。</li>
</ul>
</li>
<li>如果搜索路径没有从上述步骤1和步骤2中返回一个模块或包，但在步骤3至少记录了一个路径，就会创建一个命名空间包；</li>
<li>python只会在一个模块或常规包被找到的时候，或者整个路径已经被完全扫描过以后才停止搜索；</li>
<li>命名空间包只有在整个过程中没有找到其他同名的模块、包或文件才会被返回；</li>
<li>在模块搜索路径上任意位置的模块文件和常规包都优先于命名空间包目录；</li>
<li>命名空间包的创建会立即发生，不会推迟到子层级的导入发生之时。新的命名空间包有一个__path__属性；</li>
<li>该属性被设置为在上述步骤3中扫描并记录的目录路径字符串的可迭代对象，但是没有<strong>file</strong>属性；</li>
<li>__path__属性在随后更深的访问过程中用于搜索所有包组件；</li>
<li>命名空间包是访问更低层次项目的“父路径”。</li>
</ul>
<p>4、对常规包的影响：可选的__init__.py</p>
<ul>
<li>如果一个单独目录包没有该文件，它将被当作一个单独目录命名空间包，而且不会引发任何警告；</li>
<li>同时，原始的常规包模型仍然支持，而且作为一个初始化钩子会自动运行__init__.py文件中的代码；</li>
<li>而且常规包有性能上的优势。</li>
</ul>
<p>5、命名空间包的实际应用</p>
<ul>
<li>在这一结构中，2个名为sub的子目录位于2个不同的父目录dir1和dir2中：<ul>
<li>C:\code\ns\dir1\sub\mod1.py</li>
<li>C:\code\ns\dir2\sub\mod2.py</li>
</ul>
</li>
<li>如果将dir1和dir2都添加进模块搜索路径，sub将成为一个横跨2个目录的命名空间包</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ns\dir1\sub\mod1.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;dir1\sub\mod1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ns\dir2\sub\mod2.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;dir2\sub\mod2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">r&#x27;XXXXX\\ns\\dir1&#x27;</span>)</span><br><span class="line">sys.path.append(<span class="string">r&#x27;XXXXX\\ns\\dir2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sub.mod1 <span class="comment"># 无错误，可以运行</span></span><br><span class="line"><span class="keyword">import</span> sub.mod2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sub.mod1)</span><br><span class="line"><span class="built_in">print</span>(sub.mod2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sub)</span><br><span class="line"><span class="built_in">print</span>(sub.__path__)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>相对导入也适用于命名空间包：</p>
<ul>
<li><p>可以把mod1里的代码改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> mod2</span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;dir1\sub\mod1&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样import sub.mod1会得到dir2\sub\mod2和dir1\sub\mod1。</p>
</li>
</ul>
</li>
</ul>
<p>6、命名空间包嵌套</p>
<ul>
<li>命名空间包支持任意嵌套，并成为低层级的“父路径”；</li>
<li>较低层的组件可以是一个模块、常规包也可以是另一个命名空间包。</li>
</ul>
<blockquote>
<p><strong>分界线（之前的笔记格式要调整）</strong></p>
</blockquote>
<h2 id="chapter-25-Advanced-Module-Topics"><a href="#chapter-25-Advanced-Module-Topics" class="headerlink" title="chapter 25 Advanced Module Topics"></a>chapter 25 Advanced Module Topics</h2><h3 id="一、Module-Design-Concepts"><a href="#一、Module-Design-Concepts" class="headerlink" title="一、Module Design Concepts"></a>一、Module Design Concepts</h3><p>1、模块设计概念</p>
<ul>
<li>在python中用户总是位于某个模块中，即使在交互式命令行下输入的代码实际上也存在于<em>__main__</em>的内置模块中；</li>
<li>最小化模块<em>耦合coupling</em>：全局变量，模块应该尽可能地独立于其他模块内使用的全局变量；</li>
<li>最大化模块<em>内聚cohesion</em>：统一的目标；</li>
<li>模块尽可能不去更改其他模块的变量；</li>
<li>模块不仅可以被导入，而且还可以导入和使用其他用python或者诸如C的其他语言编写的模块。</li>
</ul>
<p>2、使 * 的破坏最小化：<em>_X</em> 和 <em>__all__</em></p>
<ul>
<li>可以在名称前面加上下划线，防止导入时把名称复制出来，最小化对命名空间的破坏；</li>
<li><code>from *</code> 是复制出所有的名称；</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># unders.py</span></span><br><span class="line">a, _b, c, _d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unders <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(a, c)</span><br><span class="line"><span class="built_in">print</span>(_b) <span class="comment"># 会出现NameError</span></span><br></pre></td></tr></table></figure>
<ul>
<li>但 import 仍然可以获取并修改这类名称：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unders</span><br><span class="line"><span class="built_in">print</span>(unders._b)</span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过在模块顶层把变量名的字符串列表赋值给变量 <em>__all__</em> ，从而达到类似于 <em>_X</em> 命名惯例的隐藏效果；</li>
<li>使用此功能时，<code>from *</code> 语句只会把列在 <em>__all__ 列表</em>中的这些名称复制出来；</li>
<li><em>__all__</em> 是指明要复制的名称，而 <em>_X</em> 是指明不被复制的名称。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># alls.py</span></span><br><span class="line">__all__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;_c&#x27;</span>]</span><br><span class="line">a, b, _c, _d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> alls <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(a, _c)</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># 会出现NameError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> alls <span class="keyword">import</span> a, b, _c, _d</span><br><span class="line"><span class="built_in">print</span>(a, b, _c, _d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> alls</span><br><span class="line"><span class="built_in">print</span>(alls.a, alls.b, alls._c, alls._d)</span><br></pre></td></tr></table></figure>
<ul>
<li>就像 <em>_X</em> 一样，<em>__all__ 列表</em>只对 <code>from *</code> 语句有效；其他导入语句仍然能访问全部名称。</li>
</ul>
<p>3、启用未来语言特性：<em>__future__ 模块</em></p>
<ul>
<li>可以在Python 2.X中使用<code>from __future__ import featurename</code>来获取3.X的语言特性。</li>
</ul>
<h3 id="二、Built-in-Attribute-name"><a href="#二、Built-in-Attribute-name" class="headerlink" title="二、Built-in Attribute __name__"></a>二、Built-in Attribute __name__</h3><p>1、<em>__name__</em> 和 <em>__main__</em></p>
<ul>
<li>每个模块都有一个名为 <em>__name__</em> 的内置属性：<ul>
<li>如果文件作为顶层程序文件执行，在启动时 <em>__name__</em> 就会被设置为字符串<em>“__main__“</em>；</li>
<li>如果文件被导入， <em>__name__</em> 就会设为客户程序所了解的模块名。</li>
</ul>
</li>
</ul>
<p>2、混合使用模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># runme.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tester</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s Christmas in Heaven...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tester()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> runme <span class="comment"># 因为是导入，不是顶层文件执行，所以导入语句执行模块代码时，不直接调用函数</span></span><br><span class="line">runme.tester() <span class="comment"># 正常调用函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里的 <em>__name__</em> 允许模块被同时编写成一个可导入的库和一个顶层文件；</li>
<li>因为<code>if __name__ == &#39;__main__&#39;</code>后面是调用，不是定义函数或者 print ；</li>
<li>所以 <em>__name__</em> 可以用于自我测试，判断是在执行还是在导入。</li>
</ul>
<p>3、以 <em>__name__</em> 进行测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># minmax.py</span></span><br><span class="line"><span class="comment"># 直接执行minmax得到I am: __main__；1；6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am:&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minmax</span>(<span class="params">test, *args</span>):</span><br><span class="line">    res = args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> test(arg, res):</span><br><span class="line">            res = arg</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lessthan</span>(<span class="params">x, y</span>): <span class="keyword">return</span> x &lt; y</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grtrthan</span>(<span class="params">x, y</span>): <span class="keyword">return</span> x &gt; y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(minmax(lessthan, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="built_in">print</span>(minmax(grtrthan, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> minmax <span class="comment"># 得到I am: minmax</span></span><br><span class="line"><span class="built_in">print</span>(minmax.minmax(minmax.lessthan, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)) <span class="comment"># 得到&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="三、Other-Advanced-Module-related-Topics"><a href="#三、Other-Advanced-Module-related-Topics" class="headerlink" title="三、Other Advanced Module-related Topics"></a>三、Other Advanced Module-related Topics</h3><p>1、修改模块搜索路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sys.path.append(&#39;C:\\sourcedir&#39;)</code> 添加路径；</li>
<li><code>sys.path = [r&#39;d:\temp&#39;]</code> 修改路径；</li>
<li><code>sys.path.insert(0, &#39;..&#39;)</code> 插入路径；</li>
<li><code>sys.path</code>是暂时的，只存在于发生的 python 会话，修改不会被保留下来。</li>
</ul>
<p>2、 import 语句和 from 语句的<em> as 拓展</em></p>
<ul>
<li>重命名 import 的模块：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> reallylongmodulename <span class="keyword">as</span> name</span><br><span class="line">name.func()</span><br></pre></td></tr></table></figure>
<ul>
<li>同理 from 也可以：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> utility <span class="keyword">as</span> util1</span><br><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> utility <span class="keyword">as</span> util2</span><br><span class="line">util1(); util2()</span><br></pre></td></tr></table></figure>
<p>3、用名称字符串导入模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">import</span> X</span><br></pre></td></tr></table></figure>
<ul>
<li>这样代码会尝试导入 X.py ，而不是 string 模块。</li>
<li>要用<code>exec内置函数</code>解决， <em>exec</em> 会编译代码字符串，传给解释器执行：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">modname = <span class="string">&#x27;minmax&#x27;</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;import &#x27;</span> + modname)</span><br></pre></td></tr></table></figure>
<ul>
<li>或者用内置的<code>__import__函数</code>，但是这个函数返回模块对象：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">modname = <span class="string">&#x27;minmax&#x27;</span></span><br><span class="line">minmax = <span class="built_in">__import__</span>(modname)</span><br><span class="line"><span class="built_in">print</span>(minmax)</span><br></pre></td></tr></table></figure>
<ul>
<li>或者用<code>importlib.import_module</code>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line">modname = <span class="string">&#x27;minmax&#x27;</span></span><br><span class="line">minmax = importlib.import_module(modname)</span><br><span class="line"><span class="built_in">print</span>(minmax)</span><br></pre></td></tr></table></figure>
<h3 id="四、Module-Gotchas"><a href="#四、Module-Gotchas" class="headerlink" title="四、Module Gotchas"></a>四、Module Gotchas</h3><p>1、模块名称冲突：包和包相对导入</p>
<ul>
<li>如果有2个同名模块，默认情况下， python 总是选择搜索路径 <em>sys.path</em> 中最左边的那一项，要么避免这问题，要么使用包导入功能。</li>
</ul>
<p>2、顶层代码中语句次序很重要</p>
<ul>
<li>当模块被导入（或重载）， python 会从头到尾执行它的代码语句。</li>
</ul>
<p>3、from 复制名称，而不是链接，和 import 不太一样</p>
<ul>
<li>import 是将模块对象赋值到名称。</li>
</ul>
<p>4、reload 不能作用于 from 导入</p>
<ul>
<li>因为 from 是复制，不会链接到名称所在模块，所以重载无效。</li>
</ul>
<p>5、递归形式的 from 导入可能无法工作</p>
<ul>
<li>相互导入的模块，称为<em>递归导入 recursive imports</em>；</li>
<li>用 from 可能会导致递归不会实际发生，有可能在导入时，名称尚不存在，用 import 可能没什么影响。</li>
</ul>
<h1 id="PART-VI-Classes-and-OOP"><a href="#PART-VI-Classes-and-OOP" class="headerlink" title="PART VI Classes and OOP"></a>PART VI Classes and OOP</h1><h2 id="chapter-26-OOP-The-Big-Picture"><a href="#chapter-26-OOP-The-Big-Picture" class="headerlink" title="chapter 26 OOP: The Big Picture"></a>chapter 26 OOP: The Big Picture</h2><h3 id="一、OOP-and-Class"><a href="#一、OOP-and-Class" class="headerlink" title="一、OOP and Class"></a>一、OOP and Class</h3><p>1、<em>类 Classes</em> 是<em>面向对象程序设计 object-oriented programming (OOP)</em> 的主要工具</p>
<ul>
<li>类支持<strong>继承 inheritance</strong> ，一种代码定制和复用的机制，真正的OOP，对象需要有继承层次。</li>
</ul>
<p>2、类 Classes</p>
<ul>
<li><em>多重实例 Multiple instances</em><ul>
<li>类是产生对象的工厂。每当调用类，就会产生一个带有独立命名空间的新对象，该对象可以读取类的属性，并用自己的命名空间来存储数据；</li>
</ul>
</li>
<li><em>通过继承进行定制 Customization via inheritance</em><ul>
<li>可以在类的外部以编写子类的方式，来重新定义其属性进而扩充类；</li>
</ul>
</li>
<li><em>运算符重载 Operator overloading</em><ul>
<li>python 提供了一些可以让类使用的钩子，从而能够拦截并实现任何的内置类型运算。</li>
</ul>
</li>
</ul>
<p>3、属性继承搜索</p>
<ul>
<li><code>object.attribute</code></li>
<li>当对 class 语句产生的对象使用上述表达式时，会启用一次搜索，搜索对象连接的类树；</li>
<li>即：找到 attribute 首次出现的地方，先搜索 object ，然后是该对象上的所有类，由下往上；</li>
<li><em>属性访问就是搜索类树，这种搜索即继承</em>，因为树中较低位置的对象继承了较高位置的对象的所有属性；</li>
<li>树中较高位置的类称为<strong>父类 superclass</strong>，较低位置称为<strong>子类 subclass</strong>；父类提供了所有子类共享的行为，子类可以重新定义父类的名称，从而覆盖父类定义的行为。</li>
</ul>
<p>4、编写类树</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>: ... <span class="comment"># 创建父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span>: ... <span class="comment"># 创建父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>(C2, C3): ... <span class="comment"># 继承父类，括号内从左到右的顺序决定了树中次序</span></span><br><span class="line"></span><br><span class="line">I1 = C1() <span class="comment"># 类调用，创建实例</span></span><br><span class="line">I2 = C1()</span><br></pre></td></tr></table></figure>
<ul>
<li>类的属性是在 class 语句的顶层语句块中通过赋值语句添加到类的；</li>
<li>属性是通过 <strong>self</strong> 的赋值，来附加给实例的。 <strong>self</strong> 提供了被处理的实例的引用；</li>
<li>类通过方法函数为实例提供行为（即 class 里的 def 语句）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>: ... </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span>: ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>(C2, C3):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setname</span>(<span class="params">self, who</span>):</span><br><span class="line">        self.name = who</span><br><span class="line"></span><br><span class="line">I1 = C1()</span><br><span class="line">I2 = C1()</span><br><span class="line"></span><br><span class="line">I1.setname(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">I2.setname(<span class="string">&#x27;sue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(I1.name)</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的代码，直到 setname 调用前，C1 类都不会把 name 属性附加到实例上。</li>
<li><code>__init__方法</code>（又称为<strong>构造函数</strong>），如果没有<code>__init__方法</code>，类调用将返回一个空实例，而不会将其初始化：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>: ... </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span>: ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>(C2, C3):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, who</span>):</span><br><span class="line">        self.name = who</span><br><span class="line"></span><br><span class="line">I1 = C1(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">I2 = C1(<span class="string">&#x27;sue&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(I1.name)</span><br></pre></td></tr></table></figure>
<p>5、在很多应用领域，可以获取或购买父类的集合，即软件框架 framework<br>这些软件框架可能提供一些数据库接口、测试协议、GUI工具包等</p>
<h2 id="chapter-27-Class-Coding-Basics"><a href="#chapter-27-Class-Coding-Basics" class="headerlink" title="chapter 27 Class Coding Basics"></a>chapter 27 Class Coding Basics</h2><h3 id="一、Classes-Generate-Multiple-Instance-Objects"><a href="#一、Classes-Generate-Multiple-Instance-Objects" class="headerlink" title="一、Classes Generate Multiple Instance Objects"></a>一、Classes Generate Multiple Instance Objects</h3><p>1、类对象和实例对象</p>
<ul>
<li><em>类对象 class objects</em> 提供默认行为，<em>实例对象 instance objects</em> 是程序处理的实际对象；</li>
<li>class 语句创建类并赋值给一个名称，class 语句内的赋值语句会创建类的属性；</li>
<li>类属性提供了对象的<strong>状态信息</strong>和<strong>行为</strong>；</li>
<li>调用类对象会创建实例对象，每个实例对象继承了类的属性并获得了自己的命名空间；</li>
<li>在方法内对 self 属性做赋值运算会产生每个实例自己的属性。</li>
</ul>
<p>2、第一个示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setdata</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data)</span><br><span class="line"></span><br><span class="line">x = FirstClass() <span class="comment"># 调用产生实例</span></span><br><span class="line">y = FirstClass()</span><br><span class="line">x.setdata(<span class="string">&quot;King Arthur&quot;</span>)</span><br><span class="line">y.setdata(<span class="number">3.14159</span>)</span><br><span class="line"></span><br><span class="line">x.display()</span><br><span class="line">y.display()</span><br></pre></td></tr></table></figure>
<ul>
<li>类中的函数称为<strong>方法 methods</strong> ；</li>
<li>setdata 函数中，传入的值会赋给 self.data 。 self 会自动引用当前处理的实例，所以赋值语句会把值存储在实例的命名空间；</li>
<li>可以修改实例属性：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.data = <span class="string">&quot;New value&quot;</span></span><br><span class="line">x.display()</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以在类方法函数外，在实例命名空间内产生全新的属性（很少见，不常用）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.anothername = <span class="string">&quot;spam&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x.anothername)</span><br></pre></td></tr></table></figure>
<h3 id="二、Classes-Are-Customized-by-Inheritance"><a href="#二、Classes-Are-Customized-by-Inheritance" class="headerlink" title="二、Classes Are Customized by Inheritance"></a>二、Classes Are Customized by Inheritance</h3><p>1、类产生的实例对象继承类的属性。也可以让类继承其他类。</p>
<ul>
<li>父类列在 class 语句头部的括号里；</li>
<li>类从其父类中继承属性；</li>
<li>实例会继承所有可访问类的属性；</li>
<li>每个 object.attribute 引用都会启动一个独立的搜索；</li>
<li>逻辑的修改是通过创建子类，而不是修改父类。</li>
</ul>
<p>2、第二个示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setdata</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondClass</span>(<span class="title class_ inherited__">FirstClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>): <span class="comment"># Changes display</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Current value = &quot;%s&quot;&#x27;</span> % self.data)</span><br></pre></td></tr></table></figure>
<ul>
<li>继承搜索会从实例往上进行，首先到子类，然后到父类；</li>
<li>所以 SecondClass 覆盖了 FirstClass 中的 display ，有时称这种重新定义取代属性的动作为<em>重载 overloading</em> ：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = SecondClass()</span><br><span class="line">z.setdata(<span class="number">42</span>) <span class="comment"># FirstClass的setdata</span></span><br><span class="line">z.display()</span><br></pre></td></tr></table></figure>
<p>3、类是模块内的属性</p>
<ul>
<li>若 FirstClass 从其他模块导入：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modulename <span class="keyword">import</span> FirstClass</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondClass</span>(<span class="title class_ inherited__">FirstClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>): ...</span><br></pre></td></tr></table></figure>
<ul>
<li>或者，其等效写法如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> modulename</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondClass</span>(modulename.FirstClass):   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>): ...</span><br></pre></td></tr></table></figure>
<h3 id="三、Classes-Can-Intercept-Python-Operators"><a href="#三、Classes-Can-Intercept-Python-Operators" class="headerlink" title="三、Classes Can Intercept Python Operators"></a>三、Classes Can Intercept Python Operators</h3><p>1、<strong>运算符重载</strong>，即让类编写的对象，截获并响应用在内置类型上的运算：加法、切片、打印和点号运算等，运算符重载能让对象拥有内置对象那样的行为。</p>
<ul>
<li>以双下划线命名的方法（<em>__X__</em>）是特殊钩子，来拦截运算；</li>
<li>当实例出现在内置运算中，这类方法会自动被调用；</li>
<li>类可以重载绝大多数内置类型运算；</li>
<li>默认的运算符不存在，如果类没有定义或继承运算符重载方法，那么类的实例将不能支持相应运算；</li>
<li>新式类有一些默认的运算符重载方法。新式类见后面；</li>
<li>运算符将类与对象模型结合到一起，让类获得与内置对象一样的行为；</li>
<li>运算符重载主要被 Python 工具开发人员使用，而不是应用程序开发人员。所以不应被随意使用；</li>
<li>但是<code>__init__方法</code>，几乎每个类都会用到，也称为构造函数方法，用于初始化对象状态。</li>
</ul>
<p>2、第三个示例</p>
<ul>
<li><code>__init__</code>会在创建实例时被调用： self 是新的 ThirdClass 对象；<code>__add__</code>会在 ThirdClass 实例出现在 + 表达式时被调用；<code>__str__</code>会在打印对象时被调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setdata</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondClass</span>(<span class="title class_ inherited__">FirstClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>): <span class="comment"># Changes display</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Current value = &quot;%s&quot;&#x27;</span> % self.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdClass</span>(<span class="title class_ inherited__">SecondClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> ThirdClass(self.data + other)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[ThirdClass: %s]&#x27;</span> % self.data</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">self, other</span>):</span><br><span class="line">        self.data *= other</span><br><span class="line"></span><br><span class="line">a = ThirdClass(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">a.display()</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># __str__: returns display string</span></span><br><span class="line"></span><br><span class="line">b = a + <span class="string">&#x27;xyz&#x27;</span> <span class="comment"># __add__: makes a new instance。实例对象a传给了__add__中的self，右侧传给了other</span></span><br><span class="line">b.display()</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line">a.mul(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<h3 id="四、The-World’s-Simplest-Python-Class"><a href="#四、The-World’s-Simplest-Python-Class" class="headerlink" title="四、The World’s Simplest Python Class"></a>四、The World’s Simplest Python Class</h3><p>1、最简单的类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rec</span>: <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以在 class 语句外，通过赋值变量名给这个类增加属性：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Rec.name = <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">Rec.age = <span class="number">40</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时创建实例，会继承附加在类上的属性：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = Rec()</span><br><span class="line">y = Rec()</span><br><span class="line"><span class="built_in">print</span>(x.name, y.name)</span><br></pre></td></tr></table></figure>
<ul>
<li>可以再对实例对象赋值属性，因为属性引用会启动继承搜索，所以实例会先获得实例属性：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.name = <span class="string">&#x27;Sue&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(Rec.name, x.name, y.name)</span><br></pre></td></tr></table></figure>
<ul>
<li>命名空间对象的属性通常以字典形式实现的，类继承树就是互相连接的字典，详见第29章。</li>
<li><code>__dict__属性</code>是大多数基于类的对象的命名空间字典：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(Rec.__dict__.keys()))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(name <span class="keyword">for</span> name <span class="keyword">in</span> Rec.__dict__ <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(x.__dict__.keys()))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(y.__dict__.keys()))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__class__</code>代表实例指向其类的链接：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(x.__class__)</span><br></pre></td></tr></table></figure>
<ul>
<li>类也有个<code>__bases__属性</code>，它是其父类对象引用的元组，在这里是隐含的 object 根类：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(Rec.__bases__)</span><br></pre></td></tr></table></figure>
<p>2、python的类模型是相当动态的</p>
<ul>
<li>类和实例只是<em>命名空间对象</em>，可以在任何地方使用它们的属性；</li>
<li>方法也可以独立地创建在任意类对象的外部：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">uppername</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">return</span> obj.name.upper()</span><br></pre></td></tr></table></figure>
<ul>
<li>只要传入一个带 name 属性（该属性自带有 upper 方法）的 obj 对象就可以调用</li>
<li>x 这个类实例适合 uppername 的接口：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(uppername(x))</span><br></pre></td></tr></table></figure>
<ul>
<li>我们也可以把函数赋值成类的属性，该函数就变成了类的方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Rec.method = uppername</span><br><span class="line"><span class="built_in">print</span>(x.method())</span><br><span class="line"><span class="built_in">print</span>(y.method())</span><br><span class="line"><span class="built_in">print</span>(Rec.method(x))</span><br></pre></td></tr></table></figure>
<h2 id="chapter-28-A-More-Realistic-Example"><a href="#chapter-28-A-More-Realistic-Example" class="headerlink" title="chapter 28 A More Realistic Example"></a>chapter 28 A More Realistic Example</h2><h3 id="一、Example-of-Classes"><a href="#一、Example-of-Classes" class="headerlink" title="一、Example of Classes"></a>一、Example of Classes</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># person.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="comment"># 步骤1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, job=<span class="literal">None</span>, pay=<span class="number">0</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastName</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">return</span> self.name.split()[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent</span>):</span><br><span class="line">        self.pay = <span class="built_in">int</span>(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤3</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[Person: %s, %s]&#x27;</span> % (self.name, self.pay)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤4</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="comment"># 步骤5</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, pay</span>):</span><br><span class="line">        Person.__init__(self, name, <span class="string">&#x27;mgr&#x27;</span>, pay)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤4</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent, bonus=<span class="number">.10</span></span>):</span><br><span class="line">        Person.giveRaise(self, percent + bonus) <span class="comment"># 也可以复制父类的代码self.pay = int(self.pay * (1 + percent + bonus))，坏处就是修改代码就需要修改2次了</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤1</strong>：创建实例</p>
<ul>
<li>实例对象属性在类方法函数中的 self 属性赋值来创建。常见方法是在<em>__init__构造函数方法</em>中赋值给 self ；</li>
<li>self 就是新创建的实例对象。job 参数是 <em>__init__</em> 函数作用域里的一个局部变量，而 self.job 是实例的一个属性；</li>
<li><code>self.job = job</code> 就是把局部 job 赋给 self.job 属性。</li>
<li>生成几个实例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> Person</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>, job=<span class="string">&#x27;dev&#x27;</span>, pay=<span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name, bob.pay)</span><br><span class="line"><span class="built_in">print</span>(sue.name, sue.pay)</span><br></pre></td></tr></table></figure>
<p><strong>步骤2</strong>：添加行为方法</p>
<ul>
<li><strong>封装encapsulation</strong>：封装思想就是把操作逻辑包装到接口之后；</li>
<li>把操作对象的代码编写到类方法，即封装的一种方式：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bob.lastName(), sue.lastName())</span><br><span class="line">sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line"><span class="built_in">print</span>(sue.pay)</span><br></pre></td></tr></table></figure>
<p><strong>步骤3</strong>：运算符重载</p>
<ul>
<li>排在 <em>__init__</em> 之后第二常用的运算符重载 <em>__repr__</em> ，以及 <em>__str__</em> ；</li>
<li>打印对象会显示该对象的 <em>__str__</em> 或 <em>__repr__</em> 方法所返回的内容；</li>
<li>这2者被用在不同的上下文实现不同的显示，但是只编写 <em>__repr__</em> 足以支持几乎所有的场景：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bob)</span><br><span class="line"><span class="built_in">print</span>(sue)</span><br></pre></td></tr></table></figure>
<p><strong>步骤4</strong>：通过编写子类定制行为</p>
<ul>
<li>编写名为 Manager 的子类：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> Manager</span><br><span class="line">tom = Manager(<span class="string">&#x27;Tom Jones&#x27;</span>, <span class="number">50000</span>)</span><br><span class="line">tom.giveRaise(<span class="number">.10</span>)</span><br><span class="line"><span class="built_in">print</span>(tom.lastName())</span><br><span class="line"><span class="built_in">print</span>(tom)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>super内置函数</code>也可以调用父类，详见第32章。</li>
<li>多态的应用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--All three--&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> (bob, sue, tom):</span><br><span class="line">    obj.giveRaise(<span class="number">.10</span>)</span><br><span class="line">    <span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure>
<ul>
<li>对象可能是一个 Person 或 Manager ，而 Python 自动运行相应的 giveRaise ，这就是 Python 中的多态概念</li>
</ul>
<p><strong>步骤5</strong>：定制构造函数</p>
<ul>
<li>为 Manager 定制构造函数，初始化对象的状态信息属性。</li>
<li>组合类 Combine Classes 的其他方式</li>
<li><code>__getattr__运算符重载方法</code>，能拦截未定义属性的访问并把这些访问委托给一个带有 getattr 内置调用的内嵌对象，详见第30章。第31章将讨论组合 composition 的设计问题。</li>
</ul>
<p><strong>步骤6</strong>：使用<em>内省工具 Introspection</em></p>
<ul>
<li>Python 的内省工具允许我们访问对象实现的内部机制的一些特殊属性和函数，语言框架工具的开发者会比应用程序开发者更广泛地使用它们：<ul>
<li>内置的 <em>instance.__class__ 属性</em>提供了一个从实例到创建它的类的链接。同时类还有个 <em>__name__</em> ，还有一个 <em>__base__</em> 序列来提供父类的访问；</li>
<li>内置的 <em>object.__dict__</em> 属性提供了一个字典，将所有命名空间对象中的属性都存储为键值对。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob)</span><br><span class="line"><span class="built_in">print</span>(bob.__class__)</span><br><span class="line"><span class="built_in">print</span>(bob.__class__.__name__)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(bob.__dict__.keys()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> bob.__dict__:</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;=&gt;&#x27;</span>, bob.__dict__[key])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> bob.__dict__:</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;=&gt;&#x27;</span>, <span class="built_in">getattr</span>(bob, key))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(bob))</span><br></pre></td></tr></table></figure>
<p><strong>步骤7</strong>：把对象存储到数据库中</p>
<ul>
<li>我们关闭 python ，实例会消失，因为它是内存中临时性对象；</li>
<li>因为应用程序往往需要永久性改变，所以需要把对象持久化 object persistence/permanence；<ul>
<li><code>pickle 模块</code>：实现任意 python 对象与字节串之间的序列化和解序列化；</li>
<li><code>dbm 模块</code>：实现一个通过键访问的文件系统，以存储字节串；</li>
<li><code>shelve 模块</code>：使用以上2个模块，按照键把 Python 对象存储到一个文件中；</li>
<li>shelve 使用 pickle 把一个对象转换为其 pickle 化的字节串，并将其存储在一个 dbm 文件中的键之下；pickle：腌制、酸菜 shelve：搁置。</li>
</ul>
</li>
<li>在 shelve 数据库中存储对象，详见 makedb.py ：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># makedb.py</span></span><br><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> Person, Manager</span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>, job=<span class="string">&#x27;dev&#x27;</span>, pay=<span class="number">100000</span>)</span><br><span class="line">tom = Manager(<span class="string">&#x27;Tom Jones&#x27;</span>, <span class="number">50000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">db = shelve.<span class="built_in">open</span>(<span class="string">&#x27;persondb&#x27;</span>) <span class="comment"># Filename where objects are stored</span></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> (bob, sue, tom): <span class="comment"># 把对象的名称用做键，把它们赋给shelve</span></span><br><span class="line">    db[obj.name] = obj</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<ul>
<li>交互式地探索 shelve ：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">db = shelve.<span class="built_in">open</span>(<span class="string">&#x27;persondb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(db))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(db.keys()))</span><br><span class="line"></span><br><span class="line">bob = db[<span class="string">&#x27;Bob Smith&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(bob)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bob.lastName())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> db:</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;=&gt;&#x27;</span>, db[key]) <span class="comment"># db[key]即对应的对象，打印出来就是运行了__repr__方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(db):</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;=&gt;&#x27;</span>, db[key])</span><br></pre></td></tr></table></figure>
<ul>
<li>以上代码即导入了实例对象，并且将 bob 连接到它。</li>
<li>更新 shelve 中的对象：<ul>
<li>编写一个程序，在每次运行的时候都更新一个实例，以证实对象是持久的，即每次运行时，它们当前的值都是可用的，详见 updatedb.py ：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># updatedb.py</span></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">db = shelve.<span class="built_in">open</span>(<span class="string">&#x27;persondb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(db):</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;\t=&gt;&#x27;</span>, db[key])</span><br><span class="line"></span><br><span class="line">sue = db[<span class="string">&#x27;Sue Jones&#x27;</span>]</span><br><span class="line">sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">db[<span class="string">&#x27;Sue Jones&#x27;</span>] = sue</span><br><span class="line">db.close()</span><br><span class="line"><span class="comment"># 每次运行都会永久改变 sue 的工资，可以证明对象的持久化。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果要了解 pickle 和 shelve 的更多细节，见官方手册。</li>
</ul>
<h2 id="chapter-29-Class-Coding-Details"><a href="#chapter-29-Class-Coding-Details" class="headerlink" title="chapter 29 Class Coding Details"></a>chapter 29 Class Coding Details</h2><h3 id="一、The-class-Statement"><a href="#一、The-class-Statement" class="headerlink" title="一、The class Statement"></a>一、The class Statement</h3><p>1、Class 语句是对象的创建者并且是一个隐含的赋值运算：当它执行时产生类对象，并把其引用值存储到前面所使用的名称中</p>
<ul>
<li>class语句的一般形式：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">name</span>(superclass,...):</span><br><span class="line">    attr = value </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self,...</span>):</span><br><span class="line">        self.attr = value</span><br></pre></td></tr></table></figure>
<p>2、示例</p>
<ul>
<li>当 python 执行 class 语句时，会从头到尾执行其主体内语句；</li>
<li>在 class 语句中的赋值语句所创建的名称，位于 class 的局部作用域中，会成为类对象中的属性。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedData</span>:</span><br><span class="line">    spam = <span class="number">42</span></span><br><span class="line">    <span class="built_in">print</span>(spam)</span><br><span class="line"></span><br><span class="line">x = SharedData()</span><br><span class="line">y = SharedData()</span><br><span class="line"><span class="built_in">print</span>(x.spam, y.spam)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>可以通过类名称修改类属性</em></strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SharedData.spam = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(x.spam, y.spam, SharedData.spam)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><em>对实例对象赋值修改实例属性</em></strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.spam = <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(x.spam, y.spam, SharedData.spam)</span><br></pre></td></tr></table></figure>
<ul>
<li>以下例子能更好解释这种把同一名称存储在两个位置的行为：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MixedNames</span>:</span><br><span class="line">    data = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data, MixedNames.data)</span><br><span class="line"></span><br><span class="line">x = MixedNames(<span class="number">1</span>)</span><br><span class="line">y = MixedNames(<span class="number">2</span>)</span><br><span class="line">x.display(); y.display()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> spam</span><br><span class="line"><span class="number">2</span> spam</span><br></pre></td></tr></table></figure>
<ul>
<li>data 位于 2 个地方：在实例对象内（由 __init__ 中的 self.data 赋值运算所创建以及在实例继承的类中（由类中的data赋值运算所创建）</li>
</ul>
<h3 id="二、Methods"><a href="#二、Methods" class="headerlink" title="二、Methods"></a>二、Methods</h3><p>1、在一个类方法中，第一位参数为 self 。这个参数给方法提供了一个钩子 hook ，从而返回调用的主体，即<strong>实例对象</strong>。</p>
<ul>
<li>这个名称的存在是为了明确脚本中使用的是实例的属性名称，而不是局部作用域或全局作用域中的名称。</li>
</ul>
<p>2、示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NextClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printer</span>(<span class="params">self, text</span>):</span><br><span class="line">        self.message = text</span><br><span class="line">        <span class="built_in">print</span>(self.message)</span><br><span class="line"></span><br><span class="line">x = NextClass()</span><br><span class="line">x.printer(<span class="string">&#x27;instance call&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x.message)</span><br></pre></td></tr></table></figure>
<ul>
<li>当对实例进行点号运算来调用它时，printer 会先通过继承进行定位，然后它的 self 参数会被自动赋值为实例对象；</li>
<li>text 参数会得到在调用时传入的字符串（’instance call’）；</li>
<li><em>方法能通过实例或类本身2种方式的任意一种进行调用</em>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">NextClass.printer(x, <span class="string">&#x27;class call&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x.message)</span><br></pre></td></tr></table></figure>
<h3 id="三、Inheritance"><a href="#三、Inheritance" class="headerlink" title="三、Inheritance"></a>三、Inheritance</h3><p>1、在 Python 中，当对对象进行点号运算时就会触发继承，以及搜索属性定义树，即在一个或多个相互链接的命名空间中搜索</p>
<ul>
<li>实例属性是由对方法内的 self 属性进行赋值运算产生的；</li>
<li>类属性是通过 class 语句内的语句创建的；</li>
<li>父类的连接是通过 class 语句首行的括号内列出的类而产生的；</li>
<li>结果就是连接实例的属性命名空间树，到产生它的类、再到类首行中列出的所有父类。</li>
</ul>
<p>2、子类可以完全替代继承的属性，也可以拓展父类方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;in Super.method&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Super</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;starting Sub.method&#x27;</span>)</span><br><span class="line">        Super.method(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ending Sub.method&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>这类 sub 替代了 super 的方法，同时又调用了 super 的方法，即拓展：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = Super()</span><br><span class="line">x.method()</span><br><span class="line"></span><br><span class="line">x = Sub()</span><br><span class="line">x.method()</span><br></pre></td></tr></table></figure>
<p>3、抽象父类 Abstract Superclasses</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delegate</span>(<span class="params">self</span>):</span><br><span class="line">        self.action()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Provider</span>(<span class="title class_ inherited__">Super</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">action</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;in Provider.action&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = Provider()</span><br><span class="line">x.delegate()</span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码的调用 delegate 方法时，会发生 2 次独立的继承搜索：<ul>
<li>x.delegate 调用时，python 会搜索 Provider 实例和类树中更上层的类对象，直到 Super 中找到 delegate ，实例 x 传给该方法的 self 参数；</li>
<li>在 Super.delegate 方法中， self.action 会对 self 以及它上层的对象发起另一次继承搜索。因为 self 引用了一个 Provider 实例，所以 action 方法会在 Provider 子类中找到；</li>
</ul>
</li>
<li>这个例子中的父类有时被称为<strong>抽象父类 abstract superclass</strong>，即类的部分行为预期由其子类来提供；</li>
<li>如果所预期的方法没有在子类中定义，那么当继承搜索失败时， python 会引发名称未定义的异常。</li>
</ul>
<h3 id="四、Namespaces-The-Conclusion"><a href="#四、Namespaces-The-Conclusion" class="headerlink" title="四、Namespaces: The Conclusion"></a>四、Namespaces: The Conclusion</h3><p>1、<strong>命名空间 Namespaces</strong>与<strong>作用域 Scopes</strong></p>
<ul>
<li>带点号和无点号的名称采用不同的处理方式；</li>
<li>无点号运算的名称( X )对应于作用域；</li>
<li>带点号的属性名( object.X )使用的是对象的命名空间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    X = <span class="number">22</span></span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    X = <span class="number">33</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m</span>(<span class="params">self</span>):</span><br><span class="line">        X = <span class="number">44</span></span><br><span class="line">        <span class="built_in">print</span>(X)</span><br><span class="line">        self.X = <span class="number">55</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码产生了5个 X 变量：模块属性（11）、函数内的局部变量（22）、类属性（33）、方法中的局部变量（44）以及实例属性（55）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">f()</span><br><span class="line">g()</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line">obj = C()</span><br><span class="line"><span class="built_in">print</span>(obj.X)</span><br><span class="line"></span><br><span class="line">obj.m()</span><br><span class="line"><span class="built_in">print</span>(obj.X)</span><br><span class="line"><span class="built_in">print</span>(C.X)</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">44</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure>
<p>2、嵌套的类：重温 LEGB 作用域规则</p>
<p>（1）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nester</span>():</span><br><span class="line">    <span class="built_in">print</span>(X)                         <span class="comment"># Global: 1</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">        <span class="built_in">print</span>(X)                     <span class="comment"># Global: 1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method1</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(X)                 <span class="comment"># Global: 1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method2</span>(<span class="params">self</span>):</span><br><span class="line">            X = <span class="number">3</span></span><br><span class="line">            <span class="built_in">print</span>(X)                 <span class="comment"># Local: 3</span></span><br><span class="line">    I = C()</span><br><span class="line">    I.method1()</span><br><span class="line">    I.method2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">nester()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<p>（2）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nester</span>():</span><br><span class="line">    X = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(X)                         <span class="comment"># Local: 2</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">        <span class="built_in">print</span>(X)                     <span class="comment"># In enclosing def (nester): 2</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method1</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(X)                 <span class="comment"># In enclosing def (nester): 2</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method2</span>(<span class="params">self</span>):</span><br><span class="line">            X = <span class="number">3</span></span><br><span class="line">            <span class="built_in">print</span>(X)                 <span class="comment"># Local: 3</span></span><br><span class="line">    I = C()</span><br><span class="line">    I.method1()</span><br><span class="line">    I.method2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">nester()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<p>（3）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nester</span>():</span><br><span class="line">    X = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(X)                        <span class="comment"># Local: 2</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">        X = <span class="number">3</span></span><br><span class="line">        <span class="built_in">print</span>(X)                    <span class="comment"># Local: 3</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method1</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(X)                <span class="comment"># In enclosing def (not 3 in class!): 2</span></span><br><span class="line">            <span class="built_in">print</span>(self.X)           <span class="comment"># Inherited class local: 3</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method2</span>(<span class="params">self</span>):</span><br><span class="line">            X = <span class="number">4</span></span><br><span class="line">            <span class="built_in">print</span>(X)                <span class="comment"># Local: 4</span></span><br><span class="line">            self.X = <span class="number">5</span></span><br><span class="line">            <span class="built_in">print</span>(self.X)           <span class="comment"># Located in instance: 5</span></span><br><span class="line">    I = C()</span><br><span class="line">    I.method1()</span><br><span class="line">    I.method2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">nester()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<p>上面3个运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">----------------------------------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">----------------------------------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure>
<ul>
<li>像 X 这样简单名称的查找规则从来不会搜索外层 class 语句，只搜索 def 语句、模块和内置的；</li>
<li>是 LEGB 规则，不是 CLEGB ！！</li>
<li>所以在 method1 中， X 在位于其外层类外部的 def 语句中被找到；</li>
<li>想要访问类中被赋值的名称，必须将其作为类对象或者实例对象的属性来获取。</li>
</ul>
<h3 id="五、Namespace-Dictionaries-Review"><a href="#五、Namespace-Dictionaries-Review" class="headerlink" title="五、Namespace Dictionaries: Review"></a>五、Namespace Dictionaries: Review</h3><p>1、命名空间字典</p>
<ul>
<li>如同模块的命名空间，类对象和实例对象的命名空间被实现为字典，即内置的 <code>__dict__ 属性</code>；</li>
<li>属性继承就是搜索链接的字典；实例对象和类对象就是互相之间带有链接的字典：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        self.data1 = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Super</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hola</span>(<span class="params">self</span>):</span><br><span class="line">        self.data2 = <span class="string">&#x27;eggs&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当我们创建子类的实例时，该实例一开始是空的命名空间字典，但是有指向它的类的链接，让继承搜索能顺着寻找；</li>
<li>继承树可在特殊的属性中显式获取；</li>
<li>实例对象的 <code>__class__ 属性</code>链接到了它的类，而类有一个 <code>__bases__ 属性</code>（一个元组），其中包含通往更高的父类的链接：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = Sub()</span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br><span class="line"><span class="built_in">print</span>(X.__class__)</span><br><span class="line"><span class="built_in">print</span>(Sub.__bases__)</span><br><span class="line"><span class="built_in">print</span>(Super.__bases__)</span><br></pre></td></tr></table></figure>
<ul>
<li>当类为 self 属性赋值时，属性会位于实例的属性命名空间字典内：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y = Sub()</span><br><span class="line">X.hello()</span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br><span class="line">X.hola()</span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(Sub.__dict__.keys()))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(Super.__dict__.keys()))</span><br><span class="line"><span class="built_in">print</span>(Y.__dict__)</span><br></pre></td></tr></table></figure>
<ul>
<li>因为属性在 python 内部是字典键，所以有2种方式进行访问或赋值：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(X.data1, X.__dict__[<span class="string">&#x27;data1&#x27;</span>])</span><br><span class="line">X.data3 = <span class="string">&#x27;toast&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br><span class="line">X.__dict__[<span class="string">&#x27;data3&#x27;</span>] = <span class="string">&#x27;ham&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br></pre></td></tr></table></figure>
<ul>
<li>但是属性的点号运算会执行继承搜索，而字典索引无法访问继承属性；</li>
<li>比如继承的属性 X.hello 就无法由 <code>X.__dict__[&#39;hello&#39;]</code> 来访问。</li>
</ul>
<h3 id="六、Documentation-Strings-Revisited"><a href="#六、Documentation-Strings-Revisited" class="headerlink" title="六、Documentation Strings Revisited"></a>六、Documentation Strings Revisited</h3><p>1、如同模块，文档字符串 Documentation Strings 也可以用于类</p>
<ul>
<li>文本字符串由 python 自动保存到相应对象的 __doc__ 属性中；</li>
<li>文档字符串适用于模块文件、函数定义，以及类和方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docstr.py</span></span><br><span class="line"><span class="string">&quot;I am: docstr.__doc__&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="string">&quot;I am: docstr.func.__doc__&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">spam</span>:</span><br><span class="line">    <span class="string">&quot;I am: spam.__doc__ or docstr.spam.__doc__ or self.__doc__&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;I am: spam.method.__doc__ or self.method.__doc__&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(self.__doc__)</span><br><span class="line">        <span class="built_in">print</span>(self.method.__doc__)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> docstr</span><br><span class="line"><span class="built_in">print</span>(docstr.__doc__)</span><br><span class="line"><span class="built_in">print</span>(docstr.func.__doc__)</span><br><span class="line"><span class="built_in">print</span>(docstr.spam.__doc__)</span><br><span class="line"><span class="built_in">print</span>(docstr.spam.method.__doc__)</span><br><span class="line"></span><br><span class="line">x = docstr.spam()</span><br><span class="line">x.method()</span><br></pre></td></tr></table></figure>
<ul>
<li>第15章还讨论了 PyDoc 工具，该工具能将这些文档字符串整理成报告和网页：<code>help(docstr)</code>。</li>
</ul>
<h2 id="chapter-30-Class-Coding-Details"><a href="#chapter-30-Class-Coding-Details" class="headerlink" title="chapter 30 Class Coding Details"></a>chapter 30 Class Coding Details</h2><h3 id="一、The-Basics"><a href="#一、The-Basics" class="headerlink" title="一、The Basics"></a>一、The Basics</h3><p>1、运算符重载 operator overloading 基础知识</p>
<ul>
<li>运算符重载让类拦截常规的 Python 操作；</li>
<li>类可重载所有 python 表达式运算符；</li>
<li>类也可以重载打印、函数调用、属性访问等内置运算；</li>
<li>重载使类实例的行为更接近内置类型；</li>
<li>重载是通过在一个类中提供特殊名称的方法来实现的。</li>
</ul>
<p>2、构造函数和捕捉减法的表达式： __init__ 和 __sub__</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start</span>):</span><br><span class="line">        self.data = start</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sub__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Number(self.data - other)</span><br><span class="line"></span><br><span class="line">X = Number(<span class="number">5</span>)</span><br><span class="line">Y = X - <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(Y.data)</span><br></pre></td></tr></table></figure>
<ul>
<li>__sub__ 跟第27章的 __add__ 方法类似，会拦截减法表达式并返回一个新的对象实例作为结果；</li>
<li>在一个实例被创建的过程中，首先触发是 __new__ 方法，这一方法将创建并返回一个新的实例对象，并传入 __init__ 函数以供初始化，见第40章。</li>
</ul>
<p>3、常见的运算符重载方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">方法名 Method</th>
<th style="text-align:left">实现功能 Implements</th>
<th style="text-align:left">触发调用的形式 Called for</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">__init__</td>
<td style="text-align:left">Constructor</td>
<td style="text-align:left">Object creation: X = Class(args)</td>
</tr>
<tr>
<td style="text-align:left">__del__</td>
<td style="text-align:left">Destructor</td>
<td style="text-align:left">Object reclamation of X</td>
</tr>
<tr>
<td style="text-align:left">__add__</td>
<td style="text-align:left">Operator +</td>
<td style="text-align:left">X + Y, X += Y if no __iadd__</td>
</tr>
<tr>
<td style="text-align:left">__or__</td>
<td style="text-align:left">Operator &#124; (bitwise OR)</td>
<td style="text-align:left">X &#124; Y, X &#124;= Y if no __ior__</td>
</tr>
<tr>
<td style="text-align:left">__repr__, __str__</td>
<td style="text-align:left">Printing, conversions</td>
<td style="text-align:left">print(X), repr(X), str(X)</td>
</tr>
<tr>
<td style="text-align:left">__call__</td>
<td style="text-align:left">Function calls</td>
<td style="text-align:left">X(*args, **kargs)</td>
</tr>
<tr>
<td style="text-align:left">__getattr__</td>
<td style="text-align:left">Attribute fetch</td>
<td style="text-align:left">X.undefined</td>
</tr>
<tr>
<td style="text-align:left">__setattr__</td>
<td style="text-align:left">Attribute assignment</td>
<td style="text-align:left">X.any = value</td>
</tr>
<tr>
<td style="text-align:left">__delattr__</td>
<td style="text-align:left">Attribute deletion</td>
<td style="text-align:left">del X.any</td>
</tr>
<tr>
<td style="text-align:left">__getattribute__</td>
<td style="text-align:left">Attribute fetch</td>
<td style="text-align:left">X.any</td>
</tr>
<tr>
<td style="text-align:left">__getitem__</td>
<td style="text-align:left">Indexing, slicing, iteration</td>
<td style="text-align:left">X[key], X[i:j], for loops and other iterations if no __iter__</td>
</tr>
<tr>
<td style="text-align:left">__setitem__</td>
<td style="text-align:left">Index and slice assignment</td>
<td style="text-align:left">X[key] = value, X[i:j] = iterable</td>
</tr>
<tr>
<td style="text-align:left">__delitem__</td>
<td style="text-align:left">Index and slice deletion</td>
<td style="text-align:left">del X[key], del X[i:j]</td>
</tr>
<tr>
<td style="text-align:left">__len__</td>
<td style="text-align:left">Length</td>
<td style="text-align:left">len(X), truth tests if no __bool__</td>
</tr>
<tr>
<td style="text-align:left">__bool__</td>
<td style="text-align:left">Boolean tests</td>
<td style="text-align:left">bool(X), truth tests (named __nonzero__ in 2.X)</td>
</tr>
<tr>
<td style="text-align:left">__lt__, __gt__</td>
<td style="text-align:left">Comparisons</td>
<td style="text-align:left">X &lt; Y, X &gt; Y</td>
</tr>
<tr>
<td style="text-align:left">__le__, __ge__</td>
<td style="text-align:left">Comparisons</td>
<td style="text-align:left">X &lt;= Y, X &gt;= Y</td>
</tr>
<tr>
<td style="text-align:left">__eq__, __ne__</td>
<td style="text-align:left">Comparisons</td>
<td style="text-align:left">X == Y, X != Y</td>
</tr>
<tr>
<td style="text-align:left">__radd__</td>
<td style="text-align:left">Right-side operators</td>
<td style="text-align:left">Other + X</td>
</tr>
<tr>
<td style="text-align:left">__iadd__</td>
<td style="text-align:left">In-place augmented operators</td>
<td style="text-align:left">X += Y (or else __add__)</td>
</tr>
<tr>
<td style="text-align:left">__iter__, __next__</td>
<td style="text-align:left">Iteration contexts</td>
<td style="text-align:left">I=iter(X), next(I); for loops, in if no __contains__, all comprehensions, map(F,X), others</td>
</tr>
<tr>
<td style="text-align:left">__contains__</td>
<td style="text-align:left">Membership test</td>
<td style="text-align:left">item in X (any iterable)</td>
</tr>
<tr>
<td style="text-align:left">__index__</td>
<td style="text-align:left">Integer value</td>
<td style="text-align:left">hex(X), bin(X), oct(X), O[X], O[X:] (replaces 2.X __oct__, __hex__)</td>
</tr>
<tr>
<td style="text-align:left">__enter__, __exit__</td>
<td style="text-align:left">Context manager</td>
<td style="text-align:left">with obj as var:</td>
</tr>
<tr>
<td style="text-align:left">__get__, __set__, __delete__</td>
<td style="text-align:left">Descriptor attributes</td>
<td style="text-align:left">X.attr, X.attr = value, del X.attr</td>
</tr>
<tr>
<td style="text-align:left">__new__</td>
<td style="text-align:left">Creation</td>
<td style="text-align:left">Object creation, before __init__</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>运算符重载方法是可选的，如果没有给出相应的运算符重载方法的话，大多数内置函数会对类实例失效。</li>
</ul>
<h3 id="二、Indexing-and-Slicing-getitem-and-setitem"><a href="#二、Indexing-and-Slicing-getitem-and-setitem" class="headerlink" title="二、Indexing and Slicing: __getitem__ and __setitem__"></a>二、Indexing and Slicing: __getitem__ and __setitem__</h3><p>1、<code>__getitem__</code>：如果类定义或继承了该方法，该方法会自动被调用并进行实例的索引运算</p>
<ul>
<li>即实例 X 出现在 <code>X[i]</code> 的运算中，python 会调用实例继承的 <code>__getitem__</code> 方法，把 X 作为第一个参数传入，索引值传给第二个参数：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Indexer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> index ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">X = Indexer()</span><br><span class="line"><span class="built_in">print</span>(X[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>2、拦截分片 Intercepting Slices</p>
<ul>
<li>除了索引，<code>__getitem__</code> 也会被分片表达式调用：</li>
<li>以下为分片相关，详见第7章：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">2</span>:<span class="number">4</span>], L[<span class="number">1</span>:], L[:-<span class="number">1</span>], L[::<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以手动地传入分片对象：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(L[<span class="built_in">slice</span>(<span class="number">2</span>, <span class="number">4</span>)], L[<span class="built_in">slice</span>(<span class="number">1</span>, <span class="literal">None</span>)], L[<span class="built_in">slice</span>(<span class="literal">None</span>, -<span class="number">1</span>)], L[<span class="built_in">slice</span>(<span class="literal">None</span>, <span class="literal">None</span>, <span class="number">2</span>)])</span><br></pre></td></tr></table></figure>
<ul>
<li>而 <code>__getitem__</code> 即能被基础索引（带有一个索引）调用，又能被分片（带有一个分片对象）调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Indexer</span>:</span><br><span class="line">    data = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;getitem:&#x27;</span>, index)</span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line"></span><br><span class="line">X = Indexer()</span><br><span class="line">X[<span class="number">0</span>]</span><br><span class="line">X[<span class="number">1</span>]</span><br><span class="line">X[-<span class="number">1</span>]</span><br><span class="line">X[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">X[<span class="number">1</span>:]</span><br><span class="line">X[:-<span class="number">1</span>]</span><br><span class="line">X[::<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__getitem__</code> 可以检测它接收的参数类型，并提取分片对象的边界。分片对象拥有 start 、 stop 和 step 这些属性，任意一项被省略的话都是 None ：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Indexer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(index, <span class="built_in">int</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;indexing&#x27;</span>, index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;slicing&#x27;</span>, index.start, index.stop, index.step)</span><br><span class="line"></span><br><span class="line">X = Indexer()</span><br><span class="line">X[<span class="number">99</span>]</span><br><span class="line">X[<span class="number">1</span>:<span class="number">99</span>:<span class="number">2</span>]</span><br><span class="line">X[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
<p>3、<code>__setitem__</code> 方法是对索引进行赋值，可以拦截索引赋值或分片赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IndexSetter</span>:</span><br><span class="line">    data = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, index, value</span>):</span><br><span class="line">        self.data[index] = value ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">X = IndexSetter()</span><br><span class="line">X[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(X.data)</span><br></pre></td></tr></table></figure>
<p>4、<code>__index__</code> 方法不是索引</p>
<ul>
<li><code>__index__</code> 方法会为一个实例返回一个整数值，供转化数字串的内置函数使用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__index__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">255</span></span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(X))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(X))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(X))</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以作为索引：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="string">&#x27;C&#x27;</span> * <span class="number">256</span>)[<span class="number">255</span>])</span><br><span class="line"><span class="built_in">print</span>((<span class="string">&#x27;C&#x27;</span> * <span class="number">256</span>)[X])</span><br><span class="line"><span class="built_in">print</span>((<span class="string">&#x27;C&#x27;</span> * <span class="number">256</span>)[X:])</span><br></pre></td></tr></table></figure>
<p>5、索引迭代：<code>__getitem__</code></p>
<ul>
<li><code>__getitem__</code> 也可以是 Python 中一种重载迭代的方式；</li>
<li>可以重复对序列进行索引运算，直到检测到超出边界的 IndexError 异常。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StepperIndex</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data[i]</span><br><span class="line">    </span><br><span class="line">X = StepperIndex()</span><br><span class="line">X.data = <span class="string">&quot;Spam&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X[<span class="number">1</span>])  <span class="comment"># Indexing calls __getitem__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> X:  <span class="comment"># for loops call __getitem__</span></span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>成员关系测试 in 、列表推导、内置函数 map 、列表和元组赋值运算以及类型构造方法都会自动调用 <code>__getitem__</code> ：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> X)</span><br><span class="line"><span class="built_in">print</span>([c <span class="keyword">for</span> c <span class="keyword">in</span> X])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>.upper, X)))</span><br><span class="line">(a, b, c, d) = X</span><br><span class="line"><span class="built_in">print</span>(a, c, d)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(X), <span class="built_in">tuple</span>(X), <span class="string">&#x27;&#x27;</span>.join(X))</span><br><span class="line"><span class="built_in">print</span>(X)</span><br></pre></td></tr></table></figure>
<h3 id="三、Iterable-Objects-iter-and-next"><a href="#三、Iterable-Objects-iter-and-next" class="headerlink" title="三、Iterable Objects: __iter__ and __next__"></a>三、Iterable Objects: __iter__ and __next__</h3><p>1、Python 中所有的迭代上下文都先尝试 <code>__iter__</code> 方法，再尝试 <code>__getitem__</code></p>
<p>2、用类定义用户自定义可迭代对象</p>
<ul>
<li>迭代上下文是通过将一个可迭代对象传入内置函数 iter ，并尝试调用 __iter__ 方法来实现的，该方法返回一个迭代器对象；</li>
<li>如果提供了这种方法，python 会重复调用这个迭代器对象的 __next__ 方法来产生元素，直到引发 StopIteration 异常。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Squares</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, stop</span>):</span><br><span class="line">        self.value = start - <span class="number">1</span></span><br><span class="line">        self.stop = stop</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self <span class="comment"># __iter__方法返回的迭代器对象就是实例对象self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.value == self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration <span class="comment"># 迭代通过raise语句来结束</span></span><br><span class="line">        self.value += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.value ** <span class="number">2</span> <span class="comment"># 改为生成平方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Squares(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = Squares(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">I = <span class="built_in">iter</span>(X)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br></pre></td></tr></table></figure>
<p>3、单遍扫描和多遍扫描</p>
<ul>
<li>类的 <code>__iter__</code> 被设计为只遍历一次，而不是多次；</li>
<li>类在代码中显式地选择扫描行为；</li>
<li>由于上面 Squares 类的 __iter__ 通常返回只带有一份迭代状态复制的 self ，因此是一个一次性的迭代；</li>
<li>一旦迭代过这个类的一个实例，它就变为空；</li>
<li>所以需要为每一次新的迭代创建一个新的可迭代实例对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = Squares(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>([n <span class="keyword">for</span> n <span class="keyword">in</span> X]) <span class="comment"># Exhausts items: __iter__ returns self</span></span><br><span class="line"><span class="built_in">print</span>([n <span class="keyword">for</span> n <span class="keyword">in</span> X]) <span class="comment"># Now it&#x27;s empty: __iter__ returns same self</span></span><br><span class="line"><span class="built_in">print</span>([n <span class="keyword">for</span> n <span class="keyword">in</span> Squares(<span class="number">1</span>, <span class="number">5</span>)]) <span class="comment"># Make a new iterable object</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(Squares(<span class="number">1</span>, <span class="number">3</span>))) <span class="comment"># A new object for each new __iter__ call</span></span><br></pre></td></tr></table></figure>
<p>4、单个对象上的多个迭代器</p>
<ul>
<li>例如14章提到的：生成器函数、生成器表达式以及 map 和 zip 这样的内置函数，是单次迭代对象，只能支持唯一一个活跃扫描；</li>
<li>range 内置函数和其他的内置类型（如列表），则支持多个带有独立位置的活跃迭代器。</li>
</ul>
<p>（1）单次遍历迭代对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="built_in">map</span>(<span class="built_in">list</span>, <span class="string">&#x27;ace&#x27;</span>) <span class="comment"># 得到的是[&#x27;a&#x27;],[&#x27;b&#x27;],[&#x27;c&#x27;]的迭代器</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> S:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> S:</span><br><span class="line">        <span class="built_in">print</span>(x + y, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>（2）多次遍历迭代对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="built_in">list</span>(<span class="string">&#x27;ace&#x27;</span>) <span class="comment"># 得到的是[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> S:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> S:</span><br><span class="line">        <span class="built_in">print</span>(x + y, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>当用类编写用户定义的可迭代对象，要达到多个迭代器的效果，__iter__ 只需替迭代器定义一个新的对象状态，而不是在每次迭代器请求中都返回 self ；</li>
<li>下面的 SkipObject 类定义了一个可迭代对象。由于它的迭代器对象会在每次迭代时都被一个支持类重新创建，因此能够支持多个循环：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SkipObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, wrapped</span>):</span><br><span class="line">        self.wrapped = wrapped</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> SkipIterator(self.wrapped) <span class="comment"># New iterator each time</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkipIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, wrapped</span>):</span><br><span class="line">        self.wrapped = wrapped <span class="comment"># Iterator state information</span></span><br><span class="line">        self.offset = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.offset &gt;= <span class="built_in">len</span>(self.wrapped):</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            item = self.wrapped[self.offset]</span><br><span class="line">            self.offset += <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">alpha = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line">skipper = SkipObject(alpha)</span><br><span class="line">I = <span class="built_in">iter</span>(skipper)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I), <span class="built_in">next</span>(I), <span class="built_in">next</span>(I))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> skipper:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> skipper:</span><br><span class="line">        <span class="built_in">print</span>(x + y, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>5、编程备选方案：<code>__iter__</code> 加 yield</p>
<ul>
<li>包含 yield 语句的函数都会被转换成一个生成器函数；</li>
<li>当被调用时，它返回一个新的生成器对象；</li>
<li>一个被自动创建的 __iter__ 方法返回它本身；</li>
<li>而另一个自动创建的 __next__ 方法要么开始函数的执行，要么回到上一次执行的位置：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x): <span class="keyword">yield</span> i ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">G = gen(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(G.__iter__() == G)</span><br><span class="line">I = <span class="built_in">iter</span>(G)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I), <span class="built_in">next</span>(I))</span><br></pre></td></tr></table></figure>
<ul>
<li>这个带有 yield 的生成器函数可以作为类的 __iter__ 重载方法；</li>
<li>这样的方法会放回带有 __next__方法的新生成器对象；</li>
<li>在类中作为方法的生成器函数有权访问存储在实例属性和局部作用域变量中的状态：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Squares</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, stop</span>):</span><br><span class="line">        self.start = start</span><br><span class="line">        self.stop = stop</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(self.start, self.stop + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">yield</span> value ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Squares(<span class="number">1</span>, <span class="number">5</span>): <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>__iter__ 返回了一个生成器对象，该生成器对象带有一个自动创建的 __next__ 类，如果调用结果对象的 next 接口，就能按需产生结果：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = Squares(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line">I = <span class="built_in">iter</span>(S)</span><br><span class="line"><span class="built_in">print</span>(I)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I), <span class="built_in">next</span>(I))</span><br></pre></td></tr></table></figure>
<ul>
<li>除了将生成器函数作为 __iter__ 方法，可以手动访问属性和调用，如<code>Squares(1,5).gen()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Squares</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, stop</span>):</span><br><span class="line">        self.start = start</span><br><span class="line">        self.stop = stop</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gen</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(self.start, self.stop + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">yield</span> value ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Squares(<span class="number">1</span>, <span class="number">5</span>).gen(): <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>①当有 __iter__ 时，迭代触发 __iter__ 并返回一个新的带有 __next__ 的生成器；<br>②当没有 __iter__ 时，代码会调用一个生成器，自动创建 __iter__ 方法返回它本身。</p>
<p>6、使用 yield 的多重迭代器</p>
<ul>
<li>之前的 __iter__ 加 yield 组合自动支持多重活跃迭代器；</li>
<li>因为每次对__iter__的调用都是返回一个新的生成器：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Squares</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, stop</span>):</span><br><span class="line">        self.start = start</span><br><span class="line">        self.stop = stop</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(self.start, self.stop + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">yield</span> value ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">S = Squares(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">I = <span class="built_in">iter</span>(S)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I), <span class="built_in">next</span>(I))</span><br><span class="line">J = Squares(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">J = <span class="built_in">iter</span>(S)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(J), <span class="built_in">next</span>(J))</span><br><span class="line"></span><br><span class="line">S = Squares(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> S:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s:%s&#x27;</span> % (i, j), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="四、Membership-contains-iter-and-getitem"><a href="#四、Membership-contains-iter-and-getitem" class="headerlink" title="四、Membership: __contains__, __iter__, and __getitem__"></a>四、Membership: __contains__, __iter__, and __getitem__</h3><p>1、in 成员关系</p>
<ul>
<li>类通常把 in 成员关系运算符实现为一个迭代，使用 <code>__iter__</code> 方法或 <code>__getitem__</code> 方法；</li>
<li>类还可以通过编写 <code>__contain__</code> 方法来支持更加特定具体的成员关系。</li>
<li>即当 <code>__contain__</code> 方法存在时，它优先于 <code>__iter__</code> 方法，而 <code>__iter__</code> 方法优先于 <code>__getitem__</code> 方法；</li>
<li><code>__contain__</code> 方法应该把成员关系定义为对一个键值做映射，或定义为对序列的搜索。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Iters</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get[%s]:&#x27;</span> % i, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.data[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;iter=&gt; &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        self.ix = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;next:&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.ix == <span class="built_in">len</span>(self.data): <span class="keyword">raise</span> StopIteration</span><br><span class="line">        item = self.data[self.ix]</span><br><span class="line">        self.ix += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;contains: &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">in</span> self.data</span><br><span class="line"></span><br><span class="line">X = Iters([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> X: </span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; | &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>([i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> X])</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">bin</span>, X)) )</span><br><span class="line"></span><br><span class="line">I = <span class="built_in">iter</span>(X)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(I), end=<span class="string">&#x27; @ &#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;-&#x27;</span> * <span class="number">128</span>)</span><br></pre></td></tr></table></figure>
<p>2、上述代码去掉 <code>__contains__</code> 方法后，成员关系由 <code>__iter__</code> 执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Iters</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get[%s]:&#x27;</span> % i, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.data[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;iter=&gt; &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        self.ix = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;next:&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.ix == <span class="built_in">len</span>(self.data): <span class="keyword">raise</span> StopIteration</span><br><span class="line">        item = self.data[self.ix]</span><br><span class="line">        self.ix += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">X = Iters([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> X: </span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; | &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>([i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> X])</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">bin</span>, X)) )</span><br><span class="line"></span><br><span class="line">I = <span class="built_in">iter</span>(X)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(I), end=<span class="string">&#x27; @ &#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;-&#x27;</span> * <span class="number">128</span>)</span><br></pre></td></tr></table></figure>
<p>3、上述代码去掉 <code>__contains__</code> 和 <code>__iter__</code> 方法后，成员关系和其他迭代上下文，由 <code>__getitem__</code> 方法调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Iters</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get[%s]:&#x27;</span> % i, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.data[i]</span><br><span class="line"></span><br><span class="line">X = Iters([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> X: </span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; | &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>([i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> X])</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">bin</span>, X)) )</span><br><span class="line"></span><br><span class="line">I = <span class="built_in">iter</span>(X)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(I), end=<span class="string">&#x27; @ &#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;-&#x27;</span> * <span class="number">128</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__getitem__</code> 方法更加通用，除了迭代，还拦截显式索引和分片：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = Iters(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(X[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X[<span class="number">1</span>:])</span><br><span class="line"><span class="built_in">print</span>(X[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(X))</span><br></pre></td></tr></table></figure>
<h3 id="五、Attribute-Access-getattr-and-setattr"><a href="#五、Attribute-Access-getattr-and-setattr" class="headerlink" title="五、Attribute Access: __getattr__ and __setattr__"></a>五、Attribute Access: __getattr__ and __setattr__</h3><p>1、类在需要的时候也可以拦截基本的属性访问（点号运算），即 <code>object.contribute</code> </p>
<p>2、属性引用</p>
<ul>
<li><code>__getattr__</code>方法可以用来拦截属性引用；</li>
<li>每当用一个未定义的（不存在的）属性名称字符串对一个实例对象做点号运算时，它就会被调用；</li>
<li>正因为如此，<code>__getattr__</code> 可以用作以泛化形式响应属性请求的钩子；</li>
<li>它通常用于将代理控制对象的调用委托给内嵌（被包装）的对象；</li>
<li>这个方法也可以用于让类适配一个接口，或是为数据属性添加一个访问方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attrname</span>):</span><br><span class="line">        <span class="keyword">if</span> attrname == <span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">40</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(attrname)</span><br><span class="line"></span><br><span class="line">X = Empty()</span><br><span class="line"><span class="built_in">print</span>(X.age)</span><br></pre></td></tr></table></figure>
<p>3、属性赋值和删除</p>
<ul>
<li><code>__setattr__</code> 会拦截所有的属性赋值；</li>
<li>如果定义或继承了这个方法，<code>self.attr = value</code> 会变成 <code>self.__setattr__(&#39;attr&#39;, value)</code></li>
<li>注意事项：如果在 <code>__setattr__</code> 中对任何 self 属性做赋值，都将再次调用 <code>__setattr__</code> ，会导致无限递归循环（最终结果是相对快速的栈溢出异常）；</li>
<li>记住：<code>__setattr__</code> 会捕获所有的属性赋值；</li>
<li>如果你想使用该方法，可以把实例属性的赋值编写成对属性字典键的赋值来避免循环；</li>
<li>即，使用 <code>self.__dict__[&#39;name&#39;] = x</code> ，而不是 <code>self.name = x</code> ，来避免循环：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accesscontrol</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, attr, value</span>):</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">            self.__dict__[attr] = value + <span class="number">10</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(attr + <span class="string">&#x27; not allowed&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = Accesscontrol()</span><br><span class="line">X.age = <span class="number">40</span></span><br><span class="line"><span class="built_in">print</span>(X.age)</span><br></pre></td></tr></table></figure>
<ul>
<li>第三个属性管理方法 <code>__delattr__</code> 被传入属性名称字符串并在所有属性删除操作被调用；</li>
<li>它也必须通过 <code>__dict__</code> 来进行属性删除操作，从而避免循环调用。</li>
</ul>
<p>4、其他属性管理工具</p>
<ul>
<li><code>__getattribute__</code> 方法拦截所有的属性访问，不只是未定义的；</li>
<li>property 内置函数允许把方法对指定类属性上的访问和修改操作关联起来；</li>
<li>描述符 Descriptors 提供了一个协议，把一个类的 <code>__get__</code> 和 <code>__set__</code> 方法对指定类属性上的访问关联起来；</li>
<li>slot 属性在类中被声明，但在每个实例中都会创建隐式的存储。</li>
</ul>
<h3 id="六、String-Representation-repr-and-str"><a href="#六、String-Representation-repr-and-str" class="headerlink" title="六、String Representation: __repr__ and __str__"></a>六、String Representation: __repr__ and __str__</h3><p>1、<code>__repr__</code> 和 <code>__str__</code></p>
<ul>
<li><code>__str__</code> 会首先被打印操作和 str 内置函数尝试；</li>
<li><code>__repr__</code> 用于交互式命令行、 repr 函数、嵌套的显示，以及没有 __str__ 时的 print 和 str 调用</li>
<li><code>__str__</code> 用于程序的用户友好的显示，而 <code>__repr__</code> 通常用于代码或底层的显示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">adder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value=<span class="number">0</span></span>):</span><br><span class="line">        self.data = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        self.data += other</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">addrepr</span>(<span class="title class_ inherited__">adder</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;addrepr(%s)&#x27;</span> % self.data</span><br><span class="line"></span><br><span class="line">x = addrepr(<span class="number">2</span>)</span><br><span class="line">x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在交互式命令行中，x 显示 addrepr(3) ，与 print(x) 一样：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(x) </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">addstr</span>(<span class="title class_ inherited__">adder</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[Value: %s]&#x27;</span> % self.data</span><br><span class="line"></span><br><span class="line">x = addstr(<span class="number">3</span>)</span><br><span class="line">x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在交互式命令行中， x 显示 <code>&lt;__main__.addstr object at 0x00000000029738D0&gt;</code>，与 print(x) 不一样：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">addboth</span>(<span class="title class_ inherited__">adder</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[Value: %s]&#x27;</span> % self.data</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;addboth(%s)&#x27;</span> % self.data</span><br><span class="line"></span><br><span class="line">x = addboth(<span class="number">4</span>)</span><br><span class="line">x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在交互式命令行中， x 显示 addboth(5) ，运行 <code>__repr__</code> 方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(x) <span class="comment"># 运行__str__方法 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(x), <span class="built_in">repr</span>(x))</span><br></pre></td></tr></table></figure>
<p>2、使用提示</p>
<ul>
<li><code>__str__</code> 和 <code>__repr__</code> 都必须返回字符串；</li>
<li><code>__str__</code> 只会应用在对象出现在打印操作顶层时；在对象中内嵌的对象仍然使用 <code>__repr__</code> 方法打印</li>
<li>我的理解是 <code>__repr__</code> 表示对象本身显示什么，<code>__str__</code> 表示对象打印出什么。</li>
<li>打印容器对象的 <code>__str__</code> 方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.val)</span><br><span class="line"></span><br><span class="line">objs = [Printer(<span class="number">2</span>), Printer(<span class="number">3</span>)]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> objs: <span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(objs)</span><br></pre></td></tr></table></figure>
<ul>
<li>打印容器对象的 <code>__repr__</code> 方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.val)</span><br><span class="line"></span><br><span class="line">objs = [Printer(<span class="number">2</span>), Printer(<span class="number">3</span>)]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> objs: <span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(objs)</span><br></pre></td></tr></table></figure>
<h3 id="七、Right-Side-and-In-Place-Uses-radd-and-iadd"><a href="#七、Right-Side-and-In-Place-Uses-radd-and-iadd" class="headerlink" title="七、Right-Side and In-Place Uses: __radd__ and __iadd__"></a>七、Right-Side and In-Place Uses: __radd__ and __iadd__</h3><p>1、右侧加法</p>
<ul>
<li>目前编写的 <code>__add__</code> 方法并不支持把实例对象写在 + 右侧；</li>
<li>为了实现更通用的表达式，需要同时编写 <code>__radd__</code> 方法；</li>
<li>只有当 + 右侧是实例对象且左侧不是实例对象时，python 才会调用 <code>__radd__</code>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Commuter1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;add&#x27;</span>, self.val, other)</span><br><span class="line">        <span class="keyword">return</span> self.val + other</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>): <span class="comment"># 顺序反转：self在 + 的右侧，other在左侧</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;radd&#x27;</span>, self.val, other)</span><br><span class="line">        <span class="keyword">return</span> other + self.val</span><br><span class="line"></span><br><span class="line">x = Commuter1(<span class="number">88</span>)</span><br><span class="line">y = Commuter1(<span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> + y)</span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br></pre></td></tr></table></figure>
<ul>
<li>2个实例对象相加后，python首先运行 <code>__add__</code> ，在 <code>__add__</code> 内部的 return 中又有加号即 88 + y，这个 + 触发了 <code>__radd__</code> 方法；</li>
<li>所以上面 <code>__add__</code> 方法中，<code>return self.val + other</code> 改为 <code>return other + self.val</code> ，就会看到2次 add ；</li>
</ul>
<p>2、在 <code>__radd__</code> 中使用 <code>__add__</code></p>
<ul>
<li>可以在 <code>__radd__</code> 中直接调用 <code>__add__</code> ；要么交换位置，间接触发 <code>__add__</code> ；要么在类的顶层直接把 <code>__radd__</code> 赋值成 <code>__add__</code> 的别名：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Commuter2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;add&#x27;</span>, self.val, other)</span><br><span class="line">        <span class="keyword">return</span> self.val + other</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__add__(other)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Commuter3</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;add&#x27;</span>, self.val, other)</span><br><span class="line">        <span class="keyword">return</span> self.val + other</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self + other</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Commuter4</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;add&#x27;</span>, self.val, other)</span><br><span class="line">        <span class="keyword">return</span> self.val + other</span><br><span class="line">    __radd__ = __add__</span><br></pre></td></tr></table></figure>
<p> 3、return 类类型，需要 isinstance 测试来避免嵌套</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Commuter5</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Commuter5): <span class="comment"># 如果不测试，会得到嵌套在Commuter5中的Commuter5对象</span></span><br><span class="line">            other = other.val</span><br><span class="line">        <span class="keyword">return</span> Commuter5(self.val + other)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Commuter5(other + self.val)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;Commuter5: %s&gt;&#x27;</span> % self.val</span><br><span class="line"></span><br><span class="line">x = Commuter5(<span class="number">88</span>)</span><br><span class="line">y = Commuter5(<span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(x + <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> + y)</span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"><span class="built_in">print</span>(x + y + <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>4、原位置加法 In-Place Addition</p>
<ul>
<li>为了实现 += ，可以编写一个 <code>__iadd__</code> 或 <code>__add__</code>；</li>
<li><code>__iadd__</code> 更高效，若不存在，则会使用 <code>__add__</code>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iadd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        self.val += other</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">x = Number(<span class="number">5</span>)</span><br><span class="line">x += <span class="number">1</span></span><br><span class="line">x += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(x.val)</span><br><span class="line"></span><br><span class="line">y = Number([<span class="number">1</span>])</span><br><span class="line">y += [<span class="number">2</span>]</span><br><span class="line">y += [<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(y.val)</span><br></pre></td></tr></table></figure>
<p>5、每个运算符都有右侧和原位置重置方法，例如乘法的 <code>__mul__</code> 、 <code>__rmul__</code> 、 <code>__imul__</code>。</p>
<h3 id="八、Other-Operator-Overloading"><a href="#八、Other-Operator-Overloading" class="headerlink" title="八、Other Operator Overloading"></a>八、Other Operator Overloading</h3><p>1、Call Expressions: <code>__call__</code></p>
<ul>
<li>调用实例会使用 <code>__call__</code> 方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Callee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *pargs, **kargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Called:&#x27;</span>, pargs, kargs)</span><br><span class="line"></span><br><span class="line">C = Callee()</span><br><span class="line">C(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">C(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, x=<span class="number">4</span>, y=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>2、Comparisons: <code>__lt__</code> , <code>__gt__</code> , and Others</p>
<ul>
<li>类可以定义方法来捕获&lt;、&gt;、&lt;=、&gt;=、==、!=</li>
<li>比较运算符没有隐含关系，比如 == 为真并不意味着 != 为假。因此 <code>__eq__</code> 和 <code>__ne__</code> 的定义要确保两个运算符都正确地工作；</li>
<li>以下为简单介绍：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    data = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__gt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data &gt; other</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data &lt; other</span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line"><span class="built_in">print</span>(X &gt; <span class="string">&#x27;ham&#x27;</span>) <span class="comment"># runs __gt__</span></span><br><span class="line"><span class="built_in">print</span>(X &lt; <span class="string">&#x27;ham&#x27;</span>) <span class="comment"># runs __lt__</span></span><br></pre></td></tr></table></figure>
<p>3、Boolean Tests: <code>__bool__</code> and <code>__len__</code></p>
<ul>
<li>Python会首先尝试 <code>__bool__</code> 来获取一个直接的布尔值；如果没有该方法，则尝试 <code>__len__</code> 来根据对象长度确定真值：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">X = Truth()</span><br><span class="line"><span class="keyword">if</span> X: <span class="built_in">print</span>(<span class="string">&#x27;yes!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">X = Truth()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(X))</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有上述方法，python 会使用长度，非零长度为真，零长度为假：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">X = Truth()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> X: <span class="built_in">print</span>(<span class="string">&#x27;no!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果上述2者都没有定义，对象会被看作真：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">X = Truth()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(X))</span><br></pre></td></tr></table></figure>
<p>4、Object Destruction: <code>__del__</code> 对象析构函数</p>
<ul>
<li>每当实例空间被收回时，<code>__del__</code>（析构函数方法）会自动执行：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Life</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="string">&#x27;unknown&#x27;</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello &#x27;</span> + name)</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">live</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Goodbye &#x27;</span> + self.name)</span><br><span class="line"></span><br><span class="line">brian = Life(<span class="string">&#x27;Brian&#x27;</span>)</span><br><span class="line">brian.live()</span><br><span class="line">brian = <span class="string">&#x27;loretta&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当 brain 被赋值为一个字符串时，我们会失去 Life 实例的最后一个引用并因此触发其析构函数；</li>
<li>python 在回收实例时，会自动回收该实例拥有的内存空间，所以析构函数并不需要考虑空间管理。</li>
</ul>
<h2 id="chapter-31-Designing-with-Classes"><a href="#chapter-31-Designing-with-Classes" class="headerlink" title="chapter 31 Designing with Classes"></a>chapter 31 Designing with Classes</h2><h3 id="一、Python-and-OOP"><a href="#一、Python-and-OOP" class="headerlink" title="一、Python and OOP"></a>一、Python and OOP</h3><p>该章内容是一些常用的 OOP 的设计模式，本书在这一块只是抛砖引玉，大致了解一下就行，按需学习，需要深入了解的时候再去深入了解。  </p>
<p>大致包括<em>继承</em>、<em>组合</em>、<em>委托</em>和<em>工厂</em>，以及<em>伪私有属性</em>、<em>多重继承</em>和<em>绑定方法</em></p>
<p>1、OOP and Inheritance</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, salary=<span class="number">0</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.salary = salary</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent</span>):</span><br><span class="line">        self.salary = self.salary + (self.salary * percent)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;does stuff&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;Employee: name=%s, salary=%s&gt;&quot;</span> % (self.name, self.salary)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chef</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        Employee.__init__(self, name, <span class="number">50000</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;makes food&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        Employee.__init__(self, name, <span class="number">40000</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;interfaces with customer&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaRobot</span>(<span class="title class_ inherited__">Chef</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        Chef.__init__(self, name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;makes pizza&quot;</span>)</span><br><span class="line"></span><br><span class="line">bob = PizzaRobot(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob)</span><br><span class="line">bob.work()</span><br><span class="line">bob.giveRaise(<span class="number">0.20</span>)</span><br><span class="line"><span class="built_in">print</span>(bob)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> klass <span class="keyword">in</span> Employee, Chef, Server, PizzaRobot:</span><br><span class="line">    obj = klass(klass.__name__)</span><br><span class="line">    obj.work()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>2、OOP and Composition 组合</p>
<ul>
<li>组合涉及把其他对象嵌入容器对象内，促使其实现容器方法；</li>
<li>有些书称组合为聚合 aggregation ：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">order</span>(<span class="params">self, server</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;orders from&quot;</span>, server)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, server</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;pays for item to&quot;</span>, server)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Oven</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bake</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;oven bakes&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaShop</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.server = Server(<span class="string">&#x27;Pat&#x27;</span>)</span><br><span class="line">        self.chef = PizzaRobot(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">        self.oven = Oven()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">order</span>(<span class="params">self, name</span>):</span><br><span class="line">        customer = Customer(name)</span><br><span class="line">        customer.order(self.server)</span><br><span class="line">        self.chef.work()</span><br><span class="line">        self.oven.bake()</span><br><span class="line">        customer.pay(self.server)</span><br><span class="line"></span><br><span class="line">scene = PizzaShop()</span><br><span class="line">scene.order(<span class="string">&#x27;Homer&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">scene.order(<span class="string">&#x27;Shaggy&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>以上的 PizzaShop 类就是容器和控制器；</li>
<li>每份订单都会创建新的 Customer 对象，并把内嵌的 Server 对象传给 Customer 的方法。</li>
</ul>
<p>3、OOP and Delegation 委托：包装器代理对象 “Wrapper” Proxy Objects</p>
<ul>
<li>委托通常是指控制器对象内嵌其他对象，并把操作请求传递给那些内嵌的对象；</li>
<li>控制器负责管理类活动，例如记录日志和验证访问，为接口组件添加额外步骤，或监视活跃实例；</li>
<li>委托是组合的一种特殊形式，它使用包装器（代理）类管理单一的内嵌对象，而包装器类保留了内嵌对象的大多数或全部的接口。</li>
<li>通常使用 <code>__getattr__</code> 方法钩子来实现委托，来把任意的访问转发给被包装的对象：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">object</span></span>):</span><br><span class="line">        self.wrapped = <span class="built_in">object</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attrname</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Trace: &#x27;</span> + attrname)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, attrname)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__getattr__</code> 方法会获取属性名称的字符串，<code>getattr</code> 内置函数可通过名称字符串获取被包装对象的属性：<code>getattr(X,N)</code> 就是 <code>X.N</code></li>
<li>这里 Wrapper 类只是在每次属性访问时打印跟踪消息，并把属性请求委托给内嵌的 wrapped 对象：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = Wrapper([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">x.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(x.wrapped)</span><br><span class="line">x = Wrapper(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(x.keys()))</span><br></pre></td></tr></table></figure>
<ul>
<li>总的效果就是通过 Wrapper 类内的额外代码来扩充被包装对象的全部接口；</li>
<li>可以利用这种方法记录方法调用，把方法调用路由到额外或定制的逻辑，使类适应一个新接口。</li>
</ul>
<h3 id="二、Pseudoprivate-Class-Attributes"><a href="#二、Pseudoprivate-Class-Attributes" class="headerlink" title="二、Pseudoprivate Class Attributes"></a>二、Pseudoprivate Class Attributes</h3><p>1、类的伪私有属性 Pseudoprivate Class Attributes</p>
<ul>
<li>python 支持名称重整 mangling ，使类中的某些名称局部化；</li>
<li>重整后的名称会被误以为是私有属性，但名称重整并不能阻止来自类外部代码的访问；</li>
<li>这个功能主要是为了避免实例内的命名空间冲突，而不是限制名称的访问，所以重整后的变量名称为伪私有。</li>
</ul>
<p>2、名称重整的工作方式</p>
<ul>
<li>只在 class 内部，任意开头双下划线，结尾没双下划线的名称，会自动在前面包含外围类的名称从而进行扩展；</li>
<li>比如 Spam 类中的 __X 会自动变成 _Spam__X ，这样就不会和其他类中相同的变量名相冲突；</li>
<li>实例属性引用也需要使用 <code>self._Spam__X</code>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth1</span>(<span class="params">self</span>): self.__X = <span class="number">88</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth2</span>(<span class="params">self</span>): <span class="built_in">print</span>(self.__X)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">metha</span>(<span class="params">self</span>): self.__X = <span class="number">99</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">methb</span>(<span class="params">self</span>): <span class="built_in">print</span>(self.__X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span>(C1, C2): <span class="keyword">pass</span></span><br><span class="line">I = C3()</span><br><span class="line"></span><br><span class="line">I.meth1(); I.metha()</span><br><span class="line"><span class="built_in">print</span>(I.__dict__)</span><br><span class="line">I.meth2(); I.methb()</span><br></pre></td></tr></table></figure>
<ul>
<li>这样可避免实例中潜在的名称冲突，如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth1</span>(<span class="params">self</span>): self.X = <span class="number">88</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth2</span>(<span class="params">self</span>): <span class="built_in">print</span>(self.X)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">metha</span>(<span class="params">self</span>): self.X = <span class="number">99</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">methb</span>(<span class="params">self</span>): <span class="built_in">print</span>(self.X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span>(C1, C2): <span class="keyword">pass</span></span><br><span class="line">I = C3()</span><br><span class="line">I.meth1(); I.metha()</span><br><span class="line"><span class="built_in">print</span>(I.__dict__)</span><br></pre></td></tr></table></figure>
<h3 id="三、Methods-Are-Objects-Bound-or-Unbound"><a href="#三、Methods-Are-Objects-Bound-or-Unbound" class="headerlink" title="三、Methods Are Objects: Bound or Unbound"></a>三、Methods Are Objects: Bound or Unbound</h3><p>1、类的方法可以通过实例或类来访问<br>①未绑定 Unbound 的类方法对象（无 self ）：直接对类进行点号运算从而获取类的函数属性。<br>②绑定 Bound 的实例方法对象（ self +函数）：对实例进行点号运算从而获取类的函数属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doit</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">object1 = Spam()</span><br><span class="line">x = object1.doit <span class="comment"># Bound method object: instance+function</span></span><br><span class="line">x(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果对类进行点号运算来获取 doit ，就会得到未绑定的方法对象；</li>
<li>要调用该方法，需要传入实例作为最左侧的参数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = Spam.doit <span class="comment"># Unbound method object</span></span><br><span class="line">object1 = Spam()</span><br><span class="line">t(object1, <span class="string">&#x27;howdy&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>同理可以在类的方法内引用 self 的属性，而该属性指向类中另外的方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m1</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m2</span>(<span class="params">self</span>):</span><br><span class="line">        x = self.m1</span><br><span class="line">        x(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">Eggs().m2()</span><br></pre></td></tr></table></figure>
<p>2、在Python 3.X 中，未绑定方法是函数</p>
<ul>
<li>打印一个非实例类的方法的类型，在 python 2.X 显示为未绑定方法，在 python 3.X 显示为函数：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Selfless</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">selfless</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">        <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">normal</span>(<span class="params">self, arg1, arg2</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg1 + arg2</span><br><span class="line"></span><br><span class="line">X = Selfless(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(X.normal(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(Selfless.normal(X, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(Selfless.selfless(<span class="number">3</span>, <span class="number">4</span>)) <span class="comment"># No instance: works in 3.X, fails in 2.X!</span></span><br><span class="line">X.selfless(<span class="number">3</span>, <span class="number">4</span>) <span class="comment"># 会出现TypeError: selfless() takes 2 positional arguments but 3 were given</span></span><br></pre></td></tr></table></figure>
<p>3、绑定方法和其他可调用对象</p>
<ul>
<li>绑定方法可以作为一般对象处理，比如用列表存储绑定方法对象：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, base</span>):</span><br><span class="line">        self.base = base</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.base * <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.base * <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">x = Number(<span class="number">2</span>)</span><br><span class="line">y = Number(<span class="number">3</span>)</span><br><span class="line">z = Number(<span class="number">4</span>)</span><br><span class="line">acts = [x.double, y.double, y.triple, z.double]</span><br><span class="line"><span class="keyword">for</span> act <span class="keyword">in</span> acts:</span><br><span class="line">    <span class="built_in">print</span>(act())</span><br></pre></td></tr></table></figure>
<ul>
<li>绑定函数对象也有自己的内省信息，包括一些属性能够让其访问配对的实例对象和方法函数：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bound = x.double</span><br><span class="line"><span class="built_in">print</span>(bound.__self__, bound.__func__)</span><br><span class="line"><span class="built_in">print</span>(bound.__self__.base)</span><br></pre></td></tr></table></figure>
<p>4、绑定方法只是可调用对象的一种，以下都可以用类似方式处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="keyword">return</span> arg ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sum</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.val + arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.val * arg</span><br><span class="line"></span><br><span class="line">sobject = Sum(<span class="number">2</span>)</span><br><span class="line">pobject = Product(<span class="number">3</span>)</span><br><span class="line">actions = [square, sobject, pobject.method]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> act <span class="keyword">in</span> actions:</span><br><span class="line">    <span class="built_in">print</span>(act(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(actions[-<span class="number">1</span>](<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>([act(<span class="number">5</span>) <span class="keyword">for</span> act <span class="keyword">in</span> actions])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> act: act(<span class="number">5</span>), actions)))</span><br></pre></td></tr></table></figure>
<h3 id="四、Classes-Are-Objects-Generic-Object-Factories"><a href="#四、Classes-Are-Objects-Generic-Object-Factories" class="headerlink" title="四、Classes Are Objects: Generic Object Factories"></a>四、Classes Are Objects: Generic Object Factories</h3><p>1、The factory design pattern</p>
<ul>
<li>工厂：将任意可调用对象，比如类，传递给生成其他种类对象的函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factory</span>(<span class="params">aClass, *pargs, **kargs</span>):</span><br><span class="line">    <span class="keyword">return</span> aClass(*pargs, **kargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doit</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, job=<span class="literal">None</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line"></span><br><span class="line">object1 = factory(Spam)</span><br><span class="line">object2 = factory(Person, <span class="string">&quot;Arthur&quot;</span>, <span class="string">&quot;King&quot;</span>)</span><br><span class="line">object3 = factory(Person, name=<span class="string">&#x27;Brian&#x27;</span>)</span><br><span class="line"></span><br><span class="line">object1.doit(<span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(object2.name, object2.job)</span><br><span class="line"><span class="built_in">print</span>(object3.name, object3.job)</span><br></pre></td></tr></table></figure>
<ul>
<li>工厂允许代码与动态配置的对象构造细节相隔绝。</li>
</ul>
<h3 id="五、Multiple-Inheritance-“Mix-in”-Classes"><a href="#五、Multiple-Inheritance-“Mix-in”-Classes" class="headerlink" title="五、Multiple Inheritance: “Mix-in” Classes"></a>五、Multiple Inheritance: “Mix-in” Classes</h3><p>1、多继承的缺点就是当相同的方法名称在不止一个父类中定义时，就会造成冲突</p>
<ul>
<li>搜索属性时，python 会从左到右遍历搜索类首行的父类<ul>
<li>在经典类 classic classes 中，所有情形下的属性搜索始终实行<strong>深度优先 depth-first</strong> 搜索，直到继承树的顶端，然后从左至右进行，这顺序称为 <strong>DFLR（depth-first, left-to-right path）</strong></li>
<li>在新式类 new-style classes 中，属性搜索通常是一样的，但在<strong>钻石模式 diamond patterns</strong> 下以<strong>广度优先</strong>方式进行，搜索向上移动之前沿着继承树的同一级搜索，这顺序称为新式 <strong>MRO（method resolution order）</strong></li>
</ul>
</li>
<li>当继承树中的多个类共享一个共同父类时，钻石模式就会出现；</li>
<li>新式搜索顺序旨在访问完全部子类后，仅访问一次这样的共享父类；</li>
<li>当冲突产生时，而不愿意使用继承的第一个名称时，会是个问题，详见下一章的新式类、MRO和新式工具。</li>
</ul>
<p>2、编写 mix-in 类</p>
<ul>
<li>多继承的最常见方法就是 to “mix in” general-purpose methods from superclasses</li>
<li>就是编写一个通用的类，然后通过多继承去使用它，跟模块作用类似；</li>
<li>下面的代码定义了一个名为 ListInstance 的 mix-in 类，它为继承了它的所有类都重载了 <code>__str__</code> 方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListInstance</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__attrnames</span>(<span class="params">self</span>):</span><br><span class="line">        result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> attr <span class="keyword">in</span> <span class="built_in">sorted</span>(self.__dict__):</span><br><span class="line">            result += <span class="string">&#x27;\t%s=%s\n&#x27;</span> % (attr, self.__dict__[attr])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;Instance of %s, address %s:\n%s&gt;&#x27;</span> % (</span><br><span class="line">            self.__class__.__name__,</span><br><span class="line">            <span class="built_in">id</span>(self),</span><br><span class="line">            self.__attrnames())</span><br></pre></td></tr></table></figure>
<ul>
<li>每个实例都有一个内置的 <code>__class__</code> 属性，引用创建本实例的类；每个类都有一个 <code>__name__</code> 属性，引用类头部的名称；</li>
<li>id 内置函数显示实例的内存地址。</li>
</ul>
<p>3、单继承模型下，混合上述的类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(<span class="title class_ inherited__">ListInstance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.data1 = <span class="string">&#x27;food&#x27;</span></span><br><span class="line"></span><br><span class="line">x = Spam()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p>4、多继承：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.data1 = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ham</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(Super, ListInstance):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Super.__init__(self)</span><br><span class="line">        self.data2 = <span class="string">&#x27;eggs&#x27;</span></span><br><span class="line">        self.data3 = <span class="number">42</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">X = Sub()</span><br><span class="line"><span class="built_in">print</span>(X)</span><br></pre></td></tr></table></figure>
<h2 id="chapter-32-Advanced-Class-Topics"><a href="#chapter-32-Advanced-Class-Topics" class="headerlink" title="chapter 32 Advanced Class Topics"></a>chapter 32 Advanced Class Topics</h2><h3 id="一、Extending-Built-in-Types"><a href="#一、Extending-Built-in-Types" class="headerlink" title="一、Extending Built-in Types"></a>一、Extending Built-in Types</h3><p>1、内嵌方式扩展类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value = []</span>):</span><br><span class="line">        self.data = []</span><br><span class="line">        self.concat(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersect</span>(<span class="params">self, other</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.data:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> other:</span><br><span class="line">                res.append(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Set</span>(res)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, other</span>):</span><br><span class="line">        res = self.data[:]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> other:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">in</span> res:</span><br><span class="line">                res.append(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Set</span>(res)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> value:               <span class="comment"># Removes duplicates</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">in</span> self.data:</span><br><span class="line">                self.data.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>): <span class="keyword">return</span> self.data[key] </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__and__</span>(<span class="params">self, other</span>): <span class="keyword">return</span> self.intersect(other)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__or__</span>(<span class="params">self, other</span>): <span class="keyword">return</span> self.union(other)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="string">&#x27;Set:&#x27;</span> + <span class="built_in">repr</span>(self.data)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="built_in">iter</span>(self.data) <span class="comment"># 生成迭代操作</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过索引和迭代操作，能让上述定义的 Set 类充当真正的列表：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="type">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>(x.union(<span class="type">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>])))</span><br><span class="line"><span class="built_in">print</span>(x | <span class="type">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>]))</span><br></pre></td></tr></table></figure>
<p>2、通过子类扩展类型</p>
<ul>
<li>在 python 中， list ,  str ,  dict , 和 tuple 这样的类型转换函数实际上是调用了类型的对象构造函数；</li>
<li>因此可以通过建立类型名称的子类来定制或扩展内置类型的行为，比如把列表的偏移量从1开始算起而不是0：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, offset</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;(indexing %s at %s)&#x27;</span> % (self, offset))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>.__getitem__(self, offset - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="string">&#x27;abc&#x27;</span>))</span><br><span class="line">x = MyList(<span class="string">&#x27;abc&#x27;</span>)  <span class="comment"># __init__ inherited from list</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># __repr__ inherited from list</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">x.append(<span class="string">&#x27;spam&#x27;</span>); <span class="built_in">print</span>(x) <span class="comment"># # Attributes from list superclass</span></span><br><span class="line">x.reverse(); <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<ul>
<li>上述的编码方式可以提供编写第一个例子的 Set 的另一种方式，即作为内置 list 的子类：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value = []</span>):</span><br><span class="line">        <span class="built_in">list</span>.__init__([]) <span class="comment"># 继承父类</span></span><br><span class="line">        self.concat(value)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersect</span>(<span class="params">self, other</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> other:</span><br><span class="line">                res.append(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Set</span>(res)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, other</span>):</span><br><span class="line">        res = <span class="type">Set</span>(self)</span><br><span class="line">        res.concat(other)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> value:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">in</span> self:</span><br><span class="line">                self.append(x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__and__</span>(<span class="params">self, other</span>): <span class="keyword">return</span> self.intersect(other)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__or__</span>(<span class="params">self, other</span>): <span class="keyword">return</span> self.union(other)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="string">&#x27;Set:&#x27;</span> + <span class="built_in">list</span>.__repr__(self)</span><br><span class="line"></span><br><span class="line">x = <span class="type">Set</span>([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>])</span><br><span class="line">y = <span class="type">Set</span>([<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(x, y, <span class="built_in">len</span>(x))</span><br><span class="line"><span class="built_in">print</span>(x.intersect(y), y.union(x))</span><br><span class="line"><span class="built_in">print</span>(x &amp; y, x | y)</span><br><span class="line">x.reverse(); <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<h3 id="二、The-“New-Style”-Class-Model"><a href="#二、The-“New-Style”-Class-Model" class="headerlink" title="二、The “New Style” Class Model"></a>二、The “New Style” Class Model</h3><p>1、介绍</p>
<ul>
<li>本书之前谈到的类和新式类相比，称为经典类，但在 python 3.X 中类的区分已经融合了；</li>
<li>在 python 3.X 中，所有的类都是所谓的新式类，不管是否显式地继承自 object ；</li>
<li>所有的类都继承自 object ，不管是显式的还是隐式的，所有的类都隐含是 object 的子类；</li>
<li>所以在 python 3.X 中新式类的功能成为了常规的类功能。</li>
<li>新式类要么从内置类型（如list）派生，要么从一个叫做 object 的特殊内置类派生。</li>
</ul>
<p>2、新式类的变化</p>
<ul>
<li>①针对内置属性的获取：跳过实例<ul>
<li><code>__getattr__</code> 和 <code>__getattribute__</code> 通用属性拦截方法仍然通过显式名称访问属性，但不再适用于那些被内置运算隐式获取的属性。</li>
</ul>
</li>
<li>②类和类型的合并：类型检验<ul>
<li><strong>类就是类型，类型就是类</strong>； <code>type(instance)</code> 内置函数返回一个实例对应的类，与 <code>instance.__class__</code> 是相同的。</li>
</ul>
</li>
<li>③ object 自动根类：默认情况<ul>
<li>所有的新式类继承自 object 类。该类在 3.X 中被自动添加为用户定义类继承树的根（最顶级夫）类，并且不需要被显式地指定为父类。</li>
</ul>
</li>
<li>④继承搜索顺序：MRO与钻石模式<ul>
<li>多继承的钻石模式的搜索顺序更像广度优先搜索，先横向搜索再纵向搜索。这种属性搜索顺序称为 <strong>MRO</strong> ，可以用新式类中的 <code>__mro__</code> 属性来跟踪。</li>
</ul>
</li>
<li>⑤继承算法：第40章<ul>
<li>新式类所使用的继承算法比经典类的深度优先模式更加复杂，包括了描述符、元类和内置函数的特殊情况。</li>
</ul>
</li>
<li>⑥新的高级工具：代码的影响</li>
<li>新式类有一组新的类工具，包括 <strong>slot</strong> 、 <strong>property</strong> 、<strong>描述符</strong>、 <strong>super</strong> 和 <code>__getattribute__</code> 方法</li>
</ul>
<p>3、内置属性的获取将跳过实例</p>
<ul>
<li>即在新式类中，通用实例属性拦截方法 <code>__getattr__</code> 和 <code>__getattribute__</code> 不能再拦截下以 <code>__X__</code> 命名的运算符重载方法名的调用；</li>
<li>也就是说对 <code>__X__</code> 这一类名称的搜索是从类开始，而非从实例开始；</li>
<li>为什么引入搜索改变：它反映了一个由元类模型引入的难题。类现在是元类 metaclass 的实例，又因为元类可以定义内置运算符方法来处理它们生成的类；</li>
<li>所以在类上运行的方法调用必须跳过类本身，并在更高层次选择处理该类的方法，而不是选取类本身的版本；</li>
<li>类本身的版本可能会导致非绑定方法调用，因为类自身方法会处理低一层次的实例；</li>
<li>结果是类本身即是类型又是实例，因此实例在内置运算方法搜索的时候都被跳过了；</li>
<li>但非内置名称和内置名称的直接显式调用仍旧会检测实例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>): <span class="keyword">pass</span> <span class="comment"># object可有可无</span></span><br><span class="line">X = C()</span><br><span class="line"></span><br><span class="line">X.normal = <span class="keyword">lambda</span>: <span class="number">99</span> <span class="comment"># 在方法外修改实例属性</span></span><br><span class="line"><span class="built_in">print</span>(X.normal())</span><br><span class="line"></span><br><span class="line">X.__add__ = <span class="keyword">lambda</span> y: y + <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(X.__add__(<span class="number">1</span>)) <span class="comment"># 内置方法的显式调用</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>print(X + 1)</code> # 3.X 会出现 TypeError ，因为不会搜索实例的内置方法，在 2.X 得到结果89</li>
</ul>
<p>4、类型模型改变</p>
<ul>
<li><strong>类即类型</strong> Classes are types；Types are classes</li>
<li>类是由元类生成，元类要么是 type 自身，要么是由 type 定制来扩展或管理生成的类的一个子类；</li>
<li>内置的类型（比如列表、字符串）和用户定义的编写为类的类型之间没有真正的区别；</li>
<li>可以编写元类：使用 class 语句编写的用户定义 type 子类，控制作为它们的实例的类的创建：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">I = C()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(I), I.__class__) <span class="comment"># 在2.X中，类实例的类型是instance，&lt;type &#x27;instance&#x27;&gt;, I.__class__结果一样</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(C), C.__class__) <span class="comment"># 在2.X中，type(C)结果为&lt;type &#x27;classobj&#x27;&gt;，而C.__class__会出错，class C has no attribute &#x27;__class__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].__class__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">list</span>), <span class="built_in">list</span>.__class__)</span><br></pre></td></tr></table></figure>
<ul>
<li>元类，详见第40章：</li>
</ul>
<blockquote>
<p>① object 类是所有新式类的父类；<br>② type 是所有类的类；<br>③ object 类是由元类 type 创建的，但是 type 类又继承了 object 类， type 元类的类则是由 type 元类自身创建的；<br>④所以任何元素都是对象（都是 type 的实例对象），一切都继承 object ，一切皆对象。</p>
</blockquote>
<p>5、所有对象派生自 “object”</p>
<ul>
<li>所有的类都隐式或显式地继承自 object 类，并且由于所有的类型都是类，所以每个对象都派生自 object 内置类；</li>
<li>一个类实例的类型就是产生它的类，一个类的类型就是 type 类；</li>
<li>实例和类都继承自内置的 object 类：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(X, <span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(C, <span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(C.__bases__)</span><br></pre></td></tr></table></figure>
<ul>
<li>内置类型 built-in types 也是如此，内置类型也是类，它们的实例继承自 object ：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">str</span>, <span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__bases__)</span><br></pre></td></tr></table></figure>
<ul>
<li>实际上， type 自身继承自 object ，而且 object 继承自 type ，即使二者是不同对象：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">type</span>, <span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">object</span>, <span class="built_in">type</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span> <span class="keyword">is</span> <span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<p>6、钻石继承改变</p>
<ul>
<li>钻石模式指：有多于一个的父类指向同个更高级父类的树状模式（长得像钻石）；</li>
<li>① DFLR 搜索顺序：经典类<ul>
<li>深度优先 depth first ，然后从左到右 left to right （首字母：DFLR）：python 一路向上搜索，深入树的左侧，返回后才开始找右侧</li>
</ul>
</li>
<li>② MRO 搜索顺序：新式类<ul>
<li>广度优先 breadth-first ，先搜索当前父类右侧的所有其他父类，再一路往上至顶端( MRO:method resolution order )</li>
</ul>
</li>
<li>新式的 MRO 允许较底层的父类覆盖高层父类的属性：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>): attr = <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>): attr = <span class="number">2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">x = D()</span><br><span class="line"><span class="built_in">print</span>(x.attr) <span class="comment"># 在2.X中，结果为1，完整的DFLR搜索顺序为x、D, B, A, C, A</span></span><br><span class="line"><span class="comment"># 而完整的MRO搜索顺序为x、D、B、C、A</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以显式得解决冲突：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): attr = B.attr</span><br><span class="line">x = D()</span><br><span class="line"><span class="built_in">print</span>(x.attr)</span><br></pre></td></tr></table></figure>
<ul>
<li>object 父类为各种内置运算提供了默认方法，在没有 MRO 的搜索模式下，多继承中 object 的默认方法总是覆盖用户编写的类中的定制代码。</li>
</ul>
<p>7、 <code>__mro__</code> 方法</p>
<ul>
<li><code>class.__mro__</code> 方法可以跟踪新式类的默认继承方式，将返回类的 MRO 顺序；</li>
<li>一个给定类的 MRO 列表包括了类本身，它的父类，以及直到继承树顶端 object 的所有高级父类；</li>
<li>在这个列表中，每个类出现在它的父类之前，而且多个父类保持了它们在 <code>__bases__</code> 父类元组中出现的顺序</li>
<li>super 函数调用可以使用 MRO 列表中的下一个类，而这个类不一定是一个父类。</li>
<li>注意 MRO 顺序只适用于钻石继承模式，如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(D.__mro__)</span><br></pre></td></tr></table></figure>
<ul>
<li>对于非钻石继承模式，还是 DFLR ，如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(D.__mro__)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>class.mro()</code> 方法在每次类进行实例化时被调用，返回值是一个列表：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(D.mro() == <span class="built_in">list</span>(D.__mro__))</span><br></pre></td></tr></table></figure>
<h3 id="三、New-Style-Class-Extensions-Slots"><a href="#三、New-Style-Class-Extensions-Slots" class="headerlink" title="三、New-Style Class Extensions - Slots"></a>三、New-Style Class Extensions - Slots</h3><p>1、Slots : 属性声明</p>
<ul>
<li>通过将一系列的字符串属性名称赋值给特殊的 <code>__slots__</code> 类属性，可以让新式类限制实例会得到的属性集，又能优化内存和速度性能</li>
</ul>
<p>2、slot 基础</p>
<ul>
<li>只有 <code>__slots__</code> 列表内的名称可赋值为实例属性：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">limiter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;job&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x = limiter()</span><br><span class="line">x.age = <span class="number">40</span></span><br><span class="line">x.spam = <span class="number">40</span> <span class="comment"># 会出现错误：AttributeError: &#x27;limiter&#x27; object has no attribute &#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(x.age)</span><br></pre></td></tr></table></figure>
<ul>
<li>slots 最好只在有大量实例出现的、内存密集型应用的情况下使用。</li>
</ul>
<p>3、slot 与命名空间字典</p>
<ul>
<li>slot 会使类模型复杂化；</li>
<li>有些带有 slot 的实例会没有 <code>__dict__</code> 属性命名空间字典（替换命名空间字典存储），有些可能会拥有这个字典不包含的数据属性（共存）；</li>
<li>这是新式类模型和传统类模型的不兼容性，导致通用访问属性的代码复杂化，甚至让程序失败：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line">X.a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(X.a)</span><br><span class="line"><span class="built_in">print</span>(X.__dict__) <span class="comment"># 会出现错误：AttributeError: &#x27;C&#x27; object has no attribute &#x27;__dict__&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>仍然可以使用 getattr 、 setattr （不仅查找 <code>__dict__</code> ，也会查找例如 slot 的类一级名称）和 dir（会收集整个类树上所有被继承的名称）；</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(X, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">setattr</span>(X, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(X.b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(X))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(X))</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有一个属性命名空间字典，不能给不在 slot 列表中的实例赋值新的名称：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.d = <span class="number">4</span> <span class="comment"># 无法赋值，创建实例后会出错</span></span><br><span class="line"></span><br><span class="line">X = D() <span class="comment"># 会出现错误：AttributeError: &#x27;D&#x27; object has no attribute &#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以在 <code>__slots__</code> 中显式包含 <code>__dict__</code> 来创建一个属性命名空间字典：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line">    c = <span class="number">3</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">X = D()</span><br><span class="line"><span class="built_in">print</span>(X.d)</span><br><span class="line"><span class="built_in">print</span>(X.c)</span><br><span class="line">X.a = <span class="number">1</span></span><br><span class="line">X.b = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br><span class="line"><span class="built_in">print</span>(X.__slots__)</span><br></pre></td></tr></table></figure>
<p>4、父类中的多个 <code>__slots__</code> 列表</p>
<ul>
<li>slot 列表可能会不止一次出现在类树；</li>
<li>因为 slot 名称是类的一级属性（ class-level attributes ），实例按一般继承规则，获得了类树中其他位置的所有 slot 名称的并集：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">E</span>):</span><br><span class="line">    __slots__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X = D()</span><br><span class="line">X.a = <span class="number">1</span>; X.b = <span class="number">2</span>; X.c = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(X.a, X.c)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果只检测被直接继承的 slot 列表，则不能获取在类树的更高层次定义的 slot ：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(E.__slots__)</span><br><span class="line"><span class="built_in">print</span>(D.__slots__)</span><br><span class="line"><span class="built_in">print</span>(X.__slots__)</span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br></pre></td></tr></table></figure>
<ul>
<li>但是 dir 包含所有的 slot ：<code>print(dir(X))</code></li>
</ul>
<p>5、slot 使用规则</p>
<ul>
<li>slot 声明可以出现在一个类树中的多个类<ul>
<li>若父类没有 slot ，子类的 slot 就没有意义：如果子类继承自一个没有 <code>__slots__</code> 的父类，为父类创建的 <code>__dict__</code> 实例属性将总是可访问的。而避免 <code>__dict__</code> 是使用 slot 的主要原因；</li>
<li>如果子类没有 slot ，父类的 slot 也没有意义：同上</li>
<li>重新定义让父类的 slot 变得没有意义：如果一个类定义了父类中相同的 slot 名称，它的重新定义会根据一般继承规则隐藏父类中的 slot 。需要从父类获取描述符来访问父类的 slot ；</li>
<li>slot 会阻止类一级的默认名称：slot 被实现成类一级的描述符，不能在类一级中对同名类属性进行赋值。</li>
</ul>
</li>
</ul>
<h3 id="四、New-Style-Class-Extensions-Properties"><a href="#四、New-Style-Class-Extensions-Properties" class="headerlink" title="四、New-Style Class Extensions - Properties"></a>四、New-Style Class Extensions - Properties</h3><p>1、property ：属性访问器</p>
<ul>
<li>property 能自动调用（动态地）方法来访问或者赋值实例属性。功能与 Java 和 C# 语言的属性类似，但在 python 最好少用；</li>
<li>property 和 slot 都属于类一级描述符 class-level attribute descriptors ，见第38章。</li>
</ul>
<p>2、property 基础</p>
<ul>
<li>property 是一种被赋值给类属性名称的对象；</li>
<li>产生 property 的方式：调用内置函数 property ，同时传入三个访问器方法（分别用于处理获取、设置和删除操作），以及一个可选的 property 文档字符串；</li>
<li>如果任一参数以 None 传入，特性就不能支持对应操作；</li>
<li>最终得到的 property 对象，一般是在 class 顶层赋值给名称（ <code>name = property()</code> ），以及后面会说的“@”来自动化这一个步骤：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">properties</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getage</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">40</span></span><br><span class="line">    age = <span class="built_in">property</span>(getage, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>) <span class="comment"># (get, set, del, docs), or use @</span></span><br><span class="line"></span><br><span class="line">x = properties()</span><br><span class="line"><span class="built_in">print</span>(x.age) <span class="comment"># 对property名称的访问，会被自动路由到property调用的一个访问器方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>新增对属性赋值运算的支持：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">properties</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getage</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">40</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setage</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;set age: %s&#x27;</span> % value)</span><br><span class="line">        self._age = value</span><br><span class="line">    age = <span class="built_in">property</span>(getage, setage, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">x = properties()</span><br><span class="line"><span class="built_in">print</span>(x.age)</span><br><span class="line">x.age = <span class="number">42</span></span><br><span class="line"><span class="built_in">print</span>(x._age)</span><br><span class="line"><span class="built_in">print</span>(x.age)</span><br><span class="line">x.job = <span class="string">&#x27;trainer&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(x.job)</span><br></pre></td></tr></table></figure>
<ul>
<li>用函数装饰器 function decorator 来编写 property 见第38章；</li>
<li><code>__getattribute__</code> and Descriptors 描述符也是类扩展，见第38章。</li>
</ul>
<h3 id="五、Static-and-Class-Methods"><a href="#五、Static-and-Class-Methods" class="headerlink" title="五、Static and Class Methods"></a>五、Static and Class Methods</h3><p>1、静态方法和类方法介绍</p>
<ul>
<li>静态方法大致与类中简单无实例函数的工作方法类似，而类方法被传入一个类而不是一个实例；</li>
<li>要使用这些方法，要在类中调用特殊的内置函数：<code>staticmethod</code> 和 <code>classmethod</code> ，或使用 <code>“@name”</code> 装饰语法；</li>
<li>在 python 3.X 中，无实例的方法只通过一个类名调用，而不需要一个 <code>staticmethod</code> 申明，但要实例来调用，仍然需要。</li>
</ul>
<p>①静态方法：嵌套在类中的没有 self 参数的简单函数；<br>②类方法：传入方法的第一个参数不是实例对象，而是类对象；<br>③实例方法：即常规方法，需要接受实例。</p>
<p>2、Python 2.X 和 3.X 中的静态方法<br>①在 Python 2.X 和 3.X 中，当一个方法通过实例被获取的时候，会产生一个绑定方法；<br>②在 Python 2.X 中，从一个类中获取一个方法会产生一个非绑定方法，如果不手动地传入一个实例就不能调用这个方法；<br>③在 Python 3.X 中，从一个类中获取一个方法会产生一个简单函数，该函数在没有传入一个实例的时候也可以正常被调用；<br>④在 Python 2.X 中，必须总是把一个方法声明为静态的，才能不传入实例来调用它，不管是通过类还是实例调用；<br>⑤在 Python 3.X 中，如果一个方法只通过一个类调用，不需要声明为静态的。但是要通过实例来调用，必须声明为静态的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>: <span class="comment"># 类实例计数器</span></span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.numInstances = Spam.numInstances + <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Number of instances created: %s&quot;</span> % Spam.numInstances)</span><br><span class="line"></span><br><span class="line">a = Spam()</span><br><span class="line">b = Spam()</span><br><span class="line">c = Spam()</span><br><span class="line"></span><br><span class="line">Spam.printNumInstances()</span><br><span class="line">a.printNumInstances() <span class="comment"># 会出现错误：TypeError: Spam.printNumInstances() takes 0 positional arguments but 1 was given</span></span><br></pre></td></tr></table></figure>
<ul>
<li>以下为上述例子的常规方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.numInstances = Spam.numInstances + <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Number of instances created: %s&quot;</span> % Spam.numInstances)</span><br><span class="line"></span><br><span class="line">a, b, c = Spam(), Spam(), Spam()</span><br><span class="line">a.printNumInstances()</span><br><span class="line">Spam.printNumInstances(a)</span><br><span class="line">Spam().printNumInstances()</span><br></pre></td></tr></table></figure>
<p>3、内置函数 <code>staticmethod</code> 和 <code>classmethod</code></p>
<ul>
<li>静态方法不需要实例，类方法需要一个类参数：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Methods</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">imeth</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="built_in">print</span>([self, x])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smeth</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">print</span>([x])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cmeth</span>(<span class="params">cls, x</span>):</span><br><span class="line">        <span class="built_in">print</span>([cls, x])</span><br><span class="line">    </span><br><span class="line">    smeth = <span class="built_in">staticmethod</span>(smeth)</span><br><span class="line">    cmeth = <span class="built_in">classmethod</span>(cmeth)</span><br><span class="line"><span class="comment"># 常规实例方法</span></span><br><span class="line">obj = Methods()</span><br><span class="line">obj.imeth(<span class="number">1</span>)</span><br><span class="line">Methods.imeth(obj, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 静态方法</span></span><br><span class="line">Methods.smeth(<span class="number">3</span>)</span><br><span class="line">obj.smeth(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 类方法：python自动将类传入类方法的第一位，不管是类调用还是实例调用</span></span><br><span class="line">Methods.cmeth(<span class="number">5</span>)</span><br><span class="line">obj.cmeth(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>4、子类继承并定制静态方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.numInstances += <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Number of instances: %s&quot;</span> % Spam.numInstances)</span><br><span class="line">    printNumInstances = <span class="built_in">staticmethod</span>(printNumInstances)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Spam</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Extra stuff...&quot;</span>)</span><br><span class="line">        Spam.printNumInstances()</span><br><span class="line">    printNumInstances = <span class="built_in">staticmethod</span>(printNumInstances)</span><br><span class="line"></span><br><span class="line">a = Sub()</span><br><span class="line">b = Sub()</span><br><span class="line">a.printNumInstances()</span><br><span class="line">Sub.printNumInstances()</span><br><span class="line">Spam.printNumInstances() <span class="comment"># 调用父类的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>(<span class="title class_ inherited__">Spam</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">c = Other()</span><br><span class="line">c.printNumInstances() <span class="comment"># 这里会打印出3，是因为子类都是继承了父类的构造方法</span></span><br></pre></td></tr></table></figure>
<p>5、继承类方法</p>
<ul>
<li>类方法接受的是调用主体的最直接的类：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.numInstances += <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Number of instances: %s %s&quot;</span> % (cls.numInstances, cls))</span><br><span class="line">    printNumInstances = <span class="built_in">classmethod</span>(printNumInstances)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Spam</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Extra stuff...&quot;</span>, cls)</span><br><span class="line">        Spam.printNumInstances()</span><br><span class="line">    printNumInstances = <span class="built_in">classmethod</span>(printNumInstances)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>(<span class="title class_ inherited__">Spam</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">x = Sub()</span><br><span class="line">y = Spam()</span><br><span class="line">x.printNumInstances() <span class="comment"># 子类的实例调用类方法，传入了sub，又由于Sub显式调用了Spam父类，故父类方法接受了父类自己</span></span><br><span class="line">Sub.printNumInstances()</span><br><span class="line">y.printNumInstances()</span><br><span class="line"></span><br><span class="line">z = Other()</span><br><span class="line">z.printNumInstances()</span><br></pre></td></tr></table></figure>
<p>6、由于类总是接受实例树中最底层（lowest）的类</p>
<ul>
<li>因此更适合处理同一类树中的各个类之间相互区别的数据，比如为每个类管理实例计数器：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">cls</span>):</span><br><span class="line">        cls.numInstances += <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.count()</span><br><span class="line">    count = <span class="built_in">classmethod</span>(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Spam</span>):</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.__init__(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>(<span class="title class_ inherited__">Spam</span>):</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">x = Spam()</span><br><span class="line">y1, y2 = Sub(), Sub()</span><br><span class="line">z1, z2, z3 = Other(), Other(), Other()</span><br><span class="line"><span class="built_in">print</span>(x.numInstances, y1.numInstances, z1.numInstances)</span><br><span class="line"><span class="built_in">print</span>(Spam.numInstances, Sub.numInstances, Other.numInstances)</span><br></pre></td></tr></table></figure>
<h3 id="六、Decorators-and-Metaclasses-Part-1"><a href="#六、Decorators-and-Metaclasses-Part-1" class="headerlink" title="六、Decorators and Metaclasses: Part 1"></a>六、Decorators and Metaclasses: Part 1</h3><p>1、装饰器介绍<br>①<strong>函数装饰器 Function decorators</strong>：同时为简单函数和类方法指明了特殊运算模式，通过把简单函数和类方法包在一层额外的逻辑实现中，也称为元函数 metafunction；<br>②<strong>类装饰器Class decorators</strong>：为类添加管理全体对象和其接口的支持。  </p>
<p>python 提供一些内置的函数装饰器，程序员也可以自己编写定制装饰器，装饰器不是严格地被要求写成类，但是通常被编写成类</p>
<p>2、函数装饰器基础</p>
<ul>
<li>函数装饰器可以看作是它跟在后面的函数的运行时声明；</li>
<li>它包含 <strong>“@”</strong> 符号，和跟着后面的元函数 metafunction（管理另一函数的函数）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.numInstances = Spam.numInstances + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod </span><span class="comment"># 跟写在后面的printNumInstances = staticmethod(printNumInstances)一样</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Number of instances created: %s&quot;</span> % Spam.numInstances)</span><br><span class="line"></span><br><span class="line">a = Spam()</span><br><span class="line">b = Spam()</span><br><span class="line">c = Spam()</span><br><span class="line">Spam.printNumInstances()</span><br><span class="line">a.printNumInstances()</span><br></pre></td></tr></table></figure>
<ul>
<li>因为 <code>classmethod</code> 和 <code>property</code> 内置函数也接受和返回函数，也能用作装饰器：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Methods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">imeth</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="built_in">print</span>([self, x])</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smeth</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">print</span>([x])</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cmeth</span>(<span class="params">cls, x</span>):</span><br><span class="line">        <span class="built_in">print</span>([cls, x])</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Bob &#x27;</span> + self.__class__.__name__</span><br><span class="line"></span><br><span class="line">obj = Methods()</span><br><span class="line">obj.imeth(<span class="number">1</span>)</span><br><span class="line">obj.smeth(<span class="number">2</span>)</span><br><span class="line">obj.cmeth(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure>
<p>3、用户定义函数装饰器</p>
<ul>
<li>下面的代码在实例中存储被装饰的函数，并捕获对原来函数名的调用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.calls = <span class="number">0</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        self.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (self.calls, self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer </span><span class="comment"># Same as spam = tracer(spam)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(spam(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>4、类装饰器和元类</p>
<ul>
<li>同理，在类前面的装饰器 <code>@decorator</code> 等同于在 class 语句后面的 <code>Class = decorator(Class)</code>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">aClass</span>):</span><br><span class="line">    aClass.numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> aClass</span><br><span class="line"></span><br><span class="line"><span class="meta">@count</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.numInstances += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@count</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Spam</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.__init__(self)</span><br><span class="line">        Sub.numInstances += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a = Spam()</span><br><span class="line">b = Sub()</span><br><span class="line"><span class="built_in">print</span>(a.numInstances, Spam.numInstances)</span><br><span class="line"><span class="built_in">print</span>(b.numInstances, Sub.numInstances)</span><br></pre></td></tr></table></figure>
<ul>
<li>类装饰器也可以通过拦截构造函数，并将实例对象包在一个代理中，管理实例的全部接口；</li>
<li>详见第39章，下面是模型的预习：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Proxy</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args</span>):</span><br><span class="line">            self.wrapped = cls(*args)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, name)</span><br><span class="line">    <span class="keyword">return</span> Proxy</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: ...</span><br><span class="line">X = C()</span><br></pre></td></tr></table></figure>
<ul>
<li>元类能把一个类对象的创建路由到顶级 type 类的一个子类，见第40章。</li>
</ul>
<h3 id="七、The-super-Built-in-Function"><a href="#七、The-super-Built-in-Function" class="headerlink" title="七、The super Built-in Function"></a>七、The super Built-in Function</h3><p>1、传统的父类调用形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">C</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>):</span><br><span class="line">        C.act(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = D()</span><br><span class="line">X.act()</span><br></pre></td></tr></table></figure>
<p>2、super 的基础用法</p>
<ul>
<li>super 通过检测调用栈来自动定位 self 参数和寻找父类，并且将 self 参数和父类配对在一个特殊的代理对象中，从而将之后的调用路由到父类方法；</li>
<li>但 super 函数后面的没有 self ：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">C</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().act()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = D()</span><br><span class="line">X.act()</span><br></pre></td></tr></table></figure>
<p>3、局限性：多继承</p>
<ul>
<li>super 函数是钻石多继承树中的协同多继承分发协议，依赖于 MRO 算法；</li>
<li>钻石多继承树中的协同多继承分发协议：cooperative multiple inheritance dispatch protocols in diamond multiple-inheritance trees。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().act()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, A):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().act()</span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line">X.act() <span class="comment"># super根据MRO顺序，找到最左边的带有该方法的类</span></span><br><span class="line">Y = D()</span><br><span class="line">Y.act() <span class="comment"># 同理</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在多继承中，能用传统继承就用传统继承，因为 super 只能继承一个。</li>
</ul>
<p>4、super的优势：继承树的修改与分发<br>①在运行时改变父类：可以通过super来分发调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;X.m&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;Y.m&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">X</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m</span>(<span class="params">self</span>): <span class="built_in">super</span>().m()</span><br><span class="line"></span><br><span class="line">i = C()</span><br><span class="line">i.m()</span><br><span class="line">C.__bases__ = (Y,)</span><br><span class="line">i.m()</span><br></pre></td></tr></table></figure>
<p>②协同多继承方法的分发：当多继承树对多个类的同名函数进行分发时，super 提供一种顺序调用路由的协议；</p>
<ul>
<li>钻石类树模型下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;A.__init__&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;B.__init__&#x27;</span>); A.__init__(self)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;C.__init__&#x27;</span>); A.__init__(self)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">x = D() <span class="comment"># 运行B</span></span><br></pre></td></tr></table></figure>
<ul>
<li>相比之下，如果所有类都使用super，方法调用将按照 MRO 类顺序分发：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;A.__init__&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;B.__init__&#x27;</span>); <span class="built_in">super</span>().__init__()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;C.__init__&#x27;</span>); <span class="built_in">super</span>().__init__()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">x = D()</span><br></pre></td></tr></table></figure>
<ul>
<li>上面先运行 B ，而 B 中的 super() 是按照 D 的 MRO 顺序（D、B、C、A）来的，所以 B 中的 super() 会运行 C ，再 C 的 super() 运行 A ；</li>
<li>故结果是 <code>B.__init__、C.__init__、A.__init__</code>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(D.__mro__)</span><br></pre></td></tr></table></figure>
<ul>
<li>只要所有类都采用了 super 调用，通过在 MRO 序列下选择下一个类，一个类方法的 super 调用就能在类树上传递调用；</li>
<li>总之， super 要么不用，要么全用，最好不用。</li>
</ul>
<p>5、相同参数限制</p>
<ul>
<li>若方法参数随着类不同而变化时，使用 super 会让程序员很难确定 super 选择的版本（实际上会随着类树而变化）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, salary</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.salary = salary</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chef</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, <span class="number">50000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, <span class="number">40000</span>)</span><br><span class="line"></span><br><span class="line">bob = Chef(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">sue = Server(<span class="string">&#x27;Sue&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.salary, sue.salary)</span><br></pre></td></tr></table></figure>
<ul>
<li>上面没问题，因为是单继承树；</li>
<li>但如果<code>class TwoJobs(Chef, Server): pass</code>，再<code>tom = TwoJobs(&#39;Tom&#39;)</code>，会出错误：<code>TypeError: __init__() takes 2 positional arguments but 3 were given</code>。</li>
</ul>
<h3 id="八、Class-Gotchas"><a href="#八、Class-Gotchas" class="headerlink" title="八、Class Gotchas"></a>八、Class Gotchas</h3><p>1、修改类属性</p>
<ul>
<li>所有从类产生的实例都共享这个类的命名空间，所以对类层次的修改都会反映在实例里：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>:</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">I = X()</span><br><span class="line"><span class="built_in">print</span>(I.a)</span><br><span class="line"><span class="built_in">print</span>(X.a)</span><br><span class="line"><span class="comment"># class语句外修改类属性</span></span><br><span class="line">X.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(I.a)</span><br><span class="line"><span class="built_in">print</span>(X.a)</span><br></pre></td></tr></table></figure>
<p>2、修改可变的类属性，比如列表</p>
<ul>
<li>因为类属性被所有实例共享，如果一个类属性引用一个可变对象，那么任何实例在原位置修改该对象会影响到所有实例和类：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    shared = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.perobj = []</span><br><span class="line"></span><br><span class="line">x = C()</span><br><span class="line">y = C()</span><br><span class="line"><span class="built_in">print</span>(y.shared, y.perobj)</span><br><span class="line">x.shared.append(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">x.perobj.append(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x.shared, x.perobj)</span><br><span class="line"><span class="built_in">print</span>(y.shared, y.perobj)</span><br><span class="line"><span class="built_in">print</span>(C.shared)</span><br></pre></td></tr></table></figure>
<p>3、方法和类中的作用域</p>
<ul>
<li>类 Spam 是在 generate 函数的局部作用域中赋值的，所以能被内嵌的函数看到，即 LEGB 作用域的 E ：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>():</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(Spam.count)</span><br><span class="line">    <span class="keyword">return</span> Spam()</span><br><span class="line"></span><br><span class="line">generate().method()</span><br></pre></td></tr></table></figure>
<ul>
<li>尽管如此， method 方法是看不到外层类的局部作用域， method 方法只看得到外层 def 的局部作用域；</li>
<li>这也是为什么方法得通过 self 实例，或类名称来引用外层类定义得方法或属性；</li>
<li>即必须使用 self.count 或 Spam.count ，而不是 count ；</li>
<li>method 方法能够访问：它自己的作用域、外层函数的作用域、外围模块的全局作用域、所有存储在类的 self 实例的数据，以及它的非局部名称的类本身。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io">鸟布</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io/2022/10/24/2022-10-24-Learning-python3/">https://ybniaobu.github.io/2022/10/24/2022-10-24-Learning-python3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ybniaobu.github.io" target="_blank">鸟布的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/11/27/R9htYK5LyFuEGTk.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src="/images/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/27/2022-10-27-Learning-python4/" title="《Learning Python》读书笔记（四）"><img class="cover" src="https://s2.loli.net/2022/11/27/R9htYK5LyFuEGTk.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《Learning Python》读书笔记（四）</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/21/2022-10-21-Learning-python2/" title="《Learning Python》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2022/11/27/R9htYK5LyFuEGTk.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《Learning Python》读书笔记（二）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/09/09/2022-09-09-Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="《Python编程从入门到实践》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2022/11/27/h9RxCDEfGAM53j4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-09</div><div class="title">《Python编程从入门到实践》读书笔记（一）</div></div></a></div><div><a href="/2022/09/12/2022-09-12-Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" title="《Python编程从入门到实践》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2022/11/27/h9RxCDEfGAM53j4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">《Python编程从入门到实践》读书笔记（二）</div></div></a></div><div><a href="/2022/10/21/2022-10-21-Learning-python2/" title="《Learning Python》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2022/11/27/R9htYK5LyFuEGTk.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-21</div><div class="title">《Learning Python》读书笔记（二）</div></div></a></div><div><a href="/2022/10/27/2022-10-27-Learning-python4/" title="《Learning Python》读书笔记（四）"><img class="cover" src="https://s2.loli.net/2022/11/27/R9htYK5LyFuEGTk.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-27</div><div class="title">《Learning Python》读书笔记（四）</div></div></a></div><div><a href="/2022/09/17/2022-09-17-Learning-python1/" title="《Learning Python》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2022/11/27/R9htYK5LyFuEGTk.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-17</div><div class="title">《Learning Python》读书笔记（一）</div></div></a></div><div><a href="/2022/11/24/2022-11-24-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B1/" title="《C#图解教程》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-24</div><div class="title">《C#图解教程》读书笔记（一）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/wechat%20avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鸟布</div><div class="author-info__description">教练，我想学技术</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://niaobu.notion.site/787824630ea6480e944c1ae5ae7f4792"><i class="fa-solid fa-book"></i><span>My Notion</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ybniaobu/ybniaobu.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:niaobubob@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为了蒂法！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PART-V-Modules-and-Packages"><span class="toc-number">1.</span> <span class="toc-text">PART V Modules and Packages</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-22-Modules-The-Big-Picture"><span class="toc-number">1.1.</span> <span class="toc-text">chapter 22 Modules: The Big Picture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Python-Program-Architecture"><span class="toc-number">1.1.1.</span> <span class="toc-text">一、Python Program Architecture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81The-Module-Search-Path"><span class="toc-number">1.1.2.</span> <span class="toc-text">二、The Module Search Path</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-23-Module-Coding-Basics"><span class="toc-number">1.2.</span> <span class="toc-text">chapter 23 Module Coding Basics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Module-Creation-and-Usage"><span class="toc-number">1.2.1.</span> <span class="toc-text">一、Module Creation and Usage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Module-Namespaces"><span class="toc-number">1.2.2.</span> <span class="toc-text">二、Module Namespaces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Reloading-Modules"><span class="toc-number">1.2.3.</span> <span class="toc-text">三、Reloading Modules</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-24-Module-Packages"><span class="toc-number">1.3.</span> <span class="toc-text">chapter 24 Module Packages</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Package-Import-Basics"><span class="toc-number">1.3.1.</span> <span class="toc-text">一、Package Import Basics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Package-Import-Example"><span class="toc-number">1.3.2.</span> <span class="toc-text">二、Package Import Example</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Package-Relative-Imports"><span class="toc-number">1.3.3.</span> <span class="toc-text">三、Package Relative Imports</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Namespace-Packages"><span class="toc-number">1.3.4.</span> <span class="toc-text">四、Namespace Packages</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-25-Advanced-Module-Topics"><span class="toc-number">1.4.</span> <span class="toc-text">chapter 25 Advanced Module Topics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Module-Design-Concepts"><span class="toc-number">1.4.1.</span> <span class="toc-text">一、Module Design Concepts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Built-in-Attribute-name"><span class="toc-number">1.4.2.</span> <span class="toc-text">二、Built-in Attribute __name__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Other-Advanced-Module-related-Topics"><span class="toc-number">1.4.3.</span> <span class="toc-text">三、Other Advanced Module-related Topics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Module-Gotchas"><span class="toc-number">1.4.4.</span> <span class="toc-text">四、Module Gotchas</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PART-VI-Classes-and-OOP"><span class="toc-number">2.</span> <span class="toc-text">PART VI Classes and OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-26-OOP-The-Big-Picture"><span class="toc-number">2.1.</span> <span class="toc-text">chapter 26 OOP: The Big Picture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81OOP-and-Class"><span class="toc-number">2.1.1.</span> <span class="toc-text">一、OOP and Class</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-27-Class-Coding-Basics"><span class="toc-number">2.2.</span> <span class="toc-text">chapter 27 Class Coding Basics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Classes-Generate-Multiple-Instance-Objects"><span class="toc-number">2.2.1.</span> <span class="toc-text">一、Classes Generate Multiple Instance Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Classes-Are-Customized-by-Inheritance"><span class="toc-number">2.2.2.</span> <span class="toc-text">二、Classes Are Customized by Inheritance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Classes-Can-Intercept-Python-Operators"><span class="toc-number">2.2.3.</span> <span class="toc-text">三、Classes Can Intercept Python Operators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81The-World%E2%80%99s-Simplest-Python-Class"><span class="toc-number">2.2.4.</span> <span class="toc-text">四、The World’s Simplest Python Class</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-28-A-More-Realistic-Example"><span class="toc-number">2.3.</span> <span class="toc-text">chapter 28 A More Realistic Example</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Example-of-Classes"><span class="toc-number">2.3.1.</span> <span class="toc-text">一、Example of Classes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-29-Class-Coding-Details"><span class="toc-number">2.4.</span> <span class="toc-text">chapter 29 Class Coding Details</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81The-class-Statement"><span class="toc-number">2.4.1.</span> <span class="toc-text">一、The class Statement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Methods"><span class="toc-number">2.4.2.</span> <span class="toc-text">二、Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Inheritance"><span class="toc-number">2.4.3.</span> <span class="toc-text">三、Inheritance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Namespaces-The-Conclusion"><span class="toc-number">2.4.4.</span> <span class="toc-text">四、Namespaces: The Conclusion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81Namespace-Dictionaries-Review"><span class="toc-number">2.4.5.</span> <span class="toc-text">五、Namespace Dictionaries: Review</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81Documentation-Strings-Revisited"><span class="toc-number">2.4.6.</span> <span class="toc-text">六、Documentation Strings Revisited</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-30-Class-Coding-Details"><span class="toc-number">2.5.</span> <span class="toc-text">chapter 30 Class Coding Details</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81The-Basics"><span class="toc-number">2.5.1.</span> <span class="toc-text">一、The Basics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Indexing-and-Slicing-getitem-and-setitem"><span class="toc-number">2.5.2.</span> <span class="toc-text">二、Indexing and Slicing: __getitem__ and __setitem__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Iterable-Objects-iter-and-next"><span class="toc-number">2.5.3.</span> <span class="toc-text">三、Iterable Objects: __iter__ and __next__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Membership-contains-iter-and-getitem"><span class="toc-number">2.5.4.</span> <span class="toc-text">四、Membership: __contains__, __iter__, and __getitem__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81Attribute-Access-getattr-and-setattr"><span class="toc-number">2.5.5.</span> <span class="toc-text">五、Attribute Access: __getattr__ and __setattr__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81String-Representation-repr-and-str"><span class="toc-number">2.5.6.</span> <span class="toc-text">六、String Representation: __repr__ and __str__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81Right-Side-and-In-Place-Uses-radd-and-iadd"><span class="toc-number">2.5.7.</span> <span class="toc-text">七、Right-Side and In-Place Uses: __radd__ and __iadd__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81Other-Operator-Overloading"><span class="toc-number">2.5.8.</span> <span class="toc-text">八、Other Operator Overloading</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-31-Designing-with-Classes"><span class="toc-number">2.6.</span> <span class="toc-text">chapter 31 Designing with Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Python-and-OOP"><span class="toc-number">2.6.1.</span> <span class="toc-text">一、Python and OOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Pseudoprivate-Class-Attributes"><span class="toc-number">2.6.2.</span> <span class="toc-text">二、Pseudoprivate Class Attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Methods-Are-Objects-Bound-or-Unbound"><span class="toc-number">2.6.3.</span> <span class="toc-text">三、Methods Are Objects: Bound or Unbound</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Classes-Are-Objects-Generic-Object-Factories"><span class="toc-number">2.6.4.</span> <span class="toc-text">四、Classes Are Objects: Generic Object Factories</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81Multiple-Inheritance-%E2%80%9CMix-in%E2%80%9D-Classes"><span class="toc-number">2.6.5.</span> <span class="toc-text">五、Multiple Inheritance: “Mix-in” Classes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-32-Advanced-Class-Topics"><span class="toc-number">2.7.</span> <span class="toc-text">chapter 32 Advanced Class Topics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Extending-Built-in-Types"><span class="toc-number">2.7.1.</span> <span class="toc-text">一、Extending Built-in Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81The-%E2%80%9CNew-Style%E2%80%9D-Class-Model"><span class="toc-number">2.7.2.</span> <span class="toc-text">二、The “New Style” Class Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81New-Style-Class-Extensions-Slots"><span class="toc-number">2.7.3.</span> <span class="toc-text">三、New-Style Class Extensions - Slots</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81New-Style-Class-Extensions-Properties"><span class="toc-number">2.7.4.</span> <span class="toc-text">四、New-Style Class Extensions - Properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81Static-and-Class-Methods"><span class="toc-number">2.7.5.</span> <span class="toc-text">五、Static and Class Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81Decorators-and-Metaclasses-Part-1"><span class="toc-number">2.7.6.</span> <span class="toc-text">六、Decorators and Metaclasses: Part 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81The-super-Built-in-Function"><span class="toc-number">2.7.7.</span> <span class="toc-text">七、The super Built-in Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81Class-Gotchas"><span class="toc-number">2.7.8.</span> <span class="toc-text">八、Class Gotchas</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/01/2025-08-01-SSAO1/" title="屏幕空间环境光遮蔽（一）SSAO"><img src="https://s2.loli.net/2025/08/01/287gfDiMYRFrmUs.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="屏幕空间环境光遮蔽（一）SSAO"/></a><div class="content"><a class="title" href="/2025/08/01/2025-08-01-SSAO1/" title="屏幕空间环境光遮蔽（一）SSAO">屏幕空间环境光遮蔽（一）SSAO</a><time datetime="2025-08-01T04:54:23.000Z" title="发表于 2025-08-01 12:54:23">2025-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/21/2025-06-21-TAA/" title="Temporal Anti-Aliasing (TAA)"><img src="https://s2.loli.net/2025/06/23/kEPO3zg8IRXwUFC.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Temporal Anti-Aliasing (TAA)"/></a><div class="content"><a class="title" href="/2025/06/21/2025-06-21-TAA/" title="Temporal Anti-Aliasing (TAA)">Temporal Anti-Aliasing (TAA)</a><time datetime="2025-06-21T11:43:03.000Z" title="发表于 2025-06-21 19:43:03">2025-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/08/2025-06-08-TileBasedLightCulling/" title="Tile-Based Light Culling"><img src="https://s2.loli.net/2025/06/08/1hF5QplnZjxBvJS.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tile-Based Light Culling"/></a><div class="content"><a class="title" href="/2025/06/08/2025-06-08-TileBasedLightCulling/" title="Tile-Based Light Culling">Tile-Based Light Culling</a><time datetime="2025-06-08T05:03:10.000Z" title="发表于 2025-06-08 13:03:10">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/29/2025-04-29-CustomSRP8/" title="Unity Custom SRP 基础（八）"><img src="https://s2.loli.net/2025/04/29/IHYjvyKDR2uoGEt.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（八）"/></a><div class="content"><a class="title" href="/2025/04/29/2025-04-29-CustomSRP8/" title="Unity Custom SRP 基础（八）">Unity Custom SRP 基础（八）</a><time datetime="2025-04-29T12:00:38.000Z" title="发表于 2025-04-29 20:00:38">2025-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/07/2025-04-07-CustomSRP7/" title="Unity Custom SRP 基础（七）"><img src="https://s2.loli.net/2025/04/07/2zi6pj3XtAPHvmy.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（七）"/></a><div class="content"><a class="title" href="/2025/04/07/2025-04-07-CustomSRP7/" title="Unity Custom SRP 基础（七）">Unity Custom SRP 基础（七）</a><time datetime="2025-04-07T12:57:36.000Z" title="发表于 2025-04-07 20:57:36">2025-04-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By 鸟布</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Your time is limited, so don't waste it living someone else's life.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>