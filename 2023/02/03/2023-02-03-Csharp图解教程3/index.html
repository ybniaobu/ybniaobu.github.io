<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《C#图解教程》读书笔记（三） | 鸟布的博客</title><meta name="author" content="鸟布"><meta name="copyright" content="鸟布"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本篇主要内容为：接口；转换；泛型；枚举器和迭代器；LINQ 。读书笔记仅为知识的记录，方便后续查找。学习完成日期为2023年07月29日。          第十六章 接口什么是接口接口 interface是指定一组函数成员但不实现它们的引用类型，所以只能用类和结构来实现接口。 接口的用途可以通过"><link rel="shortcut icon" href="https://s2.loli.net/2022/09/08/Ygib4lfw6z1khnr.png"><link rel="canonical" href="https://ybniaobu.github.io/2023/02/03/2023-02-03-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 鸟布","link":"链接: ","source":"来源: 鸟布的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《C#图解教程》读书笔记（三）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-29 20:14:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/wechat%20avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/black.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鸟布的博客"><span class="site-name">鸟布的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《C#图解教程》读书笔记（三）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-03T11:53:13.000Z" title="发表于 2023-02-03 19:53:13">2023-02-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-29T12:14:40.000Z" title="更新于 2023-07-29 20:14:40">2023-07-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C#</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">C#读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>105分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《C#图解教程》读书笔记（三）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本篇主要内容为：接口；转换；泛型；枚举器和迭代器；LINQ 。<br>读书笔记仅为知识的记录，方便后续查找。<br>学习完成日期为2023年07月29日。  </p>
</blockquote>
<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

<h1 id="第十六章-接口"><a href="#第十六章-接口" class="headerlink" title="第十六章 接口"></a>第十六章 接口</h1><h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p><strong>接口 interface</strong>是指定一组函数成员但不实现它们的引用类型，所以只能用类和结构来实现接口。</p>
<p>接口的用途可以通过下面2个例子介绍，第一个例子不使用接口：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">CB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> First;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Last;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> PersonsAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintInfo</span>(<span class="params"> CA item </span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123; item.Name &#125;</span>, Age: <span class="subst">&#123; item.Age &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        CA a = <span class="keyword">new</span> CA() &#123; Name = <span class="string">&quot;John Doe&quot;</span>, Age = <span class="number">35</span> &#125;;</span><br><span class="line">        PrintInfo( a );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码只要传入 CA 类型对象，PrintInfo 方法就能工作正常。但传入 CB 类型对象就不行，而且 CB 的结构、字段名称和类型都可能与 CA 不一样。而接口可以使不管传入 PrintInfo 的类的结构是什么样的，都能正常处理：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetName</span>()</span>; <span class="comment">//返回string的方法</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetAge</span>()</span>; <span class="comment">//返回string的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">CA</span> : <span class="title">IInfo</span> <span class="comment">//声明实现接口的CA类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123; <span class="keyword">return</span> Name; &#125; <span class="comment">//实现两个接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetAge</span>()</span> &#123; <span class="keyword">return</span> Age.ToString( ); &#125; <span class="comment">//实现两个接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">CB</span> : <span class="title">IInfo</span> <span class="comment">//声明实现接口的CB类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> First;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Last;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> PersonsAge;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123; <span class="keyword">return</span> First + <span class="string">&quot; &quot;</span> + Last; &#125; <span class="comment">//实现两个接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetAge</span>()</span> &#123; <span class="keyword">return</span> PersonsAge.ToString(); &#125; <span class="comment">//实现两个接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintInfo</span>(<span class="params"> IInfo item </span>) <span class="comment">//传入接口的引用</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Name:&#123;0&#125;, Age &#123;1&#125;&quot;</span>, item.GetName(), item.GetAge() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CA a = <span class="keyword">new</span> CA() &#123; Name = <span class="string">&quot;John Doe&quot;</span>, Age = <span class="number">35</span> &#125;;</span><br><span class="line">        CB b = <span class="keyword">new</span> CB() &#123; First = <span class="string">&quot;Jane&quot;</span>, Last = <span class="string">&quot;Doe&quot;</span>, PersonsAge = <span class="number">33</span> &#125;;</span><br><span class="line"></span><br><span class="line">        PrintInfo(a); <span class="comment">//对象的引用能自动转换为它们实现的接口的引用</span></span><br><span class="line">        PrintInfo(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Name:John Doe, Age 35</span><br><span class="line">Name:Jane Doe, Age 33</span><br></pre></td></tr></table></figure>
<h3 id="使用-IComparable-接口的示例"><a href="#使用-IComparable-接口的示例" class="headerlink" title="使用 IComparable 接口的示例"></a>使用 IComparable 接口的示例</h3><p>通过以下示例来更好地了解接口：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myInt = <span class="keyword">new</span> [] &#123; <span class="number">20</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">2</span> &#125;; <span class="comment">//创建int数组</span></span><br><span class="line"></span><br><span class="line">Array.Sort(myInt); <span class="comment">//按大小排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> myInt) <span class="comment">//输出</span></span><br><span class="line">    Console.Write(<span class="string">$&quot;<span class="subst">&#123; i &#125;</span> &quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Array 类的 Sort 方法可以运行在 int 数组上，但是在类数组上无法运行，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TheValue;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">MyClass[] mc = <span class="keyword">new</span> MyClass[<span class="number">5</span>]; <span class="comment">//创建有5个元素的数组</span></span><br><span class="line">    ...</span><br><span class="line">Array.Sort(mc); <span class="comment">//尝试使用Sort时抛出异常</span></span><br></pre></td></tr></table></figure>
<p>Array 类的 Sort 方法实际上依赖一个叫做 <strong>IComparable</strong> 的接口，它声明在 BCL 中，包含唯一的方法 CompareTo 。下面代码展示了 IComparable 接口的声明，包含 CompareTo 方法的声明，该方法接受一个 object 类型的参数，并且没有实现，即实现用分号表示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IComparable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params"> <span class="built_in">object</span> obj </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管在接口声明中没有为 CompareTo 方法提供实现，但 IComparable 接口的 .NET 文档描述了该方法应该做的事情。在调用 CompareTo 方法时，它应该返回以下几个值之一：<br>①负数值，如果当前对象小于参数对象；<br>②正数值，如果当前对象大于参数对象；<br>③零，如果两个对象在比较时相等。</p>
<p>Sort 使用的算法依赖于使用元素的 CompareTo 方法来决定两个元素的次序，int 类型实现了 IComparable，但是 MyClass 没有。我们可以通过让类实现 IComparable，让 Sort 方法可以用于 MyClass 类型的对象。要实现这一接口，类或结构要①在基类列表中列出接口名称，②为接口的每一个成员提供实现。如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IComparable</span> <span class="comment">//基类列表中的接口名称</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TheValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params"><span class="built_in">object</span> obj</span>) <span class="comment">//实现CompareTo方法以遵循接口文档的定义，参数类型和返回类型与接口成员一致</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = (MyClass)obj;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.TheValue &lt; mc.TheValue) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.TheValue &gt; mc.TheValue) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图，展示了更新后的类，从有阴影的接口方法指向类方法的箭头表示接口方法不包含代码，而是在类级别的方法实现：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/04/jeamyQVskX6HzAR.png" width = "60%" height = "60%" alt="图71 - 在MyClass中实现IComparable"/>
</div>

<p>既然 MyClass 实现了 IComparable 接口，就可以使用 Sort 了，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IComparable</span> <span class="comment">//类实现接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TheValue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params"><span class="built_in">object</span> obj</span>) <span class="comment">//实现方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = (MyClass)obj;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.TheValue &lt; mc.TheValue) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.TheValue &gt; mc.TheValue) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s, MyClass[] mc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(s);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> m <span class="keyword">in</span> mc)</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; m.TheValue &#125;</span> &quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> myInt = <span class="keyword">new</span> [] &#123; <span class="number">20</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">        MyClass[] mcArr = <span class="keyword">new</span> MyClass[<span class="number">5</span>]; <span class="comment">//创建MyClass对象的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) <span class="comment">//初始化数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            mcArr[i] = <span class="keyword">new</span> MyClass();</span><br><span class="line">            mcArr[i].TheValue = myInt[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PrintOut(<span class="string">&quot;Initial Order: &quot;</span>, mcArr);</span><br><span class="line">        Array.Sort(mcArr);</span><br><span class="line">        PrintOut(<span class="string">&quot;Sorted Order: &quot;</span>, mcArr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Initial Order: 20 4 16 9 2 </span><br><span class="line">Sorted Order: 2 4 9 16 20 </span><br></pre></td></tr></table></figure>
<h2 id="声明接口"><a href="#声明接口" class="headerlink" title="声明接口"></a>声明接口</h2><p>声明接口的重要事项：<br>①接口声明不能包括数据成员和静态成员；<br>②接口声明只能包含方法、属性、事件和索引器这几个非静态成员函数；<br>③上述函数成员的声明不能包含任何实现代码，必须使用分号代替主体；<br>④按照惯例，接口名称必须从大写的 I 开始，比如 ISaveable ；<br>⑤与类和结构一样，接口的声明可以分隔成分部接口声明。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IMyInterface1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">DoStuff</span> (<span class="params"> <span class="built_in">int</span> nVar1, <span class="built_in">long</span> lVar2 </span>)</span>; <span class="comment">//分号代替了主体</span></span><br><span class="line">    <span class="function"><span class="built_in">double</span> <span class="title">DoOtherStuff</span>(<span class="params"> <span class="built_in">string</span> s, <span class="built_in">long</span> x </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接口的访问性</strong>和接口成员的访问性之间的区别：<br>①接口声明可以有任何的访问修饰符：public、protected、internal 或 private；<br>②然而接口成员是隐式 public 的，不允许有任何访问修饰符，包括 public。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMyInterface2</span> <span class="comment">//接口可以有访问修饰符</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">Method1</span>(<span class="params"> <span class="built_in">int</span> nVar1, <span class="built_in">long</span> lVar2 </span>)</span>; <span class="comment">//错误，接口成员不能有访问修饰符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>只有类和结构能实现接口，要实现接口，类或结构必须：<br>①在基类列表中包含接口名称；<br>②为每一个接口成员提供实现。</p>
<p>关于实现接口的其他重要事项：<br>①如果类实现了接口，它必须实现接口的<strong>所有成员</strong>；<br>②如果类派生自基类并且实现了接口，基类列表中的基类名称必须放在所有接口之前，如下（只能有一个基类，所有其他类型必须为接口）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">MyBaseClass</span>, <span class="title">IIfc1</span>, <span class="title">IEnumerable</span>, <span class="title">IComparable</span> <span class="comment">//基类必须放在最前面</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简单接口的示例"><a href="#简单接口的示例" class="headerlink" title="简单接口的示例"></a>简单接口的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span> <span class="comment">//声明接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; <span class="comment">//分号代替主体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IIfc1</span> <span class="comment">//声明类，实现接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>) <span class="comment">//实现接口成员</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Calling through: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass(); <span class="comment">//创建实例</span></span><br><span class="line">        mc.PrintOut(<span class="string">&quot;object&quot;</span>); <span class="comment">//调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Calling through: object</span><br></pre></td></tr></table></figure>
<h2 id="接口是引用类型"><a href="#接口是引用类型" class="headerlink" title="接口是引用类型"></a>接口是引用类型</h2><p>接口是引用类型。不能直接通过类对象的成员来访问接口，可以通过把类对象引用强制转换为接口类型来获取指向接口的引用。一旦有了接口的引用，就可以使用点语法来调用接口的成员。示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IIfc1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Calling through: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">        mc.PrintOut(<span class="string">&quot;object&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IIfc1 ifc = (IIfc1)mc; <span class="comment">//将对象的引用转换为接口类型的引用</span></span><br><span class="line">        ifc.PrintOut(<span class="string">&quot;interface&quot;</span>); <span class="comment">//调用接口方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Calling through: object</span><br><span class="line">Calling through: interface</span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/3BXYFrgSocITWPf.png" width = "50%" height = "50%" alt="图72 - 类对象的引用以及接口的引用"/>
</div>

<h2 id="接口和-as-运算符"><a href="#接口和-as-运算符" class="headerlink" title="接口和 as 运算符"></a>接口和 as 运算符</h2><p>可以使用 <strong>as 运算符</strong>来代替使用强制转换运算符来获取对象接口的引用。as 运算符与接口配合使用更好，详见第17章。如果尝试将类对象引用强制转换为类未实现的接口的引用，强制转换操作会抛出一个异常。使用 as 运算符可以避免这个问题，若类实现了接口，表达式返回指向接口的引用，若类没有实现接口，表达式返回 null 而不是抛出异常。如下：</p>
<p><code>ILiveBirth b = a as ILiveBirth;</code><br>b 是接口引用，a 是类对象引用，跟 <code>cast: (ILiveBirth)a</code> 一样。</p>
<h2 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h2><p>①类或结构可以实现任意数量的接口；<br>②所有实现的接口必须列在基类列表中并以逗号分隔（若有基类，在其之后）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IDataRetrieve</span> &#123; <span class="function"><span class="built_in">int</span> <span class="title">GetData</span>()</span>; &#125; <span class="comment">//声明接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IDataStore</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">SetData</span>(<span class="params"> <span class="built_in">int</span> x </span>)</span>; &#125; <span class="comment">//声明接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyData</span>: <span class="title">IDataRetrieve</span>, <span class="title">IDataStore</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Mem1;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetData</span>()</span> &#123; <span class="keyword">return</span> Mem1; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetData</span>(<span class="params"> <span class="built_in">int</span> x </span>)</span> &#123; Mem1 = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        data.SetData( <span class="number">5</span> );</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Value = <span class="subst">&#123; data.GetData() &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现具有重复成员的接口"><a href="#实现具有重复成员的接口" class="headerlink" title="实现具有重复成员的接口"></a>实现具有重复成员的接口</h2><p>如果一个类实现了多个接口，并且其中一些接口成员具有相同的签名和返回类型，那么类可以实现单个成员来满足所有包含重复成员的接口。示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IIfc2</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> t</span>)</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IIfc1</span>, <span class="title">IIfc2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Calling through: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">        mc.PrintOut(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Calling through: object</span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/ax513qpkCXBcyiv.png" width = "60%" height = "60%" alt="图73 - 由同一个类成员实现多个接口"/>
</div>

<h2 id="多个接口的引用"><a href="#多个接口的引用" class="headerlink" title="多个接口的引用"></a>多个接口的引用</h2><p>如果类实现了多个接口，可以获取每一个接口的独立引用。如下，可以以三种方式调用 PrintOut，通过类对象，通过指向 IIfc1 接口的引用，通过指向 IIfc2 接口的引用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IIfc2</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IIfc1</span>, <span class="title">IIfc2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Calling through: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        IIfc1 ifc1 = (IIfc1) mc; <span class="comment">//获取IIfc1的引用</span></span><br><span class="line">        IIfc2 ifc2 = (IIfc2) mc; <span class="comment">//获取IIfc2的引用</span></span><br><span class="line"></span><br><span class="line">        mc.PrintOut(<span class="string">&quot;object&quot;</span>); <span class="comment">//从类对象调用</span></span><br><span class="line"></span><br><span class="line">        ifc1.PrintOut(<span class="string">&quot;interface 1&quot;</span>); <span class="comment">//从IIfc1调用</span></span><br><span class="line">        ifc2.PrintOut(<span class="string">&quot;interface 2&quot;</span>); <span class="comment">//从IIfc2调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="派生成员作为实现"><a href="#派生成员作为实现" class="headerlink" title="派生成员作为实现"></a>派生成员作为实现</h2><p>实现接口的类可以从它的基类继承实现代码，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Calling through: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">MyBaseClass</span>, <span class="title">IIfc1</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Derived d = <span class="keyword">new</span> Derived();</span><br><span class="line">        d.PrintOut(<span class="string">&quot;object.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IIfc1 接口指向基类的 PrintOut 方法。</p>
<h2 id="显式接口成员实现"><a href="#显式接口成员实现" class="headerlink" title="显式接口成员实现"></a>显式接口成员实现</h2><p>单个类可以实现多个接口，若要让接口分开实现，可以创建<strong>显式接口成员 explicit interface member implementations</strong>，它使用限定接口名称来声明，由接口名称和成员名称以及中间的点构成：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; &#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title">IIfc2</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> t</span>)</span>; &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IIfc1</span>, <span class="title">IIfc2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IIfc1.PrintOut(<span class="built_in">string</span> s) <span class="comment">//显式接口成员实现</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;IIfc1: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> IIfc2.PrintOut(<span class="built_in">string</span> s) <span class="comment">//显式接口成员实现</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;IIfc2: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        IIfc1 ifc1 = (IIfc1) mc;</span><br><span class="line">        ifc1.PrintOut(<span class="string">&quot;interface 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IIfc2 ifc2 = (IIfc2) mc;</span><br><span class="line">        ifc2.PrintOut(<span class="string">&quot;interface 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：上述代码，不能使用 mc 引用来调用 PrintOut 方法，因为不存在类级别的 PrintOut 方法。当然可以添加类级别的实现。</p>
<h3 id="访问显式接口成员实现"><a href="#访问显式接口成员实现" class="headerlink" title="访问显式接口成员实现"></a>访问显式接口成员实现</h3><p>显式接口成员实现只能通过指向接口的引用来访问，如前例，类的其他成员也不能直接访问他们，会产生编译错误，需要强制转换当前对象的引用（用 this ）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IIfc1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IIfc1.PrintOut(<span class="built_in">string</span> s) <span class="comment">//显式接口实现</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;IIfc1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PrintOut(<span class="string">&quot;...&quot;</span>); <span class="comment">//编译错误</span></span><br><span class="line">        <span class="keyword">this</span>.PrintOut(<span class="string">&quot;...&quot;</span>); <span class="comment">//编译错误</span></span><br><span class="line"></span><br><span class="line">        ((IIfc1)<span class="keyword">this</span>).PrintOut(<span class="string">&quot;...&quot;</span>); <span class="comment">//转换为接口引用，并调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个限制对继承产生了重要影响。由于其他类成员不能直接访问显式接口成员实现，派生类的成员也不能直接访问它们。它们必须总是通过接口的引用来访问。</p>
<h2 id="接口可以继承接口"><a href="#接口可以继承接口" class="headerlink" title="接口可以继承接口"></a>接口可以继承接口</h2><p>接口本身可以从一个或多个接口继承而来，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IDataRetrieve</span> &#123; <span class="function"><span class="built_in">int</span> <span class="title">GetData</span>()</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IDataStore</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">SetData</span>(<span class="params"> <span class="built_in">int</span> x </span>)</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从前两个接口继承而来</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IDataIO</span>: <span class="title">IDataRetrieve</span>, <span class="title">IDataStore</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyData</span>: <span class="title">IDataIO</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> nPrivateData;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetData</span>()</span></span><br><span class="line">        &#123; <span class="keyword">return</span> nPrivateData; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetData</span>(<span class="params"> <span class="built_in">int</span> x </span>)</span></span><br><span class="line">        &#123; nPrivateData = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        data.SetData( <span class="number">5</span> );</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, data.GetData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不同类实现一个接口的示例"><a href="#不同类实现一个接口的示例" class="headerlink" title="不同类实现一个接口的示例"></a>不同类实现一个接口的示例</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">ILiveBirth</span> &#123; <span class="function"><span class="built_in">string</span> <span class="title">BabyCalled</span>()</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; &#125; <span class="comment">//基类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span>, <span class="title">ILiveBirth</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> ILiveBirth.BabyCalled()</span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="string">&quot;kitten&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span>, <span class="title">ILiveBirth</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> ILiveBirth.BabyCalled()</span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="string">&quot;puppy&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Bird</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Animal[] animalArray = <span class="keyword">new</span> Animal[<span class="number">3</span>];</span><br><span class="line">        animalArray[<span class="number">0</span>] = <span class="keyword">new</span> Cat();</span><br><span class="line">        animalArray[<span class="number">1</span>] = <span class="keyword">new</span> Bird();</span><br><span class="line">        animalArray[<span class="number">2</span>] = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="keyword">foreach</span>( Animal a <span class="keyword">in</span> animalArray )</span><br><span class="line">        &#123;</span><br><span class="line">            ILiveBirth b = a <span class="keyword">as</span> ILiveBirth;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span>)</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Baby is called: <span class="subst">&#123; b.BabyCalled() &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Baby is called: kitten</span><br><span class="line">Baby is called: puppy</span><br></pre></td></tr></table></figure>
<h1 id="第十七章-转换"><a href="#第十七章-转换" class="headerlink" title="第十七章 转换"></a>第十七章 转换</h1><h2 id="什么是转换"><a href="#什么是转换" class="headerlink" title="什么是转换"></a>什么是转换</h2><p>若要把一个变量（源）的值，赋值给另外一个变量（目标），在赋值之前，源的值必须转换为目标类型的值。转换后的值应和源值一致，但其类型为目标类型。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/24nuRkv5XPVSfoH.png" width = "70%" height = "70%" alt="图74 - 从short转换为sbyte"/>
</div>

<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>有些类型的转换不会丢失数据和精度，比如8位的值转换为16位：<br>①语言会自动做这些转换，这叫做<strong>隐式转换</strong>；<br>②从位数更少的源类型转换为位数更多的目标类型时，多出来的位用0或1填充；<br>③当从更小的无符号类型转换为更大的无符号类型时，目标类型多出来的最高位都以0进行填充，称为<strong>零扩展 zero extension</strong>。<br>④对于有符号类型的转换，额外的最高位用源表达式的符号位填充，这样可以维持被转换值的正确符号和大小，叫做<strong>符号扩展 sign extension</strong>，如下图：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/RYw6FQchEmBj35q.png" width = "60%" height = "60%" alt="图75 - 有符号转换中的符号扩展"/>
</div>

<h2 id="显式转换和强制转换"><a href="#显式转换和强制转换" class="headerlink" title="显式转换和强制转换"></a>显式转换和强制转换</h2><p>若将长类型转换为短类型，不是源值的所有最高位都适合目标类型，会导致<strong>溢出 overflow</strong> 或<strong>数据丢失</strong>。如下图：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/76z9FslyoKeRCAi.png" width = "60%" height = "60%" alt="图76 - 尝试把ushort转换为byte"/>
</div>

<h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>对于预定义类型，C# 会自动将一个数据类型转换为另一个数据类型，前提是从源类型转换为目标类型不会发生数据丢失。即 C# 不会提供会丢失值情形的自动转换，这时候必须使用显式转换，即<strong>强制转换表达式 cast expression</strong> 。如果使用强制转换表达式，意味着要承担操作后引起的数据丢失的后果，如下图：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/PR4sMQimxULHn2G.png" width = "80%" height = "80%" alt="图77 - 强制把ushort转换为byte"/>
</div>

<h2 id="转换的类型"><a href="#转换的类型" class="headerlink" title="转换的类型"></a>转换的类型</h2><p>①除了标准转换，还可以为用户自定义类型定义隐式类型和显式类型；<br>②还有一个预定义的转换类型，叫<strong>装箱 boxing</strong>，它可以将任何值类型转换为 object 类型或 System.ValueType 类型；<br>③<strong>拆箱 unboxing</strong> 可以将一个装箱的值转换为原始类型。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/9HB1i2WA7ZLVNgx.png" width = "50%" height = "50%" alt="图78 - 转换的类型"/>
</div>

<h2 id="数字的转换"><a href="#数字的转换" class="headerlink" title="数字的转换"></a>数字的转换</h2><p>任何数字类型都可以转换为其他数字类型，一些转换是隐式的，另外一些转换必须是显式的。</p>
<h3 id="隐式数字转换"><a href="#隐式数字转换" class="headerlink" title="隐式数字转换"></a>隐式数字转换</h3><p>如下图，若存在箭头，则存在从源类型到目标类型的隐式转换；若不存在，则需要使用显式转换：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/TU3OPZ8YMIkptVy.png" width = "45%" height = "45%" alt="图79 - 隐式数字转换"/>
</div>

<h3 id="溢出检测上下文"><a href="#溢出检测上下文" class="headerlink" title="溢出检测上下文"></a>溢出检测上下文</h3><p>对于整数类型（包括sbyte、byte、short、ushort、int、uint、long、ulong），C# 允许选择运行时是否应该在进行类型转换时检测溢出，可以通过 <strong>checked 运算符</strong>和 <strong>checked 语句</strong>来实现。</p>
<p>代码片段无论是否被检测都称为<strong>溢出检测上下文 overflow checking context</strong> 。默认的溢出检测上下文是不检查。<br>①如果我们指定一个表达式或一段代码为 checked ，CLR 会在转换产生溢出时抛出一个 OverflowException 异常；<br>②如果代码不是 checked ，转换会继续而不管是否溢出。</p>
<p><strong><em>1、checked 和 unchecked 运算符</em></strong><br>checked 和 unchecked 运算符控制表达式的溢出检测上下文，表达式放置在一对圆括号内，并且不能是一个方法：<code>checked ( Expression )</code> 或 <code>unchecked ( Expression )</code>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ushort</span> sh = <span class="number">2000</span>;</span><br><span class="line"><span class="built_in">byte</span> sb;</span><br><span class="line"></span><br><span class="line">sb = <span class="keyword">unchecked</span> ( (<span class="built_in">byte</span>) sh ); <span class="comment">//忽略溢出</span></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;sb: <span class="subst">&#123; sb &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">sb = checked ( (<span class="built_in">byte</span>) sh ); <span class="comment">//抛出 OverflowException 异常</span></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;sb: <span class="subst">&#123; sb &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">sb: 208</span><br><span class="line">Unhandled exception. System.OverflowException: Arithmetic operation resulted in an overflow.</span><br></pre></td></tr></table></figure>
<p><strong><em>2、checked 语句和 unchecked 语句</em></strong><br>checked 语句和 unchecked 语句控制的是一块代码中的所有转换，而不是单个表达式。它们可以被嵌套在任意层次，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">byte</span> sb;</span><br><span class="line"><span class="built_in">ushort</span> sh = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">checked</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unchecked</span></span><br><span class="line">    &#123;</span><br><span class="line">        sb = (<span class="built_in">byte</span>) sh;</span><br><span class="line">        Console.WriteLine( <span class="string">$&quot;sb: <span class="subst">&#123; sb &#125;</span>&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sb = checked((<span class="built_in">byte</span>) sh);</span><br><span class="line">    Console.WriteLine( <span class="string">$&quot;sb: <span class="subst">&#123; sb &#125;</span>&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果与上面相同，只不过这里影响的是一段代码而不是一个表达式。</p>
<h3 id="显式数字转换"><a href="#显式数字转换" class="headerlink" title="显式数字转换"></a>显式数字转换</h3><p><strong><em>1、整数类型到整数类型</em></strong><br>如果转换会丢失数据，checked ：OverflowException 异常；unchecked ：丢失的位不会发出警告。</p>
<p><strong><em>2、float 或 double 转到整数类型</em></strong><br>当把浮点类型转换为整数类型时，值会舍掉小数点，截断为最接近的整数。如果截断后的值不在目标类型的范围内：checked ：OverflowException 异常；unchecked ：C# 将不定义它的值应该是什么。</p>
<p><strong><em>3、decimal 到整数类型</em></strong><br>如果结果值不在目标类型的范围内，CLR 会抛出 OverflowException 异常。</p>
<p><strong><em>4、double 到 float</em></strong><br>float 类型的值占32位，而 double 类型的值占64位。double 类型的值被舍入到最接近的 float 类型的值。①如果值太小而不能用 float 表示，那么值会被设置为正或负0；②如果值太大而不能用 float 表示，那么值会被设置为正无穷大或负无穷大。</p>
<p><strong><em>5、float 或 double 到 decimal</em></strong><br>如果值太小而不能用 decimal 类型表示，那么值会被设置为0；如果值太大，那么 CLR 会抛出 OverflowException 异常。</p>
<p><strong><em>6、decimal 到 float 或 double</em></strong><br>从 decimal 类型转换到浮点数类型总会成功，然而可能会损失精度，即截断值到最接近的 float 或 double 值。</p>
<h2 id="引用转换"><a href="#引用转换" class="headerlink" title="引用转换"></a>引用转换</h2><p>引用转换接受源引用并返回一个指向堆中同一位置的引用，只是把引用“标记”为其他类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field1; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field2; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        B myVar1 = <span class="keyword">new</span> B();</span><br><span class="line">        A myVar2 = (A) myVar1; <span class="comment">//返回指向myVar1的引用作为A类的引用</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; myVar2.Field1 &#125;</span>&quot;</span>); <span class="comment">//正确</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; myVar2.Field2 &#125;</span>&quot;</span>); <span class="comment">//编译错误，Field2对myVar2不可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/08/doaBWsuXMOmgbS3.png" width = "70%" height = "70%" alt="图80 - 引用转换返回与对象关联的不同类型"/>
</div>

<p>对于 myVar2 ，它实际上指向 B 类型的对象，但它看不到 B 扩展 A 部分，因此看不到 Field2 。</p>
<h3 id="隐式引用转换"><a href="#隐式引用转换" class="headerlink" title="隐式引用转换"></a>隐式引用转换</h3><p>①所有引用类型可以被隐式转换为 object 类型；<br>②任何接口可以隐式转换为它继承的接口；<br>③类可以隐式转换为它继承链中任何的类以及它实现的任何接口。<br>④委托可以隐式转换成如下图所示的 .NET BCL 类和接口：<br>⑤ Array 数组，比如下图的 ArrayS 数组（S for source，其中元素为 Ts 类型），可以隐式转换为如下图所示的 .NET BCL 类和接口，或者另一个数组，比如下图的 ArrayT 数组（T for target，其中元素为 Tt 类型）， ArrayT 数组必须满足：两个数组维度一样；Ts 和 Tt 都是引用类型；Ts 和 Tt 之间存在隐式转换。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/08/CZ1hvJaREHfVLxq.png" width = "70%" height = "70%" alt="图81 - 委托和数组的隐式转换"/>
</div>

<h3 id="显式引用转换"><a href="#显式引用转换" class="headerlink" title="显式引用转换"></a>显式引用转换</h3><p>上面所述隐式转换的相反转换，需要显式引用转换，比如从 object 到任何引用类型的转换或从基类到派生自它的类的转换。</p>
<p>但是如果转换的类型没有限制，可能会导致尝试去引用内存中实际不存在的类成员，虽然编译器允许这样的转换，但如果运行时遇到它们，会抛出异常，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field1; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field2; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        A myVar1 = <span class="keyword">new</span> A();</span><br><span class="line">        B myVar2 = (B) myVar1; <span class="comment">//在运行时抛出InvalidCastException异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①若 myVar2 尝试访问 Field2，它会尝试访问对象中“ B 部分”（不在内存中），这会导致内存错误；<br>②运行时会捕获这种错误的强制转换并抛出 InvalidCastException 异常，它不会导致编译错误。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/08/o2MAUtmqbWfQEVK.png" width = "40%" height = "40%" alt="图82 - 无效的转换抛出运行时异常"/>
</div>

<h3 id="有效显式引用转换"><a href="#有效显式引用转换" class="headerlink" title="有效显式引用转换"></a>有效显式引用转换</h3><p>在运行时能够成功进行的显式转换有以下3种情况：</p>
<p>第一种情况：显式转换没有必要，即可以隐式转换的情况，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field1; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field2; &#125;</span><br><span class="line">...</span><br><span class="line">B myVar1 = <span class="keyword">new</span> B();</span><br><span class="line">A myVar2 = (A) myVar1; <span class="comment">//不必转换，因为A是B的基类</span></span><br></pre></td></tr></table></figure>
<p>第二种情况：源引用是 null 。即使转换基类的引用到派生类的引用通常是不安全的，但是由于源引用是 null ，这种转换是允许的，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field1; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field2; &#125;</span><br><span class="line">...</span><br><span class="line">A myVar1 = <span class="literal">null</span>;</span><br><span class="line">B myVar2 = (B) myVar1; <span class="comment">//允许转换，因为myVar1为空</span></span><br></pre></td></tr></table></figure>
<p>第三种情况：源引用指向的实际数据安全地进行隐式转换后，可以转回原类型：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field1; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field2; &#125;</span><br><span class="line">...</span><br><span class="line">B myVar1 = <span class="keyword">new</span> B();</span><br><span class="line">A myVar2 = myVar1; <span class="comment">//将myVar1隐式转换为A类型</span></span><br><span class="line">B myVar3 = (B) myVar2; <span class="comment">//该转换是允许的，因为数据是B类型的</span></span><br></pre></td></tr></table></figure>
<p>①第二行隐式转换，看似使 myVar2 指向 A 类型的数据，实际上指向的是 B 类型的数据；<br>②第三行中的显式转换把基类引用强制转换为它的派生类的引用，这通常会产生异常，但这里由于指向的对象实际就是 B 类型的数据项，所以允许转换。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/08/PWS8RLs9tgQHX4K.png" width = "70%" height = "70%" alt="图83 - 强制转换到安全类型"/>
</div>

<h2 id="装箱变换-Boxing-Conversions"><a href="#装箱变换-Boxing-Conversions" class="headerlink" title="装箱变换 Boxing Conversions"></a>装箱变换 Boxing Conversions</h2><p>所有 C# 类型都派生自 object 类型，包括值类型，虽然 object 本身是引用类型。值类型在默认情况下在堆上不包括它们的对象组件，可以使用<strong>装箱 boxing</strong>（一种隐式转换），接受值类型，根据这个值在堆上创建一个完整的引用类型对象并返回对象引用，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">object</span> oi = <span class="literal">null</span>;</span><br><span class="line">oi = i;</span><br></pre></td></tr></table></figure>
<p>系统将 i 的值装箱如下：<br>①在堆上创建了 int 类型的对象；<br>②将 i 的值复制到 int 对象；<br>③返回 int 对象的引用，让 oi 作为引用保存。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/10/tIpGFHRgKxdLfVZ.png" width = "30%" height = "30%" alt="图84 - 装箱从值类型创建了完整的引用类型"/>
</div>

<h3 id="装箱是创建副本"><a href="#装箱是创建副本" class="headerlink" title="装箱是创建副本"></a>装箱是创建副本</h3><p>装箱后返回的是值的引用类型副本。原始值类型和引用类型副本都可以独立操作，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">object</span> oi = i;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;i: <span class="subst">&#123; i &#125;</span>, io: <span class="subst">&#123; oi &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">i = <span class="number">12</span>;</span><br><span class="line">oi = <span class="number">15</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;i: <span class="subst">&#123; i&#125;</span>, io: <span class="subst">&#123;oi &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">i: 10, io: 10</span><br><span class="line">i: 12, io: 15</span><br></pre></td></tr></table></figure>
<h3 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h3><p>任何值类型 ValueTypeS 都可以被隐式转换为 object、System.ValueType 或 InterfaceT 类型（如果 ValueTypeS 实现了 InterfaceT ）。</p>
<h2 id="拆箱转换-Unboxing-Conversions"><a href="#拆箱转换-Unboxing-Conversions" class="headerlink" title="拆箱转换 Unboxing Conversions"></a>拆箱转换 Unboxing Conversions</h2><p><strong>拆箱 unboxing</strong> 是把装箱后的对象转换回值类型的过程：<br>①拆箱是显式转换；<br>②系统在把值拆箱成 ValueTypeT 时执行了如下的步骤：<br>&ensp;&ensp;&ensp;&ensp;- 它检测到要拆箱的对象实际是 ValueTypeT 的装箱值；<br>&ensp;&ensp;&ensp;&ensp;- 它把对象的值复制到变量。  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">object</span> oi = i; <span class="comment">//对i装箱并把引用赋值给oi</span></span><br><span class="line">    <span class="built_in">int</span> j = (<span class="built_in">int</span>) oi; <span class="comment">//对oi拆箱并把值赋值给j</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;i: <span class="subst">&#123; i &#125;</span>, oi: <span class="subst">&#123; oi &#125;</span>, j: <span class="subst">&#123; j &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">i: 10, oi: 10, j: 10</span><br></pre></td></tr></table></figure>
<p>尝试将一个值拆箱为非原始类型时，会抛出 InvalidCastException 异常。</p>
<h2 id="用户自定义转换"><a href="#用户自定义转换" class="headerlink" title="用户自定义转换"></a>用户自定义转换</h2><p>除了标准转换外，可以为类或结构定义隐式和显式转换。</p>
<p>用户自定义转换的语法如下：<br>①除了 <strong>implicit</strong> 或 <strong>explicit 关键字</strong>外，隐式转换和显式转换的声明语法是一样的；<br>②需要 <strong>public</strong> 和 <strong>static 修饰符</strong>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">TargetType</span> (<span class="params"> SourceType Identifier </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ObjectOfTargetType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用户自定义转换的约束"><a href="#用户自定义转换的约束" class="headerlink" title="用户自定义转换的约束"></a>用户自定义转换的约束</h3><p>①只可以为类或结构定义用户自定义转换；<br>②不能重定义标准隐式或显式转换；<br>③对于源类型 S 和目标类型 T：S 和 T 必须是不同类型。S 和 T 不能通过继承关联，即 S 不能派生自 T，而 T 也不能派生自 S 。S 和 T 都不能是接口类型或者 object 类型。转换运算符必须是 S 或 T 的成员；<br>④不能同时对同一源和目标类型声明两种转换，即不能同时声明隐式和显式转换。</p>
<h3 id="用户自定义转换的示例"><a href="#用户自定义转换的示例" class="headerlink" title="用户自定义转换的示例"></a>用户自定义转换的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">Person p</span>) <span class="comment">//将Person转换为int</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p.Age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> i</span>) <span class="comment">//将int转换为Person</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;Nemo&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person bill = <span class="keyword">new</span> Person( <span class="string">&quot;bill&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> age = bill; <span class="comment">//把Person对象转换为int</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Person Info: <span class="subst">&#123; bill.Name &#125;</span>, <span class="subst">&#123; age &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Person anon = <span class="number">35</span>; <span class="comment">//把int转换为Person对象</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Person Info: <span class="subst">&#123; anon.Name &#125;</span>, <span class="subst">&#123; anon.Age &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Person Info: bill, 25</span><br><span class="line">Person Info: Nemo, 35</span><br></pre></td></tr></table></figure>
<p>如果使用 explicit 运算符来定义相同转换，需要使用强制转换表达式来进行转换：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params"> Person p </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p.Age;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">int</span> age = (<span class="built_in">int</span>) bill;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多步用户自定义转换"><a href="#多步用户自定义转换" class="headerlink" title="多步用户自定义转换"></a>多步用户自定义转换</h3><p>上面讨论的用户自定义转换都是单步内直接把源类型转换为目标类型对象。但是，用户自定义转换在完整转换中最多可以有3个步骤：①预备标准转换；②用户自定义转换；③后续标准转换。这个链不可能有一个以上的用户自定义转换。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/10/WF45ydOzgBiUC1s.png" width = "70%" height = "70%" alt="图85 - 多步用户自定义转换"/>
</div>

<h3 id="多步用户自定义转换的示例"><a href="#多步用户自定义转换的示例" class="headerlink" title="多步用户自定义转换的示例"></a>多步用户自定义转换的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span> : <span class="title">Person</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Person对象转换为int</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">Person p</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p.Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Employee bill = <span class="keyword">new</span> Employee();</span><br><span class="line">        bill.Name = <span class="string">&quot;William&quot;</span>;</span><br><span class="line">        bill.Age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> fVar = bill; <span class="comment">//把Employee转换为float</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Person Info: <span class="subst">&#123; bill.Name &#125;</span>, <span class="subst">&#123; fVar &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Person Info: William, 25</span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/10/9CGMNEyoaBWYen7.png" width = "70%" height = "70%" alt="图86 - 从Employee转换为float"/>
</div>

<p>①上述代码声明了一个从 Person 类到 int 的用户自定义转换。由于从 Employee 到 Person 以及从 int 到 float 有标准转换，所以可以直接从 Employee 转换到 float ：<br>&ensp;&ensp;&ensp;&ensp;- 由于 Employee 继承自 Person，从Employee 到 Person 有标准转换；<br>&ensp;&ensp;&ensp;&ensp;- 从 int 到 float 有隐式数字转换，也是标准转换。<br>②由于链中的3个部分都存在，所以可以从 Employee 转换到 float 。</p>
<h2 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h2><p>可以使用 <strong>is 运算符</strong>来检查转换是否会成功完成。is 运算符的语法如下，其中 Expr 是源表达式：<code>Expr is TargetType</code>，该表达式返回 bool 类型。</p>
<p>如果 Expr 可以通过以下方式成功转换为目标类型，则运算符返回 true ：①引用转换；②装箱转换；③拆箱转换。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span> : <span class="title">Person</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name = <span class="string">&quot;Anonymous&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Employee bill = <span class="keyword">new</span> Employee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检测变量bill是否能转换为Person类型</span></span><br><span class="line">        <span class="keyword">if</span>( bill <span class="keyword">is</span> Person )</span><br><span class="line">        &#123;</span><br><span class="line">            Person p = bill;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Person Info: <span class="subst">&#123; p.Name &#125;</span>, <span class="subst">&#123; p.Age &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>is 运算符只可以用于引用转换以及装箱和拆箱转换，不能用于用户自定义转换。</p>
<h2 id="as-运算符"><a href="#as-运算符" class="headerlink" title="as 运算符"></a>as 运算符</h2><p><strong>as 运算符</strong>和强制转换运算符类似，只是不抛出异常，如果转换失败，它返回 null 。as 运算符的语法如下，其中 Expr 是源表达式，TargetType 是目标类型，它必须是引用类型：<code>Expr as TargetType</code>。</p>
<p>由于 as 运算符返回引用表达式，它可以用作赋值操作中的源，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span> : <span class="title">Person</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name = <span class="string">&quot;Anonymous&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    Employee bill = <span class="keyword">new</span> Employee();</span><br><span class="line">    Person p;</span><br><span class="line"></span><br><span class="line">    p = bill <span class="keyword">as</span> Person;</span><br><span class="line">    <span class="keyword">if</span>( p != <span class="literal">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Person Info: <span class="subst">&#123; p.Name &#125;</span>, <span class="subst">&#123; p.Age &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>as 运算符只可以用于引用转换以及装箱转换，不能用于用户自定义转换或到值类型的转换。</p>
<h1 id="第十八章-泛型"><a href="#第十八章-泛型" class="headerlink" title="第十八章 泛型"></a>第十八章 泛型</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>到现在为止，所有在类声明中用到的类型都是特定的类型，要么是程序员定义的，要么是语言或 BCL 定义的。然而，很多时候，我们需要把类的行为提取或重构出来，使之不仅能用到它们编码的数据类型上，还能应用到其他类型上。<strong>泛型 generics</strong>可以做到这一点，我们可以重构代码并额外增加一个抽象层，数据类型就不用硬编码了。这是专门为多段代码在不同的数据类型上执行相同指令的情况专门设计的。</p>
<h3 id="一个栈的示例"><a href="#一个栈的示例" class="headerlink" title="一个栈的示例"></a>一个栈的示例</h3><p>如下，声明了 MyIntStack 的类，实现了一个 int 类型的栈，允许我们把 int 压入栈中，或弹出：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyIntStack</span> <span class="comment">//int类型的栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> StackPointer = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span>[] StackArray; <span class="comment">//int类型的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"> <span class="built_in">int</span> x </span>)</span> &#123; ... &#125; <span class="comment">//输入类型：int</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Pop</span>()</span> &#123; ... &#125; <span class="comment">//返回类型：int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果希望相同的功能应用于 float 类型的值，其中一种方式是剪切并粘贴 MyIntStack 类的代码，把类名改为 MyFloatStack ，把整个类声明中相应的 int 声明改为 float 声明。</p>
<p>这个方法可行，但是有很多缺点：需要仔细检查类的每一个部分来看哪些类型的声明需要修改，哪些需要保留；每次需要新类型的栈类时，需要重复这个过程，这就意味着具有很多相同代码的副本，占据了额外空间；并且很难调试和维护，修复问题需要一个个修改，很麻烦。</p>
<h2 id="C-中的泛型"><a href="#C-中的泛型" class="headerlink" title="C# 中的泛型"></a>C# 中的泛型</h2><p><strong>泛型 generics</strong>可以让多个类型共享一组代码。泛型允许声明<strong>类型参数化 type-parameterized</strong> 的代码，用不同类型进行实例化。即可以使用<strong>类型占位符 placeholders for types</strong> 来写代码，然后在创建类的实例时指明真实的类型。</p>
<p><strong><em>类型不是对象，而是对象或者实例的模板；而泛型类型不是类型，而是类型的模板。</em></strong></p>
<p>C# 提供了5种泛型：类、结构、接口、委托和方法。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/11/k1o2XvBEa9MnHPs.png" width = "50%" height = "50%" alt="图87 - 泛型和用户定义类型"/>
</div>

<h3 id="继续栈的示例"><a href="#继续栈的示例" class="headerlink" title="继续栈的示例"></a>继续栈的示例</h3><p>通过以下步骤可以从 MyIntStack 创建一个泛型类，T 为标识符：<br>①使用类型占位符 T 而不是 int 或 float 等；<br>②修改类名称为 Mystack ；<br>③在类名后放置 <code>&lt;T&gt;</code>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> StackPointer = <span class="number">0</span>;</span><br><span class="line">    T [] StackArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params">T x </span>)</span> &#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Pop</span>()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>创建和使用非泛型的类有2个步骤：声明类和创建类的实例。但是泛型类是类的模板，所以要先从泛型类构建实际的类类型，然后创建这个类类型的引用和实例。步骤如下：<br>①使用占位符声明泛型类型；<br>②为占位符提供真实类型，通过提供真实类型创建<strong>构造类型 constructed type</strong> ;<br>③创建构造类型的实例。</p>
<h3 id="声明泛型类"><a href="#声明泛型类" class="headerlink" title="声明泛型类"></a>声明泛型类</h3><p>声明一个泛型类和声明普通类差不多，区别如下：<br>①在类名后放置一组尖括号，在尖括号中用逗号分隔的占位符字符串表示需要提供的类型，叫做<strong>类型参数 type parameters</strong> 。<br>②在泛型类声明的主体中使用参数类型来表示替代的类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span> &lt; <span class="title">T1</span>, <span class="title">T2</span> &gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T1 SomeVar;</span><br><span class="line">    <span class="keyword">public</span> T2 OtherVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建构造类型"><a href="#创建构造类型" class="headerlink" title="创建构造类型"></a>创建构造类型</h3><p>一旦声明了泛型类型，我们需要告诉编译器能使用哪些真实类型来替代占位符（类型参数）。编译器获取真实类型并创建构建类型（用来创建真实类对象的模板）。</p>
<p>创建构建类型语法：<code>SomeClass&lt; short, int &gt;</code>，替代类型参数的真实类型叫做<strong>类型实参 type argument</strong> 。编译器接受了类型实参并且替代泛型类主体中的相应类型参数，产生了构造类型，然后通过构造类型创建真实类型的实例。</p>
<h3 id="创建变量和实例"><a href="#创建变量和实例" class="headerlink" title="创建变量和实例"></a>创建变量和实例</h3><p>在创建引用和实例方面，构造类类型和常规类型差不多，如下：<br>①第一行显示了普通非泛型类型对象的创建；<br>②第二行显示了泛型类型的创建；<br>③第三行用 var 关键字让编译器使用类型引用。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyNonGenClass         myNGC = <span class="keyword">new</span> MyNonGenClass        ();</span><br><span class="line">SomeClass&lt;<span class="built_in">short</span>, <span class="built_in">int</span>&gt; mySc1 = <span class="keyword">new</span> SomeClass&lt;<span class="built_in">short</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="keyword">var</span>                   mySc2 = <span class="keyword">new</span> SomeClass&lt;<span class="built_in">short</span>, <span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>和非泛型类一样，引用和实例可以分开创建，如下：<br>①泛型类声明下面的第一行在栈上为 myInst 分配了一个引用，值为 null ；<br>②第二行在堆上分配实例，并且把引用赋值给变量。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span> &lt; <span class="title">T1</span>, <span class="title">T2</span> &gt; <span class="comment">//泛型类声明</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T1 SomeVar;</span><br><span class="line">    <span class="keyword">public</span> T2 OtherVar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SomeClass&lt;<span class="built_in">short</span>, <span class="built_in">int</span>&gt; myInst; <span class="comment">//分配类变量</span></span><br><span class="line">myInst = <span class="keyword">new</span> SomeClass&lt;<span class="built_in">short</span>, <span class="built_in">int</span>&gt;(); <span class="comment">//分配实例</span></span><br></pre></td></tr></table></figure>
<p>可以从同一个泛型类构建出很多不同的类类型，每一个都是独立的类类型。</p>
<h3 id="使用泛型的栈的示例"><a href="#使用泛型的栈的示例" class="headerlink" title="使用泛型的栈的示例"></a>使用泛型的栈的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T[] StackArray;</span><br><span class="line">    <span class="built_in">int</span> StackPointer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params">T x</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !IsStackFull )</span><br><span class="line">            StackArray[StackPointer++] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Pop</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ( !IsStackEmpty )</span><br><span class="line">            ? StackArray[--StackPointer]</span><br><span class="line">            : StackArray[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MaxStack = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">bool</span> IsStackFull &#123; <span class="keyword">get</span>&#123; <span class="keyword">return</span> StackPointer &gt;= MaxStack; &#125; &#125;</span><br><span class="line">    <span class="built_in">bool</span> IsStackEmpty &#123; <span class="keyword">get</span>&#123; <span class="keyword">return</span> StackPointer &lt;= <span class="number">0</span>; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StackArray = <span class="keyword">new</span> T[MaxStack];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = StackPointer<span class="number">-1</span>; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot; Value: <span class="subst">&#123; StackArray[i] &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyStack&lt;<span class="built_in">int</span>&gt; StackInt = <span class="keyword">new</span> MyStack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        MyStack&lt;<span class="built_in">string</span>&gt; StackString = <span class="keyword">new</span> MyStack&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">        StackInt.Push(<span class="number">3</span>);</span><br><span class="line">        StackInt.Push(<span class="number">5</span>);</span><br><span class="line">        StackInt.Push(<span class="number">7</span>);</span><br><span class="line">        StackInt.Push(<span class="number">9</span>);</span><br><span class="line">        StackInt.Print();</span><br><span class="line"></span><br><span class="line">        StackString.Push(<span class="string">&quot;This is fun&quot;</span>);</span><br><span class="line">        StackString.Push(<span class="string">&quot;Hi there! &quot;</span>);</span><br><span class="line">        StackString.Print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Value: 9</span><br><span class="line">Value: 7</span><br><span class="line">Value: 5</span><br><span class="line">Value: 3</span><br><span class="line">Value: Hi there!</span><br><span class="line">Value: This is fun</span><br></pre></td></tr></table></figure>
<h2 id="类型参数的约束"><a href="#类型参数的约束" class="headerlink" title="类型参数的约束"></a>类型参数的约束</h2><p>上述泛型栈的示例，没有做其他需要用到项本身的运算符的事情，因为泛型栈不知道它们保存的项的类型是什么，也就不知道这些项实现的成员。然而，由于 C# 对象都是从 object 继承，所以这些保存的项实现了 object 类的成员，包括 ToString、Equals 以及 GetType 方法，除此之外，它不知道还有哪些成员可用。</p>
<p>只要代码不访问它处理的一些类型的对象，泛型类就可以处理任意类型。符合这种约束的类型参数称为<strong>未绑定的类型参数 unbounded type parameters</strong> 。但是如果代码尝试访问其他成员，编译器会产生一个错误消息，示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Simple</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">LessThan</span>(<span class="params">T i1, T i2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i1 &lt; i2; <span class="comment">//错误，因为不是所有类型都实现了小于运算符</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要让泛型变得更有用，需要提供额外的信息让编译器知道参数可以接受哪些类型，这种额外信息叫做<strong>约束 constraint</strong> 。只有符合约束的类型才能替代给定的类型参数来产生构造类型。</p>
<h3 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h3><p>约束使用 <strong>where 子句</strong>列出：<br>①每一个有约束的类型参数都有自己的 where 子句；<br>②如果参数有多个约束，它们在 where 子句中使用逗号分隔。</p>
<p>语法：<code>where TypeParam : constraint, constraint, ...</code></p>
<p>关于 where 子句的事项如下：<br>①它们在类型参数列表的关闭尖括号之后列出；<br>②不使用分隔符；<br>③可以以任意次序列出；<br>④ where 是上下文关键字，所以可以在其他上下文中使用。</p>
<p>如下泛型类有3个类型参数，T1 是未绑定的类型参数。对于 T2 ，只有 Customer 类型的类或从 Customer 派生的类才能用作类型实参。对于 T3 ，只有实现 IComparable 接口的类才能用作类型实参：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &lt; <span class="title">T1</span>, <span class="title">T2</span>, <span class="title">T3</span> &gt;</span><br><span class="line">                <span class="keyword">where</span> <span class="title">T2</span>: <span class="title">Customer</span> <span class="comment">//T2的约束</span></span><br><span class="line">                <span class="keyword">where</span> <span class="title">T3</span>: <span class="title">IComparable</span> <span class="comment">//T3的约束</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="约束类型和次序"><a href="#约束类型和次序" class="headerlink" title="约束类型和次序"></a>约束类型和次序</h3><p>共有5种约束类型，如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">约束类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">类名 ClassName</td>
<td style="text-align:left">只有这个类型的类或从它派生的类才能用作类型实参</td>
</tr>
<tr>
<td style="text-align:left">class</td>
<td style="text-align:left">任何引用类型，包括类、数组、委托和接口都可以用作类型实参</td>
</tr>
<tr>
<td style="text-align:left">struct</td>
<td style="text-align:left">任何值类型都可以用作类型实参</td>
</tr>
<tr>
<td style="text-align:left">接口名 InterfaceName</td>
<td style="text-align:left">只有这个接口或实现这个接口的类型才能用作类型实参，约束接口也可以是泛型的</td>
</tr>
<tr>
<td style="text-align:left">new( )</td>
<td style="text-align:left">任何带有无参公共构造函数的类型都可以用作类型实参。这叫构造函数约束</td>
</tr>
</tbody>
</table>
</div>
<p>where 子句可以以任意次序列出。然而，where 子句中的约束必须有特定的顺序：<br>①最多只能有一个主约束，而且放在第一位；<br>②可以有任意多的接口名称约束；<br>③如果存在构造函数约束，则必须放在后面。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/02/14/hKjGeR4WStPpiqY.png" width = "50%" height = "50%" alt="图88 - 如果类型参数有多个约束，必须遵循这个顺序"/>
</div>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SortedList</span>&lt;<span class="title">S</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="title">S</span>: <span class="title">IComparable</span>&lt;<span class="title">S</span>&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">M</span>,<span class="title">N</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="title">M</span> : <span class="title">IComparable</span>&lt;<span class="title">M</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="title">N</span> : <span class="title">ICloneable</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDictionary</span>&lt;<span class="title">KeyType</span>, <span class="title">ValueType</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="title">KeyType</span> : <span class="title">IEnumerable</span>,</span><br><span class="line">    <span class="title">new</span>()               &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>与其他泛型不同，方法是成员，不是类型。<strong>泛型方法</strong>可以在泛型类和非泛型类以及结构和接口中声明。</p>
<h3 id="声明泛型方法"><a href="#声明泛型方法" class="headerlink" title="声明泛型方法"></a>声明泛型方法</h3><p>泛型方法有两个参数列表和可选的约束，包括封闭在圆括号里的方法参数列表和封闭在尖括号的类型参数列表。要声明泛型方法，在方法名和方法参数列表中间放置类型参数列表，方法参数列表后放置可选的约束子句。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintData</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; (<span class="params"> S p, T t </span>) <span class="keyword">where</span> S: Person</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用泛型方法"><a href="#调用泛型方法" class="headerlink" title="调用泛型方法"></a>调用泛型方法</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoStuff</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt;(<span class="params"> T1 t1, T2 t2 </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    T1 someVar = t1;</span><br><span class="line">    T2 otherVar = t2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DoStuff&lt;<span class="built_in">short</span>, <span class="built_in">int</span>&gt;( sVal, iVal ); <span class="comment">//调用泛型方法</span></span><br><span class="line">DoStuff&lt;<span class="built_in">int</span>, <span class="built_in">long</span>&gt;( iVal, lVal ); <span class="comment">//调用泛型方法</span></span><br></pre></td></tr></table></figure>
<p>如果我们为方法传入参数，编译器有时可以从方法参数的类型中推断出类型参数的类型。如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyMethod</span> &lt;T&gt; (<span class="params">T myVal</span>)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> myInt = <span class="number">5</span>;</span><br><span class="line">MyMethod &lt;<span class="built_in">int</span>&gt; (myInt); <span class="comment">//两个都是int，类型参数的信息就多余了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于编译器可以从方法参数中推断出类型参数，可以省略类型参数和调用中的尖括号</span></span><br><span class="line">MyMethod(myInt);</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法的示例"><a href="#泛型方法的示例" class="headerlink" title="泛型方法的示例"></a>泛型方法的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Simple</span> <span class="comment">//非泛型类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReverseAndPrint</span>&lt;<span class="title">T</span>&gt;(<span class="params">T[] arr</span>) <span class="comment">//泛型方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Array.Reverse(arr);</span><br><span class="line">        <span class="keyword">foreach</span> (T item <span class="keyword">in</span> arr) <span class="comment">//使用类型参数T</span></span><br><span class="line">            Console.Write( <span class="string">$&quot;<span class="subst">&#123;item.ToString()&#125;</span>, &quot;</span> );</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建各种类型的数组</span></span><br><span class="line">        <span class="keyword">var</span> intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span> &#125;;</span><br><span class="line">        <span class="keyword">var</span> stringArray = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;third&quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">var</span> doubleArray = <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">3.567</span>, <span class="number">7.891</span>, <span class="number">2.345</span> &#125;;</span><br><span class="line"></span><br><span class="line">        Simple.ReverseAndPrint&lt;<span class="built_in">int</span>&gt;(intArray);</span><br><span class="line">        Simple.ReverseAndPrint(intArray);</span><br><span class="line"></span><br><span class="line">        Simple.ReverseAndPrint&lt;<span class="built_in">string</span>&gt;(stringArray);</span><br><span class="line">        Simple.ReverseAndPrint(stringArray);</span><br><span class="line"></span><br><span class="line">        Simple.ReverseAndPrint&lt;<span class="built_in">double</span>&gt;(doubleArray);</span><br><span class="line">        Simple.ReverseAndPrint(doubleArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">11, 9, 7, 5, 3, </span><br><span class="line">3, 5, 7, 9, 11,</span><br><span class="line">third, second, first,</span><br><span class="line">first, second, third,</span><br><span class="line">2.345, 7.891, 3.567, </span><br><span class="line">3.567, 7.891, 2.345,</span><br></pre></td></tr></table></figure>
<h2 id="扩展方法和泛型类"><a href="#扩展方法和泛型类" class="headerlink" title="扩展方法和泛型类"></a>扩展方法和泛型类</h2><p>第8章介绍了扩展方法，它也可以与泛型类结合使用。它允许将类中的静态方法关联到不同的泛型类上，还允许像调用类实例方法来调用方法。和非泛型类一样，泛型类的扩展方法必须声明为 static ，必须是静态类的成员，第一个参数类型中必须有关键字 this ，后面是扩展的泛型类名字。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ExtendHolder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> Holder&lt;T&gt; h</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[] vals = h.GetValues();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; vals[<span class="number">0</span>] &#125;</span>,\t<span class="subst">&#123; vals[<span class="number">1</span>] &#125;</span>,\t<span class="subst">&#123; vals[<span class="number">2</span>] &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T[] Vals = <span class="keyword">new</span> T[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span>(<span class="params">T v0, T v1, T v2</span>)</span></span><br><span class="line">    &#123; Vals[<span class="number">0</span>] = v0; Vals[<span class="number">1</span>] = v1; Vals[<span class="number">2</span>] = v2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T[] <span class="title">GetValues</span>()</span> &#123; <span class="keyword">return</span> Vals; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> intHolder = <span class="keyword">new</span> Holder&lt;<span class="built_in">int</span>&gt;(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">var</span> stringHolder = <span class="keyword">new</span> Holder&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;c3&quot;</span>);</span><br><span class="line">        intHolder.Print();</span><br><span class="line">        stringHolder.Print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">3,      5,      7</span><br><span class="line">a1,     b2,     c3</span><br></pre></td></tr></table></figure>
<h2 id="泛型结构"><a href="#泛型结构" class="headerlink" title="泛型结构"></a>泛型结构</h2><p>泛型结构的规则与泛型类一样。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> PieceOfData&lt;T&gt; <span class="comment">//泛型结构</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PieceOfData</span>(<span class="params">T <span class="keyword">value</span></span>)</span> &#123; _data = <span class="keyword">value</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> T _data;</span><br><span class="line">    <span class="keyword">public</span> T Data</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _data; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _data = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> intData = <span class="keyword">new</span> PieceOfData&lt;<span class="built_in">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">var</span> stringData = <span class="keyword">new</span> PieceOfData&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Hi there.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;intData = <span class="subst">&#123; intData.Data &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;stringData = <span class="subst">&#123; stringData.Data &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">intData = 10</span><br><span class="line">stringData = Hi there.</span><br></pre></td></tr></table></figure>
<h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><p>声明泛型委托的语法：<code>delegate R MyDelegate&lt;T, R&gt;( T value );</code>，其中 R 为返回类型，<code>&lt;T, R&gt;</code>为类型参数，<code>( T value )</code>为委托形参。T 与 R 都为类型占位符。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span>;  <span class="comment">//泛型委托</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Simple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintString</span>(<span class="params"><span class="built_in">string</span> s</span>) <span class="comment">//方法匹配委托</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( s );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintUpperString</span>(<span class="params"><span class="built_in">string</span> s</span>) <span class="comment">//方法匹配委托</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; s.ToUpper() &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> myDel = <span class="keyword">new</span> MyDelegate&lt;<span class="built_in">string</span>&gt;(Simple.PrintString); <span class="comment">//创建委托的实例</span></span><br><span class="line">        myDel += Simple.PrintUpperString; <span class="comment">//添加方法</span></span><br><span class="line">        myDel(<span class="string">&quot;Hi There.&quot;</span>); <span class="comment">//调用委托</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Hi There.</span><br><span class="line">HI THERE.</span><br></pre></td></tr></table></figure>
<h3 id="另一个泛型委托示例"><a href="#另一个泛型委托示例" class="headerlink" title="另一个泛型委托示例"></a>另一个泛型委托示例</h3><p>C# 的 LINQ 特性大量使用了泛型委托，在介绍之前，有必要给出以下示例。第20章详细介绍 LINQ 。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TR <span class="title">Func</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, <span class="title">TR</span>&gt;(<span class="params">T1 p1, T2 p2</span>)</span>; <span class="comment">//泛型委托</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Simple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">string</span> <span class="title">PrintString</span>(<span class="params"><span class="built_in">int</span> p1, <span class="built_in">int</span> p2</span>) <span class="comment">//方法匹配委托</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> total = p1 + p2;</span><br><span class="line">        <span class="keyword">return</span> total.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> myDel = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">string</span>&gt;(Simple.PrintString); <span class="comment">//创建委托实例</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Total: <span class="subst">&#123; myDel(<span class="number">15</span>, <span class="number">13</span>) &#125;</span>&quot;</span>); <span class="comment">//调用委托</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Total: 28</span><br></pre></td></tr></table></figure>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口声明需要在接口名称之后的尖括号中放置类型参数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IMyIfc</span>&lt;<span class="title">T</span>&gt; <span class="comment">//泛型接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">ReturnIt</span>(<span class="params">T inValue</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Simple</span>&lt;<span class="title">S</span>&gt; : <span class="title">IMyIfc</span>&lt;<span class="title">S</span>&gt; <span class="comment">//泛型类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">ReturnIt</span>(<span class="params">S inValue</span>) <span class="comment">//实现泛型接口</span></span></span><br><span class="line">    &#123; <span class="keyword">return</span> inValue; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> trivInt = <span class="keyword">new</span> Simple&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">var</span> trivString = <span class="keyword">new</span> Simple&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; trivInt.ReturnIt(<span class="number">5</span>) &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; trivString.ReturnIt(<span class="string">&quot;Hi there.&quot;</span>) &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">Hi there.</span><br></pre></td></tr></table></figure>
<h3 id="使用泛型接口的示例"><a href="#使用泛型接口的示例" class="headerlink" title="使用泛型接口的示例"></a>使用泛型接口的示例</h3><p>以下示例展示了泛型接口的另外两个能力：<br>①与其他泛型相似，用不同类型参数实例化的泛型接口的实例是不同的接口；<br>②可以在非泛型类型中实现泛型接口。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IMyIfc</span>&lt;<span class="title">T</span>&gt; <span class="comment">//泛型接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">ReturnIt</span>(<span class="params">T inValue</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Simple</span> : <span class="title">IMyIfc</span>&lt;<span class="title">int</span>&gt;, <span class="title">IMyIfc</span>&lt;<span class="title">string</span>&gt; <span class="comment">//非泛型类，实现源于同一泛型接口的两个不同接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ReturnIt</span>(<span class="params"><span class="built_in">int</span> inValue</span>) <span class="comment">//实现int类型接口</span></span></span><br><span class="line">    &#123; <span class="keyword">return</span> inValue; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ReturnIt</span>(<span class="params"><span class="built_in">string</span> inValue</span>) <span class="comment">//实现string类型接口</span></span></span><br><span class="line">    &#123; <span class="keyword">return</span> inValue; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Simple trivial = <span class="keyword">new</span> Simple();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; trivial.ReturnIt(<span class="number">5</span>) &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; trivial.ReturnIt(<span class="string">&quot;Hi there.&quot;</span>) &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型接口的实现必须唯一"><a href="#泛型接口的实现必须唯一" class="headerlink" title="泛型接口的实现必须唯一"></a>泛型接口的实现必须唯一</h3><p>实现泛型类型接口时，必须保证类型实参的组合不会在类型中产生两个重复的接口。</p>
<p>如下示例，会产生编译时错误，因为 Simple 有可能会有两个相同类型的接口，这是不允许的：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IMyIfc</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">ReturnIt</span>(<span class="params">T inValue</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Simple</span>&lt;<span class="title">S</span>&gt; : <span class="title">IMyIfc</span>&lt;<span class="title">int</span>&gt;, <span class="title">IMyIfc</span>&lt;<span class="title">S</span>&gt; <span class="comment">//错误</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ReturnIt</span>(<span class="params"><span class="built_in">int</span> inValue</span>) <span class="comment">//实现第一个接口</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> inValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">ReturnIt</span>(<span class="params">S inValue</span>) <span class="comment">//实现第二个接口</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> inValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>泛型接口的名字不会和非泛型冲突。例如，上面的代码可以再声明一个名为 ImyIfc 的非泛型接口。</p>
</blockquote>
<h2 id="协变和逆变-Covariance-and-Contravariance"><a href="#协变和逆变-Covariance-and-Contravariance" class="headerlink" title="协变和逆变 Covariance and Contravariance"></a>协变和逆变 Covariance and Contravariance</h2><p>这个主题叫做<strong>可变性 variance</strong>，分为<strong>协变 covariance</strong> 、<strong>逆变 contravariance</strong> 、<strong>不变 invariance</strong> ：<br>①在 C# 中，协变和逆变能够实现数组类型、委托类型和泛型类型参数的隐式引用转换。<br>②如果泛型接口或委托的泛型参数被声明为协变或逆变，该泛型接口或委托则被称为<strong>变体</strong>。<br>③协变和逆变都是术语，前者指能够使用比原始指定的派生类型的派生程度更大（更具体的）的类型，后者指能够使用比原始指定的派生类型的派生程度更小（不太具体的）的类型。<br>④想要深入了解协变、逆变、不变，详见官方 .NET 文档。</p>
<h3 id="协变-Covariance"><a href="#协变-Covariance" class="headerlink" title="协变 Covariance"></a>协变 Covariance</h3><p>每一个变量都有一种类型，可以将派生类型的对象赋值给基类型的变量，这叫做<strong>赋值兼容性 assignment compatibility</strong> 。如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123; <span class="keyword">public</span> <span class="built_in">int</span> NumberOfLegs = <span class="number">4</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Animal( );</span><br><span class="line">        Animal a2 = <span class="keyword">new</span> Dog( );</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Number of dog legs: <span class="subst">&#123; a2.NumberOfLegs &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Number of dog legs: 4</span><br></pre></td></tr></table></figure>
<p>下面的例子为上面进行了扩展，但 Main 的第二行代码会产生一条编译错误，不能隐式得把右边的类型转换为左边的类型：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Legs = <span class="number">4</span>; &#125; <span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; &#125; <span class="comment">//派生类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">Factory</span>&lt;<span class="title">T</span>&gt;(<span class="params"> </span>)</span>; <span class="comment">//委托</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Dog <span class="title">MakeDog</span>(<span class="params"> </span>) <span class="comment">//匹配委托的方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog( );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Factory&lt;Dog&gt; dogMaker = MakeDog; <span class="comment">//创建委托对象，并保存方法的引用</span></span><br><span class="line">        Factory&lt;Animal&gt; animalMaker = dogMaker; <span class="comment">//尝试赋值委托对象</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine( animalMaker( ).Legs.ToString( ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码产生编译错误的原因是尽管 Dog 是 Animal 的派生类，但是委托 Factory&lt;Dog&gt; 没有从委托 Factory&lt;Animal&gt; 派生。这两个委托对象是同级的，都从 delegate 类型派生，又派生于 object 类型。两者之间没有派生关系，因此赋值兼容性不适用。</p>
<p>在上面示例的代码中，执行 animalMaker 委托是希望返回一个 Animal 对象的引用，所以如果返回 Dog 对象的引用也是可以的，因为赋值兼容性，但是委托类型不匹配，所以无法赋值。</p>
<p>可以启用委托之间的隐式转换，以便在具有泛型类型参数所指定的不同类型按变体的要求继承自对方时，可以将这些类型的泛型委托分配给对方。若要启用隐式转换，必须使用 in 或 out 关键字将委托中的泛型参数显式声明为协变或逆变。</p>
<p>如果通过增加 <strong>out 关键字</strong> 改变上面例子中的委托声明，代码就可以通过编译了：<code>delegate T Factory&lt;out T&gt;( );</code>，out 关键字指定了类型参数的协变。</p>
<h3 id="逆变-Contravariance"><a href="#逆变-Contravariance" class="headerlink" title="逆变 Contravariance"></a>逆变 Contravariance</h3><p>逆变关键字为 <strong>in</strong> ，如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> NumberOfLegs = <span class="number">4</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action1</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params"> T a </span>)</span>; <span class="comment">//in关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ActOnAnimal</span>(<span class="params"> Animal a </span>)</span> &#123; Console.WriteLine( a.NumberOfLegs ); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Action1&lt;Animal&gt; act1 = ActOnAnimal;</span><br><span class="line">        Action1&lt;Dog&gt; dog1 = act1;</span><br><span class="line">        dog1( <span class="keyword">new</span> Dog() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然委托 dog1 的方法接受 Animal 类对象，但是由于 Dog 类对象（派生程度更高）是 Animal 类派生的对象（派生程度更低），所以可以接受。</p>
<p>可以使用 <strong>in 关键字</strong>将泛型类型参数声明为逆变，来启用委托之间的隐式转换。</p>
<h3 id="接口的协变和逆变"><a href="#接口的协变和逆变" class="headerlink" title="接口的协变和逆变"></a>接口的协变和逆变</h3><p>示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; <span class="keyword">public</span> <span class="built_in">string</span> Name; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IMyIfc</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">GetFirst</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SimpleReturn</span>&lt;<span class="title">T</span>&gt;: <span class="title">IMyIfc</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T[] items = <span class="keyword">new</span> T[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetFirst</span>()</span> &#123; <span class="keyword">return</span> items[<span class="number">0</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params">IMyIfc&lt;Animal&gt; returner</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( returner.GetFirst().Name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SimpleReturn&lt;Dog&gt; dogReturner = <span class="keyword">new</span> SimpleReturn&lt;Dog&gt;();</span><br><span class="line">        dogReturner.items[<span class="number">0</span>] = <span class="keyword">new</span> Dog() &#123; Name = <span class="string">&quot;Avonlea&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        IMyIfc&lt;Animal&gt; animalReturner = dogReturner;</span><br><span class="line"></span><br><span class="line">        DoSomething(dogReturner);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Avonlea</span><br></pre></td></tr></table></figure>
<h3 id="关于可变性的其他内容"><a href="#关于可变性的其他内容" class="headerlink" title="关于可变性的其他内容"></a>关于可变性的其他内容</h3><p>可以将具有匹配签名的方法分配给委托，还可以将返回派生程度较大的派生类型的方法分配给委托（协变），或者如果方法所接受参数的派生类型所具有的派生程度小于委托类型指定的程度（逆变），也可将其分配给委托。方法签名与委托类型之间存在隐式转换，无需 out 或 in 关键字。如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Legs = <span class="number">4</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> T <span class="title">Factory</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Dog <span class="title">MakeDog</span>()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> Dog(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Factory&lt;Animal&gt; animalMaker1 = MakeDog; <span class="comment">//隐式转换</span></span><br><span class="line">        Factory&lt;Dog&gt; dogMaker = MakeDog;</span><br><span class="line"></span><br><span class="line">        Factory&lt;Animal&gt; animalMaker2 = dogMaker; <span class="comment">//需要out关键字</span></span><br><span class="line">        Factory&lt;Animal&gt; animalMaker3 = <span class="keyword">new</span> Factory&lt;Dog&gt;(MakeDog); <span class="comment">//需要out关键字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他有关可变性的重要事项：<br>①可变性只适用于引用类型，不能从值类型派生其他类型。<br>②使用 in 和 out 关键字的显式变化只适用于接口和委托，不适用于类、结构和方法；<br>③不包括 in 和 out 关键字的委托和接口类型参数是<strong>不变</strong>的，这些参数不能用于协变或逆变。</p>
<h1 id="第十九章-枚举器和迭代器"><a href="#第十九章-枚举器和迭代器" class="headerlink" title="第十九章 枚举器和迭代器"></a>第十九章 枚举器和迭代器</h1><h2 id="枚举器和可枚举类型-Enumerators-and-Enumerable-Types"><a href="#枚举器和可枚举类型-Enumerators-and-Enumerable-Types" class="headerlink" title="枚举器和可枚举类型 Enumerators and Enumerable Types"></a>枚举器和可枚举类型 Enumerators and Enumerable Types</h2><p>当为数组使用 foreach 语句：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> [] arr1 = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> arr1)  <span class="comment">//枚举元素</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Item value: <span class="subst">&#123; item &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>之所以可以循环打印这些值，是因为数组可以按需提供一个叫做<strong>枚举器 enumerator</strong> 的对象。枚举器可以依次返回请求的数组中的元素。获取对象枚举器的方法是调用对象的 <strong>GetEnumerator 方法</strong>。实现 GetEnumerator 方法的类型叫做<strong>可枚举类型 enumerable</strong>。枚举器和可枚举类型的关系如下图：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/03/04/Z5iezdoncO7XARU.png" width = "55%" height = "55%" alt="图89 - 枚举器和可枚举类型"/>
</div>

<p>foreach 结构被设计与可枚举类型一起使用，只有给它的遍历对象是可枚举类型，比如数组，它就会执行如下行为：<br>①通过调用 GetEnumerator 方法获取对象的枚举器；<br>②从枚举器中请求每一项并且把它作为<strong>迭代变量 iteration variable</strong>，代码可以读取该变量但不可以改变。</p>
<h2 id="IEnumerator-接口"><a href="#IEnumerator-接口" class="headerlink" title="IEnumerator 接口"></a>IEnumerator 接口</h2><p>实现 <strong>IEnumerator 接口</strong>的枚举器包含3个函数成员：Current、MoveNext 以及 Reset。<br>① Current 是返回序列中当前位置项的属性；<br>&emsp;&emsp;- 它是只读属性，返回 object 类型的引用，可能返回任意类型的对象。<br>② MoveNext 是把迭代器位置前进到集合中下一项的方法。它也返回布尔值，指示新的位置是有效位置还是已经超过了序列的尾部。<br>&emsp;&emsp;- 如果新位置有效，方法返回 true 。无效则返回 false 。枚举器的原始位置在序列中的第一项之前，因此 MoveNext 必须在第一次使用 Current 之前调用。<br>③ Reset 是把位置重置为原始状态的方法。</p>
<p>下图显示了3个项的集合，右边显示了枚举器。在下图中，枚举器是一个叫作 ArrEnumerator 类的实例：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/03/04/U5nE3NTkyDal2Xj.png" width = "70%" height = "70%" alt="图90 - 小集合的枚举器"/>
</div>

<p>有了集合的枚举器，可以使用上述成员来模仿 foreach 循环遍历集合中的项。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] arr1 = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line">    IEnumerator ie = arr1.GetEnumerator(); <span class="comment">//获取并存储枚举器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( ie.MoveNext() ) <span class="comment">//移到下一项</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> item = (<span class="built_in">int</span>) ie.Current; <span class="comment">//获取当前项</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Item value: <span class="subst">&#123; item &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果和内嵌的 foreach 语句一样：  </p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Item value: 10</span><br><span class="line">Item value: 11</span><br><span class="line">Item value: 12</span><br><span class="line">Item value: 13</span><br></pre></td></tr></table></figure>
<h2 id="IEnumerable-接口"><a href="#IEnumerable-接口" class="headerlink" title="IEnumerable 接口"></a>IEnumerable 接口</h2><p>可枚举类是指实现了 <strong>IEnumerable 接口</strong>的类。IEnumerable 接口只有一个成员： GetEnumerator 方法，它返回对象的枚举器。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/03/04/TsJoLhBuP23SEY4.png" width = "50%" height = "50%" alt="图91 - GetEnumerator 方法返回类的一个枚举器对象"/>
</div>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyColors</span>: <span class="title">IEnumerable</span> <span class="comment">//实现 IEnumerable 接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] Colors = &#123; <span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Yellow&quot;</span>, <span class="string">&quot;Blue&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>() <span class="comment">//返回 IEnumerator 类型的对象</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ColorEnumerator(Colors); <span class="comment">//枚举器类的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-IEnumerable-和-IEnumerator-的示例"><a href="#使用-IEnumerable-和-IEnumerator-的示例" class="headerlink" title="使用 IEnumerable 和 IEnumerator 的示例"></a>使用 IEnumerable 和 IEnumerator 的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ColorEnumerator</span> : <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] Colors;</span><br><span class="line">    <span class="built_in">int</span> Position = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorEnumerator</span>(<span class="params"> <span class="built_in">string</span>[] theColors </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Colors = <span class="keyword">new</span> <span class="built_in">string</span>[theColors.Length];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; theColors.Length; i++ )</span><br><span class="line">            Colors[i] = theColors[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( Position == <span class="number">-1</span> )</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException();</span><br><span class="line">            <span class="keyword">if</span> ( Position &gt;= Colors.Length )</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException();</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> Colors[Position];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( Position &lt; Colors.Length - <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Position++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Position = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Spectrum</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] Colors = &#123; <span class="string">&quot;violet&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;cyan&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;red&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ColorEnumerator( Colors );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Spectrum spectrum = <span class="keyword">new</span> Spectrum();</span><br><span class="line">        <span class="keyword">foreach</span> ( <span class="built_in">string</span> color <span class="keyword">in</span> spectrum )</span><br><span class="line">            Console.WriteLine( color );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">violet</span><br><span class="line">blue</span><br><span class="line">cyan</span><br><span class="line">green</span><br><span class="line">yellow</span><br><span class="line">orange</span><br><span class="line">red</span><br></pre></td></tr></table></figure>
<h2 id="泛型枚举接口"><a href="#泛型枚举接口" class="headerlink" title="泛型枚举接口"></a>泛型枚举接口</h2><p>上述提到的都是非泛型版本，大多数情况应该使用泛型版本 <strong>IEnumerable&lt;T&gt;</strong> and <strong>IEnumerator&lt;T&gt;</strong>。两者之间的差别如下：<br>①对于非泛型接口形式：<br>&emsp;&emsp;- IEnumerable 接口的 GetEnumerator 方法返回实现 IEnumerator 的枚举器类的实例；<br>&emsp;&emsp;- 实现 IEnumerator 的类实现了 Current 属性，它返回了 object 类型的引用，然后必须把它转换为对象的实际类型。<br>②泛型接口继承自非泛型接口。对于泛型接口形式：<br>&emsp;&emsp;- IEnumerable&lt;T&gt;接口的 GetEnumerator 方法返回实现 IEnumerator&lt;T&gt; 的枚举器类的实例；<br>&emsp;&emsp;- 实现 IEnumerator&lt;T&gt; 的类实现了 Current 属性，它返回实际类型的实例，而不是 object 基类的引用。<br>&emsp;&emsp;- 这些是协变接口，所以他们的实际声明是 IEnumerable&lt;out T&gt; 和 IEnumerator&lt;out T&gt; 。</p>
<p>非泛型接口的实现不是类型安全的，它们返回 object 类型的引用，然后必须转换为实际类型。而泛型接口的枚举器是类型安全的，它返回实际类型的引用。如果要创建自己的可枚举类，应该实现这些泛型接口。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/03/04/WljoyYb3ftNrUua.png" width = "70%" height = "70%" alt="图92 - 实现 IEnumerator<T> 接口的类的结构"/>
</div>

<div  align="center">  
<img src="https://s2.loli.net/2023/03/04/imKBweqSZFPdzNU.png" width = "60%" height = "60%" alt="图93 - 实现 IEnumerable<T> 接口的类的结构"/>
</div>

<h2 id="迭代器-Iterators"><a href="#迭代器-Iterators" class="headerlink" title="迭代器 Iterators"></a>迭代器 Iterators</h2><p><strong>迭代器 Iterators</strong> 这种结构可以让编译器把手动编码的可枚举类型和枚举器替换为由迭代器生成的可枚举类型和枚举器。示例如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">BlackAndWhite</span>() <span class="comment">//版本1，返回泛型枚举器，它返回的是字符串对象</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;gray&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;white&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另外一个版本，输出同样的结果：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">BlackAndWhite</span>() <span class="comment">//版本2，返回泛型枚举器，它返回的是字符串对象</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] theColors = &#123; <span class="string">&quot;black&quot;</span>, <span class="string">&quot;gray&quot;</span>, <span class="string">&quot;white&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; theColors.Length; i++)</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> theColors[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器块"><a href="#迭代器块" class="headerlink" title="迭代器块"></a>迭代器块</h3><p><strong>迭代器块</strong>是有一个或多个 <strong>yield 语句</strong>的代码块。方法、访问器和运算符都可以是迭代器块。</p>
<p>迭代器块与其他代码块不同。其他块包含的语句是命令式的，即先执行代码块的第一个语句，然后执行后面的语句，最后控制离开块。迭代器块不是需要在同一时间执行的一串命令式命令，而是声明性的，描述了如何枚举元素：<br>① <strong>yield return</strong> 语句指定了序列中要返回的下一项；<br>② <strong>yield break</strong> 语句指定了在序列中没有更多的其他项。<br>编译器得到有关如何枚举项的描述后，使用它来构建包含所有需要的方法和属性实现的枚举器类。产生的类被嵌套包含在声明迭代器的类中。根据迭代器的返回类型，可以让迭代器产生枚举器或可枚举类型。</p>
<h3 id="使用迭代器来创建枚举器"><a href="#使用迭代器来创建枚举器" class="headerlink" title="使用迭代器来创建枚举器"></a>使用迭代器来创建枚举器</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> BlackAndWhite(); &#125; <span class="comment">//返回枚举器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">BlackAndWhite</span>() <span class="comment">//返回枚举器的迭代器</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;gray&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;white&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> shade <span class="keyword">in</span> mc)</span><br><span class="line">            Console.WriteLine(shade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">black</span><br><span class="line">gray</span><br><span class="line">white</span><br></pre></td></tr></table></figure>
<h3 id="使用迭代器来创建可枚举类型"><a href="#使用迭代器来创建可枚举类型" class="headerlink" title="使用迭代器来创建可枚举类型"></a>使用迭代器来创建可枚举类型</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IEnumerable&lt;<span class="built_in">string</span>&gt; myEnumerable = BlackAndWhite(); <span class="comment">//获取可枚举类型</span></span><br><span class="line">        <span class="keyword">return</span> myEnumerable.GetEnumerator(); <span class="comment">//获取枚举器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">BlackAndWhite</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;gray&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;white&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> shade <span class="keyword">in</span> mc)</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; shade &#125;</span> &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> shade <span class="keyword">in</span> mc.BlackAndWhite()) <span class="comment">//使用类枚举器方法</span></span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; shade &#125;</span> &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">black gray white black gray white </span><br></pre></td></tr></table></figure>
<h2 id="常见迭代器模式"><a href="#常见迭代器模式" class="headerlink" title="常见迭代器模式"></a>常见迭代器模式</h2><p>总结上述的创建迭代器来返回可枚举类型或者枚举器：<br>①当实现返回枚举器的迭代器时，必须通过实现 GetEnumerator 来让类可枚举，它返回由迭代器返回的枚举器；<br>②在类中实现返回可枚举类型的迭代器时，可以让类实现 GetEnumerator 来让类本身可枚举，也可以不实现 GetEnumerator 。<br>&emsp;&emsp;- 如果实现 GetEnumerator ，让它调用迭代器方法以获取自动生成的实现 IEnumerable 的类示例。然后，从 IEnumerable 对象返回由 GetEnumerator 创建的枚举器；<br>&emsp;&emsp;- 如果不实现 GetEnumerator ，仍然可以使用由迭代器返回的可枚举类，只需直接调用迭代器方法。</p>
<h2 id="产生多个可枚举类型"><a href="#产生多个可枚举类型" class="headerlink" title="产生多个可枚举类型"></a>产生多个可枚举类型</h2><p>如下示例，尽管有两个方法返回可枚举类型，但类本身不是可枚举类型，因为它没有实现 GetEnumerator ：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Spectrum</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] colors = &#123; <span class="string">&quot;violet&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;cyan&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;red&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">UVtoIR</span>() <span class="comment">//返回一个可枚举类型</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; colors.Length; i++ )</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> colors[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">IRtoUV</span>() <span class="comment">//返回一个可枚举类型</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i=colors.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- )</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> colors[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Spectrum spectrum = <span class="keyword">new</span> Spectrum();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ( <span class="built_in">string</span> color <span class="keyword">in</span> spectrum.UVtoIR() )</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; color &#125;</span> &quot;</span> );</span><br><span class="line">        Console.WriteLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ( <span class="built_in">string</span> color <span class="keyword">in</span> spectrum.IRtoUV() )</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; color &#125;</span> &quot;</span> );</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">violet blue cyan green yellow orange red </span><br><span class="line">red orange yellow green cyan blue violet</span><br></pre></td></tr></table></figure>
<h2 id="将迭代器作为属性"><a href="#将迭代器作为属性" class="headerlink" title="将迭代器作为属性"></a>将迭代器作为属性</h2><p>将迭代器实现为属性而不是方法，示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Spectrum</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> _listFromUVtoIR;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span>[] colors = &#123; <span class="string">&quot;violet&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;cyan&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;red&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spectrum</span>(<span class="params"> <span class="built_in">bool</span> listFromUVtoIR </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _listFromUVtoIR = listFromUVtoIR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _listFromUVtoIR</span><br><span class="line">                    ? UVtoIR</span><br><span class="line">                    : IRtoUV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; UVtoIR</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; colors.Length; i++ )</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> colors[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; IRtoUV</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="built_in">int</span> i=colors.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- )</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> colors[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Spectrum startUV = <span class="keyword">new</span> Spectrum( <span class="literal">true</span> );</span><br><span class="line">        Spectrum startIR = <span class="keyword">new</span> Spectrum( <span class="literal">false</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ( <span class="built_in">string</span> color <span class="keyword">in</span> startUV )</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; color &#125;</span> &quot;</span> );</span><br><span class="line">        Console.WriteLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ( <span class="built_in">string</span> color <span class="keyword">in</span> startIR )</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; color &#125;</span> &quot;</span> );</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">violet blue cyan green yellow orange red </span><br><span class="line">red orange yellow green cyan blue violet</span><br></pre></td></tr></table></figure>
<h2 id="迭代器的实质"><a href="#迭代器的实质" class="headerlink" title="迭代器的实质"></a>迭代器的实质</h2><p>①迭代器需要 System.Collections.Generic 命名空间，需要 using 指令；<br>②在编译器生成的枚举器中，不支持 Reset 方法。当它被接口需要时会实现但是会抛出 System.NotSupportedException 异常。</p>
<p>在后台，由编译器生成的枚举器类是包含4个状态的状态机：<br>① Before，首次调用 MoveNext 之前的初始状态；<br>② Runing，调用 MoveNext 之后进入这个状态。在这个状态中，枚举器检测并设置下一项的位置。在遇到 yield return、yield break 或在迭代器体结束时，退出状态；<br>③ Suspended，状态机等待下次调用 MoveNext 的状态；<br>④ After，没有更多项可以枚举的状态。<br>如果状态机在 Before 或 Suspended 状态时调用了 MoveNext 方法，就转到 Running 状态。在 Running 状态中，它检测集合的下一项并设置位置。如果有更多项，状态机会转入 Suspended 状态；如果没有更多项，它转入并保持在 After 状态。</p>
<h1 id="第二十章-LINQ"><a href="#第二十章-LINQ" class="headerlink" title="第二十章 LINQ"></a>第二十章 LINQ</h1><h2 id="什么是-LINQ"><a href="#什么是-LINQ" class="headerlink" title="什么是 LINQ"></a>什么是 LINQ</h2><p>在关系型数据库中，数据被放入规范化的表里，通过 SQL 来进行访问。然后，和数据库相反，在程序中，数据被保存在差异很大的类对象或结构中。因此，使用 LINQ 可以轻松地查询对象集合。<br>① LINQ 代表<strong>语言集成查询 Language Integrated Query</strong> ；<br>② LINQ 是 .NET 框架的扩展，允许使用像 SQL 查询数据库的类似方式来查询数据集合；<br>③ 使用 LINQ，可以从数据库、对象集合以及 XML 文档等查询数据。</p>
<p>一个简单的示例如下，该例中，被查询的数据源是 int 数组。查询的定义就是带有 from 和 select 关键字的语句。尽管查询在语句中定义，直到最后的 foreach 语句请求其结果时才会执行：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] numbers = &#123; <span class="number">2</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">15</span> &#125;;</span><br><span class="line"></span><br><span class="line">    IEnumerable&lt;<span class="built_in">int</span>&gt; lowNums = <span class="comment">//定义并存储查询</span></span><br><span class="line">                        <span class="keyword">from</span> n <span class="keyword">in</span> numbers</span><br><span class="line">                        <span class="keyword">where</span> n &lt; <span class="number">10</span></span><br><span class="line">                        <span class="keyword">select</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> lowNums) <span class="comment">//执行查询</span></span><br><span class="line">        Console. Write(<span class="string">$&quot;<span class="subst">&#123; x &#125;</span>, &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">2, 5, </span><br></pre></td></tr></table></figure>
<h2 id="LINQ-提供程序"><a href="#LINQ-提供程序" class="headerlink" title="LINQ 提供程序"></a>LINQ 提供程序</h2><p>LINQ 除了可以查询程序在内存中的对象，还可以查询 SQL 数据库、XML 文档等等。对于每一个数据源类型，一定有根据该数据源类型实现 LINQ 查询的代码模块。这些模块叫做 <strong>LINQ 提供程序 provider</strong> 。微软为一些常见的数据源类型提供了 LINQ 提供程序；可以使用任何支持 LINQ 的语言，比如 C# ，来查询有 LINQ 提供程序的数据源类型。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/03/05/JyGjXQL4bot537p.png" width = "60%" height = "60%" alt="图94 - LINQ 的体系结构"/>
</div>

<p>本章主要介绍 LINQ to object 和 XML 。</p>
<h3 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h3><p><strong>匿名类型 anonymous type</strong> 经常用于 LINQ 查询的结果之中。创建匿名类型的变量与对象初始化语句相同，但是没有类名和构造函数，语法如下：<code>new &#123; FieldProp = InitExpr, FieldProp = InitExpr, ...&#125;</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> student = <span class="keyword">new</span> &#123;Name=<span class="string">&quot;Mary Jones&quot;</span>, Age=<span class="number">19</span>, Major=<span class="string">&quot;History&quot;</span>&#125;; <span class="comment">//必须使用var</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; student.Name &#125;</span>, Age <span class="subst">&#123; student.Age &#125;</span>, Major: <span class="subst">&#123;student.Major&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Mary Jones, Age 19, Major: History</span><br></pre></td></tr></table></figure>
<p>关于匿名类型的重要事项如下：<br>①匿名类型只能用于局部变量，不能用于类成员；<br>②由于匿名函数没有名字，必须使用 var 关键字作为变量类型；<br>③不能设置匿名类型对象的属性。编译器为匿名类型创建的属性是只读的；<br>④对于每一个成员初始化语句（即 FieldProp = InitExpr ），编译器推断其类型并创建一个只读属性来访问它的值。</p>
<p>除了对象初始化语句的赋值形式，匿名类型的对象初始化语句还有两个形式：简单标识符和成员访问表达式。这两种形式叫做<strong>投影初始化语句 projection initializers</strong> 。如下，展示了3种形式，第一个成员初始化语句是赋值形式，第二个是成员访问表达式，第三个是标识符形式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Other</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">string</span> Name = <span class="string">&quot;Mary Jones&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> Major = <span class="string">&quot;History&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> student = <span class="keyword">new</span> &#123; Age = <span class="number">19</span>, Other.Name, Major&#125;; <span class="comment">//分别为赋值、成员访问、标识符</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;student.Name &#125;</span>, Age <span class="subst">&#123;student.Age &#125;</span>, Major: <span class="subst">&#123;student.Major&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Mary Jones, Age 19, Major: History</span><br></pre></td></tr></table></figure>
<p>如果编译器遇到另一个具有相同的参数名、相同的推断类型和相同顺序的匿名类型对象初始化语句，它会重用这个类型并直接创建新的实例，不会创建新的匿名类型。</p>
<h2 id="方法语法和查询语法"><a href="#方法语法和查询语法" class="headerlink" title="方法语法和查询语法"></a>方法语法和查询语法</h2><p>使用 LINQ 查询时可以使用两种形式的语法：查询语法和方法语法。<br>①<strong>方法语法 method syntax</strong>：使用标准的方法调用，这些方法是一组叫作标准查询运算符的方法，见后面；方法语法是<strong>命令式的 imperative</strong> 的，它指明了查询方法调用的顺序。<br>②<strong>查询语法 query syntax</strong>：与 SQL 语句类似，使用查询表达式形式书写；查询语法是<strong>声明式 declarative</strong> 的，即查询描述的是想返回的但并没指明如何执行查询。<br>在一个查询中可以组合两种形式。编译器会将查询语法翻译为方法调用的形式，这两种形式在运行上没有性能差异。</p>
<p>微软推荐使用查询语法，因为易读清晰，但一些表达式必须用方法语法来书写。</p>
<p>示例如下，注意方法语法的 Where 方法的参数使用了 Lambda 表达式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] numbers = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">42</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> numsQuery = <span class="keyword">from</span> n <span class="keyword">in</span> numbers <span class="comment">//查询语法</span></span><br><span class="line">                    <span class="keyword">where</span> n &lt; <span class="number">20</span></span><br><span class="line">                    <span class="keyword">select</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> numsMethod = numbers.Where(N =&gt; N &lt; <span class="number">20</span>); <span class="comment">//方法语法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numsCount = (<span class="keyword">from</span> n <span class="keyword">in</span> numbers <span class="comment">//两种形式的合并</span></span><br><span class="line">                    <span class="keyword">where</span> n &lt; <span class="number">20</span></span><br><span class="line">                    <span class="keyword">select</span> n).Count();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> numsQuery)</span><br><span class="line">        Console.Write(<span class="string">$&quot;<span class="subst">&#123; x &#125;</span>, &quot;</span>);</span><br><span class="line">    Console.WriteLine();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> numsMethod)</span><br><span class="line">        Console.Write(<span class="string">$&quot;<span class="subst">&#123; x &#125;</span>, &quot;</span>);</span><br><span class="line">    Console.WriteLine();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(numsCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">2, 5, 17, 16, </span><br><span class="line">2, 5, 17, 16,</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="查询变量"><a href="#查询变量" class="headerlink" title="查询变量"></a>查询变量</h2><p>LINQ 查询返回两种类型的结果：枚举 enumeration （不是枚举类型），即满足查询参数的项列表；标量 scalar ，单一值，满足查询条件的结果的某种形式。</p>
<p>示例如下，第二个语句指定了一个 LINQ 查询，它可以用来枚举查询的结果；第三个语句调用 LINQ 方法，即 Count ，来返回从查询返回的项的总数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">28</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; lowNums = <span class="keyword">from</span> n <span class="keyword">in</span> numbers <span class="comment">//返回一个枚举</span></span><br><span class="line">                            <span class="keyword">where</span> n &lt; <span class="number">20</span></span><br><span class="line">                            <span class="keyword">select</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> numsCount = (<span class="keyword">from</span> n <span class="keyword">in</span> numbers <span class="comment">//返回一个整数</span></span><br><span class="line">                            <span class="keyword">where</span> n &lt; <span class="number">20</span></span><br><span class="line">                            <span class="keyword">select</span> n).Count();</span><br></pre></td></tr></table></figure>
<p>第二条和第三条语句等号左边的变量叫做<strong>查询变量 query variable</strong> 。虽然示例显示定义了查询变量类型，还是可以使用 var 关键字让编译器自行推断。</p>
<p>在执行前面的代码后，查询变量 lowNums 不会包含查询的结果，编译器会创建能够执行这个查询的代码；查询变量 numCount 包含真实的整数值。差异总结如下：<br>①如果查询表达式返回枚举，则查询一直到处理枚举时才会执行；<br>②如果枚举被处理多次，查询就会执行多次；<br>③如果在枚举返回之后、查询执行之前数据有改动，则查询会使用新的数据；<br>④如果查询表达式返回标量，查询立即执行，并且把结果保存在查询变量中。</p>
<h2 id="查询表达式的结构"><a href="#查询表达式的结构" class="headerlink" title="查询表达式的结构"></a>查询表达式的结构</h2><p><strong>查询表达式 Query Expressions</strong> 由 from 子句和查询主体组成。重要事项如下：<br>①子句必须按照一定顺序出现；<br>② from 子句和 select…group 子句这两部分是必需的；<br>③其他子句是可选的；<br>④在 LINQ 查询表达式中，select 子句在表达式最后。这与 SQL 的 SELECT 语句在查询的开始处不一样；<br>⑤可以有任意多的 from…let…where 子句，如下图：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/03/07/ybF7U8GiZxmXHeR.png" width = "65%" height = "65%" alt="图95 - 查询语句的结构"/>
</div>

<h3 id="from-子句"><a href="#from-子句" class="headerlink" title="from 子句"></a>from 子句</h3><p>from 子句的语法：<code>from Type Item in Items</code><br>① Type 是集合中元素的类型，这是可选的，因为编译器可以从集合中判断类型；<br>② Item 是迭代变量的名称，迭代变量逐个表示数据源的每一个元素；<br>③ Items 是要查询的集合的名字，集合必须是可枚举的。</p>
<p>示例如下，这段代码没有指明迭代变量的可选类型 int ：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr1 = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> item <span class="keyword">in</span> arr1</span><br><span class="line">            <span class="keyword">where</span> item &lt; <span class="number">13</span></span><br><span class="line">            <span class="keyword">select</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>( <span class="keyword">var</span> item <span class="keyword">in</span> query )</span><br><span class="line">Console.Write( <span class="string">$&quot;<span class="subst">&#123;item &#125;</span>,&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">10,11,12,</span><br></pre></td></tr></table></figure>
<p>from 子句可以有任意多个可选 join 子句：<code>from Type Identifier in Expression JoinClause</code> , join 子句见下一小节。</p>
<p>LINQ 的 from 子句和 foreach 语句很像，但不同点如下：<br>① foreach 语句命令式地指定了要从第一个到最后一个按顺序访问集合中的项；而 from 子句声明式地规定集合中的每一项都要被访问，但是没有假定顺序。<br>② foreach 语句在遇到代码时就执行其主体，而 from 子句什么也不执行。from 子句创建可执行查询的后台代码对象。只有在程序的控制流遇到访问查询变量的语句时，才会执行查询。</p>
<h3 id="join-子句"><a href="#join-子句" class="headerlink" title="join 子句"></a>join 子句</h3><p>LINQ 中的 join 子句和 SQL 中的 JOIN 子句很相似，不同的是不但可以在数据库的表上执行<strong>联结 join</strong> ，还可以在集合对象上进行这个操作。可以使用联结来结合两个或更多集合中的数据，联结操作接受两个集合，然后创建一个临时的对象集合，其中每一个对象包含两个原始集合对象中的所有字段。</p>
<p>联结的语法如下，它指定了第二个集合要和之前子句中的集合进行联结，注意必须使用上下文关键字 equals 来比较字段，不能用 == 运算符：<code>join Identifier in Collection2 on Field1 equals Field2</code>。</p>
<p>一个 join 子句的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line">            <span class="keyword">join</span> c <span class="keyword">in</span> studentsInCourses <span class="keyword">on</span> s.StID <span class="keyword">equals</span> c.StID</span><br></pre></td></tr></table></figure>
<h3 id="什么是联结"><a href="#什么是联结" class="headerlink" title="什么是联结"></a>什么是联结</h3><p>联结就是基于集合之间的共同字段连接集合方便查询，示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> StID;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> LastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CourseStudent</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> CourseName;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> StID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Student[] students = <span class="keyword">new</span> Student[] &#123;</span><br><span class="line">        <span class="keyword">new</span> Student &#123; StID = <span class="number">1</span>, LastName = <span class="string">&quot;Carson&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> Student &#123; StID = <span class="number">2</span>, LastName = <span class="string">&quot;Klassen&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> Student &#123; StID = <span class="number">3</span>, LastName = <span class="string">&quot;Fleming&quot;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> CourseStudent[] studentsInCourses = <span class="keyword">new</span> CourseStudent[] &#123;</span><br><span class="line">        <span class="keyword">new</span> CourseStudent &#123; CourseName = <span class="string">&quot;Art&quot;</span>, StID = <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> CourseStudent &#123; CourseName = <span class="string">&quot;Art&quot;</span>, StID = <span class="number">2</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> CourseStudent &#123; CourseName = <span class="string">&quot;History&quot;</span>, StID = <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> CourseStudent &#123; CourseName = <span class="string">&quot;History&quot;</span>, StID = <span class="number">3</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> CourseStudent &#123; CourseName = <span class="string">&quot;Physics&quot;</span>, StID = <span class="number">3</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//查找所有选择了历史课的学生的姓氏</span></span><br><span class="line">        <span class="keyword">var</span> query = <span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line">                    <span class="keyword">join</span> c <span class="keyword">in</span> studentsInCourses <span class="keyword">on</span> s.StID <span class="keyword">equals</span> c.StID</span><br><span class="line">                    <span class="keyword">where</span> c.CourseName == <span class="string">&quot;History&quot;</span></span><br><span class="line">                    <span class="keyword">select</span> s.LastName;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//显示所有选择了历史课的学生的名字</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> q <span class="keyword">in</span> query)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Student taking History: <span class="subst">&#123; q &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Student taking History: Carson</span><br><span class="line">Student taking History: Fleming</span><br></pre></td></tr></table></figure>
<h3 id="查找主体中的-from…let…where-片段"><a href="#查找主体中的-from…let…where-片段" class="headerlink" title="查找主体中的 from…let…where 片段"></a>查找主体中的 from…let…where 片段</h3><p>可选的 from…let…where 部分是查询主体的第一部分，可以由任意数量的3种子句构成：from 子句、let 子句和 where 子句。</p>
<p><strong>1、 from 子句</strong><br>查询表达式从必需的 from 子句开始，后面跟着查询主体。主体本身可以从任何数量的其他 from 子句开始，每一个子句都指定了一个额外的源数据集合并引入了在之后运算的迭代变量。</p>
<p>示例如下，第一个 from 子句是查询表达式必需的子句，第二个 from 子句是第一个子句的查询主体，select 子句创建了一个匿名类型的对象：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> groupA = <span class="keyword">new</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> groupB = <span class="keyword">new</span>[] &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> someInts = <span class="keyword">from</span> a <span class="keyword">in</span> groupA <span class="comment">//必需的第一个 from 子句</span></span><br><span class="line">                    <span class="keyword">from</span> b <span class="keyword">in</span> groupB <span class="comment">//查询主体的第一个子句</span></span><br><span class="line">                    <span class="keyword">where</span> a &gt; <span class="number">4</span> &amp;&amp; b &lt;= <span class="number">8</span></span><br><span class="line">                    <span class="keyword">select</span> <span class="keyword">new</span> &#123;a, b, sum = a + b&#125;; <span class="comment">//匿名类型对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> someInts)</span><br><span class="line">        Console.WriteLine(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&#123; a = 5, b = 6, sum = 11 &#125;</span><br><span class="line">&#123; a = 5, b = 7, sum = 12 &#125;</span><br><span class="line">&#123; a = 5, b = 8, sum = 13 &#125;</span><br><span class="line">&#123; a = 6, b = 6, sum = 12 &#125;</span><br><span class="line">&#123; a = 6, b = 7, sum = 13 &#125;</span><br><span class="line">&#123; a = 6, b = 8, sum = 14 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、let 子句</strong><br>let 子句接受一个表达式的运算并且把它赋值给一个需要在其他运算中使用的标识符。let 子句的语法如下：<code>let Identifier = Expression</code>。示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> groupA = <span class="keyword">new</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> groupB = <span class="keyword">new</span>[] &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> someInts = <span class="keyword">from</span> a <span class="keyword">in</span> groupA</span><br><span class="line">                    <span class="keyword">from</span> b <span class="keyword">in</span> groupB</span><br><span class="line">                    <span class="keyword">let</span> sum = a + b <span class="comment">//在新的变量中保存结果</span></span><br><span class="line">                    <span class="keyword">where</span> sum == <span class="number">12</span></span><br><span class="line">                    <span class="keyword">select</span> <span class="keyword">new</span> &#123;a, b, sum&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> someInts)</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&#123; a = 3, b = 9, sum = 12 &#125;</span><br><span class="line">&#123; a = 4, b = 8, sum = 12 &#125;</span><br><span class="line">&#123; a = 5, b = 7, sum = 12 &#125;</span><br><span class="line">&#123; a = 6, b = 6, sum = 12 &#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、where 子句</strong><br>where 子句根据之后的运算来去除不符合指定条件的项，语法如下：<code>where BooleanExpression</code>。只要是在 from…let…where 部分中，查询表达式可以有任意多个 where 子句，一个项必须满足所有 where 子句才能避免在之后被去除。示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> groupA = <span class="keyword">new</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> groupB = <span class="keyword">new</span>[] &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> someInts = <span class="keyword">from</span> <span class="built_in">int</span> a <span class="keyword">in</span> groupA</span><br><span class="line">                    <span class="keyword">from</span> <span class="built_in">int</span> b <span class="keyword">in</span> groupB</span><br><span class="line">                    <span class="keyword">let</span> sum = a + b</span><br><span class="line">                    <span class="keyword">where</span> sum &gt;= <span class="number">11</span> <span class="comment">//条件1</span></span><br><span class="line">                    <span class="keyword">where</span> a == <span class="number">4</span> <span class="comment">//条件2</span></span><br><span class="line">                    <span class="keyword">select</span> <span class="keyword">new</span> &#123;a, b, sum&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> someInts)</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&#123; a = 4, b = 7, sum = 11 &#125;</span><br><span class="line">&#123; a = 4, b = 8, sum = 12 &#125;</span><br><span class="line">&#123; a = 4, b = 9, sum = 13 &#125;</span><br></pre></td></tr></table></figure>
<h3 id="orderby-子句"><a href="#orderby-子句" class="headerlink" title="orderby 子句"></a>orderby 子句</h3><p>orderby 子句接受一个表达式并根据表达式按顺序返回结果项。语法为：<code>orderby Expression ascending/descending ,</code>。其中表达式通常是项的一个字段，可以是数值字段，也可以是字符串。orderby 子句的默认排序是升序，可选的 ascending 和 descending 关键字显式地设置元素的排序为升序或降序。可以有任意的 orderby 子句，它们必须用逗号分隔。示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> students = <span class="keyword">new</span> [] <span class="comment">//匿名类型的对象数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Jones&quot;</span>, FName=<span class="string">&quot;Mary&quot;</span>, Age=<span class="number">19</span>, Major=<span class="string">&quot;History&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Smith&quot;</span>, FName=<span class="string">&quot;Bob&quot;</span>, Age=<span class="number">20</span>, Major=<span class="string">&quot;CompSci&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Fleming&quot;</span>, FName=<span class="string">&quot;Carol&quot;</span>, Age=<span class="number">21</span>, Major=<span class="string">&quot;History&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> query = <span class="keyword">from</span> student <span class="keyword">in</span> students</span><br><span class="line">                <span class="keyword">orderby</span> student.Age</span><br><span class="line">                <span class="keyword">select</span> student;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> s <span class="keyword">in</span> query) &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; s.LName &#125;</span>, <span class="subst">&#123; s.FName &#125;</span>: <span class="subst">&#123; s.Age &#125;</span>, <span class="subst">&#123; s.Major &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Jones, Mary: 19, History</span><br><span class="line">Smith, Bob: 20, CompSci</span><br><span class="line">Fleming, Carol: 21, History</span><br></pre></td></tr></table></figure>
<h3 id="select…group-子句"><a href="#select…group-子句" class="headerlink" title="select…group 子句"></a>select…group 子句</h3><p>select…group 由两种类型的子句组成：select 子句和 group…by 子句。<br>① select 子句指定应该选择所选对象的哪些部分，可以指定整个数据项、数据项的一个字段或者数据项中几个字段组成的新对象（见下面查询中的匿名类型）。<br>② group…by 子句是可选的，用来指定选择的项如何被分组，见后面。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> students = <span class="keyword">new</span>[] <span class="comment">//匿名类型的对象数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Jones&quot;</span>, FName=<span class="string">&quot;Mary&quot;</span>, Age=<span class="number">19</span>, Major=<span class="string">&quot;History&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Smith&quot;</span>, FName=<span class="string">&quot;Bob&quot;</span>, Age=<span class="number">20</span>, Major=<span class="string">&quot;CompSci&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Fleming&quot;</span>, FName=<span class="string">&quot;Carol&quot;</span>, Age=<span class="number">21</span>, Major=<span class="string">&quot;History&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> query1 = <span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line">                    <span class="keyword">select</span> s; <span class="comment">//选择整个数据项</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> q <span class="keyword">in</span> query1)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; q.LName &#125;</span>, <span class="subst">&#123; q.FName &#125;</span>: <span class="subst">&#123; q.Age &#125;</span>, <span class="subst">&#123; q.Major &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> query2 = <span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line">                    <span class="keyword">select</span> s.LName; <span class="comment">//选择对象的某些字段</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> q <span class="keyword">in</span> query2)</span><br><span class="line">            Console.WriteLine(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Jones, Mary: 19, History</span><br><span class="line">Smith, Bob: 20, CompSci</span><br><span class="line">Fleming, Carol: 21, History</span><br><span class="line">Jones</span><br><span class="line">Smith</span><br><span class="line">Fleming</span><br></pre></td></tr></table></figure>
<h3 id="查询中的匿名类型"><a href="#查询中的匿名类型" class="headerlink" title="查询中的匿名类型"></a>查询中的匿名类型</h3><p>查询结果可以由原始集合的项、原始集合中项的字段或匿名类型组成。可以通过在 select 子句中把希望在类型中包括的字段以逗号分隔，并以大括号包围来创建匿名类型，语法如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> students = <span class="keyword">new</span>[] <span class="comment">//匿名类型的对象数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Jones&quot;</span>, FName=<span class="string">&quot;Mary&quot;</span>, Age=<span class="number">19</span>, Major=<span class="string">&quot;History&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Smith&quot;</span>, FName=<span class="string">&quot;Bob&quot;</span>, Age=<span class="number">20</span>, Major=<span class="string">&quot;CompSci&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Fleming&quot;</span>, FName=<span class="string">&quot;Carol&quot;</span>, Age=<span class="number">21</span>, Major=<span class="string">&quot;History&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> query = <span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line">                    <span class="keyword">select</span> <span class="keyword">new</span> &#123; s.LName, s.FName, s.Major &#125;; <span class="comment">//创建匿名类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> q <span class="keyword">in</span> query)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; q.FName &#125;</span> <span class="subst">&#123; q.LName &#125;</span> -- <span class="subst">&#123; q.Major&#125;</span>&quot;</span>); <span class="comment">//匿名类型的访问字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Mary Jones -- History</span><br><span class="line">Bob Smith -- CompSci</span><br><span class="line">Carol Fleming -- History</span><br></pre></td></tr></table></figure>
<h3 id="group-子句"><a href="#group-子句" class="headerlink" title="group 子句"></a>group 子句</h3><p>group 子句根据指定的标准对选择的对象进行分组。<br>①如果项包含在查询的结果中，它们就可以根据某个字段的值进行分组，作为分组依据的数据叫做<strong>键 key</strong> ；<br>② group 子句返回的不是原始数据源中项的枚举，而是返回可以枚举的已经形成的项的分组可枚举类型；<br>③分组本身是可枚举类型，它们可以枚举实际的项。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> students = <span class="keyword">new</span>[] <span class="comment">//匿名类型的对象数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Jones&quot;</span>, FName=<span class="string">&quot;Mary&quot;</span>, Age=<span class="number">19</span>, Major=<span class="string">&quot;History&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Smith&quot;</span>, FName=<span class="string">&quot;Bob&quot;</span>, Age=<span class="number">20</span>, Major=<span class="string">&quot;CompSci&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Fleming&quot;</span>, FName=<span class="string">&quot;Carol&quot;</span>, Age=<span class="number">21</span>, Major=<span class="string">&quot;History&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> query = <span class="keyword">from</span> student <span class="keyword">in</span> students</span><br><span class="line">                <span class="keyword">group</span> student <span class="keyword">by</span> student.Major;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> g <span class="keyword">in</span> query) <span class="comment">//枚举分组</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, g.Key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> s <span class="keyword">in</span> g) <span class="comment">//枚举分组中的项</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot; <span class="subst">&#123; s.LName &#125;</span>, <span class="subst">&#123; s.FName &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">History</span><br><span class="line"> Jones, Mary</span><br><span class="line"> Fleming, Carol</span><br><span class="line">CompSci</span><br><span class="line"> Smith, Bob</span><br></pre></td></tr></table></figure>
<p>下图演示了从查询表达式返回并保存于查询变量中的对象：<br>①从查询表达式返回的对象是从查询中枚举分组结果的可枚举类型；<br>②每一个分组由一个叫做键的字段区分；<br>③每一个分组本身是可枚举类型并且可以枚举它的项。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/03/11/qVzFHNBl5svUwky.png" width = "65%" height = "65%" alt="图96 - group子句返回对象集合的集合"/>
</div>

<h3 id="查询延续：into-子句"><a href="#查询延续：into-子句" class="headerlink" title="查询延续：into 子句"></a>查询延续：into 子句</h3><p>查询延续子句可以接受查询的一部分的结果并赋予一个名字，从而可以在查询的另一部分中使用，示例如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> groupA = <span class="keyword">new</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> groupB = <span class="keyword">new</span>[] &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> someInts = <span class="keyword">from</span> a <span class="keyword">in</span> groupA</span><br><span class="line">                    <span class="keyword">join</span> b <span class="keyword">in</span> groupB <span class="keyword">on</span> a <span class="keyword">equals</span> b</span><br><span class="line">                    <span class="keyword">into</span> groupAandB <span class="comment">//查询延续</span></span><br><span class="line">                    <span class="keyword">from</span> c <span class="keyword">in</span> groupAandB</span><br><span class="line">                    <span class="keyword">select</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> v <span class="keyword">in</span> someInts)</span><br><span class="line">        Console.Write(<span class="string">$&quot;<span class="subst">&#123; v &#125;</span> &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">4 5 6</span><br></pre></td></tr></table></figure>
<h2 id="标准查询运算符"><a href="#标准查询运算符" class="headerlink" title="标准查询运算符"></a>标准查询运算符</h2><p>标准查询运算符由一系列 API 方法组成，可以查询任何 .NET 数组或集合。标准查询运算符的重要特性如下：<br>①标准查询运算符使用方法语法；<br>②一些运算符返回 IEnumerable 对象，而其他运算符返回标量。返回标量的运算符立即执行查询，并返回一个值，而不是一个可枚举类型对象。ToArray( )、ToList( )等 ToCollection 运算符也会立即执行；<br>③很多操作都是以一个谓词作为参数。<strong>谓词 predicate</strong> 是一个方法，它以对象为参数，根据对象是否满足某个条件而返回 true 或 false 。<br>④被查询的集合对象叫作<strong>序列 sequence</strong> ，它必须实现 IEnumerable&lt;T&gt;接口。</p>
<p>示例如下，用作方法的运算符直接作用于序列对象，在这里就是 numbers 数组，返回类型是 int ：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span>[] numbers = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> total = numbers.Sum();</span><br><span class="line">        <span class="built_in">int</span> howMany = numbers.Count();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Total: <span class="subst">&#123; total &#125;</span>, Count: <span class="subst">&#123; howMany &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Total: 12, Count: 3</span><br></pre></td></tr></table></figure>
<p>有大量标准查询运算符，可用来操作一个或多个序列。序列指实现了 IEnumerable&lt; &gt;接口的类，包括 List&lt; &gt;、Dictionary&lt; &gt;、Stack&lt; &gt;、Array 等。如下表，列出了这些运算符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Where</td>
<td style="text-align:left">根据给定的谓词对序列进行过滤</td>
</tr>
<tr>
<td style="text-align:left">Select</td>
<td style="text-align:left">指定要包含一个对象或对象的一部分</td>
</tr>
<tr>
<td style="text-align:left">SelectMany</td>
<td style="text-align:left">一种查询类型，返回集合的集合。该方法将这些结果合并为一个单独的集合</td>
</tr>
<tr>
<td style="text-align:left">Take</td>
<td style="text-align:left">接受一个输出参数count，返回序列中的前count个对象</td>
</tr>
<tr>
<td style="text-align:left">Skip</td>
<td style="text-align:left">接受一个输出参数count，跳过序列中的前count个对象，返回剩余对象</td>
</tr>
<tr>
<td style="text-align:left">TakeWhile</td>
<td style="text-align:left">接受一个谓词，开始迭代序列，只要谓词对当前项的计算结果为true，就选择该项。在谓词返回第一个false时，该项和其余项都被丢弃</td>
</tr>
<tr>
<td style="text-align:left">SkipWhile</td>
<td style="text-align:left">接受一个谓词，开始迭代序列，只要谓词对当前项的计算结果为true，就跳过该项。在谓词返回第一个false时，该项和其余项都被选择</td>
</tr>
<tr>
<td style="text-align:left">Join</td>
<td style="text-align:left">对两个序列执行内联结</td>
</tr>
<tr>
<td style="text-align:left">GroupJoin</td>
<td style="text-align:left">可以产生层次结果的联结，第一个序列中的各个元素都与第二个序列中的元素集合相关联</td>
</tr>
<tr>
<td style="text-align:left">Concat</td>
<td style="text-align:left">连接两个序列</td>
</tr>
<tr>
<td style="text-align:left">OrderBy/ThenBy</td>
<td style="text-align:left">根据一个或多个键对序列中的元素按升序排序</td>
</tr>
<tr>
<td style="text-align:left">Reverse</td>
<td style="text-align:left">反转序列中的元素</td>
</tr>
<tr>
<td style="text-align:left">GroupBy</td>
<td style="text-align:left">分组序列中的元素</td>
</tr>
<tr>
<td style="text-align:left">Distinct</td>
<td style="text-align:left">去除序列中的重复项</td>
</tr>
<tr>
<td style="text-align:left">Union</td>
<td style="text-align:left">返回两个序列的并集</td>
</tr>
<tr>
<td style="text-align:left">Intersect</td>
<td style="text-align:left">返回两个序列的交集</td>
</tr>
<tr>
<td style="text-align:left">Except</td>
<td style="text-align:left">操作两个序列。返回的是第一个序列中不重复的元素减去同样位于第二个序列中的元素</td>
</tr>
<tr>
<td style="text-align:left">AsEnumerable</td>
<td style="text-align:left">将序列作为IEnumerable&lt;TSource&gt;返回</td>
</tr>
<tr>
<td style="text-align:left">AsQueryable</td>
<td style="text-align:left">将IEnumerable转换为IQueryable</td>
</tr>
<tr>
<td style="text-align:left">ToArray</td>
<td style="text-align:left">将序列作为数组返回</td>
</tr>
<tr>
<td style="text-align:left">ToList</td>
<td style="text-align:left">将序列作为List&lt;T&gt;返回</td>
</tr>
<tr>
<td style="text-align:left">ToDictionary</td>
<td style="text-align:left">将序列作为Dictionary&lt;TKey, TElement&gt;返回</td>
</tr>
<tr>
<td style="text-align:left">ToLookup</td>
<td style="text-align:left">将序列作为LookUp&lt;TKey, TElement&gt;返回</td>
</tr>
<tr>
<td style="text-align:left">OfType</td>
<td style="text-align:left">返回的序列中的元素是指定的类型</td>
</tr>
<tr>
<td style="text-align:left">Cast</td>
<td style="text-align:left">将序列中所有元素强制转换为给定的类型</td>
</tr>
<tr>
<td style="text-align:left">SequenceEqual</td>
<td style="text-align:left">返回一个布尔值，指定两个序列是否相等</td>
</tr>
<tr>
<td style="text-align:left">First</td>
<td style="text-align:left">返回序列中第一个与谓词匹配的元素。如果没有元素与谓词匹配，就抛出InvalidOperationException</td>
</tr>
<tr>
<td style="text-align:left">FirstOrDefault</td>
<td style="text-align:left">返回序列中第一个与谓词匹配的元素。如果没有给出谓词，方法返回序列的第一个元素。如果没有元素与谓词匹配，就使用该类型的默认值</td>
</tr>
<tr>
<td style="text-align:left">Last</td>
<td style="text-align:left">返回序列中最后一个与谓词匹配的元素。如果没有元素与谓词匹配，就抛出InvalidOperationException</td>
</tr>
<tr>
<td style="text-align:left">LastOrDefault</td>
<td style="text-align:left">返回序列中最后一个与谓词匹配的元素。如果没有元素与谓词匹配，就使用该类型的默认值</td>
</tr>
<tr>
<td style="text-align:left">Single</td>
<td style="text-align:left">返回序列中与谓词匹配的单个元素。如果没有元素匹配，或多于一个元素匹配，就抛出异常</td>
</tr>
<tr>
<td style="text-align:left">SingleOrDefault</td>
<td style="text-align:left">返回序列中与谓词匹配的单个元素。如果没有元素匹配，或多于一个元素匹配，就返回默认值</td>
</tr>
<tr>
<td style="text-align:left">ElementAt</td>
<td style="text-align:left">给定一个参数n，返回序列中第n+1个元素</td>
</tr>
<tr>
<td style="text-align:left">ElementAtOrDefault</td>
<td style="text-align:left">给定一个参数n，返回序列中第n+1个元素。如果索引超出范围，就返回默认值</td>
</tr>
<tr>
<td style="text-align:left">DefaultIfEmpty</td>
<td style="text-align:left">提供一个在序列为空时的默认值</td>
</tr>
<tr>
<td style="text-align:left">Range</td>
<td style="text-align:left">给定一个start整形和count整形，该方法返回的序列包含count个整形，其中第一个元素的值为start，每个后续元素都比前一个大1</td>
</tr>
<tr>
<td style="text-align:left">Repeat</td>
<td style="text-align:left">给定一个T类型的element和一个count整数，该方法返回的序列具有count个element副本</td>
</tr>
<tr>
<td style="text-align:left">Empty</td>
<td style="text-align:left">返回给定类型T的空序列</td>
</tr>
<tr>
<td style="text-align:left">Any</td>
<td style="text-align:left">返回一个布尔值，指明序列中是否存在满足谓词的元素</td>
</tr>
<tr>
<td style="text-align:left">All</td>
<td style="text-align:left">返回一个布尔值，指明序列中的全部元素是否都满足谓词</td>
</tr>
<tr>
<td style="text-align:left">Contains</td>
<td style="text-align:left">返回一个布尔值，指明序列中是否包含给定的元素</td>
</tr>
<tr>
<td style="text-align:left">Count</td>
<td style="text-align:left">返回序列中元素的个数（int）。它的重载可以接受一个谓词，并返回序列中满足谓词的元素个数</td>
</tr>
<tr>
<td style="text-align:left">Sum</td>
<td style="text-align:left">返回序列中值的总数</td>
</tr>
<tr>
<td style="text-align:left">Min</td>
<td style="text-align:left">返回序列中最小的值</td>
</tr>
<tr>
<td style="text-align:left">Max</td>
<td style="text-align:left">返回序列中最大的值</td>
</tr>
<tr>
<td style="text-align:left">Average</td>
<td style="text-align:left">返回序列中的平均值</td>
</tr>
<tr>
<td style="text-align:left">Aggregate</td>
<td style="text-align:left">连续对序列中的各个元素应用给定的函数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="标准查询运算符的签名"><a href="#标准查询运算符的签名" class="headerlink" title="标准查询运算符的签名"></a>标准查询运算符的签名</h3><p>System.Linq.Enumerable 类声明了标准查询运算符方法。然而，这些方法不仅仅是普通方法，它们是扩展了 IEnumerable&lt;T&gt;泛型类的扩展方法。第8章和第18章中介绍了扩展方法，但本节更为详细。</p>
<p>扩展方法是公有的静态方法，尽管定义在一个类中，但目的是为另一个类（第一个形参）增加功能，该参数前必须有关键字 this 。</p>
<p>有关签名的重要事项：<br>①由于运算符是泛型方法，因此每个方法名都具有相关的泛型参数（T）；<br>②由于运算符是扩展 IEnumerable 类的扩展方法，必须声明为 public 和 static ，在第一个参数前有 this 扩展指示器，把 IEnumerable&lt;T&gt;作为第一个参数类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>      <span class="built_in">int</span>       <span class="title">Count</span>&lt;<span class="title">T</span>&gt;(<span class="params"> <span class="keyword">this</span> IEnumerable&lt;T&gt; source </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>       T        <span class="title">First</span>&lt;<span class="title">T</span>&gt;(<span class="params"> <span class="keyword">this</span> IEnumerable&lt;T&gt; source </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IEnumerable</span>&lt;<span class="title">T</span>&gt; <span class="title">Where</span>&lt;<span class="title">T</span>&gt;(<span class="params"> <span class="keyword">this</span> IEnumerable&lt;T&gt; source, ... </span>)</span>;</span><br></pre></td></tr></table></figure>
<p>如下代码，演示了直接调用扩展方法和将其作为扩展进行调用的区别。前两次的直接调用和普通方法类似，传入数组名字作为第一个参数。方法语法调用和扩展语法调用在语义上完全相等，只是语法不同：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> count1 = Enumerable.Count(intArray); <span class="comment">//方法语法</span></span><br><span class="line">    <span class="keyword">var</span> firstNum1 = Enumerable.First(intArray); <span class="comment">//方法语法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> count2 = intArray.Count(); <span class="comment">//扩展语法</span></span><br><span class="line">    <span class="keyword">var</span> firstNum2 = intArray.First(); <span class="comment">//扩展语法</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Count: <span class="subst">&#123; count1 &#125;</span>, FirstNumber: <span class="subst">&#123; firstNum1 &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Count: <span class="subst">&#123; count2 &#125;</span>, FirstNumber: <span class="subst">&#123; firstNum2 &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Count: 6, FirstNumber: 3</span><br><span class="line">Count: 6, FirstNumber: 3</span><br></pre></td></tr></table></figure>
<h3 id="查询表达式和标准查询运算符"><a href="#查询表达式和标准查询运算符" class="headerlink" title="查询表达式和标准查询运算符"></a>查询表达式和标准查询运算符</h3><p>每一个查询表达式都可以使用带有标准查询运算符的方法语法来编写。编译器把每一个查询表达式翻译成标准查询运算符的形式。由于所有查询表达式都被翻译成标准查询运算符，因此运算符可以执行由查询表达式完成的任何操作，而且运算符还有查询表达式形式所不能提供的附加功能。例如，在之前示例中使用的 Sum 和 Count 运算符，可以只用方法语法来表示。</p>
<p>查询表达式和方法语法这两种表达式也可以组合，示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> numbers = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> howMany = (<span class="keyword">from</span> n <span class="keyword">in</span> numbers</span><br><span class="line">                   <span class="keyword">where</span> n &lt; <span class="number">7</span></span><br><span class="line">                   <span class="keyword">select</span> n).Count();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Count: <span class="subst">&#123; howMany &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Count: 3</span><br></pre></td></tr></table></figure>
<h3 id="将委托作为参数"><a href="#将委托作为参数" class="headerlink" title="将委托作为参数"></a>将委托作为参数</h3><p>每一个运算符的第一个参数是 IEnumerable&lt;T&gt; 对象的引用，之后的参数可以是任何类型。很多运算符接受泛型委托作为参数，泛型委托用于给运算符提供用户定义的代码，解释如下：</p>
<p>比如 Count 运算符被重载且有两种形式。第一种形式，即之前的示例，它有一个参数，返回集合中元素的个数，签名如下：<code>public static int Count&lt;T&gt;(this IEnumerable&lt;T&gt; source);</code></p>
<p>但若希望计算数组中奇数元素的总数，需为 Count 方法提供检测整数是否为奇数的代码，为此要使用 Count 方法的第二种形式，它接受一个泛型委托作为其第二个参数。调用时，必须提供一个接受单个 T 类型的输入参数并返回布尔值的委托对象，委托代码的返回值必须指定元素是否应包含在总数中：<code>public static int Count&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate );</code></p>
<p>示例如下，对于集合的每次遍历，Count 调用 Lambda 表达式表示的方法并把当前值作为输入，如果输入的是奇数，方法返回 true，Count 会把这个元素包含在总数中：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> countOdd = intArray.Count(n =&gt; n % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Count of odd numbers: <span class="subst">&#123; countOdd &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Count of odd numbers: 4</span><br></pre></td></tr></table></figure>
<h3 id="LINQ-预定义的委托类型"><a href="#LINQ-预定义的委托类型" class="headerlink" title="LINQ 预定义的委托类型"></a>LINQ 预定义的委托类型</h3><p>和前面的 Count 运算符类似，很多 LINQ 运算符需要提供代码来指示运算符如何执行它的操作，通过把委托对象作为参数来实现。.NET 框架定义了两套泛型委托来用于标准查询运算符，即 <strong>Func 委托</strong>和 <strong>Action 委托</strong>，各有19个成员。用作运算符实参的委托对象必须是这些形式之一。</p>
<p>下面列出了前4个泛型 Func 委托。TR 表示返回值，总是类型参数列表中的最后一个。&lt; &gt; 里的为类型参数，( ) 里的为方法参数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TR <span class="title">Func</span>&lt;<span class="keyword">out</span> <span class="title">TR</span>&gt;                     (<span class="params"> </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TR <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">out</span> <span class="title">TR</span> &gt;             (<span class="params"> T1 a1 </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TR <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>, <span class="keyword">out</span> <span class="title">TR</span> &gt;      (<span class="params"> T1 a1, T2 a2 </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TR <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>, <span class="keyword">in</span> <span class="title">T3</span>, <span class="keyword">out</span> <span class="title">TR</span>&gt;(<span class="params"> T1 a1, T2 a2, T3 a3 </span>)</span>;</span><br></pre></td></tr></table></figure>
<p>注意返回类型参数有一个 out 关键字，使之可以协变。输入参数有个 in 关键字，使之可以逆变。</p>
<p>Count 的声明（第二种形式）里，第二个参数必须是上面说的委托对象，它接受单个 T 类型的值作为方法参数并且返回一个 bool 类型的值。如之前所说，这种形式的委托称为<strong>谓词</strong>。</p>
<p>以下是前4个 Action 委托，与 Func 委托类似，但没有返回值：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>                     (<span class="params"> </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>&gt;              (<span class="params"> T1 a1 </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>&gt;       (<span class="params"> T1 a1, T2 a2 </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>, <span class="keyword">in</span> <span class="title">T3</span>&gt;(<span class="params"> T1 a1, T2 a2, T3 a3 </span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用委托参数的示例"><a href="#使用委托参数的示例" class="headerlink" title="使用委托参数的示例"></a>使用委托参数的示例</h3><p>以下代码先声明了 IsOdd 方法，接受单个 int 类型的参数，并且返回表示输入参数是否为奇数的 bool 值，并且使用该方法来初始化名称为 MyDel 的委托对象。不需要声明 Func 委托类型，因为 .NET 框架已经预定义了：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsOdd</span>(<span class="params"><span class="built_in">int</span> x</span>) <span class="comment">//委托对象使用的方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span>; <span class="comment">//如果x是奇数，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; myDel = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;(IsOdd); <span class="comment">//委托对象</span></span><br><span class="line">        <span class="keyword">var</span> countOdd = intArray.Count(myDel); <span class="comment">//使用委托</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Count of odd numbers: <span class="subst">&#123; countOdd &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Count of odd numbers: 4</span><br></pre></td></tr></table></figure>
<h3 id="使用-Lambda-表达式参数的示例"><a href="#使用-Lambda-表达式参数的示例" class="headerlink" title="使用 Lambda 表达式参数的示例"></a>使用 Lambda 表达式参数的示例</h3><p>之前的示例使用独立的方法和委托来把代码附加到运算符上，这需要声明方法和委托对象，然后把委托对象传递给运算符。也可以使用 Lambda 表达式来给运算符提供代码，使用 Lambda 表达式修改之前的示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> countOdd = intArray.Count( x =&gt; x % <span class="number">2</span> == <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Count of odd numbers: <span class="subst">&#123; countOdd &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Count of odd numbers: 4</span><br></pre></td></tr></table></figure>
<p>也可以使用匿名方法，见第14章委托，来代替 Lambda 表达式，但是不如 Lambda 表达式简洁：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; myDel = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">                                &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> countOdd = intArray.Count(myDel);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Count of odd numbers: <span class="subst">&#123; countOdd &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LINQ-to-XML"><a href="#LINQ-to-XML" class="headerlink" title="LINQ to XML"></a>LINQ to XML</h2><p><strong>可扩展标记语言 Extensible Markup Language ( XML )</strong> 是存储和交换数据的重要方法。LINQ 为该语言增加了一些特性，简化了 XML 的创建、查询和操作：<br>①可以使用单一语句自顶而下创建 XML 树；<br>②可以在不使用包含树的 XML 文档在内存中创建并操作 XML ；<br>③可以不使用 Text 子节点来创建和操作字符串节点；<br>④搜索 XML 树时，不需要遍历它。只需要查询树并让它返回想要的结果。</p>
<h3 id="标记语言"><a href="#标记语言" class="headerlink" title="标记语言"></a>标记语言</h3><p><strong>标记语言 markup language</strong> 是文档中的一组标签，它提供有关文档的信息并组织其内容。即标记语言不是文档的数据，它们包含关于数据的数据(元数据)。标记语言是定义的一组标签，旨在传递有关文档内容的特定类型的元数据，比如 HTML 的标签中的元数据包含了 Web 页面如何在浏览器中呈现以及如何使用超链接在页面中导航的信息。</p>
<p>大部分标记语言包含一组预定义的标签，而 XML 只包含少量预定义的标签，其他由程序员定义，用来表示特定文档类型需要的任何元数据。</p>
<h3 id="XML-基础"><a href="#XML-基础" class="headerlink" title="XML 基础"></a>XML 基础</h3><p>XML 文档中的数据包含在一个 XML 数中，XML 树主要由嵌套元素组成。<strong>元素</strong>是 XML 树的基本要素。每个元素都有名字且包含数据，一些元素还包含其他被嵌套元素。元素由开始和关闭标签进行划分。任何元素包含的数据都必须介于开始和关闭标签之间：<br>①开始标签：<code>&lt;PhoneNumber&gt;</code>；<br>②关闭标签：<code>&lt;/PhoneNumber&gt;</code>；<br>③没有内容的元素可以直接由单个标签表示：<code>&lt;PhoneNumber /&gt;</code></p>
<p>有关 XML 的重要事项：<br>① XML 文档必须有一个根元素来包含所有其他元素；<br>② XML 标签必须合理嵌套；<br>③与 HTML 标签不同，XML 标签是区分大小写的；<br>④ XML 特性是名字/值的配对，它包含了元素的额外元数据。特性的值部分必须包含在引号内，单引号双引号皆可；<br>⑤ XML 文档中的空格是有效的。这与把空格作为单个空格输出的 HTML 不同。</p>
<p>如下示例，包含了一个 Employees 类型的根节点，它包含了两个 Employee 类型的子节点：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Employees</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Employee</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Bob Smith<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PhoneNumber</span>&gt;</span>408-555-1000<span class="tag">&lt;/<span class="name">PhoneNumber</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CellPhone</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Employee</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Employee</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Sally Jones<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PhoneNumber</span>&gt;</span>415-555-2000<span class="tag">&lt;/<span class="name">PhoneNumber</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PhoneNumber</span>&gt;</span>415-555-2001<span class="tag">&lt;/<span class="name">PhoneNumber</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Employee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Employees</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div  align="center">  
<img src="https://s2.loli.net/2023/03/18/PHKWjBJ2Qukweh8.png" width = "65%" height = "65%" alt="图97 - 示例的 XML 树的层次结构"/>
</div>

<h3 id="XML-类"><a href="#XML-类" class="headerlink" title="XML 类"></a>XML 类</h3><p>LINQ to XML 可以用两种方式用于 XML 。第一种是简化的 XML API 操作(LINQ to XML API)，第二种为之前的 LINQ 查询工具。</p>
<p>LINQ to XML API 由很多表示 XML 树组件的类组成。我们会使用 3 个最重要的类包括 XElement、XAttribute 和 XDocument。</p>
<p>下图演示了用于构造 XML 树的类以及它们如何被嵌套：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/03/18/NTrSxoJGkaPtO4U.png" width = "75%" height = "75%" alt="图98 - XML 节点的容器结构"/>
</div>

<p>① XDocument 节点中 XDeclaration 节点、XDocumentType 节点以及 XElement 节点的每一个节点类型最多有一个，XProcessingInstruction 节点可以为任意数量；<br>②如果在 XDocument 下有最高级别的 XElement 节点，那么它就是 XML 树中其他元素的根；<br>③根元素可以包含任意数量的嵌套 XElement、XComment 或 XProcessingInstruction 节点，并且可以在任何级别上嵌套。</p>
<p>除了 XAttribute 类，大多数用于创建 XML 树的类都从一个叫做 XNode 的类继承，或叫做 XNodes 。上图中，白色背景的为 XNode 类，灰色背景的为 XAttribute 类。</p>
<p><strong><em>1. 创建、保存、加载和显示 XML 文档</em></strong><br>示例如下，创建了一个简单的包含一个 Employees 节点的 XML 树：<br>①树使用一条语句来创建，并同时在适当的位置创建所有的嵌套元素，叫做<strong>函数式构造 functional construction</strong> ；<br>②每一个元素由对象创建表达式在适当的位置创建，使用了节点类型的构造函数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq; <span class="comment">//需要的命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">        XDocument employees1 =</span><br><span class="line">            <span class="keyword">new</span> XDocument( <span class="comment">//创建 XML 文档</span></span><br><span class="line">                <span class="keyword">new</span> XElement(<span class="string">&quot;Employees&quot;</span>, <span class="comment">//创建根元素</span></span><br><span class="line">                    <span class="keyword">new</span> XElement(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Bob Smith&quot;</span>), <span class="comment">//创建元素</span></span><br><span class="line">                    <span class="keyword">new</span> XElement(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Sally Jones&quot;</span>) <span class="comment">//创建元素</span></span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        employees1.Save(<span class="string">&quot;EmployeesFile.xml&quot;</span>); <span class="comment">//保存到文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将保存的文档加载到新变量中</span></span><br><span class="line">        XDocument employees2 = XDocument.Load(<span class="string">&quot;EmployeesFile.xml&quot;</span>); <span class="comment">//静态方法</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(employees2); <span class="comment">//显示文档</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;Employees&gt;</span><br><span class="line">  &lt;Name&gt;Bob Smith&lt;/Name&gt;</span><br><span class="line">  &lt;Name&gt;Sally Jones&lt;/Name&gt;</span><br><span class="line">&lt;/Employees&gt;</span><br></pre></td></tr></table></figure>
<p><strong><em>2. 创建 XML 树</em></strong><br>对于 XDocument 和 XElement 的构造函数：<br>①第一个参数都是对象名；<br>②第二个参数以及之后的参数包含了 XML 树的节点。构造函数的第二个参数是一个 params 参数，即任意多的参数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq; <span class="comment">//此命名空间是必需的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">        XDocument employeeDoc =</span><br><span class="line">            <span class="keyword">new</span> XDocument( <span class="comment">//创建文档</span></span><br><span class="line">                <span class="keyword">new</span> XElement(<span class="string">&quot;Employees&quot;</span>, <span class="comment">//创建根元素</span></span><br><span class="line">                    <span class="keyword">new</span> XElement(<span class="string">&quot;Employee&quot;</span>, <span class="comment">//第一个employee元素</span></span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Bob Smith&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;PhoneNumber&quot;</span>, <span class="string">&quot;408-555-1000&quot;</span>) ),</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">new</span> XElement(<span class="string">&quot;Employee&quot;</span>, <span class="comment">//第二个employee元素</span></span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Sally Jones&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;PhoneNumber&quot;</span>, <span class="string">&quot;415-555-2000&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;PhoneNumber&quot;</span>, <span class="string">&quot;415-555-2001&quot;</span>) )</span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line">        Console.WriteLine(employeeDoc); <span class="comment">//显示文档</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;Employees&gt;</span><br><span class="line">  &lt;Employee&gt;</span><br><span class="line">    &lt;Name&gt;Bob Smith&lt;/Name&gt;</span><br><span class="line">    &lt;PhoneNumber&gt;408-555-1000&lt;/PhoneNumber&gt;</span><br><span class="line">  &lt;/Employee&gt;</span><br><span class="line">  &lt;Employee&gt;</span><br><span class="line">    &lt;Name&gt;Sally Jones&lt;/Name&gt;</span><br><span class="line">    &lt;PhoneNumber&gt;415-555-2000&lt;/PhoneNumber&gt;</span><br><span class="line">    &lt;PhoneNumber&gt;415-555-2001&lt;/PhoneNumber&gt;</span><br><span class="line">  &lt;/Employee&gt;</span><br><span class="line">&lt;/Employees&gt;</span><br></pre></td></tr></table></figure>
<p><strong><em>3. 使用 XML 树的值</em></strong><br>可以遍历 XML 树来获取或修改值，下表列出了用于获取数据的主要方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">方法名称</th>
<th style="text-align:left">类</th>
<th style="text-align:left">返回类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Nodes</td>
<td style="text-align:left">XDocument、XElement</td>
<td style="text-align:left">IEnumerable&lt;object&gt;</td>
<td style="text-align:left">返回当前节点的所有子节点</td>
</tr>
<tr>
<td style="text-align:left">Elements</td>
<td style="text-align:left">XDocument、XElement</td>
<td style="text-align:left">IEnumerable&lt;XElement&gt;</td>
<td style="text-align:left">返回当前节点的 XElement 子节点，或所有具有某个名字的子节点</td>
</tr>
<tr>
<td style="text-align:left">Element</td>
<td style="text-align:left">XDocument、XElement</td>
<td style="text-align:left">XElement</td>
<td style="text-align:left">返回当前节点的第一个 XElement 子节点，或具有某个名字的子节点</td>
</tr>
<tr>
<td style="text-align:left">Descendants</td>
<td style="text-align:left">XElement</td>
<td style="text-align:left">IEnumerable&lt;XElement&gt;</td>
<td style="text-align:left">返回所有的 XElement 子代节点，或所有具有某名字的 XElement 子代节点，不管它们处于当前节点下什么嵌套级别</td>
</tr>
<tr>
<td style="text-align:left">DescendantsAndSelf</td>
<td style="text-align:left">XElement</td>
<td style="text-align:left">IEnumerable&lt;XElement&gt;</td>
<td style="text-align:left">和 Descendents 一样，但是包括当前节点</td>
</tr>
<tr>
<td style="text-align:left">Ancestors</td>
<td style="text-align:left">XElement</td>
<td style="text-align:left">IEnumerable&lt;XElement&gt;</td>
<td style="text-align:left">返回所有上级 XElement 节点，或者所有具有某个名字的上级 XElement 节点</td>
</tr>
<tr>
<td style="text-align:left">AncestorsAndSelf</td>
<td style="text-align:left">XElement</td>
<td style="text-align:left">IEnumerable&lt;XElement&gt;</td>
<td style="text-align:left">和 Ancestors 一样，但是包含当前节点</td>
</tr>
<tr>
<td style="text-align:left">Parent</td>
<td style="text-align:left">XElement</td>
<td style="text-align:left">XElement</td>
<td style="text-align:left">返回当前节点的父节点</td>
</tr>
</tbody>
</table>
</div>
<p>① Nodes：Nodes 方法返回 IEnumerable&lt;object&gt; 类型的对象，因为返回的节点可能是不同的类型，比如 XElement、XComment 等。我们可以使用以类型作为参数的方法 OfType(type) 来指定返回某类型的节点。例如，如下代码只能获取 XComment 节点：<code>IEnumerable&lt;XComment&gt; comments = xd.Nodes().OfType&lt;XComment&gt;();</code><br>② Elements：由于获取 XElements 是非常普遍的需求，就出现了 Nodes.OfType(XElement)() 表达式的简短形式，即 Elements 方法：<br>&emsp;&emsp;- 无参数的 Elements 方法返回所有子 XElements；<br>&emsp;&emsp;- 单个 name 参数的 Elements 方法只返回具有这个名字的子 XElements 。例如，如下代码返回具有名字 PhoneNumber 的子 XElement 节点：<code>IEnumerable&lt;XElement&gt; empPhones = emp.Elements(&quot;PhoneNumber&quot;);</code><br>③ Element：这个方法只获取当前节点的第一个子 XElement 。如果无参数，获取第一个子 XElement 节点，如果带一个名字参数，获取第一个具有该名字的子 XElement；<br>④ Descendants 和 Ancestors：这些方法和 Elements 以及 Parent 方法差不多，只不过它们不返回直接的子元素和父元素，而是忽略嵌套级别，包括所有当前节点之下或者之上的节点。</p>
<p>如下代码演示了 Element 和 Elements 方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">        XDocument employeeDoc =</span><br><span class="line">            <span class="keyword">new</span> XDocument(</span><br><span class="line">                <span class="keyword">new</span> XElement(<span class="string">&quot;Employees&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> XElement(<span class="string">&quot;Employee&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Bob Smith&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;PhoneNumber&quot;</span>, <span class="string">&quot;408-555-1000&quot;</span>)),</span><br><span class="line">                    <span class="keyword">new</span> XElement(<span class="string">&quot;Employee&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Sally Jones&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;PhoneNumber&quot;</span>, <span class="string">&quot;415-555-2000&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;PhoneNumber&quot;</span>, <span class="string">&quot;415-555-2001&quot;</span>))</span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        XElement root = employeeDoc.Element(<span class="string">&quot;Employees&quot;</span>);</span><br><span class="line">        IEnumerable&lt;XElement&gt; employees = root.Elements();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (XElement emp <span class="keyword">in</span> employees)</span><br><span class="line">        &#123;</span><br><span class="line">            XElement empNameNode = emp.Element(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">            Console.WriteLine(empNameNode.Value);</span><br><span class="line"></span><br><span class="line">            IEnumerable&lt;XElement&gt; empPhones = emp.Elements(<span class="string">&quot;PhoneNumber&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (XElement phone <span class="keyword">in</span> empPhones)</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot; <span class="subst">&#123; phone.Value &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Bob Smith</span><br><span class="line"> 408-555-1000</span><br><span class="line">Sally Jones</span><br><span class="line"> 415-555-2000</span><br><span class="line"> 415-555-2001</span><br></pre></td></tr></table></figure>
<p><strong><em>4. 增加节点以及操作 XML</em></strong><br>可以使用 Add 方法在一次方法调用中增加任意多个元素，不管增加的节点类型是什么，示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        XDocument xd = <span class="keyword">new</span> XDocument( <span class="comment">//创建XML树</span></span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;root&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Original tree&quot;</span>);</span><br><span class="line">        Console.WriteLine(xd); Console.WriteLine(); <span class="comment">//显示树</span></span><br><span class="line"></span><br><span class="line">        XElement rt = xd.Element(<span class="string">&quot;root&quot;</span>); <span class="comment">//获取第一个元素</span></span><br><span class="line"></span><br><span class="line">        rt.Add( <span class="keyword">new</span> XElement(<span class="string">&quot;second&quot;</span>)); <span class="comment">//添加子元素</span></span><br><span class="line"></span><br><span class="line">        rt.Add( <span class="keyword">new</span> XElement(<span class="string">&quot;third&quot;</span>), <span class="comment">//再添加3个子元素</span></span><br><span class="line">                <span class="keyword">new</span> XComment(<span class="string">&quot;Important Comment&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> XElement(<span class="string">&quot;fourth&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Modified tree&quot;</span>);</span><br><span class="line">        Console.WriteLine(xd); <span class="comment">//显示modified树.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Original tree</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line">Modified tree</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">  &lt;second /&gt;</span><br><span class="line">  &lt;third /&gt;</span><br><span class="line">  &lt;!--Important Comment--&gt;</span><br><span class="line">  &lt;fourth /&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
<p>Add 方法把新的子节点放在既有子节点之后，也可以使用 AddFirst、AddBeforeSelf 和 AddAfterSelf 方法放在其他位置。下表列出了一些常见的操作 XML 的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">方法名称</th>
<th style="text-align:left">从哪里调用</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Add</td>
<td style="text-align:left">父节点</td>
<td style="text-align:left">在当前节点的既有子节点后增加新的子节点</td>
</tr>
<tr>
<td style="text-align:left">AddFirst</td>
<td style="text-align:left">父节点</td>
<td style="text-align:left">在当前节点的既有子节点前增加新的子节点</td>
</tr>
<tr>
<td style="text-align:left">AddBeforeSelf</td>
<td style="text-align:left">节点</td>
<td style="text-align:left">在同级别的当前节点之前增加新的节点</td>
</tr>
<tr>
<td style="text-align:left">AddAfterSelf</td>
<td style="text-align:left">节点</td>
<td style="text-align:left">在同级别的当前节点之后增加新的节点</td>
</tr>
<tr>
<td style="text-align:left">Remove</td>
<td style="text-align:left">节点</td>
<td style="text-align:left">删除当前所选的节点及其内容</td>
</tr>
<tr>
<td style="text-align:left">RemoveNodes</td>
<td style="text-align:left">节点</td>
<td style="text-align:left">删除当前所选的 XElement 及其内容</td>
</tr>
<tr>
<td style="text-align:left">SetElement</td>
<td style="text-align:left">父节点</td>
<td style="text-align:left">设置节点的内容</td>
</tr>
</tbody>
</table>
</div>
<h3 id="使用-XML-特性"><a href="#使用-XML-特性" class="headerlink" title="使用 XML 特性"></a>使用 XML 特性</h3><p><strong>特性 Attribute</strong> 提供了有关 XElement 节点的额外信息，它放在 XML 元素的开始标签中。当以函数方法构造 XML 树时，在 XElement 构造函数中包含 XAttribute 构造函数就可以增加特性。XAttribute 构造函数有两种形式：一种接受 name 和 value，另一种接受现有 XAttribute 的引用。</p>
<p>如下代码为 root 增加了两个特性：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">XDocument xd = <span class="keyword">new</span> XDocument(</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> XElement(<span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>), <span class="comment">//特性构造函数，参数为名称和值</span></span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;large&quot;</span>), <span class="comment">//特性构造函数，参数为名称和值</span></span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;second&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(xd);</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;root color=&quot;red&quot; size=&quot;large&quot;&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">  &lt;second /&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
<p>要从一个 XElement 节点获取特性可以使用 Attribute 方法，提供特性名称作为参数即可，示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XDocument xd = <span class="keyword">new</span> XDocument( <span class="comment">//创建XML树</span></span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;large&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(xd); Console.WriteLine(); <span class="comment">//显示XML树</span></span><br><span class="line"></span><br><span class="line">    XElement rt = xd.Element(<span class="string">&quot;root&quot;</span>); <span class="comment">//获取元素</span></span><br><span class="line"></span><br><span class="line">    XAttribute color = rt.Attribute(<span class="string">&quot;color&quot;</span>); <span class="comment">//获取特性</span></span><br><span class="line">    XAttribute size = rt.Attribute(<span class="string">&quot;size&quot;</span>); <span class="comment">//获取特性</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;color is <span class="subst">&#123; color.Value &#125;</span>&quot;</span>); <span class="comment">//显示特性值</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;size is <span class="subst">&#123; size.Value &#125;</span>&quot;</span>); <span class="comment">//显示特性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;root color=&quot;red&quot; size=&quot;large&quot;&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line">color is red</span><br><span class="line">size is large</span><br></pre></td></tr></table></figure>
<p>要移除特性，可以选择一个特性使用 Remove 方法，或者在父节点使用 SetAttributeValue 方法把特性值设置为 null，示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">    XDocument xd = <span class="keyword">new</span> XDocument(</span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;large&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    XElement rt = xd.Element(<span class="string">&quot;root&quot;</span>); <span class="comment">//获取元素</span></span><br><span class="line"></span><br><span class="line">    rt.Attribute(<span class="string">&quot;color&quot;</span>).Remove(); <span class="comment">//移除color特性</span></span><br><span class="line">    rt.SetAttributeValue(<span class="string">&quot;size&quot;</span>, <span class="literal">null</span>); <span class="comment">//移除size特性</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(xd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
<p>要向 XML 树增加一个特性或改变特性的值，也可以使用 SetAttributeValue 方法，示例如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">    XDocument xd = <span class="keyword">new</span> XDocument(</span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;large&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    XElement rt = xd.Element(<span class="string">&quot;root&quot;</span>); <span class="comment">//获取元素</span></span><br><span class="line"></span><br><span class="line">    rt.SetAttributeValue(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;medium&quot;</span>); <span class="comment">//改变特性值</span></span><br><span class="line">    rt.SetAttributeValue(<span class="string">&quot;width&quot;</span>, <span class="string">&quot;narrow&quot;</span>); <span class="comment">//添加特性</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(xd); Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;root color=&quot;red&quot; size=&quot;medium&quot; width=&quot;narrow&quot;&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
<h3 id="其他类型的节点"><a href="#其他类型的节点" class="headerlink" title="其他类型的节点"></a>其他类型的节点</h3><p><strong><em>1. XComment</em></strong><br>XML 注释由 &lt;!— 和 —&gt; 记号之间的文本组成。记号之间的文本会被 XML 解析器忽略。也可以使用 XComment 类向一个 XML 文档插入文本，比如：<code>new XComment(&quot;This is a comment&quot;)</code>，产生如下的 XML 文档行：<code>&lt;!--This is a comment--&gt;</code>。</p>
<p><strong><em>2. XDeclaration</em></strong><br>XML 文档从包含 XML 使用的版本号、字符编码类型以及文档是否依赖外部引用的一行开始。这是有关 XML 的信息，因此它其实是有关数据的元数据。这叫做 XML 声明，可以使用 XDeclaration 类来插入，示例如下：<code>new XDeclaration(&quot;1.0&quot;, &quot;utf-8&quot;, &quot;yes&quot;)</code>，产生如下的 XML 文档行：<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;</code>。</p>
<p><strong><em>3. XProcessingInstruction</em></strong><br>XML 处理指令用于提供关于 XML 文档的使用和解释方式的额外数据。处理指令最常用于关联 XML 文档和样式表。  </p>
<p>可以使用 XProecssingInstruction 构造函数来包含处理指令。它接受两个字符串参数：目标和数据串。如果处理指令接受多个数据参数，这些参数必须包含在 XProecssingInstruction 构造函数的第二个字符串参数中，如下的构造函数代码所示。注意，第二个参数是一个逐字字符串，在字符串中的双引号文本使用两个连续的双引号来表现：<code>new XProcessingInstruction( &quot;xml-stylesheet&quot;, @&quot;href=&quot;&quot;stories&quot;&quot;, type=&quot;&quot;text/css&quot;&quot;&quot;)</code>，产生如下的 XML 文档行：<code>&lt;?xml-stylesheet href=&quot;stories.css&quot; type=&quot;text/css&quot;?&gt;</code>。</p>
<p>结合上述3个构造函数的代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XDocument xd = <span class="keyword">new</span> XDocument(</span><br><span class="line">        <span class="keyword">new</span> XDeclaration(<span class="string">&quot;1.0&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="string">&quot;yes&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> XComment(<span class="string">&quot;This is a comment&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> XProcessingInstruction(<span class="string">&quot;xml-stylesheet&quot;</span>,</span><br><span class="line">                                    <span class="string">@&quot;href=&quot;&quot;stories.css&quot;&quot; type=&quot;&quot;text/css&quot;&quot;&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;second&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码产生如下的输入文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;yes&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--This is a comment--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet href=<span class="string">&quot;stories.css&quot;</span> type=<span class="string">&quot;text/css&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">first</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">second</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果使用 xd 的 WriteLine，即使声明语句包含在文档文件中也不会显示，输出如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;!--This is a comment--&gt;</span><br><span class="line">&lt;?xml-stylesheet href=&quot;stories.css&quot; type=&quot;text/css&quot;?&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">  &lt;second /&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用-LINQ-to-XML-的-LINQ-查询"><a href="#使用-LINQ-to-XML-的-LINQ-查询" class="headerlink" title="使用 LINQ to XML 的 LINQ 查询"></a>使用 LINQ to XML 的 LINQ 查询</h3><p>把 LINQ XML API 和 LINQ 查询表达式组合起来使用。</p>
<p>先创建一个简单的 XML 树：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XDocument xd = <span class="keyword">new</span> XDocument(</span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;MyElements&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;small&quot;</span>)),</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;second&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;medium&quot;</span>)),</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;third&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;large&quot;</span>))));</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(xd); <span class="comment">//显示XML树</span></span><br><span class="line">    xd.Save(<span class="string">&quot;SimpleSample.xml&quot;</span>); <span class="comment">//保存XML树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;MyElements&gt;</span><br><span class="line">  &lt;first color=&quot;red&quot; size=&quot;small&quot; /&gt;</span><br><span class="line">  &lt;second color=&quot;red&quot; size=&quot;medium&quot; /&gt;</span><br><span class="line">  &lt;third color=&quot;blue&quot; size=&quot;large&quot; /&gt;</span><br><span class="line">&lt;/MyElements&gt;</span><br></pre></td></tr></table></figure>
<p>以下代码使用了 LINQ 查询来从 XML 树中选择节点的子集，然后以各种方式显示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XDocument xd = XDocument.Load(<span class="string">&quot;SimpleSample.xml&quot;</span>); <span class="comment">//加载文档</span></span><br><span class="line">    XElement rt = xd.Element(<span class="string">&quot;MyElements&quot;</span>); <span class="comment">//获取根元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xyz = <span class="keyword">from</span> e <span class="keyword">in</span> rt.Elements() <span class="comment">//选择元素</span></span><br><span class="line">                <span class="keyword">where</span> e.Name.ToString().Length == <span class="number">5</span> <span class="comment">//5个字符长度的元素</span></span><br><span class="line">                <span class="keyword">select</span> e;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (XElement x <span class="keyword">in</span> xyz)</span><br><span class="line">        Console.WriteLine(x.Name.ToString());</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    <span class="keyword">foreach</span> (XElement x <span class="keyword">in</span> xyz)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Name: &#123;0&#125;, color: &#123;1&#125;, size: &#123;2&#125;&quot;</span>,</span><br><span class="line">                            x.Name,</span><br><span class="line">                            x.Attribute(<span class="string">&quot;color&quot;</span>).Value, <span class="comment">//获取特性的值</span></span><br><span class="line">                            x.Attribute(<span class="string">&quot;size&quot;</span>) .Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">first</span><br><span class="line">third</span><br><span class="line"></span><br><span class="line">Name: first, color: red, size: small</span><br><span class="line">Name: third, color: blue, size: large</span><br></pre></td></tr></table></figure>
<p>如下代码使用了一个简单的查询来获取 XML 树的所有顶层元素，并为每一个元素创建了一个匿名类型的对象：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XDocument xd = XDocument.Load(<span class="string">&quot;SimpleSample.xml&quot;</span>); <span class="comment">//加载文档</span></span><br><span class="line">    XElement rt = xd.Element(<span class="string">&quot;MyElements&quot;</span>); <span class="comment">//获取根元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xyz = <span class="keyword">from</span> e <span class="keyword">in</span> rt.Elements()</span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">new</span> &#123; e.Name, color = e.Attribute(<span class="string">&quot;color&quot;</span>) &#125;; <span class="comment">//创建匿名类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> xyz)</span><br><span class="line">        Console.WriteLine(x);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> xyz)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0,-6&#125;, color: &#123;1, -7&#125;&quot;</span>, x.Name, x.color.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&#123; Name = first, color = color=&quot;red&quot; &#125;</span><br><span class="line">&#123; Name = second, color = color=&quot;red&quot; &#125;</span><br><span class="line">&#123; Name = third, color = color=&quot;blue&quot; &#125;</span><br><span class="line"></span><br><span class="line">first , color: red</span><br><span class="line">second, color: red</span><br><span class="line">third , color: blue</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io">鸟布</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io/2023/02/03/2023-02-03-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B3/">https://ybniaobu.github.io/2023/02/03/2023-02-03-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ybniaobu.github.io" target="_blank">鸟布的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><a class="post-meta__tags" href="/tags/net/">.net</a><a class="post-meta__tags" href="/tags/C/">C#</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src="/images/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/24/2023-03-24-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B4/" title="《C#图解教程》读书笔记（四）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《C#图解教程》读书笔记（四）</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/06/2022-12-06-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B2/" title="《C#图解教程》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《C#图解教程》读书笔记（二）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/06/2022-12-06-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B2/" title="《C#图解教程》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-06</div><div class="title">《C#图解教程》读书笔记（二）</div></div></a></div><div><a href="/2022/11/24/2022-11-24-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B1/" title="《C#图解教程》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-24</div><div class="title">《C#图解教程》读书笔记（一）</div></div></a></div><div><a href="/2023/03/24/2023-03-24-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B4/" title="《C#图解教程》读书笔记（四）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-24</div><div class="title">《C#图解教程》读书笔记（四）</div></div></a></div><div><a href="/2023/07/07/2023-07-07-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B5/" title="《C#图解教程》读书笔记（五）"><img class="cover" src="https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">《C#图解教程》读书笔记（五）</div></div></a></div><div><a href="/2022/09/12/2022-09-12-Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/" title="《Python编程从入门到实践》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2022/11/27/h9RxCDEfGAM53j4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-12</div><div class="title">《Python编程从入门到实践》读书笔记（二）</div></div></a></div><div><a href="/2022/09/09/2022-09-09-Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="《Python编程从入门到实践》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2022/11/27/h9RxCDEfGAM53j4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-09</div><div class="title">《Python编程从入门到实践》读书笔记（一）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/wechat%20avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鸟布</div><div class="author-info__description">教练，我想学技术</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://niaobu.notion.site/787824630ea6480e944c1ae5ae7f4792"><i class="fa-solid fa-book"></i><span>My Notion</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ybniaobu/ybniaobu.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:niaobubob@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为了蒂法！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">第十六章 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">什么是接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-IComparable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">使用 IComparable 接口的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">声明接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.</span> <span class="toc-text">实现接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">简单接口的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">接口是引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C-as-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">接口和 as 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.</span> <span class="toc-text">实现多个接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B7%E6%9C%89%E9%87%8D%E5%A4%8D%E6%88%90%E5%91%98%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.</span> <span class="toc-text">实现具有重复成员的接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.8.</span> <span class="toc-text">多个接口的引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E6%88%90%E5%91%98%E4%BD%9C%E4%B8%BA%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.</span> <span class="toc-text">派生成员作为实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.10.</span> <span class="toc-text">显式接口成员实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%98%BE%E5%BC%8F%E6%8E%A5%E5%8F%A3%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.10.1.</span> <span class="toc-text">访问显式接口成员实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.11.</span> <span class="toc-text">接口可以继承接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.12.</span> <span class="toc-text">不同类实现一个接口的示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">第十七章 转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">什么是转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.</span> <span class="toc-text">隐式转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.</span> <span class="toc-text">显式转换和强制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.1.</span> <span class="toc-text">强制转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">转换的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.5.</span> <span class="toc-text">数字的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.5.1.</span> <span class="toc-text">隐式数字转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.5.2.</span> <span class="toc-text">溢出检测上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.5.3.</span> <span class="toc-text">显式数字转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.6.</span> <span class="toc-text">引用转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%BC%95%E7%94%A8%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.6.1.</span> <span class="toc-text">隐式引用转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%BC%95%E7%94%A8%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.6.2.</span> <span class="toc-text">显式引用转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E6%98%BE%E5%BC%8F%E5%BC%95%E7%94%A8%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.6.3.</span> <span class="toc-text">有效显式引用转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E5%8F%98%E6%8D%A2-Boxing-Conversions"><span class="toc-number">2.7.</span> <span class="toc-text">装箱变换 Boxing Conversions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E6%98%AF%E5%88%9B%E5%BB%BA%E5%89%AF%E6%9C%AC"><span class="toc-number">2.7.1.</span> <span class="toc-text">装箱是创建副本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.7.2.</span> <span class="toc-text">装箱转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%86%E7%AE%B1%E8%BD%AC%E6%8D%A2-Unboxing-Conversions"><span class="toc-number">2.8.</span> <span class="toc-text">拆箱转换 Unboxing Conversions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.9.</span> <span class="toc-text">用户自定义转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="toc-number">2.9.1.</span> <span class="toc-text">用户自定义转换的约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.9.2.</span> <span class="toc-text">用户自定义转换的示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%AD%A5%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.9.3.</span> <span class="toc-text">多步用户自定义转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%AD%A5%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.9.4.</span> <span class="toc-text">多步用户自定义转换的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#is-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.10.</span> <span class="toc-text">is 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#as-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.11.</span> <span class="toc-text">as 运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">第十八章 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">什么是泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">一个栈的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">C# 中的泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E7%BB%AD%E6%A0%88%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">继续栈的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">泛型类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">3.3.1.</span> <span class="toc-text">声明泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">创建构造类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text">创建变量和实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A0%88%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.4.</span> <span class="toc-text">使用泛型的栈的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.4.</span> <span class="toc-text">类型参数的约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#where-%E5%AD%90%E5%8F%A5"><span class="toc-number">3.4.1.</span> <span class="toc-text">where 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%AC%A1%E5%BA%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">约束类型和次序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.1.</span> <span class="toc-text">声明泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.2.</span> <span class="toc-text">调用泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.5.3.</span> <span class="toc-text">泛型方法的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">3.6.</span> <span class="toc-text">扩展方法和泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="toc-number">3.7.</span> <span class="toc-text">泛型结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98"><span class="toc-number">3.8.</span> <span class="toc-text">泛型委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.8.1.</span> <span class="toc-text">另一个泛型委托示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.9.</span> <span class="toc-text">泛型接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.9.1.</span> <span class="toc-text">使用泛型接口的示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%BF%85%E9%A1%BB%E5%94%AF%E4%B8%80"><span class="toc-number">3.9.2.</span> <span class="toc-text">泛型接口的实现必须唯一</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98-Covariance-and-Contravariance"><span class="toc-number">3.10.</span> <span class="toc-text">协变和逆变 Covariance and Contravariance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98-Covariance"><span class="toc-number">3.10.1.</span> <span class="toc-text">协变 Covariance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%8F%98-Contravariance"><span class="toc-number">3.10.2.</span> <span class="toc-text">逆变 Contravariance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98"><span class="toc-number">3.10.3.</span> <span class="toc-text">接口的协变和逆变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%8F%AF%E5%8F%98%E6%80%A7%E7%9A%84%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9"><span class="toc-number">3.10.4.</span> <span class="toc-text">关于可变性的其他内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">第十九章 枚举器和迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%99%A8%E5%92%8C%E5%8F%AF%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-Enumerators-and-Enumerable-Types"><span class="toc-number">4.1.</span> <span class="toc-text">枚举器和可枚举类型 Enumerators and Enumerable Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IEnumerator-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.</span> <span class="toc-text">IEnumerator 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IEnumerable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.</span> <span class="toc-text">IEnumerable 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-IEnumerable-%E5%92%8C-IEnumerator-%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">使用 IEnumerable 和 IEnumerator 的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%9E%9A%E4%B8%BE%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.4.</span> <span class="toc-text">泛型枚举接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterators"><span class="toc-number">4.5.</span> <span class="toc-text">迭代器 Iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9D%97"><span class="toc-number">4.5.1.</span> <span class="toc-text">迭代器块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%9D%A5%E5%88%9B%E5%BB%BA%E6%9E%9A%E4%B8%BE%E5%99%A8"><span class="toc-number">4.5.2.</span> <span class="toc-text">使用迭代器来创建枚举器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%8F%AF%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.3.</span> <span class="toc-text">使用迭代器来创建可枚举类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">常见迭代器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%A4%9A%E4%B8%AA%E5%8F%AF%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.7.</span> <span class="toc-text">产生多个可枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7"><span class="toc-number">4.8.</span> <span class="toc-text">将迭代器作为属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E8%B4%A8"><span class="toc-number">4.9.</span> <span class="toc-text">迭代器的实质</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-LINQ"><span class="toc-number">5.</span> <span class="toc-text">第二十章 LINQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-LINQ"><span class="toc-number">5.1.</span> <span class="toc-text">什么是 LINQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LINQ-%E6%8F%90%E4%BE%9B%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.2.</span> <span class="toc-text">LINQ 提供程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">匿名类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95%E5%92%8C%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">方法语法和查询语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8F%98%E9%87%8F"><span class="toc-number">5.4.</span> <span class="toc-text">查询变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">5.5.</span> <span class="toc-text">查询表达式的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#from-%E5%AD%90%E5%8F%A5"><span class="toc-number">5.5.1.</span> <span class="toc-text">from 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join-%E5%AD%90%E5%8F%A5"><span class="toc-number">5.5.2.</span> <span class="toc-text">join 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%94%E7%BB%93"><span class="toc-number">5.5.3.</span> <span class="toc-text">什么是联结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%BB%E4%BD%93%E4%B8%AD%E7%9A%84-from%E2%80%A6let%E2%80%A6where-%E7%89%87%E6%AE%B5"><span class="toc-number">5.5.4.</span> <span class="toc-text">查找主体中的 from…let…where 片段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orderby-%E5%AD%90%E5%8F%A5"><span class="toc-number">5.5.5.</span> <span class="toc-text">orderby 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select%E2%80%A6group-%E5%AD%90%E5%8F%A5"><span class="toc-number">5.5.6.</span> <span class="toc-text">select…group 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.5.7.</span> <span class="toc-text">查询中的匿名类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#group-%E5%AD%90%E5%8F%A5"><span class="toc-number">5.5.8.</span> <span class="toc-text">group 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%BB%B6%E7%BB%AD%EF%BC%9Ainto-%E5%AD%90%E5%8F%A5"><span class="toc-number">5.5.9.</span> <span class="toc-text">查询延续：into 子句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.6.</span> <span class="toc-text">标准查询运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%AD%BE%E5%90%8D"><span class="toc-number">5.6.1.</span> <span class="toc-text">标准查询运算符的签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%A0%87%E5%87%86%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.6.2.</span> <span class="toc-text">查询表达式和标准查询运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%A7%94%E6%89%98%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">5.6.3.</span> <span class="toc-text">将委托作为参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LINQ-%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%A7%94%E6%89%98%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.6.4.</span> <span class="toc-text">LINQ 预定义的委托类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A7%94%E6%89%98%E5%8F%82%E6%95%B0%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.6.5.</span> <span class="toc-text">使用委托参数的示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%82%E6%95%B0%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.6.6.</span> <span class="toc-text">使用 Lambda 表达式参数的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LINQ-to-XML"><span class="toc-number">5.7.</span> <span class="toc-text">LINQ to XML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80"><span class="toc-number">5.7.1.</span> <span class="toc-text">标记语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML-%E5%9F%BA%E7%A1%80"><span class="toc-number">5.7.2.</span> <span class="toc-text">XML 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML-%E7%B1%BB"><span class="toc-number">5.7.3.</span> <span class="toc-text">XML 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-XML-%E7%89%B9%E6%80%A7"><span class="toc-number">5.7.4.</span> <span class="toc-text">使用 XML 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">5.7.5.</span> <span class="toc-text">其他类型的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-LINQ-to-XML-%E7%9A%84-LINQ-%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.7.6.</span> <span class="toc-text">使用 LINQ to XML 的 LINQ 查询</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/13/2025-03-13-CustomSRP6/" title="Unity Custom SRP 基础（六）"><img src="https://s2.loli.net/2025/03/13/LozNxAmnlEJSOyV.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（六）"/></a><div class="content"><a class="title" href="/2025/03/13/2025-03-13-CustomSRP6/" title="Unity Custom SRP 基础（六）">Unity Custom SRP 基础（六）</a><time datetime="2025-03-13T12:44:31.000Z" title="发表于 2025-03-13 20:44:31">2025-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/26/2025-02-26-CustomSRP5/" title="Unity Custom SRP 基础（五）"><img src="https://s2.loli.net/2025/02/26/m2zJbPd8aeGD14A.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（五）"/></a><div class="content"><a class="title" href="/2025/02/26/2025-02-26-CustomSRP5/" title="Unity Custom SRP 基础（五）">Unity Custom SRP 基础（五）</a><time datetime="2025-02-26T03:30:46.000Z" title="发表于 2025-02-26 11:30:46">2025-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/02/2025-02-02-CustomSRP4/" title="Unity Custom SRP 基础（四）"><img src="https://s2.loli.net/2025/02/02/aLrYVUITs8tnuOw.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（四）"/></a><div class="content"><a class="title" href="/2025/02/02/2025-02-02-CustomSRP4/" title="Unity Custom SRP 基础（四）">Unity Custom SRP 基础（四）</a><time datetime="2025-02-02T06:35:41.000Z" title="发表于 2025-02-02 14:35:41">2025-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/07/2025-01-07-CustomSRP3/" title="Unity Custom SRP 基础（三）"><img src="https://s2.loli.net/2025/01/14/ELDF7wHpCPn2mKM.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（三）"/></a><div class="content"><a class="title" href="/2025/01/07/2025-01-07-CustomSRP3/" title="Unity Custom SRP 基础（三）">Unity Custom SRP 基础（三）</a><time datetime="2025-01-07T12:43:16.000Z" title="发表于 2025-01-07 20:43:16">2025-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/09/2024-12-09-CustomSRP2/" title="Unity Custom SRP 基础（二）"><img src="https://s2.loli.net/2024/12/09/paBhbkD6Vd9CIsy.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（二）"/></a><div class="content"><a class="title" href="/2024/12/09/2024-12-09-CustomSRP2/" title="Unity Custom SRP 基础（二）">Unity Custom SRP 基础（二）</a><time datetime="2024-12-09T08:00:29.000Z" title="发表于 2024-12-09 16:00:29">2024-12-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By 鸟布</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Your time is limited, so don't waste it living someone else's life.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>