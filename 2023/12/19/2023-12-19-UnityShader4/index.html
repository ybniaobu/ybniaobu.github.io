<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《Unity Shader入门精要》读书笔记（四） | 鸟布的博客</title><meta name="author" content="鸟布"><meta name="copyright" content="鸟布"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本读书笔记为高级篇的前 4 章，主要内容为屏幕后处理的边缘检测、高斯模糊、Bloom 效果和运动模糊；使用深度法线纹理的屏幕后处理的运动模糊、全局雾效和边缘检测；非真实感渲染的卡通渲染、素描风格；使用噪声的消融、水波、全局雾效效果。读书笔记是对知识的记录与总结，但是对比较熟悉的内容不会再行描述。"><link rel="shortcut icon" href="https://s2.loli.net/2022/09/08/Ygib4lfw6z1khnr.png"><link rel="canonical" href="https://ybniaobu.github.io/2023/12/19/2023-12-19-UnityShader4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 鸟布","link":"链接: ","source":"来源: 鸟布的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《Unity Shader入门精要》读书笔记（四）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-30 16:02:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/wechat%20avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/black.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鸟布的博客"><span class="site-name">鸟布的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《Unity Shader入门精要》读书笔记（四）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-19T11:35:53.000Z" title="发表于 2023-12-19 19:35:53">2023-12-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-30T08:02:24.000Z" title="更新于 2023-12-30 16:02:24">2023-12-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/unity/">unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/unity/unity-shader/">unity shader</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>101分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《Unity Shader入门精要》读书笔记（四）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本读书笔记为高级篇的前 4 章，主要内容为屏幕后处理的边缘检测、高斯模糊、Bloom 效果和运动模糊；使用深度法线纹理的屏幕后处理的运动模糊、全局雾效和边缘检测；非真实感渲染的卡通渲染、素描风格；使用噪声的消融、水波、全局雾效效果。<br>读书笔记是对知识的记录与总结，但是对比较熟悉的内容不会再行描述。</p>
</blockquote>
<h1 id="第十一章-屏幕后处理效果"><a href="#第十一章-屏幕后处理效果" class="headerlink" title="第十一章 屏幕后处理效果"></a>第十一章 屏幕后处理效果</h1><h2 id="建立一个基本的屏幕后处理脚本系统"><a href="#建立一个基本的屏幕后处理脚本系统" class="headerlink" title="建立一个基本的屏幕后处理脚本系统"></a>建立一个基本的屏幕后处理脚本系统</h2><p><strong>屏幕后处理效果 screen post-processing effects</strong> 通常指在渲染完整个场景得到屏幕图像后，再对图像进行一系列操作，实现各种屏幕特效。使用这种技术，可以为游戏画面添加更多的艺术效果，例如<strong>景深 Depth of Field</strong>、<strong>运动模糊 Motion Blur</strong> 等。</p>
<p>因此，想要实现屏幕后处理首先要得到渲染后的屏幕图像，即抓取屏幕，Unity 为我们提供了一个方便的接口 <code>OnRenderImage</code> 函数，声明如下：  </p>
<pre><code>MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)
</code></pre><p>Unity 会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，通过函数中的一系列操作后，再把目标渲染纹理，即第二个参数对应的渲染纹理显示到屏幕上。在 OnRenderImage 函数中，通常利用 <code>Graphics.Blit</code> 函数来完成对渲染纹理的处理。它有 3 中函数声明：  </p>
<pre><code>public static void Blit(Texture src, RenderTexture dest);
public static void Blit(Texture src, RenderTexture dest, Material mat, int pass = -1);
public static void Blit(Texture src, Material mat, int pass = -1);
</code></pre><p>参数 src 即源纹理，参数 dest 为目标纹理，若 dest 为 null 就会直接将结果显示在屏幕上。参数 mat 是我们使用的材质，在这个材质使用的 Unity Shader 里进行各种屏幕后处理操作，而 src 纹理将会被传递给 Shader 中名为 _MainTex 的纹理属性。参数 pass 的默认值为 -1，表示将会依次调用 Shader 内的所有 Pass。否则，只会调用给定索引的 Pass。</p>
<hr>
<p>在默认情况下，OnRenderImage 函数会在所有不透明和透明的 Pass 执行完毕后被调用，以便对场景中所有游戏对象都产生影响。但有时，会希望在不透明的 Pass（RenderQueue &lt;= 2500，内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内）执行完毕后立即调用 OnRenderImage 函数，从而不对透明物体产生任何影响。可在 OnRenderImage 函数前添加 <code>ImageEffectOpaque</code> 属性实现这样的目的（见第 12 章，利用深度和法线纹理进行边缘检测从而实现描边效果，但是不希望透明物体也被描边）。</p>
<hr>
<p>因此，要在 Unity 中实现屏幕后处理效果，过程通常如下：<br>①在摄像机中添加一个用于屏幕后处理的脚本，用于实现 OnRenderImage 函数；<br>②调用 Graphics.Blit 函数使用特定的 Unity Shader 对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。对于一些复杂的屏幕特效可多次调用 Graphics.Blit 函数对上一步的输出结果做进一步处理。  </p>
<p>但是，在进行屏幕后处理之前，需要检查一系列条件是否满足，例如当前平台是否支持渲染纹理和屏幕特效，是否支持当前使用的 Unity Shader 等。为此，我们创建了一个用于屏幕后处理效果的基类，在实现各种屏幕特效时，我们只需要继承自该基类，再实现派生类中不同的操作即可。代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent (typeof(Camera))</span>] <span class="comment">//屏幕效果需要绑定在某个摄像机中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了提前检查各种资源和条件是否满足，在 Start 函数调用 CheckResources 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResources</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isSupported == <span class="literal">false</span>) &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>) &#123;</span><br><span class="line">            Debug.LogWarning(<span class="string">&quot;This platform does not support image effects or render textures.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>()</span> &#123;</span><br><span class="line">        enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        CheckResources();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为每一个屏幕处理效果通常都需要制定一个 shader 来创建一个用于处理渲染纹理的材质，从而基类中也提供了该方法。该函数首先检查 Shader 的可用性，检查通过后就返回一个使用了该 shader 的材质</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!shader.isSupported) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">            material.hideFlags = HideFlags.DontSave;</span><br><span class="line">            <span class="keyword">if</span> (material)</span><br><span class="line">                <span class="keyword">return</span> material;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调整屏幕的亮度、饱和度和对比度"><a href="#调整屏幕的亮度、饱和度和对比度" class="headerlink" title="调整屏幕的亮度、饱和度和对比度"></a>调整屏幕的亮度、饱和度和对比度</h2><p>准备工作如下：<br>①新建名为 Scene_12_2 的场景，并去掉天空盒子；<br>②导入一张图片（案例图路径：Assets/Textures/Chapter12/Sakura0.jpg），调整图片纹理类型为 Sprite (2D and UI)，并拖拽到场景中，使其生成一个 Sprite；<br>③新建名为 BrightnessSaturationAndContrast 的脚本，并拖拽到相机上；<br>④新建名为 Chapter12-BrightnessSaturationAndContrast 的 Unity Shader；</p>
<p>BrightnessSaturationAndContrast 脚本代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrightnessSaturationAndContrast</span> : <span class="title">PostEffectsBase</span> &#123; <span class="comment">//继承 PostEffectsBase 基类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader briSatConShader; <span class="comment">//声明该效果需要的 shader</span></span><br><span class="line">    <span class="keyword">private</span> Material briSatConMaterial; <span class="comment">//并创建相应的材质</span></span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);</span><br><span class="line">            <span class="keyword">return</span> briSatConMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供调整亮度、饱和度和对比度的参数</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> brightness = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> saturation = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> contrast = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123; <span class="comment">//如果材质不为空，则把参数传递给材质，若不可用，则直接把源图像显示到屏幕上，不做任何处理</span></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Brightness&quot;</span>, brightness);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Saturation&quot;</span>, saturation);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Contrast&quot;</span>, contrast);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Chapter12-BrightnessSaturationAndContrast 的 Unity Shader 代码如下：  </p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 12/Brightness Saturation And Contrast&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">//Graphics.Blit 把第一个参数传递给名为 _MainTex 的属性，所以必需声明 _MainTex</span></span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; </span><br><span class="line">        <span class="comment">//下面三个属性的值由脚本传递而得，事实上，这些属性声明可以省略，Properties 中声明属性仅仅是为了显示在材质面板里，但对于屏幕特效来说，使用的材质是临时创建的，不需要在材质面板上调整参数</span></span><br><span class="line">        _Brightness (<span class="string">&quot;Brightness&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">        _Saturation(<span class="string">&quot;Saturation&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">        _Contrast(<span class="string">&quot;Contrast&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">//屏幕后处理实际上是在场景中绘制了一个与屏幕同宽同高的四边形面片，为了防止它对物体产生影响，需要设置相关的渲染状态。关闭深度写入为了防止挡住其他后面被渲染的物体。如果当前 OnRenderImage 函数在所有不透明的 Pass 执行完毕后立刻被调用，不关闭深度写入就会影响后面透明的 Pass 渲染，该设置可以看作是用于屏幕后处理的 shader 的标配</span></span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span>  </span></span><br><span class="line">             </span><br><span class="line">            sampler2D _MainTex;  </span><br><span class="line">            half _Brightness;</span><br><span class="line">            half _Saturation;</span><br><span class="line">            half _Contrast;</span><br><span class="line">              </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用 Unity 内置的 appdata_img 结构体作为顶点着色器的输入，其只包含图像处理时必须的顶点坐标和纹理坐标等变量。屏幕特效使用的顶点着色器通常比较简单，只需要进行必要的顶点变换，把正确的纹理坐标传递给片元着色器，以便对屏幕图像进行正确的采样</span></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed4 renderTex = tex2D(_MainTex, i.uv); <span class="comment">//原屏幕图像采样</span></span><br><span class="line">                </span><br><span class="line">                fixed3 finalColor = renderTex.rgb * _Brightness; <span class="comment">//利用 _Brightness 来调整亮度，亮度调整只需要把原颜色乘以亮度系数即可</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//luminance 亮度值：通过对每个颜色分量乘以一个特定的系数再相加即可得到。我们使用该亮度值创建一个饱和度为 0 的颜色值，并使用 _Saturation 和上一步得到的颜色值进行插值从而得到希望的饱和度颜色</span></span><br><span class="line">                fixed luminance = <span class="number">0.2125</span> * renderTex.r + <span class="number">0.7154</span> * renderTex.g + <span class="number">0.0721</span> * renderTex.b;</span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance, luminance, luminance);</span><br><span class="line">                finalColor = lerp(luminanceColor, finalColor, _Saturation);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//对比度：首先创建对比度为 0 的颜色值（各分量均为 0.5），使用 _Contrast 和上一步得到的颜色值进行插值从而得到最终的处理结果</span></span><br><span class="line">                fixed3 avgColor = fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">                finalColor = lerp(avgColor, finalColor, _Contrast);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, renderTex.a);  </span><br><span class="line">            &#125; </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：<br>①亮度：很简单，用 _Brightness 对 RGB 进行统一缩放，但各自混合比例不变，保证了颜色不变，但亮度变大。<br>②饱和度：饱和度指色彩的纯净程度，在同一色相中添加白色、黑色或灰色会降低纯度。因为有 Cg 的 Lerp 函数的存在，只要得到饱和度为 0 时的 RGB 值，当 _Saturation &gt; 1 时，就可以增大颜色饱和度。由上面的饱和度概念可推，往一种颜色添加大量黑白灰色，即该颜色的灰度图就是该颜色的饱和度为 0 时的 RGB 值。因此当一个画面饱和度为 0 时，得到的是该画面对应的灰度图。<br>③上述代码的 luminance 值的计算公式就是求 RGB 颜色值对应的灰度值，这个公式是 RGB 转 YUV 的 BT709 明亮度转换公式，YUV 颜色模型起源于解决彩色电视和黑白电视的兼容性问题，其中 Y 值即 Luminance 就是灰阶值。至于三个系数不统一，是因为人眼对 RGB 三原色的敏感程度不同，有兴趣了解色度学（将主观颜色感知和客观物理测量联系的科学）。<br>④对比度：对比度指一个画面显示的 RGB 值最大的像素和最小的像素之间的差值的大小，即最亮与最暗的像素之间的差值为对比度。使用（0.5, 0.5, 0.5）对原 RGB 值进行插值。所以 _Contrast 值越小，画面中像素的 RGB 的值都会越来越接近 0.5，对比度就会越小；值越大，特别是 &gt; 1 时，画面中像素的 RGB 的值都会越来越远离 0.5，对比度就会越大。</p>
</blockquote>
<p>将编写好的 Shader 文件拖拽到摄像机 C# 脚本组件的 Bri Sat Con Shader 属性中，调整参数，效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/20/mytDJOCMLgZro56.png" width = "70%" height = "70%" alt="图62-  左图：原效果。右图：调整了亮度（值为 1.2）、饱和度（值为 1.5）和对比度（值为 1.1）后的效果"/>
</div>

<h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><p>边缘检测是描边效果的一种实现方法，其原理是利用一些边缘检测算子对图像进行<strong>卷积 convolution</strong> 操作。</p>
<h3 id="什么是卷积"><a href="#什么是卷积" class="headerlink" title="什么是卷积"></a>什么是卷积</h3><p>在图像处理中，卷积操作指的是使用一个<strong>卷积核 kernel</strong> 对一张图像中的每个像素进行一系列操作。卷积核通常是一个四方形网格结构（例如：2x2、3x3的方形区域），该区域内每个方格都有一个权重值。当对图形中的某个像素进行卷积时，我们会把卷积核的中心放置到该像素上，如下图所示，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是该位置的新像素值。</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/20/3t2MPVUadi5zWno.png" width = "70%" height = "70%" alt="图63-  卷积核与卷积。使用一个3×3大小的卷积核对一张5×5大小的图像进行卷积操作，当计算图中红色方块对应的像素的卷积结果时，我们首先把卷积核的中心放置在该像素位置，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到新的像素值"/>
</div>

<p>卷积操作可用于图像模糊、边缘检测、锐化等效果，例如：均值模糊，可以使用 3x3 的卷积核，核内每个元素的值均为 1/9。</p>
<h3 id="常见的边缘检测算子"><a href="#常见的边缘检测算子" class="headerlink" title="常见的边缘检测算子"></a>常见的边缘检测算子</h3><p>卷积操作的神奇之处在于选择的卷积核。用于边缘检测的卷积核，也被称为<strong>边缘检测算子</strong>。</p>
<p>如果相邻像素之间存在差别明显的颜色、亮度、纹理等属性，可以认为他们之间有一条边界，这种相邻像素之间的差异用<strong>梯度 gradient</strong> 来表示，边缘处的梯度绝对值会比较大。基于这样的理解，有几种不同的边缘检测算子被先后提出：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/20/ZrSGUK6ya3WeFJ4.png" width = "70%" height = "70%" alt="图64-  三种常见的边缘检测算子"/>
</div>

<p>上图的三种常见的边缘检测算子都包含了 2 个方向的卷积核，分别用于检测水平方向和竖直方向上的边缘信息。边缘检测时，需要对每个像素分别进行一次卷积计算，得到 2 个方向上的梯度值 $\,G_x\,$ 和 $\,G_y\,$，而整体的梯度可按如下公式计算得到：  </p>
<script type="math/tex; mode=display">G = \sqrt {G_x^2 + G_y^2}</script><p>考虑到性能，有时会用绝对值操作代替开根号操作：  </p>
<script type="math/tex; mode=display">G = \lvert G_x \rvert + \lvert G_y \rvert</script><p>得到梯度 G 后，可据此判断哪些像素对应了边缘（梯度值越大，越有可能是边缘点）。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>准备工作如下：<br>①新建名为 Scene_12_3 的场景，并去掉天空盒子；<br>②导入一张图片（案例图路径：Assets/Textures/Chapter12/Sakura0.jpg），调整图片纹理类型为Sprite (2D and UI)，并拖拽到场景中，使其生成一个 Sprite；<br>③新建名为 EdgeDetection 的 C#脚本，并拖拽到相机上；<br>④新建名为 Chapter12-EdgeDetection 的 Unity Shader。</p>
<p>首先是 C# 脚本文件，代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetection</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shader edgeDetectShader;</span><br><span class="line">    <span class="keyword">private</span> Material edgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            <span class="keyword">return</span> edgeDetectMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供调整边缘性强度、描边颜色以及背景颜色的参数</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>; <span class="comment">//当其为 0 时，边缘将会叠加在原渲染图像上；当为 1 时，则只会显示边缘，不显示原渲染图像</span></span><br><span class="line">    <span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, edgesOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>, edgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Chapter12-EdgeDetection 的 Shader 代码如下：  </p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 12/Edge Detection&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _EdgeOnly (<span class="string">&quot;Edge Only&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (<span class="string">&quot;Edge Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (<span class="string">&quot;Background Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;  </span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragSobel</span></span><br><span class="line">            </span><br><span class="line">            sampler2D _MainTex;  </span><br><span class="line">            uniform half4 _MainTex_TexelSize; <span class="comment">//xxx_TexelSize 是 Unity 为开发者提供的访问 xxx 纹理对应的每个纹素的大小（一张 512 × 512 大小的纹理，该值为 1/512）；因为卷积需要对相邻区域内的纹理进行采样，因此需要利用 _Main_TexelSize 来计算各个相邻区域的纹理坐标。</span></span><br><span class="line">            fixed _EdgeOnly;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv[<span class="number">9</span>] : TEXCOORD0; <span class="comment">//维数为 9 的纹理数组，对应算子需求的 9 个纹理坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在顶点着色器中计算采样纹理坐标减少性能消耗。由于从顶点着色器到片元着色器的插值是线性的，因此不会影响纹理坐标的计算结果</span></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                half2 uv = v.texcoord;</span><br><span class="line">                o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed <span class="title function_">luminance</span><span class="params">(fixed4 color)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            half <span class="title function_">Sobel</span><span class="params">(v2f i)</span> &#123;</span><br><span class="line">                <span class="type">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>, <span class="comment">//定义了水平方向的卷积核 Gx</span></span><br><span class="line">                                    <span class="number">-2</span>,  <span class="number">0</span>,  <span class="number">2</span>,</span><br><span class="line">                                    <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="type">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="comment">//定义了竖直方向的卷积核 Gy</span></span><br><span class="line">                                    <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">                                    <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span>&#125;;        </span><br><span class="line">                </span><br><span class="line">                half texColor;</span><br><span class="line">                half edgeX = <span class="number">0</span>;</span><br><span class="line">                half edgeY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">0</span>; it &lt; <span class="number">9</span>; it++) &#123;</span><br><span class="line">                    texColor = luminance(tex2D(_MainTex, i.uv[it])); <span class="comment">//依次对 9 个像素进行采样，计算他们的亮度值</span></span><br><span class="line">                    edgeX += texColor * Gx[it]; <span class="comment">//再与 Gx 和 Gy 对应的权重进行相乘，得到各自的梯度值</span></span><br><span class="line">                    edgeY += texColor * Gy[it];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                half edge = <span class="number">1</span> - <span class="built_in">abs</span>(edgeX) - <span class="built_in">abs</span>(edgeY); <span class="comment">//从 1 中减去水平方向和竖直方向的梯度值的绝对值，得到 edge，edge 值越小则表明该位置越可能是一个边缘点</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">fragSobel</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                half edge = Sobel(i); <span class="comment">//调用 Soble 函数计算当前像素的梯度值 edge</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//利用 edge 分别计算了背景为原图和纯色下的颜色值</span></span><br><span class="line">                fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>]), edge);</span><br><span class="line">                fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">                <span class="comment">//利用 _EdgeOnly 在两者之间插值得到最终的像素值</span></span><br><span class="line">                <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">             &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将编写好的 Shader 文件拖拽到 C# 组件的 Edge Detect Shader 属性中，效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/20/F1qZG5ioYhjOKmk.png" width = "100%" height = "100%" alt="图65-  左图：原效果。中图：Edges Only 为 0。右图：Edges Only 为 1。"/>
</div>

<p>需要注意的是，本节实现的边缘检测仅仅利用了屏幕颜色信息，而在实际的应用中，物体的纹理、阴影等信息都会影响到边缘检测的结果。为了得到更加准确的边缘信息，往往会在屏幕的深度纹理和法线纹理上进行边缘检测，在 第 12 章实现这种方法。</p>
<h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>常见的使用卷积的模糊有均值模糊和中值模糊。均值模糊使用的卷积核各个元素都相等，且相加等于1，即卷积后得到的像素值是其邻域内各个像素值的平均值。中值模糊，则是选择邻域内所有像素排序后的中值替换掉原颜色。而<strong>高斯模糊</strong>是一个更高级的模糊方式。</p>
<h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>高斯模糊同样利用了卷积计算，它使用的卷积核名为<strong>高斯核</strong>。高斯核是一个正方形大小的滤波核，其中每个元素都是基于下面的高斯方程：  </p>
<script type="math/tex; mode=display">G(x,y) = \cfrac {1}{2 \pi \sigma ^ 2} e ^ {- \cfrac {x^2 + y^2} {2 \sigma ^2} }</script><p>其中，$\,\sigma\,$ 是标准方差，一般取值为 1；$\,x\,$  和 $\,y\,$ 分别对应了当前位置到卷积核中心的整数距离。要构建高斯核，只需要计算高斯核中各个位置对应的高斯值。为了保证滤波后的图像不会变暗，需要对高斯核中的权重进行归一化，即让每一个权重除以所有权重的和，以保证所有权重的和为 1，因此高斯函数中的 $\,e\,$  前面的系数实际不会对结果有任何影响。</p>
<p>高斯方程很好地模拟了邻域每个像素对当前处理像素的影响程度 —— 距离越近，影响越大。高斯核的维数越高，模糊程度越大。使用 N x N 的高斯核对图像进行卷积滤波，需要进行 N x N x W x H（W 和 H分别是图像的宽和高）次纹理采样。N 不断增大，采样次数会变得非常巨大。</p>
<p>为了节省性能，可以把二维高斯函数可以拆分成两个一维函数。使用两个一维的高斯核先后对图像进行滤波，得到的结果和直接使用二位高斯核是一样的，但采样次数只需要 2 x N x W x H。对于一个大小为 5 的一维高斯核，只需要记录 3 个权重值即可，因为左右权重有重复的值。如下图：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/21/XCzRgKkvqG6Q7a5.png" width = "70%" height = "70%" alt="图66-  一个 5×5 大小的高斯核。左图显示了标准方差为 1 的高斯核的权重分布。我们可以把这个二维高斯核拆分成两个一维的高斯核（右图）。"/>
</div>

<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>接下来使用上述的 5 x 5 的高斯核对原图像进行高斯模糊。先后调用两个 Pass，第一个 Pass 将会使用竖直方向的一维高斯核对图像进行滤波，第二个 Pass 再使用水平方向的一维高斯核对图像进行滤波，得到最终的目标图像。在现实中还会利用图像缩放来进一步提高性能，通过调整高斯滤波的应用次数来控制模糊程度（次数越多，图像越模糊）。</p>
<p>准备工作如下：<br>①新建名为 Scene_12_4 的场景，并去掉天空盒子；<br>②导入一张图片（资源路径：Assets/Textures/Chapter12/Sakura1.jpg），调整图片纹理类型为 Sprite (2D and UI)，并拖拽到场景中，使其生成一个 Sprite；<br>③新建名为 GaussianBlur 的 C# 脚本，将脚本拖拽到相机；<br>④新建名为 Chapter12-GaussianBlur 的 Unity Shader。</p>
<p>GaussianBlur 的 C# 脚本的代码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GaussianBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader gaussianBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material gaussianBlurMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> gaussianBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>; <span class="comment">//高斯模糊迭代次数</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>; <span class="comment">//模糊范围，计算得到 shader 中的 _BlurSize。_BlurSize 越大，模糊程度越大，但采样数不会受到影响，过大的 _BlueSize 值会造成虚影</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Range(1, 8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>; <span class="comment">//缩放图像降采样的系数，downSample 越大，需要处理的像素数越少，同时也可以进一步提高模糊程度，但过大的 downSample 会造成图像像素化</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 第一个版本：简单的 OnRenderImage 实现，不使用上面 3 个字段。首先利用 RenderTexture.GetTemporary 函数分配一块与屏幕图像大小相同的缓冲区。因为模糊需要调用两个Pass，从而需要使用一块中间缓存来存储第一个 Pass 执行完毕后得到的模糊结果。</span></span><br><span class="line"><span class="comment">//    void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//        if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//            int rtW = src.width;</span></span><br><span class="line"><span class="comment">//            int rtH = src.height;</span></span><br><span class="line"><span class="comment">//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);        </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, buffer, material, 0); //参数为 0，即使用 Shader 中的第一个 Pass（即使用竖直方向的一维高斯核进行滤波）对 src 进行处理，并将结果存储在 buffer中</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(buffer, dest, material, 1); //然后利用第二个 pass 对 buffer 进行处理，返回最终的屏幕图像</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            RenderTexture.ReleaseTemporary(buffer); //调用这个释放之前分配的缓存</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个版本：利用缩放系数对图像进行降采样，从而减少需要处理的像素个数，提高性能</span></span><br><span class="line"><span class="comment">//    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//        if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//            int rtW = src.width/downSample;</span></span><br><span class="line"><span class="comment">//            int rtH = src.height/downSample;</span></span><br><span class="line"><span class="comment">//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span></span><br><span class="line"><span class="comment">//            buffer.filterMode = FilterMode.Bilinear; //声明缓冲区的大小时，使用了小于原屏幕分辨率的尺寸，并将该临时渲染纹理的滤波模式设置为双线性，从而不仅减少需要处理的像素个数，同时更提高了性能，适当的降采样还可以得到更好的模糊效果，但过大的 downSample 会造成图像像素化</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, buffer, material, 0);</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(buffer, dest, material, 1);</span></span><br><span class="line"><span class="comment">//            RenderTexture.ReleaseTemporary(buffer);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 第三个版本相比第二个版本增加了迭代次数和模糊范围，下面代码显示了如何利用两个临时缓存在迭代之间进行交替的过程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//首先定义第一个缓存 buffer0，并直接把 scr 的图像缩放后存储到 buffer0 中</span></span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">            Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在迭代过程中，定义第二个缓存 buffer1。在执行第一个 Pass 时，输入的是 buffer0，输出的是 buffer1，完毕之后，释放 buffer0，将 buffer1 存储到 buffer0 中，重新分配 buffer1，再调用第二个 Pass，不断重复</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line">            </span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>); <span class="comment">//第一个 Pass</span></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>); <span class="comment">//第二个 Pass</span></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(buffer0, dest);        <span class="comment">//把结果显示在屏幕上</span></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Chapter12-GaussianBlur 的 Unity Shader 代码如下：  </p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 12/Gaussian Blur&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _BlurSize (<span class="string">&quot;Blur Size&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">//第一次使用 CGINCLUDE，该代码不需要包含任何 Pass 语义块，在使用时只需要在 Pass 中直接指定需要使用的顶点着色器和片元着色器函数名即可，类似于 C++ 中的头文件，这样可以避免编写相同的片元着色器</span></span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex;  </span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line">          </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>]: TEXCOORD0; <span class="comment">//因为可以拆分成 2 个大小为 5 的一维高斯核，从而只需要计算 5 个纹理坐标即可</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//竖直方向的顶点着色器代码</span></span><br><span class="line">        v2f <span class="title function_">vertBlurVertical</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//利用与属性 _BlurSize 相乘来控制采样距离。在高斯核维数不变的情况下，_BlurSize 越大，模糊程度越高，但采样数不受到影响</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//水平方向的顶点着色器代码</span></span><br><span class="line">        v2f <span class="title function_">vertBlurHorizontal</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;   </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个 Pass 共用的片元着色器</span></span><br><span class="line">        fixed4 <span class="title function_">fragBlur</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;; <span class="comment">//高斯核的三个不重复的权重</span></span><br><span class="line">            </span><br><span class="line">            fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>]; <span class="comment">//权重和 sum 初始化为当前的像素值乘以它的权重值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据对称性，进行两次迭代，每次迭代包含了两次纹理采样</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++) &#123;</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>); <span class="comment">//返回滤波结果sum</span></span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义第一个竖直的 Pass</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">//使用 NAME 语义定义了它们的名字，为 Pass 定义名字可以在其他 shader 中直接通过它们的名字来使用该 Pass，而不需要重新写代码</span></span><br><span class="line">            NAME <span class="string">&quot;GAUSSIAN_BLUR_VERTICAL&quot;</span></span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">              </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vertBlurVertical <span class="comment">//告诉 Unity，顶点着色器的代码在 vertBlurVertical 函数中</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragBlur <span class="comment">//告诉 Unity，片元着色器的代码在 fragBlur 函数中</span></span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            NAME <span class="string">&quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span></span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vertBlurHorizontal  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将编写好的 Shader 文件拖拽到 C# 脚本组件的 Gaussian Blur Shader 属性中，效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/21/6IuoeZQXA2YzkGt.png" width = "70%" height = "70%" alt="图67-  左图：原效果。右图：高斯模糊后的效果（Iterations 为 3，Blur Spread 为 0.6，Down Sample 为 2）。"/>
</div>

<h2 id="Bloom-效果"><a href="#Bloom-效果" class="headerlink" title="Bloom 效果"></a>Bloom 效果</h2><p>Bloom 特效是游戏中常见的一种屏幕效果，可以模拟真实相机的一种图像效果，它让画面中较亮的区域“扩散”到周围的区域中，产生一种朦胧的效果。</p>
<p>Bloom 的实现原理非常简单：<br>①根据一个阈值提取出图像中的较亮区域，把它们存储在一张渲染纹理中；<br>②再利用高斯模糊对这张纹理进行模糊处理，模拟光线扩散的效果；<br>③最后与原图像进行混合，得到最终效果。</p>
<p>准备工作如下：<br>①新建名为 Scene_12_5 的场景，并去掉天空盒子；<br>②导入一张图片（资源图路径：Assets/Textures/Chapter12/Sakura1.jpg），调整图片纹理类型为 Sprite (2D and UI)，并拖拽到场景中，使其生成一个 Sprite；<br>③新建名为 Bloom 的 C# 脚本；<br>④新建名为 Chapter12-Bloom 的 Unity Shader。</p>
<p>Bloom.cs 的脚本代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bloom</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader bloomShader;</span><br><span class="line">    <span class="keyword">private</span> Material bloomMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);</span><br><span class="line">            <span class="keyword">return</span> bloomMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(1, 8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加 luminanceThreshold 来控制提取较亮的区域时使用的阈值大小。尽管在绝大多数的情况下，图像的亮度值不会超过 1，但如果开启了 HDR，硬件会允许把颜色值存储在一个更高精度范围的缓冲中，此时像素的亮度值可能会超过 1，这里把 luminanceThreshold 的值规定在 [0,4] 中</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 4.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> luminanceThreshold = <span class="number">0.6f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Bloom 建立在高斯模糊之上实现，从而与高斯模糊的代码有大量重复的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold); </span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//先使用 Shader 中的第一个 Pass 提取图像中的较亮区域，存储到 buffer0 中</span></span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">            Graphics.Blit(src, buffer0, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//和之前相同的高斯模糊迭代处理，只不过 Pass 对应的是 Shader 的第二个和第三个 Pass</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line">                </span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0); </span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>); </span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">2</span>);</span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将 buffer0 传递给材质中的 _Bloom 纹理属性，使用第四个 pass 进行最后的混合，并存储到目标渲染纹理 dest 中</span></span><br><span class="line">            material.SetTexture (<span class="string">&quot;_Bloom&quot;</span>, buffer0);</span><br><span class="line">            Graphics.Blit (src, dest, material, <span class="number">3</span>);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Chapter12-Bloom 的 Shader 代码如下：  </p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 12/Bloom&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Bloom (<span class="string">&quot;Bloom (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//高斯模糊后较亮的区域的输出纹理</span></span><br><span class="line">        _LuminanceThreshold (<span class="string">&quot;Luminance Threshold&quot;</span>, Float) = <span class="number">0.5</span> <span class="comment">//提取较亮区域的阈值</span></span><br><span class="line">        _BlurSize (<span class="string">&quot;Blur Size&quot;</span>, Float) = <span class="number">1.0</span> <span class="comment">//控制不同迭代之间高斯模糊的模糊区域范围</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;        </span><br><span class="line">        sampler2D _Bloom;</span><br><span class="line">        <span class="type">float</span> _LuminanceThreshold;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面先定义提取较亮区域需要使用的结构体、顶点着色器和片元着色器</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION; </span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;    </span><br><span class="line"></span><br><span class="line">        v2f <span class="title function_">vertExtractBright</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed <span class="title function_">luminance</span><span class="params">(fixed4 color)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 <span class="title function_">fragExtractBright</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">            fixed val = clamp(luminance(c) - _LuminanceThreshold, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">//采样得到的亮度值减去阈值 _LuminanceThreshold，并把结果截取在 0～1 之间</span></span><br><span class="line">            <span class="keyword">return</span> c * val; <span class="comment">//把该值和愿像素相乘，得到提取后的亮度区域</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义混合亮部图像和原图像时使用的结构体、顶点着色器和片元着色器</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2fBloom</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION; </span><br><span class="line">            half4 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        v2fBloom <span class="title function_">vertBloom</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2fBloom o;</span><br><span class="line">            o.pos = UnityObjectToClipPos (v.vertex);</span><br><span class="line">            <span class="comment">//定义两个纹理坐标，并存储在同一个类型为 half4 的变量 uv 中，xy 对应 _MainTex，即原图像的纹理坐标；zw 对应 _Bloom，即对应模糊后的较亮区域的纹理坐标</span></span><br><span class="line">            o.uv.xy = v.texcoord;</span><br><span class="line">            o.uv.zw = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//平台差异化处理的代码</span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP            </span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0.0</span>)</span><br><span class="line">                o.uv.w = <span class="number">1.0</span> - o.uv.w;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                            </span><br><span class="line">            <span class="keyword">return</span> o; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 <span class="title function_">fragBloom</span><span class="params">(v2fBloom i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义 Bloom 效果需要的 4 个 pass</span></span><br><span class="line">        Pass &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vertExtractBright  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragExtractBright  </span></span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二、第三个 pass 使用上一节的高斯模糊定义的两个 pass，该是通过 UsePass 语义来指明所使用的 pass，注意：Unity 内部会把 shader 名字全部转换为大写字母，从而使用时需要大写字母</span></span><br><span class="line">        </span><br><span class="line">        UsePass <span class="string">&quot;Unity Shaders Book/Chapter 12/Gaussian Blur/GAUSSIAN_BLUR_VERTICAL&quot;</span></span><br><span class="line">        </span><br><span class="line">        UsePass <span class="string">&quot;Unity Shaders Book/Chapter 12/Gaussian Blur/GAUSSIAN_BLUR_HORIZONTAL&quot;</span></span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vertBloom  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragBloom  </span></span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将编写好的 Shader 文件拖拽到 C# 脚本组件的 Bloom Shader 属性中，效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/21/GnsWkg5EzRAZoX4.png" width = "70%" height = "70%" alt="图68-  左图：原效果。右图：Bloom 处理后的效果（Iterations 为 4，Blur Spread 为 1.5，Down Sample 为 4，Luminance Threshold 为 0.1）。"/>
</div>


<h2 id="运动模糊"><a href="#运动模糊" class="headerlink" title="运动模糊"></a>运动模糊</h2><p>运动模糊是真实世界中的摄像机的一种效果。摄像机曝光时如果拍摄场景发生了变化，就会产生模糊的画面。由于在计算机生成的图像中，不存在在曝光这一物理现象，渲染出来的图像往往都是棱角分明，缺少运动模糊。  </p>
<p>运动模糊的实现有多种方法：<br>①<strong>累积缓存 accumulation buffer</strong>：混合多张连续图像。当物体快速移动产生多张图像后，我们取它们之间的平均值作为最后的运动模糊图像。这种暴力的方法对性能消耗很大，想要获取多张帧图像意味着我们需要在同一帧里渲染多次场景。<br>②<strong>速度缓存 velocity buffer</strong>：这个缓存中存储了各个像素当前的运动速度，然后利用该值来觉得模糊的方向和大小。</p>
<p>本节中，我们将使用类似于累积缓存的方法来实现运动模糊。我们不需要在一帧中把场景渲染多次，但需要保存之前的渲染结果，不断把当前的渲染图像叠加到之前的渲染图像中，从而产生一种运动轨迹的视觉效果。这种方法与原始的利用累计缓存的方法相比性能更好，但模糊效果可能略有影响。</p>
<p>准备工作如下：<br>①新建名为 Scene_12_6 的场景，并去掉天空盒子；<br>②往场景里放置几个立方体和平面；<br>③新建名为 Translating 的 C# 脚本，并拖拽到相机，用于控制相机围绕目标物体旋转；<br>④新建名为 MotionBlur 的 C# 脚本，并把脚本拖拽到相机；<br>⑤新建名为 Chapter12-MotionBlur 的 Unity Shader。</p>
<p>Translating.cs 的代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Translating</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">10.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Vector3 startPoint = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector3 endPoint = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector3 lookAt = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> pingpong = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 curEndPoint = Vector3.zero;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.position = startPoint;</span><br><span class="line">        curEndPoint = endPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.position = Vector3.Slerp(transform.position, curEndPoint, Time.deltaTime * speed);</span><br><span class="line">        transform.LookAt(lookAt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pingpong)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Vector3.Distance(transform.position, curEndPoint) &lt; <span class="number">0.001f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                curEndPoint = Vector3.Distance(curEndPoint, endPoint) &lt; Vector3.Distance(curEndPoint, startPoint) ? startPoint : endPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MotionBlur.cs 的代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MotionBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shader motionBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material motionBlurMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> motionBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义运动模糊在混合图像时使用的模糊参数，并限定范围值，blurAmount 越大，运动拖尾越明显</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 0.9f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurAmount = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个RenderTexture类型的变量，并且保存之前图像叠加的结果</span></span><br><span class="line">    <span class="keyword">private</span> RenderTexture accumulationTexture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在该脚本不运行时，即调用 OnDisable 函数时，立即销毁 accumulationTexture。保证下一次开始应用运动模糊时重新叠加图像</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span> &#123;</span><br><span class="line">        DestroyImmediate(accumulationTexture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断用于混合图像的 accumulationTexture 是否满足条件：不为空且与当前的屏幕分辨率相等</span></span><br><span class="line">            <span class="keyword">if</span> (accumulationTexture == <span class="literal">null</span> || accumulationTexture.width != src.width || accumulationTexture.height != src.height) &#123;</span><br><span class="line">                DestroyImmediate(accumulationTexture);</span><br><span class="line">                accumulationTexture = <span class="keyword">new</span> RenderTexture(src.width, src.height, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// HideAndDontSave 表示该变量不会显示在Hierarchy，也不会保存到场景中</span></span><br><span class="line">                accumulationTexture.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">                Graphics.Blit(src, accumulationTexture);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用 accumulationTexture.MarkRestoreExpected() 来表示需要进行一个渲染纹理的恢复操作，恢复操作指发生在纹理到渲染而该纹理又没有被提前清空或销毁的情况下。在本例中每次调用 OnRenderImage 都需要把当前帧图像和 accumulationTexture 中的图像混合，accumulationTexture 不需要提前清空，因为保存了之前的混合结果</span></span><br><span class="line">            accumulationTexture.MarkRestoreExpected();</span><br><span class="line"></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurAmount&quot;</span>, <span class="number">1.0f</span> - blurAmount);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, accumulationTexture, material);</span><br><span class="line">            Graphics.Blit (accumulationTexture, dest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Chapter12-MotionBlur.shader 的代码如下：  </p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 12/Motion Blur&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _BlurAmount (<span class="string">&quot;Blur Amount&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex; </span><br><span class="line">        fixed _BlurAmount;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;   </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义两个片元着色器，一个用于更新渲染纹理的 RGB 通道部分，一个用于更新渲染纹理的 A 通道部分。RGB 通道的 shader 对当前图像进行采样，并将其 A 通道设置为 _BlurAmount，以便可以在后面使用它的透明通道进行混合。A 通道直接返回采样结果，该只是为了维护渲染纹理的透明通道，不让其收到混合时使用的透明度值的影响</span></span><br><span class="line">        fixed4 <span class="title function_">fragRGB</span> <span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        half4 <span class="title function_">fragA</span> <span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新渲染纹理的 RGB 通道的 Pass，利用 A 通道来混合图像，但不希望该 A 通道写入渲染纹理</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ColorMask RGB</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragRGB  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新 A 通道的 Pass</span></span><br><span class="line">        Pass &#123;   </span><br><span class="line">            Blend One Zero</span><br><span class="line">            ColorMask A</span><br><span class="line">                   </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragA</span></span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 Chapter12-MotionBlurShader 文件拖拽到脚本的 Motion Blur Shader 属性上，效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/23/nQmI5FfOdJ9g3k7.gif" width = "70%" height = "70%" alt="图69-  运动模糊后的效果。"/>
</div>


<h1 id="第十二章-使用深度和法线纹理"><a href="#第十二章-使用深度和法线纹理" class="headerlink" title="第十二章 使用深度和法线纹理"></a>第十二章 使用深度和法线纹理</h1><p>在前一章节，学习的屏幕后处理效果都只是在屏幕颜色图像上进行各种操作来实现的。然而，很多时候我们不仅需要当前屏幕的颜色信息，还希望得到深度和法线信息。比如，在进行边缘检测时，直接利用颜色信息会使检测到的边缘信息受物体纹理和光照等外部因素的影响，得到很多不需要的边缘点。一种更好的方法是，我们可以在深度纹理和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。</p>
<h2 id="获取深度和法线纹理"><a href="#获取深度和法线纹理" class="headerlink" title="获取深度和法线纹理"></a>获取深度和法线纹理</h2><h3 id="背后的原理"><a href="#背后的原理" class="headerlink" title="背后的原理"></a>背后的原理</h3><p>深度纹理实际就是一张渲染纹理，里面存储的像素值不是颜色值，而是一个高精度的深度值。由于被存储在一张纹理中，深度纹理的深度值范围是 [0, 1]，而且通常是非线性分布的。</p>
<p><strong>深度值来自于顶点变换后得到的归一化的设备坐标 Normalized Device Coordinates, NDC 的 z 分量</strong>。一个模型要想最终被绘制在屏幕上，需要把它的顶点从模型空间变换到齐次裁剪坐标系下，通过在顶点着色器中乘以 MVP 矩阵变换得到的。在变换到最后一步，需要使用一个投影矩阵来变换顶点，而透视投影的投影矩阵就是非线性的（正交投影的投影矩阵是线性的）。</p>
<blockquote>
<p>回忆一下：顶点着色器阶段要把模型空间一步步转换到应用透视裁剪矩阵（或者正交）后的变换结果，合起来即 MVP 矩阵变换。而齐次除法则是底层硬件进行的，得到归一化的设备坐标。OpenGL 中 NDC 的 z 分量范围在 [-1, 1] 之间，而在 DirectX 中，z 分量在 [0, 1] 之间。</p>
</blockquote>
<p>在得到 NDC 之后，深度纹理中的像素值就可以得到了。NDC 的 z 分量范围在 [-1, 1] 之间，为了让这些值能够存储到一张图上，需要对其进行映射（d 对应了深度纹理中的像素值）：  </p>
<script type="math/tex; mode=display">d = 0.5 \cdot z_{NDC} + 0.5</script><hr>
<p>在 Unity 中，深度纹理可以直接来自于真正的深度缓存，也可以是由一个单独的 Pass 渲染而得，这取决于使用的渲染路径和硬件。<br>①当使用延迟渲染路径时，因为延迟渲染会把深度信息渲染到 G-buffer 中。<br>②当无法直接获取深度缓存时，深度和法线纹理是通过一个渲染。具体实现是：Unity 会使用着色器替换 Shader Replacement 技术选择那些渲染类型（即 SubShader 的 RenderType 标签）为 Opaque 的物体，判断它们使用的渲染队列是否小于等于 2500（内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内），如果满足条件，就把它渲染到深度和法线纹理中。因此，要想让物体能够出现在深度和法线纹理中，就<strong>必须在 Shader 中设置正确的 RenderType 标签</strong>。</p>
<p>在 Unity 中，我们可以选择让一个摄像机生成一张深度纹理或是一张深度 + 法线纹理。<br>①当只需要一张单独的深度纹理时，Unity 会直接获取深度缓存或是按之前讲到的着色器替换技术，选取需要的不透明物体，并使用它投射阴影时使用的 Pass （即 LightMode 设置为 ShaowCaster 的 Pass）来得到深度纹理。如果 Shader 中不包含这样一个 Pass，那么这个物体就不会出现在深度纹理中（当然，它也不能向其他物体投射阴影）。深度纹理的精度通常是 24 位或 16 位，这取决于使用的深度缓存的精度。<br>②如果选择生成一张深度 + 法线纹理，Unity 会创建一张和屏幕分辨率相同、 精度为 32 位（每个通道为 8 位）的纹理，其中观察空间下的法线信息会被编码进纹理的 R 和 G 通道，而深度信息会被编码进 B 和 A 通道。法线信息的获取在延迟渲染中是非常容易得到的，Unity 只需要合并深度和法线缓存即可。而在前向渲染中，默认情况下是不会去创建法线缓存的，因此 Unity 底层使用了一个单独的 Pass 把整个场景再次渲染一遍来完成。这个 Pass 被包含在 Unity 的内置的一个 Unity Shader 中，我们可以在内置的 build_shaders-xxx/DefaultResourcesExtra/Internal-DepthNormalsTexture.shader 文件中找到这个用于渲染深度和法线信息的的 Pass。</p>
<h3 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h3><p>在 Unity 中，首先获取深度纹理需要通过脚本中设置摄像机的 depthTextureMode：</p>
<pre><code>camera.depthTextureMode = DepthTextureMode.Depth;
</code></pre><p>一旦设置好了上面的摄像机模式后，我们就可以在 Shader 中通过声明 <code>_CameraDepthTexture</code> 变量来访问它。</p>
<p>同理，如果想要获取深度 + 法线纹理，我们需要在代码中这样设置：</p>
<pre><code>camera.depthTextureMode = DepthTextureMode.DepthNormals;
</code></pre><p>然后在 Shader 中通过声明 <code>_CameraDepthNormalsTexture</code> 来访问它。</p>
<p>我们还可以组合这些模式，让一个摄像机同时产生一张深度和深度 + 法线纹理：  </p>
<pre><code>camera.depthTextureMode |= DepthTextureMode.Depth;
camera.depthTextureMode |= DepthTextureMode.DepthNormals;
</code></pre><hr>
<p>在 Unity 5 中，我们还可以在摄像机的 Camera 组件上看到当前摄像机是否需要渲染深度或深度 + 法线纹理，当在 Shader 中访问到深度纹理 _CameraDepthTexture 后，我们就可以使用当前像素的纹理坐标对它进行采样。绝大多数情况下，我们直接使用 <code>tex2D</code> 函数采样即可，但在某些平台上，我们需要一些特殊处理。Unity 为我们提供了一个统一的宏 <code>SAMPLE_DEPTH_TEXTURE</code>，用来处理这些由于平台差异造成的问题。而我们只需要在 Shader 中使用 SAMPLE_DEPTH_TEXTURE 宏对深度纹理进行采样，得到深度值，例如：</p>
<pre><code>float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);
</code></pre><p>其中，i.uv 是一个 float2 类型的变量，对应了当前像素的纹理坐标。类似的宏还有 <code>SAMPLE_DEPTH_TEXTURE_PROJ</code> 和 <code>SAMPLE_DEPTH_TEXTURE_LOD</code>。</p>
<p><code>SAMPLE_DEPTH_TEXTURE_PROJ</code> 宏同样接收两个参数 – 深度纹理和一个 float3 或 float4 类型的纹理坐标，它内部使用了 tex2Dproj 这样的函数进行纹理采样，纹理坐标的前两个分量首先会除以最后一个分量，再进行纹理采样。如果提供了第四个分量，还会进行一次比较，通常用于阴影的实现中。第二个参数通常是由顶点着色器输出插值而得的屏幕坐标。例如：  </p>
<pre><code>float d = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTetxure, UNITY_PROJ_COORD(i.scrPos));
</code></pre><p>其中，i.scrPos 是在顶点着色器中通过调用 ComputeScreenPos(o.pos) 得到的屏幕坐标，上述这些宏的定义都可以在 Unity 内置的 HLSLSupport.cingc 文件中找到。</p>
<blockquote>
<p>ComputeScreenPos(o.pos) 得到是一个未进行齐次除法的“假视口坐标”，SAMPLE_DEPTH_TEXTURE_PROJ 宏使用了  tex2Dproj 函数将 i.scrPos 齐次除法后得到真正的视口坐标，再进行采样。而 UNITY_PROJ_COORD 返回一个适合投影纹理读取的纹理坐标，在大多数平台上，它直接返回给定值。</p>
</blockquote>
<hr>
<p>之前讲过，通过纹理采样得到的深度值，这些深度值往往是非线性的，这种非线性来自于透视投影使用的裁剪矩阵。然而，在我们的计算过程中通常是需要线性的深度值，也就是说，我们需要把投影后的深度值变换到线性空间下，例如视角空间（观察空间）下的深度值。下面以透视投影为例，推导如何由深度纹理的深度信息倒推顶点变换回到视角空间下的深度值：  </p>
<p>第三章中讲过，当我们使用透视投影的裁剪矩阵 $\,P_{clip}\,$ 对观察空间下的一个顶点进行变换后，裁剪空间下顶点的 z 和 w 分量为：  </p>
<script type="math/tex; mode=display">z_{clip} = - z_{view} \cfrac {Far + Near}{Far - Near} - \cfrac {2 \cdot Far \cdot Near}{Far - Near}</script><script type="math/tex; mode=display">w_{clip} = - z_{view}</script><p>然后通过齐次除法得到 NDC 下的 z 分量：  </p>
<script type="math/tex; mode=display">z_{ndc} = \cfrac {z_{clip}} {w_{clip}} = \cfrac {Far + Near}{Far - Near} + \cfrac {2 \cdot Far \cdot Near}{(Far - Near) \cdot z_{view} }</script><p>在本章最前面提到，深度纹理的深度值是 NDC 的 z 分量映射而得的：  </p>
<script type="math/tex; mode=display">d = 0.5 \cdot z_{NDC} + 0.5</script><p>由上面公式可以反向推导出 $\,z_{view}\,$ ：  </p>
<script type="math/tex; mode=display">z_{view} = \cfrac {1} { \cfrac { Far - Near }{ Far \cdot Near } d - \cfrac { 1 }{ Near } }</script><p>由于在 Unity 中使用的观察空间中，摄像机正向对应的 z 值均为负值，因此为了得到深度值的正数表示，我们需要对上面的结果取反，最后得到的结果如下：</p>
<script type="math/tex; mode=display">z_{view}' = \cfrac {1} { \cfrac { Near - Far }{ Near \cdot Far } d + \cfrac { 1 }{ Near } }</script><p>它的取值范围就是视锥体深度范围，即 [Near, Far]。如果我们想得到范围在 [0, 1] 之间的深度值，只需要把上面的结果除以 Far 即可。这样，0 就表示该点与摄像机位于同一位置，1 表示该点位于视锥体的远裁剪平面上，结果如下：</p>
<script type="math/tex; mode=display">z_{01} = \cfrac {1} { \cfrac { Near - Far }{ Near } d + \cfrac { Far }{ Near } }</script><p>幸运的是，Unity 提供了两个辅助函数来为我们进行上述的计算过程 —— <code>LinearEyeDepth</code> 和 <code>Linear01Depth</code>。<br>①<code>LinearEyeDepth</code> 负责把深度纹理的采样结果转换到观察空间下的深度值，也就是上面的 $\,z_{view}’\,$ ；<br>②<code>Linear01Depth</code> 则返回一个范围在 [0, 1] 的线性深度值，也就是上面得到的 $z_{01}$。<br>这两个函数内置使用了内置的 <code>_ZBufferParams</code> 变量来得到远近裁剪平面的距离。</p>
<hr>
<p>如果我们需要获取深度 + 法线纹理，可以直接使用 tex2D 函数对 _CameraDepthNormalsTexture 进行采样，得到里面存储的深度和法线信息。Unity 提供了辅助函数来为我们对这个采样结果进行解码，从而得到深度值和法线方向。这个函数是 <code>DecodeDepthNormal</code>，它在 UnityCG.cginc 被定义：  </p>
<pre><code>inline void DecodeDepthNormal(float4 enc, out float depth, out float3 normal)
&#123;
    depth = DecodeFloatRG(enc.zw);
    normal = DecodeViewNormalStereo(enc);
&#125;
</code></pre><p><code>DecodeDepthNormal</code> 的第一个参数是对深度 + 法线纹理的采样结果，这个采样结果是 Unity 对深度和法线信息编码后的结果，它的 xy 分量存储的是观察空间下的法线信息，而深度信息被编码进了 zw 分量。通过调用 DecodeDepthNormal 函数对采样结果解码后，我们就可以得到解码后的深度值和法线，这个深度值是范围在 [0, 1] 的线性深度值（<strong>这和单独的深度纹理中存储的深度值不同</strong>），得到的法线则是观察空间下的法线方向。同样，我们也可以通过调用 DecodeFloatRG 和 DecodeViewNormalStereo 来解码 + 深度法线纹理中的深度和法线信息。</p>
<h3 id="查看深度和法线纹理"><a href="#查看深度和法线纹理" class="headerlink" title="查看深度和法线纹理"></a>查看深度和法线纹理</h3><p>可以使用帧调试器查看摄像机生成的深度纹理和深度+法线纹理，图片这里不放出了，在 Camera Render 事件中的 UpdateDepthTexture 和 UpdateDepthNormalsTexture 事件中。</p>
<p>帧调试器看到的深度纹理是非线性空间的深度值，而深度+法线纹理都是由 Unity 编码后的结果。有时线性空间下的深度信息或解码后的法线方向会更加有用，此时可在片元着色器中做转换或解码逻辑：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">\\使用类似代码来输出线性深度值</span><br><span class="line"><span class="built_in">float</span>  depth  =  SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,  i.uv);</span><br><span class="line"><span class="built_in">float</span>  linearDepth  =  Linear01Depth(depth);</span><br><span class="line"><span class="keyword">return</span>  fixed4(linearDepth,  linearDepth,  linearDepth,  <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">\\或是输出解码后的法线方向</span><br><span class="line">fixed3  normal  =  DecodeViewNormalStereo(tex2D(_CameraDepthNormalsTexture,  i.uv).xy);</span><br><span class="line"><span class="keyword">return</span>  fixed4(normal  ＊  <span class="number">0.5</span>  +  <span class="number">0.5</span>,  <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>
<p>查看深度纹理时，如果画面几乎是全黑或全白时，可以将相机的远裁剪平面的距离（Unity 默认为1000）调小，使之刚好覆盖场景的所在区域即可。若裁剪平面的距离过大，会导致距离相机较近的物体会被映射到非常小的深度值，导致看起来全黑（场景为封闭区域比较常见）；相反，若场景为开放区域，物体距离相机较远，则会导致画面几乎全白。</p>
<h2 id="再谈运动模糊"><a href="#再谈运动模糊" class="headerlink" title="再谈运动模糊"></a>再谈运动模糊</h2><p>上一章学习了如何混合多张屏幕图像来模拟运动模糊的效果。而应用更加广泛的技术则是使用<strong>速度映射图</strong>。速度映射纹理中存储每个像素的速度，基于这个速度决定模糊的方向和大小。</p>
<p><strong>《GPU Gems3》</strong> 在第 27 章(<a target="_blank" rel="noopener" href="https://developer.nvidia.cn/gpugems/gpugems3/part-iv-image-effects/chapter-27-motion-blur-post-processing-effect">https://developer.nvidia.cn/gpugems/gpugems3/part-iv-image-effects/chapter-27-motion-blur-post-processing-effect</a>) 中介绍了一种生成速度映射图的方法。这种方法利用深度纹理在片元着色器中为每个像素计算其在世界空间下的位置，这是通过使用当前的观察 * 投影矩阵的逆矩阵对 NDC 下的顶点坐标进行变换得到的。当得到世界空间下的顶点坐标后，我们使用前一帧的观察 * 投影矩阵得到该位置在前一帧中的 NDC 坐标。我们计算前一帧和当前帧的位置差，生成该像素的速度。优点是可以在一个屏幕后处理步骤中完成整个效果的模拟，但缺点是需要在片元着色器中进行两次矩阵乘法的操作，对性能有所影响。</p>
<p>为了使用深度纹理模拟运动模糊，需要进行如下准备工作：<br>①新建名为 Scene_13_2 的场景，并关闭天空盒子；<br>②搭建测试运动模糊的场景，放置 3 面墙，4 个立方体；<br>③将 Translating.cs 脚本拖拽给摄像机，让其在场景中不断运动；<br>④新建名为 MotionBlurWithDepthTexture.cs 脚本，并拖拽给相机；<br>⑤新建名为 Chapter13-MotionBlurWithDepthTexture 的 Unity Shader；</p>
<p>MotionBlurWithDepthTexture.cs 脚本的 C# 代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MotionBlurWithDepthTexture</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader motionBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material motionBlurMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> motionBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本节需要得到摄像机的视角和投影矩阵，定义一个 Camera 变量获取脚本所在的摄像机组件</span></span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;        </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义运动模糊时模糊图像大小的参数</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSize = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个变量来保存上一帧摄像机的视角 × 投影矩阵</span></span><br><span class="line">    <span class="keyword">private</span> Matrix4x4 previousViewProjectionMatrix;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        <span class="comment">//为了获取摄像机的深度纹理，在 OnEnable 函数中设置摄像机的状态</span></span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line"></span><br><span class="line">        previousViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, blurSize);</span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_PreviousViewProjectionMatrix&quot;</span>, previousViewProjectionMatrix); <span class="comment">//设置矩阵参数并赋给 shader 中对应的参数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用 camera.projectionMatrix 和 camera.worldToCameraMatrix 分别获得当前摄像机的视角矩阵和投影矩阵</span></span><br><span class="line">            Matrix4x4 currentViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;</span><br><span class="line">            <span class="comment">//取逆得到当前帧的视角*投影矩阵的逆矩阵</span></span><br><span class="line">            Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;</span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_CurrentViewProjectionInverseMatrix&quot;</span>, currentViewProjectionInverseMatrix);</span><br><span class="line">            previousViewProjectionMatrix = currentViewProjectionMatrix;        <span class="comment">//将未取逆的结果存储到 previousViewProjectionMatrix 以便在下一帧时传递给材质。</span></span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);        <span class="comment">//若有material，则混合；若无则输出原图</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Chapter13-MotionBlurWithDepthTexture 的 Shader 代码如下：  </p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 13/Motion Blur With Depth Texture&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//输入的渲染纹理</span></span><br><span class="line">        _BlurSize (<span class="string">&quot;Blur Size&quot;</span>, Float) = <span class="number">1.0</span> <span class="comment">//脚本中模糊图像的控制参数</span></span><br><span class="line">        <span class="comment">//我们没有声明 _PreviousViewProjectionMatrix 和 _CurrentViewProjectionInverseMatrix 属性，是因为 Unity 没有提供矩阵的属性，但是仍然可以在 CG 代码块中定义这些矩阵</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        sampler2D _CameraDepthTexture;</span><br><span class="line">        float4x4 _CurrentViewProjectionInverseMatrix;</span><br><span class="line">        float4x4 _PreviousViewProjectionMatrix;</span><br><span class="line">        half _BlurSize;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">            half2 uv_depth : TEXCOORD1; <span class="comment">//对深度纹理采样的纹理坐标变量</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="type">float</span> d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth); <span class="comment">//对深度纹理进行采样得到该像素的深度缓冲值</span></span><br><span class="line">            </span><br><span class="line">            float4 H = float4(i.uv.x * <span class="number">2</span> - <span class="number">1</span>, i.uv.y * <span class="number">2</span> - <span class="number">1</span>, d * <span class="number">2</span> - <span class="number">1</span>, <span class="number">1</span>);    <span class="comment">//d 是 NDC 坐标映射而来，若要构建像素的 NDC 坐标 H，需要把这个深度值重新映射回 NDC，使用原映射的反函数，得到范围在 [-1, 1] 的 NDC 坐标。而渲染纹理的 uv 就是范围在 [0, 1] 的视口坐标，NDC 是范围在 [-1, 1] 的视口坐标，也需要映射回去</span></span><br><span class="line">            float4 D = mul(_CurrentViewProjectionInverseMatrix, H); <span class="comment">//逆矩阵回推</span></span><br><span class="line">            float4 worldPos = D / D.w; <span class="comment">//将结果除以 w 分量得到世界空间下的坐标表示 worldPos，这里除是因为 NDC 是被齐次除法后的坐标，需要乘回去，而经过逆矩阵回推的 D 的 w 分量，因为 H 的 w 分量为 1，逆矩阵会使 D 的 w 分量包含齐次除法的信息，而且这个值应该是齐次除法值的倒数，所以是除不是乘（可以尝试推导）</span></span><br><span class="line"></span><br><span class="line">            float4 currentPos = H; <span class="comment">//该像素现在的 NDC 坐标</span></span><br><span class="line">             </span><br><span class="line">            float4 previousPos = mul(_PreviousViewProjectionMatrix, worldPos); <span class="comment">//使用前一帧的视角 × 投影矩阵对它进行变换，得到前一帧在 NDC 下的坐标 previousPos </span></span><br><span class="line">            previousPos /= previousPos.w; <span class="comment">//齐次除法得到前一帧 NDC 的坐标</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//使用前一帧和当前帧的 NDC 的视口坐标下的位置差</span></span><br><span class="line">            float2 velocity = (currentPos.xy - previousPos.xy) / <span class="number">2.0f</span>;</span><br><span class="line">            </span><br><span class="line">            float2 uv = i.uv;</span><br><span class="line">            float4 c = tex2D(_MainTex, uv);</span><br><span class="line"></span><br><span class="line">            uv += velocity * _BlurSize;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++, uv += velocity * _BlurSize) &#123;</span><br><span class="line">                float4 currentColor = tex2D(_MainTex, uv); <span class="comment">//使用速度值对像素进行偏移后进行采样</span></span><br><span class="line">                c += currentColor;</span><br><span class="line">            &#125;</span><br><span class="line">            c /= <span class="number">3</span>; <span class="comment">//取平均值</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fixed4(c.rgb, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义模糊所需要的Pass</span></span><br><span class="line">        Pass &#123;      </span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">                    </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把该脚本拖拽到摄像机的 MotionBlurWithDepthTexture.cs 脚本中的 Motion Blur Shader 参数中，效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/25/Jp5ENyLDY2o1TBI.gif" width = "70%" height = "70%" alt="图70-  运用速度映射图的运动模糊后的效果。"/>
</div>

<p>注意：本节实现的运动模糊只适用于场景静止，摄像机运动的情况，因为只考虑了摄像机的运动。如果想要对快速移动的物体产生运动模糊后的效果，就需要更加精确的速度映射图，可以在 Unity 的 ImageEffect 包中找到更多的运动模糊的实现方法。</p>
<h2 id="全局雾效"><a href="#全局雾效" class="headerlink" title="全局雾效"></a>全局雾效</h2><p><strong>雾效 Fog</strong>是游戏里经常使用的一种效果。Unity 内置的雾效可以产生基于距离的线性或指数雾效。然而，想要在自己编写的顶点/片元着色器中实现这种雾效，我们需要在 Shader 中添加 <code>#paragma multi_compile_fog</code> 指令，同时还需要相关的内置宏，例如 UNITY_FOG_COORDS、UNITY_TRANSFER_FOG 和 UNITY_APPLY_FOG 等。这种方法的缺点在于，我们不仅需要为场景中所有物体添加相关的渲染代码，而且能够实现的效果也非常有限。我们需要对雾效进行一些个性化操作时，例如使用基于高度的雾效等，仅仅使用 Unity 内置的雾效就变得不再可行。</p>
<p>在本节中，我们将会学习一种基于屏幕后处理的全局雾效的实现。使用这种方法，我们不需要更改场景内渲染到物体所使用的 Shader 代码，而仅仅依靠一次屏幕后处理的步骤即可。这种方法的自由性很高，我们可以方便地模拟各种雾效，例如均匀的雾效、基于距离的线性/指数雾效、基于高度的雾效等。</p>
<p>基于屏幕后处理的全局雾效的关键是，根据深度纹理来重建每个像素在世界空间下的位置。我们在模拟运动模糊时已经实现了这个要求，即构建出当前像素的 NDC 坐标，再通过当前摄像机中的视角 * 投影矩阵的逆矩阵来得到世界空间下的像素坐标，但是，这样的实现需要在片元着色器中进行矩阵乘法的操作，而这通常会影响游戏性能。</p>
<p>本节中，我们将会学习一个快速从深度纹理中重构世界坐标的方法。这种方法首先对图像空间下的视锥体射线（从摄像机出发，指向图像上的某点的射线）进行插值，这条射线存储了该像素在世界空间下到摄像机的方向信息。然后，我们把该射线和线性化后的观察空间下的深度值相乘，再加上摄像机的世界位置，就可以得到该像素在世界空间下的位置。当我们得到世界坐标后，就可以轻松的使用各个公式来模拟全局雾效了。</p>
<h3 id="重建世界坐标"><a href="#重建世界坐标" class="headerlink" title="重建世界坐标"></a>重建世界坐标</h3><p>坐标系中的一个顶点坐标可以通过它相对于另一个顶点坐标的偏移量来求得。重建像素的世界坐标也是基于这种思想。我们只需要知道摄像机在世界空间下的位置，以及世界空间下该像素相对于摄像机的偏移量，把它们相加就可以得到该像素的世界坐标：  </p>
<pre><code>float4 worldPos = _WorldSpaceCamearaPos + linearDepth * interpolatedRay;
</code></pre><p>其中，<strong>_WorldSpaceCamearaPos</strong> 是摄像机在世界空间下的位置，这可以由 Unity 的内置变量直接访问得到。而 linearDepth <em> interpolatedRay 则可以计算得到该像素相对于摄像机的偏移量，<strong>linearDepth</strong> 是由深度纹理得到的线性深度值，<em>*interpolatedRay</em></em> 是由顶点着色器输出并插值后得到的射线，它不仅包含了该像素到摄像机的方向，也包含了距离信息。</p>
<p><strong>interpolatedRay 来源于对近裁剪平面的 4 个角的某个特定向量的插值</strong>，这 4 个向量包含了它们到摄像机的方向和距离信息，我们可以利用摄像机的近裁剪平面距离、FOV、横纵比计算而得。下图显示了计算时使用的一些辅助向量：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/26/gOjhfcrTqSiNUPw.jpg" width = "50%" height = "50%" alt="图71-  计算 interpolatedRay"/>
</div>

<p>为了方便计算，我们可以先计算两个向量 —— toTop 和 toRight，它们是起点位于近裁剪平面中心、分别指向摄像机正上方和正右方的向量，它们的计算公式如下：  </p>
<script type="math/tex; mode=display">halfHeight = Near \times tan( \cfrac {FOV} {2} )</script><script type="math/tex; mode=display">toTop = camera.up \times halfHeight</script><script type="math/tex; mode=display">toRight = camera.right \times halfHeight \cdot aspect</script><p>有了这两个辅助向量后，就可以计算 4 个角相对于摄像机的方向：  </p>
<script type="math/tex; mode=display">TL = camera.forward \cdot Near + toTop - toRight</script><script type="math/tex; mode=display">TR = camera.forward \cdot Near + toTop + toRight</script><script type="math/tex; mode=display">BL = camera.forward \cdot Near - toTop - toRight</script><script type="math/tex; mode=display">BR = camera.forward \cdot Near - toTop + toRight</script><p>上面求得的 4 个向量不仅包含了方向信息，它们的模对应了 4 个点到摄像机的空间距离。由于我们得到的线性深度值并非是点到摄像机的欧式距离，而是在 z 方向上的距离，不能直接使用深度值和 4 个角的单位方向的乘积来计算它们到相机的偏移量。要把深度值转换成到摄像机的欧式距离，我们以 TL 点为例，如下图：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/26/t9m42ryzPfjTOIB.jpg" width = "40%" height = "40%" alt="图72-  采样得到的深度值并非是点到摄像机的欧式距离"/>
</div>

<p>根据相似三角形原理，TL 所在的射线上，像素的深度值和它到摄像机的实际距离的比等于近裁剪平面的距离和 TL 向量的模的比，即：  </p>
<script type="math/tex; mode=display">\cfrac {depth}{dist} = \cfrac {Near}{|TL|}</script><p>即 TL 所在的射线上的像素距离摄像机的欧式距离 dist：  </p>
<script type="math/tex; mode=display">dist = \cfrac {|TL|}{Near} \times depth</script><p>为了得到 linearDepth * interpolatedRay 中的 interpolatedRay，需要求得近裁切平面的四个角的向量的类似于  interpolatedRay 的值作插值，以 TL 为例子，即：</p>
<script type="math/tex; mode=display">linearDepth \times Ray_{TL} = depth \times Ray_{TL} = dist \times \cfrac {TL}{|TL|}</script><script type="math/tex; mode=display">Ray_{TL} = \cfrac {|TL|}{Near} \times depth \times \cfrac {TL}{|TL|} \div depth = \cfrac {TL}{Near}</script><p>因为近裁切平面的四个角相互对称，令 $\,scale = |TL| / Near\,$，则：  </p>
<script type="math/tex; mode=display">Ray_{TL} = \cfrac {TL}{|TL|} \times scale , Ray_{TR} = \cfrac {TR}{|TR|} \times scale</script><script type="math/tex; mode=display">Ray_{BL} = \cfrac {BL}{|BL|} \times scale , Ray_{BR} = \cfrac {BR}{|BR|} \times scale</script><p>屏幕后处理的原理就是使用特定的材质去渲染一个刚好填充整个屏幕的四边形面片，<strong>屏幕后处理所用的模型是一个四边形网格，只包含 4 个顶点</strong>。这个四边形面片的 4 个顶点就对应了近裁剪平面的 4 个角。因此，我们可以把上面的计算结果传递给顶点着色器，顶点着色器根据当前的位置选择它所对应的向量，然后将其输出，经插值后传递给片元着色器得到基于像素的 interpolatedRay，我们就可以直接利用本节一开始提到的公式重建该像素在世界空间下的位置了。</p>
<h3 id="雾的计算"><a href="#雾的计算" class="headerlink" title="雾的计算"></a>雾的计算</h3><p>在简单的雾效实现中，我们需要计算一个雾效系数 f，作为混合原始颜色和雾的颜色的混合系数：  </p>
<pre><code>float3 afterFog = f * fogColor + (1 - f) * origColor
</code></pre><p>这个雾效系数 f 有很多计算方法。在 Unity 内置的雾效实现中，支持三种雾的计算方式 —— 线性 Linear、指数 Exponential 以及指数的平方 Exponential Squared。当给定距离 z 后，f 的计算公式分别如下：<br>①Linear：  </p>
<script type="math/tex; mode=display">f= \cfrac {d_{max} - |z|}{d_{max} - d_{min}},d_{max}和d_{min}分别表示受雾影响的最大最小距离</script><p>②Exponential：</p>
<script type="math/tex; mode=display">f= e^{-d \cdot |z|},d是控制雾的浓度的参数</script><p>③Exponential Squared：</p>
<script type="math/tex; mode=display">f= e^{-(d \cdot |z|)^2},d是控制雾的浓度的参数</script><p>在本节中，我们将使用类似线性雾的计算方式，计算基于高度的雾效。具体方法是，当给定一点在世界空间下的高度 y 后，f 的计算公式为：  </p>
<script type="math/tex; mode=display">f = \cfrac {H_{end} - y}{H_{end} - H_{start}},H_{start}和H_{end} 分别表示受雾影响的起始高度和终止高度</script><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>准备工作如下：<br>①新建名为 Scene_13_3 的场景，并去掉天空盒子；<br>②搭建一个雾效场景，构建包含 3 面墙的房间，并放置几个立方体；<br>③拖拽一个控制相机不断围绕一个中心运动的脚本 Translating.cs 到相机组件；<br>④新建一个名为 FogWithDepthTexture 的 C# 脚本，并拖拽给相机；<br>⑤新建一个名为 Chapter13-FogWithDepthTexture 的 Unity Shader。</p>
<p>FogWithDepthTexture.cs 的 C# 脚本代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FogWithDepthTexture</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shader fogShader;</span><br><span class="line">    <span class="keyword">private</span> Material fogMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);</span><br><span class="line">            <span class="keyword">return</span> fogMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Transform myCameraTransform;</span><br><span class="line">    <span class="keyword">public</span> Transform cameraTransform &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCameraTransform == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCameraTransform = camera.transform;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCameraTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogDensity = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Color fogColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//雾效的起始高度和终止高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogStart = <span class="number">0.0f</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogEnd = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth; <span class="comment">//设置模式以在 shader 里获取深度纹理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            Matrix4x4 frustumCorners = Matrix4x4.identity; <span class="comment">//frustum：视锥体，初始化为单位矩阵，把计算近裁剪平面的四个角对应的向量，存储到这个矩阵类型的变量</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">            <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">            <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//本节最开始的公式的计算过程如下</span></span><br><span class="line">            <span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">            Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">            Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line">            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">            <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line">            topLeft.Normalize();</span><br><span class="line">            topLeft *= scale;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算各点的欧式距离</span></span><br><span class="line">            Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">            topRight.Normalize();</span><br><span class="line">            topRight *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">            bottomLeft.Normalize();</span><br><span class="line">            bottomLeft *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">            bottomRight.Normalize();</span><br><span class="line">            bottomRight *= scale;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按一定顺序把四个方向存储到 frustumCorners 的不同的行中</span></span><br><span class="line">            frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line"></span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Chapter13-FogWithDepthTexture 的 Shader 代码如下：  </p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 13/Fog With Depth Texture&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _FogDensity (<span class="string">&quot;Fog Density&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _FogColor (<span class="string">&quot;Fog Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _FogStart (<span class="string">&quot;Fog Start&quot;</span>, Float) = <span class="number">0.0</span></span><br><span class="line">        _FogEnd (<span class="string">&quot;Fog End&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        float4x4 _FrustumCornersRay;</span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        sampler2D _CameraDepthTexture;</span><br><span class="line">        half _FogDensity;</span><br><span class="line">        fixed4 _FogColor;</span><br><span class="line">        <span class="type">float</span> _FogStart;</span><br><span class="line">        <span class="type">float</span> _FogEnd;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">            half2 uv_depth : TEXCOORD1;</span><br><span class="line">            float4 interpolatedRay : TEXCOORD2;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//决定该顶点对应了 4 个角中的哪个角，这里使用判断语句是因为屏幕后处理所用的模型是一个四边形网格，只包含 4 个顶点，因此对性能影响不大</span></span><br><span class="line">            <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (v.texcoord.x &lt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                index = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                index = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                index = <span class="number">3</span> - index;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            </span><br><span class="line">            o.interpolatedRay = _FrustumCornersRay[index]; <span class="comment">//利用索引值来获取 _FrustumCornersRay 中对应的行</span></span><br><span class="line">              </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth)); <span class="comment">//对深度纹理采样后，使用 LinearEyeDepth 得到观察空间下的线性深度值</span></span><br><span class="line">            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;</span><br><span class="line">                        </span><br><span class="line">            <span class="type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); </span><br><span class="line">            fogDensity = saturate(fogDensity * _FogDensity); <span class="comment">//控制雾效系数</span></span><br><span class="line">            fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line">            <span class="keyword">return</span> finalColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">                     </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 Chapter13-FogWithDepthTexture 拖拽到摄像机的脚本的 Fog Shader 参数中，效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/26/VpA56mbuRcKTIMg.jpg" width = "70%" height = "70%" alt="图73-  添加全局雾效后的效果"/>
</div>

<p><strong>本节介绍的使用深度纹理重构像素的世界坐标的方法是非常有用的</strong>。但是需要注意的是，这里的实现是基于摄影机的投影类型是透视投影的前提下。若需要在正交投影的情况下重建世界坐标，需要使用不同的公式，有兴趣可以自己推导。</p>
<h2 id="再谈边缘检测"><a href="#再谈边缘检测" class="headerlink" title="再谈边缘检测"></a>再谈边缘检测</h2><p>在上一章节，使用的是 <strong>Sobel 算子</strong> 对屏幕图像进行边缘检测，这种直接利用颜色信息进行边缘检测的方法会受纹理、阴影等因素的影响，导致最终的描边并不精确。</p>
<p>在本节中，将利用深度和法线纹理，通过 <strong>Roberts 算子</strong>进行边缘检测，不受纹理和光照影响。Roberts 算子使用的卷积核如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/26/V6PIaFLX7sToSvt.jpg" width = "20%" height = "20%" alt="图74-   Roberts 算子"/>
</div>

<p>Roberts 算子的本质是就是计算左上角和右上角的差值，乘以右上角和左下角的差值，作为评估边缘的依据。在下面的实现中，我们也会按照这样的方式，取对角方向的深度或法线值，比较它们之间的差值，如果超过某个阈值，就认为它们之间存在一条边。</p>
<p>准备工作如下：<br>①新建名为 Scene_13_4 的场景，并去掉天空盒；<br>②搭建类似上一节全局雾效的场景；<br>③将上一节中用到的 Translating.cs 脚本拖拽给相机；<br>④新建名为 EdgeDetectNormalsAndDepth 的 C# 脚本，并拖拽给相机；<br>⑤新建名为 Chapter13-EdgeDetectNormalAndDepth 的 Unity Shader；  </p>
<p>EdgeDetectNormalsAndDepth.cs 的 C# 脚本代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetectNormalsAndDepth</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shader edgeDetectShader;</span><br><span class="line">    <span class="keyword">private</span> Material edgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            <span class="keyword">return</span> edgeDetectMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sampleDistance = <span class="number">1.0f</span>; <span class="comment">//用于控制对深度+法线纹理采样时，使用的采样距离。从视觉上看，为描边粗细程度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//sensitivityDepth 和 sensitivityNormals 则影响当邻域的深度值或法线值相差多少时被认为存在一条边界，而如果灵敏度调的很大，那么可能是深度或法线上很小的变化也会成为一条边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sensitivityDepth = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sensitivityNormals = <span class="number">1.0f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ImageEffectOpaque 特性，见第 11 章最前面，目的是为了在不透明的 Pass 执行完毕后立即调用该函数，不对透明物体产生影响。在本例中，不希望对透明物体也被描边</span></span><br><span class="line">    [<span class="meta">ImageEffectOpaque</span>]</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, edgesOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>, edgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_SampleDistance&quot;</span>, sampleDistance);</span><br><span class="line">            material.SetVector(<span class="string">&quot;_Sensitivity&quot;</span>, <span class="keyword">new</span> Vector4(sensitivityNormals, sensitivityDepth, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Chapter13-EdgeDetectNormalAndDepth 的 Shader 代码如下：</p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 13/Edge Detection Normals And Depth&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _EdgeOnly (<span class="string">&quot;Edge Only&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (<span class="string">&quot;Edge Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (<span class="string">&quot;Background Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _SampleDistance (<span class="string">&quot;Sample Distance&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _Sensitivity (<span class="string">&quot;Sensitivity&quot;</span>, Vector) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        fixed _EdgeOnly;</span><br><span class="line">        fixed4 _EdgeColor;</span><br><span class="line">        fixed4 _BackgroundColor;</span><br><span class="line">        <span class="type">float</span> _SampleDistance;</span><br><span class="line">        half4 _Sensitivity;</span><br><span class="line">        </span><br><span class="line">        sampler2D _CameraDepthNormalsTexture;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>]: TEXCOORD0; <span class="comment">//定义维数为 5 的纹理坐标数组，第一个坐标存储了屏幕颜色图像的采样纹理，剩下四个存储使用 Roberts 算子时需要采样的纹理坐标</span></span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP <span class="comment">//解决平台差异性</span></span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                uv.y = <span class="number">1</span> - uv.y;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算罗伯特算子，使用 _SampleDistance 控制采样距离</span></span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        half <span class="title function_">CheckSame</span><span class="params">(half4 center, half4 sample)</span> &#123;</span><br><span class="line">            <span class="comment">//对输入的两个点的采样后的深度和法线信息进行处理。注意，这里没有解码得到真正的法线值，而是直接使用了 xy 分量。是因为我们只需要比较两个采样值的差异，不需要知道它们真正的法线</span></span><br><span class="line">            half2 centerNormal = center.xy;        </span><br><span class="line">            <span class="type">float</span> centerDepth = DecodeFloatRG(center.zw);        </span><br><span class="line">            half2 sampleNormal = sample.xy;</span><br><span class="line">            <span class="type">float</span> sampleDepth = DecodeFloatRG(sample.zw);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//两个采样点的对应值相减并取绝对值在乘以灵敏度参数，再把差异值的每个分量相加和一个阈值比较，若小于阈值则返回 1，说明差异不明显，否则则返回 0</span></span><br><span class="line">            half2 diffNormal = <span class="built_in">abs</span>(centerNormal - sampleNormal) * _Sensitivity.x;</span><br><span class="line">            <span class="type">int</span> isSameNormal = (diffNormal.x + diffNormal.y) &lt; <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用偏差是否达到深度的十分之一来判定深度值是否相近</span></span><br><span class="line">            <span class="type">float</span> diffDepth = <span class="built_in">abs</span>(centerDepth - sampleDepth) * _Sensitivity.y;</span><br><span class="line">            <span class="type">int</span> isSameDepth = diffDepth &lt; <span class="number">0.1</span> * centerDepth;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// return:</span></span><br><span class="line">            <span class="comment">// 1 - if normals and depth are similar enough</span></span><br><span class="line">            <span class="comment">// 0 - otherwise</span></span><br><span class="line">            <span class="keyword">return</span> isSameNormal * isSameDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 <span class="title function_">fragRobertsCrossDepthAndNormal</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="comment">//使用 4 个纹理坐标对深度+法线纹理进行法线采样</span></span><br><span class="line">            half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">1</span>]);</span><br><span class="line">            half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">2</span>]);</span><br><span class="line">            half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">3</span>]);</span><br><span class="line">            half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">4</span>]);</span><br><span class="line">            </span><br><span class="line">            half edge = <span class="number">1.0</span>;</span><br><span class="line">            edge *= CheckSame(sample1, sample2); <span class="comment">//调用 checksame 计算对角线上两个纹理值的差值，若返回 0 则两点间存在一条边界，反之则为 1</span></span><br><span class="line">            edge *= CheckSame(sample3, sample4);</span><br><span class="line">            </span><br><span class="line">            fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">0</span>]), edge);</span><br><span class="line">            fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">            <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        Pass &#123; </span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM      </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragRobertsCrossDepthAndNormal</span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 Chapter13-EdgeDetectNormalAndDepth 拖入摄像机脚本的 Edge Detect Shader 参数中，效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/27/5DIAmgKqwtXaZhV.png" width = "60%" height = "60%" alt="图75-   在深度和法线纹理上进行更健壮的边缘检测。上图：在原图上描边的效果（Edges only 为 0）。右图：只显示描边的效果（Edges only 为 1）"/>
</div>

<p>本节实现的描边效果是基于整个屏幕空间进行的，场景内所有物体都会被添加描边效果。但有时，我们希望只对特定的物体进行描边，这时需要 Unity 提供的 Graphics.DrawMesh 或 Graphics.DrawMeshNow 函数，把需要描边的物体再次渲染一次（在所有不透明物体渲染完毕之后），再使用本节提到的边缘检测算法计算深度或法线纹理中每个像素的梯度值，判断它们是否小于阈值。若是，则在 Shader 中使用 clip() 函数将该像素剔除掉，从而显示出原来的颜色。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>在本章中，我们只使用了深度和法线纹理，但实际上我们可以在 Unity 中创建任何需要的缓存纹理。这可以通过使用 Unity 的着色器替换 shader replacement 功能，即调用 Camera.RenderWithShader(shader, replacementTag) 函数，把整个场景再次渲染一遍来得到，而在很多时候，这实际上也是 Unity 创建深度和法线纹理时使用的方法。</p>
<p>深度和法线纹理在屏幕特效的实现中扮演很重要的角色，很多特殊的屏幕效果都可以基于深度和法线纹理去实现，原作者给出了 Unity 在 2011 年的 SIGGRAPH（计算机图形学的顶级会议）上做的一个关于使用深度纹理实现各种特效的演讲，感兴趣可前往阅读：<a target="_blank" rel="noopener" href="https://blog.unity.com/community/special-effects-with-depth-talk-at-siggraph">https://blog.unity.com/community/special-effects-with-depth-talk-at-siggraph</a></p>
<h1 id="第十三章-非真实感渲染"><a href="#第十三章-非真实感渲染" class="headerlink" title="第十三章 非真实感渲染"></a>第十三章 非真实感渲染</h1><p>一些游戏渲染是以<strong>照相写实主义 photorealism</strong> 作为主要目标，但也有一些游戏使用了<strong>非真实感渲染 Non-Photorealistic Rendering, NPR</strong> 的方法来渲染游戏画面。非真实感渲染的一个主要目标是，使用一些渲染方法使得画面达到和某些特殊的绘画风格相似的效果，例如卡通、水彩风格等。</p>
<h2 id="卡通风格的渲染"><a href="#卡通风格的渲染" class="headerlink" title="卡通风格的渲染"></a>卡通风格的渲染</h2><p>要实现卡通渲染有很多方法，其中之一就是使用<strong>基于色调的着色技术 tone-based shading</strong>。在实现中，我们往往会使用漫反射系数对一张一维纹理进行采样，以控制漫反射的色调，也就是第六章实现的渐变纹理。</p>
<p>卡通的高光效果和之前学习的光照不同，模型的高光往往是一块块分界明显的纯色区域。</p>
<p>除了光照模型不同外，卡通风格通常还需要在物体边缘部分绘制轮廓。在上一章节，使用的是屏幕后处理技术对屏幕图像进行描边。在本节中，将介绍基于模型的描边方法，这种方法的实现更加简单，而且大多数情况下效果不错。</p>
<h3 id="渲染轮廓线"><a href="#渲染轮廓线" class="headerlink" title="渲染轮廓线"></a>渲染轮廓线</h3><p>在实时渲染中，轮廓线的渲染应用广泛。在《Real Time Rendering, third edition》中，作者将绘制模型轮廓的方法分为了 5 种：<br>①基于观察角度和表面法线的轮廓线渲染：使用视角方向和表面法线的点乘结果来得到轮廓线的信息。这种方法简单快捷，可以在一个 Pass 中就得到渲染结果，但局限性很大，很多模型渲染出来的描边效果都不尽人意。<br>②过程式几何轮廓渲染：使用两个 Pass 渲染。第一个 Pass 渲染背面的面片，并使用某些技术让它的轮廓可见；第二个 Pass 再正常渲染正面的面片。这种方法的优点在于快速有效，并且适用于绝大多数表面平滑的模型，但它的缺点是不适用于类似于立方体这样的平整的模型。<br>③基于图像处理的轮廓线渲染：我们在 11、12 章介绍的边缘检测的方法就属于这个类别。这种方法的优点在于，可以适用于任何种类的模型。但它也有自身的局限所在，一些深度和法线变化很小的轮廓无法被检测出来，例如桌子上的纸张。<br>④基于轮廓边检测的轮廓线渲染：上面提到的各种方法，一个最大的问题是，无法控制轮廓线的风格渲染。对于一些情况，我们希望可以渲染出独特风格的轮廓线，例如水墨风格等。为此，我们希望可以检测出精确的轮廓边，然后直接渲染它们。检测一条边是否是轮廓边的公式也很简单，我们只需要检查和这条边相邻的两个三角面片是否满足以下条件：</p>
<script type="math/tex; mode=display">(n_0 \cdot v > 0) \neq (n_1 \cdot v > 0)</script><p>其中，$\,n_0\,$ 和 $\,n_1\,$ 分别表示两个相邻三角面片的法向，v 是从视角到该边上任意顶点的方向。上述公式的本质在于检查两个相邻的三角面片是否一个朝正面、一个朝背面。我们可以在几何着色器 Geometry Shader 的帮助下实现上面的检测过程。当然，这种方法也有缺点，除了实现相对复杂外，它还会有动画连贯性的问题。也就是说，由于是逐帧单独提取轮廓，所以在帧与帧之间会出现跳跃性。<br>⑤最后一个种类就是混合了上述几种渲染方法。例如，首先找到精确的轮廓边，把模型和轮廓边渲染到纹理中，再使用图像处理的方法识别出轮廓线，并在图像空间下进行风格化渲染。</p>
<hr>
<p>在本节中，我们将会在 Unity 中使用<strong>过程式几何轮廓线渲染</strong>的方法来对模型进行轮廓描边。我们将使用两个 Pass 渲染模型：在第一个 Pass 中，我们会使用轮廓线颜色渲染整个背面的面片，并在视角(观察)空间下把模型顶点沿着法线方向向外扩张一段距离，一次来让背部轮廓线可见。代码如下：  </p>
<pre><code>viewPos = viewPos + viewNormal * _Outline;
</code></pre><p>但是，如果直接使用顶点法线进行扩展，对于一些内凹的模型，就可能发生背面面片遮挡正面面片的情况。为了尽可能防止出现这样的情况，在扩张背面顶点之前，我们首先对顶点法线的 z 分量进行处理，使它们等于一个定值，然后把法线归一化再对顶点进行扩张。这样的好处在于，扩展后的背面更加扁平化，从而降低了遮挡正面面片的可能性。代码如下：  </p>
<pre><code>viewNormal.z = -0.5;
viewNormal = normalize(viewNormal);
viewPos = viewPos + viewNormal * _Outline;
</code></pre><h3 id="添加高光"><a href="#添加高光" class="headerlink" title="添加高光"></a>添加高光</h3><p>卡通风格中的高光是模型上一块块分界明显的纯色区域。因此不能在使用之前学习的光照模型，回顾一下之前实现的 Blinn-Phong 模型，我们使用法线点乘光照方向以及视角方向和的一半，再和另一个参数进行指数操作得到高光反射系数，代码如下：  </p>
<pre><code>float spec = pow(max(0, dot(normal, halfDir)), _Gloss);
</code></pre><p>对于卡通渲染需要的高光反射光照模型，我们同样需要计算 normal 和 halfDir 的点乘结果，但不同的是，我们把该值和一个阈值进行比较，如果小于该阈值，则高光反射系数为 0，否则返回 1：  </p>
<pre><code>float spec = dot(worldNormal, worldHalfDir);
spec = step(threshold, spec);
</code></pre><p>在上面的代码中，我们使用 Cg 的 <code>step</code> 函数来实现和阈值比较的目的。step 函数接受两个参数，第一个参数是参考值，第二个参数是待比较的数值。如果第二个参数大于等于第一个参数，则返回 1，否则返回 0。</p>
<p>但是，这种粗暴的判断方法会在高光区域的边界造成锯齿，因为高光区域的边缘不是平滑渐变的，而是从 0 突破到 1。要想对其进行抗锯齿处理，我们可以在边界很小的一块区域内，进行平滑处理，代码如下：  </p>
<pre><code>float spec = dot(worldNormal, worldHalfDir);
spec = lerp(0, 1, smoothstep(-w, w, spec - threshold))
</code></pre><p>使用了 Cg 的 <code>smoothstep</code> 函数。其中，w 是一个很小的值，当 spec - threshold 小于 -w 时，返回 0，大于 w 时，返回 1，否则在 0 到 1 之间进行插值。这样的效果是，我们可以在 [-w, w] 区间内，即高光区域的边界处，得到一个从 0 到 1 平滑变化的 spec 值，从而实现抗锯齿的目的。尽管我们可以把 w 设为一个很小的定值，但在本例中，我们选择使用领域像素之间的近似导数值，这可以通过 CG 的 <code>fwidth</code> 函数来得到。</p>
<blockquote>
<pre><code>ddx(v) = 该像素点右边的值 - 该像素点的值  
ddy(v) = 该像素点下面的值 - 该像素点的值  
fwidth（v） = abs(ddx(v)) + abs(ddy(v))  //邻域像素之间的近似导数值  
</code></pre><p>当代 GPU 在像素化的时候一般是以 2 x 2 像素为基本单位，那么在这个 2 x 2 像素块当中，右侧的像素对应的 fragment 的 x 坐标减去左侧的像素对应的 fragment 的 x 坐标就是ddx；下侧像素对应的 fragment 的坐标 y 减去上侧像素对应的 fragment 的坐标 y 就是 ddy，ddx 和 ddy 代表了相邻两个像素在设备坐标系当中的距离。</p>
</blockquote>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>准备工作如下：<br>①新建名为 Scene_14_1 的场景，并去掉天空盒；<br>②往场景中拖入一个 Suzanne 模型；<br>③新建名为 ToonShadingMat 的材质，并赋给上一步的模型；<br>④新建名为 Chapter14-ToonShading 的 Unity Shader，并赋给上一步的材质。</p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 14/Toon Shading&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Ramp (<span class="string">&quot;Ramp Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Outline (<span class="string">&quot;Outline&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span> <span class="comment">//控制轮廓线宽度</span></span><br><span class="line">        _OutlineColor (<span class="string">&quot;Outline Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) </span><br><span class="line">        _Specular (<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _SpecularScale (<span class="string">&quot;Specular Scale&quot;</span>, Range(<span class="number">0</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span> <span class="comment">//控制高光反射的阈值</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            NAME <span class="string">&quot;OUTLINE&quot;</span> <span class="comment">//定义名称，方便其他 shader 调用</span></span><br><span class="line">            </span><br><span class="line">            Cull Front <span class="comment">//把正面的三角面片剔除掉，只渲染背面</span></span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="type">float</span> _Outline;</span><br><span class="line">            fixed4 _OutlineColor;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span>        </span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;; </span><br><span class="line">                </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span>        </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//先变换到观察空间</span></span><br><span class="line">                float4 pos = mul(UNITY_MATRIX_MV, v.vertex); </span><br><span class="line">                float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);</span><br><span class="line">                <span class="comment">//观察空间是右手坐标系，所以是减</span></span><br><span class="line">                normal.z = <span class="number">-0.5</span>;</span><br><span class="line">                pos = pos + float4(normalize(normal), <span class="number">0</span>) * _Outline;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_P, pos); <span class="comment">//变换到裁剪空间中</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            float4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> float4(_OutlineColor.rgb, <span class="number">1</span>); <span class="comment">//渲染着整个背面即可       </span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125; <span class="comment">//前向渲染标签，光照模型需要 Unity 提供光照等信息，从而要对pass进行相应的设置</span></span><br><span class="line">            </span><br><span class="line">            Cull Back</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">        </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">        </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityShaderVariables.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _Ramp;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            fixed _SpecularScale;</span><br><span class="line">        </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">            &#125;; </span><br><span class="line">        </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 worldNormal : TEXCOORD1;        </span><br><span class="line">                float3 worldPos : TEXCOORD2;    </span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>) <span class="comment">//阴影相关宏</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos( v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX (v.texcoord, _MainTex);</span><br><span class="line">                o.worldNormal  = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                TRANSFER_SHADOW(o); <span class="comment">//阴影相关宏</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            float4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123; </span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 worldHalfDir = normalize(worldLightDir + worldViewDir);</span><br><span class="line">                </span><br><span class="line">                fixed4 c = tex2D (_MainTex, i.uv);</span><br><span class="line">                fixed3 albedo = c.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); <span class="comment">//利用内置宏计算当前世界坐标下的阴影值</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//半兰伯特漫反射系数和阴影值相乘得到最终的漫反射系数</span></span><br><span class="line">                fixed diff =  dot(worldNormal, worldLightDir);</span><br><span class="line">                diff = (diff * <span class="number">0.5</span> + <span class="number">0.5</span>) * atten;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;</span><br><span class="line">                </span><br><span class="line">                fixed spec = dot(worldNormal, worldHalfDir);</span><br><span class="line">                fixed w = fwidth(spec) * <span class="number">2.0</span>; <span class="comment">//抗锯齿操作</span></span><br><span class="line">                fixed3 specular = _Specular.rgb * lerp(<span class="number">0</span>, <span class="number">1</span>, smoothstep(-w, w, spec + _SpecularScale - <span class="number">1</span>)) * step(<span class="number">0.0001</span>, _SpecularScale); <span class="comment">//0.0001是为了在 _SpecularScale 为 0 时完全消除高光反射的光照</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>); <span class="comment">//环境光、漫反射和高光反射相加的结果</span></span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/28/vxXMywPiJB6pWNK.jpg" width = "70%" height = "70%" alt="图76- 卡通风格的渲染效果"/>
</div>

<p>本节实现的卡通渲染光照模型是一种非常简单的实现，要获取更出色的卡通效果，需自行查阅更多资料。</p>
<h2 id="素描风格的渲染"><a href="#素描风格的渲染" class="headerlink" title="素描风格的渲染"></a>素描风格的渲染</h2><p>另一个非常流行的非真实渲染时素描风格的渲染。微软研究院的 Praun 等人在 2001 年的 SIGGRAPH 上发表了一篇非常著名的论文。在这篇文章中，他们使用了提前生成的素描纹理来实现实时的素描风格渲染，这些纹理组成了一个<strong>色调艺术映射 Tonal Art Map，TAM</strong>，如下图所示：</p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/28/8ChEtLKZicqxYJ2.jpg" width = "70%" height = "70%" alt="图77- 一个 TAM 的例子（来源：Praun E, et al. Real-time hatching）"/>
</div>

<p>上图中，从左到右纹理中的笔触逐渐增多，用于模拟不同光照下的漫反射效果，从上到下对应了每张纹理的<strong>多级渐远纹理 mipmaps</strong>。这些纹理的生成并不是简单的对上一层纹理进行降采样，而是需要保持笔触之间的间隔，以便真实模拟素描的效果。</p>
<p>本节将会实现简化版的论文中提出的算法，我们不考虑多级渐远纹理的生成，而直接使用 6 张纹理进行渲染。在渲染阶段，我们首先在顶点着色阶段计算逐顶点的光照，根据光照结果来决定 6 张纹理的混合权重，并传递给片元着色器。然后，在片元着色器中根据这些权重来混合 6 张纹理的采样结果。</p>
<p>准备工作如下：<br>①新建名为 Scene_14_2 的场景，并去掉天空盒；<br>②拖拽 TeddyBear 模型到场景。可以往场景中拖入一张纸张图像作为背景；<br>③新建名为 HatchingMat 的材质，并赋给上一步的模型；<br>④新建名为 Chapter14-Hatching 的 Unity Shader，并赋给上一步创建的材质。</p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 14/Hatching&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _TileFactor (<span class="string">&quot;Tile Factor&quot;</span>, Float) = <span class="number">1</span> <span class="comment">//纹理的平铺系数，越大，素描线条越密</span></span><br><span class="line">        _Outline (<span class="string">&quot;Outline&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span> <span class="comment">//描边的粗细</span></span><br><span class="line">        <span class="comment">//渲染时的6张素描纹理，其线条密度依次增加</span></span><br><span class="line">        _Hatch0 (<span class="string">&quot;Hatch 0&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Hatch1 (<span class="string">&quot;Hatch 1&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Hatch2 (<span class="string">&quot;Hatch 2&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Hatch3 (<span class="string">&quot;Hatch 3&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Hatch4 (<span class="string">&quot;Hatch 4&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Hatch5 (<span class="string">&quot;Hatch 5&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        UsePass <span class="string">&quot;Unity Shaders Book/Chapter 14/Toon Shading/OUTLINE&quot;</span> <span class="comment">//使用卡通渲染的 pass 进行渲染轮廓，别忘了 Pass 名字要全部转为大写</span></span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityShaderVariables.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _TileFactor;</span><br><span class="line">            sampler2D _Hatch0;</span><br><span class="line">            sampler2D _Hatch1;</span><br><span class="line">            sampler2D _Hatch2;</span><br><span class="line">            sampler2D _Hatch3;</span><br><span class="line">            sampler2D _Hatch4;</span><br><span class="line">            sampler2D _Hatch5;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float3 normal : NORMAL; </span><br><span class="line">                float2 texcoord : TEXCOORD0; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                <span class="comment">//因为声明了 6 张纹理，从而需要 6 个混合权重，把其存储在两个 fixed3 类型的变量中</span></span><br><span class="line">                fixed3 hatchWeights0 : TEXCOORD1;</span><br><span class="line">                fixed3 hatchWeights1 : TEXCOORD2;</span><br><span class="line">                float3 worldPos : TEXCOORD3; <span class="comment">//为添加阴影，从而需要声明 worldPos 变量</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>) <span class="comment">//使用 SHADOW_COORDS 宏声明阴影纹理的采样坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord.xy * _TileFactor; <span class="comment">//使用 _TileFactor 得到纹理采样坐标</span></span><br><span class="line">                </span><br><span class="line">                fixed3 worldLightDir = normalize(WorldSpaceLightDir(v.vertex));</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed diff = max(<span class="number">0</span>, dot(worldLightDir, worldNormal)); <span class="comment">//漫反射系数</span></span><br><span class="line"></span><br><span class="line">                o.hatchWeights0 = fixed3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//把权重值初始化定位0</span></span><br><span class="line">                o.hatchWeights1 = fixed3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把 diff 缩放到 [0,7] 得到 hatchFactor，通过 hatchFactor 来计算其所处的自区间来计算对应的纹理混合权重</span></span><br><span class="line">                <span class="type">float</span> hatchFactor = diff * <span class="number">7.0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (hatchFactor &gt; <span class="number">6.0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Pure white, do nothing</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">5.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor - <span class="number">5.0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">4.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor - <span class="number">4.0</span>;</span><br><span class="line">                    o.hatchWeights0.y = <span class="number">1.0</span> - o.hatchWeights0.x;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">3.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.y = hatchFactor - <span class="number">3.0</span>;</span><br><span class="line">                    o.hatchWeights0.z = <span class="number">1.0</span> - o.hatchWeights0.y;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">2.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.z = hatchFactor - <span class="number">2.0</span>;</span><br><span class="line">                    o.hatchWeights1.x = <span class="number">1.0</span> - o.hatchWeights0.z;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights1.x = hatchFactor - <span class="number">1.0</span>;</span><br><span class="line">                    o.hatchWeights1.y = <span class="number">1.0</span> - o.hatchWeights1.x;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    o.hatchWeights1.y = hatchFactor;</span><br><span class="line">                    o.hatchWeights1.z = <span class="number">1.0</span> - o.hatchWeights1.y;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                TRANSFER_SHADOW(o); <span class="comment">//计算阴影纹理的采样坐标</span></span><br><span class="line">                <span class="keyword">return</span> o; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                <span class="comment">//混合权重，对每张纹理进行采样，并和他们对应的权重值相乘得到每张纹理的采样颜色</span></span><br><span class="line">                fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x;</span><br><span class="line">                fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y;</span><br><span class="line">                fixed4 hatchTex2 = tex2D(_Hatch2, i.uv) * i.hatchWeights0.z;</span><br><span class="line">                fixed4 hatchTex3 = tex2D(_Hatch3, i.uv) * i.hatchWeights1.x;</span><br><span class="line">                fixed4 hatchTex4 = tex2D(_Hatch4, i.uv) * i.hatchWeights1.y;</span><br><span class="line">                fixed4 hatchTex5 = tex2D(_Hatch5, i.uv) * i.hatchWeights1.z;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算纯白在渲染中的贡献度，主要是为了光照最亮的部分是纯白色，即素描的留白部分</span></span><br><span class="line">                fixed4 whiteColor = fixed4(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * (<span class="number">1</span> - i.hatchWeights0.x - i.hatchWeights0.y - i.hatchWeights0.z - i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z);</span><br><span class="line">                </span><br><span class="line">                fixed4 hatchColor = hatchTex0 + hatchTex1 + hatchTex2 + hatchTex3 + hatchTex4 + hatchTex5 + whiteColor;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); <span class="comment">//得到阴影值</span></span><br><span class="line">                                </span><br><span class="line">                <span class="keyword">return</span> fixed4(hatchColor.rgb * _Color.rgb * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/28/PRnjh2JEz5oZC3A.jpg" width = "70%" height = "70%" alt="图78- 素描风格的渲染效果"/>
</div>


<h1 id="第十四章-使用噪声"><a href="#第十四章-使用噪声" class="headerlink" title="第十四章 使用噪声"></a>第十四章 使用噪声</h1><h2 id="消融效果"><a href="#消融效果" class="headerlink" title="消融效果"></a>消融效果</h2><p><strong>消融 dissolve</strong> 效果常见于游戏中的角色死亡、地图烧毁等效果。在这些效果中，消融往往从不同的区域开始，并向看似随机的方向扩张，最后整个物体都将消失不见。在本节中，我们将在 Unity 中实现这种效果。</p>
<p>消融效果的原理：概括来说就是噪声纹理+透明度测试。我们使用噪声纹理采样的结果和某个控制消融程度的阈值比较，如果小于阈值，就使用 clip 函数把它对应的像素裁剪掉，这些部分就对应了被“烧毁”的区域。而镂空区域边缘的烧焦效果则是将两种颜色混合，再用 pow 函数处理后，与原纹理颜色混合后的的结果。</p>
<p>准备工作如下：<br>①新建名为 Scene_15_1 的场景，并去掉天空盒；<br>②往场景中放置一个立方体；<br>③新建名为 DissolveMat 的材质，并赋给上一步创建的立方体；<br>④新建名为 Chapter15-Dissolve 的 Unity Shader，并赋给上一步创建的材质。</p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 15/Dissolve&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _BurnAmount (<span class="string">&quot;Burn Amount&quot;</span>, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.0</span> <span class="comment">//控制燃烧的效果</span></span><br><span class="line">        _LineWidth(<span class="string">&quot;Burn Line Width&quot;</span>, Range(<span class="number">0.0</span>, <span class="number">0.2</span>)) = <span class="number">0.1</span> <span class="comment">//控制燃烧烧焦效果时的线宽</span></span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _BumpMap (<span class="string">&quot;Normal Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">        _BurnFirstColor(<span class="string">&quot;Burn First Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">//燃烧边界的第一种颜色</span></span><br><span class="line">        _BurnSecondColor(<span class="string">&quot;Burn Second Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">//燃烧边界的渐变的第二种颜色</span></span><br><span class="line">        _BurnMap(<span class="string">&quot;Burn Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125; <span class="comment">//对应的噪声纹理</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            Cull Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            fixed _BurnAmount;</span><br><span class="line">            fixed _LineWidth;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            fixed4 _BurnFirstColor;</span><br><span class="line">            fixed4 _BurnSecondColor;</span><br><span class="line">            sampler2D _BurnMap;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            float4 _BurnMap_ST;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uvMainTex : TEXCOORD0;</span><br><span class="line">                float2 uvBumpMap : TEXCOORD1;</span><br><span class="line">                float2 uvBurnMap : TEXCOORD2;</span><br><span class="line">                float3 lightDir : TEXCOORD3;</span><br><span class="line">                float3 worldPos : TEXCOORD4;</span><br><span class="line">                SHADOW_COORDS(<span class="number">5</span>) <span class="comment">//阴影纹理</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line">                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把光源信息从模型空间变换到切线空间</span></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                  </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                TRANSFER_SHADOW(o); <span class="comment">//得到阴影信息</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将采样结果和用于控制消融效果的属性 _BurnAmount 相减并传递给 clip 函数，如果结果小于 0 则该像素将会被剔除，从而不会显示到屏幕上，而如果通过了测试，则将进行正常的光照效果</span></span><br><span class="line">                clip(burn.r - _BurnAmount);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果通过了测试，则进行正常的光照计算</span></span><br><span class="line">                float3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));</span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="number">0</span>, dot(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算燃烧颜色 burncolor，在 _LineWidth 范围内模拟烧焦的颜色变化，使用 smoothstep 函数计算混合系数 t，当 t 为 1 时，表明该像素位于消融的边界，当 t 为 0 时，表明该像素为正常的模型颜色</span></span><br><span class="line">                fixed t = <span class="number">1</span> - smoothstep(<span class="number">0.0</span>, _LineWidth, burn.r - _BurnAmount);</span><br><span class="line">                fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t); <span class="comment">//混合两种火焰颜色</span></span><br><span class="line">                burnColor = <span class="built_in">pow</span>(burnColor, <span class="number">5</span>); <span class="comment">//pow 让其更加接近烧焦效果</span></span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);        </span><br><span class="line">                fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(<span class="number">0.0001</span>, _BurnAmount)); <span class="comment">//使用 t 来混合正常的光照颜色（环境光+漫反射）和烧焦颜色，而 step 是保证 _BurnAmount 为 0 时不显示任何消融效果</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义投射阴影的 pass，让阴影能够配合透明度测试产生正确的效果</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ShadowCaster&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_shadowcaster</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            fixed _BurnAmount;</span><br><span class="line">            sampler2D _BurnMap;</span><br><span class="line">            float4 _BurnMap_ST;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                V2F_SHADOW_CASTER; <span class="comment">//得到定义阴影投射所需要定义的变量</span></span><br><span class="line">                float2 uvBurnMap : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(appdata_base v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) <span class="comment">//该宏用于填充 V2F_SHADOW_CASTER 背后声明的一些变量</span></span><br><span class="line">                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">                clip(burn.r - _BurnAmount); <span class="comment">//利用噪声纹理的采样结果 uvBurnMap 来剔除片元</span></span><br><span class="line">                SHADOW_CASTER_FRAGMENT(i) <span class="comment">//完成阴影投射部分，把结果输出到深度图和阴影映射纹理中</span></span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将噪声纹理拖拽到材质的 Burn Map 属性上，再调整材质的 Burn Amount 属性，就可以看到消融的效果了。可以自己实现一个辅助脚本用于控制材质的 Burn Amount 属性，或者使用 Shader 动画来实现动画效果。效果如下：  </p>
<table><tr>
<td><img src='https://s2.loli.net/2023/12/29/i8PvuV4ZhpKW2EX.jpg' width="330" alt="图79- 消融效果使用的噪声纹理"></td>
<td><img src='https://s2.loli.net/2023/12/29/DPnZNSjpFLer56R.gif' width="600" alt="图80- 箱子的消融效果"></td>
</tr></table>

<h2 id="水波效果"><a href="#水波效果" class="headerlink" title="水波效果"></a>水波效果</h2><p>在模拟水面的过程中，我们往往也会使用噪声纹理。此时，噪声纹理通常会用作一个高度图，以不断修改水面的法线方向。为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，再进行正常的反射 + 折射计算，得到最后的水面波动效果。</p>
<p>本节中，我们将使用一个由噪声纹理得到的法线贴图，实现一个包含菲涅尔反射的水面效果。和第 9 章实现的透明玻璃类似。首先使用一张立方体纹理 Cubemap 作为环境纹理，模拟反射。为了模拟折射效果，我们使用 GrabPass 来获取当前屏幕的渲染纹理，并使用切线空间下的法线方向对像素的屏幕坐标进行偏移，再使用该坐标对渲染纹理进行屏幕采样，从而模拟近似的折射效果。</p>
<p>和之前不同，水波的法线纹理是由一张噪声纹理生成而得。除此之外，我们没有使用一个定值来混合反射和折射颜色，而是使用之前菲涅尔系数来动态决定混合系数。我们使用的公式计算菲涅尔系数：  </p>
<script type="math/tex; mode=display">fresnel = pow(1 - max(0, v \cdot n),4)</script><p>其中，v 和 n 分别对应了视角方向和法线方向。它们之间的夹角越小，fresnel 值越小，反射越弱，折射越强。菲涅尔系数还经常会用于边缘光照的计算中。</p>
<hr>
<p>准备工作如下：<br>①新建名为 Scene_15_2 的场景，并去掉天空盒；<br>②搭建水波效果的测试场景，构建一个由 6 面墙围成的封闭房间，房间中放置一个平面来模拟水面；<br>③新建名为 WaterWaveMat 的材质，并赋给上一步的平面（水面）；<br>④新建名为 Chapter15-WaterWave 的 Unity Shader，并赋给上一步的材质；<br>⑤使用第 9 章 1.2节中实现的创建立方体纹理的脚本创建一个立方体纹理，用于得到本场景适用的环境纹理。在 Project 创建一张名为 Wave_Cubemap 的立方体纹理（右键 -&gt; Create -&gt; Legacy -&gt; Cubemap）；点击菜单栏 GameObject -&gt; Render into CubeMap。  </p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 15/Water Wave&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Main Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0.15</span>, <span class="number">0.115</span>, <span class="number">1</span>) <span class="comment">//控制水面颜色</span></span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//水面波纹材质纹理</span></span><br><span class="line">        _WaveMap (<span class="string">&quot;Wave Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125; <span class="comment">//由噪声纹理生成的法线纹理</span></span><br><span class="line">        _Cubemap (<span class="string">&quot;Environment Cubemap&quot;</span>, Cube) = <span class="string">&quot;_Skybox&quot;</span> &#123;&#125;</span><br><span class="line">        _WaveXSpeed (<span class="string">&quot;Wave Horizontal Speed&quot;</span>, Range(<span class="number">-0.1</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span> <span class="comment">//法线纹理在 x 方向上的平移速度</span></span><br><span class="line">        _WaveYSpeed (<span class="string">&quot;Wave Vertical Speed&quot;</span>, Range(<span class="number">-0.1</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span> <span class="comment">//法线纹理在 y 方向上的平移速度</span></span><br><span class="line">        _Distortion (<span class="string">&quot;Distortion&quot;</span>, Range(<span class="number">0</span>, <span class="number">100</span>)) = <span class="number">10</span> <span class="comment">//模拟折射时图像的扭曲程度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125; <span class="comment">//Queue 设置成 Transparent 可以确保该物体渲染时，其他所有不透明物体都已经被渲染到屏幕上，否则可能无法正确得到“透过水面看到的图像”；而设置为 RenderType 则是为了在使用着色器替换时，该物体可以在需要时被正确渲染，见第 12 章开头</span></span><br><span class="line">        </span><br><span class="line">        GrabPass &#123; <span class="string">&quot;_RefractionTex&quot;</span> &#125; <span class="comment">//GrabPass 定义了一个抓去屏幕图像的 Pass，在该 Pass 中定义一个字符串，该字符串内部的名称决定了抓去得到的屏幕图像将会被存入哪个纹理中</span></span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125; </span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _WaveMap;</span><br><span class="line">            float4 _WaveMap_ST;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            fixed _WaveXSpeed;</span><br><span class="line">            fixed _WaveYSpeed;</span><br><span class="line">            <span class="type">float</span> _Distortion;    </span><br><span class="line">            sampler2D _RefractionTex;</span><br><span class="line">            float4 _RefractionTex_TexelSize;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 scrPos : TEXCOORD0;</span><br><span class="line">                float4 uv : TEXCOORD1;</span><br><span class="line">                float4 TtoW0 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD4; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.scrPos = ComputeGrabScreenPos(o.pos); <span class="comment">//通过调用 ComputeGrabScreenPos 来得到对应被抓取屏幕图像的采样坐标，它的主要代码和 ComputeScreenPos 类似，最大的不同是针对平台差异问题</span></span><br><span class="line">                </span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex); </span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _WaveMap);</span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line"></span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x); </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y); </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z); </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//通过 _Time.y 变量和 _WaveXSpeed、_WaveYSpeed 计算法线纹理当前偏移量</span></span><br><span class="line">                float2 speed = _Time.y * float2(_WaveXSpeed, _WaveYSpeed);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//利用偏移量对法线纹理进行两次采样从而模拟两层交叉的水面波动的效果</span></span><br><span class="line">                fixed3 bump1 = UnpackNormal(tex2D(_WaveMap, i.uv.zw + speed)).rgb;</span><br><span class="line">                fixed3 bump2 = UnpackNormal(tex2D(_WaveMap, i.uv.zw - speed)).rgb;</span><br><span class="line">                fixed3 bump = normalize(bump1 + bump2); <span class="comment">//两次结果相加并归一化得到切线空间下的法线方向</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//利用 _Distortion 和 _RefractionTex_TexelSize 来对屏幕图像的采样坐标进行偏移，模拟折射效果，offset 越大，水面扭曲程度越大</span></span><br><span class="line">                float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//选择切线空间下的法线方向来进行偏移，因为该空间下的法线可以反应顶点局部空间下的法线方向，在计算偏移后的屏幕坐标，需要把偏移量和屏幕坐标的 z 分量相乘，从而模拟深度变大、折射程度越大的效果</span></span><br><span class="line">                i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//对 scrPos 进行透视除法，再使用该坐标对抓取的屏幕图像 _RefractionTex 进行采样</span></span><br><span class="line">                fixed3 refrCol = tex2D( _RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//把法线方向从切线空间变换到世界空间下</span></span><br><span class="line">                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));</span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv.xy + speed);</span><br><span class="line">                fixed3 reflDir = reflect(-viewDir, bump); <span class="comment">//根据视角方向和法线方向得到反射方向</span></span><br><span class="line">                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb * _Color.rgb; <span class="comment">//使用Cubemap进行采样并把结果和主纹理颜色相乘后得到反射颜色</span></span><br><span class="line">                </span><br><span class="line">                fixed fresnel = <span class="built_in">pow</span>(<span class="number">1</span> - saturate(dot(viewDir, bump)), <span class="number">4</span>); <span class="comment">//计算菲涅尔系数</span></span><br><span class="line">                fixed3 finalColor = reflCol * fresnel + refrCol * (<span class="number">1</span> - fresnel); <span class="comment">//混合折射和反射颜色，并作为最终的输出颜色</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do not cast shadow</span></span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>水面使用的噪声纹理是本书资源的 Water_Noise.png，只不过我们需要的是法线纹理，可以通过在它的纹理面板把纹理类型设置为 Normal Map，同时选中 Create from grayscale 来把灰度图生成法线纹理。将生成的法线纹理拖拽到 Wave Map 上，效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/29/SJ8wQrMc2nfT5Zp.gif" width = "70%" height = "70%" alt="图81- 包含菲涅耳反射的水面波动效果。视角方向和水面法线的夹角越大，反射效果越强"/>
</div>

<h2 id="再谈全局雾效"><a href="#再谈全局雾效" class="headerlink" title="再谈全局雾效"></a>再谈全局雾效</h2><p>第十二章讲过如何使用深度纹理来实现一种基于屏幕后处理的全局雾效，效果是基于高度的均匀雾效，即在同一个高度上，雾的浓度是相同的。然而一些时候我们希望可以模拟一种不均匀的雾效，同时让雾不断飘动，使雾看起来更飘渺。而这就可以通过一张噪声纹理来实现。</p>
<p>本节的实现大部分和第十二章完全一样，只是增加了噪声相关参数和属性，准备工作如下：<br>①新建名为 Scene_15_3 的场景，并去掉天空盒；<br>②搭建雾效测试场景，3 面墙的房间，放置几个立方体；<br>③新建名为 FogWithNoise 的 C# 脚本，并拖拽给场景中的相机；<br>④新建名为 Chapter15-FogWithNoise 的 Unity Shader。</p>
<p>FogWithNoise.cs 的 C# 脚本代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FogWithNoise</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shader fogShader;</span><br><span class="line">    <span class="keyword">private</span> Material fogMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);</span><br><span class="line">            <span class="keyword">return</span> fogMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform myCameraTransform;</span><br><span class="line">    <span class="keyword">public</span> Transform cameraTransform &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCameraTransform == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCameraTransform = camera.transform;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCameraTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.1f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogDensity = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Color fogColor = Color.white;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogStart = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogEnd = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Texture noiseTexture;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(-0.5f, 0.5f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogXSpeed = <span class="number">0.1f</span>;</span><br><span class="line">    [<span class="meta">Range(-0.5f, 0.5f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogYSpeed = <span class="number">0.1f</span>;</span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> noiseAmount = <span class="number">1.0f</span>; <span class="comment">//控制噪声的程度，当 noiseAmount 为 0 时，得到一个均匀的雾效</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//下面计算原理详见 12.3 章节</span></span><br><span class="line">            Matrix4x4 frustumCorners = Matrix4x4.identity;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">            <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">            <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">            Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">            Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line">            </span><br><span class="line">            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">            <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line">            </span><br><span class="line">            topLeft.Normalize();</span><br><span class="line">            topLeft *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">            topRight.Normalize();</span><br><span class="line">            topRight *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">            bottomLeft.Normalize();</span><br><span class="line">            bottomLeft *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">            bottomRight.Normalize();</span><br><span class="line">            bottomRight *= scale;</span><br><span class="line">            </span><br><span class="line">            frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line">            </span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line"></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">            material.SetTexture(<span class="string">&quot;_NoiseTex&quot;</span>, noiseTexture);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogXSpeed&quot;</span>, fogXSpeed);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogYSpeed&quot;</span>, fogYSpeed);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_NoiseAmount&quot;</span>, noiseAmount);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Chapter15-FogWithNoise 的  Shader 代码如下：  </p>
<figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 15/Fog With Noise&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">    <span class="comment">//声明属性</span></span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _FogDensity (<span class="string">&quot;Fog Density&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _FogColor (<span class="string">&quot;Fog Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _FogStart (<span class="string">&quot;Fog Start&quot;</span>, Float) = <span class="number">0.0</span></span><br><span class="line">        _FogEnd (<span class="string">&quot;Fog End&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _NoiseTex (<span class="string">&quot;Noise Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _FogXSpeed (<span class="string">&quot;Fog Horizontal Speed&quot;</span>, Float) = <span class="number">0.1</span></span><br><span class="line">        _FogYSpeed (<span class="string">&quot;Fog Vertical Speed&quot;</span>, Float) = <span class="number">0.1</span></span><br><span class="line">        _NoiseAmount (<span class="string">&quot;Noise Amount&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        float4x4 _FrustumCornersRay; <span class="comment">//Unity 没有提供矩阵的属性，所以没在 Properties 中声明</span></span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        sampler2D _CameraDepthTexture;</span><br><span class="line">        half _FogDensity;</span><br><span class="line">        fixed4 _FogColor;</span><br><span class="line">        <span class="type">float</span> _FogStart;</span><br><span class="line">        <span class="type">float</span> _FogEnd;</span><br><span class="line">        sampler2D _NoiseTex;</span><br><span class="line">        half _FogXSpeed;</span><br><span class="line">        half _FogYSpeed;</span><br><span class="line">        half _NoiseAmount;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            float2 uv : TEXCOORD0;</span><br><span class="line">            float2 uv_depth : TEXCOORD1;</span><br><span class="line">            float4 interpolatedRay : TEXCOORD2;        </span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP <span class="comment">//适配不同平台</span></span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (v.texcoord.x &lt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                index = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                index = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                index = <span class="number">3</span> - index;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            </span><br><span class="line">            o.interpolatedRay = _FrustumCornersRay[index];</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth)); <span class="comment">//根据深度纹理构建该像素在世界空间中的位置</span></span><br><span class="line">            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;    </span><br><span class="line">            </span><br><span class="line">            float2 speed = _Time.y * float2(_FogXSpeed, _FogYSpeed); <span class="comment">//计算雾的偏移量</span></span><br><span class="line">            <span class="type">float</span> noise = (tex2D(_NoiseTex, i.uv + speed).r - <span class="number">0.5</span>) * _NoiseAmount; <span class="comment">//对噪声纹理进行采样从而得到噪声值</span></span><br><span class="line">                    </span><br><span class="line">            <span class="type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart);         </span><br><span class="line">            fogDensity = saturate(fogDensity * _FogDensity * (<span class="number">1</span> + noise)); <span class="comment">//计算雾效混合系数</span></span><br><span class="line">            </span><br><span class="line">            fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line">            <span class="keyword">return</span> finalColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;              </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 Chapter15-FogWithNoise 拖拽到摄像机的脚本中的 Fog Shader 属性中，效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2023/12/30/YK8PdcguWLUmRfQ.gif" width = "70%" height = "70%" alt="图82- ：使用噪声纹理后的非均匀雾效"/>
</div>

<h2 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>噪声纹理由计算机利用某些算法生成的，可以被认为是一种程序纹理 Procedure Texture。Perlin 纹理、Worley 纹理是比较常使用的噪声纹理类型。Perlin 噪声可以用于生成更自然的噪声纹理；Worley 噪声则通常用于模拟诸如石头、水、纸张等多孔噪声。有兴趣自行查阅资料。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io">鸟布</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io/2023/12/19/2023-12-19-UnityShader4/">https://ybniaobu.github.io/2023/12/19/2023-12-19-UnityShader4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ybniaobu.github.io" target="_blank">鸟布的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/unity/">unity</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/12/20/9Ah5ugiIpONK1cX.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src="/images/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/30/2023-12-30-UnityShader5/" title="《Unity Shader入门精要》读书笔记（五）"><img class="cover" src="https://s2.loli.net/2023/12/30/hc2s7BS45l1wUdQ.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《Unity Shader入门精要》读书笔记（五）</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/22/2023-11-22-UnityShader3/" title="《Unity Shader入门精要》读书笔记（三）"><img class="cover" src="https://s2.loli.net/2023/11/23/L3ts4WnThMlDN9d.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《Unity Shader入门精要》读书笔记（三）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/15/2023-09-15-UnityShader1/" title="《Unity Shader入门精要》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2023/09/19/cDvdURBPhjwkOsY.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-15</div><div class="title">《Unity Shader入门精要》读书笔记（一）</div></div></a></div><div><a href="/2023/10/13/2023-10-13-UnityShader2/" title="《Unity Shader入门精要》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2023/10/15/RZftaNSscWoLH1u.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-13</div><div class="title">《Unity Shader入门精要》读书笔记（二）</div></div></a></div><div><a href="/2023/12/30/2023-12-30-UnityShader5/" title="《Unity Shader入门精要》读书笔记（五）"><img class="cover" src="https://s2.loli.net/2023/12/30/hc2s7BS45l1wUdQ.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-30</div><div class="title">《Unity Shader入门精要》读书笔记（五）</div></div></a></div><div><a href="/2023/11/22/2023-11-22-UnityShader3/" title="《Unity Shader入门精要》读书笔记（三）"><img class="cover" src="https://s2.loli.net/2023/11/23/L3ts4WnThMlDN9d.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-22</div><div class="title">《Unity Shader入门精要》读书笔记（三）</div></div></a></div><div><a href="/2024/02/23/2024-02-23-URP%E5%9F%BA%E7%A1%80/" title="Unity URP 基础"><img class="cover" src="https://s2.loli.net/2024/02/18/pMAzYioaFZEkS8I.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-23</div><div class="title">Unity URP 基础</div></div></a></div><div><a href="/2024/03/20/2024-03-20-NPR_StarRail1/" title="基于星穹铁道的卡通渲染（一）"><img class="cover" src="https://s2.loli.net/2024/03/26/dZTwsApi59CSUal.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="title">基于星穹铁道的卡通渲染（一）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/wechat%20avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鸟布</div><div class="author-info__description">教练，我想学技术</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://niaobu.notion.site/787824630ea6480e944c1ae5ae7f4792"><i class="fa-solid fa-book"></i><span>My Notion</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ybniaobu/ybniaobu.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:niaobubob@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为了蒂法！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C"><span class="toc-number">1.</span> <span class="toc-text">第十一章 屏幕后处理效果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.</span> <span class="toc-text">建立一个基本的屏幕后处理脚本系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E5%B1%8F%E5%B9%95%E7%9A%84%E4%BA%AE%E5%BA%A6%E3%80%81%E9%A5%B1%E5%92%8C%E5%BA%A6%E5%92%8C%E5%AF%B9%E6%AF%94%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">调整屏幕的亮度、饱和度和对比度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-number">1.3.</span> <span class="toc-text">边缘检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%B7%E7%A7%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">什么是卷积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E5%AD%90"><span class="toc-number">1.3.2.</span> <span class="toc-text">常见的边缘检测算子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A"><span class="toc-number">1.4.</span> <span class="toc-text">高斯模糊</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.4.1.</span> <span class="toc-text">高斯滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bloom-%E6%95%88%E6%9E%9C"><span class="toc-number">1.5.</span> <span class="toc-text">Bloom 效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A"><span class="toc-number">1.6.</span> <span class="toc-text">运动模糊</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">第十二章 使用深度和法线纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">获取深度和法线纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.1.</span> <span class="toc-text">背后的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96"><span class="toc-number">2.1.2.</span> <span class="toc-text">如何获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-number">2.1.3.</span> <span class="toc-text">查看深度和法线纹理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A"><span class="toc-number">2.2.</span> <span class="toc-text">再谈运动模糊</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%9B%BE%E6%95%88"><span class="toc-number">2.3.</span> <span class="toc-text">全局雾效</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%BB%BA%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87"><span class="toc-number">2.3.1.</span> <span class="toc-text">重建世界坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%BE%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">2.3.2.</span> <span class="toc-text">雾的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">2.3.3.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-number">2.4.</span> <span class="toc-text">再谈边缘检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">2.5.</span> <span class="toc-text">扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93"><span class="toc-number">3.</span> <span class="toc-text">第十三章 非真实感渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%A1%E9%80%9A%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="toc-number">3.1.</span> <span class="toc-text">卡通风格的渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E8%BD%AE%E5%BB%93%E7%BA%BF"><span class="toc-number">3.1.1.</span> <span class="toc-text">渲染轮廓线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E9%AB%98%E5%85%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">添加高光</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">3.1.3.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A0%E6%8F%8F%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="toc-number">3.2.</span> <span class="toc-text">素描风格的渲染</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%99%AA%E5%A3%B0"><span class="toc-number">4.</span> <span class="toc-text">第十四章 使用噪声</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E8%9E%8D%E6%95%88%E6%9E%9C"><span class="toc-number">4.1.</span> <span class="toc-text">消融效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B0%B4%E6%B3%A2%E6%95%88%E6%9E%9C"><span class="toc-number">4.2.</span> <span class="toc-text">水波效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%85%A8%E5%B1%80%E9%9B%BE%E6%95%88"><span class="toc-number">4.3.</span> <span class="toc-text">再谈全局雾效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-1"><span class="toc-number">4.4.</span> <span class="toc-text">扩展阅读</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/09/2024-12-09-CustomSRP2/" title="Unity Custom SRP 基础（二）"><img src="https://s2.loli.net/2024/12/09/paBhbkD6Vd9CIsy.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（二）"/></a><div class="content"><a class="title" href="/2024/12/09/2024-12-09-CustomSRP2/" title="Unity Custom SRP 基础（二）">Unity Custom SRP 基础（二）</a><time datetime="2024-12-09T08:00:29.000Z" title="发表于 2024-12-09 16:00:29">2024-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/26/2024-11-26-CustomSRP1/" title="Unity Custom SRP 基础（一）"><img src="https://s2.loli.net/2024/12/09/SGVnTxOM6BURAJI.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（一）"/></a><div class="content"><a class="title" href="/2024/11/26/2024-11-26-CustomSRP1/" title="Unity Custom SRP 基础（一）">Unity Custom SRP 基础（一）</a><time datetime="2024-11-26T04:43:30.000Z" title="发表于 2024-11-26 12:43:30">2024-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/2024-10-22-BetterPBR1/" title="Custom Better PBR in Unity"><img src="https://s2.loli.net/2024/10/22/x6Xp3JjS4k5PO2W.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Custom Better PBR in Unity"/></a><div class="content"><a class="title" href="/2024/10/22/2024-10-22-BetterPBR1/" title="Custom Better PBR in Unity">Custom Better PBR in Unity</a><time datetime="2024-10-22T03:13:12.000Z" title="发表于 2024-10-22 11:13:12">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/16/2024-08-16-IBL_Basics2/" title="IBL 基于图像的光照（二）"><img src="https://s2.loli.net/2024/08/16/KQGyA6zfCW74dYw.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IBL 基于图像的光照（二）"/></a><div class="content"><a class="title" href="/2024/08/16/2024-08-16-IBL_Basics2/" title="IBL 基于图像的光照（二）">IBL 基于图像的光照（二）</a><time datetime="2024-08-16T04:43:39.000Z" title="发表于 2024-08-16 12:43:39">2024-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/09/2024-07-09-IBL_Basics1/" title="IBL 基于图像的光照（一）"><img src="https://s2.loli.net/2024/07/22/nD1y67NcRpQOHbS.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IBL 基于图像的光照（一）"/></a><div class="content"><a class="title" href="/2024/07/09/2024-07-09-IBL_Basics1/" title="IBL 基于图像的光照（一）">IBL 基于图像的光照（一）</a><time datetime="2024-07-09T07:25:54.000Z" title="发表于 2024-07-09 15:25:54">2024-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 鸟布</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Your time is limited, so don't waste it living someone else's life.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>