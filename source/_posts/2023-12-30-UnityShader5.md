---
title: 《Unity Shader入门精要》读书笔记（五）
date: 2023-12-30 16:05:42
categories: 
  - [unity, unity shader]
tags:
  - 游戏开发
  - unity
  - 图形学
top_img: /images/black.jpg
cover: https://s2.loli.net/2023/12/30/hc2s7BS45l1wUdQ.gif
mathjax: true
---

> 本读书笔记为高级篇的最后一章和扩展篇，主要内容为XXXXXXXXXXXXXXXXXXXXXXXXX。
> 读书笔记是对知识的记录与总结，但是对比较熟悉的内容不会再行描述。

# 第十五章 Unity 中的渲染优化技术
在本章中，将会阐述一些 Unity 常见的优化技术。这些优化技术都是和渲染有关的，例如：使用批处理、LOD 技术（Level of Detail）等。

## 移动平台的特点
和 PC 平台相比，移动平台上的 GPU 架构有很大的不同。由于处理资源等条件的限制，移动设备上的 GPU 架构专注于尽可能使用更小的带宽和功能，也由此带来许多和 PC 不同的现象。

例如，为了尽可能移除一些隐藏的表面，减少 overdraw（同一像素绘制多次），PowerVR 芯片（用于 iOS 设备和一些 Android 设备）使用**基于瓦片的延迟渲染 Tiled-based Deferred Rendering, TBDR** 架构，把所有渲染图像装入一个个瓦片中，由硬件找到可见的片元，并只对它们执行片元着色器；另一些基于瓦片的 GPU 架构，如：Adreno（高通的芯片）和 Mali（ARM 的芯片），则会使用 Early-Z 或相似的技术进行低精度的深度检测，剔除不需要渲染的片元。还有一些 GPU，如 Tegra（英伟达的芯片），则使用了传统的架构设计，因此在这些设备上，overdraw 更可能造成性能的瓶颈。

由于这些芯片架构造成的不同，一些游戏往往需要针对不同的芯片发布不同的版本，以便对每个芯片进行更有针对性的优化。

## 影响性能的因素
游戏主要使用两种计算资源：GPU 和 CPU。CPU 主要负责保证帧率，GPU 主要负责分辨率相关。把造成游戏性能瓶颈的主要原因分成以下几方面：  
①CPU：  
&emsp;&emsp; - 过多的 drawcall，每次调用 Draw Call，CPU 往往需要改变很多渲染状态的设置，这些操作非常耗时，若大部分时间花费在提交 Draw Call 的准备工作上，会导致性能下降；  
&emsp;&emsp; - 复杂的脚本或者模拟（物理、布料、蒙皮、粒子等）。  
②GPU  
&emsp;&emsp; - 过多的顶点或过多的逐顶点计算；  
&emsp;&emsp; - 过多的片元（可能是由于分辨率造成，也有可能是 overdraw）或过多的逐片元计算。  
③带宽  
&emsp;&emsp; - 使用了尺寸很大且未压缩的纹理；  
&emsp;&emsp; - 分辨率过高的帧缓存。

--- 

在了解上面的基本内容后，本章后续涉及的优化技术有：  
①CPU 优化：  
&emsp;&emsp; - 使用批处理技术减少 Draw Call 数目；  
②GPU 优化：  
减少需要处理的顶点数目：  
&emsp;&emsp; - 优化几何体；  
&emsp;&emsp; - 使用模型的 LOD（Level of Detail）技术；  
&emsp;&emsp; - 使用遮挡剔除 Occlusion Culling 技术；  
减少需要处理的片元数目：  
&emsp;&emsp; - 控制绘制顺序；  
&emsp;&emsp; - 警惕透明物体；  
&emsp;&emsp; - 减少实时光照；  
减少计算复杂度：  
&emsp;&emsp; - 使用 Shader 的 LOD（Level of Detail）技术；  
&emsp;&emsp; - 代码方面的优化；  
③节省内存带宽：  
&emsp;&emsp; - 减少纹理大小；  
&emsp;&emsp; - 利用分辨率缩放。

## Unity 中的渲染分析工具
Unity 内置了一些工具，用来查看和渲染相关的统计数据，包括渲染统计窗口 Rendering Statistics Window、性能分析器 Profiler，以及帧调试器 Frame Debugger。

### 渲染统计窗口
就是 Game 窗口的 Stats 按钮。图片不放出了，主要包括 3 个方面的信息：音频 Audio、图像 Graphics 和网络 Network。而图像相关的渲染统计结果包含了很多重要的渲染数据，如下表：  

| 信息名称 | 描述 |
| :---- | :---- |
| 每帧的时间和 FPS | Frame per Second，后面的括号中显示的是当前帧的耗时 |
| CPU：main / render thread | main 是主线程的耗时，render thread 是渲染线程的耗时 |
| Batches | 当前帧需要进行的批处理数目 |
| Saved by batching | 合并的批处理数目，这个数字表明了批处理为我们节省了多少 draw call |
| Tris / Vertes | 当前帧绘制的三角面片和顶点的数目 |
| Screen | 屏幕的大小，及它占用的内存大小 |
| SetPass calls | 渲染使用的 Pass 的数目，每个 Pass 都需要 Unity 的 runtime 来绑定一个新的 Shader。数目越大，越容易产生 CPU 的性能瓶颈 |
| Shadow casters | 当前帧投射阴影的物体数目 |
| Visible skinned meshes | 渲染的蒙皮网格数目 |
| Animation / Animator components playing | 当前帧播放的 Animation / Animator 数目 |


### 性能分析器
Window -> Analysis -> Profiler 打开性能分析器 Profiler 。这里图片也不放了。性能分析器中的渲染模块 Rendering 提供了更多关于渲染的统计信息，比如，draw call 数目、动态批处理/静态批处理的数目、渲染纹理的数目和内存占用等。

使用 Unity 性能分析器可以通过三种主要方式记录数据：  
①在目标平台上的播放器中对应用程序进行性能分析；  
②在 Unity 编辑器中以运行模式对应用程序进行性能分析；  
③对 Unity 编辑器进行性能分析。

获得有关应用程序性能的最佳方法是在打算发布它的终端平台上对它进行性能分析。详见官方文档：https://docs.unity3d.com/2022.3/Documentation/Manual/profiler-profiling-applications.html

### 帧调试器
Window -> Analysis -> Frame Debugger 打开帧调试器面板。在该窗口中可以看到每一个 draw call 的工作和结果。之前讲过，不再重复摘抄了。需要详细信息见官方文档：https://docs.unity3d.com/2022.3/Documentation/Manual/frame-debugger-window.html

### 其他性能分析工具
①对 Android 平台来说：  
&emsp;&emsp; - 高通的 Adreno 分析工具可以对不同的测试机进行详细的性能分析。  
&emsp;&emsp; - 英伟达的 NVPerfHUD 工具可以帮助我们得到几乎所有需要的性能分析数据，如：每个 Draw Call 的 GPU 时间、每个 Shader 花费的 cycle 数目等。  
②对 iOS 平台来说：  
&emsp;&emsp; - PowerVRAM 的 PVRUniSCo Shader 分析器可以给出大致的性能评估。
&emsp;&emsp; - XCode 的 OpenGL ES Driver Instruments 可以给出一些宏观上的性能信息，如：设备利用率、渲染器利用率等。

相比 Android，对 iOS 的性能分析更加困难（工具较少）。且 PowerVR 芯片采用了基于瓦片的延迟渲染器，想得到每个 Draw Call 花费的 GPU 时间几乎不可能，所以一些宏观上的统计数据更有参考价值。

## 减少 draw call 数目
最常见的优化技术大概就是**批处理 batching**了。批处理的实现原理就是为了减少每一帧需要的 draw call 的数量。为了把一个对象渲染到屏幕上，CPU 需要检查哪些光源影响了该物体，绑定 shader 并设置它的参数，再把渲染命令发送给 GPU。当场景中包含了大量对象时，这些操作会非常耗时。批处理就是在每次调用 draw call 时尽可能的处理多个物体。

什么样的物体可以进行一起批处理：即使用相同材质的物体。因为它们之间的不同仅仅在于顶点数据的差别，可以把这些顶点数据合并在一起发送给 GPU，就可以完成一次批处理。

Unity 支持两种批处理方式：  
①**动态批处理**：有点在于一切都是Unity自动完成，无需自己做任何操作，物体可移动。缺点是限制太多，一不小心就破坏这种机制，导致无法动态批处理一些使用了相同材质的物体；  
②**静态批处理**：自由度高，限制少。但是占用更多内存，而且经过静态批处理后的物体不能再移动（即使脚本中尝试改变物体的位置也是无效的）。

### 动态批处理
如果场景中有一些模型共享了同一材质并满足了一些条件，Unity 就自动把它们进行批处理，从而只需要花费一个 draw call 就可以渲染所有模型。动态批处理的基本原理就是每一帧把可以进行批处理的模型网格进行合并，再把合并后模型数据传递给 GPU，然后使用同一个材质对其渲染。除了实现方便，动态批处理的另一个好处是，经过批处理的物体仍然可以移动，这是因为由于在处理每帧时 Unity 都会重新合并一次网格。

模型网格批处理合并的主要的条件限制（随着 Unity 版本变化，条件可能会改变）：  
①网格的顶点属性规模要小于 900。例如，如果 Shader 中需要使用顶点位置、法线、纹理坐标这 3 个顶点属性，想要让模型被动态批处理，他们的顶点数目不能超过 300；  
②一般来说，所有对象都需要使用同一个缩放尺度。一个例外情况是，如果所有物体都使用了不同的非统一缩放，那么也是可以被动态批处理的。但在 Unity 5 中，这种对模型缩放的限制不存在了；  
③使用光照纹理 lightmap 的物体需要额外的渲染参数，例如，在光照纹理上的索引、偏移量和缩放信息等。为了让这些物体可以被动态批处理，需要保证它们指向光照纹理的同一个位置；  
④多 Pass 的 shader 会中断批处理。前向渲染中，有时需要额外的 Pass 来为模型添加更多的光照效果，这样会导致模型无法被完全动态批处理。Unity 只会批处理第一个 Pass，不能为额外的逐像素光源进行批处理。

### 静态批处理
相对于动态批处理来说，静态批处理适合于任何大小的几何模型。其实现原理是，只在运行开始阶段，把需要进行静态批处理的模型合并到一个新的网格结构中，这意味着这些模型不可以在运行时刻被移动。静态批处理的另一个缺点在于，它往往需要占用更多的内存来存储合并后的几何结构。因为，若在静态批处理前一些物体共享了相同的网格，那么在内存中每一个物体都会对应一个该网格的复制品，即一个网格会变成多个网格再发给 GPU。如果这一类使用同一网格的对象很多，那么将会成为一个性能瓶颈。

静态批处理的实现，只需要把物体面板右上角的 **Static** 勾选上即可，实际上只需要在其右边的下拉菜单里勾选 Batching Static 即可。

在内部实现上，Unity 首先把这些静态物体变换到世界空间下，为它们构建成一个更大的顶点和索引缓存。对于使用同一材质的物体，Unity 只需调用一个 Draw Call 就可以绘制全部物体；对于使用不同材质的物体，静态批处理同样可以提升渲染性能，尽管仍然需要调用多个 Draw Call，但静态批处理可以减少这些 Draw Call 之间的状态切换，而这些切换往往是费时的操作。我们可以从 Unity 的分析器中观察在应用静态批处理前后 **VBO total**（**Vertex Buffer Object**，顶点缓冲对象）的变化。VBO 的数目变大，即它需要更多的内存存储合并后的几何结构，即如果一些物体共享了相同的网格，那么在内存中每一个物体都会对应一个该网格的复制品。

若场景中包含了除了平行光以外的其他光源，并且在 shader 中定义了额外的 pass 来处理它们，这些 pass 将不会被批处理，而平行光的 base pass 仍然可以被静态批处理。

### 共享材质
无论是动态批处理还是静态批处理，都要求模型之间共享同一个材质。但不同模型之间总需要有不同的渲染属性，如：不同的纹理、颜色等，这时需要一些策略尽可能地合并材质。

如果两个材质之间只有使用的纹理不同，可以这些纹理合并到一张更大的纹理中，这张更大的纹理被称为一张**图集 atlas**。一旦使用了同一张纹理，就可以使用同一个材质，再使用不同的采样坐标对纹理采样即可。

但除了纹理不同外，不同的物体在材质上还有一些微小的参数变化。但是只要调整了参数，就会影响到所有使用了这个材质的对象。一个常用的解决方案就是使用网格的顶点数据（最常见的就是顶点颜色数据）来存储这些参数。前面说过，经过批处理后的物体会被处理成更大的 VBO 发送给 GPU，VBO 中的数据可以作为输入传递给顶点着色器，因此可以对 VBO 中的数据进行控制，从而达到不同的目的。

如果需要在脚本中访问共享材质，可以使用 `Renderer.sharedMaterial` 来修改共享材质。

### 批处理的注意事项
①尽可能选择静态批处理，要时刻小心对内存的消耗，记住经过静态批处理的物体不可以再被移动；  
②如果无法进行静态批处理而需要动态批处理时，小心各种限制条件；  
③游戏中的小道具，如可以拾取的金币，可以使用动态批处理；  
④对于包含动画的物体，无法全部使用静态批处理，而如果不动的部分可以把这部分标示为 static；  
⑤批处理需要把多个模型变换到 *世界空间* 下合并他们，因此，如果 shader 存在一些在模型空间下的坐标的运算，那么往往会得到错误的结果，可以在这部分的 shader 中使用 **DisableBatching** 标签来强制使用该 shader 的材质不会被批处理；  
⑥对于使用 *半透明材质* 的物体通常需要使用严格的从后往前的绘制顺序来保证透明混合的正确性。对于这些物体，Unity 会首先保证它们的绘制顺序，再尝试对它们进行批处理。即当绘制顺序无法满足时，批处理无法被成功应用。


## 减少需要处理的顶点数目
顶点数目可能会造成 GPU 的性能瓶颈。有 3 个常用的顶点优化策略。

### 优化几何体
优化网格来尽可能减少模型中三角面片的数目或顶点数目。Unity 的渲染统计窗口中可以查看渲染当前帧需要的三角面片数目和顶点数目。需要注意的是：Unity 中显示的顶点数目往往要多于建模软件里显示的顶点数。主要有几个原因：  
①三维软件是以人类的角度理解顶点，而 Unity 是站在 GPU 的角度计算顶点数的；  
②在 GPU 看来，有时候一个顶点需要拆分成多个顶点，其原因主要有两个：一是为了**分离纹理坐标 uv splits**，另一个是为了**产生平滑的边界 smoothing splits**。建模时一个顶点的纹理坐标有多个，例如：一个立方体，它的 6 个面之间虽然使用了一些相同的顶点，但在不同面上，同一个顶点的纹理坐标可能并不相同。而对 GPU 来说，顶点的每个属性和顶点之间必须是一对一的关系，所以必须将这个顶点拆分成多个具有不同纹理坐标的顶点。而平滑边界也是类似，顶点可能会对应多个法线信息或切线信息，这通常是因为我们要决定这个边是**硬边 hard edge** 还是**平滑边 smooth edge**。

使用可以移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离，来尽可能减少顶点数目。

### 模型的 LOD 技术
**LOD，Level of Detail** 技术的原理是，当一个物体离摄像机很远时，模型上的很多细节是无法被察觉到的，因此 LOD 允许当对象逐渐远离摄像机时，减少模型上的面片数量，从而提高性能。  

在 Unity 中，可以使用 LOD Group 组件来为一个物体构建一个 LOD。当需要为一个对象准备多个包含不同细节程度的模型，然后把它们赋给 LOD Group 组件中的不同等级，Unity 会自动判断当前位置上使用哪个等级的模型。

### 遮挡剔除技术
**遮挡剔除 Occlusion Culling** 可以用来消除那些被其他物体遮挡住的物体，这意味着看不见的顶点不会被 GPU 渲染，从而提升性能。

注意，区分遮挡剔除和摄像机的视锥体剔除 Frustum Culling。视锥体剔除只会剔除掉那些不在相机的视野范围内的对象，但不会判断视野中是否有物体被其他物体遮挡。而遮挡剔除会使用一个虚拟的相机来遍历场景，从而构建一个潜在可见的对象集合的层级结构。运行时，每个相机将会使用这个数据来识别哪些物体可见，哪些物体被挡住。

遮挡剔除不仅可以减少处理的顶点数目，还可以减少 overdraw，提高游戏性能。


## 减少需要处理的片元数目
过多的片元是造成 GPU 性能瓶颈的另一原因，其优化的重点在于减少 **Overdraw**，Overdraw 指的是同一个像素被绘制了多次。

Unity 提供了查看 overdraw 的视图，在 Scene 视图的 2D 按钮前一个 Shading Mode 的球体按钮下拉菜单里可以选择 Overdraw。实际上，这里的视图只是提供了查看物体互相遮挡的层数，并不是真正绘制屏幕的最终 overdraw。也就是说，它显示的是，没有使用任何深度测试和其他优化策略时的 overdraw。这种视图是通过把所有对象都渲染成一个透明的轮廓，通过查看透明颜色的累计程度来判断物体之间的遮挡。

### 控制绘制顺序
为了最大限度地避免 overdraw，一个重要的优化策略就是控制绘制顺序。由于深度测试的存在，从而如果保证了所有物体都是从前往后进行绘制，从很大程度上减少 overdraw。因为后面绘制的物体无法通过深度测试，从而无法被绘制出来。  

在 Unity 中，渲染队列数目小于 2500（如 “Background”、“Geometry”、“AlphaTest”）的对象都被认为是不透明 opaque 的物体，这些物体总体上是从前到后绘制的。而使用其他队列（如 “Transparent”、“Overlay” 等）的物体，则是从后到前，意味着开发者尽可能把物体的队列设置为不透明物体的渲染队列，而经可能避免使用半透明队列。

而且，我们还可以充分利用渲染队列，比如：  
①在第一人称射击游戏，游戏的主角的 shader 往往比较复杂。但是通常会挡住屏幕的很大一部分区域，因此可以将主角的渲染队列调小，先渲染；  
②对于一些敌方角色，由于它们通常在掩体的后面，所以可以将它们的渲染队列调大，这样先渲染不透明掩体，掩体后面的敌人就不用再被渲染；  
③对于天空盒来说，它几乎覆盖所有的像素，而且它永远会出现在所有物体的后面。将它的队列设置为 “Geometry+1”，就可以保证其最后渲染，减少 Overdraw。

### 时刻警惕透明物体
半透明物体因为没有开启深度写入，需要从后往前进行渲染，这意味着一定会产生 overdraw 现象。

例如，对于 GUI 对象来说，如果大多被设置成了半透明，并且占据比例太多，那么会造成大量 overdraw。因此，场景中若包含了大面积的半透明物体，或者很多层相互覆盖的半透明对象，或者是透明的粒子效果，在移动设备上也会造成大量的 overdraw。

可以尽量减少窗口中的 GUI 所占的面积，如果没办法，可以把 GUI 的绘制和三维场景的绘制交给不同的摄像机，而其中负责三维场景的摄像机的视角范围经历不要与 GUI 的相互重叠。

在移动平台上，透明度测试也会影响游戏性能。透明度测试会使用 discard 或 clip 操作，导致一些硬件的优化策略失效。比如：PowerVR 使用的基于瓦片的延迟渲染技术，为了减少 Overdraw 它会调用片元着色器前就判定哪些瓦片被真正渲染。但由于透明度测试在片元着色器中使用了 discard 函数改变了片元是否会被渲染的结果，因此 GPU 无法使用上述的优化策略，只有执行了所有的片元着色器后，GPU 才知道哪些片元会被真正渲染到屏幕上，这样原先减少的 Overdraw 的优化就都失效了。

### 减少实时光照和阴影
如果场景中包含了过多的点光源，并且使用了多个 Pass 的 Shader，那么很可能会造成性能下降。对于逐像素的点光源，使用了逐像素的 Shader 不仅会提高 draw call，同时会增加 overdraw。这是因为，对于逐像素的光源来说，被这些光源照亮的物体需要被再渲染一次，而且也会中断批处理。

模拟光源的方法有：  
①使用烘焙技术，把光照提前烘焙到一张**光照纹理 lightmap** 中，在运行时对纹理进行采样即可。  
②使用 **God Ray**，即**丁达尔效应**，不是真的光源，而是通过透明纹理模拟得到的。  

开发者还可以把复杂的光照计算存储到一张**查找纹理 lookup texture**，即**查找表 lookup table, LUT**，中。然后只需要使用光源方向、视角方向、法线方向等参数，对 LUT 采样得到光照结果即可。对于主要角色使用更大分辨率的 LUT，一些 NPC 就使用较小的 LUT，这样可以优化性能。

实时阴影同样是非常消耗性能的效果，不仅是 CPU 需要提交更多的 Draw Call，GPU 也要做贡多的处理。所以尽量减少实时阴影，可以使用烘焙把静态物体的阴影信息存储到光照纹理当中，而只对动态物体使用适当的实时阴影。


## 节省带宽
大量使用未经压缩的纹理以及过大的分辨率都会造成由于带宽而引发的性能瓶颈。  

### 减少纹理大小
需要注意的是，所有纹理的长宽比最好是正方形，而且长宽值最好是 2 的整数幂。很多优化策略只有在这种时候才可以发挥最大效用。在 Unity 5 中，即使导入的纹理长宽值并不是 2 的整数幂，Unity 也会自动把长宽转换到离他最近的 2 的整数幂。

 除此之外，还应该尽可能使用**多级渐变纹理技术 mipmapping** 和**纹理压缩**。  
 ①纹理的属性面板里，勾选 **Generate Mip Maps**，Unity 就会为同一张纹理创建出很多大小不同的小纹理。而在游戏运行时可以根据物体的远近来动态选择使用哪一个纹理。  
 ②而纹理压缩，不同的 GPU 架构有它自己的纹理压缩格式，例如 PowerVRAM 的 PVRTC 格式、Tegra 的 DXT 格式、Adreno 的 ATC 格式。所幸的是，Unity 会根据不同的设备选择不同的压缩格式，只需设置为自动压缩即可。但是对一些有一定画质要求的纹理，比如 GUI，可以选择不压缩。

 ### 利用分辨率缩放
 过高的分辨率也是造成性能下降的原因之一，尤其对于很多低端手机，除了分辨率高其他硬件条件不尽如人意，也就是游戏性能的两大瓶颈：过大的屏幕分辨率、糟糕的 GPU。

对于特定设备，将其屏幕分辨率设低，再放大到屏幕的尺寸，虽然降低游戏效果，但是可以带来性能上的提升。Unity 中设置分辨率可以调用`Screen.SetResolution`。


## 减少计算复杂度
计算复杂度同样会影响游戏的渲染性能，可通过两方面的技术来减少计算复杂度：Shader 的 LOD 技术、代码方面的优化。

 ### Shader 的 LOD 技术
 跟之前提到的**模型的 LOD 技术**类似，**Shader 的 LOD 技术**可以控制使用的 Shader 等级。它的原理是，只有 Shader 的 LOD 值小于某个设定的值，这个 Shader 才会被使用，而使用了那些超过设定值的 Shader 的物体将不会被渲染。

 通常会在 SubShader 中使用类似下面的语句来指明该 Shader 的 LOD 值：  

     SubShader {
        Tags { "RenderTYpe" = "Opaque"}
        LOD 200

在 Unity Shader 的导入面板上看到该 Shader 使用的 LOD 值。默认情况下，LOD 等级是无限大的，即任何被当前显卡支持的 Shader 都可以被使用。有时需要去掉一些使用了复杂计算的 Shader 渲染，这时可以使用 `Shader.maximumLOD` 或 `Shader.globalMaximumLOD` 来设置允许的最大 LOD 值。

Unity 内置的 Shader 使用了不同的 LOD 值，例如：Diffuse 的 LOD 值为 200，Bumped Specular 的 LOD 值为 400。

### 代码方面的优化
游戏需要计算的对象、顶点和像素排序是：对象数 < 顶点数 < 像素数。因此需要尽可能需要把计算放在对象或逐顶点上，例如在实现高斯模糊或边缘检测，把采样坐标的计算放在顶点着色器中，该做法好于原片着色器中。

尽可能使用低精度的浮点值进行运算：  
①最高精度的 float/highp 适用于存储顶点坐标等变量，但它计算速度最慢，所以应尽量避免在片元着色器中使用这种精度的计算；  
②half/mediump 适用于一些标量、纹理坐标等变量，其计算速度约为 float 的两倍；  
③fixed/lowp 适用于大多数颜色变量和归一化后的方向矢量，对于一些精度要求不高的计算，尽量使用这种精度，其计算速度约为 float 的 4 倍。但要避免频繁的 swizzle 操作（如：color.xwxw），同时避免不同精度间的转换。

对于绝大多数 GPU 来说，在使用**插值寄存器**把数据从顶点着色器传递给下一个阶段时，我们应该使用尽量少的插值变量。例如，如果需要对两个纹理坐标进行插值，通常需要会把它们打包在同一个 float4 类型的变量中，两个纹理坐标分别对应了 xy 分量和 zw 分量。然而对于 PowerVR 平台来说，这种插值变量是非常廉价的，直接把不同的纹理坐标存储在不同的插值变量中，性能会更好。尤其是，如果在 PowerVR 上使用类似 `tex2D(_MainTex, uv.zw)` 语句进行采样，GPU 就无法进行一些纹理的预读取，因为它会认为这些纹理坐标是需要依赖其他数据的。

尽可能不使用全屏的屏幕后处理效果。如果必须使用，尽量使用 fixed/lowp 进行低精度运算（纹理坐标除外，可使用 half/mediump）；高精度运算可使用查找表（LUT）或转移到顶点着色器进行处理；尽量把多个特效合并到一个 Shader 中，例如：颜色校正和添加噪声等屏幕特效在 Bloom 特效的最后一个 Pass 中进行合成。  

其他代码优化规则：  
①尽量不要使用分支语句和循环语句；  
②避免使用 sin、tan、pow、log 等较为复杂的数学运算，用查找表代替；  
③尽量不要使用 discard 操作，这会影响硬件的某些优化。

### 根据硬件条件进行缩放
保证游戏基本的配置可以在所有的平台上运行良好；对于一些具有更高表现能力的设备，可以开启一些更“养眼”的效果，如：使用更高分辨率、开启屏幕后处理特效、开启粒子效果等。


## 扩展阅读
Unity 官方手册给出了很多优化的建议，建议详细阅读。


# 第十六章 Unity 的表面着色器
2009年（Unity 2.x），Unity 的渲染工程师 Aras 连续发表3篇名为《Shaders must die》的博客。博客中，Aras 认为：把渲染流程分为顶点和像素的抽象层面是不易理解的，这种在顶点/几何/片元着色器上的操作是对硬件友好的一种方式，他提出应该划分为：表面着色器、光照模型和光照着色器这样的层面。  
①表面着色器定义模型表面的反射率、法线和高光等；  
②光照模型选择使用兰伯特还是 Blinn-Phong 等模型；  
③光照着色器负责计算光照衰减、阴影等。

这样绝大多数时候开发者只需要和表面着色器打交道，如：混合纹理、颜色等；而光照模型是可以提前定义好的，只需要选择几种预定义的光照模型即可；光照着色器一旦由系统实现后，更不会轻易改动。这样大大减轻 Shader 编写者的工作量。2010年的 Unity 3 中，Surface Shader 被加入到 Unity 中。

## 表面着色器的一个例子
准备工作如下：  
①新建名为 Scene_17_1 的场景，并去掉天空盒，在场景中新建一个胶囊体；  
②新建名为 BumpedSpecularMat 的材质，并赋给场景中的胶囊体；  
③新建名为 Chapter17-BumpedDiffuse 的 Unity Shader，并赋给上一步创建的材质。

这里使用表面着色器来实现了一个使用了法线纹理的漫反射效果，下面代码参考的是 Unity 内置的 DefaultResourcesExtra/Bumped Diffuse 的代码：  

``` C C for Graphics
Shader "Unity Shaders Book/Chapter 17/Bumped Diffuse" {
    Properties {
        _Color ("Main Color", Color) = (1.0, 1.0, 1.0, 1.0)
        _MainTex ("Base (RGB)", 2D) = "white" {}
        _BumpMap ("Normalmap", 2D) = "bump" {}
    }

    SubShader {
        Tags { "RenderType"="Opaque" }
        LOD 300

        CGPROGRAM

        #pragma surface surf Lambert
        
        sampler2D _MainTex;
        sampler2D _BumpMap;
        fixed4 _Color;

        struct Input {
            float2 uv_MainTex;
            float2 uv_BumpMap;
        };

        void surf(Input IN, inout SurfaceOutput o) {
            fixed4 tex = tex2D(_MainTex, IN.uv_MainTex);
            o.Albedo = tex.rgb * _Color.rgb;
            o.Alpha = tex.a * _Color.a;
            o.Normal =  UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));
        }

        ENDCG
    }
    Fallback "Legacy Shaders/Diffuse"
}
```

在材质面板上拖拽一张漫反射纹理、一张法线纹理，分别在对应路径为：Assets/Textures/Chapter17/Mud_Diffuse.tif 和 Assets/Textures/Chapter17/Mud_Normal.tif。我们还可以向场景中添加一些点光源和聚光灯，我们不需要对代码做任何改动，效果如下：  

<div  align="center">  
<img src="https://s2.loli.net/2024/01/03/wWrkYsa3RSv6XDl.jpg" width = "60%" height = "60%" alt="图83- 表面着色器的例子。左图：在一个平行光下的效果。右图：添加了一个点光源（蓝
色）和一个聚光灯（紫色）后的效果。"/>
</div>

从上面例子来看，相比顶点/片元着色器，表面着色器的代码很少。而且，可以轻松地实现常见的光照模型，不需要和任何光照变量打交道，Unity 帮我们处理好了每个光源的光照结果。

和顶点/片元着色器需要包含到一个特定的 Pass 块中不同，**表面着色器的 Cg 代码是直接而且必需写在 SubShader 块中，Unity 会在背后生成多个 Pass**。

## 编译指令
一个表面着色器中最重要的部分是**两个结构体**以及它的**编译指令**，两个结构体是表面着色器中不同函数之间信息传递的桥梁，而编译指令是开发者和 Unity 沟通的重要手段。

编译指令最重要的作用是指明该表面着色器使用的**表面函数**和**光照函数**，并设置一些可选参数。表面着色器的 Cg 块中第一句往往就是编译指令，编译指令的一般格式如下：  

    #pragma surface surfaceFunction lightModel [optionalparams]

其中，**#pragma surface** 用于指明该编译指令是用于定义表面着色器的，在它后面需要指明使用的表面函数 surfaceFunction 和光照模型 lightModel，同时还可以使用一些可选参数来控制表面着色器的一些行为。

### 表面函数
一个对象的表面属性定义了它的反射率、光滑度、透明度等值，而表面函数用于定义这些表面属性。surfaceFunction 通常就是名为 surf 的函数（函数名可以是任意的），其函数格式是固定的：  

    void surf (Input IN, inout SurfaceOutput o)
    void surf (Input IN, inout SurfaceOutputStandard o)
    void surf (Input IN, inout SurfaceOutputStandardSpecular o)

其中，后两个是基于物理的渲染。**SurfaceOutput**、**SurfaceOutputStandard** 和 **SurfaceOutputStandardSpecular** 都是 Unity 内置的结构体，需要配合不同的光照模型使用，后面会介绍。

在表面函数中，会使用输入结构体 **Input IN** 来设置各种表面属性，并把这些属性存储在结构体  SurfaceOutput、SurfaceOutputStandard 和 SurfaceOutputStandardSpecular 中，再传递给光照函数计算光照结果。

可以在 Unity 手册的表面着色器例子中找到更多示例：https://docs.unity3d.com/Manual/SL-SurfaceShaderExamples.html

### 光照函数
光照函数会使用表面函数中设置的各种表面属性，来应用某些光照模型，进而模拟物体表面的光照效果。Unity 内置了基于物理的光照模型函数：**Standard**、**StandardSpecular**（在 UnityPBSLighting.cginc 文件中被定义），以及简单的非基于物理的光照模型函数：**Lambert**、**BlinnPhong**（在 Lighting.cginc 文件中被定义）。

当然，也可以定义自己的光照函数。例如，可以使用下面的函数来定义用于前向渲染中的光照函数：  

    // 用于不依赖视角的光照模型，例如：漫反射
    half4 Lighting<Name> (SurfaceOutput s, half3 lightDir, half atten);
    // 使用依赖视角的光照模型，例如：高光反射
    half4 Lighting<Name> (SurfaceOutput s, half3 lightDir, half3 viewDir, half atten);

### 其他可选参数
**可选参数 optionalparams** 包含了很多有用的指令类型，例如：开启/设置透明混合/透明度测试，指明自定义的顶点和颜色修改函数，控制生成的代码等。下面选取了一些比较重要和常用的参数进行更深入地说明，可以在 Unity 官方手册查看更多：  
①自定义的修改函数：除了表面函数和光照模型外，表面着色器还可以支持其他两种自定义的函数：**顶点修改函数 vertex:VertexFunction**和**最后的颜色修改函数 finalcolor:ColorFunction**。顶点修改函数允许开发者自定义一些顶点属性，例如，把顶点颜色传递给表面函数，或是修改顶点位置，实现某些顶点动画等。最后的颜色修改函数则可以在颜色绘制到屏幕前，最后一次修改颜色值，例如实现自定义的雾效等。  
②阴影：可以通过一些指令来控制和阴影相关的代码。例如，**addshadow** 参数会为表面着色器生成一个阴影投射的 pass。通常情况下，Unity 可以直接在 FallBack 中找到通用的光照模式为 ShadowCaster 的 pass，从而将物体正确地渲染到深度和阴影纹理中。但是对于一些进行了顶点动画、透明度测试地物体，就需要特殊处理，正如第 10 章最后说的一样；**fullforwardshadows** 参数则可以在前向渲染路径中支持所有光源类型的阴影。默认情况下，Unity 只支持最重要的平行光的阴影效果，如果需要让点光源或聚光灯在前向渲染中也有阴影，就可以添加这个参数；如果不想对这个 Shader 的物体进行任何阴影计算，就可以使用 **noshadow** 参数来禁用阴影。  
③透明度混合和透明度测试：可以通过 **alpha** 和 **alphatest** 指令来控制透明度混合和透明度测试。例如，**alphatest:VariableName** 指令会使用名为 VariableName 的变量来剔除不满足条件的片元。此时，还需要使用前面提到的 **addshadow** 参数来生成正确的阴影投射的 Pass。  
④光照：**noambient** 参数会告诉 Unity 不要应用任何环境光照或光照探针 light probe；**novertexlights** 参数告诉 Unity 不要应用任何逐顶点光照；**noforwardadd** 会去掉所有前向渲染中的额外的 Pass，也就是说，这个 Shader 只会支持一个逐像素的平行光，而其他的光源会按照逐顶点或 SH 的方法来计算光照影响；还有一些用于控制光照烘焙、雾效模拟的参数，如 **nolightmap**、**nofog** 等。
⑤控制代码的生成：默认情况下，Unity 会为一个表面着色器生成相应的前向渲染路径、延迟渲染路径使用的 Pass，这会导致生成的 Shader 文件比较大。如果确定该表面着色器只会在某些渲染路径中使用，可使用 **exclude_path:deferred**、**exclude_path:forward** 和 **exclude_path:prepass** 来告诉 Unity 不需要为某些渲染路径生成代码。


## 两个结构体
表面着色器支持最多自定义 4 个关键的函数：表面函数（设置表面属性，如反射率、法线等）、光照函数（定义光照模型）、顶点修改函数（修改、传递顶点属性）、颜色修改函数（修改最后的颜色）。那么这些函数之间的信息是如何传递的？这就是两个结构体的工作。

一个表面着色器需要使用两个结构体：表面函数的输入结构体 **Input**，以及存储了表面属性的结构体 **SurfaceOutput**、**SurfaceOutputStandard** 或 **SurfaceOutputStandardSpecular** 。

### 数据来源：Input 结构体
**Input** 结构体包含了许多表面属性的数据来源，



