---
title: 《Unity Shader入门精要》读书笔记（五）
date: 2023-12-30 16:05:42
categories: 
  - [unity, unity shader]
tags:
  - 游戏开发
  - unity
  - 图形学
top_img: /images/black.jpg
cover: https://s2.loli.net/2023/12/30/hc2s7BS45l1wUdQ.gif
mathjax: true
---

> 本读书笔记为高级篇的最后一章和扩展篇，主要内容为XXXXXXXXXXXXXXXXXXXXXXXXX。
> 读书笔记是对知识的记录与总结，但是对比较熟悉的内容不会再行描述。

# 第十五章 Unity 中的渲染优化技术
在本章中，将会阐述一些 Unity 常见的优化技术。这些优化技术都是和渲染有关的，例如：使用批处理、LOD 技术（Level of Detail）等。

## 移动平台的特点
和 PC 平台相比，移动平台上的 GPU 架构有很大的不同。由于处理资源等条件的限制，移动设备上的 GPU 架构专注于尽可能使用更小的带宽和功能，也由此带来许多和 PC 不同的现象。

例如，为了尽可能移除一些隐藏的表面，减少 overdraw（同一像素绘制多次），PowerVR 芯片（用于 iOS 设备和一些 Android 设备）使用**基于瓦片的延迟渲染 Tiled-based Deferred Rendering, TBDR** 架构，把所有渲染图像装入一个个瓦片中，由硬件找到可见的片元，并只对它们执行片元着色器；另一些基于瓦片的 GPU 架构，如：Adreno（高通的芯片）和 Mali（ARM 的芯片），则会使用 Early-Z 或相似的技术进行低精度的深度检测，剔除不需要渲染的片元。还有一些 GPU，如 Tegra（英伟达的芯片），则使用了传统的架构设计，因此在这些设备上，overdraw 更可能造成性能的瓶颈。

由于这些芯片架构造成的不同，一些游戏往往需要针对不同的芯片发布不同的版本，以便对每个芯片进行更有针对性的优化。

## 影响性能的因素
游戏主要使用两种计算资源：GPU 和 CPU。CPU 主要负责保证帧率，GPU 主要负责分辨率相关。把造成游戏性能瓶颈的主要原因分成以下几方面：  
①CPU：  
&emsp;&emsp; - 过多的 drawcall，每次调用 Draw Call，CPU 往往需要改变很多渲染状态的设置，这些操作非常耗时，若大部分时间花费在提交 Draw Call 的准备工作上，会导致性能下降；  
&emsp;&emsp; - 复杂的脚本或者模拟（物理、布料、蒙皮、粒子等）。  
②GPU  
&emsp;&emsp; - 过多的顶点或过多的逐顶点计算；  
&emsp;&emsp; - 过多的片元（可能是由于分辨率造成，也有可能是 overdraw）或过多的逐片元计算。  
③带宽  
&emsp;&emsp; - 使用了尺寸很大且未压缩的纹理；  
&emsp;&emsp; - 分辨率过高的帧缓存。

--- 

在了解上面的基本内容后，本章后续涉及的优化技术有：  
①CPU 优化：  
&emsp;&emsp; - 使用批处理技术减少 Draw Call 数目；  
②GPU 优化：  
减少需要处理的顶点数目：  
&emsp;&emsp; - 优化几何体；  
&emsp;&emsp; - 使用模型的 LOD（Level of Detail）技术；  
&emsp;&emsp; - 使用遮挡剔除 Occlusion Culling 技术；  
减少需要处理的片元数目：  
&emsp;&emsp; - 控制绘制顺序；  
&emsp;&emsp; - 警惕透明物体；  
&emsp;&emsp; - 减少实时光照；  
减少计算复杂度：  
&emsp;&emsp; - 使用 Shader 的 LOD（Level of Detail）技术；  
&emsp;&emsp; - 代码方面的优化；  
③节省内存带宽：  
&emsp;&emsp; - 减少纹理大小；  
&emsp;&emsp; - 利用分辨率缩放。

## Unity 中的渲染分析工具
Unity 内置了一些工具，用来查看和渲染相关的统计数据，包括渲染统计窗口 Rendering Statistics Window、性能分析器 Profiler，以及帧调试器 Frame Debugger。

### 渲染统计窗口
就是 Game 窗口的 Stats 按钮。图片不放出了，主要包括 3 个方面的信息：音频 Audio、图像 Graphics 和网络 Network。而图像相关的渲染统计结果包含了很多重要的渲染数据，如下表：  

| 信息名称 | 描述 |
| :---- | :---- |
| 每帧的时间和 FPS | Frame per Second，后面的括号中显示的是当前帧的耗时 |
| CPU：main / render thread | main 是主线程的耗时，render thread 是渲染线程的耗时 |
| Batches | 当前帧需要进行的批处理数目 |
| Saved by batching | 合并的批处理数目，这个数字表明了批处理为我们节省了多少 draw call |
| Tris / Vertes | 当前帧绘制的三角面片和顶点的数目 |
| Screen | 屏幕的大小，及它占用的内存大小 |
| SetPass calls | 渲染使用的 Pass 的数目，每个 Pass 都需要 Unity 的 runtime 来绑定一个新的 Shader。数目越大，越容易产生 CPU 的性能瓶颈 |
| Shadow casters | 当前帧投射阴影的物体数目 |
| Visible skinned meshes | 渲染的蒙皮网格数目 |
| Animation / Animator components playing | 当前帧播放的 Animation / Animator 数目 |


### 性能分析器
Window -> Analysis -> Profiler 打开性能分析器 Profiler 。这里图片也不放了。性能分析器中的渲染模块 Rendering 提供了更多关于渲染的统计信息，比如，draw call 数目、动态批处理/静态批处理的数目、渲染纹理的数目和内存占用等。

使用 Unity 性能分析器可以通过三种主要方式记录数据：  
①在目标平台上的播放器中对应用程序进行性能分析；  
②在 Unity 编辑器中以运行模式对应用程序进行性能分析；  
③对 Unity 编辑器进行性能分析。

获得有关应用程序性能的最佳方法是在打算发布它的终端平台上对它进行性能分析。详见官方文档：https://docs.unity3d.com/2022.3/Documentation/Manual/profiler-profiling-applications.html

### 帧调试器
Window -> Analysis -> Frame Debugger 打开帧调试器面板。在该窗口中可以看到每一个 draw call 的工作和结果。之前讲过，不再重复摘抄了。需要详细信息见官方文档：https://docs.unity3d.com/2022.3/Documentation/Manual/frame-debugger-window.html

### 其他性能分析工具
①对 Android 平台来说：  
&emsp;&emsp; - 高通的 Adreno 分析工具可以对不同的测试机进行详细的性能分析。  
&emsp;&emsp; - 英伟达的 NVPerfHUD 工具可以帮助我们得到几乎所有需要的性能分析数据，如：每个 Draw Call 的 GPU 时间、每个 Shader 花费的 cycle 数目等。  
②对 iOS 平台来说：  
&emsp;&emsp; - PowerVRAM 的 PVRUniSCo Shader 分析器可以给出大致的性能评估。
&emsp;&emsp; - XCode 的 OpenGL ES Driver Instruments 可以给出一些宏观上的性能信息，如：设备利用率、渲染器利用率等。

相比 Android，对 iOS 的性能分析更加困难（工具较少）。且 PowerVR 芯片采用了基于瓦片的延迟渲染器，想得到每个 Draw Call 花费的 GPU 时间几乎不可能，所以一些宏观上的统计数据更有参考价值。

## 减少 draw call 数目
最常见的优化技术大概就是**批处理 batching**了。批处理的实现原理就是为了减少每一帧需要的 draw call 的数量。为了把一个对象渲染到屏幕上，CPU 需要检查哪些光源影响了该物体，绑定 shader 并设置它的参数，再把渲染命令发送给 GPU。当场景中包含了大量对象时，这些操作会非常耗时。批处理就是在每次调用 draw call 时尽可能的处理多个物体。

什么样的物体可以进行一起批处理：即使用相同材质的物体。因为它们之间的不同仅仅在于顶点数据的差别，可以把这些顶点数据合并在一起发送给 GPU，就可以完成一次批处理。

Unity 支持两种批处理方式：  
①**动态批处理**：有点在于一切都是Unity自动完成，无需自己做任何操作，物体可移动。缺点是限制太多，一不小心就破坏这种机制，导致无法动态批处理一些使用了相同材质的物体；  
②**静态批处理**：自由度高，限制少。但是占用更多内存，而且经过静态批处理后的物体不能再移动（即使脚本中尝试改变物体的位置也是无效的）。

### 动态批处理
如果场景中有一些模型共享了同一材质并满足了一些条件，Unity 就自动把它们进行批处理，从而只需要花费一个 draw call 就可以渲染所有模型。动态批处理的基本原理就是每一帧把可以进行批处理的模型网格进行合并，再把合并后模型数据传递给 GPU，然后使用同一个材质对其渲染。除了实现方便，动态批处理的另一个好处是，经过批处理的物体仍然可以移动，这是因为由于在处理每帧时 Unity 都会重新合并一次网格。

模型网格批处理合并的主要的条件限制（随着 Unity 版本变化，条件可能会改变）：  
①网格的顶点属性规模要小于 900。例如，如果 Shader 中需要使用顶点位置、法线、纹理坐标这 3 个顶点属性，想要让模型被动态批处理，他们的顶点数目不能超过 300；  
②一般来说，所有对象都需要使用同一个缩放尺度。一个例外情况是，如果所有物体都使用了不同的非统一缩放，那么也是可以被动态批处理的。但在 Unity 5 中，这种对模型缩放的限制不存在了；  
③使用光照纹理 lightmap 的物体需要额外的渲染参数，例如，在光照纹理上的索引、偏移量和缩放信息等。为了让这些物体可以被动态批处理，需要保证它们指向光照纹理的同一个位置；  
④多 Pass 的 shader 会中断批处理。前向渲染中，有时需要额外的 Pass 来为模型添加更多的光照效果，这样会导致模型无法被完全动态批处理。Unity 只会批处理第一个 Pass，不能为额外的逐像素光源进行批处理。

### 静态批处理
相对于动态批处理来说，静态批处理适合于任何大小的几何模型。其实现原理是，只在运行开始阶段，把需要进行静态批处理的模型合并到一个新的网格结构中，这意味着这些模型不可以在运行时刻被移动。静态批处理的另一个缺点在于，它往往需要占用更多的内存来存储合并后的几何结构。因为，若在静态批处理前一些物体共享了相同的网格，那么在内存中每一个物体都会对应一个该网格的复制品，即一个网格会变成多个网格再发给 GPU。如果这一类使用同一网格的对象很多，那么将会成为一个性能瓶颈。

静态批处理的实现，只需要把物体面板右上角的 **Static** 勾选上即可，实际上只需要在其右边的下拉菜单里勾选 Batching Static 即可。

在内部实现上，Unity 首先把这些静态物体变换到世界空间下，为它们构建成一个更大的顶点和索引缓存。对于使用同一材质的物体，Unity 只需调用一个 Draw Call 就可以绘制全部物体；对于使用不同材质的物体，静态批处理同样可以提升渲染性能，尽管仍然需要调用多个 Draw Call，但静态批处理可以减少这些 Draw Call 之间的状态切换，而这些切换往往是费时的操作。我们可以从 Unity 的分析器中观察在应用静态批处理前后 **VBO total**（**Vertex Buffer Object**，顶点缓冲对象）的变化。VBO 的数目变大，即它需要更多的内存存储合并后的几何结构，即如果一些物体共享了相同的网格，那么在内存中每一个物体都会对应一个该网格的复制品。

若场景中包含了除了平行光以外的其他光源，并且在 shader 中定义了额外的 pass 来处理它们，这些 pass 将不会被批处理，而平行光的 base pass 仍然可以被静态批处理。

### 共享材质
无论是动态批处理还是静态批处理，都要求模型之间共享同一个材质。但不同模型之间总需要有不同的渲染属性，如：不同的纹理、颜色等，这时需要一些策略尽可能地合并材质。

如果两个材质之间只有使用的纹理不同，可以这些纹理合并到一张更大的纹理中，这张更大的纹理被称为一张**图集 atlas**。一旦使用了同一张纹理，就可以使用同一个材质，再使用不同的采样坐标对纹理采样即可。

但除了纹理不同外，不同的物体在材质上还有一些微小的参数变化。但是只要调整了参数，就会影响到所有使用了这个材质的对象。一个常用的解决方案就是使用网格的顶点数据（最常见的就是顶点颜色数据）来存储这些参数。前面说过，经过批处理后的物体会被处理成更大的 VBO 发送给 GPU，VBO 中的数据可以作为输入传递给顶点着色器，因此可以对 VBO 中的数据进行控制，从而达到不同的目的。

如果需要在脚本中访问共享材质，可以使用 `Renderer.sharedMaterial` 来修改共享材质。

### 批处理的注意事项
①尽可能选择静态批处理，要时刻小心对内存的消耗，记住经过静态批处理的物体不可以再被移动；  
②如果无法进行静态批处理而需要动态批处理时，小心各种限制条件；  
③游戏中的小道具，如可以拾取的金币，可以使用动态批处理；  
④对于包含动画的物体，无法全部使用静态批处理，而如果不动的部分可以把这部分标示为 static；  
⑤批处理需要把多个模型变换到 *世界空间* 下合并他们，因此，如果 shader 存在一些在模型空间下的坐标的运算，那么往往会得到错误的结果，可以在这部分的 shader 中使用 **DisableBatching** 标签来强制使用该 shader 的材质不会被批处理；  
⑥对于使用 *半透明材质* 的物体通常需要使用严格的从后往前的绘制顺序来保证透明混合的正确性。对于这些物体，Unity 会首先保证它们的绘制顺序，再尝试对它们进行批处理。即当绘制顺序无法满足时，批处理无法被成功应用。


## 减少需要处理的顶点数目
顶点数目可能会造成 GPU 的性能瓶颈。有 3 个常用的顶点优化策略。

### 优化几何体
优化网格来尽可能减少模型中三角面片的数目或顶点数目。Unity 的渲染统计窗口中可以查看渲染当前帧需要的三角面片数目和顶点数目。需要注意的是：Unity 中显示的顶点数目往往要多于建模软件里显示的顶点数。主要有几个原因：  
①三维软件是以人类的角度理解顶点，而 Unity 是站在 GPU 的角度计算顶点数的；  
②在 GPU 看来，有时候一个顶点需要拆分成多个顶点，其原因主要有两个：一是为了**分离纹理坐标 uv splits**，另一个是为了**产生平滑的边界 smoothing splits**。建模时一个顶点的纹理坐标有多个，例如：一个立方体，它的 6 个面之间虽然使用了一些相同的顶点，但在不同面上，同一个顶点的纹理坐标可能并不相同。而对 GPU 来说，顶点的每个属性和顶点之间必须是一对一的关系，所以必须将这个顶点拆分成多个具有不同纹理坐标的顶点。而平滑边界也是类似，顶点可能会对应多个法线信息或切线信息，这通常是因为我们要决定这个边是**硬边 hard edge** 还是**平滑边 smooth edge**。

使用可以移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离，来尽可能减少顶点数目。

### 模型的 LOD 技术
**LOD，Level of Detail** 技术的原理是，当一个物体离摄像机很远时，模型上的很多细节是无法被察觉到的，因此 LOD 允许当对象逐渐远离摄像机时，减少模型上的面片数量，从而提高性能。  

在 Unity 中，可以使用 LOD Group 组件来为一个物体构建一个 LOD。当需要为一个对象准备多个包含不同细节程度的模型，然后把它们赋给 LOD Group 组件中的不同等级，Unity 会自动判断当前位置上使用哪个等级的模型。

### 遮挡剔除技术
**遮挡剔除 Occlusion Culling** 可以用来消除那些被其他物体遮挡住的物体，这意味着看不见的顶点不会被 GPU 渲染，从而提升性能。

注意，区分遮挡剔除和摄像机的视锥体剔除 Frustum Culling。视锥体剔除只会剔除掉那些不在相机的视野范围内的对象，但不会判断视野中是否有物体被其他物体遮挡。而遮挡剔除会使用一个虚拟的相机来遍历场景，从而构建一个潜在可见的对象集合的层级结构。运行时，每个相机将会使用这个数据来识别哪些物体可见，哪些物体被挡住。

遮挡剔除不仅可以减少处理的顶点数目，还可以减少 overdraw，提高游戏性能。


## 减少需要处理的片元数目
过多的片元是造成 GPU 性能瓶颈的另一原因，其优化的重点在于减少 **Overdraw**，Overdraw 指的是同一个像素被绘制了多次。

Unity 提供了查看 overdraw 的视图，在 Scene 视图的 2D 按钮前一个 Shading Mode 的球体按钮下拉菜单里可以选择 Overdraw。实际上，这里的视图只是提供了查看物体互相遮挡的层数，并不是真正绘制屏幕的最终 overdraw。也就是说，它显示的是，没有使用任何深度测试和其他优化策略时的 overdraw。这种视图是通过把所有对象都渲染成一个透明的轮廓，通过查看透明颜色的累计程度来判断物体之间的遮挡。

### 控制绘制顺序
为了最大限度地避免 overdraw，一个重要的优化策略就是控制绘制顺序。由于深度测试的存在，从而如果保证了所有物体都是从前往后进行绘制，从很大程度上减少 overdraw。因为后面绘制的物体无法通过深度测试，从而无法被绘制出来。  

在 Unity 中，渲染队列数目小于 2500（如 “Background”、“Geometry”、“AlphaTest”）的对象都被认为是不透明 opaque 的物体，这些物体总体上是从前到后绘制的。而使用其他队列（如 “Transparent”、“Overlay” 等）的物体，则是从后到前，意味着开发者尽可能把物体的队列设置为不透明物体的渲染队列，而经可能避免使用半透明队列。

而且，我们还可以充分利用渲染队列，比如：  
①在第一人称射击游戏，游戏的主角的 shader 往往比较复杂。但是通常会挡住屏幕的很大一部分区域，因此可以将主角的渲染队列调小，先渲染；  
②对于一些敌方角色，由于它们通常在掩体的后面，所以可以将它们的渲染队列调大，这样先渲染不透明掩体，掩体后面的敌人就不用再被渲染；  
③对于天空盒来说，它几乎覆盖所有的像素，而且它永远会出现在所有物体的后面。将它的队列设置为 “Geometry+1”，就可以保证其最后渲染，减少 Overdraw。

### 时刻警惕透明物体
半透明物体因为没有开启深度写入，需要从后往前进行渲染，这意味着一定会产生 overdraw 现象。

例如，对于 GUI 对象来说，如果大多被设置成了半透明，并且占据比例太多，那么会造成大量 overdraw。因此，场景中若包含了大面积的半透明物体，或者很多层相互覆盖的半透明对象，或者是透明的粒子效果，在移动设备上也会造成大量的 overdraw。

可以尽量减少窗口中的 GUI 所占的面积，如果没办法，可以把 GUI 的绘制和三维场景的绘制交给不同的摄像机，而其中负责三维场景的摄像机的视角范围经历不要与 GUI 的相互重叠。

在移动平台上，透明度测试也会影响游戏性能。透明度测试会使用 discard 或 clip 操作，导致一些硬件的优化策略失效。比如：PowerVR 使用的基于瓦片的延迟渲染技术，为了减少 Overdraw 它会调用片元着色器前就判定哪些瓦片被真正渲染。但由于透明度测试在片元着色器中使用了 discard 函数改变了片元是否会被渲染的结果，因此 GPU 无法使用上述的优化策略，只有执行了所有的片元着色器后，GPU 才知道哪些片元会被真正渲染到屏幕上，这样原先减少的 Overdraw 的优化就都失效了。

### 减少实时光照和阴影
如果场景中包含了过多的点光源，并且使用了多个 Pass 的 Shader，那么很可能会造成性能下降。对于逐像素的点光源，使用了逐像素的 Shader 不仅会提高 draw call，同时会增加 overdraw。这是因为，对于逐像素的光源来说，被这些光源照亮的物体需要被再渲染一次，而且也会中断批处理。

可以使用烘焙技术，把光照提前烘焙到一张**光照纹理 lightmap** 中，在运行时对纹理进行采样即可。

