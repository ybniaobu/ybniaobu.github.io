---
title: Unity URP 基础
date: 2024-02-22 14:03:56
categories: 
  - [unity, unity shader]
tags:
  - 游戏开发
  - unity
  - 图形学
top_img: /images/black.jpg
cover: https://s2.loli.net/2024/02/18/pMAzYioaFZEkS8I.gif
mathjax: true
description: 主要内容有 Unity SRP 介绍、URP 相关基础知识点、URP shader 代码的大致框架、URP 透明度测试和透明度混合、 GPU Instancing 以及光照和阴影。
---

> 之前的《Unity Shader入门精要》是以 Unity 内置渲染管线为基础的，以 Cg 语言为主，但当使用 URP 和 HDRP 时，使用的是 HLSL 语言；  
> 本文介绍 URP 相关基础知识，主要关注 URP 的 Shader 代码基础框架，充当备忘录的功能。
> 本文参考了 https://catlikecoding.com/ 的 tutorials for Unity 的部分内容。

# Unity SRP
**SRP**，**Scriptable Render Pipeline**，即**可编程渲染管线**。Unity 当前提供两个预先构建的 SRP： ①**URP**，**Universal Render Pipeline**，即**通用渲染管线**；②**HDRP**，**High Definition Render Pipeline**，即**高清渲染管线**。SRP 可以理解为是一个 API 层，允许使用 C# 脚本来调度和配置渲染命令。Unity 将这些命令传递给它的低级图形架构，后者随后将指令发送给图形 API。

①**Universal Render Pipleline** 前身为 Lightweight Render Pipeline，即 LWRP 轻量级渲染管线，专注于性能，它被设计为能够在任何平台上都能提供最好的性能，所以除非有特殊需求只能在 HDRP 或者 SRP 解决的，其他都应该选择 URP，不管是移动端、主机、PC 等，URP 都能提供高性能的渲染，目前 URP 能做的也非常多，它拥有很多 HDRP 相同的功能，但为了在所有平台达到更好的性能，其做了一定的缩减。2D 光照和阴影是 URP 独占的，所以如果需要做 2D 游戏，就选 URP。

②**High Definition Render Pipleline** 专注于高端图形渲染，针对高端硬件配置，像 PC、XBox 和 Playstation，其面向高逼真度的游戏、图形 demo 和建筑渲染、超写实效果，以及所需的最佳图形效果。同时针对高端图形处理时，它要比内置渲染器要快得多；但要想得到完成利用 HDRP 的完美表现能力，需要大量的贴图，漫反射贴图、高光贴图、金属贴图、平滑贴图、AO 贴图、法线贴图、凹凸贴图、高度贴图；HDRP 同时提供高级和丰富的光照功能，比如实时全局光照 RealTime GI ，能够模拟光线反射、体积光、能模拟光穿过空气中的粒子，还有光线跟踪。HDRP 提供一系列高端的 shader 特效，例如高度、细节和 parallax Maps，分别用于纹理的位移、细节和深度模拟，它还支持子面散射，用于模拟光线穿过很薄的物体，比如皮肤和衣物，它提供了高级的 shader，能够让你同时使用多个材质的属性，比如子面散射、彩虹色、各向异性和模糊参数化。

URP 和 HDRP 都可以使用 **Shader Graph** 来编写 Shader，同时都支持 Visual Effect Graph，但是手写 Shader 在性能方面有很大的优势，因此在项目中前期建议直接使用 Shader Graph 来编写 Shader，因为 Shader Graph 可视化更加便捷，在得到想要的效果后，在项目后期改成手写 Shader 来提高性能。

## SRP 和内置管线的不同
在 SRP 中手写 Shader 仍然使用的是 Shader Lab，和内置渲染管线相比，结构并没有太大的变化，主要的几点不同如下：  
**①**使用 **HLSL** 而不是 Cg 语言，尽管这不是强制的，但是 HLSL 是官方推荐的。Cg 语言已经不再更新。官方的 URP 的自带的 Shader 都是 HLSL 编写的，URP Shader 代码中会调用 URP Shader Library 中的 Shader 代码（在名为 Universal RP 的 Packages 中）；  
**②**SubShader 的 Tags 中需要指定 **RenderPipeline**，例如：`"RenderPipeline" = "UniversalPipeline"`表示这是一个 URP 的 Shader；  
**③**Pass 的 Tags 中的 **LightMode** 和内置渲染管线不同，在内置管线中，LightMode 表示了这个 Pass 处于管线中处理光照的哪个步骤，例如 `ForwardBase`，`ForwardAdd`分别是前向流水线中的主光照 pass 和附加逐像素光照 pass。而 URP 中，我们经常使用的有 `UniversalForward`，`ShadowCaster`，`DepthNormalsOnly`，`DepthOnly`，`SRPDefaultUnlit` 等 pass；  
**④**为了兼容 **SRP Batcher**，Shader 需要采用一些特殊的写法。简单来说，就是对于 Properties 中的属性，需要放到特定的 **CBuffer** 中，这个 CBuffer 的名字为 **UnityPerMaterial**。另外对于 Unity 的内置属性，比如一些内置矩阵，要放到 **UnityPerDraw** 的 CBuffer 中；  
**⑤**如果要支持 **GPU Instancing**，Shader 代码还要使用另外的一组宏来修改，使得可以支持 GPU Instancing。

## Universal Render Pipeline Asset
每个 Unity URP 项目都需要一个 URP Asset 来配置 URP 相关设置。如果使用了 URP 模板创建了 URP 项目，Unity 会自动在 Settings 的文件夹中创建 URP Asset，并将其分配至 Project Settings 当中。URP Asset 是一个继承自 RenderPipelineAsset 的 scriptable object。一个项目可以拥有多个 URP Asset，可以进行切换以获取不同的效果。

> 自定义渲染管线资产不在这里说明，日后有更高的需求详见官方文档和 https://catlikecoding.com/unity/tutorials/custom-srp/custom-render-pipeline/


# URP 基础语法
## 常用的材质属性的特性

| 特性 | 作用 |
| :---- | :---- |
| [Gamma] | 当使用 Linear color space 时，材质的颜色属性提供的是 sRGB 色彩，但是当传递给 shader 时会被自动转换为线性值，为了线性插值计算更合理。但是对于材质的 Float 或 Vector 属性，不会自动进行色彩空间转换，因此对于一些跟色彩相关的 Float 或 Vector 属性，比如金属度，需要把它们指定到 sRGB 空间，此时可以添加 [Gamma] 特性。 |
| [HDR] | 指定颜色或纹理属性使用 HDR 值。 |
| [HideInInspector] | 在 Inspector 面板隐藏属性。 |
| [MainTexture] | 设置材质的主纹理，可以在脚本通过 `Material.mainTexture` 获取或设置。默认情况下，Unity 会把 _MainTex 作为主纹理，此时不用添加 [MainTexture] 特性。 |
| [MainColor] | 设置材质的主颜色，可以在脚本通过 `Material.color` 获取或设置。默认情况下，Unity 会把 _Color 作为主纹理，此时不用添加 [MainColor] 特性。 |
| [NoScaleOffset] | 让材质面板的纹理属性隐藏 tiling 和 offset 选项。 |
| [Normal] | 指明当前纹理属性希望得到一个 normal map，如果不是会报错。 |
| [PerRendererData] | 指明当前纹理属性作为 MaterialPropertyBlock 的 per-renderer data，即 per-instance data。材质面板会将添加该特性的属性显示为只读 |
| [Toggle(XXX)] <br> [ToggleOff(XXX)] | 括号及内部关键字名称可以没有，若有关键字名称，若材质面板勾选，Unity 会激活全为大写的该关键字。若没有关键字名称，若材质面板勾选，Unity 会激活全为大写的名称为材质属性名称的关键字。[ToggleOff] 和 [Toggle] 相反，若勾选，则不激活。 |
| [KeywordEnum(XXX, XXX, ...)] | 关键字枚举，允许我们在下拉菜单中选择一个关键字启用，最多支持 9 个关键字 |
| [Enum(XXX)] | 为 float 属性提供下拉菜单，最多可指定 7 个名称。常规用法有：`[Enum(UnityEngine.Rendering.BlendOp)] _BlendOp ("BlendOp", Float) = 0`，<br> `[Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend ("SrcBlend", Float) = 1`，<br> `[Enum(UnityEngine.Rendering.BlendMode)] _DstBlend ("DstBlend", Float) = 0`，<br> `[Enum(Off, 0, On, 1)] _ZWriteMode ("ZWriteMode", float) = 1`，<br> `[Enum(UnityEngine.Rendering.CullMode)]_CullMode ("CullMode", float) = 2`，<br> `[Enum(UnityEngine.Rendering.CompareFunction)]_ZTestMode ("ZTestMode", Float) = 4`，<br> `[Enum(UnityEngine.Rendering.ColorWriteMask)]_ColorMask ("ColorMask", Float) = 15`，<br> `[Enum(UnityEngine.Rendering.CompareFunction)]_StencilComp ("Stencil Comparison", Float) = 8`，<br> `[Enum(UnityEngine.Rendering.StencilOp)] _StencilPass ("Stencil Pass", Float) = 0`，<br> `[Enum(UnityEngine.Rendering.StencilOp)] _StencilFail ("Stencil Fail", Float) = 0`，<br> `[Enum(UnityEngine.Rendering.StencilOp)] _StencilZFail ("Stencil ZFail", Float) = 0` |
| [PowerSlider(3.0)] | 和 Range 属性一起使用，显示一个非线性响应的滑动条。意思就是，让 Range 滑杆更加方便调整细微的值。以 [PowerSlider(1.0)] 为分界，当值为 1.0 时，效果与 range 一致。当值 < 1.0 时，值越大可调整的范围越大。当值 > 1.0 时，值越小可调整的范围越大。可以更精细地在这些区间进行微调。 |
| [IntRange] | 显示一个适用于 Range 着色器属性的整数滑动条。 |
| [Space(XXX)] | [Space] 在材质面板中增加空行，[Space(50)] 可以在后面添加数值增加更多空行。 |
| [Header(XXX)] | 在材质面板中显示标题。 |

## URP 支持的 HLSL 变量
> URP 的 HLSL 和 HLSL 存在细微差别。想对 HLSL 了解更深可以查阅微软的文档：https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl。

在 HLSL 中，有几种不同的变量类型，其中在 URP 中常用的是标量、向量和矩阵，还有一些特殊类型，比如纹理 Texture 类型、采样器 Sampler 类型。

常用的数值类型：  
①中等精度 **half** ：16-bit floating point value，常用于方向、模型坐标、HDR 颜色等。部分平台可能不支持，会变为 float；  
②高精度 **float** ：32-bit floating point value，常用于世界坐标、纹理坐标等；  
③**real** ：Unity 定义的精度修饰符，在 URP/HDRP 中使用，如果是移动平台或者是 SWITCH 平台，real 用 half 来代替，否则用 float 来代替。它在 Core RP 下的 Common.hlsl 中定义，ShaderLibrary 中的许多常用数学函数使用此类型；  
④**fixed**：HLSL 不支持。
⑤**int**：32-bit integer，部分平台和 GPU 不支持整数类型。

## ShaderLab SubShader tags
SubShader 支持的 Tags：  

| SubShader 标签名 | 描述 |
| :---- | :---- |
| RenderPipeline | 指定渲染管线。 |
| Queue | 指明渲染队列，表示 shader 在渲染中的顺序，值越小越优先。Background：值为 1000，一般有与远处的背景及天空盒等；Geometry：值为 2000，不透明物体的渲染队列；AlphaTest：值为 2450，需要进行透明度测试的 shader 队列；Transparent：值为 3000，半透明物体渲染队列；Overlay：值为 4000，覆盖屏幕的渲染队列。 |
| RenderType | 对着色器进行分类，主要用于 shader 替换功能。内置的 RenderType 标签有 Opaque、Transparent、TransparentCutout、Background、Overlay、TreeOpaque、TreeTransparentCutout、TreeBillboard、Grass、GrassBillboard。 |
| DisableBatching | 指明 SubShader 是否使用批处理。 |
| ForceNoShadowCasting | 强制不投射阴影。 |
| IgnoreProjector | 指明是否受 Projectors 的影响，Projectors 是 Unity 的一个组件，用于创造一些视觉效果，比如在墙壁上投射涂鸦等等。 |
| PreviewType | 指明材质面板该如何预览材质，默认材质预览为球体，可以设置为 Sphere、Plane、Skybox |
| CanUseSpriteAtlas | 为 false 时，将不会对进入图集的精灵图片进行绘制 |
| UniversalMaterialType | 仅延迟渲染中使用，标识 shader 类型，默认 Lit。可以设置为 Lit、Unlit、SimpleLit、ComplexLit，不知道有什么具体作用，没有找到说明，待补充。 |

## URP ShaderLab Pass tags
URP 不支持以下的 LightMode 标签：Always, ForwardAdd, PrepassBase, PrepassFinal, Vertex, VertexLMRGBM, VertexLM。

如果没有在 Pass 中指定 LightMode 标签，URP 会为该 Pass 默认使用 `SRPDefaultUnlit`。

下表给出了所有的 LightMode 标签：  

| LightMode 标签名 | 描述 |
| :---- | :---- |
| UniversalForward | 渲染物体并计算所有光线贡献，在前向渲染路径中使用 |
| UniversalGBuffer | 渲染 G 缓冲，延迟渲染路径中使用，照明在路径的后续的 Pass 中处理 |
| UniversalForwardOnly | 类似于 UniversalForward，计算光照，可以在前向渲染路径和延迟渲染路径中使用。如果在 URP 使用延迟渲染路径时某个通道必须使用前向渲染路径来渲染对象，请使用该标签 |
| DepthNormalsOnly | 与延迟渲染路径中的 UniversalForwardOnly 结合使用。在延迟渲染路径中，如果缺少具有 DepthNormalsOnly 标签值的通道，则 Unity 不会在网格周围生成环境光遮挡。 |
| Universal2D | 在 2D 渲染中使用该标签 |
| ShadowCaster | 将对象深度渲染到阴影贴图或深度纹理中 |
| DepthOnly | 从摄像机的角度将深度信息渲染到深度纹理中 |
| Meta | Unity 仅在 Unity 编辑器中烘焙光照贴图时执行该通道。Unity 在构建播放器时会从着色器中剥离该通道 |
| SRPDefaultUnlit | 前向渲染路径和延迟渲染路径，Unity 使用该标签作为默认值，使用此标签绘制额外的 Pass，比如绘制对象轮廓线 |
| MotionVectors | 使用该标签添加 motion vector 支持 |  

## 渲染状态设置命令
在 Pass 代码块中使用这些命令可为该 Pass 设置渲染状态，或者在 SubShader 代码块中使用这些命令可为该 SubShader 以及其中的所有 Pass 设置渲染状态：  

| 命令 | 描述 |
| :---- | :---- |
| AlphaToMask | 设置 alpha-to-coverage 模式，该模式可以减少将多样本抗锯齿 (MSAA multisample anti-aliasing) 与使用 Alpha 测试的着色器（如植被着色器）一起使用时出现的过度锯齿。它根据片元着色器结果输出中的 Alpha 值按比例修改多样本覆盖率遮罩。此命令需要与 MSAA 一起使用 |
| Blend | 设置颜色混合类型（混合因子） |
| BlendOp | 设置颜色混合操作的运算符 |
| ColorMask | 设置颜色通道写入遮罩，默认情况下，GPU 写入所有通道 RGBA，对于某些效果可能希望不修改某些通道，比如禁用颜色渲染来渲染无色阴影 |
| Conservative | 启用或禁用保守光栅化 conservative rasterization，保守光栅化是指 GPU 对被三角形部分覆盖的像素进行光栅化，即使只被三角形覆盖一部分。这在需要确定性时很有用，例如在执行遮挡剔除、GPU 上的碰撞检测或可见性检测时。保守光栅化意味着 GPU 在三角形边上生成更多的片元；这会导致更多片元着色器调用，从而导致 GPU 帧时间增加。 |
| Cull | 设置剔除模式，默认背面剔除 |
| Offset | 设置深度缓存的偏移量。调整深度偏差有时可以帮助避免不需要的视觉效果 |
| Stencil | 配置与 GPU 上的模板缓冲区相关的设置。模板缓冲区为帧缓冲区中的每个像素存储一个 8 位整数值。为给定像素执行片元着色器之前，GPU 可以将模板缓冲区中的当前值与给定参考值进行比较。这称为模板测试。如果模板测试通过，则 GPU 会执行深度测试。如果模板测试失败，则 GPU 会跳过对该像素的其余处理。这意味着可以使用模板缓冲区作为遮罩来告知 GPU 要绘制的像素以及要丢弃的像素。 |
| ZClip | 设置深度裁切模式，默认为 True，即裁切比近平面更近的片元和比远平面更远的片元。False 为钳制模式，比近平面更近的片元正好在近平面，而比远平面更远的片元正好在远平面 |
| ZTest | 设置深度测试的条件，深度测试可使具有 “Early-Z” 功能的 GPU 在管线早期拒绝几何体，并确保几何体的正确排序。默认值为 LEqual，即绘制位于现有几何体前面或相同距离的几何体，不绘制位于现有几何体后面的几何体。 |
| ZWrite | 设置深度缓冲写入状态 |


# URP shader 基础框架
下面通过一个非常基础的 URP shader 代码介绍 URP shader 的基础框架：

> 不要管代码块标注的 c，只是为了让代码高亮

``` C
Shader "Example/URPUnlitShaderBasic" {
    Properties {
        [MainColor] _BaseColor("Base Color", Color) = (1, 1, 1, 1)
        [MainTexture] _BaseMap("Base Map", 2D) = "white"{}
    }

    SubShader {
        //SubShader Tags 定义何时以及在何种条件下执行某个 SubShader 代码块或某个 Pass。
        Tags { "RenderType" = "Opaque" "RenderPipeline" = "UniversalPipeline" }

        Pass {
            //声明 Pass 名称，方便调用与识别
            Name "ForwardUnlit" 

            HLSLPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            //Core.hlsl 文件包含常用的 HLSL 宏和函数的定义，还包含对其他 HLSL 文件（例如Common.hlsl、SpaceTransforms.hlsl 等）的 #include 引用。
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            struct Attributes {
                //positionOS 即 position in object space
                float4 positionOS   : POSITION;
                float2 uv           : TEXCOORD0;
                half3 normal        : NORMAL;
            };

            struct Varyings {
                //positionHCS 即 position in homogeneous clip space 齐次裁剪空间
                float4 positionHCS  : SV_POSITION;
                float2 uv           : TEXCOORD0;
                half3 normal        : NORMAL;
            };

            //材质单独声明，使用 DX 风格的新采样方法，下面两个宏都在 Core.hlsl 里面
            //此宏将 _BaseMap 声明为 Texture2D 对象。
            TEXTURE2D(_BaseMap);
            //此宏声明采样器
            SAMPLER(sampler_BaseMap);

            //要使 Unity 着色器 SRP Batcher 兼容，请在名为 UnityPerMaterial 的单个 CBUFFER 代码块中声明与材质相关的所有属性。
            CBUFFER_START(UnityPerMaterial)
                half4 _BaseColor;
                float4 _BaseMap_ST;
            CBUFFER_END

            Varyings vert(Attributes IN) {
                Varyings OUT;
                OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);
                //TRANSFORM_TEX 宏在 Macros.hlsl 定义，用于应用纹理偏移缩放
                OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);
                OUT.normal = TransformObjectToWorldNormal(IN.normal);
                return OUT;
            }

            half4 frag(Varyings IN) : SV_Target {
                //SAMPLE_TEXTURE2D 宏用于纹理采样
                half4 color = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);
                color *= _BaseColor;
                return color;
            }
            ENDHLSL
        }
    }
}
```

## URP Shader 目录结构
我们观察一下 URP 源码的目录结构（在 项目/Liabrary/PackageCache/**com.unity.render-pipelines.universal** 目录下面），可以看到 Shader 代码位于 Shader 目录以及 ShaderLibrary 目录中，其中 Shader 代码主要放在 Shader 目录，HLSL 文件主要放在 ShaderLibrary 目录中。在 Pass 中可以直接插入 HLSL 文件中的代码，下面会详细介绍。

另外，URP 的 Shader 还会引用 SRP Core 这个包中的 ShaderLibrary（在 项目/Liabrary/PackageCache/**com.unity.render-pipelines.core** 目录下面）。这个 SRP Core 提供了 URP/HDRP 共享的一些功能的实现，如果需要自定义一个 SRP，使用这个库也可以大大简化工作。其 ShaderLibrary 中包含了很多基础和核心 Shader 函数以及宏定义。

我们也可以采用官方的目录结构，将主要的 HLSL 的 Pass 代码放置在 ShaderLibrary 文件夹中，然后在 shader 代码中添加 `#include` 指令以及 HLSL 文件的相对地址来插入 HLSL 代码，如下：

        HLSLPROGRAM
		#pragma vertex UnlitPassVertex
		#pragma fragment UnlitPassFragment
		#include "UnlitPass.hlsl"
		ENDHLSL

## include 指令保护
`#include` HLSL 文件和 using 命名空间不同，它直接在指令的位置插入整个文件的内容。有可能会 `#include` 同样的文件两次，从而导致编译错误，为了防止上述情况发生，可以在 HLSL 文件开头添加 include 指令保护：  

        #ifndef CUSTOM_UNLIT_PASS_INCLUDED
        #define CUSTOM_UNLIT_PASS_INCLUDED
        #endif

`#define` 指令理论上可以定义任意标识符 identifier。使用 `#ifndef` 指令来判断代码是否被定义，因为我们只想在没被定义的情况下插入代码。所有在 `#ifndef` 和 `#endif` 之间的代码块会被跳过并且不会被编译，如果该宏已经被定义的话。

我们可以将函数代码放在上述代码块之间，HLSL 文件的简易代码框架如下：  

``` C
#ifndef CUSTOM_UNLIT_PASS_INCLUDED
#define CUSTOM_UNLIT_PASS_INCLUDED

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

CBUFFER_START(UnityPerMaterial) //见下面 Optimizing draw calls
float4 _BaseColor;
CBUFFER_END

float4 UnlitPassVertex(float3 positionOS : POSITION) : SV_POSITION {
    float3 positionWS = TransformObjectToWorld(positionOS.xyz);
    return TransformWorldToHClip(positionWS);
}

float4 UnlitPassFragment () : SV_TARGET {
    return _BaseColor;
}

#endif
```

## Optimizing draw calls

> 这里只是简单介绍一下，详见官方文档：https://docs.unity3d.com/2022.3/Documentation/Manual/optimizing-draw-calls.html ，本文重点关注 URP 代码，故下面主要关注对 shader 代码的影响。

优化 draw call 主要有四个方法：  
①**Draw call batching**：对于使用相同材质的物体，合并 mesh 从而减少 draw call 的一种方式，包括下面两种内置的 draw call batching 方式：  
&emsp;&emsp; - **Static batching**：将静态物体合并为一个大网格；  
&emsp;&emsp; - **Dynamic batching**：在运行时 Unity 自动把符合条件的多个模型网格合并为一个；  
②**SRP Batcher**：对于使用相同 shader 的材质球，减少 CPU 在不同的 draw call 之间的准备工作；  
③**GPU instancing**：对于使用同个材质的多个物体进行一次 draw call 的一种方式。

上述 4 个优化方法的**优先级**是：**SRP Batcher and static batching > GPU instancing > Dynamic batching**。Unity 只会使用优先级最高的方法，除了 SRP Batcher 和 static batching 可以同时使用。

### Dynamic batching
动态批处理是为老的低端设备而设计的。只有当动态批处理产生的 CPU 开销小于 Draw Call 的开销，动态批处理才具有优化性能的效果。而在如今的电子设备上，动态批处理产生的 CPU 开销反而有可能大于 DrawCall 的开销，影响性能。比如，对于 Apple Metal 来说，Draw Call 的开销非常低，所以动态批处理并不能提供性能。

动态批处理对 HDRP 不兼容，其他都兼容。

动态批处理是满足一定条件自动开启的，在运行时 Unity 自动把每一帧画面里符合条件的多个模型网格合并为一个，在 CPU 中将所有顶点转换到世界空间。

其他可能需了解的内容的关键词如下，详见官方文档：  
①MaterialPropertyBlock：一种使用相同材质但是不同材质属性的方法，不影响批处理，但是不与 SRP Batcher 兼容；  
②如果物体使用相同材质但是不同的纹理贴图，可以使用纹理图集 Texture atlases 技术将不同纹理合并为一个更大的纹理，从而使用一个材质；  
③通过 C# 脚本修改材质，请使用 Renderer.sharedMaterial 以保持批处理，Renderer.material 创建材质的复制；  
④可以使用 Mesh.CombineMeshes 手动合并网格；  
⑤对于不同材质的相同的 shadows caster pass，Unity 可以使用动态批处理。

### Static batching
静态批处理将静态物体合并为一个大网格，只使用一个 draw call 画出所有合并的网格。静态批处理比动态批处理效率更高，因为它不需要在 CPU 上转换顶点，但是需要占据更多的 CPU 内存。这段话虽然是官方文档说法，但是不太准确，下面更加准确：

静态批处理不一定减少 DrawCall，但是会让 CPU 在“设置渲染状态-提交 Draw Call”上更高效；Unity 将静态物体合并为一个(或多个)大网格，这个(或这些)大网格以 vertex buffers 和 index buffers 的形式存储在 GPU 上；Unity 按顺序绘制场景中的物体时，如果两个物体的数据属于同一块 buffer，且在 vertex buffer 和 index buffer 上连续，那么这两个物体仅产生 1 次 DrawCall；如果它们不连续，那么将产生 2 次 DrawCall(specify different regions of this buffer)；但是由于它们属于同一块 buffer，因此这 2 次 DrawCall 之间的 GPU 状态不发生改变，它们构成 1 次 StaticBatch；虽然没有降低 DrawCall 次数，但是避免了重复的 "buffer binding"。

静态批处理对内置管线、URP、HDRP 和自定义 SRP 都兼容。

### SRP Batcher
SRP Batcher 适用于使用不同材质的物体，但这些材质使用相同的 Shader（确切地说是 Shader Variant）。

顾名思义 SRP 才支持。在 URP 项目中，这一项是默认开启的，可以找到 URP Asset，可以看到 SRP Batcher 的选项是默认开启的，默认情况下该选项是被隐藏的，可以在 Edit -> Preferences -> Core Render Pipeline 中把 Visibility 改为 All Visible。

被渲染的物体需要满足兼容性：  
①被渲染的物体必须是 mesh 或 skinned mesh，不可以是 particle；  
②被渲染的物体不能使用 MaterialPropertyBlock 修改属性，MaterialPropertyBlock 不支持 SRP Batcher；  
③Shader 需要支持 SRP Batcher，见下面。

要想 Shader 使用 SRP Batcher 必须满足 SRP Batcher compatibility 条件：  
①在一个名为 **UnityPerDraw** 的 **CBuffer** (constant buffer) 中声明所有内置属性，比如 unity_ObjectToWorld；  
②在一个名为 **UnityPerMaterial** 的 **CBuffer** (constant buffer) 中声明所有材质属性。  
可以在 Shader 的 Inspector 面板中，看到 SRP Batcher 的兼容性状态。

> UnityPerDraw 这部分内容 URP 的 Core.hlsl 都帮我们做好了，若引入了 Core.hlsl 理论上不用关心这部分内容，只需要在自己的 Shader 里关心 UnityPerMaterial 这部分就行。若要编写自己的 Custom SRP，则需要自己加入 UnityPerDraw，即对一些内置的 Unity 自动更新的矩阵进行定义（比如 unity_ObjectToWorld，这些矩阵每次 draw call 都会被 GPU 设置），可以参考 URP 的 Core.hlsl -> Input.hlsl -> UnityInput.hlsl。

    CBUFFER_START(UnityPerDraw)
    float4x4 unity_ObjectToWorld;
    float4x4 unity_WorldToObject;
    float4 unity_LODFade;
    real4 unity_WorldTransformParams;
    CBUFFER_END

    CBUFFER_START(UnityPerMaterial)
    float4 _BaseColor;
    CBUFFER_END

SRP Batcher 主要减少不同 draw call 之间的渲染状态转换。原本，CPU 每次提交 Draw Call 前都要 Set up Cbuffer - Upload Cbuffer，但是在 SRP Batcher 里，所有材质球在显存里占有固定的 CBuffer，如果材质球的内容不发生改变，CPU 就不需要 Set Up - Upload，从而降低了 CPU 渲染时间。

### GPU instancing
GPU instancing 适用于处理大量相同物体（同一 Mesh 和同一 Material），比如建筑物/树/草等重复出现的物体。注意 GPU instancing 和 SRP Batcher 不兼容。若要使用 GPU instancing 需要移除 SRP Batcher 兼容性，否则根据优先级，Unity 会自动选择 SRP Batcher。

要想使用 GPU instancing 需要满足以下条件：  
①材质的 Shader 需要支持 GPU instancing，见后面；    
②网格必须有一个 MeshRenderer 组件，或是由 Graphics.DrawMesh 产生，或是由 Graphics.DrawMeshInstanced、Graphics.DrawMeshIndirect 产生。不支持 SkinnedMeshRenderer；  

GPU instancing 允许实例物体具有不同的 Transform，但如果想要创建更多的变体，比如不同颜色的变体，你需要修改 shader 添加 pre-instance 属性。自定义的 shader 没有 pre-instance 的数据，需要使用 `UNITY_SETUP_INSTANCE_ID` 添加一个实例 ID，表面着色器会自动创建实例 ID，然后在脚本中通过 MaterialPropertyBlock 修改实例的颜色。

创建支持 GPU instancing 的 Shader 的步骤如下：  
**①**第一步在 shader 的顶点和片元着色器的指令前添加 `#pragma multi_compile_instancing`

        #pragma multi_compile_instancing
        #pragma vertex UnlitPassVertex
        #pragma fragment UnlitPassFragment

这会让 Unity 生成两个 shader 变体，一个支持 GPU instancing 一个不支持，我们可以在材质的 inspector 面板中选择是否 **Enable GPU instancing** 让材质使用相应的 shader。

**②**支持 GPU instancing 需要引入 core shader library 的 UnityInstancing.hlsl 文件，但是若引入 URP 的 Core.hlsl，则不需要再重复引入了，因为 Core.hlsl 都帮我们处理好了，可以在 Core.hlsl 引入的 Input.hlsl 最下面看到以下代码：  

        #define UNITY_MATRIX_M unity_ObjectToWorld
        ...

        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/UnityInput.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"

        ...

        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"

**③**UnityInstancing.hlsl 的工作包括对矩阵相关宏进行重定义使其可以被替换为 instanced data arrays。但是为了让其工作，还需知道当前渲染物体的索引，因为不同实例的变换矩阵不同，这些索引需要在顶点着色器的输入结构中被提供，我们只需将 `UNITY_VERTEX_INPUT_INSTANCE_ID` 放在 Attributes 结构中，如下：  

        struct Attributes {
            float3 positionOS : POSITION;
            UNITY_VERTEX_INPUT_INSTANCE_ID
        };

**④**然后在定制着色器函数的开头添加 `UNITY_SETUP_INSTANCE_ID(input);`，这会提取 input 中的索引并把它存储为一个全局静态变量，让其他 instancing 的宏使用它，如下：  

        float4 UnlitPassVertex (Attributes input) : SV_POSITION {
            UNITY_SETUP_INSTANCE_ID(input);
            float3 positionWS = TransformObjectToWorld(input.positionOS);
            return TransformWorldToHClip(positionWS);
        }

**⑤**为了取消 SRP batcher 兼容性，我们还需要修改 CBUFFER，替换为 `UNITY_INSTANCING_BUFFER_START` 和 `UNITY_INSTANCING_BUFFER_END`，从而支持  per-instance material data。还要替换属性声明，比如 _BaseColor 替换为 `UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)` ：   

        UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)
            UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)
        UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)

**⑥**接下来是为了让片元着色器也能获取到实例索引，我们需要在顶点着色器的输出结构添加 `UNITY_VERTEX_INPUT_INSTANCE_ID`，并且在顶点着色器中使用 `UNITY_TRANSFER_INSTANCE_ID(input, output);` 来复制索引：  

        struct Varyings {
            float4 positionCS : SV_POSITION;
            UNITY_VERTEX_INPUT_INSTANCE_ID
        };

        Varyings UnlitPassVertex (Attributes input) {
            Varyings output;
            UNITY_SETUP_INSTANCE_ID(input);
            UNITY_TRANSFER_INSTANCE_ID(input, output);
            float3 positionWS = TransformObjectToWorld(input.positionOS);
            output.positionCS = TransformWorldToHClip(positionWS);
            return output;
        }

**⑦**最后，在片元着色器中使用 `UNITY_SETUP_INSTANCE_ID(input);` 让索引可用。材质的属性现在需要通过 `UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor);` 获取：  

        float4 UnlitPassFragment (Varyings input) : SV_TARGET {
            UNITY_SETUP_INSTANCE_ID(input);
            return UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor);
        }

# 透明效果
## 透明度混合
首先在 SubShader 的 Tags 里把渲染队列设为 Transparent：`"Queue" = "Transparent"`。可以在材质添加 _SrcBlend 和 _DstBlend 属性，以及深度写入 Zwrite 的开关属性，如下：  

        Properties {
            _BaseColor("Color", Color) = (1.0, 1.0, 1.0, 1.0)
            [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend ("Src Blend", Float) = 1
            [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend ("Dst Blend", Float) = 0
            [Enum(Off, 0, On, 1)] _ZWrite ("Z Write", Float) = 1
        }

`[Enum(UnityEngine.Rendering.BlendMode)]` 特性可以让我们在材质面板中选择混合模式，不透明的 _SrcBlend 为 1，_DstBlend 为 0；一般透明度混合，_SrcBlend 为 ScrAlpha，_DstBlend 为 OneMinusSrcAlpha。详见 Unity Shader 入门精要。

然后在 Pass 中添加混合命令，以及深度写入开关命令：  

        Blend [_SrcBlend] [_DstBlend]
        ZWrite [_ZWrite]

## 透明度测试
添加 _Cutoff 阈值属性：  

        _Cutoff ("Alpha Cutoff", Range(0.0, 1.0)) = 0.5

别忘了在 CBuffer 里声明属性。接下来在片元着色器用 Clip 函数进行裁切：  

        clip(_BaseColor.a - _Cutoff)

我们可以在材质属性中添加 `Toggle` 特性来控制一个 _CLIPPING 关键字，该特性让我们可以选择是否开启透明度测试：  

        [Toggle(_CLIPPING)] _Clipping ("Alpha Clipping", Float) = 0

如果在材质面板中开启了透明度测试，就会自动添加 _CLIPPING 关键字到材质的激活的关键字表里，关闭就去除。我们可以根据关键字是否被定义，来告诉 Unity 编写不同的 shader。首先我们需要在 Pass 中添加 `#pragma shader_feature _CLIPPING` 指令：  

        #pragma shader_feature _CLIPPING

这样 Unity 就可以根据 _CLIPPING 是否被定义来编译 shader 代码，然后修改 Clip 函数：  

        #if defined(_CLIPPING)
            clip(_BaseColor.a -  _Cutoff);
        #endif

## 实践
①新建一个名为 Transparency.shader 的 shader 文件，代码如下：  

``` C
Shader "Custom/Transparency"
{
    Properties
    {
        [Header(Base)] //在材质面板中插入标题
        [Space(12)] //在材质面板中插入多行空行
        _BaseColor("Base Color", Color) = (1, 1, 1, 1)
        _BaseMap("Base Map", 2D) = "white"{}
        
        [Header(Transparency)] //在材质面板中插入标题
        [Space(12)] //在材质面板中插入多行空行
        [Toggle(_CLIPPING)] _Clipping ("Alpha Clipping", Float) = 0 //开关透明度测试
        _Cutoff("Alpha CutOff", Range(0.0, 1.0)) = 0.5 //裁切阈值
        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend ("Src Blend", Float) = 1 //混合因子
        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend ("Dst Blend", Float) = 0 //混合因子
        [Enum(Off, 0, On, 1)] _ZWrite ("Z Write", Float) = 1 //开关深度写入
    }

    SubShader
    {
        Tags { "RenderType" = "Transparent" "RenderPipeline" = "UniversalPipeline" "Queue" = "Transparent" } //渲染队列为 Transparent
        LOD 100

        Pass
        {
            Name "TransparencyForwardUnlit" //Pass 命名
            
            Blend [_SrcBlend] [_DstBlend] //混合命令
            ZWrite [_ZWrite] //深度写入开关
            
            HLSLPROGRAM

            #pragma shader_feature _CLIPPING //控制 shader 变体
            #pragma vertex vert
            #pragma fragment frag

            #include "Assets/ShaderLibrary/TransparencyPass.hlsl" //引入 HLSL 文件，见下面
            
            ENDHLSL
        }
    }
}
```

②在 ShaderLibrary 创建名为 TransparencyPass.hlsl 的 HLSL 文件，代码如下：  

``` C
#ifndef CUSTOM_UNLIT_PASS_INCLUDED
#define CUSTOM_UNLIT_PASS_INCLUDED

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

struct Attributes
{
    float4 positionOS   : POSITION;
    float2 uv           : TEXCOORD0;
};

struct Varyings
{
    float4 positionHCS  : SV_POSITION;
    float2 uv           : TEXCOORD0;
};

TEXTURE2D(_BaseMap);
SAMPLER(sampler_BaseMap);

CBUFFER_START(UnityPerMaterial)
half4 _BaseColor;
float4 _BaseMap_ST;  //别忘了这个
float _Cutoff;
CBUFFER_END

Varyings vert(Attributes IN) {
    Varyings OUT;
    OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);
    OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);
    return OUT;
}

half4 frag(Varyings IN) : SV_Target {
    half4 color = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv); //纹理采样
    color *= _BaseColor;

    #if defined(_CLIPPING)
        clip(color.r -  _Cutoff); //这里选择 r 是因为希望根据纹理的颜色来裁切
    #endif

    return color;
}

#endif
```

这样就得到了一个包含了透明度混合和透明度测试的 Shader，材质面板如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2024/02/24/fFWhj2K1R7vkYCL.jpg" width = "60%" height = "60%" alt="图1 - 包含透明度混合和透明度测试的材质"/>
</div>

我选择的是一张**高斯噪声纹理 Gaussian Noise**，我让纹理颜色与基础颜色相乘后若小于 0.85 则被裁切掉，透明度混合是基础的 ScrAlpha 和 OneMinusScrAlpha 即根据 Alpha 值混合，关闭深度写入防止渲染错误，效果如下：  

<div  align="center">  
<img src="https://s2.loli.net/2024/02/24/GFzAeuNrxDbgOyo.png" width = "70%" height = "70%" alt="图2 - 透明度混合和透明度测试的效果"/>
</div>

# GPU instancing 实践
接下来根据上面的实践的 shader，改造为使用 GPU instancing 的 shader。TransparencyGPUInstancing.shader 的代码如下：

``` C
Shader "Custom/TransparencyGPUInstaning"
{
    Properties
    {
        [Header(Base)]
        [Space(12)]
        _BaseColor("Base Color", Color) = (1, 1, 1, 1)
        _BaseMap("Base Map", 2D) = "white"{}
        
        [Header(Transparency)]
        [Space(12)]
        [Toggle(_CLIPPING)] _Clipping ("Alpha Clipping", Float) = 0
        _Cutoff("Alpha CutOff", Range(0.0, 1.0)) = 0.5
        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend ("Src Blend", Float) = 1
        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend ("Dst Blend", Float) = 0
        [Enum(Off, 0, On, 1)] _ZWrite ("Z Write", Float) = 1
    }
    SubShader
    {
        Tags { "RenderType" = "Transparent" "RenderPipeline" = "UniversalPipeline" "Queue" = "Transparent" }
        LOD 100
        
        Pass
        {
            Name "TransparencyGPUInstaningForwardUnlit"
            
            Blend [_SrcBlend] [_DstBlend]
            ZWrite [_ZWrite]
            
            HLSLPROGRAM
            
            #pragma shader_feature _CLIPPING
            #pragma multi_compile_instancing //生成支持或不支持 GPU instancing 的 shader 变体
            #pragma vertex vert
            #pragma fragment frag

            #include "../ShaderLibrary/TransparencyGPUInstaningPass.hlsl"
            
            ENDHLSL
        }
    }
}
```

上述 Shader 中引入的 TransparencyGPUInstaningPass.hlsl 代码如下：  

``` C
#ifndef CUSTOM_UNLIT_PASS_INCLUDED
#define CUSTOM_UNLIT_PASS_INCLUDED

//引入 Core.hlsl 了就不需要重复引入 UnityInstancing.hlsl 了
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

struct Attributes
{
    float4 positionOS   : POSITION;
    float2 uv           : TEXCOORD0;
    UNITY_VERTEX_INPUT_INSTANCE_ID //为顶点着色器的输入输出结构定义 instance ID
};

struct Varyings
{
    float4 positionHCS  : SV_POSITION;
    float2 uv           : TEXCOORD0;
    UNITY_VERTEX_INPUT_INSTANCE_ID //使用这个是为了在片元着色器获取 instanced 属性
};

TEXTURE2D(_BaseMap);
SAMPLER(sampler_BaseMap);

UNITY_INSTANCING_BUFFER_START(UnityPerMaterial) //声明 per-instance 的 CBuffer
    UNITY_DEFINE_INSTANCED_PROP(half4, _BaseColor) //定义 per-instance 的属性
    UNITY_DEFINE_INSTANCED_PROP(float4, _BaseMap_ST)
    UNITY_DEFINE_INSTANCED_PROP(float, _Cutoff)
UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)

Varyings vert(Attributes IN) {
    Varyings OUT;
    UNITY_SETUP_INSTANCE_ID(IN); //允许着色器函数获取 instance ID
    UNITY_TRANSFER_INSTANCE_ID(IN, OUT); //从输入结构复制 instance ID 到输出结构
    OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);
    float4 baseST = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseMap_ST); //获取 per-instance 属性
    OUT.uv = IN.uv * baseST.xy + baseST.zw;
    return OUT;
}

half4 frag(Varyings IN) : SV_Target {
    UNITY_SETUP_INSTANCE_ID(IN); //允许着色器函数获取 instance ID
    half4 mapColor = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);
    half4 baseColor = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor); //获取 per-instance 属性
    half4 color = half4(mapColor.rgb * baseColor.rgb, baseColor.a);

    #if defined(_CLIPPING)
    clip(mapColor.r -  UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Cutoff)); //获取 per-instance 属性
    #endif

    return color;
}

#endif
```

这样子材质部分就准备好了，接下来为了方便生成大量的物体，并生成不同的颜色，使用了下面的脚本代码（MeshBall.cs）：  

``` C#
using UnityEngine;

public class MeshBall : MonoBehaviour
{
    private static int baseColorId = Shader.PropertyToID("_BaseColor"); //找到 _BaseColor 材质属性的 ID，每个 shader 属性都有个独特的数字 ID，并在游戏中保持不变。
    
    [SerializeField]
    private Mesh mesh; //要生成的 mesh
    
    [SerializeField]
    private Material material; //要生成的 mesh 的材质
    
    //为了生成 1023 个实例，我们需要告诉 Unity 它们的变换矩阵和颜色
    private Matrix4x4[] matrices = new Matrix4x4[1023];
    private Vector4[] baseColors = new Vector4[1023];

    //MaterialPropertyBlock 适用于需要画出使用相同材质但不同材质属性的多个物体，传递给 Graphics.RenderMesh 或 Renderer.SetPropertyBlock 时会被复制，所以创建一个 block 一直复用最佳。我们使用它来传递颜色数组。
    private MaterialPropertyBlock block;

    void Awake()
    {
        for (int i = 0; i < matrices.Length; i++)
        {
            //使用 Matrix4x4.TRS 创建了一个在半径十米的球内的随机位置的，无旋转和缩放的变换矩阵
            matrices[i] = Matrix4x4.TRS(Random.insideUnitSphere * 10f, Quaternion.identity, Vector3.one ); 
            //随机颜色
            baseColors[i] = new Vector4(Random.value, Random.value, Random.value, Random.value);
        }
    }
    
    void Update () {
        if (block == null) {
            block = new MaterialPropertyBlock();
            block.SetVectorArray(baseColorId, baseColors); //设置颜色到 block
        }

        //画出使用 GPU Instancing 的大量相同 mesh，并赋予材质、变换矩阵、数量以及材质属性块
        Graphics.DrawMeshInstanced(mesh, 0, material, matrices, 1023, block);
    }
}
```

把该代码赋给任意空物体上，如下：  

<div  align="center">  
<img src="https://s2.loli.net/2024/02/25/FXb9O6YrP34jem7.jpg" width = "70%" height = "70%" alt="图3 - 附上 mesh 和材质后的 MeshBall.cs"/>
</div>

在材质上别忘了开启 GPU Instancing：  

<div  align="center">  
<img src="https://s2.loli.net/2024/02/25/btBDClwi64aYVq7.jpg" width = "70%" height = "70%" alt="图4 - 勾选 Enable GPU Instancing"/>
</div>

运行游戏效果如下：  

<div  align="center">  
<img src="https://s2.loli.net/2024/02/25/4PqBzvnHjCu2pNO.png" width = "90%" height = "90%" alt="图5 - 1023 个透明球体"/>
</div>

<div  align="center">  
<img src="https://s2.loli.net/2024/02/25/evZMxzK3yJQbm24.jpg" width = "50%" height = "50%" alt="图6 - 画这些透明物体只使用了 3 个 draw call"/>
</div>


# 光照
## URP 光照机制
在 URP 中，**主光源 Main Light** 和**附加光源 Additional Lights** 模式替代了之前内置渲染管线的 Important 和 Not Important 的光源。我们可以在 Universal Render Pipeline Asset -> Lighting 里看到 Main Light 和 Additional Lights 的设置。

URP 的默认渲染路径为前向渲染路径 Forward Rendering Path，可以在 Universal Renderer Data （也在 Settings 文件夹）里修改渲染路径，支持**前向渲染路径 Forward Rendering Path**、**前向+ 渲染路径 Forward+ Rendering Path**、**延迟渲染路径 Deferred Rendering Path**。

前向渲染路径默认每个物体最多支持 9 个实时光照，其中包括 1 个主光源、8 个额外的光源，其中额外的光源受到渲染管线资产里的 Per Object Limit 的限制。这些光源默认都是逐像素光源，当然也可以在渲染管线资产里设置。而 Forward+ 和 Deferred 渲染路径不受 Per Object Limit 的限制，即理论上可以支持无限数量的光照，但是受到 per-Camera limit 的限制，per-Camera limit 根据平台不同而不同。

在 URP 中主光源和附加光源都可以在一个 Pass 中完成，即 `Tags {"LightMode" = "UniversalForward"}`，而不像在内置渲染管线中，需要使用多个 Pass。

## 主光源渲染

光照渲染的本质就是，让 Shader 拿到光照的数据，根据光照数据来计算片元的颜色，最后输出结果。URP 渲染管线中 Unity 会通过 CPU 把光源数据传递给 GPU，Unity 把这些工作都封装好了，我们只要在我们的 Shader 中获取 URP 内置的光照变量即可。

为了获取到光照变量，使用一些内置的光照和阴影（阴影后面讲）函数，我们需要在 Pass 中引入 URP 的 Lighting.hlsl 文件：  

    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
    #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl" //包含了光照和阴影相关变量和函数

打开 Lighting.hlsl 引入的 RealtimeLights.hlsl 文件，我们可以看到光照变量的结构体：  

    struct Light
    {
        half3   direction;
        half3   color;
        float   distanceAttenuation;
        half    shadowAttenuation;
        uint    layerMask;
    };

以及一个获取光照变量的重要函数 `GetMainLight()`：  

    Light GetMainLight()
    {
        Light light;
        light.direction = half3(_MainLightPosition.xyz);
    #if USE_FORWARD_PLUS
    #if defined(LIGHTMAP_ON) && defined(LIGHTMAP_SHADOW_MIXING)
        light.distanceAttenuation = _MainLightColor.a;
    #else
        light.distanceAttenuation = 1.0;
    #endif
    #else
        light.distanceAttenuation = unity_LightData.z; // unity_LightData.z is 1 when not culled by the culling mask, otherwise 0.
    #endif
        light.shadowAttenuation = 1.0;
        light.color = _MainLightColor.rgb;

        light.layerMask = _MainLightLayerMask;

        return light;
    }

所以要渲染主光源，可以在自己的 Shader 里声明 Light 结构体然后使用 `GetMainLight()` 获取光照变量。

---

接下来是实践内容，制作一个漫反射为 Lambert，高光为 Blinn-Phong 的简单光照 Shader。  
①新建一个名为 LambertBlinnPhongLit.shader 的 Shader 文件：  

``` C
shader "Custom/LambertBlinnPhongLit"
{
    Properties
    {
        [Header(Base Color)] [Space(10)]
        [MainColor] _BaseColor ("Base Color", Color) = (1,1,1,1)
        [MainTexture] _BaseMap ("Base Map", 2D) = "white" {}
        
        [Header(Specular)] [Space(10)]
        _Gloss("Gloss", Range(8.0, 512.0)) = 10
        _SpecColor("Specular Color", Color) = (0.5, 0.5, 0.5)
    }
    SubShader
    {
        Tags 
        { 
            "RenderType" = "Opaque" 
            "RenderPipeline" = "UniversalPipeline" 
            "Queue" = "Geometry"
            "IgnoreProjector" = "True"
        }
        
        LOD 100

        Pass
        {
            Name "LambertBlinnPhongForwardLit"
            
            Tags { "LightMode" = "UniversalForward" } //必须写上这个
            
            HLSLPROGRAM
            #pragma vertex LambertBlinnPhongVert
            #pragma fragment LambertBlinnPhongFrag

            #include "Assets/ShaderLibrary/LambertBlinnPhongLitPass.hlsl"
            ENDHLSL
        }
    }
}
```

② LambertBlinnPhongLitPass.hlsl 的代码如下：  
