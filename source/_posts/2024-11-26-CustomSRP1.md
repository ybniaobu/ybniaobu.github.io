---
title: Unity Custom SRP（一）
date: 2024-11-26 12:43:30
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2024/11/26/zxA7bEi36HYDQKP.gif
description: 
---

> 本文章是关于 Unity 的**自定义可编程渲染管线**的入门基础，即 **SRP (Scriptable Rendering Pipeline)**，主要参考了著名的教程 https://catlikecoding.com/ 的 Custom SRP Tutorial，以及知乎上各位图形学大神们的文章。

# 基础概念介绍
## SRP 和 CommandBuffer
Unity 的 **CommandBuffer** 是一个渲染命令列表，类似于 DirectX 中的**命令列表 Command list**，它们的作用主要是为了 CPU 与 GPU 间的交互。每个 GPU 都至少有一个**命令队列 Command queue**，借助图形 API（比如 Direct3D），CPU 可以利用**命令列表 Command list** 将命令提交到这个队列中。所以 Unity 的 SRP 可以理解为是对图形 API 的封装，并提供了 C# 调用接口。我们使用 C# 脚本来配置渲染命令，告诉 Unity C++ 底层图形框架去执行这些命令，然后 Unity 底层再传递指令给图形 API。

而在 SRP 中，连接 C# 渲染管线代码和底层 C++ 图形框架的正是 **ScriptableRenderContext** 类。SRP 渲染工作使用的是延迟执行，我们使用 `ScriptableRenderContext.ExecuteCommandBuffer` 将 CommandBuffer 队列信息缓存到 ScriptableRenderContext 中，最后 `ScriptableRenderContext.Submit` 集中提交绘制指令。

一个简易的渲染流程图如下：  

<div  align="center">  
<img src="https://s2.loli.net/2024/11/26/hwqQCckXT4eUOn1.png" width = "30%" height = "30%" alt="图1 - 简易渲染流程"/>
</div>

## RenderTarget
**渲染目标 RenderTarget** 是现代图形处理单元 GPU 的一个特征，它允许将 3D 场景渲染到中间存储缓冲区或**渲染目标纹理 RenderTargetTexture（RTT）**，而不是帧缓冲区或后缓冲区。然后可以通过像素着色器操纵此 RTT ，以便在显示最终图像之前将其他效果应用于最终图像。

而**延迟渲染 Deferred Rendering** 正是得益于硬件对于**多重渲染目标 Multiple Render Target（MRT）** 的支持。其核心在于 **G-Buffer** ，延迟渲染将计算光照的参数渲染至 G-Buffer 中，也就是若干张纹理贴图，通常包含了 Depth，Normal，Albedo，Roughness，Specular 和 Metallic。最后将上述几张贴图进行相关计算混合，生成了游戏中的一帧。

# 创建基本的自定义 SRP
## 前置工作
①切换色彩空间：在 Edit -> Project Settings -> Player -> Other Settings -> Color Space 中选择 Linear。  
②在 PackageManager 下载 Core RP Library，这个包里有一些可以重复利用的代码来帮助我们创建自己的渲染管线。

## 创建管线资产和实例
要创建基于 SRP 的自定义渲染管线，项目中必须包含以下三个要素：  
①需要有一个脚本继承自 `RenderPipelineAsset` 并覆写它的 `CreatePipeline()` 方法，这个脚本定义了**渲染管线资产 Render Pipeline Asset**；  
②需要有一个脚本继承自 `RenderPipeline` 并覆写它的 `Render()` 方法，这个脚本定义了**渲染管线实例 Render Pipeline Instance**，同时也是写自定义渲染代码的入口；  
③一个从第一步的脚本创建出来的渲染管线资产，这个资产作为创建渲染管线实例的工厂。

首先第一步：创建一个名为 XXRenderPipelineAsset 的 C# 脚本：  

``` C#
using UnityEngine;
using UnityEngine.Rendering;

[CreateAssetMenu(menuName = "XXXX/XXRenderPipelineAsset")]
public class XXRenderPipelineAsset : RenderPipelineAsset
{
    protected override RenderPipeline CreatePipeline() 
    {
        return new XXRenderPipeline();
    }
}
```

Unity 在渲染第一帧前会调用 `CreatePipeline()` 方法，如果 Render Pipeline Asset 的设置发生了改变，Unity 会释放当前的 Render Pipeline Instance 并在下一帧渲染前重新调用这个方法。而这个 Render Pipeline Asset 则是一个存储渲染设置的地方，只不过这里暂时还没有设置，我们可以在 Render Pipeline Asset 存储一些信息以便 Render Pipeline Instance 使用。

第二步：创建一个名为 XXRenderPipeline 的 C# 脚本：  

``` C#
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

public class XXRenderPipeline : RenderPipeline
{
    public XXRenderPipeline() {}

    protected override void Render(ScriptableRenderContext context, Camera[] cameras) 
    {
        // Older version of the Render function that can generate garbage, needed for backwards compatibility
    }

    protected override void Render(ScriptableRenderContext context, List<Camera> cameras) {}
}
```

这个 `Render()` 方法就是我们自定义渲染循环 render loop 的入口，这个方法接受一个 ScriptableRenderContext 和摄像机数组。我们可以看到两个 `Render()` 方法，一个接受摄像机数组，一个接受集合中的列表。而接受摄像机数组的方法由于会因为数组长度变化而造成堆分配的原因而不推荐使用，所以我们使用那个接受摄像机列表的 `Render()` 方法。但是即使我们不使用接受摄像机数组的 `Render()` 方法，我们仍然需要覆写它，因为它是一个抽象方法。

第三步：根据第一步脚本自己设定的 AssetMenu 位置，在项目中右键创建自己的渲染管线资产 XXRenderPipelineAsset，并在 Edit -> Project Settings -> Graphics -> Default Render Pipeline 中替换为自己的渲染管线资产 XXRenderPipelineAsset。此时屏幕会全黑，因为我们还没有设置任何东西，无法渲染。

## 创建渲染循环
Unity 会在渲染的每一帧调用 Render Pipeline Instance 的 `Render()` 方法，并传递一个 ScriptableRenderContext 结构体，用于连接 Unity C++ 底层，以及 Cameras 列表。通过传递过来的 Cameras 列表，可以使用一个循环遍历所有摄像机对 ScriptableRenderContext 进行绘制。

