---
title: 屏幕空间环境光遮蔽（一）SSAO
date: 2025-08-01 12:54:23
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2025/08/01/287gfDiMYRFrmUs.gif
mathjax: true
description: XXXXXXXXXXXXXXXXXXXXXX
---

> 终于要进入**全局光照 Global Illumination** 的领域了，之前 YPipeline 能够使用的全局光照技术基本只有 **IBL** 和 **Light Map**。Unity 的 Progressive Lightmapper 在离线烘焙 Light Map 时理论上应该隐式地包含了因遮挡导致的环境光减弱的 AO 效果，所以若使用了 Light Map 是不需要使用 SSAO 的，而且 Progressive Lightmapper 也提供了 AO 的烘焙，可以额外开启加强 AO 效果。但是若只使用 IBL (Light Probe)，它只为场景添加了一个整体的颜色或者均匀的光照，但是没有考虑因遮挡导致的暗处或光线衰减，所以整体呈现的效果会让玩家在一定程度上感到不真实或不可信。而**环境光遮蔽 Ambient Occlusion (AO)** 通过描绘物体之间由于遮挡而产生的阴影可以更好地增强场景的可信度和立体感，是一个非常不错的补充 IBL 环境光的方式。IBL (Light Probe) + SSAO 的组合可以说是一种较为廉价的全局光照效果，一般对于小作坊的简陋的 3D 游戏来说肯定是足够了的。  
> 
> 其实我原来并不想先补充学习屏幕空间环境光遮蔽相关技术，想直接一步到位进入 SSGI 的学习，但是我后来看到 https://github.com/cdrinmatane/SSRT3 实现的 SSGI 借鉴了 GTAO 的思想，实现效果看得我非常心动，所以为了巩固基础，先实现 SSAO 相关算法。

# Ambient Occlusion 介绍
以下内容主要参考了《Real-Time Rendering, Fourth Edition》的 Chapter 11 Global Illumination。  

## 理论基础
**环境光遮蔽 Ambient Occlusion** 最早是由**工业光魔**（又是你乔治卢卡斯）在电影《珍珠港》中为提高计算机生成飞机的环境光照质量所开发的。尽管环境光遮蔽是对光照物理效果进行了很大程度地简化，但是所呈现的效果往往能极大地增加可信度。当光源较为均匀，无法展现物体细节时，这种廉价方法可以提供对于物体形状的视觉暗示。

量化环境光遮蔽的理论背景就是反射方程，相关知识忘了详见[《GAMES101-图形学入门公开课笔记（二）》](https://ybniaobu.github.io/2024/04/23/2024-04-23-GAMES_101_2/)第十四课和第十五课。因为环境光遮蔽估计的是整个半球内的光照可见性，所以要基于表面 irradiance ($\,E\,$) 计算，表面 irradiance 是所有入射 radiance 的余弦加权积分。同时假设所有入射方向 $\,\omega_{i}\,$ 或 $\,l\,$ 上的 radiance 都是相同且恒定的，这样子计算表面 irradiance，即 $\,E(p)\,$ ，的方程和积分结果如下：  

$$ E(p) = \int_{\Omega} L_i (n \cdot l) dl = \pi L_i $$

上述方程没有考虑可见性问题，在着色点半球范围内的某些方向，可能会被自身物体的其他部分或者是场景中的其他物体所遮挡。为了简单起见，我们假设来自这些遮挡方向上的入射 radiance 为零，这个假设忽略了场景中可能会被其他物体反弹，并最终从这些遮挡方向到达点 p 的光线，但是它极大地简化了推理过程。基于上述假设，补充可见性后，可以得到下述方程：  

$$ E(p) = L_i \int_{\Omega} v(p,l) (n \cdot l) dl = k_{AO}(p) \pi L_i $$

$\,v(p,l)\,$ 是一个**可见性函数**，如果从点 p 向方向 l 投射的光线会被物体遮挡，则该函数值为 0，反之为 1。而 $\,k_{AO}(p)\,$ 则为**环境遮挡系数**，它的范围位于 \[0, 1\] 内，根据上述公式，环境遮挡系数可以被量化为：  

$$ k_{AO}(p) = \cfrac{1}{\pi} \int_{\Omega} v(p,l) (n \cdot l) dl $$

注意，表面的朝向会影响到 $\,k_{AO}(p)\,$ 的数值，因为可见性函数 $\,v(p,l)\,$ 会被余弦加权。若某表面大部分未遮挡区域都位于其表面法线的两端，因此该位置的余弦因子相对较小，$\,k_{AO}(p)\,$ 也会相对较小。还有一点，环境遮挡系数的名称可能会造成一定的误解，它本质上应该是可见性系数，因为它是对可见性函数（未遮挡为 1）的余弦加权积分。

## 环境法线 Bent Normal
除了环境遮挡系数，还有个概念叫做**环境法线 Bent Normal**，首先它是个方向向量，且是未遮挡方向的余弦加权平均值。在计算环境光着色时，可以使用它来代替几何法线，从而提供更加准确的全局光照结果，同时不需要额外的性能开销。注意，环境法线包含了遮挡信息，使用环境法线采样全局光照（IBL）后，理论上不应该再使用其他环境光遮蔽算法，当然实际上还得看美术需求。环境法线的计算公式如下：  

$$ n_{bent} = \cfrac { \int_{\Omega} l\cdot v(p,l) (n \cdot l) dl }{ ||\int_{\Omega} l\cdot v(p,l) (n \cdot l) dl|| } $$

其中符号 $\,||x||\,$ 是向量 x 的长度，积分的结果再除以它自身的长度，即归一化向量。

## Obscurance
环境遮挡系数的可见性函数方法对于封闭的几何体是不起作用的，因为对于封闭的几何体内部的物体来说，来自表面的所有射线都会击中该封闭的空间。所有有人提出了 Obscurance 思想，即通过**距离映射函数** $\,\rho(l)\,$ 来替代可见性函数 $\,v(l)\,$，从而对环境光遮蔽的计算进行了修改：  

$$ k_{AO}(p) = \cfrac{1}{\pi} \int_{\Omega} \rho(l) (n \cdot l) dl $$

距离映射函数是一个连续的函数，其返回值取决于射线与表面相交之前所传播的距离，当相交距离为 0 时，$\,\rho(l)\,$ 的值为 0；当相交距离大于设定的最大距离，或者没有相交时，$\,\rho(l)\,$ 的值为 1。Obscurance 在物理上是不正确的。然而，Obscurance 通常可以给出符合期望的合理结果。

## 相互反射
环境光遮蔽与完整全局光照之间的一个重要区别是**相互反射 interreflection**，所以相对于完整全局光照模拟产生的结果，会更暗一些。Occlusion 假设被遮挡方向上的 radiance 为零，但是实际上相互反射会为这些方向引入一个非零的 radiance。使用 Obscurance 距离映射函数来代替可见性函数也可以缓解这个问题，因为 Obscurance 函数的值通常会大于零。

以一种更加精确的方式来追踪相互反射是很昂贵的，因为它需要求解一个递归问题。想要给一个点进行着色，必须首先对其他点进行着色，以此类推。因此有人提出了一种廉价但较为准确的方法来近似相互反射，它基于在漫反射光照下对 Lambertian 场景的观察，即从一个给定位置能够看见的表面，往往会具有相似的 radiance。假设遮挡方向的 radiance $\,L_i\,$，等于当前着色点的出射 radiance $\,L_o\,$，从而打破递归，可以得到这样一个解析表达式：  

$$ E = \cfrac {\pi k_{AO}}{1 - \rho_{ss}(1 - k_{AO})} L_i $$

其中 $\,\rho_{ss}\,$ 是次表面反照率（漫反射率），上述表达式相当于使用了新的环境遮挡因子 $\,k'_{AO}\,$ 来替代之前的 $\,k_{AO}\,$ ：  

$$ k'_{AO} = \cfrac {k_{AO}}{1 - \rho_{ss}(1 - k_{AO})} $$

上式倾向于让环境遮挡因子变得更大（更亮），从而使得它在视觉上更加接近一个完整全局光照所产生的结果，它在一定程度上模拟了相互反射效应。

## 计算环境光遮蔽
环境遮挡因子的计算可能会很耗时，可以在渲染之前离线计算，预计算任何与光照相关的信息（包括环境光遮蔽），这个过程通常被称为**烘焙 Baking**，预计算环境光遮蔽最常见的方法就是蒙特卡罗方法。除了直接预计算环境光遮蔽的结果，对于静态场景还可以先预先计算环境遮挡因子 $\,k_{AO}\,$ 和环境法线 $\,n_{bent}\,$。遮挡数据对于物体上的每个顶点都是唯一的，它们通常会存储在纹理、体积或者网格顶点中。可以将环境遮挡因子和环境法线（可选）存储一个三维网格中，称为**环境光遮蔽体 ambient occlusion volume**。这类方法的计算成本较低，因为可以从纹理中直接读取出环境遮挡因子，不用实时计算。

但上述方法只适用于静态场景，对于动态场景，还是要实时计算这些参数，实际计算的方式，按照空间可以划分为两类：在**世界空间**中执行的方法和在**屏幕空间**中执行的方法。世界空间中执行的方法跟全局光照技术类似，比如符号距离场 SDF、稀疏体素八叉树 Sparse Voxel Octree 等等，世界空间的方法不是本篇文章的重点，而且对于现在来说，真的要实现，可以直接和全局光照技术一起实现。

在**屏幕空间**中执行的方法中，最出名的当属**屏幕空间环境光遮蔽 screen-space ambient occlusion (SSAO)** 算法，它最早是由 Crytek 在 SIGGRAPH 2007 的演讲 [Finding Next Gen CryEngine2](https://www.realtimerendering.com/advances/s2007/Mittring-Finding_NextGen_CryEngine2(Siggraph07).pdf 中提出，最早该技术使用 z-buffer 作为唯一的输入，来估计环境遮挡因子 $\,k_{AO}\,$，该方法会将球形范围内的所有样本都考虑在内，而不是只考虑表面上半球范围内的样本，并且没有考虑余弦因子，所以该方法产生的 AO 效果相对来说不太正确，但尽管如此，最终产生结果在视觉上还是令人较为满意的。

<div align="center">  
<img src="https://s2.loli.net/2025/08/08/tZYC1rxUgDePzRf.png" width = "50%" height = "50%" alt="图1 - Crytek 的 SSAO，球内样本所对应的深度，超过了 z-buffer 中对应位置的深度，则被认为被遮挡，即图中红色点。环境遮挡因子是通过测试的样本数与总样本数的加权比值。"/>
</div>

Crytek 的方法可以被解释为蒙特卡洛积分，计算出来的值可以称为 **Volumetric Obscurance**，可以被定义为：  

$$ \int_{\chi} d(x) o(x) dx $$

其中 $\,\chi\,$ 是围绕该像素点的一个三维球形邻域，$\,d(x)\,$ 是距离映射函数，$\,o(x)\,$ 是占用函数（occupancy function），即 0 和 1。另外，距离映射函数对于最终视觉质量的影响很小，因此可以使用常数。Szirmay-Kalos 等人据此提出了 [Volumetric Ambient Occlusion](https://cg.iit.bme.hu/~szirmay/ambient8.pdf)，它将积分转换到一个球面上，而不是在一个半球上；这个球体的半径为半球的一半，并且会沿着法线移动一个球体半径的距离，最终这个球体会与半球内接，被半球完全包裹。

之后 NVIDIA 的 Louis Bavoil 和 Miguel Sainz 提出了一个不同的方法，在 SIGGRAPH 2008 的演讲 [Image-Space Horizon-Based Ambient Occlusion](https://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf) 提出了基于视界的环境光遮蔽，即大名鼎鼎的 **Horizon-Based Ambient Occlusion (HBAO)**，它假设 z-buffer 中的数据表示了一个连续的高度场。通过确定**视界角 horizon angle**，可以对像素点的可见性进行估计，这里的视界角，指的是切面上方被邻域遮挡的最大角度。也就是说，对于某个点上的给定方向，我们会记录最高的可见物体所对应的角度。

再之后，受到上述算法的启发，动视 Activision 的 Jorge Jiménez 在 SIGGRAPH 2016 的演讲 [Practical Real-Time Strategies for Accurate Indirect Occlusion](https://blog.selfshadow.com/publications/s2016-shading-course/activision/s2016_pbs_activision_occlusion.pptx) 提出了 **Ground-truth Ambient Occlusion (GTAO)**，还可以看他们的论文：[链接一](https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf)，[链接二](https://www.activision.com/cdn/research/PracticalRealtimeStrategiesTRfinal.pdf) 。HBAO 在计算遮挡的时候并不包括余弦项，并且它还增加了一个特殊的衰减，因此它的结果最多只能与光线追踪相接近，但是始终还是不一样的。GTAO 引入了缺失的余弦因子，去除了这个特殊的衰减函数，并在绕观察向量的参考系中给出了遮挡积分。

之后会详细讲解 **SSAO**、**HBAO**、**GTAO** 这三种算法，其实在屏幕空间实现的 AO 算法都可以称为 SSAO，所以在文章中提到的 SSAO 需要自行判断是特指 Crytek 的 SSAO 算法还是广义上的 SSAO。

> 其他关于 SSAO 相关算法的文章或演讲有：  
> ① A Comparative Study of Screen-Space Ambient Occlusion Methods ：https://www.gamedevs.org/uploads/comparative-study-of-ssao-methods.pdf ；  
> ② NIVDIA 的 Multi-Layer Dual-Resolution Screen-Space Ambient Occlusion（SIGGRAPH 2009）：https://developer.download.nvidia.com/presentations/2009/SIGGRAPH/Bavoil_MultiLayerDualResolutionSSAO.pdf；  
> ③ NIVDIA 的 The Alchemy Screen-space Ambient Obscurance Algorithm ：https://research.nvidia.com/publication/2011-08_alchemy-screen-space-ambient-obscurance-algorithm ；  
> ④ NIVDIA 的 Scalable Ambient Obscurance ：https://research.nvidia.com/publication/2012-06_scalable-ambient-obscurance ；  
> ⑤ Efficient Screen-Space Approach to High-Quality Multi-Scale Ambient Occlusion：https://www.comp.nus.edu.sg/~lowkl/publications/mssao_visual_computer_2012.pdf 。



## 着色中的运用
### Diffuse Occlusion
我们计算出环境遮挡系数 $\,k_{AO}\,$ 之后，如何在着色光照计算中进行运用呢？首先只讨论**漫反射遮蔽 Diffuse Occlusion**，回顾反射方程，假设漫反射 Lambertian 表面，使用 Lambertian BRDF 作为反射方程的 $\,f_r(l, v)\,$，并补充上可见性函数 $\,v(l)\,$：  

$$ L_o = \int_{\Omega} \cfrac {\rho_{ss}}{\pi} L_i v(l) (n \cdot l) dl = \cfrac {\rho_{ss}}{\pi} \int_{\Omega} L_i v(l) (n \cdot l) dl $$

从中拆分出 $\,k_{AO}\,$ 项：  

$$ \begin{align*} L_o &= \cfrac {\rho_{ss}}{\pi} \int_{\Omega} L_i v(l) (n \cdot l) dl \\ &= \cfrac {\rho_{ss}}{\pi} \cfrac {\int_{\Omega} L_i v(l) (n \cdot l) dl}{\int_{\Omega} v(l) (n \cdot l) dl} \int_{\Omega} v(l) (n \cdot l) dl \\ &= \rho_{ss} k_{AO} \cfrac {\int_{\Omega} L_i v(l) (n \cdot l) dl}{\int_{\Omega} v(l) (n \cdot l) dl} \end{align*} $$

接下来做出了一个大胆的假设，就是忽略了可见性函数，忽略可见性是一个影响很大的近似操作，所产生的阴影没有任何预期的方向性，也就是说，它们看起来并不像是由特定光源产生的，比如精确光源。那么上面公式可以进一步简化为（余弦在单位半球上积分为 $\,\pi\,$）：  

$$ \begin{align*} L_o &\approx \rho_{ss} k_{AO} \cfrac {\int_{\Omega} L_i (n \cdot l) dl}{\int_{\Omega} (n \cdot l) dl} \\ &= \cfrac {\rho_{ss}}{\pi} k_{AO} \int_{\Omega} L_i (n \cdot l) dl \\ &= k_{AO} \int_{\Omega} \cfrac {\rho_{ss}}{\pi} L_i (n \cdot l) dl \end{align*} $$

$\,k_{AO}\,$ 后面的部分就是漫反射 BRDF 计算的 IBL 环境光积分，忘了回去看 [IBL 基于图像的光照（一）](https://ybniaobu.github.io/2024/07/09/2024-07-09-IBL_Basics1/#%E6%BC%AB%E5%8F%8D%E5%B0%84-BRDF-%E7%A7%AF%E5%88%86)。这意味着，可以直接通过计算 irradiance，即 IBL，并将其乘上环境光遮蔽值来完成环境光遮蔽的效果着色。

### Specular Occlusion
到目前为止，我们都是假设处理的是 Lambertian BRDF，对于**镜面反射遮蔽 Specular Occlusion** 来说，直接乘以 $\,k_{AO}\,$ 项可能无法产生可信的结果，因为此时除了可见性和法线，还取决于观察方向。同时，相比于漫反射的半球波瓣，镜面反射的 BRDF 波瓣也更窄。

寒霜引擎在它的 [Moving Frostbite to Physically Based Rendering 3.0](https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/course-notes-moving-frostbite-to-pbr-v32.pdf) (SIGGRAPH 2014) 中提到过一个近似方法来模拟 GGX 波瓣的镜面反射遮蔽效果，对于粗糙表面来说，下述公式得到的 AO 值几乎是没有修改的，但对于光滑表面来说，观察方向越接近法线，ao 效果越低，即值越高，越接近掠射角，ao 效果越大，即值越低：  

    float computeSpecOcclusion ( float NdotV , float AO , float roughness )
    {
        return saturate (pow( NdoV + AO , exp2 ( -16.0 f * roughness - 1.0 f )) - 1.0 f + AO );
    }

具体如何应用，我在 [Custom Better PBR in Unity](https://ybniaobu.github.io/2024/10/22/2024-10-22-BetterPBR1/#Ambient-Occlusion) 文章中的 Ambient Occlusion 中有详细说明过，就不再赘述了。

而动视 Activision 在 GTAO 中还提出了 **Ground Truth Based Specular Occlusion (GTSO)**，使用了类似于分割求和近似 Split Sum Approximation（由 Epic Games 在 SIGGRAPH 2013 的 [Real Shading in Unreal Engine 4](https://cdn2-unrealengine-1251447533.file.myqcloud.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf) 中提出）的方法，将 Visibility 项也拆分了出来，这个之后学习 GTAO 时会详细说明。

# Normal Buffer
在正式进入 SSAO 之前，因为 SSAO 算法需要使用到场景法线信息，而法线信息的获取有两张方式：①通过 Normal Buffer；②通过 Depth Buffer 重建法线信息。我们先讲额外开 Normal Buffer 的方式，对于延迟管线，GBuffer 肯定是要存储法线信息的，对于前向管线，则需要额外开一张 Normal Buffer（和其他前向管线需要使用的场景信息 RT 一起又可称为 **Thin G-Buffer**），可以和 Depth Prepass 一起输出。

我目前的前向管线开了格式为 R10G10B10A2_UNORM 的 Normal Buffer，无压缩，A2 暂时不存储任何信息（感觉这里可能还是 R16G16 的 xy only 的法线存储方式更好，但先这样），并且额外开了存储 F0（Specular Color）、Roughness 的 R8G8B8A8_UNORM 用于之后的 SSR 效果，我看 DOOM (2016) 的前向管线就是 R16G16 + R8G8B8A8 的方式。但是我觉得对于屏幕空间效果多的游戏来说，还是延迟管线优先吧，前向管线的尴尬之处太多了，我之后应该也会全面转换至延迟管线的。

虽然我看到现在大部分游戏很少会对 Normal Buffer 进行压缩，但是下面还是聊一下 Normal Buffer 的压缩问题，巩固一下基础。


## Normal Encoding
R16G16 或 R10G10B10A2


## Derived From Depth Buffer

# SSAO
①Learn OpenGL 教程中的 SSAO 章节：https://learnopengl.com/Advanced-Lighting/SSAO；  
②John Chapman 的博客文章 SSAO Tutorial：http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html；  
③Alex Tardif 的博客文章 SSAO ：https://alextardif.com/SSAO.html；

## 介绍

## 基本实现

## Downsample
depth/normal downsample

## Filter
### Spatial Filter

### Temproal Filter
Stable SSAO in Battlefield 3 with Selective Temporal Filtering : https://d29g4g2dyqv443.cloudfront.net/sites/default/files/akamai/gamedev/files/gdc12/GDC12_Bavoil_Stable_SSAO_In_BF3_With_STF.pdf

## Upsample


# 其他说明
## SSDO
