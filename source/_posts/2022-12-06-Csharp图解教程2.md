---
title: 《C#图解教程》读书笔记（二）
date: 2022-12-06 16:34:24
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：XXXXXXXXXXXXX。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第七章 深入理解类
## 类成员

| 数据成员（保存数据） | 函数成员（执行代码） |
| :---- | :---- |
| 字段 Fields <br> 常量 Constants | 方法 Methods&emsp; &emsp;运算符 Operators <br> 属性 Properties &emsp; &emsp;索引 Indexers <br> 构造函数 Constructors &emsp; &emsp;事件 Events <br> 析构函数 Destructors |

## 成员修饰符的顺序
类成员声明语句由下列部分组成：**核心声明**、一组可选的**修饰符 modifiers** 和一组可选的**特性 attributes** 。语法如下，方括号内的成分是可选的：  
`[特性] [修饰符] 核心声明`

①修饰符：若有多个修饰符，可以任意顺序排列。
②特性：若有多个特性，可以任意顺序排列。在第25章介绍特性。

比如以下代码在语义上是等价的（public 和 static 都是修饰符，返回类型是核心声明的一部分）：  
`public static int MaxVal;`  
`static public int MaxVal;`

## 实例类成员 Instance Class Members
类成员可以关联到类的一个实例，也可以关联到整个类。类的每个实例都拥有自己的各自类成员的副本，称为**实例成员**。改变一个实例字段的值，不会影响其他实例成员的值。

``` C#
class D
{
    public int Mem1;
}

class Program
{
    static void Main()
    {
        D d1 = new D();
        D d2 = new D();
        d1.Mem1 = 10; d2.Mem1 = 28;

        Console.WriteLine($"d1 = { d1.Mem1 }, d2 = { d2.Mem1 }");
    }
}
```

运行结果如下：

``` console
d1 = 10, d2 = 28
```

## 静态字段 Static Fields
以上都是实例字段，类还可以拥有**静态字段**。静态字段被类的所有实例**共享**，所有实例都访问同一内存位置。使用 **static 修饰符**将字段声明为静态： 

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/vjSrekiyVHofd6z.png" width = "80%" height = "80%" alt="图25 - 静态和非静态数据成员"/>
</div>

## 从类的外部访问静态成员
**点运算符**由实例名、点和成员名组成。就像实例成员，静态成员也可以使用点运算符从外部访问，因为没有实例，所以使用*类名*来访问静态成员：`D.Mem2 = 5;`

访问静态成员的另一种方法不需要前缀，而是使用 using static 声明：

``` C#
using static System.Console; // includes, amongst other members, Writeline()
using static System.Math; // includes, amongst other members, Sqrt()
...
WriteLine($"The square root of 16 is { Sqrt(16) }" );
```

等价于：

``` C#
using System;
...
Console.WriteLine($"The square root of 16 is { Math.Sqrt(16) }");
```

第22章详细介绍 using static 声明结构体。

### 静态字段示例：

``` C#
class D
{
    int Mem1;
    static int Mem2;

    public void SetVars(int v1, int v2) //设置值
    {   Mem1 = v1; Mem2 = v2;   }

    public void Display( string str )
    {   Console.WriteLine("{0}: Mem1= {1}, Mem2= {2}", str, Mem1, Mem2);   }
}

class Program {
    static void Main()
    {
        D d1 = new D(), d2 = new D(); //创建2个实例

        d1.SetVars(2, 4); //设置d1的值
        d1.Display("d1");

        d2.SetVars(15, 17); //设置d2的值
        d2.Display("d2");
    
        d1.Display("d1"); //注意，这时Mem2静态成员的值已改变
    }
}
```

运行结果如下：

``` console
d1: Mem1= 2, Mem2= 4
d2: Mem1= 15, Mem2= 17
d1: Mem1= 2, Mem2= 17
```

### 静态成员的生存期
即使类没有实例，也存在静态成员，并且可以访问。

## 静态函数成员 Static Function Members
如同静态字段，静态函数成员独立于任何类实例，没有实例也可以调用静态方法；*静态函数成员不能访问实例成员，但能访问其他静态成员*。

``` C#
class X
{
    static public int A; //静态字段
    static public void PrintValA() //静态方法
    {
        Console.WriteLine("Value of A: {0}", A); //访问静态字段
    }
}
```

## 其他静态类成员类型
可声明为 static 的类成员前面有勾号：

| 数据成员（保存数据） | 函数成员（执行代码） |
| :---- | :---- |
| √ 字段 Fields <br> √ 类型 Types <br> 常量 Constants | √ 方法 Methods <br> √ 运算符 Operators <br> √ 属性 Properties <br> 索引 Indexers <br> √ 构造函数 Constructors <br> √ 事件 Events |

## 成员常量 Member Constants
区分局部常量和成员常量，成员常量声明在类声明中而不是方法内：

``` C#
class MyClass
{
    const int IntVal1 = 100;
    const int IntVal2 = 2 * IntVal1; //用于初始化成员常量的值在编译时必须是可计算的
}
```

> C# 没有全局常量，常量必须声明在类型中，与 C 和 C++ 不同。

## 常量和静态量 Constants Are Like Statics
常量非常像静态值，没有类的实例也可以使用，但常量没有自己的存储位置，而是在编译时被编译器替换。这种方式类似于 C 和 C++ 的 #define 值。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/7YgDBGnX5zWKS9I.png" width = "75%" height = "75%" alt="图26 - 常量字段变现得像静态字段，但是在内存中没有存储位置"/>
</div>

不能将常量声明为 static ：`static const double PI = 3.14; //错误`

## 属性 Properties
**属性**是代表类实例或类中数据项的成员。使用属性如同写入和读取字段，语法相同。  

与字段不同，属性是一个函数成员：  
①它不一定为数据存储分配内存；  
②它执行代码

**属性 Properties** 是一个包含2个相关方法的被命名为**访问器 accessors** 的组合：  
① **set** 访问器为属性赋值；  
② **get** 访问器从属性获取值。

如下图，注意 - 访问器从后面伸出，因为它们不能直接被调用：

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/4AuSJHGaxwBvhP6.png" width = "60%" height = "60%" alt="图27 - int 类型的、名称为 MyValue 的属性示例"/>
</div>

### 属性声明和访问器
**set** 访问器总是：  
①拥有一个单独的、隐式的值参，名称为 value，与属性的类型相同；  
②拥有一个返回类型 void 。

**get** 访问器总是：  
①没有参数；  
②拥有一个与属性类型相同的返回类型。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/jwPlrzJe3Zs1tfk.png" width = "65%" height = "65%" alt="图28 - 属性声明的语法与结构"/>
</div>

set 访问器中的隐式参数 value 和其他值参一样，可以用它发送数据到方法体或访问器块。  

访问器其他要点如下：  
1、get 访问器和所有执行路径*必须包含一个 return 语句*，返回一个属性类型的值。  
2、访问器 set 和 get 可以以任何顺序声明，并且，除了这两个访问器外，属性不允许有其他方法。

### 属性示例
属性本身没有任何存储，在下面的情况下，使用名为 TheRealValue 的字段作为存储：

``` C#
class C1
{
    private int theRealValue; //字段：分配内存

    public int MyValue //属性：未分配内存
    {
        set { theRealValue = value; }
        get { return theRealValue; }
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/8VH1CPpoYmv5RUd.png" width = "35%" height = "35%" alt="图29 - 属性访问器常常使用字段作为存储"/>
</div>

### 使用属性
写入和读取属性时，访问器会被隐式得调用：  
`MyValue = 5; //赋值：隐式地调用 set 方法`  
`z = MyValue; //表达式：隐式地调用 get 方法`

注意：不能显示地调用访问器，会产生编译错误。

### 属性和关联字段 Properties and Associated Fields
一种常见的方式是在类中将字段声明为 private 以封装该字段，并声明一个 public 属性来控制从类外部对该字段的访问。和属性关联的字段被称为**后备字段 backing field **或**后备存储 backing store**。

以下示例使用公有属性 MyValue 来控制对私有字段 theRealValue 的访问：

``` C#
class C1
{
    private int theRealValue = 10; //后备字段：分配内存

    public int MyValue //属性：不分配内存
    {
        set{ theRealValue = value; } //设置字段值
        get{ return theRealValue; } //获取字段值
    }
}

class Program
{
    static void Main()
    {
        C1 c = new C1();
        Console.WriteLine("MyValue: {0}", c.MyValue); //把属性看作字段，从中读取它的值

        c.MyValue = 20; //使用赋值语句设置属性的值
        Console.WriteLine("MyValue: {0}", c.MyValue);
    }
}
```

### 执行其他计算
访问器 get 和 set 能执行任何计算，下面若输入值大于100，就将 theRealValue 设置为100：

``` C#
int theRealValue = 10; //字段
int MyValue //属性
{
    set { theRealValue = value > 100 ? 100 : value; } //条件运算符，见第9章
    get { return theRealValue; }
}
```

C# 7.0 为属性的 getter/setter 引入了使用**表达函数体**的语法，见第14章。这种语法只有在访问函数体由一个表达式组成的时候才能使用：

``` C#
int MyValue
{
    set => value > 100 ? 100 : value;
    get => theRealValue;
}
```

### 只读和只写属性 Read-Only and Write-Only Properties
只有 get 访问器的属性称为**只读属性**；只有 get 访问器的属性称为**只写属性**。

两个访问器中至少有一个必须被定义，否则编译器会产生一条错误信息。

### 属性与公有字段
根据实践，属性比公有字段更好：  
①属性是函数成员不是数据成员，允许处理输入和输出；  
②属性可以只读和只写，而字段不行；  
③编译后的变量和编译后的属性语义不同。

### 计算只读属性示例
在大多示例中，属性都和一个后备字段关联，并且 get 和 set 访问器引用该字段。但是属性不是必须和字段关联：

``` C#
class RightTriangle
{
    public double A = 3;
    public double B = 4;
    public double Hypotenuse //只读属性
    {
        get{ return Math.Sqrt((A*A)+(B*B)); } 
    }
}

class Program
{
    static void Main()
    {
        RightTriangle c = new RightTriangle();
        Console.WriteLine($"Hypotenuse: { c.Hypotenuse }");
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/JfszWaUQgRqPrt5.png" width = "35%" height = "35%" alt="图30 - 只读属性 Hypotenuse"/>
</div>

### 自动实现属性
因为属性经常被关联到后备字段，所以 C# 提供了**自动实现属性**（automatically implemented property 或 auto-implemented property，简称为**自动属性 auto-property**），允许只声明属性而不声明后备字段。编译器会自动创建隐藏的后备字段，并且自动挂接到 get 和 set 访问器上。

自动实现属性要点：  
①不声明后备字段：编译器根据属性的类型分配存储；  
②不能提供访问器的方法体：声明为分号。

``` C#
class C1
{
    public int MyValue //分配内存，没有声明后备字段
    {
        set; get; //访问器的方法体被声明为分号
    }
}

class Program
{
    static void Main()
    {
        C1 c = new C1();
        Console.WriteLine("MyValue: {0}", c.MyValue);

        c.MyValue = 20;
        Console.WriteLine("MyValue: {0}", c.MyValue);
    }
}
```

运行结果如下：

``` console
MyValue: 0
MyValue: 20
```

### 静态属性
属性也可以被声明为 static ，示例如下：

``` C#
using System;
using static ConsoleTestApp.Trivial;
namespace ConsoleTestApp
{
    class Trivial {
        public static int MyValue { get; set; }
        public void PrintValue()
        { Console.WriteLine("Value from inside: {0}", MyValue); } //从类内部访问MyValue
    }

    class Program {
        static void Main() {
            Console.WriteLine("Init Value: {0}", Trivial.MyValue); //从类外部访问MyValue
            Trivial.MyValue = 10;
            Console.WriteLine("New Value : {0}", Trivial.MyValue); //从类外部访问MyValue

            MyValue = 20; //从类外部访问，但因为using static，所以可以省略类名
            Console.WriteLine($"New Value : { MyValue }");
            Trivial tr = new Trivial();
            tr.PrintValue();
        }
    }
}
```

运行结果如下：

``` console
Init Value: 0
New Value : 10
New Value : 20
Value from inside: 20
```

## 实例构造函数 Instance Constructors
**实例构造函数**是一个特殊的方法，它在创建类的每个新实例时执行。构造函数用于初始化类实例的状态；如果要从类的外部创建类的实例，需要将构造函数声明为 public 。

构造函数的名称和类名相同；构造函数不能有返回值。

``` C#
class MyClass
{
    public MyClass() //声明为public，没有返回类型，和类名相同
    {
        ···
    }
    ...
}
```

### 带参数的构造函数
构造函数可以带参数，也可以被重载，和方法类似。

在使用创建对象表达式创建类的新实例时，要使用 new 运算符，后面跟着类的构造函数，new 运算符使用该构造函数创建类的实例：

``` C#
class Class1
{
    int Id;
    string Name;

    public Class1()            { Id=28; Name="Nemo";  } //构造函数0
    public Class1(int val)     { Id=val; Name="Nemo"; } //构造函数1
    public Class1(String name) { Name=name;           } //构造函数2

    public void SoundOff()
    { Console.WriteLine($"Name { Name }, Id { Id }"); }
}

class Program
{
    static void Main()
    {
        Class1 a = new Class1(), //调用构造函数0
               b = new Class1(7), //调用构造函数1
               c = new Class1("Bill"); //调用构造函数2

        a.SoundOff();
        b.SoundOff();
        c.SoundOff();
    }
}
```

运行结果如下：

``` console
Name Nemo, Id 28
Name Nemo, Id 7
Name Bill, Id 0
```

### 默认构造函数
如果在类中没有显示地提供实例构造函数，那么编译器会提供一个隐式的默认构造函数，它没有参数，方法体为空。若为类声明了构造函数，那么编译器将不会为该类定义默认构造函数。

如果声明了带参数的构造函数，那么试图使用不带参数的构造函数创建新的实例时，编译器会产生一条错误消息，因为没有无参数的构造函数。

## 静态构造函数
实例构造函数初始化类的每个新实例，而**静态构造函数**初始化类级别的项，通常，静态构造函数初始化类的静态字段。

静态构造函数的特点：  
①类只能有一个静态构造函数，而且不能带参数；  
②静态构造函数不能有访问修饰符（static 关键字不是访问修饰符）；  
③类即可以有静态构造函数也可以有实例构造函数；  
④如同静态方法，静态构造函数不能访问所在类的实例成员，因此不能使用 this 访问器；  
⑤不能从程序中显示地调用静态构造函数，系统会自动调用它们：在类的任意实例被创建之前，在类的任意静态成员被引用之前。

示例如下，Random 是 BCL 提供的用于产生随机数的类，位于 System 命名空间中：

``` C#
class RandomNumberClass
{
    private static Random RandomKey; //私有静态字段

    static RandomNumberClass() //静态构造函数
    {
        RandomKey = new Random(); //初始化RandomKey
    }

    public int GetRandomNumber()
    {
        return RandomKey.Next();
    }
}

class Program
{
    static void Main()
    {
        RandomNumberClass a = new RandomNumberClass();
        RandomNumberClass b = new RandomNumberClass();
        Console.WriteLine("Next Random #: {0}", a.GetRandomNumber());
        Console.WriteLine($"Next Random #: { b.GetRandomNumber() }");
    }
}
```

## 对象初始化语句 Object Initializers
**对象创建表达式**由关键字 new 和类构造函数加参数列表组成。  
**对象初始化语句**扩展了创建语法，在表达式尾部加上一组成员初始化语句，利用对象初始化语句，可以在创建新的对象实例时，设置字段和属性的值。

该语法有两种形式：  
①包括构造函数的参数列表：`new TypeName(ArgList) { FieldOrProp = InitExpr, FieldOrProp = InitExpr, ...}`；  
②不包括构造函数的参数列表：`new TypeName { FieldOrProp = InitExpr, FieldOrProp = InitExpr, ...}`；

``` C#
public class Point
{
    public int X = 1;
    public int Y = 2;
}

class Program
{
    static void Main( )
    {
        Point pt1 = new Point();
        Point pt2 = new Point { X = 5, Y = 6 };
        Console.WriteLine("pt1: {0}, {1}", pt1.X, pt1.Y);
        Console.WriteLine($"pt2: { pt2.X }, { pt2.Y }");
    }
}
```

运行结果如下：

``` console
pt1: 1, 2
pt2: 5, 6
```

## 析构函数 Destructors
**析构函数**执行在类的实例被销毁之前需要的清理或释放非托管资源的行为。非托管资源 Unmanaged resources 是指通过 Win32 API 获得的文件句柄 file handles ，或非托管内存块。详见第27章。

## readonly 修饰符
**readonly 修饰符**类似于将字段声明为 const，一旦值设置了就不能改变：  
① const 字段只能在字段的声明语句中初始化，而 readonly 字段可以在下列任意位置设置它的值：  
&ensp;&ensp;- 字段声明语句，类似于 const ；  
&ensp;&ensp;- 类的任何构造函数。如果是 static 字段，初始化必须在静态构造函数中完成。  
② const 字段的值必须可在编译时决定，而 readonly 字段的值可以在运行时决定。
③ const 的行为总是静态的，而对于 readonly 字段可以是实例字段，也可以是静态字段，并且在内存中有存储位置。

``` C#
class Shape
{
    readonly double PI = 3.1416; //初始化
    readonly int NumberOfSides; //未初始化

    public Shape(double side1, double side2) //构造函数
    {
        NumberOfSides = 4; //在构造函数中设定
        ···
    }

    public Shape(double side1, double side2, double side3) { 
        NumberOfSides = 3; //在构造函数中设定
        ···
    }
}
```

## this 关键字
**this 关键字**在类中是对当前实例的引用，只能被用在实例构造函数、实例方法、属性和索引器的实例访问器。

因为静态成员不是实例的一部分，所以不能在任何静态函数成员的代码中使用 this 关键字。this 主要用于区分类成员和局部变量或参数，以及作为调用方法的实参。

``` C#
class MyClass
{
    int Var1 = 10;

    public int ReturnMaxSum(int Var1) //参数
    { Parameter Field
        return Var1 > this.Var1
                    ? Var1 //参数
                    : this.Var1; //字段
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();

        Console.WriteLine($"Max: { mc.ReturnMaxSum(30) }");
        Console.WriteLine($"Max: { mc.ReturnMaxSum(5) }");
    }
}
```

虽然理解 this 关键字很重要，但是很少在代码中使用。

## 索引器 Indexers
**索引器**允许用索引访问类字段。

### 什么是索引器
**索引器**是一组 get 和 set 访问器，与属性类似：

<div  align="center">  
<img src="https://s2.loli.net/2022/12/16/aEWC8UMjmXOGA6i.png" width = "60%" height = "60%" alt="图31 - 索引器的表现形式"/>
</div>

### 索引器和属性
①和属性一样，索引器不用分配内存来存储；  
②索引器和属性都主要用来访问其他数据成员，与这些成员关联，并为它们提供获取和设置访问：
&ensp;&ensp;- 属性表示单个数据成员；  
&ensp;&ensp;- 索引器表示多个数据成员。

> 可以认为**索引器**是为类的多个数据成员提供 get 和 set 访问的**属性**。

但索引器总是实例成员，因此不能被声明为 static 。

### 声明索引器
声明索引器语法如下：  
①索引器没有名称，在名称的位置是关键字 this ；  
②参数列表在**方括号**内；  
③参数列表必须至少声明一个参数。

``` C#
ReturnType this [ Type param1, ... ]
{
    get
    {
        ...
    }

    set
    {
        ...
    }
}
```

### 索引器的 set 访问器
当索引器被用于赋值，set 访问器被调用，并接受2种数据：  
①一个名为 value 的隐式参数，其中持有要保存的数据；  
②索引参数，表示数据应该保存在哪里。  
`emp[0] = "Doe";`

set 访问器的语法和含义如下图：

<div  align="center">  
<img src="https://s2.loli.net/2022/12/16/lUVajeY5kGuXJ8W.png" width = "70%" height = "70%" alt="图32 - set 访问器的语法和含义"/>
</div>

左边是访问器声明的实际语法，右边展示了 set 访问器有如下语义：  
①它的返回类型为 void ；  
②它使用的参数列表和索引器声明中的相同；  
③它有一个名为 value 的隐式参数，值参类型与索引器类型相同。

### 索引器的 get 访问器
当使用索引器获取值时，可以通过索引参数调用 get 访问器：`string s = emp[0];`

get 访问器方法体内的代码必须检查索引参数，来确定它表示的是哪个字段，并返回该字段的值，语法和含义如下：

<div  align="center">  
<img src="https://s2.loli.net/2022/12/16/T4EuXyLAjODoW3h.png" width = "70%" height = "70%" alt="图33 - get 访问器的语法和含义"/>
</div>

①get 访问器的参数列表和索引器声明中的相同；  
②get 访问器返回与索引器类型相同的值。  

### 关于索引器的更多内容
和属性一样，不能显示地调用 get 和 set 访问器：  
`emp[0] = "Doe"; \\自动调用 set 访问器`  
`string NewName = emp[0]; \\自动调用 get 访问器`

### 为类声明索引器示例
①下面的索引器需要读取 string 类型的值，所以索引器的类型要和字段一致，且索引器要声明为 public ，以便从类外部访问；  
②若索引为整数，方括号内的 index 的形参需为 int 型。

``` C#
class Employee {
    public string LastName; //调用字段0
    public string FirstName; //调用字段1
    public string CityOfBirth; //调用字段2

    public string this[int index] //索引器声明
    {
        set //set访问器声明
        {
            switch (index) {
                case 0: LastName = value;
                    break;
                case 1: FirstName = value;
                    break;
                case 2: CityOfBirth = value;
                    break;

                default: //异常，见第23章
                    throw new ArgumentOutOfRangeException("index");
            }
        }

        get //get访问器声明
        {
            switch (index) {
                case 0: return LastName;
                case 1: return FirstName;
                case 2: return CityOfBirth;

                default: //异常，见第23章
                    throw new ArgumentOutOfRangeException("index");
            }
        }
    }
}
```

### 另一个索引器示例

``` C#
class Class1
{
    int Temp0; //私有字段
    int Temp1; //私有字段

    public int this [ int index ] //索引器
    {
        get
        {
            return ( 0 == index ) //返回Temp0或Temo1的值
                        ? Temp0
                        : Temp1;
        }

        set
        {
            if( 0 == index )
                Temp0 = value; //隐式变量value
            else
                Temp1 = value; //隐式变量value
        }
    }
}

class Example
{
    static void Main()
    {
        Class1 a = new Class1();

        Console.WriteLine("Values -- T0: {0}, T1: {1}", a[0], a[1]);
        a[0] = 15;
        a[1] = 20;
        Console.WriteLine($"Values -- T0: { a[0] }, T1: { a[1] }");
    }
}
```

运行结果如下：

``` console
Values -- T0: 0, T1: 0
Values -- T0: 15, T1: 20
```

### 索引器重载
只要索引器的参数列表不同，类就可以有任意多个索引器，类型不同不行。

## 访问器的访问修饰符
默认情况下，属性或索引器这两种函数成员的两个访问器（ get 和 set ）的访问级别与成员相同。即属性的访问级别是 public ，两个访问器的访问级别也是 public 。但是可以为两个访问器分配不同的访问级别。

如下代码展示了非常常见重要的示例，将 set 访问器声明为 private ，将 get 访问器声明为 public 。get 之所以是 public ，是因为属性的访问级别是 public 。这样尽管可以从类的外部读取属性，但只能从类内部设置它（该示例在构造函数内设置），是一个非常重要的封装工具：

``` C#
class Person
{
    public string Name { get; private set; } //不同访问级别的访问器
    public Person( string name ) { Name = name; }
}

class Program
{
    static public void Main( )
    {
        Person p = new Person( "Capt. Ernest Evans" );
        Console.WriteLine( $"Person's name is { p.Name }");
    }
}
```

运行结果如下：

``` console
Person's name is Capt. Ernest Evans
```

访问器的访问修饰符有几个限制：  
①仅当成员既有 get 访问器也有 set 访问器时，其访问器才能有访问修饰符；  
②虽然两个访问器都必须出现，但是只有一个能有访问修饰符；  
③访问器的访问修饰符的限制必须比成员的访问级别更严格：比如若属性的访问级别是 protected ，则唯一能对访问器使用的是 private 。

## 分部类和分部类型 Partial Classes and Partial Types
类的声明可以分割为几个分部类的声明，类的分部类声明可以在不同文件里。每个分部类声明要标注为 partial class，比普通类增加了**类型修饰符 partial** 。

> 类型修饰符 partial 不是关键字，所以在其他上下文中，可以被用作标识符。但是在关键字 class、struct 或 interface 之前时，表示分部类型。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/16/NzhGewJvAR1kYb2.png" width = "70%" height = "70%" alt="图34 - 使用分部类型来分割类"/>
</div>

组成类的所有分部类声明必须在一起编译；除了分部类还有2种分部类型，分部结构（第11章）和分部接口（第16章）

## 分部方法 Partial Methods
分部方法是声明在分部类中不同部分的方法，分部方法的不同部分可以声明在分部类的不同部分中。

分部方法的两个部分如下：  
①定义分部方法声明：给出签名和返回类型，声明的实现部分只是一个分号；  
②实现分部方法声明：给出签名和返回类型，以普通语句块形式实现。

定义声明和实现声明的签名和返回类型必须匹配：  
&ensp;&ensp;- 返回类型必须是 void ；  
&ensp;&ensp;- 签名不能包括访问修饰符，这使分部方法是隐式的 private ；  
&ensp;&ensp;- 参数列表不能包括 out 参数；  
&ensp;&ensp;- 定义和实现声明中都必须包含上下文关键字 partial ，并且直接在关键字 void 之前。

可以有定义部分而没有实现部分，此时编译器会把方法的声明和方法内部对方法的调用移除。

``` C#
partial class MyClass
{
    partial void PrintSum(int x, int y); //定义分部方法，注意分号，没有实现部分

    public void Add(int x, int y) //因为分部方法是隐式私有，PrintSum不能从类外部调用，所以用公有方法Add调用PrintSum
    {
        PrintSum(x, y);
    }
}

partial class MyClass
{
    partial void PrintSum(int x, int y) //实现分部方法
    {
        Console.WriteLine("Sum is {0}", x + y); //实现部分
    }
}

class Program
{
    static void Main( )
    {
    var mc = new MyClass();
    mc.Add(5, 6);
    }
}
```

运行结果如下：

``` console
Sum is 11
```


# 第八章 类和继承
## 类继承 Class Inheritance
通过**继承**定义一个新类，使用一个已存在的类作为新类的基础。已存在的类称为**基类 base class**，新类称为**派生类 derived class**。

要声明一个派生类，需要在类名后加上**基类规格说明 class-base specification**。  
①基类规格说明由冒号和用作基类的类名称组成：`class OtherClass : SomeClass`  
②派生类成员包括本身声明中的成员以及基类的成员；  
③派生类 *不能删除* 它所继承的任何成员。

## 访问继承的成员
继承的成员可以被访问，就像它们是派生类自己声明的一样（构造函数特殊，见本章后面）

``` C#
class SomeClass //基类
{
    public string Field1 = "base class field ";
    public void Method1( string value ) {
        Console.WriteLine($"Base class -- Method1: { value }");
    }
}

class OtherClass: SomeClass { //派生类
    public string Field2 = "derived class field";
    public void Method2( string value ) {
        Console.WriteLine($"Derived class -- Method2: { value }");
    }
}

class Program {
    static void Main() {
        OtherClass oc = new OtherClass();

        oc.Method1( oc.Field1 ); //以基类字段为参数的基类方法
        oc.Method1( oc.Field2 ); //以派生类字段为参数的基类方法
        oc.Method2( oc.Field1 ); //以基类字段为参数的派生类方法
        oc.Method2( oc.Field2 ); //以派生类字段为参数的派生类方法
    }
}
```

运行结果如下：

``` console
Base class -- Method1: base class field 
Base class -- Method1: derived class field
Derived class -- Method2: base class field
Derived class -- Method2: derived class field
```

## 所有类都派生自 object 类
所有类都是派生类，**类 object** 是唯一的非派生类，它是所有继承层次的基础。没有基类规格说明的类隐式地直接派生自类 object。类声明显式地派生自 object 类和隐式地派生自 object 类在语义上是等价的。

一个类声明的基类规格说明中只能有一个单独的类，称为**单继承 single inheritance**。

## 屏蔽基类的成员
虽然派生类不能删除它继承的任何成员，但可以用与基类成员名称相同的成员来屏蔽 mask 基类成员。  
①要屏蔽一个继承的数据成员，需要声明一个新的相同类型的成员，并使用相同的名称；  
②要屏蔽一个继承的函数成员，需要声明一个新的带有相同签名的函数成员，签名包括名称和参数列表，不包括返回类型；  
③最好使用 new 修饰符，虽然没有该修饰符，程序可以成功编译，但编译器会警告你隐藏了一个继承的成员；  
④可以屏蔽静态成员。

``` C#
class SomeClass //基类
{
    public string Field1 = "SomeClass Field1";
    public void Method1(string value)
        { Console.WriteLine($"SomeClass.Method1: { value }"); }
}

class OtherClass : SomeClass //派生类
{
    new public string Field1 = "OtherClass Field1"; //屏蔽基类成员
    new public void Method1(string value) //屏蔽基类成员
        { Console.WriteLine($"OtherClass.Method1: { value }"); }
}

class Program
{
    static void Main()
    {
        OtherClass oc = new OtherClass(); //使用屏蔽成员
        oc.Method1(oc.Field1); //使用屏蔽成员
    }
}
```

运行结果如下：

``` console
OtherClass.Method1: OtherClass Field1
```

## 基类访问 Base Access
如果派生类必须访问被隐藏的继承成员，可以使用**基类访问 base access** 表达式，由关键字 base 和点加上成员的名称组成：`Console.WriteLine("{0}", base.Field1);`

``` C#
class SomeClass { //基类
    public string Field1 = "Field1 -- In the base class";
}

class OtherClass : SomeClass { //派生类
    new public string Field1= "Field1 -- In the derived class";

    public void PrintField1()
    {
        Console.WriteLine(Field1); //访问派生类
        Console.WriteLine(base.Field1); //访问基类
    }
}

class Program {
    static void Main()
    {
        OtherClass oc = new OtherClass();
        oc.PrintField1();
    }
}
```

运行结果如下：

``` console
Field1 -- In the derived class
Field1 -- In the base class
```

## 使用基类的引用
派生类的实例由基类的实例和派生类新增的成员组成，派生类的引用指向整个类对象，包括基类部分。

如果有一个派生类对象的引用，就可以获取该对象基类部分的引用（使用**类型转换运算符 cast operator** 把引用转换 cast 为基类类型，详见第17章）。类型转换运算符放置在对象引用的前面，由圆括号括起的要被转换成的类名组成。将派生类对象强制转换为基类对象的作用是产生的变量只能访问基类的成员（在被覆写方法中除外，见本章后面）。

``` C#
MyDerivedClass derived = new MyDerivedClass(); //创建一个对象
MyBaseClass mybc = (MyBaseClass) derived; //转换引用
```

①第一行声明并初始化了变量 derived，它包含一个 MyDerivedClass 类型对象的引用；  
②第二行声明了一个基类类型 MyBaseClass 的变量，并把 derived 中的引用转换为该类型，给出对象的基类部分的引用。  

<div  align="center">  
<img src="https://s2.loli.net/2022/12/20/qvf8azxGJnpZkAi.png" width = "70%" height = "70%" alt="图35 - 派生类的引用可以看到完整的 MyDerivedClass 对象，而 mybc 只能看到对象的 MyBaseClass 部分"/>
</div>

``` C#
class MyBaseClass
{
    public void Print()
    {
        Console.WriteLine("This is the base class.");
    }
}

class MyDerivedClass : MyBaseClass
{
    public int var1;

    new public void Print()
    {
        Console.WriteLine("This is the derived class.");
    }
}

class Program
{
    static void Main()
    {
        MyDerivedClass derived = new MyDerivedClass();
        MyBaseClass mybc = (MyBaseClass)derived; //转换为基类

        derived.Print(); //从派生类部分调用Print
        mybc.Print(); //从基类部分调用Print
        // mybc.var1 = 5; //错误：基类引用无法访问派生类成员
    }
}
```

运行结果如下：

``` console
This is the derived class.
This is the base class.
```

### 虚方法和覆写方法 Virtual and Override Methods
