---
title: 《C#图解教程》读书笔记（二）
date: 2022-12-06 16:34:24
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 本篇主要内容为：表达式与运算符；语句；结构；枚举；数组；委托；事件。  
> 读书笔记仅为知识的记录，方便后续查找。  
> 学习完成日期为2023年07月29日。  

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第九章 表达式和运算符
## 表达式 Expressions
**运算符 operator** 是一个符号，表示返回单个结果的操作。**操作数 operand** 指作为运算符输入的数据元素。**表达式 expression** 是运算符和操作数的字符串。比如 `a + b + c + d` 有3个运算符和4个操作数。

**表达式求值 Evaluating an expression** 是将每个运算符以适当的顺序应用到它的操作数以产生一个值的过程。值被返回到表达式求值的位置。除了返回值，一些表达式可能还会在内存中设置一个值。

## 字面量 Literals
**字面量**是源代码中键入的数字或字符串。

``` C#
static void Main()
{
    Console.WriteLine("{0}", 1024); //整数字面量
    Console.WriteLine("{0}", 3.1416); //双精度型字面量
    Console.WriteLine("{0}", 3.1416F); //浮点型字面量
    Console.WriteLine("{0}", true); //布尔型字面量
    Console.WriteLine("{0}", 'x'); //字符型字面量
    Console.WriteLine("{0}", "Hi there"); //字符串字面量
}
```

① bool 有两个字面量：true 和 false ，注意和所有 C# 关键字一样，它们都是小写。  
② 对于引用类型变量，字面量 null 表示变量没有指向内存中的数据。

### 整数字面量 Integer Literals
整数字面量被书写为十进制数字序列，没有小数点，带有可选的后缀，指明整数的类型。

比如以下四个字面量：  
`236 //整数`  
`236L //长整数`  
`236U //无符号整数`  
`236UL //无符号长整数`  

整数类型字面量还可以写成十六进制 hex 形式，以 0x 或 0X 为前缀，实际数据类型用后缀指定。也可以写成二进制记法，以 0b 或 0B 为前缀，实际数据类型用后缀指定。

若没有后缀，编译器会把数字字符串解释为能表示该值而不丢失数据的相应类型的最小类型，比如236和5000000000都没有后缀，236会被解释为一个 int ，5000000000会被解释为一个 long 。

可以在数字字面量插入分隔符：`5_000_000_000`。

| 后缀 | 整数类型 | 备注 |
| :---- | :---- | :---- |
| 无 | int, uint, long, ulong | |
| U, u | uint, ulong | |
| L, l | long, ulong | 不推荐使用小写字母l，会和数字1混淆
| ul, uL, Ul, UL, lu, Lu, lU, LU | ulong | 不推荐使用小写字母l，会和数字1混淆 |

### 实数字面量 Real Literals
C# 有三种实数数据类型：float、double 和 decimal ，分别对应32位、64位和128位精度，都是浮点数据类型，实际使用中，double 最常用。

实数字面量包括十进制数字；一个可选的小数点；一个可选的指数部分 E 或 e ；一个可选的后缀：  
`float f1 = 236F;`  
`double d1 = 236.714;`  
`double d2 = .35192;`  
`double d3 = 6.338e-26;`

| 后缀 | 实数类型 |
| :---- | :---- |
| 无 | double |
| F, f | float |
| D, d | double |
| M, m | decimal |

> 注意：无后缀的实数字面量是 double 类型，而不是 float 类型！！！

### 字符字面量 Character Literals
**字符字面量**由**两个单引号**内的字符组成，用于表示单个字符(a)、非打印字符(\n换行符)或者执行特殊任务的字符，比如转义 escape (\\)。

尽管可能需要多个字符来表示一个字符字面量，但是每个字符字面量只表示一个字符，要引入多个字符，必须使用字符串字面量。

字符字面量可以是以下任意一种：  
`char c1 = 'd'; //单个字符`  
`char c2 = '\n'; //简单转义序列`  
`char c3 = '\x0061'; //十六进制转义序列`  
`char c4 = '\u005a'; //Unicode转义序列`  

①字符字面量的类型是 **char** ；  
②简单转义序列是一个反斜杠后面跟着单个字符；  
③十六进制转义序列是一个反斜杠后面跟着 X 或 x，后面4个十六进制数字；  
④Unicode 转义序列是一个反斜杠后面跟着 U 或 u，后面4个十六进制数字。

| 名称 | 转义序列 | 十六进制编码 |
| :---- | :---- | :---- |
| 空字符 Null | \0 | 0x0000 |
| 警告 Alert | \a | 0x0007 |
| 退格符 Backspace | \b | 0x0008 |
| 水平制表符 Horizontal tab | \t | 0x0009 |
| 换行符 New line | \n | 0x000A |
| 垂直制表符 Vertical tab | \v | 0x000B |
| 换页符 Form feed | \f | 0x000C |
| 回车符 Carriage return | \r | 0x000D |
| 双引号 Double quote | \" | 0x0022 |
| 单引号 Single quote | \' | 0x0027 |
| 反斜杠 Backslash | \\ | 0x005C |

### 字符串字面量 String Literals
**字符串字面量**使用**双引号**标记，不同于字符字面量使用单引号。

字符串字面量有两种类型：①**常规字符串字面量 Regular string literals**；②**逐字字符串字面量 Verbatim string literals**。

常规字符串字面量可以包含：字符、简单转义序列、十六进制转义序列和Unicode转义序列。例如：  
`string st1 = "Hi there!";`  
`string st2 = "Val1\t5, Val2\t10";`  
`string st3 = "Add\x000ASome\u0007Interest";`

逐字字符串字面量是以 @ 字符为前缀的常规字符串字面量，逐字字符串字面量中字符串不会被转义。逐字字符串字面量的唯一例外就是相邻的双引号组，被解释为单个双引号字符。

``` C#
string rst1 = "Hi there!";
string vst1 = @"Hi there!";

string rst2 = "It started, \"Four score and seven...\"";
string vst2 = @"It started, ""Four score and seven...""";

string rst3 = "Value 1 \t 5, Val2 \t 10";
string vst3 = @"Value 1 \t 5, Val2 \t 10";

string rst4 = "C:\\Program Files\\Microsoft\\";
string vst4 = @"C:\Program Files\Microsoft\";

string rst5 = " Print \x000A Multiple \u000A Lines";

string vst5 = @" Print
Multiple
Lines";
```

打印这些字符串会产生以下输出：

``` console
Hi there!
Hi there!

It started, "Four score and seven..."
It started, "Four score and seven..."

Value 1 5, Val2 10
Value 1 \t 5, Val2 \t 10

C:\Program Files\Microsoft\
C:\Program Files\Microsoft\

Print
Multiple
Lines

Print
Multiple
Lines
```

> 编译器让相同的字符串字面量共享堆中同一内存位置以节约内存。

## 求值顺序
表达式可以有很多嵌套的子表达式构成，求值顺序可以是表达式最终值发生变化。

### 优先级
优先级从高到低如下表所示：

| 分类 | 运算符 |
| :---- | :---- |
| 初级运算符 <font face= "Arial"> Primary </font> | <font face= "Arial"> a.x, f(x), a[x], x + +, x - -, new, typeof, checked, unchecked </font> |
| 一元运算符 <font face= "Arial">Unary</font> | <font face= "Arial">+, -, !, ~, + + x, - - x, (T)x</font> |
| 乘法 <font face= "Arial">Multiplicative</font> | <font face= "Arial"> *, /, % </font> |
| 加法 <font face= "Arial">Additive</font> | <font face= "Arial">+, -</font> |
| 移位 <font face= "Arial">Shift</font> | <font face= "Arial"><<, >></font> |
| 关系和类型 <font face= "Arial">Relational and type</font> | <font face= "Arial"><, >, <=, >=, is, as</font> |
| 相等 <font face= "Arial">Equality</font> | <font face= "Arial">==, !=</font> |
| 位与 <font face= "Arial">Logical AND</font> | <font face= "Arial">&</font> |
| 位异或 <font face= "Arial">Logical XOR</font> | <font face= "Arial">^</font> |
| 位或 <font face= "Arial">Logical OR</font> | <font face= "Arial">&#124;</font> |
| 条件与 <font face= "Arial">Conditional AND</font> | <font face= "Arial">&&</font> |
| 条件或 <font face= "Arial">Conditional OR</font> | <font face= "Arial">&#124;&#124;</font> |
| 条件选择 <font face= "Arial">Conditional</font> | <font face= "Arial">?:</font> |
| 赋值运算符 <font face= "Arial">Assignment</font> | <font face= "Arial">=, *=, /=, %=, +=, -=, <<=, >>=, &=, ^=, &#124;=</font> |

### 结合性 Associativity
如果有连续的运算符有相同的优先级别，求值顺序由**操作结合性 operator associativity** 决定，比如 `2/6*4` 求值顺序有2种。

运算符结合性重要特征：①左结合运算符从左至右求值；②右结合运算符从右至左求值；  

| 运算符类型 | 结合性 |
| :---- | :---- |
| 赋值运算符 | 右结合 |
| 其他二元运算符 | 左结合 |
| 条件运算符 | 右结合 |

所以 `2/6*4` 应该是从左到右，得到 4/3 。

可以直接使用**圆括号**来显式地设定子表达式求值顺序，并覆盖优先级和结合性规则。

## 简单算术运算符
简单算术运算符包括 `+` 、`-` 、`*` 、`/` 。这些运算符都是二元左结合运算符。对于除法，要注意整数除法，直接截取整数部分。

## 求余运算符 The Remainder Operator
求余运算符 `%` ，返回余数。

求余运算符还可以用于实数以得到实余数 real remainders。

``` C#
Console.WriteLine("0.0f % 1.5f is {0}" , 0.0f % 1.5f);
Console.WriteLine("0.5f % 1.5f is {0}" , 0.5f % 1.5f);
Console.WriteLine("1.0f % 1.5f is {0}" , 1.0f % 1.5f);
Console.WriteLine("1.5f % 1.5f is {0}" , 1.5f % 1.5f);
Console.WriteLine("2.0f % 1.5f is {0}" , 2.0f % 1.5f);
Console.WriteLine("2.5f % 1.5f is {0}" , 2.5f % 1.5f);
```

得到：

``` console
0.0f % 1.5f is 0 
0.5f % 1.5f is 0.5 
1.0f % 1.5f is 1 
1.5f % 1.5f is 0 
2.0f % 1.5f is 0.5 
2.5f % 1.5f is 1 
```

## 关系比较运算符和相等比较运算符
关系比较运算符和相等比较运算符是二元运算符，比较它们的操作数并返回 bool 型值，它们都是左结合运算符。包括 `<` , `>` , `<=` , `>=` , `==` , `!=` 。

> 与 C 和 C++ 不同，**在 C# 中数字不具有布尔意义**。

### 比较操作和相等性操作
对于大多数引用类型来说，比较它们的相等性时，只比较它们的引用。  
①如果引用相等，即指向内存中相同的对象，那么相等性比较为 true，否则为 false 。这称为**浅比较 shallow comparison** 。  
② string 类型对象也是引用类型，但是比较字符串的相等性时，若两个字符串有相同的长度和内容（区分大小写），则返回 true ，即使它们占有不同的内存区域。这称为**深比较 deep comparison** 。

委托也是深比较，见第14章，若两个委托都是 null ，或两者的调用列表中有相同数目的成员，并且调用列表相匹配，则比较返回 true 。

比较数值表达式时，比较类型和值；比较 enum 类型，比较操作数的实际值，枚举见第12章。

## 递增运算符和递减运算符 Increment and Decrement Operators
递增运算符和递减运算符是一元的，有2种形式，**前置**形式和**后置**形式，产生不同效果：

| 运算符 | 名称 | 描述 |
| :---- | :---- | :---- |
| <font face= "Arial">++</font> | 前置递增 <font face= "Arial">++var</font> | 变量的值加1并保存，返回变量的新值 |
| <font face= "Arial">++</font> | 后置递增 <font face= "Arial">var++</font> | 变量的值加1并保存，返回变量递增之前的旧值 |
| <font face= "Arial">\-\-</font> | 前置递减 <font face= "Arial">\-\-var</font> | 变量的值减1并保存，返回变量的新值 |
| <font face= "Arial">\-\-</font> | 后置递减 <font face= "Arial">var\-\-</font> | 变量的值减1并保存，返回变量递增之前的旧值 |

| | 表达式：x=10 | 返回给表达式的值 | 计算后变量的值 |
| :---- | :---- | :---- | :---- |
| 前置递增 | <font face= "Arial">++x</font> | 11 | 11 |
| 后置递增 | <font face= "Arial">x++</font> | 10 | 11 |
| 前置递减 | <font face= "Arial">\-\-x</font> | 9 | 9 |
| 后置递减 | <font face= "Arial">x\-\-</font> | 10 | 9 |

## 条件逻辑运算符 Conditional Logical Operators
逻辑运算符包括逻辑与 AND 、逻辑或 OR 、逻辑非 NOT 。逻辑与和逻辑或运算符是二元左结合运算符。逻辑非是一元运算符。

| 运算符 | 名称 | 描述 |
| :---- | :---- | :---- |
| && | 与 | 如果两个操作数都是true，结果为true；否则为false |
| &#124;&#124; | 或 | 如果至少一个操作数是true，结果为true；否则为false |
| ! | 非 | 如果操作数是false，结果为true；否则为false |

条件逻辑运算符使用 **“短路” short-circuit** 模式操作，即若计算第一个操作数之后就能确定值，就会跳过第二个操作数的计算。比如下面代码，变量 iVal 的后置递增不会被执行，因为执行了第一个子表达式后，可以确定返回值是 false 。

``` C#
bool bVal; int iVal = 10;

    bVal = (1 == 2) && (9 == iVal++); //结果：bVal = False, iVal = 10
```

## 逻辑运算符 Logical Operators
按位逻辑运算符如下表，除按位非运算符以外，这些运算符都是二元左结合运算符，按位非运算符是一元运算符：

| 运算符 | 名称 | 描述 |
| :---- | :---- | :---- |
| & | 位与 Bitwise AND | 仅当两个操作数都为1时，位的结果为1 |
| &#124; | 位或 Bitwise OR | 只要任意一个操作数为1时，位的结果为1 |
| ^ | 位异或 Bitwise XOR | 仅当一个而不是两个操作数为1时，位的结果为1 |
| ~ | 位非 Bitwise negation | 得到操作数的二进制反码 |

<div  align="center">  
<img src="https://s2.loli.net/2023/01/05/I7cKHLZrNB9sbn4.png" width = "60%" height = "60%" alt="图46 - 按位逻辑操作示例"/>
</div>

## 移位运算符 Shift Operators
移位运算符是二元左结合运算符：

| 运算符 | 名称 | 描述 |
| :---- | :---- | :---- |
| << | 左移 | 将位组向左移动给定数目个位置。位从左边移出并丢失，右边的位位置用0填充 |
| >> | 右移 | 将位组向右移动给定数目个位置。位从右边移出并丢失 |

底层硬件使用二进制补码 two’s complement 的形式表示有符号二进制数。在二进制补码表示法中，负数最左侧的位位置是1，正数的补码和原码一致，负数的补码是原码的基础上对各个位取反后加1。所以要把一个正数转换成负数，要把这个数按位取反再加1，反之亦然。

位移有符号的数字，左移一位的结果与把它乘以2的结果相同，右移一位的结果和除以2相同。然而如果右移一个负数，最左边位用0填充，会让数字变成正数，为了应对这种情形，当操作数是有符号的整数时，如果操作数最左边的位是1，在左边移开的位位置用1而不是0填充，这保持了正确的二进制补码表示法。

<div  align="center">  
<img src="https://s2.loli.net/2023/01/05/Gf4H6V7msDu5pvt.png" width = "65%" height = "65%" alt="图47 - 移位"/>
</div>

## 赋值运算符 Assignment Operators
赋值运算符先将运算符右侧的表达式求值，并用该值设置运算符左边的变量的值，故赋值运算符是二元右结合运算符：

| 运算符 | 描述 |
| :---- | :---- |
| = | 简单赋值; 计算右边表达式的值，并把返回值赋给左边的变量或表达式 |
| \*= | 复合赋值; var \*= expr 等价于 var = var \* (expr) |
| /= | 复合赋值; var /= expr 等价于 var = var / (expr) |
| %= | 复合赋值; var %= expr 等价于 var= var % (expr) |
| += | 复合赋值; var += expr 等价于 var = var + (expr) |
| -= | 复合赋值; var -= expr 等价于 var = var- (expr) |
| <<= | 复合赋值; var <<= expr 等价于 var = var << (expr) |
| >>= | 复合赋值; var >>= expr 等价于 var = var >> (expr) |
| &= | 复合赋值; var &= expr 等价于 var = var & (expr) |
| ^= | 复合赋值; var ^= expr 等价于 var = var ^ (expr) |
| &#124;= | 复合赋值; var &#124;= expr 等价于 var = var &#124; (expr) |

对于复合赋值：

``` C#
x += y – z; //等价于 x = x + (y – z);
x *= y – z; //等价于 x = x * (y – z);
x /= y – z; //等价于 x = x / (y – z);
```

## 条件运算符 The Conditional Operator
条件运算符是三元运算符，语法如下：`Condition ? Expression1 : Expression2`，包含一个测试表达式和两个结果表达式：  
① Condition 必须返回一个 bool 类型的值；  
② 如果 Condition 求值为 true ，那么对 Expression1 求值并返回，否则，对 Expression2 求值并返回；

``` C#
if ( x < y )
    intVar = 5;
else
    intVar = 10;
```

上述代码等价于 `intVar = x < y ? 5 : 10;`，或者如下：

``` C#
intVar = x < y
        ? 5
        : 10;
```

## 一元算术运算符 Unary Arithmetic Operators
就是数学的正负号，比如 `int x = +10;` `int y = -x;`

## 用户定义的类型转换
用户定义的类型转换详见第17章，这里提一下是因为它们是运算符：

可以为自己的类和结构定义隐式转换和显式转换：  
①对于隐式转换，编译器会根据特定上下文决定使用特定的类型，并进行自动转换；  
②对于显式转换，编译器只在使用显式转换运算符时才执行转换。

声明隐式转换的语法如下，public 和 static 修饰符是必需的，TargetType 为目标类型，SourceType Identifier 为源数据：

``` C#
public static implicit operator TargetType ( SourceType Identifier )
{
    ...
    return ObjectOfTargetType;
}
```

显式转换语法相同，但用 explicit 替换 implicit 。

隐式转换示例如下：

``` C#
class LimitedInt
{
    const int MaxValue = 100;
    const int MinValue = 0;

    public static implicit operator int (LimitedInt li) //将LimitedInt转换为int
    {
        return li.TheValue;
    }

    public static implicit operator LimitedInt (int x) //将int转换为LimitedInt
    {
        LimitedInt li = new LimitedInt();
        li.TheValue = x;
        return li;
    }

    private int mTheValue = 0;
    public int TheValue {
        get { return mTheValue; }
        set
        {
            if (value < MinValue)
                mTheValue = 0;
            else
                mTheValue = value > MaxValue
                                ? MaxValue
                                : value;
        }
    }
}

class Program {
    static void Main()
    {
        LimitedInt li = 500; //将500转换为LimitedInt
        int value = li; //将LimitedInt转换为int

        Console.WriteLine($"li: { li.TheValue }, value: { value }");
    }
}
```

运行结果如下：

``` console
li: 100, value: 100
```

### 显式转换和转换运算符 Explicit Conversion and the Cast Operator
将上述代码改为 explicit ，并且在实现转换时显式使用转换运算符。**转换运算符 cast operator** 由想要把表达式转换成的目标类型的名称组成，放在一对圆括号内：`LimitedInt li = (LimitedInt) 500;`。改变的部分代码如下：

``` C#
public static explicit operator int(LimitedInt li)
{
    return li.TheValue;
}

public static explicit operator LimitedInt(int x)
{
    LimitedInt li = new LimitedInt();
    li.TheValue = x;
    return li;
}

static void Main()
{
    LimitedInt li = (LimitedInt) 500;
    int value = (int) li;

    Console.WriteLine($"li: { li.TheValue }, value: { value }");
}
```

运行结果如下：

``` console
li: 100, value: 100
```

> is 和 as 运算符接受一种类型的值，并返回另一种不同的、指定类型的值。详见第17章。

## 运算符重载 Operator Overloading
C# 运算符被定义为使用预定义类型作为操作数，而**运算符重载**允许定义 C# 运算符应该如何操作自定义类型的操作数。  
①运算符重载只能用于类和结构；  
②为类或结构重载一个运算符 x ，可以声明一个名称为 operate x 的方法并实现它的行为：  
&emsp;&emsp;- 一元运算符的重载方法带有一个单独的 class 或 struct 类型的参数；  
&emsp;&emsp;- 二元运算符的重载方法带两个参数，其中至少有一个必须是class 或 struct 类型。  
③运算符重载的方法声明必须同时使用 static 和 public 的修饰符，且运算符必须是要操作的类或结构的成员。  


### 运算符重载的示例
以下代码展示了3个运算符的重载：负数、减法和加法。

``` C#
class LimitedInt
{
    const int MaxValue = 100;
    const int MinValue = 0;

    public static LimitedInt operator -(LimitedInt x)
    {
        //取一个值的负数等于0
        LimitedInt li = new LimitedInt();
        li.TheValue = 0;
        return li;
    }

    public static LimitedInt operator -(LimitedInt x, LimitedInt y)
    {
        LimitedInt li = new LimitedInt();
        li.TheValue = x.TheValue - y.TheValue;
        return li;
    }

    public static LimitedInt operator +(LimitedInt x, double y)
    {
        LimitedInt li = new LimitedInt();
        li.TheValue = x.TheValue + (int)y;
        return li;
    }

    private int _theValue = 0;
    public int TheValue
    {
        get { return _theValue; }
        set
        {
            if (value < MinValue)
                _theValue = 0;
            else
                _theValue = value > MaxValue
                                ? MaxValue
                                : value;
        }
    }
}

class Program
{
    static void Main()
    {
        LimitedInt li1 = new LimitedInt();
        LimitedInt li2 = new LimitedInt();
        LimitedInt li3 = new LimitedInt();
        li1.TheValue = 10; li2.TheValue = 26;
        Console.WriteLine($" li1: { li1.TheValue }, li2: { li2.TheValue }");

        li3 = -li1;
        Console.WriteLine($"-{ li1.TheValue } = { li3.TheValue }");

        li3 = li2 - li1;
        Console.WriteLine($" { li2.TheValue } - { li1.TheValue } = { li3.TheValue }");

        li3 = li1 - li2;
        Console.WriteLine($" { li1.TheValue } - { li2.TheValue } = { li3.TheValue }");
    }
}
```

运行结果如下：

``` console
 li1: 10, li2: 26
-10 = 0
 26 - 10 = 16
 10 - 26 = 0
```

### 运算符重载的限制
不是所有的运算符都能被重载：  
①可重载的一元运算符：+ , - , ! , ~ , ++ , \-\- , true , false  
②可重载的二元运算符：+ , - , * , / , % , & , | , ^ , << , >> , == , != , > , < , >= , <=

运算符重载不能创建新运算符；不能改变运算符语法；不能重新定义如何处理预定义类型；不能改变运算符的优先级和结合性。

递增运算符和递减运算符也可以重载：  
①在运行时，代码对对象执行前置操作（递增或递减）时，会发生以下行为：  
&emsp;&emsp;- 在对象上执行递增或递减代码；  
&emsp;&emsp;- 返回对象。  
②在运行时，代码对对象执行后置操作（递增或递减）时，会发生以下行为：  
&emsp;&emsp;- 如果对象是值对象，则系统会复制该对象；如果对象是引用类型，则引用会被复制；  
&emsp;&emsp;- 在对象上执行递增或递减代码；  
&emsp;&emsp;- 返回保存的操作数。

对于引用类型的对象，前置操作没问题。但是对于后置操作，因为保存的副本是引用的副本，即指向同一对象，当执行到第二步操作时，递增或递减代码影响了对象，会导致保存的引用指向的对象不是起始状态。

示例如下，可以运行以下代码2次，第二次将 MyType 的类型改为类，会得到不同结果：

``` C#
using static System.Console;

public struct MyType //运行两次，一个是结构体，一次是类
{
    public int X;
    public MyType( int x )
    {
        X = x;
    }

    public static MyType operator ++( MyType m )
    {
        m.X++;
        return m;
    }
}

class Test
{
    static void Show( string message, MyType tv )
    {
        WriteLine( $"{message} {tv.X}" );
    }

    static void Main()
    {
        MyType tv = new MyType( 10 );
        WriteLine( "Pre-increment" );
        Show( "Before ", tv );
        Show( "Returned ", ++tv );
        Show( "After ", tv );
        WriteLine();

        tv = new MyType( 10 );
        WriteLine( "Post-increment" );
        Show( "Before ", tv );
        Show( "Returned ", tv++ );
        Show( "After ", tv );
    }
}
```

运行结果如下：

``` console
Pre-increment
Before  10
Returned  11
After  11

Post-increment
Before  10
Returned  10
After  11
```

如果将 MyType 改为类，运行结果如下：

``` console
Pre-increment
Before  10
Returned  11
After  11

Post-increment
Before  10
Returned  11
After  11
```

## typeof 运算符
**typeof 运算符**返回作为其参数的任何类型的 System.Type 对象。通过这个对象可以了解类型的特征。typeof 运算符是一元运算符。

下面是 typeof 运算符语法的示例，Type 是 System 命名空间中的一个类，代码使用了 typeof 运算符以获取 SomeClass 类的信息，并打印出公有字段和方法的名称：

``` C#
using System.Reflection; //使用反射命名空间来全面利用检测类型信息的功能

class SomeClass
{
    public int Field1;
    public int Field2;

    public void Method1() { }
    public int Method2() { return 1; }
}

class Program
{
    static void Main()
    {
        Type t = typeof(SomeClass);
        FieldInfo[] fi = t.GetFields();
        MethodInfo[] mi = t.GetMethods();

        foreach (FieldInfo f in fi)
            Console.WriteLine($"Field : { f.Name }");
        foreach (MethodInfo m in mi)
            Console.WriteLine($"Method: { m.Name }");
    }
}
```

运行结果如下：

``` console
Field : Field1
Field : Field2
Method: Method1
Method: Method2
Method: GetType
Method: ToString
Method: Equals
Method: GetHashCode
```

**GetType** 方法也会调用 typeof 运算符，该方法对每个类型的每个对象都有效，示例如下：

``` C#
class SomeClass
{
}

class Program
{
    static void Main()
    {
        SomeClass s = new SomeClass();

        Console.WriteLine($"Type s: { s.GetType().Name }");
    }
}
```

运行结果如下：

``` console
Type s: SomeClass
```

## nameof 运算符
**nameof 运算符**返回一个表示传入参数的字符串，以下示例展示了可以作为参数传递给 nameof 运算符的不同项，注释的括号里是每个语句的输出：

``` C#
string var1 = "Local Variable";
Console.WriteLine (nameof (var1)); //局部变量("var1")
Console.WriteLine (nameof (MyClass)); //类("MyClass")
Console.WriteLine (nameof (MyClass.Method1)); //公有方法("Method1")
Console.WriteLine (nameof (parameter1)); //方法参数("parameter1")
Console.WriteLine (nameof (MyClass.Property1)); //公有属性("Property1")
Console.WriteLine (nameof (MyClass.Field1)); //公有字段("Field1")
Console.WriteLine (nameof (MyStruct)); //结构体("MyStruct ")
```

即使参数使用完全限定名，nameof 运算符也只返回其参数的非限定名称。

nameof 运算符主要用于代码名称会变更的时候。

## 其他运算符
以上介绍的运算符都是内置类型的标准运算符，后面还有一些特殊用法的运算符。


# 第十章 语句
## 什么是语句
**语句 statement** 是描述某个类型或让程序执行某个动作的源代码指令。语句主要有3种类型：  
①**声明语句 Declaration statements** ：声明类型或变量；  
②**嵌入语句 Embedded statements** ：执行动作或管理控制流；  
③**标签语句 Labeled statements** ：控制跳转。

**块**是由一对大括号括起来的语句序列，括起来的语句可以包括：声明语句、嵌入语句、标签语句和嵌套块。块在语法上算作一个单条嵌入语句。任何语法上需要一个嵌入语句的地方，都可以使用块。

**简单语句**由一个表达式和后面跟着的分号组成。

``` C#
int x = 10; //简单声明
int z; //简单声明

{ //块
    int y = 20; //简单声明
    z = x + y; //嵌入语句
top: y = 30; //标签语句
        ...
    { //嵌套块
        ...
    } //结束嵌套块
} //结束外部块
```

**空语句**仅由一个分号组成，一般用在语法需要一条嵌入语句，但又不需要它有任何动作，示例如下：

``` C#
if( x < y )
    ; //空语句
else
    z = a + b; //简单语句
```

## 表达式语句
可以在表达式后面放置语句终结符（分号）来从一个表达式创建一条语句，表达式返回的任何值都会被丢弃。比如：`x = 10;` 该表达式把运算符右边的值赋给变量 x 引用的内存位置，设置了 x 的值后，表达式返回 x 的新值，然后因为没有东西接受该值，该值被忽略。

## 控制流语句 Flow-of-Control Statements
**条件执行语句 Conditional execution statements** 包括：`if` , `if...else` , `switch` ;  
**循环语句 Looping statements** 包括：`while` , `do` , `for` , `foreach` ;  
**跳转语句 Jump statements** 包括：`break` , `continue` , `return` , `goto` , `throw` ;

> 与 C 和 C++ 不同，数字在 C# 没有布尔意义。

## if 语句
**if 语句**实现按条件执行：

``` C#
if( TestExpr )
    Statement
```

①TestExpr 必须计算成 bool 型值；  
②如果 TestExpr 求值为 true ，执行 Statement ；  
③如果求值为 false ，则跳过 Statement 。

示例如下：

``` C#
//简单语句
if( x <= 10 )
    z = x – 1; //简单语句不需要大括号

//块
if( x >= 20 )
{
    x = x – 5; //块需要大括号
    y = x + z;
}

int x = 5;
if( x ) //错误：表达式必须是bool型，而不是int型
{
    ···
}
```

## if...else 语句
**if...else 语句**实现双路分支：

``` C#
if( TestExpr )
    Statement1
else
    Statement2
```

①如果 TestExpr 求值为 true，执行 Statement1 。  
②如果求值为 false，执行 Statement2 .

示例如下：

``` C#
if( x <= 10 )
    z = x – 1; //简单语句
else
{
    x = x – 5; //多条语句组成的语句块
    y = x + z;
}
```

Statement1 和 Statement2 可以嵌套 if 或 if...else 语句。当 Statement2 是 if 或 if...else 语句，常常会格式化为下面的形式：

``` C#
if( TestExpr1 )
    Statement1
else if ( TestExpr2 )
    Statement2
else
    Statement3
```

## while 循环
**while 循环**是一种简单循环结构，其测试表达式在循环顶部执行：

``` C#
while( TestExpr )
    Statement
```

①若 TestExpr 求值为 true 时，执行 Statement，并且再次对 TestExpr 求值，直到 TestExpr 求值为 false ；  
②若 TestExpr 求值为 false，执行在 while 循环结尾之后的语句。

示例如下：

``` C#
int x = 3;
while( x > 0 )
{
    Console.WriteLine($"x: { x }");
    x--;
}
Console.WriteLine("Out of loop");
```

## do 循环
**do 循环**是一种简单循环结构，其测试表达式在循环底部执行：

``` C#
do
    Statement
while( TestExpr ); //结束do循环，别忘了分号
```

①首先执行 Statement ；  
②然后，对 TestExpr 求值。若为 true，再次执行 Statement，再重复，直到返回 false ，控制传递到循环结构结尾之后的语句。

示例如下：

``` C#
int x = 0;
do
    Console.WriteLine($"x is {x++ }");
while (x<3); //分号是必需的，别忘了
```

## for 循环
只要测试表达式在循环体顶端计算时返回 true，for循环结构就会执行循环体：

``` C#
for( Initializer ; TestExpr ; IterationExpr )
    Statement
```

①在 for 循环开始时，执行一次 Initializer 。Initializer 只执行一次，常用于声明和初始化循环中使用的局部变量；  
②然后对 TestExpr 求值，若为 true ，执行 Statement ，接着执行 IterationExpr 。接着控制回到循环顶端，再次对 TestExpr 求值，重复步骤，直到返回 false ，执行循环之后的语句；  
③ Initializer 、TestExpr 和 IterationExpr 都是可选的。若 TestExpr 为空，测试返回 true ，会进入无限循环，需要有退出该语句的方法。作为字段分隔符，两个分号是必须的，即使省略了上述部分。

示例如下：

``` C#
//执行3次for循环体
for( int i=0 ; i<3 ; i++ )
    Console.WriteLine($"Inside loop. i: { i }");

Console.WriteLine("Out of Loop");
```

### for 语句中变量的作用域
任何声明在 initializer 中的变量只在该 for 语句的内部可见，和 C 和 C++ 不同。

> 循环变量常常使用标识符 i、j、k 。

### 初始化和迭代表达式中的多表达式
初始化表达式和迭代表达式都可以包含多个表达式，只需要用逗号隔开，示例如下：

``` C#
static void Main( )
{
    const int MaxI = 5;

    for (int i = 0, j = 10; i < MaxI; i++, j += 10)
    {
        Console.WriteLine($"{ i }, { j }");
    }
}
```

## switch 语句
switch 语句实现多路分支：

``` C#
switch( TestExpr )
{
    case Expr1:
        StatementList
            break;
            ···
    
    case ExprN:
        StatementList
            break;
    
    default:
        StatementList
            break;
}
```

①switch 语句有一个被称为**测试表达式**或**匹配表达式**的参数，C# 7.0 后允许测试表达式为任何类型；  
②switch 语句包含0个或多个**分支块 switch sections** ；  
③每个分支块都以一个或多个**分支标签 switch labels**开头，switch 标签形式：`case PatternExpression:` ，case 为关键字，冒号为分支标签结束符。每个分支标签后面跟着一个模式表达式，该模式表达式与测试表达式比较。如果模式表达式和测试表达式都是整数类型，使用 C# 的相对运算符 == 进行比较。在所有其他情况下，则使用静态方法 Object.Equals(test, pattern) 进行比较，即对于非整数类型，C# 使用深度比较。在 C# 7.0 之前，case 后面的表达式必须是常量表达式ConstantExpression，必须在编译时被编译器计算，现在这个约束不适用。  
④每个分支块遵循“不穿过规则”，即表达语句不能到达终点并且进入下一个分支，一般使用**跳转语句**来结束表达语句列表，包括 break 、return 、continue 、goto 和 throw 。goto 跳转语句不能与非常量 switch 表达式一起使用。  
⑤分支块会按顺序执行。如果其中一个分支块与测试表达式的值匹配，则执行这个分支块，然后控制流会跳转到该分支块中使用的跳转语句指定的位置。由于 break 语句是最常用的跳转语句，所以通常控制流会跳转到 switch 语句结束后的代码。  
⑥一个switch 语句可以有任意数目的分支，也可以没有分支。default 分支是可选的，若包括了，也要以一条跳转语句结束。拥有 default 是好习惯，因为它可以捕获潜在错误。

### 分支示例

``` C#
for( int x=1; x<6; x++ )
{
    switch( x ) //计算变量x的值
    {
        case 2: //如果x=2
            Console.WriteLine($"x is { x } -- In Case 2");
            break; //结束switch语句
        
        case 5: //如果x=5
            Console.WriteLine($"x is { x } -- In Case 5";
            break; //结束switch语句
        
        default: //如果x既不等于2也不等于5
            Console.WriteLine($"x is { x } -- In Default case");
            break; //结束switch语句
    }
}
```

### 其他类型的模式表达式
**case 标签**由**关键字 case** 和其后面的模式构成，模式可以是简单的值，或者表达式，也可以是一个类型。模式也可以使用**关键字 when** 来包含一个过滤器。

示例如下：

``` C#
public abstract class Shape { }

public class Square : Shape
{
    public double Side {get; set;}
}

public class Circle : Shape
{
    public double Radius {get; set;}
}

public class Triangle : Shape
{
    public double Height {get; set;}
}

class Program
{
    static void Main()
    {
        var shapes = new List<Shape>();
        shapes.Add(new Circle() { Radius = 7 });
        shapes.Add(new Square() { Side = 5 });
        shapes.Add(new Triangle() { Height = 4 });
        var nullSquare = (Square)null;
        shapes.Add(nullSquare);

        foreach (var shape in shapes )
        {
            switch( shape ) //判断类型或者shape变量的值
            {
                case Circle circle: //等价于 if(shape is Circle)
                    Console.WriteLine($"This shape is a circle of radius { circle.Radius }");
                    break;
                case Square square when square.Side > 10: //仅仅匹配一部分Square
                    Console.WriteLine($"This shape is a large square of side { square.Side }");
                    break;
                case Square square:
                    Console.WriteLine($"This shape is a square of side { square.Side }");
                    break;
                case Triangle triangle: //等价于 if(shape is Triangle)
                    Console.WriteLine($"This shape is a triangle of side { triangle.Height }");
                    break;
                //case Triangle triangle when triangle.Height < 5: //编译错误
                    //Console.WriteLine($"This shape is a triangle of side { triangle.Height }");
                    //break;
                case null:
                    Console.WriteLine($"This shape could be a Square, Circle or a Triangle");
                    break;
                default:
                    throw new ArgumentException(
                        message: "shape is not a recognized shape",
                        paramName: nameof(shape));
            }
        }
    }
}
```

运行结果如下：

``` console
This shape is a circle of radius 7
This shape is a square of side 5
This shape is a triangle of side 4
This shape could be a Square, Circle or a Triangle
```

上面注释掉的代码会导致编译错误，因为永远到达不了这个case，它是前一个一般 case 的受限的 case 。

### switch 语句的补充
C# 允许把多个分支标签附加到任意分支，只要这些分支标签之间没有插入可执行语句。示例如下：

``` C#
switch( x )
{
    case 1: //可接受的
    case 2:
    case 3: //如果x等于1、2、3，则执行该代码
        ···
        break;
    case 5:
        y = x + 1;
    case 6: //因为没有break，所以不可以接受
        ···
}
```

但是如果在同一分支存在多个模式，因为无法确定匹配的是哪个模式，所以不能在构成该块的语句中使用这些变量，可能会导致空引用异常，比如：

``` C#
case Square s:
case Circle c:
    Console.WriteLine($“Square has dimensions: { s.Side } x { s.Side }”);
    Console.WriteLine($“Found a Circle of radius { c.Radius }”);
    break;
```

还有就是虽然结束分支块的最常用方法是使用5个跳转语句中的一个，但是也可以不用，当某个结构可以使语句列表满足“不穿过规则”时，即不直接进入下一个分支块，编译器是可以检测到的。

## 跳转语句 Jump Statements
当控制流到达**跳转语句**时，程序执行被无条件地转移至程序的另一部分，包括：`break` , `continue` , `return` , `goto` , `throw` 。throw 语句详见第23章。

## break 语句
**break 语句**可以被用在 switch 、for 、foreach 、while 、do 语句中。在这些语句体中，break 会导致执行跳出**最内层封装语句 the innermost enclosing loop** 。

``` C#
int x = 0;
while( true )
{
    x++;
    if( x >= 3 )
        break;
}
```

## continue 语句
**continue 语句**可以被用在 for 、foreach 、while 、do 语句中。在这些语句体中，continue 会导致执行转到**最内层封装语句 the innermost enclosing loop** 的顶端。

``` C#
for( int x=0; x<5; x++ ) //执行循环5次
{
    if( x < 3 ) //先执行3次
        continue; //直接回到循环开始处
    //当x>=3时执行下面语句
    Console.WriteLine($"Value of x is { x }");
}
```

## 标签语句 Labeled Statements
**标签语句**由一个标识符后面跟着一个冒号和语句组成：`Identifier: Statement` 。

标签语句的执行如同标签不存在一样，仅执行 Statement 部分：  
①给语句增加一个标签允许控制从代码的其他部分转移到该语句；  
②标签语句只允许用在块内部。

### 标签
标签有自己的命名空间，标签语句的标识符可以是任何有效的标识符，包括局部变量或参数名。但标识符不能是关键字，也不能在重叠范围内和另一个标签标识符相同。

下面代码展示了标签的有效使用，该标签和一个局部变量有相同的标识符：

``` C#
{
    int xyz = 0; //变量xyz
        ...
    xyz: Console.WriteLine("No problem."); //标签xyz
}
```

### 标签语句的作用域
标签语句的作用域为：它声明所在的块；任何嵌套在该块内部的块。标签语句在其声明所在块的外部不可见或不可访问。

``` C#
static void Main()
{ //作用域A
    { //作用域B
        increment: x++;
        { //作用域C

            { //作用域D
                ···
            }
            { //作用域E
                ···
            }
            ···
        }
        end: Console.WriteLine("Exiting")
    }
}
```

①2个标签语句的有效代码区域为作用域B及以内；  
②作用域B和所有嵌套块中的代码都能看到并访问标签语句；  
③从作用域内部的任何位置，代码都能跳出到标签语句；  
④作用域A的代码不能跳入到标签语句的块中。

## goto 语句
**goto 语句**无条件地将控制转移到一个**标签语句**，一般形式：`goto Identifier ;` ，其中 Identifier 是标签语句的标识符。

``` C#
bool thingsAreFine;
while (true)
{
    thingsAreFine = GetNuclearReactorCondition();

    if ( thingsAreFine )
        Console.WriteLine("Things are fine.");
    else
        goto NotSoGood;
}

NotSoGood: Console.WriteLine("We have a problem.");
```

goto 语句必须在标签语句的作用域之内：  
①goto 语句可以跳到它所在块内的任何标签语句，或跳出到任何嵌套它的块内的标签语句；  
②goto 语句不能跳入嵌套在其所在块内部的任何块。

> 尽量不使用 goto 语句，它会导致弱结构化、难以调试和维护的代码。

### switch 语句内部的 goto 语句
goto 语句也可以把控制转到 switch 语句内部的分支标签，但是 goto 标签只能引用编译时常量，如同 C# 7.0 之前的 switch 语句一样。形式如下：

`goto case ConstantExpression;`  
`goto default;`  
`goto case PatternExpression; //编译错误`

## using 语句
某些类型的非托管对象有数量限制或很耗费系统资源，在代码适用完它们后，尽快释放它们很重要。**using 语句**有助于简化该过程并确保这些资源被适当地处置。

**资源**是指实现了 System.IDisposable 接口的类或结构，接口详见第16章，简单来说，接口就是未实现的函数成员的集合，类和结构可以选择去实现它们。IDisposable 接口含有单独一个名称为 Dispose 的方法。

使用资源的阶段如下图，包括分配资源；使用资源；处置资源：

<div  align="center">  
<img src="https://s2.loli.net/2023/01/07/Vb2FD1TpHiBUE9G.png" width = "55%" height = "55%" alt="图48 - 使用资源的阶段"/>
</div>

> 区分 using 语句和 using 指令（比如使用 System.Math;），using 指令见第22章。

### 包装资源的使用
using 语句帮助减少意外的运行时错误（即异常，见第23章）带来的潜在问题，整洁地包装了资源的使用。有两种形式的 using 语句。

第一种形式：`using ( ResourceType Identifier = Expression ) Statement`  
①圆括号内的代码分配资源；  
②Statement 是使用资源的代码；  
③using 语句隐式地产生处置资源的代码。

处理可能的异常的标准方法是把可能导致异常的代码放入一个 try 块里，并把任何无论有没有异常都执行的代码放进一个 finally 块中。这种形式的 using 语句就是这么做的，先分配资源，再把 Statement 放进 try 块，最后创建资源的 Dispose 方法的调用，并放进 finally 块，见下图：

<div  align="center">  
<img src="https://s2.loli.net/2023/01/07/DXOR5fV387KYo2W.png" width = "70%" height = "70%" alt="图49 - using语句的效果"/>
</div>

### using 语句的示例
TextWriter 和 TextReader 的类，来自 System.IO 命名空间，都实现了 IDisposable 接口，这是 using 语句的要求：

``` C#
using System; //using指令，不是using语句
using System.IO;

namespace UsingStatement
{
    class Program
    {
        using (TextWriter tw = File.CreateText("Lincoln.txt") )
        {
            tw.WriteLine("Four score and seven years ago, ...");
        }

        using (TextReader tr = File.OpenText("Lincoln.txt"))
        {
            string InputString;
            while (null != (InputString = tr.ReadLine()))
                Console.WriteLine(InputString);
        }
    }
}
```

运行结果如下：

``` console
Four score and seven years ago, ...
```

### 多个资源和嵌套
using 语句可以使用相同类型的多个资源，资源声明用逗号隔开：`using ( ResourceType Id1 = Expr1, Id2 = Expr2, ... ) EmbeddedStatement`

``` C#
static void Main()
{
    using (TextWriter tw1 = File.CreateText("Lincoln.txt"),
                      tw2 = File.CreateText("Franklin.txt"))
    {
        tw1.WriteLine("Four score and seven years ago, ...");
        tw2.WriteLine("Early to bed; Early to rise ...");
    }

    using (TextReader tr1 = File.OpenText("Lincoln.txt"),
                      tr2 = File.OpenText("Franklin.txt"))
    {
        string InputString;

        while (null != (InputString = tr1.ReadLine()))
            Console.WriteLine(InputString);

        while (null != (InputString = tr2.ReadLine()))
            Console.WriteLine(InputString);
    }
}
```

using 语句还可以嵌套：

``` C#
using ( TextWriter tw1 = File.CreateText("Lincoln.txt") )
{
    tw1.WriteLine("Four score and seven years ago, ...");

    using ( TextWriter tw2 = File.CreateText("Franklin.txt") ) //嵌套语句
        tw2.WriteLine("Early to bed; Early to rise ..."); //简单语句
}
```

### using 语句的另外一种形式
语法：`using ( Expression ) EmbeddedStatement`，在这种形式中，资源在 using 语句之前声明。

``` C#
TextWriter tw = File.CreateText("Lincoln.txt"); //声明资源

using ( tw )
    tw.WriteLine("Four score and seven years ago, ...");
```

这种形式不推荐，见下图：

<div  align="center">  
<img src="https://s2.loli.net/2023/01/07/xXTcoYRzK7fOi9d.png" width = "70%" height = "70%" alt="图50 - 资源声明在using语句之前"/>
</div>

## 其他语句

| 语句 | 描述 | 相关章节 |
| :---- | :---- | :---- |
| checked, unchecked | 控制溢出检查上下文 | 第17章 |
| foreach | 遍历一个集合的每个成员 | 第13和19章 |
| try, throw, finally | 处理异常 | 第23章 |
| return | 将控制返回到调用函数的成员，而且还能返回一个值 | 第6章 |
| yield | 用于迭代 | 第19章 |

# 第十一章 结构
## 什么是结构
**结构 struct** 是用户定义的数据类型，跟类类似，也有数据成员和函数成员，与类的最重要区别包括：  
①类是引用类型，而结构是值类型；  
②结构是隐式密封的，即不能从它们派生其他结构。

``` C#
struct Point
{
    public int X;
    public int Y;
}

class Program
{
    static void Main()
    {
        Point first, second, third;

        first.X = 10; first.Y = 10;
        second.X = 20; second.Y = 20;
        third.X = first.X + second.X;
        third.Y = first.Y + second.Y;

        Console.WriteLine($"first: { first.X }, { first.Y }");
        Console.WriteLine($"second: { second.X }, { second.Y }");
        Console.WriteLine($"third: { third.X }, { third.Y }");
    }
}
```

## 结构是值类型
因为结构是值类型，因此：  
①结构类型的变量不能为 null ；  
②两个结构变量不能引用同一对象。

以下示例和图展示了类变量和结构变量的内存安排：

``` C#
class CSimple
{
    public int X;
    public int Y;
}

struct Simple
{
    public int X;
    public int Y;
}

class Program
{
    static void Main()
    {
        CSimple cs = new CSimple();
        Simple ss = new Simple();
            ···
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2023/01/09/aVAIuwlSvWsLTYi.png" width = "50%" height = "50%" alt="图51 - 类与结构的内存安排"/>
</div>

## 对结构赋值
把一个结构赋值给另一个结构，就是将一个结构的值复制给另一个结构。这和复制类变量不同，复制类变量时只复制引用。示例如下：

``` C#
class CSimple
{ public int X; public int Y; }

struct Simple
{ public int X; public int Y; }

class Program
{
    static void Main()
    {
        CSimple cs1 = new CSimple(), cs2 = null; //类实例
        Simple ss1 = new Simple(), ss2 = new Simple(); //结构实例

        cs1.X = ss1.X = 5; //将5赋值ss1.X和cs1.X
        cs1.Y = ss1.Y = 10; //将10赋值ss1.Y和cs1.Y

        cs2 = cs1; //赋值类实例
        ss2 = ss1; //赋值结构实例
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2023/01/09/ybqUXVh7xHSclgw.png" width = "70%" height = "70%" alt="图52 - 类变量和结构变量赋值"/>
</div>

## 构造函数和析构函数 Constructors and Destructors
结构可以有实例构造函数和静态构造函数，但不允许有析构函数。

### 实例构造函数 Instance Constructors
语言隐式地为每个结构提供一个无参数的结构函数，这个构造函数把结构的每个成员设置为该类型的默认值，即值成员设置为它们的默认值，引用成员设置为 null 。

对于每个结构，都存在预定义的无参数构造函数，可以创建另外的构造函数，只要有参数。这和类不同，对于类，编译器只在没有声明其他构造函数时提供隐式的无参数构造函数。

调用构造函数，包括隐式无参数构造函数，要使用 new 运算符，即使不从堆中分配内存。

``` C#
struct Simple
{
    public int X;
    public int Y;

    public Simple(int a, int b) //带有参数的构造函数
    {
        X = a;
        Y = b;
    }
}

class Program
{
    static void Main()
    {
        Simple s1 = new Simple(); //调用隐式构造函数
        Simple s2 = new Simple(5, 10); //调用构造函数

        Console.WriteLine($"{ s1.X },{ s1.Y }");
        Console.WriteLine($"{ s2.X },{ s2.Y }");
    }
}
```

运行结果如下：

``` console
0,0
5,10
```

也可以不使用 new 运算符创建结构的实例，但是：  
①在显示地设置数据成员后，才能使用它们的值；  
②在对所有数据成员赋值之后，才能调用结构的函数成员。

``` C#
struct Simple
{
    public int X;
    public int Y;
}

class Program
{
    static void Main()
    {
        Simple s1, s2; //没有调用构造函数
        Console.WriteLine("{0},{1}", s1.X, s1.Y); //因为没有赋值，所以编译错误

        s2.X = 5;
        s2.Y = 10;
        Console.WriteLine($"{ s2.X },{ s2.Y }"); //没问题
    }
}
```

### 静态构造函数 Static Constructors
与类相似，结构的静态构造函数创建并初始化静态数据成员，而且不能引用实例成员。结构的静态构造函数与类类似，但允许有不带参数的静态构造函数。

以下行为，任意一种发生前，会调用静态构造函数：  
①调用显式声明的构造函数；  
②引用结构的静态成员。

### 构造函数和析构函数小结

| 类型 | 描述 |
| :---- | :---- |
| 实例构造函数（无参数） | 不能在程序中声明。系统为所有结构提供一个隐式的构造函数，不能被程序删除或重定义 |
| 实例构造函数（有参数） | 可以在程序中声明 |
| 静态构造函数 | 可以在程序中声明 |
| 析构函数 | 不能在程序中声明。不允许声明析构函数 |

## 属性和字段初始化语句
在声明结构体时，不允许使用实例属性和字段初始化语句。

``` C#
struct Simple
{
    public int x = 0; //不允许，编译错误
    public int y = 10; //不允许，编译错误

    public int prop1 {get; set;} = 5; //编译错误
}
```

但是结构体的静态属性和静态字段都可以在声明结构体时进行初始化，即使结构体本身不是静态的。

## 结构是密封的
结构总是隐式密封的，不能从它们派生其他结构。

不能用于结构的修饰符：protected 、protected internal 、abstract 、virtual 、sealed 。

结构本身派生自 System.ValueType ，而 System.ValueType 派生自 object 。

## 装箱和拆箱 Boxing and Unboxing
装箱和拆箱详见第17章。因为结构实例是值类型数据，要作为引用类型对象，必须创建装箱的副本。装箱的过程就是制作值类型变量的引用类型副本。

## 结构作为返回值和参数
①当结构作为返回值，将创建它的副本并从函数成员返回；  
②当结构被用作值参数，将创建实参结构的副本，用于方法的执行中；  
③如果把一个结构用作 ref 和 out 参数，传入方法的是该结构的一个引用，这样就可以修改其数据成员。

## 关于结构的更多内容
对结构进行分配的开销比创建类实例小，但要注意装箱和拆箱的高昂代价。

其他事项：  
①预定义类型（比如 int 、short 、long 等等），尽管是原始类型，但实际上在 .NET 都实现为结构；  
②可以使用与声明分部类相同的方法声明分结构，见第7章；  
③结构和类一样，都能实现接口，见第16章。


# 第十二章 枚举
## 枚举 Enumerations
**枚举 enumeration** 也是用户定义的类型。枚举是值类型，只有一种类型的成员：命名的整数值常量。

示例如下，注意成员声明列表是逗号分隔的，在枚举声明中没有分号：

``` C#
enum TrafficLight
{
    Green,
    Yellow,
    Red
}
```

每个枚举类型都有一个底层整数类型，默认为 int ：每个枚举成员都被赋予一个底层类型的常量值，默认情况下，第一个成员赋值为0，第二个为1，以此类推。

即在上面示例的 TrafficLight 类型中，编译器把 int 值0、1、2分别赋值给了 Green 、Yellow 和 Red 。*在代码输出中，需要把他们转换为类型 int ，才能看到底层的成员值，否则成员名被当作字符串打印。*

``` C#
TrafficLight t1 = TrafficLight.Green;
TrafficLight t2 = TrafficLight.Yellow;
TrafficLight t3 = TrafficLight.Red;

Console.WriteLine($"{ t1 },\t{(int) t1 }");
Console.WriteLine($"{ t2 },\t{(int) t2 }");
Console.WriteLine($"{ t3 },\t{(int) t3 }");
```

运行结果如下：

``` console
Green,  0
Yellow, 1
Red,    2
```

<div  align="center">  
<img src="https://s2.loli.net/2023/01/10/7ydJ1cPGXUWwR9H.png" width = "65%" height = "65%" alt="图53 - 枚举的成员常量表示为底层整数值"/>
</div>

### 设置底层类型和显式值
可以把冒号和类型名放在枚举名之后，把枚举设置为任何整数类型，所有枚举成员常量都为该类型：`enum TrafficLight : ulong`

可以显式地设置一个成员常量的值，即在枚举声明中的变量名之后使用初始化表达式。

``` C#
enum TrafficLight : long
{
    Green = 10L,
    Yellow = 15L,
    Red = 15L
}
```

### 隐式成员编号
如果不初始化成员常量，编译器会隐式地给它赋值，并且比前一个成员常量大1：

``` C#
enum CardSuit {
    Hearts, //0
    Clubs, //1
    Diamonds, //2
    Spades, //3
    MaxSuits //4
}

enum FaceCards {
    Jack = 11, //11，显式设置
    Queen, //12，比之前大1
    King, //13
    Ace, //14
    NumberOfFaceCards = 4, //4，显式设置
    SomeOtherValue, //5
    HighestFaceCard = Ace //14
}
```

## 位标志 Bit Flags
程序员长期使用单个字的不同位作为表示一组开关标志的方法，即**标志字 flag word** 。枚举可以实现它，一般步骤如下：  
①确定需要多少个位标志，选择一种足够多位的无符号类型来保存它；  
②确定每个位位置代表什么，并给它们名称。声明一个选中的整数类型的枚举，每个成员由一个位位置表示；  
③使用按位或 OR 运算符在持有该位标志的字中设置适当的位；  
④使用按位与 AND 运算符或 HasFlag 方法检查是否设置了特定位标志。

步骤2示例如下：

``` C#
[Flags]
enum CardDeckSettings : uint
{
    SingleDeck = 0x01, //位0
    LargePictures = 0x02, //位1
    FancyNumbers = 0x04, //位2
    Animation = 0x08 //位3
}
```

使用 Flags 特性 attribute 装饰枚举不是必需的，但是可以带来额外的便利，详见第25章。

<div  align="center">  
<img src="https://s2.loli.net/2023/01/10/mrRg62fGHvcVzux.png" width = "70%" height = "70%" alt="图54 - 标志位的定义（左）和它们各自代表的值（右）"/>
</div>

步骤3：要创建一个带有适当的位标志的字，需要声明一个该枚举类型的变量，并使用按位或运算符设置需要的位，如下：

``` C#
CardDeckSettings ops = CardDeckSettings.SingleDeck
                    | CardDeckSettings.FancyNumbers
                    | CardDeckSettings.Animation ;
```

步骤4：要判断标志字是否包含特定的位标志集，可以使用枚举类型的 HasFlag 布尔方法。在标志字上调用 HasFlag 方法，并将要检查的位标志作为参数，如果设置了指定的位标志，HasFlag 返回 true，否则返回 false 。如下：

``` C#
bool useFancyNumbers = ops.HasFlag(CardDeckSettings.FancyNumbers);
```

HasFlag 方法还可以检测多个位标志，可以创建一个测试字，并用 HasFlag 检测是否测试字中的所有标志都在 ops 标志字中进行了设置。如下：

``` C#
CardDeckSettings testFlags = CardDeckSettings.Animation | CardDeckSettings.FancyNumbers; 

bool useAnimationAndFancyNumbers = ops.HasFlag( testFlags );
```

另一种判断是否设置了一个或多个指定位的方法是使用按位与运算符：

``` C#
bool useFancyNumbers = (ops & CardDeckSettings.FancyNumbers) == CardDeckSettings.FancyNumbers;
```

<div  align="center">  
<img src="https://s2.loli.net/2023/01/11/BSh8D37ApQc5Lyr.png" width = "50%" height = "50%" alt="图55 - 生成一个标志字并检查一个特定的位标志"/>
</div>

### Flags 特性
Flags 特性通知编译器，该枚举的成员不仅可以用作单独的值，还可以组合成位标志。其次，它允许枚举的 ToString 方法为位标志的值提供更多的格式化信息。ToString 方法以一个枚举值为参数，将其与枚举的常量成员相比较，若匹配，ToString 返回该成员的字符串名称。

``` C#
enum CardDeckSettings : uint
{
    SingleDeck = 0x01, //位0
    LargePictures = 0x02, //位1
    FancyNumbers = 0x04, //位2
    Animation = 0x08 //位3
}

class Program {
    static void Main( ) {
        CardDeckSettings ops;
        ops = CardDeckSettings.FancyNumbers; //设置一个标志
        Console.WriteLine( ops.ToString() );
                                             //设置两个标志
        ops = CardDeckSettings.FancyNumbers | CardDeckSettings.Animation;
        Console.WriteLine( ops.ToString() ); 
    }
}
```

运行结果如下：

``` console
FancyNumbers
12
```


该枚举没有 Flags 特性，第二次赋值的结果是12，是因为 ToString 方法会查找哪个枚举成员具有12，由于没找到，返回了12。然而，如果在枚举声明前加上 Flags 特性，ToString 方法就可以发现12对应两个分开的位标志成员，即 FancyNumbers 和 Animation 。运行包含 Flags 特性的代码，结果如下：

``` console
FancyNumbers
FancyNumbers, Animation
```

### 使用位标志的示例

``` C#
[Flags]
enum CardDeckSettings : uint
{
    SingleDeck = 0x01, //位0
    LargePictures = 0x02, //位1
    FancyNumbers = 0x04, //位2
    Animation = 0x08 //位3
}

class MyClass {
    bool UseSingleDeck = false,
         UseBigPics = false,
         UseFancyNumbers = false,
         UseAnimation = false,
         UseAnimationAndFancyNumbers = false;

    public void SetOptions( CardDeckSettings ops ) 
    {
        UseSingleDeck = ops.HasFlag( CardDeckSettings.SingleDeck );
        UseBigPics = ops.HasFlag( CardDeckSettings.LargePictures );
        UseFancyNumbers = ops.HasFlag( CardDeckSettings.FancyNumbers );
        UseAnimation = ops.HasFlag( CardDeckSettings.Animation );

        CardDeckSettings testFlags =
                        CardDeckSettings.Animation | CardDeckSettings.FancyNumbers;
        UseAnimationAndFancyNumbers = ops.HasFlag( testFlags );
    }

    public void PrintOptions( )
    {
    Console.WriteLine( "Option settings:" );
    Console.WriteLine($" Use Single Deck - { UseSingleDeck }");
    Console.WriteLine($" Use Large Pictures - { UseBigPics }");
    Console.WriteLine($" Use Fancy Numbers - { UseFancyNumbers }");
    Console.WriteLine($" Show Animation - { UseAnimation }");
    Console.WriteLine( " Show Animation and FancyNumbers – {0}",
                    UseAnimationAndFancyNumbers );
    }
}

class Program
{
    static void Main( )
    {
        MyClass mc = new MyClass( );
        CardDeckSettings ops = CardDeckSettings.SingleDeck
                            | CardDeckSettings.FancyNumbers
                            | CardDeckSettings.Animation;
        mc.SetOptions( ops );
        mc.PrintOptions( );
    }
}
```

运行结果如下：

``` console
Option settings:
 Use Single Deck - True
 Use Large Pictures - False
 Use Fancy Numbers - True
 Show Animation - True
 Show Animation and FancyNumbers – True
```

## 关于枚举的更多内容
枚举只有单一的成员类型：声明的成员常量  
①不能对成员使用修饰符，它们都隐式地具有和枚举相同的可访问性；  
②由于成员是静态的，即使没有枚举变量也可以访问它们；  
③比较不同枚举类型的成员会导致编译时错误，即使两个枚举具有完全相同的结构和成员名。同一枚举不同成员可以比较；  

.NET Enum 类型（enum 就是基于该类型的）还包含一些有用的静态方法：  
①GetName 方法以一个枚举类型对象和一个整数为参数，返回相应的枚举成员名称；  
②GetNames 方法以一个枚举类型对象为参数，返回该枚举中所有成员的名称。

``` C#
enum TrafficLight
{
    Green,
    Yellow,
    Red
}

class Program
{
    static void Main()
    {
        Console.WriteLine( "Second member of TrafficLight is {0}\n",
                            Enum.GetName( typeof( TrafficLight ), 1 ) );
        
        foreach ( var name in Enum.GetNames( typeof( TrafficLight ) ) )
            Console.WriteLine( name );
    }
}
```

运行结果如下：

``` console
Second member of TrafficLight is Yellow

Green
Yellow
Red
```


# 第十三章 数组
## 数组 Arrays
数组是由一个变量名称表示的一组同类型的数据元素。每个元素通过变量名称和方括号中的一个或多个索引来访问：`MyArray[4]` 。

### 定义
①**元素 Elements**：数组的独立数据项称为元素，所有元素必须是相同类型或者继承自相同的类型；  
②**秩/维度 Rank/dimensions**：数组的维度数可以为任何正数，数组的维度数称作秩；  
③**维度长度 Dimension length**：数组的每一个维度有长度，就是这个方向的位置个数；  
④**数组长度 Array length**：数组的所有维度中的元素总数称为数组的长度。

### 重要细节
①数组一旦被创建，大小就固定了，C# 不支持动态数组；  
②数组索引号是从0开始。

一维数组：`int[5]`，秩=1，数组长度=5；二维数组：`int[3,6]`，秩=2，数组长度=18。

<div  align="center">  
<img src="https://s2.loli.net/2023/01/11/6QH7RTnq19eDaIp.png" width = "60%" height = "60%" alt="图56 - 维度和大小"/>
</div>

## 数组的类型
①**一维数组**可以认为是单行元素或元素向量；  
②**多维数组**是由主向量中的位置组成的，每个位置本身又是一个数组，称为子数组 subarray 。子数组向量中的位置本身又是一个子数组。

有两种类型的多维数组：**矩形数组 rectangular array** 和**交错数组 jagged array** ：  
①矩阵数组的某个维度的所有子数组具有相同长度，只有一组方括号：`myArray2[4, 6, 1]` ；  
②交错数组的每一个子数组都是独立数组，子数组可以不同长度，每个维度都使用一组方括号：`jagArray1[2][7][4]` 。

## 数组是对象
数据实例是从 System.Array 继承类型的对象。数组从 BCL 基类派生而来，它们也继承了 BCL 基类很多的成员，比如 Rank 返回数组维度数，Length 返回数组长度，如下图：

<div  align="center">  
<img src="https://s2.loli.net/2023/01/12/ALG15WS2PdqjZTu.png" width = "70%" height = "70%" alt="图57 - 数组的结构"/>
</div>

数组是引用类型，引用在栈或堆上，而数组对象本身总是在堆上。尽管数组是引用类型，数组的元素可以是值类型或者引用类型。若存储的元素是值类型，数组被称作**值类型数组 value type array** ；若存储的元素是引用类型，数组被称作**引用类型数组 reference type array** 。

## 一维数组和矩形数组
要声明一维数组和矩形数组，要在类型和变量名之间使用一组方括号。

方括号内的**逗号**就是**秩说明符 rank specifiers**，指明了数组的维度数，没有逗号代表一维数组，一个逗号代表二维数组。

基类型和秩说明符构成了数组类型：  
①可以使用多个秩说明符；  
②不能在数组类型区域中放数组维度长度。秩是数组类型的一部分，而维度长度不是；  
③数组声明后，维度数就是固定的，维度长度要等实例化时才确定。

``` C#
int[,,] firstArray; //数组类型：三维整数数组  
int[,] arr1; //数组类型：二维整数数组
long[,,] arr3; //数组类型：三维long数组

long[3,2,6] SecondArray; //不允许添加维度长度，编译错误
```

> 与 C 和 C++ 不同，方括号在基类型之后，而不是变量名称后。

## 实例化一维数组或矩形数组
**数组创建表达式 array-creation expression**由 new 运算符构成，后面是基类名称和一组方括号。方括号中以逗号分隔每一个维度长度。

``` C#
int[] arr2 = new int[4]; //包含4个int的一维数组
MyClass[] mcArr = new MyClass[4]; //包含4个MyClass引用的一维数组

int[,,] arr3 = new int[3,6,2]; //三维数组，数组长度3*6*2=36
```

<div  align="center">  
<img src="https://s2.loli.net/2023/01/12/KFJ4MufzRmohBNw.png" width = "65%" height = "65%" alt="图58 - 声明和实例化数组"/>
</div>

> 与对象创建表达式不同，数组创建表达式不包含圆括号。

## 访问数组元素
在数组中使用整数值作为索引来访问数组元素。

``` C#
int[] intArr1 = new int[15]; //声明一维数组
intArr1[2] = 10; //向第3个元素写入值
int var1 = intArr1[2]; //从第3个元素读取值

int[,] intArr2 = new int[5,10]; //声明二维数组
intArr2[2,3] = 7; //向数组写入值
int var2 = intArr2[2,3]; //从数组读取值
```

## 初始化数组
当数组被创建之后，每一个元素被自动初始化为类型的默认值。整数默认值为0，浮点型的默认值为0.0，布尔型的默认值为 false ，而引用类型的默认值为 null 。

### 显式初始化一维数组
对于一维数组，若要设置显式初始值，可以在数组实例化的数组创建表达式之后加上一个**初始化列表 initialization list** ：`int[] intArr = new int[] { 10, 20, 30, 40 };`，大括号及以内即初始化列表，初始值必须以逗号分隔。

*注意：显式初始化可以不输入维度长度，因为编译器可以通过初始化值的个数来推断长度。*

### 显式初始化矩形数组
`int[,] intArray2 = new int[,] { {10, 1}, {2, 10}, {11, 9} };`

<div  align="center">  
<img src="https://s2.loli.net/2023/01/12/kgSJKUNMA1wRxFQ.png" width = "45%" height = "45%" alt="图59 - 初始化矩形数组"/>
</div>

### 初始化矩形数组的语法点
矩形数组使用嵌套的、逗号分隔的初始化列表进行初始化：

``` C#
int[,,] intArray = new int[4,3,2] {
                                    { {8, 6}, {5, 2}, {12, 9} },
                                    { {6, 4}, {13, 9}, {18, 4} },
                                    { {7, 2}, {1, 13}, {9, 3} },
                                    { {4, 6}, {3, 2}, {23, 8} }
                                  };
```

### 快捷语法
在一条语句中使用声明、数组创建表达式和初始化列表时，可以省略语法的数组创建表达式部分：

比如，下面2个语句等价：  
`int[] arr1 = new int[3] {10, 20, 30};`  
`int[] arr1 =            {10, 20, 30};`  
又比如：  
`int[,] arr = new int[2,3] {{0, 1, 2},{10, 11, 12}};`  
`int[,] arr =              {{0, 1, 2},{10, 11, 12}};`  

### 隐式类型数组
当初始化数组时，可以使用 var 关键字让编译器根据初始化语句的类型来推断数组类型。只有所有初始化语句能隐式转换为单个类型，才能这么做。如下：

``` C#
int [] intArr1 = new int[] { 10, 20, 30, 40 };
var    intArr2 = new    [] { 10, 20, 30, 40 }; //第二个int可以省略也可以不省略
var    intArr2 = new int[] { 10, 20, 30, 40 };

int[,] intArr3 = new int[,] { { 10, 1 }, { 2, 10 }, { 11, 9 } };
var    intArr4 = new    [,] { { 10, 1 }, { 2, 10 }, { 11, 9 } };
var    intArr4 = new int[,] { { 10, 1 }, { 2, 10 }, { 11, 9 } };

string[] sArr1 = new string[] { "life", "liberty", "pursuit of happiness" };
var      sArr2 = new       [] { "life", "liberty", "pursuit of happiness" };
var      sArr2 = new string[] { "life", "liberty", "pursuit of happiness" };
```

### 综合内容

``` C#
var arr = new int[,] {{0, 1, 2}, {10, 11, 12}};

for( int i=0; i<2; i++ )
    for( int j=0; j<3; j++ )
        Console.WriteLine($"Element [{ i },{ j }] is { arr[i,j] }");
```

运行结果如下：

``` console
Element [0,0] is 0
Element [0,1] is 1
Element [0,2] is 2
Element [1,0] is 10
Element [1,1] is 11
Element [1,2] is 12
```

## 交错数组 Jagged Arrays
交错数组是数组的数组，交错数组的子数组的元素个数可以不同。

例如，如下代码声明了一个二维交错数组：

``` C#
int[][] jagArr = new int[3][]; //声明并创建顶层数组
    ···                        //声明并创建子数组
```

<div  align="center">  
<img src="https://s2.loli.net/2023/01/12/GN9bHxc1KhkVP4B.png" width = "45%" height = "45%" alt="图60 - 交错数组是数组的数组"/>
</div>

### 声明交错数组
交错数组的声明语法要求每一个维度都有独立的方括号，方括号的数量即数组的秩。和矩形数组一样，维度长度不能包含在数组类型声明部分。

``` C#
int[][] SomeArr;  //秩=2
int[][][] OtherArr;  //秩=3
```

### 实例化顶层数组
可以使用数组创建表达式创建顶层数组，但是不能在声明语句中初始化顶层数组以外的数组：

``` C#
int[][] jagArr = new int[3][]; //3个子数组

int[][] jagArr = new int[3][4]; //不允许，编译错误
```

### 实例化交错数组
交错数组的初始化不能在一个步骤里完成，每个数组必须独立创建，步骤包括：  
①实例化顶层数组；  
②分别实例化每一个子数组，把新建数组的引用赋给它们所属数组的合适元素。

``` C#
int[][] Arr = new int[3][]; //实例化顶层数组

Arr[0] = new int[] {10, 20, 30}; //实例化子数组
Arr[1] = new int[] {40, 50, 60, 70}; //实例化子数组
Arr[2] = new int[] {80, 90, 100, 110, 120}; //实例化子数组
```

### 交错数组中的子数组
由于交错数组中的子数组本身就是数组，因此子数组也可能是矩形数组。

``` C#
int[][,] Arr; //带有二维数组的交错数组
Arr = new int[3][,]; //实例化带有3个二维数组的交错数组

Arr[0] = new int[,] { { 10,  20  },
                      { 100, 200 } };

Arr[1] = new int[,] { { 30,  40,  50  },
                      { 300, 400, 500 } };

Arr[2] = new int[,] { { 60,  70,  80,  90  },
                      { 600, 700, 800, 900 } };

for (int i = 0; i < Arr.GetLength(0); i++) //GetLength获取Arr维度0的长度
{
    for (int j = 0; j < Arr[i].GetLength(0); j++) //GetLength获取Arr[i]维度0的长度
    {
        for (int k = 0; k < Arr[i].GetLength(1); k++) //GetLength获取Arr[i]维度1的长度
        {
            Console.WriteLine($"[{ i }][{ j },{ k }] = { Arr[i][j,k] }");
        }
        Console.WriteLine("");
    }
    Console.WriteLine("");
}
```

运行结果如下：  

``` console
[0][0,0] = 10
[0][0,1] = 20

[0][1,0] = 100
[0][1,1] = 200


[1][0,0] = 30
[1][0,1] = 40
[1][0,2] = 50

[1][1,0] = 300
[1][1,1] = 400
[1][1,2] = 500


[2][0,0] = 60
[2][0,1] = 70
[2][0,2] = 80
[2][0,3] = 90

[2][1,0] = 600
[2][1,1] = 700
[2][1,2] = 800
[2][1,3] = 900


```

## 比较矩形数组和交错数组
矩形数组和交错数组的结构区别很大，一个3×3的矩形数组，和一个由3个长度为3的一维数组组成的交错数组，都保存了9个数据，但矩形数组只有单个数组对象，而交错数组有4个数组对象。

在 CIL 中，一维数组有特定的性能优化指令。因此有时一维数组的交错数组比矩形数组更加高效。另一方面，矩形数组的编程复杂度低，因为是一个单元而不是数组的数组。

## foreach 语句
**foreach 语句**允许我们连续访问数组中的每一个元素。也可以和其他集合类型一起使用，见第19章。

foreach 语句语法如下：  

``` C#
foreach( Type Identifier in ArrayName ) //显式类型迭代变量声明
    Statement

foreach( var Identifier in ArrayName ) //隐式类型迭代变量声明
    Statement
```

①**迭代变量 iteration variable**是临时的，并且和数组中的元素类型相同。foreach 语句使用迭代变量来相继表示数组中的每个元素；  
②Type 是数组中元素的类型。可以显式提供它的类型，也可以使用 var 让编译器来推断，因为编译器知道数组的类型；  
③Identifier 是迭代变量的名字；  
④ArrayName 是要处理的数组的名字；  
⑤Statement 是为数组每个元素执行一次的语句或语句块。

示例如下：

``` C#
int[] arr1 = { 10, 11, 12, 13 };

foreach( int item in arr1 )
    Console.WriteLine( $"Item Value: { item }");
```

### 迭代变量是只读的
由于迭代变量是只读的，它不能被改变，但是对于值类型数组和引用类型数组的效果不一样。

对于值类型数组，在用迭代变量来表示数组元素时，不能改变它们，如下，尝试改变迭代变量的数据会产生编译时错误：  

``` C#
int[] arr1 = { 10, 11, 12, 13 };

foreach( int item in arr1 )
    item++; //编译错误，不得改变变量值
```

对于引用类型数组，虽然不能改变迭代变量，但是迭代变量只是数据的引用，所以可以改变数据：

``` C#
class MyClass {
    public int MyField = 0;
}

class Program {
    static void Main() {
        MyClass[] mcArray = new MyClass[4]; //创建数组
        for (int i = 0; i < 4; i++)
        {
            mcArray[i] = new MyClass(); //创建类对象
            mcArray[i].MyField = i; //设置字段
        }
        foreach (MyClass item in mcArray)
            item.MyField += 10; //改变数据

        foreach (MyClass item in mcArray)
            Console.WriteLine($"{ item.MyField }"); //读取改变的数据
    }
}
```

运行结果如下：

``` console
10
11
12
13
```

### foreach 语句和多维数组

矩形数组的示例：

``` C#
class Program
{
    static void Main()
    {
        int total = 0;
        int[,] arr1 = { {10, 11}, {12, 13} };

        foreach( var element in arr1 )
        {
            total += element;
            Console.WriteLine($"Element: { element }, Current Total: { total }");
        }
    }   
}
```

运行结果如下：

``` console
Element: 10, Current Total: 10
Element: 11, Current Total: 21
Element: 12, Current Total: 33
Element: 13, Current Total: 46
```

交错数组的示例，由于交错数组是数组的数组，所以需要为每个维度都使用独立的 foreach 语句，foreach 语句必须嵌套以确保每一个嵌套数组都被正确处理：

``` C#
class Program
{
    static void Main( )
    {
        int total = 0;
        int[][] arr1 = new int[2][];
        arr1[0] = new int[] { 10, 11 };
        arr1[1] = new int[] { 12, 13, 14 };

        foreach (int[] array in arr1) //处理顶层数组
        {
            Console.WriteLine("Starting new array");
            foreach (int item in array) //处理第二层数组
            {
                total += item;
                Console.WriteLine($" Item: { item }, Current Total: { total }");
            }
        }
    }
}
```

运行结果如下：

``` console
Starting new array
 Item: 10, Current Total: 10
 Item: 11, Current Total: 21
Starting new array
 Item: 12, Current Total: 33
 Item: 13, Current Total: 46
 Item: 14, Current Total: 60
```

## 数组协变 Array Covariance
在某些情况下，即使某个对象不是数组的基类型，也可以把它赋值给数组元素，即**数组协变**。在下列情况下可以使用数组协变：  
①数组是引用类型数组；  
②在赋值的对象类型和数组的基类型之间有隐式或显式转换。

由于在派生类和基类之间总是有隐式转换，因此总是可以将一个派生类的对象赋值给为基类声明的数组：

``` C#
class A { ... }
class B : A { ... }

class Program {
    static void Main() {
        //两个A[]类型的数组
        A[] AArray1 = new A[3]; 
        A[] AArray2 = new A[3]; 

        //普通：将A类型的对象赋值给A类型的数组
        AArray1[0] = new A(); AArray1[1] = new A(); AArray1[2] = new A();

        //协变：将B类型的对象赋值给A类型的数组
        AArray2[0] = new B(); AArray2[1] = new B(); AArray2[2] = new B();
    }
}
```

> 值类型数组没有协变。

## 数组继承的有用成员
C# 数组派生自 System.Array 类，继承了很多有用的属性和方法：

| 成员 | 类型 | 生存期 | 意义 |
| :---- | :---- | :---- | :---- |
| Rank | 属性 | 实例 | 获取数组的维度数 |
| Length | 属性 | 实例 | 获取数组中所有维度的元素总数 |
| GetLength | 方法 | 实例 | 返回数组的指定维度的长度 |
| Clear | 方法 | 静态 | 将某一范围内的元素设置为0或null |
| Sort | 方法 | 静态 | 在一维数组中对元素进行排序 |
| BinarySearch | 方法 | 静态 | 使用二进制搜索，搜索一维数组中的值 |
| Clone | 方法 | 实例 | 进行数组的浅复制 —— 对于值类型数组和引用类型数组，都只复制元素 |
| IndexOf | 方法 | 静态 | 返回一维数组中遇到的第一个值 |
| Reverse | 方法 | 静态 | 反转一维数组中某个范围内的元素 |
| GetUpperBound | 方法 | 实例 | 获取指定维度的上限 |

部分示例如下：

``` C#
public static void PrintArray(int[] a)
{
    foreach (var x in a)
        Console.Write($"{ x } ");
    
    Console.WriteLine("");
}

static void Main()
{
    int[] arr = new int[] { 15, 20, 5, 25, 10 };
    PrintArray(arr);

    Array.Sort(arr);
    PrintArray(arr);

    Array.Reverse(arr);
    PrintArray(arr);

    Console.WriteLine();
    Console.WriteLine($"Rank = { arr.Rank }, Length = { arr.Length }");
    Console.WriteLine($"GetLength(0) = { arr.GetLength(0) }");
    Console.WriteLine($"GetType() = { arr.GetType() }");
}
```

运行结果如下：

``` console
15 20 5 25 10 
5 10 15 20 25
25 20 15 10 5

Rank = 1, Length = 5
GetLength(0) = 5
GetType() = System.Int32[]
```

### Clone 方法
Clone 方法为数组进行浅复制，即只创建了数组本身的克隆：  
①克隆值类型数组会产生两个独立的数组；  
②克隆引用类型数组会产生指向相同对象的两个数组；
③Clone 方法返回 object 类型的引用，它必须被强制转换为数组类型。

克隆值类型数组的示例如下：

``` C#
static void Main()
{
    int[] intArr1 = { 1, 2, 3 };
    int[] intArr2 = (int[]) intArr1.Clone(); //因为返回object，所以要转换为数组

    intArr2[0] = 100; intArr2[1] = 200; intArr2[2] = 300; //intArr1为{1,2,3}，intArr2为{100,200,300}
}
```

克隆引用类型的示例如下：

``` C#
class A
{
    public int Value = 5;
}

class Program
{
    static void Main()
    {
        A[] AArray1 = new A[3] { new A(), new A(), new A() };
        A[] AArray2 = (A[]) AArray1.Clone();

        AArray2[0].Value = 100;
        AArray2[1].Value = 200;
        AArray2[2].Value = 300;
        //AArray1和AArray2都引用{100,200,300}
    }
}
```

## 数组与 ref 返回和 ref 局部变量
第6章介绍了 ref 返回和 ref 局部变量，利用 ref 返回功能，可以把一个引用作为返回值传到方法体之外，而利用 ref 局部变量，可以在调用域内使用这个引用

``` C#
class Program
{
    public static ref int PointerToHighestPositive(int[] numbers) //接受一个数组为参数，并且返回对该数组元素的引用
    {
        int highest = 0;
        int indexOfHighest = 0;

        for (int i = 0; i < numbers.Length; i++) 
        {
            {
                if (numbers[i] > highest)
                {
                    indexOfHighest = i;
                    highest = numbers[indexOfHighest];
                }
            }
        }

        return ref numbers[indexOfHighest];
    }

    static void Main() 
    {
        int[] scores = { 5, 80 };
        Console.WriteLine($"Before: {scores[0]}, {scores[1]}");
        ref int locationOfHigher = ref PointerToHighestPositive(scores);

        locationOfHigher = 0;
        Console.WriteLine($"After : {scores[0]}, {scores[1]}");
    }
}
```

运行结果如下：

``` console
Before: 5, 80
After : 5, 0
```


# 第十四章 委托
## 什么是委托
**委托 delegate** 是持有一个或多个方法的对象。示例如下：

``` C#
delegate void MyDel(int value); //声明委托类型

class Program
{
    void PrintLow( int value )
    {
        Console.WriteLine($"{ value } - Low Value");
    }

    void PrintHigh( int value )
    {
        Console.WriteLine($"{ value } - High Value");
    }

    static void Main( )
    {
        Program program = new Program();

        MyDel del; //声明委托变量

        //创建随机整数生成器对象，并得到0到99之间的一个随机数
        Random rand = new Random();
        int randomValue = rand.Next( 99 );

        //创建一个包含PrintLow或PrintHigh的委托对象并将其复制给del变量
        del = randomValue < 50
                ? new MyDel( program.PrintLow )
                : new MyDel( program.PrintHigh );

        del( randomValue ); //执行委托
    }
}
```

## 委托概述
委托和类一样是一种用户定义类型。类表示是数据和方法的集合，委托则持有一个或多个方法，以及一系列预定义操作。可以通过以下步骤来使用委托：  
①声明一个委托类型，委托类型没有实现主体（块）；  
②使用该委托类型声明一个委托变量；  
③创建一个委托类型的对象，并赋值给委托变量。新的委托对象包含指向某个方法的引用，这个方法的签名和返回类型必须和第一步定义的委托类型一致；  
④可以选择为委托对象添加其他方法。这些方法的签名和返回类型要与第一步定义的委托类型相同；  
⑤调用委托时，其包含的每一个方法都会被执行。

可以把 delegate 看作一个包含有序方法的列表，这些方法拥有相同的签名和返回类型：  
①方法的列表被称为**调用列表 invocation list** ；  
②委托持有的方法可以来自任何类和结构，只有能与委托的返回类型和签名匹配；  
③调用列表的方法可以是实例方法也可以是静态方法；  
④调用委托时，会执行其调用列表中的所有方法。

## 声明委托类型
声明语法：`delegate void MyDel( int x );` ，委托类型的声明看上去和方法的声明类似，有返回类型和签名。返回类型和签名指定了委托接受的方法的形式，比如该 MyDel 委托，只接受无返回值的并且有单个 int 参数的方法。

委托类型声明没有方法主体。

<div  align="center">  
<img src="https://s2.loli.net/2023/01/16/pTVtcDSKRi2f38M.png" width = "70%" height = "70%" alt="图61 - 委托类型和对象"/>
</div>

## 创建委托对象
委托是引用类型，在类型声明后，要声明变量并创建类型的对象。

**委托类型变量的声明**语法：`MyDel delVar;`

有两种**创建委托对象**的方法，第一种是使用带 new 运算符的对象创建表达式，包括委托类型名，和圆括号内的作为调用列表的第一个成员的方法的名称，该方法可以是实例方法或静态方法，如下：

``` C#
delVar = new MyDel( myInstObj.MyM1 ); //创建委托并保持引用，实例方法
dVar = new MyDel( SClass.OtherM2 ); //创建委托并保持引用，静态方法
```

第二种创建委托对象的方式为快捷语法，仅由方法说明符构成。这种快捷语法可以工作是因为方法名称和相应的委托类型之间存在隐式转换，如下：

``` C#
delVar = myInstObj.MyM1; //创建委托并保持引用，实例方法
dVar = SClass.OtherM2; //创建委托并保持引用，静态方法
```

将声明委托类型、声明委托变量、创建委托对象合并的示例如下：

``` C#
delegate void MyDel(int x); //声明委托类型
MyDel delVar, dVar; //创建两个委托变量

delVar = new MyDel( myInstObj.MyM1 ); //创建委托并保存引用
dVar = new MyDel( SClass.OtherM2 ); //创建委托并保存引用
```

<div  align="center">  
<img src="https://s2.loli.net/2023/01/29/ZE3i2n5mRuGjQcr.png" width = "60%" height = "60%" alt="图62 - 初始化委托"/>
</div>

除了为委托分配内存，创建委托对象还会把第一个方法放入委托的调用列表。

## 给委托赋值
由于委托是引用类型，可以通过给它赋值来改变包含在委托变量中的引用。旧委托对象会被垃圾回收器回收。

委托是恒定的，委托对象被创建后不能被改变，但是可以改变变量的引用。

## 组合委托 Combining Delegates
委托可以使用额外的运算符来组合，这个运算会创建一个新的委托，其调用列表连接了作为操作数的两个委托的调用列表副本，如下：

``` C#
MyDel delA = myInstObj.MyM1;
MyDel delB = SClass.OtherM2;

MyDel delC = delA + delB; //组合调用列表
```

<div  align="center">  
<img src="https://s2.loli.net/2023/01/29/G5M46l2Be31rTP9.png" width = "65%" height = "65%" alt="图63 - 组合委托"/>
</div>

## 为委托添加方法
使用 **+=** 运算符，可以为委托“添加”方法，方法加在了调用列表的底部。使用 += 运算符，实际上是创建了一个新的委托，然后将这个委托赋值给了原名称，如下：

``` C#
MyDel delVar = inst.MyM1; //创建并初始化
delVar += SCl.m3; //增加方法
delVar += X.Act; //增加方法
```

<div  align="center">  
<img src="https://s2.loli.net/2023/01/29/Ve93Cgcd5xFBuRm.png" width = "50%" height = "50%" alt="图64 - 由于委托是不可变的，所以为委托的调用列表添加3个方法后的结果其实是变量指向的一个全新的委托"/>
</div>

## 从委托移除方法
使用 **-=** 运算符，可以为委托“移除”方法。与为委托添加方法一样，其实是创建了一个新的委托，如下：

``` C#
delVar -= SCl.m3; //从委托移除方法
```

<div  align="center">  
<img src="https://s2.loli.net/2023/01/29/4Tadl6vA8C5yZzx.png" width = "50%" height = "50%" alt="图65 - 从委托移除方法"/>
</div>


其他注意事项：  
①如果在调用列表中的有多个同名方法，-= 运算符从列表底部开始搜索，并且移除第一个与方法匹配的实例；  
②试图删除委托中不存在的方法将无效；  
③试图调用空委托会抛出异常。可以通过将委托和 null 进行比较来判断委托的调用列表是否为空。如果调用列表为空，则委托是 null 。

## 调用委托 Invoking a Delegate
①可以通过两种方式调用委托，一种是像调用方法一样调用委托，另一种是使用委托的 Invoke 方法；  
②可以将参数放在调用的圆括号之内。用于调用委托的参数作用于调用列表中的每个方法，除非其中一个参数是输出参数，见后面；  
③如果一个方法在调用列表中多次出现，则在调用委托时，每次在列表中遇到该方法时都会调用它；  
④调用时委托不能为空 null ，否则会引发异常。可以使用 if 语句或者使用**空条件运算符**和 Invoke 方法去检查。

``` C#
MyDel delVar = inst.MyM1;
delVar += SCl.m3;
delVar += X.Act;
    ...

if (delVar != null)
    { delVar(55); } //调用委托
delVar?.Invoke(65); //使用Invoke和空条件运算符
    ...
```

<div  align="center">  
<img src="https://s2.loli.net/2023/01/29/4RD9hkBjc7Oysnl.png" width = "60%" height = "60%" alt="图66 - 在调用委托时，它使用相同的参数来执行调用列表中的每一个方法"/>
</div>

## 委托的示例

``` C#
//定义一个没有返回值和参数的委托类型
delegate void PrintFunction();

class Test
{
    public void Print1()
    { Console.WriteLine("Print1 -- instance"); }

    public static void Print2()
    { Console.WriteLine("Print2 -- static"); }
}

class Program
{
    static void Main()
    {
        Test t = new Test(); //创建类示例
        PrintFunction pf; //创建一个空委托

        pf = t.Print1; //实例化并初始化该委托

        pf += Test.Print2;
        pf += t.Print1;
        pf += Test.Print2;

        if( null != pf) //确认委托有方法
            pf(); //调用委托
        else
            Console.WriteLine("Delegate is empty");
    }
}
```

运行结果如下：

``` console
Print1 -- instance
Print2 -- static
Print1 -- instance
Print2 -- static
```

## 调用带返回值的委托
如果委托有返回值并且在调用列表中有一个以上的方法，则：  
①调用列表中最后一个方法返回的值就是委托调用返回的值；  
②调用列表中其他方法的返回值就会被忽略。

``` C#
delegate int MyDel( ); //声明有返回值的方法

class MyClass {
    int IntValue = 5;
    public int Add2() { IntValue += 2; return IntValue;}
    public int Add3() { IntValue += 3; return IntValue;}
}

class Program {
    static void Main( ){
        MyClass mc = new MyClass(); 
        MyDel mDel = mc.Add2; //创建并初始化委托
        mDel += mc.Add3; //增加方法
        mDel += mc.Add2; //增加方法
        Console.WriteLine($"Value: { mDel() }");
    }
}
```

运行结果如下：

``` console
Value: 12
```

## 调用带引用参数的委托
如果委托有引用参数，参数值会根据调用列表中的一个或多个方法而改变。在调用委托列表中的下一个方法时，参数的新值会传给下一个方法。

``` C#
delegate void MyDel( ref int X );

class MyClass {
    public void Add2(ref int x) { x += 2; }
    public void Add3(ref int x) { x += 3; }
    static void Main() {
        MyClass mc = new MyClass();

        MyDel mDel = mc.Add2;
        mDel += mc.Add3;
        mDel += mc.Add2;

        int x = 5;
        mDel(ref x);

        Console.WriteLine($"Value: { x }");
    }   
}
```

运行结果如下：

``` console
Value: 12
```

如果没有 ref 关键字，则每个方法的参数都为5，所以上述案例的输出也为5。

## 匿名方法
**匿名方法 anonymous method**是在实例化委托时内联(inline)声明的方法：

``` C#
//具名方法
class Program
{
    public static int Add20(int x)
    {
        return x + 20;
    }

    delegate int OtherDel(int InParam);

    static void Main()
    {
        OtherDel del = Add20;

        Console.WriteLine("{0}", del(5));
        Console.WriteLine("{0}", del(6));
    }
}

//匿名方法
class Program
{
    delegate int OtherDel(int InParam);

    static void Main()
    {
        OtherDel del = delegate(int x)
                        {
                            return x + 20;
                        };
        
        Console.WriteLine("{0}", del(5));
        Console.WriteLine("{0}", del(6));
    }
}
```

上述两组代码输入都是：

``` console
25
26
```

### 使用匿名方法
我们可以在以下地方使用匿名方法：  
①声明委托变量时作为初始化表达式；  
②组合委托时在赋值语句的右边；  
③为委托增加事件时，在赋值语句的右边。见第15章。

### 匿名方法的语法
匿名方法表达式的语法包含如下组成部分：  
① delegate 类型关键字；  
②参数列表，若语句块没有使用任何参数可以省略；  
③语句块，包含匿名方法的代码。

格式：`delegate ( Parameters ) { ImplementationCode }`

***1、返回类型***  
匿名方法不会显式声明返回值，但是必须返回一个与委托的返回值类型相同的值。如果委托是 void 类型的返回值，则匿名方法不能返回值。

``` C#
delegate int OtherDel(int InParam); //委托类型的返回类型

static void Main()
{
    OtherDel del = delegate(int x)
                {
                    return x + 20 ; //返回一个整数型
                };
    ...
}
```

***2、参数***  
除了数组参数，匿名方法的参数列表必须在这几个方面与委托匹配：参数数量；参数的类型以及位置；修饰符。

可以使用空括号或者省略括号，但是需要满足2个条件：①委托的参数列表不包含任何 out 参数；②匿名方法不使用任何参数。如下：

``` C#
delegate void SomeDel ( int X ); //声明委托类型

SomeDel SDel = delegate //省略参数列表，因为不使用参数
            {
                PrintMessage();
                Cleanup();
            };
```

***3、params 参数***  
如果委托声明的参数列表包含了 params 参数，那么匿名方法的参数列表将忽略 params 关键字。如下：

``` C#
delegate void SomeDel( int X, params int[] Y); //委托类型声明中使用params关键字

SomeDel mDel = delegate (int X, int[] Y) //在匹配的匿名方法中省略关键字
            {
                ...
            };
```

### 变量和参数的作用域
参数以及声明在匿名方法内部的局部变量的作用域限制在实现代码的主体中。

如下，匿名方法定义的参数 y 和局部变量 z 。在匿名方法主体结束之后，y 和 z 就不在作用域之内。

``` C#
delegate void MyDel( int x);
...

MyDel mDel = delegate (int y)
            {
                int z = 10;
                Console.WriteLine("{0},{1}", y, z);
            };

Console.WriteLine("{0},{1}", y, z); //编译错误
```

***1、外部变量***  
匿名方法可以访问它们外围作用域的局部变量和环境。外围作用域的变量叫做**外部变量 outer variable**。用在匿名方法实现代码中的外部变量称为被方法**捕获**。

``` C#
int x = 5; //变量x定义在匿名方法作用域的前面
    ...

MyDel mDel = delegate
            {
                Console.WriteLine("{0}", x); //变量x可以在匿名方法作用域内使用
            };
```

***2、捕获变量的生命周期的扩展***  
如下，局部变量x在块中声明并初始化，然后委托 mDel 用匿名方法初始化，该匿名方法捕获了外部变量x。

``` C#
delegate void MyDel( );

static void Main()
{
    MyDel mDel;

    {
        int x = 5; //变量x定义在外部块里，在匿名方法之外

        mDel = delegate
                {
                    Console.WriteLine("Value of x: {0}", x); //变量x被匿名方法捕获
                };
    }

    // Console.WriteLine("Value of x: {0}", x); 变量x离开了作用域并且会导致编译错误

    if (null != mDel)
        mDel(); //而这里在匿名方法内部使用了x
}
```

运行结果如下：

``` console
Value of x: 5
```

## Lambda 表达式
**Lambda 表达式**简化了匿名方法的语法。在匿名方法中，delegate 有点多余，我们可以通过①删除 delegate 关键字，和②在参数列表和匿名方法主体之间放置 **Lambda 运算符 =>** 来把匿名方法转换为 Lambda 表达式。Lambda 运算符读做“goes to”。

``` C#
MyDel del = delegate(int x)    { return x + 1; } ; //匿名方法
MyDel le1 =         (int x) => { return x + 1; } ; //Lambda表达式
```

①因为编译器还可以从委托的声明中知道委托参数的类型，因此 Lambda 表达式允许省略类型参数；  
②如果只有一个隐式类型参数，可以省略括号；  
③Lambda 表达式允许表达式的主体是语句块或表达式。如果语句块包含了一个返回语句，可以将语句块替换为 return 关键字后的表达式。

``` C#
MyDel le1 =         (int x) => { return x + 1; } ; //Lambda表达式
MyDel le2 =             (x) => { return x + 1; } ; //Lambda表达式
MyDel le3 =              x  => { return x + 1; } ; //Lambda表达式
MyDel le4 =              x  =>          x + 1    ; //Lambda表达式
```

Lambda 表达式的参数列表的要点如下：  
①Lambda 表达式参数列表中的参数必须在参数数量、类型和位置上与委托相匹配；  
②表达式的参数列表中的参数不一定需要包含类型（隐式类型），除非委托有 ref 和 out 参数，则必须注明类型（显式类型）；  
③如果只有一个参数，并且是隐式类型，则括号可以省略；  
④如果没有参数必须使用一组空的圆括号。


# 第十五章 事件
## 发布者和订阅者
很多程序需要当某一特定的程序事件发生时，程序的其他部分可以得到该事件已经发生的通知。**发布者/订阅者模式 publisher / subscriber pattern** 可以满足这个需求。在这种模式下，**发布者类**定义了一系列事件成员。其他类可以“注册”，以便这些事件发生时收到通知。这些**订阅者类**通过向发布者提供一个方法来“注册”以获取通知。当事件发生时，发布者“触发事件”，然后执行订阅者提交的所有事件。由订阅者提供的方法称为**回调方法 callback methods**，因为发布者通过执行订阅者的方法“calls the subscribers back”。也可以称为**事件处理程序 event handlers**。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/03/GvWbIk84gY7MpsT.png" width = "80%" height = "80%" alt="图67 - 发布者和订阅者"/>
</div>

①**发布者 publisher** ：发布某个事件的类或结构；  
②**订阅者 subscriber** ：注册并在事件发生时得到通知的类或结构；  
③**事件处理程序 event handler** ：订阅者注册到事件的方法，在发布者触发事件时执行。事件处理程序方法可以定义在事件所在的类或结构里，也可以定义在不同的类或结构里；  
④**触发事件 Raising an event** ：当调用 invoke 或触发 fire 事件，所有注册到它的方法都会被依次调用。

**事件**和委托类似，实际上事件包含了一个私有委托，如下图：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/03/hGtlFfVYb8DjeB5.png" width = "50%" height = "50%" alt="图68 - 事件有被封装的委托"/>
</div>

事件的私有委托的重要事项如下：  
①事件提供了对它私有控制的委托的结构化方法，即无法直接访问委托；  
②事件中可用的操作比委托少，对于事件只可以添加、删除或调用事件处理程序；  
③事件被触发时，它调用委托来依次调用调用列表中的方法。

下图演示了一个叫做 Incrementer 的类：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/03/qHBh6jzQoIwYAnR.png" width = "70%" height = "70%" alt="图69 - 具有一个事件的类的结构和术语"/>
</div>

## 源代码组件概览
需要在事件中使用的代码有5部分：  
①**委托类型声明**：事件和事件处理程序必须有共同的签名和返回类型；  
②**事件处理程序声明**：订阅者类中会在事件触发时执行的方法的声明，可以是匿名方法或者是 Lambda 表达式；
③**事件声明**：发布者类必须声明一个订阅者类可以注册的事件成员。当类声明的事件为 public 时，称为发布了事件；  
④**事件注册**：订阅者必须注册事件才能在事件被触发时得到通知，这是将事件处理程序与事件相连的代码；  
⑤**触发事件的代码**：发布者类中触发事件并导致调用注册的所有事件处理程序的代码。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/03/IsnQ2Wdi8bY4Tt1.png" width = "50%" height = "50%" alt="图70 - 使用事件时的5个源代码组件"/>
</div>

## 声明事件
发布者类必须提供**事件对象**。事件声明在一个类中，它需要委托类型的名称，任何附加在事件（如注册）的处理程序都必须与委托类型的签名和返回类型匹配。事件需声明为 public ，这样其他的类和结构可以在它上面注册事件处理程序。不能使用对象创建表达式，即 new，来创建事件对象。

``` C#
class Incrementer
{
    public event EventHandler CountedADozen; //EventHandler为委托类型，CountedADozen为事件名

    public event EventHandler MyEvent1, MyEvent2, OtherEvent; //可以通过逗号分隔来声明一个以上的事件

    public static event EventHandler CountedADozen; //可以使用 static 关键字让事件变成静态的

```

**事件是成员**，和方法、属性一样，是类或结构的成员：  
①由于事件是成员，不能在一段可执行代码中声明事件，它必须声明在类或结构中；  
②事件成员被隐式自动初始化为 null。

BCL 声明了一个叫作 EventHandler 的委托，专门用于系统事件，见后面。

## 订阅事件
订阅者向事件添加事件处理程序，其必须具有与事件委托相同的返回类型和签名。使用 += 运算符为事件添加事件处理程序，可以是实例方法、静态方法、匿名方法和 Lambda 表达式。

``` C#
//incrementer为类，CountedADozen为类的事件成员
incrementer.CountedADozen += IncrementDozensCount; //实例方法
incrementer.CountedADozen += ClassB.CounterHandlerB; //静态方法

mc.CountedADozen += new EventHandler(cc.CounterHandlerC); //委托形式的实例方法

incrementer.CountedADozen += () => DozensCount++; //Lambda表达式

incrementer.CountedADozen += delegate { DozensCount++; }; //匿名方法
```

## 触发事件
事件成员本身只保存了需要被调用的事件处理程序，需要在合适的时候触发事件，代码如下：

``` C#
if (CountedADozen != null) //确定有方法可以执行
    CountedADozen (source, args); //触发事件，包括事件名称和参数列表，参数列表必须与事件的委托类型相匹配
```

把事件声明和触发事件的代码合并，如下：

``` C#
class Incrementer
{
    public event EventHandler CountedADozen; //声明事件

    void DoCount(object source, EventArgs args)
    {
        for( int i=1; i < 100; i++ )
            if( i % 12 == 0 )
                if (CountedADozen != null)
                    CountedADozen(source, args);
    }
}
```

如下展示了整个程序，包含发布者类 Incrementer 和订阅者类 Dozens：  
①在构造函数内，Dozens 类订阅事件，将 IncrementDozensCount 作为事件处理程序；  
②在 Incrementer 类的 DoCount 方法中，每增加12个计数就触发 CountedADozen 事件。

``` C#
delegate void Handler(); //声明委托

//发布者
class Incrementer
{
    public event Handler CountedADozen; //创建事件并发布

    public void DoCount()
    {
        for ( int i = 1; i < 100; i++ )
            if ( i % 12 == 0 && CountedADozen != null )
                CountedADozen(); //每增加12个计数触发事件一次
    }
}

//订阅者
class Dozens
{
    public int DozensCount { get; private set; }

    public Dozens( Incrementer incrementer )
    {
        DozensCount = 0;
        incrementer.CountedADozen += IncrementDozensCount; //订阅事件
    }

    void IncrementDozensCount() //声明事件处理程序
    {
        DozensCount++;
    }
}

class Program
{
    static void Main()
    {
        Incrementer incrementer = new Incrementer();
        Dozens dozensCounter = new Dozens( incrementer );

        incrementer.DoCount();
        Console.WriteLine("Number of dozens = {0}", dozensCounter.DozensCount );
    }
}
```

运行结果如下：

``` console
Number of dozens = 8
```

## 标准事件的用法
GUI 编程是事件驱动的，即程序运行时可以被事件打断，比如按钮点击或系统定时器。程序事件的异步 asynchronous 处理是使用 C# 事件的绝佳场景。.NET 框架提供一个标准模式，其基础就是 System 命名空间中声明的 **EventHandler 委托类型**。

EventHandler 委托类型的声明代码：`public delegate void EventHandler(object sender, EventArgs e);`  
①第一个参数用来保存触发事件的对象的引用，由于是 object 类型，可以匹配任何类型的实例；  
②第二个参数用来保存状态信息，指明什么类型适用于该应用程序；  
③返回类型为 void 。

EventHandler 委托类型的第二个参数是 **EventArgs 类**的对象，它声明在 System 命名空间中：  
① EventArgs 不能传递任何数据，它用于不需要传递数据的事件处理程序；  
②如果要传递数据，必须声明一个派生自 EventArgs 的类，并使用合适的字段来保存需要传递的数据。

EventArgs 类是使用 EventHandler 委托模式的重要部分。不管参数的实际类型是什么，object 和 EventArgs 类型的参数总是基类。这样 EventHandler 就能提供一个对所有事件和事件处理器都通用的签名，让所有事件都正好有两个参数。

以下代码修改了之前的 Incrementer，让它使用 EventHandler 委托，触发事件的代码在调用事件时必须使用适当的参数类型的对象：

``` C#
public delegate void EventHandler(object sender, EventArgs e);

//发布者
class Incrementer
{
    public event EventHandler CountedADozen; //使用系统定义的EventHandler委托

    public void DoCount()
    {
        for ( int i = 1; i < 100; i++ )
            if ( i % 12 == 0 && CountedADozen != null )
                CountedADozen(this, null); //触发事件时使用EventHandler的参数
    }
}

//订阅者
class Dozens
{
    public int DozensCount { get; private set; }

    public Dozens( Incrementer incrementer )
    {
        DozensCount = 0;
        incrementer.CountedADozen += IncrementDozensCount;
    }

    void IncrementDozensCount(object source, EventArgs e) //签名与委托的签名匹配
    {
        DozensCount++;
    }
}

class Program
{
    static void Main()
    {
        Incrementer incrementer = new Incrementer();
        Dozens dozensCounter = new Dozens( incrementer );

        incrementer.DoCount();
        Console.WriteLine("Number of dozens = {0}", dozensCounter.DozensCount );
    }
}
```

### 通过扩展 EventArgs 来传递数据
为了向自己的事件处理程序的第二个参数传入数据，需要声明一个派生自 EventArgs 的自定义类，用于保存我们需要传入的数据。

``` C#
public class IncrementerEventArgs : EventArgs
{
    public int IterationCount { get; set; } //存储一个整数
}
```

有了一个自定义类，可以向事件处理程序的第二个参数传递数据，但需要一个使用新自定义类的委托类型，可以使用**泛型版本的委托 generic version of delegate**：EventHandler<>。详见第18章。要使用泛型委托，要将自定义类的名称放在尖括号内：`public event EventHandler<IncrementerEventArgs> CountedADozen;`

以下代码更新了 Incrementer，使用了自定义类和泛型委托：

``` C#
public delegate void EventHandler(object sender, EventArgs e);

public class IncrementerEventArgs : EventArgs //自定义类派生自EventArgs
{
    public int IterationCount { get; set; } //存储一个整数
}

class Incrementer
{
    public event EventHandler<IncrementerEventArgs> CountedADozen;

    public void DoCount()
    {
        IncrementerEventArgs args = new IncrementerEventArgs(); //创建自定义类实例

        for ( int i = 1; i < 100; i++ )
            if ( i % 12 == 0 && CountedADozen != null )
            {
                args.IterationCount = i;
                CountedADozen( this, args ); //在触发事件时传递参数
            }
    }
}

class Dozens
{
    public int DozensCount { get; private set; }

    public Dozens( Incrementer incrementer )
    {
        DozensCount = 0;
        incrementer.CountedADozen += IncrementDozensCount;
    }

    void IncrementDozensCount( object source, IncrementerEventArgs e )
    {
        Console.WriteLine($"Incremented at iteration: { e.IterationCount } in { source.ToString() }");
        DozensCount++;
    }
}

class Program
{
    static void Main()
    {
        Incrementer incrementer = new Incrementer();
        Dozens dozensCounter = new Dozens( incrementer );

        incrementer.DoCount();
        Console.WriteLine($"Number of dozens = { dozensCounter.DozensCount }");
    }
}
```

运行结果如下，Counter.Incrementer 的 Counter 是命名空间的名称：

``` console
Incremented at iteration: 12 in Counter.Incrementer
Incremented at iteration: 24 in Counter.Incrementer
Incremented at iteration: 36 in Counter.Incrementer
Incremented at iteration: 48 in Counter.Incrementer
Incremented at iteration: 60 in Counter.Incrementer
Incremented at iteration: 72 in Counter.Incrementer
Incremented at iteration: 84 in Counter.Incrementer
Incremented at iteration: 96 in Counter.Incrementer
Number of dozens = 8
```

### 移除事件处理程序
可以利用 -= 运算符把事件处理程序从事件移除：`p.SimpleEvent -= s.MethodB;`

实例如下：

``` C#
class Publisher
{
    public event EventHandler SimpleEvent;

    public void RaiseTheEvent() { SimpleEvent( this, null ); }
}

class Subscriber
{
    public void MethodA( object o, EventArgs e ) { Console.WriteLine( "AAA" ); }
    public void MethodB( object o, EventArgs e ) { Console.WriteLine( "BBB" ); }
}

class Program
{
    static void Main( )
    {
        Publisher p = new Publisher();
        Subscriber s = new Subscriber();

        p.SimpleEvent += s.MethodA;
        p.SimpleEvent += s.MethodB;
        p.RaiseTheEvent();

        Console.WriteLine( "\r\nRemove MethodB" );
        p.SimpleEvent -= s.MethodB;
        p.RaiseTheEvent();
    }      
}
```

运行结果如下：

``` console
AAA
BBB

Remove MethodB
AAA
```

## 事件访问器 Event Accessors
事件只允许 += 和 -= 运算符，但是我们可以修改这两个运算符的行为，让事件执行自定义的代码。由于是高级主题，这里只简单介绍。

要改变这两个运算符的操作，必须为事件定义**事件访问器**：  
①有两个访问器：add 和 remove；  
②声明事件的访问器看上去和声明属性差不多；

示例如下，两个访问器都有叫做 value 的隐式值参数，接受实例或静态方法的引用：

``` C#
public event EventHandler CountedADozen
{
    add
    {
        ... //执行+=运算符的代码
    }

    remove
    {
        ... //执行-=运算符的代码
    }
}
```

声明了事件访问器之后，事件不包含任何内嵌委托对象。必须实现自己的机制来存储和移除事件注册的方法。事件访问器表现为 void 方法，不能使用 return 语句返回值。