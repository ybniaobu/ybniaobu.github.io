---
title: 《C#图解教程》读书笔记（二）
date: 2022-12-06 16:34:24
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：XXXXXXXXXXXXX。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第七章 深入理解类
## 类成员

| 数据成员（保存数据） | 函数成员（执行代码） |
| :---- | :---- |
| 字段 Fields <br> 常量 Constants | 方法 Methods&emsp; &emsp;运算符 Operators <br> 属性 Properties &emsp; &emsp;索引 Indexers <br> 构造函数 Constructors &emsp; &emsp;事件 Events <br> 析构函数 Destructors |

## 成员修饰符的顺序
类成员声明语句由下列部分组成：**核心声明**、一组可选的**修饰符 modifiers** 和一组可选的**特性 attributes** 。语法如下，方括号内的成分是可选的：  
`[特性] [修饰符] 核心声明`

①修饰符：若有多个修饰符，可以任意顺序排列。
②特性：若有多个特性，可以任意顺序排列。在第25章介绍特性。

比如以下代码在语义上是等价的（public 和 static 都是修饰符，返回类型是核心声明的一部分）：  
`public static int MaxVal;`  
`static public int MaxVal;`

## 实例类成员 Instance Class Members
类成员可以关联到类的一个实例，也可以关联到整个类。类的每个实例都拥有自己的各自类成员的副本，称为**实例成员**。改变一个实例字段的值，不会影响其他实例成员的值。

``` C#
class D
{
    public int Mem1;
}

class Program
{
    static void Main()
    {
        D d1 = new D();
        D d2 = new D();
        d1.Mem1 = 10; d2.Mem1 = 28;

        Console.WriteLine($"d1 = { d1.Mem1 }, d2 = { d2.Mem1 }");
    }
}
```

运行结果如下：

``` console
d1 = 10, d2 = 28
```

## 静态字段 Static Fields
以上都是实例字段，类还可以拥有**静态字段**。静态字段被类的所有实例**共享**，所有实例都访问同一内存位置。使用 **static 修饰符**将字段声明为静态： 

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/vjSrekiyVHofd6z.png" width = "80%" height = "80%" alt="图25 - 静态和非静态数据成员"/>
</div>

## 从类的外部访问静态成员
**点运算符**由实例名、点和成员名组成。就像实例成员，静态成员也可以使用点运算符从外部访问，因为没有实例，所以使用*类名*来访问静态成员：`D.Mem2 = 5;`

访问静态成员的另一种方法不需要前缀，而是使用 using static 声明：

``` C#
using static System.Console; // includes, amongst other members, Writeline()
using static System.Math; // includes, amongst other members, Sqrt()
...
WriteLine($"The square root of 16 is { Sqrt(16) }" );
```

等价于：

``` C#
using System;
...
Console.WriteLine($"The square root of 16 is { Math.Sqrt(16) }");
```

第22章详细介绍 using static 声明结构体。

### 静态字段示例：

``` C#
class D
{
    int Mem1;
    static int Mem2;

    public void SetVars(int v1, int v2) //设置值
    {   Mem1 = v1; Mem2 = v2;   }

    public void Display( string str )
    {   Console.WriteLine("{0}: Mem1= {1}, Mem2= {2}", str, Mem1, Mem2);   }
}

class Program {
    static void Main()
    {
        D d1 = new D(), d2 = new D(); //创建2个实例

        d1.SetVars(2, 4); //设置d1的值
        d1.Display("d1");

        d2.SetVars(15, 17); //设置d2的值
        d2.Display("d2");
    
        d1.Display("d1"); //注意，这时Mem2静态成员的值已改变
    }
}
```

运行结果如下：

``` console
d1: Mem1= 2, Mem2= 4
d2: Mem1= 15, Mem2= 17
d1: Mem1= 2, Mem2= 17
```

### 静态成员的生存期
即使类没有实例，也存在静态成员，并且可以访问。

## 静态函数成员 Static Function Members
如同静态字段，静态函数成员独立于任何类实例，没有实例也可以调用静态方法；*静态函数成员不能访问实例成员，但能访问其他静态成员*。

``` C#
class X
{
    static public int A; //静态字段
    static public void PrintValA() //静态方法
    {
        Console.WriteLine("Value of A: {0}", A); //访问静态字段
    }
}
```

## 其他静态类成员类型
可声明为 static 的类成员前面有勾号：

| 数据成员（保存数据） | 函数成员（执行代码） |
| :---- | :---- |
| √ 字段 Fields <br> √ 类型 Types <br> 常量 Constants | √ 方法 Methods <br> √ 运算符 Operators <br> √ 属性 Properties <br> 索引 Indexers <br> √ 构造函数 Constructors <br> √ 事件 Events |

## 成员常量 Member Constants
区分局部常量和成员常量，成员常量声明在类声明中而不是方法内：

``` C#
class MyClass
{
    const int IntVal1 = 100;
    const int IntVal2 = 2 * IntVal1; //用于初始化成员常量的值在编译时必须是可计算的
}
```

> C# 没有全局常量，常量必须声明在类型中，与 C 和 C++ 不同。

## 常量和静态量 Constants Are Like Statics
常量非常像静态值，没有类的实例也可以使用，但常量没有自己的存储位置，而是在编译时被编译器替换。这种方式类似于 C 和 C++ 的 #define 值。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/7YgDBGnX5zWKS9I.png" width = "75%" height = "75%" alt="图26 - 常量字段变现得像静态字段，但是在内存中没有存储位置"/>
</div>

不能将常量声明为 static ：`static const double PI = 3.14; //错误`

## 属性 Properties
**属性**是代表类实例或类中数据项的成员。使用属性如同写入和读取字段，语法相同。  

与字段不同，属性是一个函数成员：  
①它不一定为数据存储分配内存；  
②它执行代码

**属性 Properties** 是一个包含2个相关方法的被命名为**访问器 accessors** 的组合：  
① **set** 访问器为属性赋值；  
② **get** 访问器从属性获取值。

如下图，注意 - 访问器从后面伸出，因为它们不能直接被调用：

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/4AuSJHGaxwBvhP6.png" width = "60%" height = "60%" alt="图27 - int 类型的、名称为 MyValue 的属性示例"/>
</div>

### 属性声明和访问器
**set** 访问器总是：  
①拥有一个单独的、隐式的值参，名称为 value，与属性的类型相同；  
②拥有一个返回类型 void 。

**get** 访问器总是：  
①没有参数；  
②拥有一个与属性类型相同的返回类型。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/jwPlrzJe3Zs1tfk.png" width = "65%" height = "65%" alt="图28 - 属性声明的语法与结构"/>
</div>

set 访问器中的隐式参数 value 和其他值参一样，可以用它发送数据到方法体或访问器块。  

访问器其他要点如下：  
1、get 访问器和所有执行路径*必须包含一个 return 语句*，返回一个属性类型的值。  
2、访问器 set 和 get 可以以任何顺序声明，并且，除了这两个访问器外，属性不允许有其他方法。

### 属性示例
属性本身没有任何存储，在下面的情况下，使用名为 TheRealValue 的字段作为存储：

``` C#
class C1
{
    private int theRealValue; //字段：分配内存

    public int MyValue //属性：未分配内存
    {
        set { theRealValue = value; }
        get { return theRealValue; }
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/8VH1CPpoYmv5RUd.png" width = "35%" height = "35%" alt="图29 - 属性访问器常常使用字段作为存储"/>
</div>

### 使用属性
写入和读取属性时，访问器会被隐式得调用：  
`MyValue = 5; //赋值：隐式地调用 set 方法`  
`z = MyValue; //表达式：隐式地调用 get 方法`

注意：不能显示地调用访问器，会产生编译错误。

### 属性和关联字段 Properties and Associated Fields
一种常见的方式是在类中将字段声明为 private 以封装该字段，并声明一个 public 属性来控制从类外部对该字段的访问。和属性关联的字段被称为**后备字段 backing field **或**后备存储 backing store**。

以下示例使用公有属性 MyValue 来控制对私有字段 theRealValue 的访问：

``` C#
class C1
{
    private int theRealValue = 10; //后备字段：分配内存

    public int MyValue //属性：不分配内存
    {
        set{ theRealValue = value; } //设置字段值
        get{ return theRealValue; } //获取字段值
    }
}

class Program
{
    static void Main()
    {
        C1 c = new C1();
        Console.WriteLine("MyValue: {0}", c.MyValue); //把属性看作字段，从中读取它的值

        c.MyValue = 20; //使用赋值语句设置属性的值
        Console.WriteLine("MyValue: {0}", c.MyValue);
    }
}
```

### 执行其他计算
访问器 get 和 set 能执行任何计算，下面若输入值大于100，就将 theRealValue 设置为100：

``` C#
int theRealValue = 10; //字段
int MyValue //属性
{
    set { theRealValue = value > 100 ? 100 : value; } //条件运算符，见第9章
    get { return theRealValue; }
}
```

C# 7.0 为属性的 getter/setter 引入了使用**表达函数体**的语法，见第14章。这种语法只有在访问函数体由一个表达式组成的时候才能使用：

``` C#
int MyValue
{
    set => value > 100 ? 100 : value;
    get => theRealValue;
}
```

### 只读和只写属性 Read-Only and Write-Only Properties
只有 get 访问器的属性称为**只读属性**；只有 get 访问器的属性称为**只写属性**。

两个访问器中至少有一个必须被定义，否则编译器会产生一条错误信息。

### 属性与公有字段
根据实践，属性比公有字段更好：  
①属性是函数成员不是数据成员，允许处理输入和输出；  
②属性可以只读和只写，而字段不行；  
③编译后的变量和编译后的属性语义不同。

### 计算只读属性示例
在大多示例中，属性都和一个后备字段关联，并且 get 和 set 访问器引用该字段。但是属性不是必须和字段关联：

``` C#
class RightTriangle
{
    public double A = 3;
    public double B = 4;
    public double Hypotenuse //只读属性
    {
        get{ return Math.Sqrt((A*A)+(B*B)); } 
    }
}

class Program
{
    static void Main()
    {
        RightTriangle c = new RightTriangle();
        Console.WriteLine($"Hypotenuse: { c.Hypotenuse }");
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/JfszWaUQgRqPrt5.png" width = "35%" height = "35%" alt="图30 - 只读属性 Hypotenuse"/>
</div>

### 自动实现属性
因为属性经常被关联到后备字段，所以 C# 提供了**自动实现属性**（automatically implemented property 或 auto-implemented property，简称为**自动属性 auto-property**），允许只声明属性而不声明后备字段。编译器会自动创建隐藏的后备字段，并且自动挂接到 get 和 set 访问器上。

自动实现属性要点：  
①不声明后备字段：编译器根据属性的类型分配存储；  
②不能提供访问器的方法体：声明为分号。

``` C#
class C1
{
    public int MyValue //分配内存，没有声明后备字段
    {
        set; get; //访问器的方法体被声明为分号
    }
}

class Program
{
    static void Main()
    {
        C1 c = new C1();
        Console.WriteLine("MyValue: {0}", c.MyValue);

        c.MyValue = 20;
        Console.WriteLine("MyValue: {0}", c.MyValue);
    }
}
```

运行结果如下：

``` console
MyValue: 0
MyValue: 20
```

### 静态属性
属性也可以被声明为 static ，示例如下：

``` C#
using System;
using static ConsoleTestApp.Trivial;
namespace ConsoleTestApp
{
    class Trivial {
        public static int MyValue { get; set; }
        public void PrintValue()
        { Console.WriteLine("Value from inside: {0}", MyValue); } //从类内部访问MyValue
    }

    class Program {
        static void Main() {
            Console.WriteLine("Init Value: {0}", Trivial.MyValue); //从类外部访问MyValue
            Trivial.MyValue = 10;
            Console.WriteLine("New Value : {0}", Trivial.MyValue); //从类外部访问MyValue

            MyValue = 20; //从类外部访问，但因为using static，所以可以省略类名
            Console.WriteLine($"New Value : { MyValue }");
            Trivial tr = new Trivial();
            tr.PrintValue();
        }
    }
}
```

运行结果如下：

``` console
Init Value: 0
New Value : 10
New Value : 20
Value from inside: 20
```

## 实例构造函数 Instance Constructors
**实例构造函数**是一个特殊的方法，它在创建类的每个新实例时执行。构造函数用于初始化类实例的状态；如果要从类的外部创建类的实例，需要将构造函数声明为 public 。

构造函数的名称和类名相同；构造函数不能有返回值。

``` C#
class MyClass
{
    public MyClass() //声明为public，没有返回类型，和类名相同
    {
        ···
    }
    ...
}
```

### 带参数的构造函数
构造函数可以带参数，也可以被重载，和方法类似。

在使用创建对象表达式创建类的新实例时，要使用 new 运算符，后面跟着类的构造函数，new 运算符使用该构造函数创建类的实例：

``` C#
class Class1
{
    int Id;
    string Name;

    public Class1()            { Id=28; Name="Nemo";  } //构造函数0
    public Class1(int val)     { Id=val; Name="Nemo"; } //构造函数1
    public Class1(String name) { Name=name;           } //构造函数2

    public void SoundOff()
    { Console.WriteLine($"Name { Name }, Id { Id }"); }
}

class Program
{
    static void Main()
    {
        Class1 a = new Class1(), //调用构造函数0
               b = new Class1(7), //调用构造函数1
               c = new Class1("Bill"); //调用构造函数2

        a.SoundOff();
        b.SoundOff();
        c.SoundOff();
    }
}
```

运行结果如下：

``` console
Name Nemo, Id 28
Name Nemo, Id 7
Name Bill, Id 0
```

### 默认构造函数
如果在类中没有显示地提供实例构造函数，那么编译器会提供一个隐式的默认构造函数，它没有参数，方法体为空。若为类声明了构造函数，那么编译器将不会为该类定义默认构造函数。

如果声明了带参数的构造函数，那么试图使用不带参数的构造函数创建新的实例时，编译器会产生一条错误消息，因为没有无参数的构造函数。

## 静态构造函数
实例构造函数初始化类的每个新实例，而**静态构造函数**初始化类级别的项，通常，静态构造函数初始化类的静态字段。

静态构造函数的特点：  
①类只能有一个静态构造函数，而且不能带参数；  
②静态构造函数不能有访问修饰符（static 关键字不是访问修饰符）；  
③类即可以有静态构造函数也可以有实例构造函数；  
④如同静态方法，静态构造函数不能访问所在类的实例成员，因此不能使用 this 访问器；  
⑤不能从程序中显示地调用静态构造函数，系统会自动调用它们：在类的任意实例被创建之前，在类的任意静态成员被引用之前。

示例如下，Random 是 BCL 提供的用于产生随机数的类，位于 System 命名空间中：

``` C#
class RandomNumberClass
{
    private static Random RandomKey; //私有静态字段

    static RandomNumberClass() //静态构造函数
    {
        RandomKey = new Random(); //初始化RandomKey
    }

    public int GetRandomNumber()
    {
        return RandomKey.Next();
    }
}

class Program
{
    static void Main()
    {
        RandomNumberClass a = new RandomNumberClass();
        RandomNumberClass b = new RandomNumberClass();
        Console.WriteLine("Next Random #: {0}", a.GetRandomNumber());
        Console.WriteLine($"Next Random #: { b.GetRandomNumber() }");
    }
}
```

## 对象初始化语句 Object Initializers
**对象创建表达式**由关键字 new 和类构造函数加参数列表组成。  
**对象初始化语句**扩展了创建语法，在表达式尾部加上一组成员初始化语句，利用对象初始化语句，可以在创建新的对象实例时，设置字段和属性的值。

该语法有两种形式：  
①包括构造函数的参数列表：`new TypeName(ArgList) { FieldOrProp = InitExpr, FieldOrProp = InitExpr, ...}`；  
②不包括构造函数的参数列表：`new TypeName { FieldOrProp = InitExpr, FieldOrProp = InitExpr, ...}`；

``` C#
public class Point
{
    public int X = 1;
    public int Y = 2;
}

class Program
{
    static void Main( )
    {
        Point pt1 = new Point();
        Point pt2 = new Point { X = 5, Y = 6 };
        Console.WriteLine("pt1: {0}, {1}", pt1.X, pt1.Y);
        Console.WriteLine($"pt2: { pt2.X }, { pt2.Y }");
    }
}
```

运行结果如下：

``` console
pt1: 1, 2
pt2: 5, 6
```

## 析构函数 Destructors
**析构函数**执行在类的实例被销毁之前需要的清理或释放非托管资源的行为。非托管资源 Unmanaged resources 是指通过 Win32 API 获得的文件句柄 file handles ，或非托管内存块。详见第27章。

## readonly 修饰符
**readonly 修饰符**类似于将字段声明为 const，一旦值设置了就不能改变：  
① const 字段只能在字段的声明语句中初始化，而 readonly 字段可以在下列任意位置设置它的值：  
&ensp;&ensp;- 字段声明语句，类似于 const ；  
&ensp;&ensp;- 类的任何构造函数。如果是 static 字段，初始化必须在静态构造函数中完成。  
② const 字段的值必须可在编译时决定，而 readonly 字段的值可以在运行时决定。
③ const 的行为总是静态的，而对于 readonly 字段可以是实例字段，也可以是静态字段，并且在内存中有存储位置。

``` C#
class Shape
{
    readonly double PI = 3.1416; //初始化
    readonly int NumberOfSides; //未初始化

    public Shape(double side1, double side2) //构造函数
    {
        NumberOfSides = 4; //在构造函数中设定
        ···
    }

    public Shape(double side1, double side2, double side3) { 
        NumberOfSides = 3; //在构造函数中设定
        ···
    }
}
```

## this 关键字
**this 关键字**在类中是对当前实例的引用，只能被用在实例构造函数、实例方法、属性和索引器的实例访问器。

因为静态成员不是实例的一部分，所以不能在任何静态函数成员的代码中使用 this 关键字。this 主要用于区分类成员和局部变量或参数，以及作为调用方法的实参。

``` C#
class MyClass
{
    int Var1 = 10;

    public int ReturnMaxSum(int Var1) //参数
    { Parameter Field
        return Var1 > this.Var1
                    ? Var1 //参数
                    : this.Var1; //字段
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();

        Console.WriteLine($"Max: { mc.ReturnMaxSum(30) }");
        Console.WriteLine($"Max: { mc.ReturnMaxSum(5) }");
    }
}
```

虽然理解 this 关键字很重要，但是很少在代码中使用。

## 索引器 Indexers
**索引器**允许用索引访问类字段。

### 什么是索引器
**索引器**是一组 get 和 set 访问器，与属性类似：

<div  align="center">  
<img src="https://s2.loli.net/2022/12/16/aEWC8UMjmXOGA6i.png" width = "60%" height = "60%" alt="图31 - 索引器的表现形式"/>
</div>

### 索引器和属性
①和属性一样，索引器不用分配内存来存储；  
②索引器和属性都主要用来访问其他数据成员，与这些成员关联，并为它们提供获取和设置访问：
&ensp;&ensp;- 属性表示单个数据成员；  
&ensp;&ensp;- 索引器表示多个数据成员。

> 可以认为**索引器**是为类的多个数据成员提供 get 和 set 访问的**属性**。

但索引器总是实例成员，因此不能被声明为 static 。

### 声明索引器
声明索引器语法如下：  
①索引器没有名称，在名称的位置是关键字 this ；  
②参数列表在**方括号**内；  
③参数列表必须至少声明一个参数。

``` C#
ReturnType this [ Type param1, ... ]
{
    get
    {
        ...
    }

    set
    {
        ...
    }
}
```

### 索引器的 set 访问器
当索引器被用于赋值，set 访问器被调用，并接受2种数据：  
①一个名为 value 的隐式参数，其中持有要保存的数据；  
②索引参数，表示数据应该保存在哪里。  
`emp[0] = "Doe";`

set 访问器的语法和含义如下图：

<div  align="center">  
<img src="https://s2.loli.net/2022/12/16/lUVajeY5kGuXJ8W.png" width = "70%" height = "70%" alt="图32 - set 访问器的语法和含义"/>
</div>

左边是访问器声明的实际语法，右边展示了 set 访问器有如下语义：  
①它的返回类型为 void ；  
②它使用的参数列表和索引器声明中的相同；  
③它有一个名为 value 的隐式参数，值参类型与索引器类型相同。

### 索引器的 get 访问器
当使用索引器获取值时，可以通过索引参数调用 get 访问器：`string s = emp[0];`

