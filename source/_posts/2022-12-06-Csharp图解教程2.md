---
title: 《C#图解教程》读书笔记（二）
date: 2022-12-06 16:34:24
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：XXXXXXXXXXXXX。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第七章 深入理解类
## 类成员

| 数据成员（保存数据） | 函数成员（执行代码） |
| :---- | :---- |
| 字段 Fields <br> 常量 Constants | 方法 Methods&emsp; &emsp;运算符 Operators <br> 属性 Properties &emsp; &emsp;索引 Indexers <br> 构造函数 Constructors &emsp; &emsp;事件 Events <br> 析构函数 Destructors |

## 成员修饰符的顺序
类成员声明语句由下列部分组成：**核心声明**、一组可选的**修饰符 modifiers** 和一组可选的**特性 attributes** 。语法如下，方括号内的成分是可选的：  
`[特性] [修饰符] 核心声明`

①修饰符：若有多个修饰符，可以任意顺序排列。
②特性：若有多个特性，可以任意顺序排列。在第25章介绍特性。

比如以下代码在语义上是等价的（public 和 static 都是修饰符，返回类型是核心声明的一部分）：  
`public static int MaxVal;`  
`static public int MaxVal;`

## 实例类成员 Instance Class Members
类成员可以关联到类的一个实例，也可以关联到整个类。类的每个实例都拥有自己的各自类成员的副本，称为**实例成员**。改变一个实例字段的值，不会影响其他实例成员的值。

``` C#
class D
{
    public int Mem1;
}

class Program
{
    static void Main()
    {
        D d1 = new D();
        D d2 = new D();
        d1.Mem1 = 10; d2.Mem1 = 28;

        Console.WriteLine($"d1 = { d1.Mem1 }, d2 = { d2.Mem1 }");
    }
}
```

运行结果如下：

``` console
d1 = 10, d2 = 28
```

## 静态字段 Static Fields
以上都是实例字段，类还可以拥有**静态字段**。静态字段被类的所有实例**共享**，所有实例都访问同一内存位置。使用 **static 修饰符**将字段声明为静态： 

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/vjSrekiyVHofd6z.png" width = "80%" height = "80%" alt="图25 - 静态和非静态数据成员"/>
</div>

## 从类的外部访问静态成员
**点运算符**由实例名、点和成员名组成。就像实例成员，静态成员也可以使用点运算符从外部访问，因为没有实例，所以使用*类名*来访问静态成员：`D.Mem2 = 5;`

访问静态成员的另一种方法不需要前缀，而是使用 using static 声明：

``` C#
using static System.Console; // includes, amongst other members, Writeline()
using static System.Math; // includes, amongst other members, Sqrt()
...
WriteLine($"The square root of 16 is { Sqrt(16) }" );
```

等价于：

``` C#
using System;
...
Console.WriteLine($"The square root of 16 is { Math.Sqrt(16) }");
```

第22章详细介绍 using static 声明结构体。

### 静态字段示例：

``` C#
class D
{
    int Mem1;
    static int Mem2;

    public void SetVars(int v1, int v2) //设置值
    {   Mem1 = v1; Mem2 = v2;   }

    public void Display( string str )
    {   Console.WriteLine("{0}: Mem1= {1}, Mem2= {2}", str, Mem1, Mem2);   }
}

class Program {
    static void Main()
    {
        D d1 = new D(), d2 = new D(); //创建2个实例

        d1.SetVars(2, 4); //设置d1的值
        d1.Display("d1");

        d2.SetVars(15, 17); //设置d2的值
        d2.Display("d2");
    
        d1.Display("d1"); //注意，这时Mem2静态成员的值已改变
    }
}
```

运行结果如下：

``` console
d1: Mem1= 2, Mem2= 4
d2: Mem1= 15, Mem2= 17
d1: Mem1= 2, Mem2= 17
```

### 静态成员的生存期
即使类没有实例，也存在静态成员，并且可以访问。

## 静态函数成员 Static Function Members
如同静态字段，静态函数成员独立于任何类实例，没有实例也可以调用静态方法；*静态函数成员不能访问实例成员，但能访问其他静态成员*。

``` C#
class X
{
    static public int A; //静态字段
    static public void PrintValA() //静态方法
    {
        Console.WriteLine("Value of A: {0}", A); //访问静态字段
    }
}
```

## 其他静态类成员类型
可声明为 static 的类成员前面有勾号：

| 数据成员（保存数据） | 函数成员（执行代码） |
| :---- | :---- |
| √ 字段 Fields <br> √ 类型 Types <br> 常量 Constants | √ 方法 Methods <br> √ 运算符 Operators <br> √ 属性 Properties <br> 索引 Indexers <br> √ 构造函数 Constructors <br> √ 事件 Events |

## 成员常量 Member Constants
区分局部常量和成员常量，成员常量声明在类声明中而不是方法内：

``` C#
class MyClass
{
    const int IntVal1 = 100;
    const int IntVal2 = 2 * IntVal1; //用于初始化成员常量的值在编译时必须是可计算的
}
```

> C# 没有全局常量，常量必须声明在类型中，与 C 和 C++ 不同。

## 常量和静态量 Constants Are Like Statics
常量非常像静态值，没有类的实例也可以使用，但常量没有自己的存储位置，而是在编译时被编译器替换。这种方式类似于 C 和 C++ 的 #define 值。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/7YgDBGnX5zWKS9I.png" width = "75%" height = "75%" alt="图26 - 常量字段变现得像静态字段，但是在内存中没有存储位置"/>
</div>

不能将常量声明为 static ：`static const double PI = 3.14; //错误`

## 属性 Properties
**属性**是代表类实例或类中数据项的成员。使用属性如同写入和读取字段，语法相同。  

与字段不同，属性是一个函数成员：  
①它不一定为数据存储分配内存；  
②它执行代码

**属性 Properties** 是一个包含2个相关方法的被命名为**访问器 accessors** 的组合：  
① **set** 访问器为属性赋值；  
② **get** 访问器从属性获取值。

如下图，注意 - 访问器从后面伸出，因为它们不能直接被调用：

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/4AuSJHGaxwBvhP6.png" width = "60%" height = "60%" alt="图27 - int 类型的、名称为 MyValue 的属性示例"/>
</div>

### 属性声明和访问器
**set** 访问器总是：  
①拥有一个单独的、隐式的值参，名称为 value，与属性的类型相同；  
②拥有一个返回类型 void 。

**get** 访问器总是：  
①没有参数；  
②拥有一个与属性类型相同的返回类型。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/jwPlrzJe3Zs1tfk.png" width = "65%" height = "65%" alt="图28 - 属性声明的语法与结构"/>
</div>

set 访问器中的隐式参数 value 和其他值参一样，可以用它发送数据到方法体或访问器块。  

访问器其他要点如下：  
1、get 访问器和所有执行路径*必须包含一个 return 语句*，返回一个属性类型的值。  
2、访问器 set 和 get 可以以任何顺序声明，并且，除了这两个访问器外，属性不允许有其他方法。

### 属性示例
属性本身没有任何存储，在下面的情况下，使用名为 TheRealValue 的字段作为存储：

``` C#
class C1
{
    private int theRealValue; //字段：分配内存

    public int MyValue //属性：未分配内存
    {
        set { theRealValue = value; }
        get { return theRealValue; }
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/8VH1CPpoYmv5RUd.png" width = "35%" height = "35%" alt="图29 - 属性访问器常常使用字段作为存储"/>
</div>

### 使用属性
写入和读取属性时，访问器会被隐式得调用：  
`MyValue = 5; //赋值：隐式地调用 set 方法`  
`z = MyValue; //表达式：隐式地调用 get 方法`

注意：不能显示地调用访问器，会产生编译错误。

### 属性和关联字段 Properties and Associated Fields
一种常见的方式是在类中将字段声明为 private 以封装该字段，并声明一个 public 属性来控制从类外部对该字段的访问。和属性关联的字段被称为**后备字段 backing field **或**后备存储 backing store**。

以下示例使用公有属性 MyValue 来控制对私有字段 theRealValue 的访问：

``` C#
class C1
{
    private int theRealValue = 10; //后备字段：分配内存

    public int MyValue //属性：不分配内存
    {
        set{ theRealValue = value; } //设置字段值
        get{ return theRealValue; } //获取字段值
    }
}

class Program
{
    static void Main()
    {
        C1 c = new C1();
        Console.WriteLine("MyValue: {0}", c.MyValue); //把属性看作字段，从中读取它的值

        c.MyValue = 20; //使用赋值语句设置属性的值
        Console.WriteLine("MyValue: {0}", c.MyValue);
    }
}
```

### 执行其他计算
访问器 get 和 set 能执行任何计算，下面若输入值大于100，就将 theRealValue 设置为100：

``` C#
int theRealValue = 10; //字段
int MyValue //属性
{
    set { theRealValue = value > 100 ? 100 : value; } //条件运算符，见第9章
    get { return theRealValue; }
}
```

C# 7.0 为属性的 getter/setter 引入了使用**表达函数体**的语法，见第14章。这种语法只有在访问函数体由一个表达式组成的时候才能使用：

``` C#
int MyValue
{
    set => value > 100 ? 100 : value;
    get => theRealValue;
}
```

### 只读和只写属性 Read-Only and Write-Only Properties
只有 get 访问器的属性称为**只读属性**；只有 get 访问器的属性称为**只写属性**。

两个访问器中至少有一个必须被定义，否则编译器会产生一条错误信息。

### 属性与公有字段
根据实践，属性比公有字段更好：  
①属性是函数成员不是数据成员，允许处理输入和输出；  
②属性可以只读和只写，而字段不行；  
③编译后的变量和编译后的属性语义不同。

### 计算只读属性示例
在大多示例中，属性都和一个后备字段关联，并且 get 和 set 访问器引用该字段。但是属性不是必须和字段关联：

``` C#
class RightTriangle
{
    public double A = 3;
    public double B = 4;
    public double Hypotenuse //只读属性
    {
        get{ return Math.Sqrt((A*A)+(B*B)); } 
    }
}

class Program
{
    static void Main()
    {
        RightTriangle c = new RightTriangle();
        Console.WriteLine($"Hypotenuse: { c.Hypotenuse }");
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/JfszWaUQgRqPrt5.png" width = "35%" height = "35%" alt="图30 - 只读属性 Hypotenuse"/>
</div>

### 自动实现属性
因为属性经常被关联到后备字段，所以 C# 提供了**自动实现属性**（automatically implemented property 或 auto-implemented property，简称为**自动属性 auto-property**），允许只声明属性而不声明后备字段。编译器会自动创建隐藏的后备字段，并且自动挂接到 get 和 set 访问器上。

自动实现属性要点：  
①不声明后备字段：编译器根据属性的类型分配存储；  
②不能提供访问器的方法体：声明为分号。

``` C#
class C1
{
    public int MyValue //分配内存，没有声明后备字段
    {
        set; get; //访问器的方法体被声明为分号
    }
}

class Program
{
    static void Main()
    {
        C1 c = new C1();
        Console.WriteLine("MyValue: {0}", c.MyValue);

        c.MyValue = 20;
        Console.WriteLine("MyValue: {0}", c.MyValue);
    }
}
```

运行结果如下：

``` console
MyValue: 0
MyValue: 20
```

### 静态属性
属性也可以被声明为 static ，示例如下：

``` C#
using System;
using static ConsoleTestApp.Trivial;
namespace ConsoleTestApp
{
    class Trivial {
        public static int MyValue { get; set; }
        public void PrintValue()
        { Console.WriteLine("Value from inside: {0}", MyValue); } //从类内部访问MyValue
    }

    class Program {
        static void Main() {
            Console.WriteLine("Init Value: {0}", Trivial.MyValue); //从类外部访问MyValue
            Trivial.MyValue = 10;
            Console.WriteLine("New Value : {0}", Trivial.MyValue); //从类外部访问MyValue

            MyValue = 20; //从类外部访问，但因为using static，所以可以省略类名
            Console.WriteLine($"New Value : { MyValue }");
            Trivial tr = new Trivial();
            tr.PrintValue();
        }
    }
}
```

运行结果如下：

``` console
Init Value: 0
New Value : 10
New Value : 20
Value from inside: 20
```

## 实例构造函数 Instance Constructors
**实例构造函数**是一个特殊的方法，它在创建类的每个新实例时执行。构造函数用于初始化类实例的状态；如果要从类的外部创建类的实例，需要将构造函数声明为 public 。

构造函数的名称和类名相同；构造函数不能有返回值。

``` C#
class MyClass
{
    public MyClass() //声明为public，没有返回类型，和类名相同
    {
        ···
    }
    ...
}
```

### 带参数的构造函数
构造函数可以带参数，也可以被重载，和方法类似。

在使用创建对象表达式创建类的新实例时，要使用 new 运算符，后面跟着类的构造函数，new 运算符使用该构造函数创建类的实例：

``` C#
class Class1
{
    int Id;
    string Name;

    public Class1()            { Id=28; Name="Nemo";  } //构造函数0
    public Class1(int val)     { Id=val; Name="Nemo"; } //构造函数1
    public Class1(String name) { Name=name;           } //构造函数2

    public void SoundOff()
    { Console.WriteLine($"Name { Name }, Id { Id }"); }
}

class Program
{
    static void Main()
    {
        Class1 a = new Class1(), //调用构造函数0
               b = new Class1(7), //调用构造函数1
               c = new Class1("Bill"); //调用构造函数2

        a.SoundOff();
        b.SoundOff();
        c.SoundOff();
    }
}
```

运行结果如下：

``` console
Name Nemo, Id 28
Name Nemo, Id 7
Name Bill, Id 0
```

### 默认构造函数
如果在类中没有显示地提供实例构造函数，那么编译器会提供一个隐式的默认构造函数，它没有参数，方法体为空。若为类声明了构造函数，那么编译器将不会为该类定义默认构造函数。

如果声明了带参数的构造函数，那么试图使用不带参数的构造函数创建新的实例时，编译器会产生一条错误消息，因为没有无参数的构造函数。

## 静态构造函数
实例构造函数初始化类的每个新实例，而**静态构造函数**初始化类级别的项，通常，静态构造函数初始化类的静态字段。

