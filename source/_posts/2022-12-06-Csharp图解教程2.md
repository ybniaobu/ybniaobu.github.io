---
title: 《C#图解教程》读书笔记（二）
date: 2022-12-06 16:34:24
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：XXXXXXXXXXXXX。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第九章 表达式和运算符
## 表达式 Expressions
**运算符 operator** 是一个符号，表示返回单个结果的操作。**操作数 operand** 指作为运算符输入的数据元素。**表达式 expression** 是运算符和操作数的字符串。比如 `a + b + c + d` 有3个运算符和4个操作数。

**表达式求值 Evaluating an expression** 是将每个运算符以适当的顺序应用到它的操作数以产生一个值得过程。值被返回到表达式求值的位置。除了返回值，一些表达式可能还会在内存中设置一个值。

## 字面量 Literals
**字面量**是源代码中键入的数字或字符串。

``` C#
static void Main()
{
    Console.WriteLine("{0}", 1024); //整数字面量
    Console.WriteLine("{0}", 3.1416); //双精度型字面量
    Console.WriteLine("{0}", 3.1416F); //浮点型字面量
    Console.WriteLine("{0}", true); //布尔型字面量
    Console.WriteLine("{0}", 'x'); //字符型字面量
    Console.WriteLine("{0}", "Hi there"); //字符串字面量
}
```

① bool 有两个字面量：true 和 false ，注意和所有 C# 关键字一样，它们都是小写。  
② 对于引用类型变量，字面量 null 表示变量没有指向内存中的数据。

### 整数字面量 Integer Literals
整数字面量被书写为十进制数字序列，没有小数点，带有可选的后缀，指明整数的类型。

比如以下四个字面量：  
`236 //整数`  
`236L //长整数`  
`236U //无符号整数`  
`236UL //无符号长整数`  

整数类型字面量还可以写成十六进制 hex 形式，以 0x 或 0X 为前缀，实际数据类型用后缀指定。也可以写成二进制记法，以 0b 或 0B 为前缀，实际数据类型用后缀指定。

若没有后缀，编译器会把数字字符串解释为能表示该值而不丢失数据的相应类型的最小类型，比如236和5000000000都没有后缀，236会被解释为一个 int ，5000000000会被解释为一个 long 。

可以在数字字面量插入分隔符：`5_000_000_000`。

| 后缀 | 整数类型 | 备注 |
| :---- | :---- | :---- |
| 无 | int, uint, long, ulong | |
| U, u | uint, ulong | |
| L, l | long, ulong | 不推荐使用小写字母l，会和数字1混淆
| ul, uL, Ul, UL, lu, Lu, lU, LU | ulong | 不推荐使用小写字母l，会和数字1混淆 |

### 实数字面量 Real Literals
C# 有三种实数数据类型：float、double 和 decimal ，分别对应32位、64位和128位精度，都是浮点数据类型，实际使用中，double 最常用。

实数字面量包括十进制数字；一个可选的小数点；一个可选的指数部分 E 或 e ；一个可选的后缀：  
`float f1 = 236F;`  
`double d1 = 236.714;`  
`double d2 = .35192;`  
`double d3 = 6.338e-26;`

| 后缀 | 实数类型 |
| :---- | :---- |
| 无 | double |
| F, f | float |
| D, d | double |
| M, m | decimal |

> 注意：无后缀的实数字面量是 double 类型，而不是 float 类型！！！

### 字符字面量 Character Literals
**字符字面量**由**两个单引号**内的字符组成，用于表示单个字符(a)、非打印字符(\n换行符)或者执行特殊任务的字符，比如转义 escape (\\)。

尽管可能需要多个字符来表示一个字符字面量，但是每个字符字面量只表示一个字符，要引入多个字符，必须使用字符串字面量。

字符字面量可以是以下任意一种：  
`char c1 = 'd'; //单个字符`  
`char c2 = '\n'; //简单转义序列`  
`char c3 = '\x0061'; //十六进制转义序列`  
`char c4 = '\u005a'; //Unicode转义序列`  

①字符字面量的类型是 **char** ；  
②简单转义序列是一个反斜杠后面跟着单个字符；  
③十六进制转义序列是一个反斜杠后面跟着 X 或 x，后面4个十六进制数字；  
④Unicode 转义序列是一个反斜杠后面跟着 U 或 u，后面4个十六进制数字。

| 名称 | 转义序列 | 十六进制编码 |
| :---- | :---- | :---- |
| 空字符 Null | \0 | 0x0000 |
| 警告 Alert | \a | 0x0007 |
| 退格符 Backspace | \b | 0x0008 |
| 水平制表符 Horizontal tab | \t | 0x0009 |
| 换行符 New line | \n | 0x000A |
| 垂直制表符 Vertical tab | \v | 0x000B |
| 换页符 Form feed | \f | 0x000C |
| 回车符 Carriage return | \r | 0x000D |
| 双引号 Double quote | \" | 0x0022 |
| 单引号 Single quote | \' | 0x0027 |
| 反斜杠 Backslash | \\ | 0x005C |

### 字符串字面量 String Literals
**字符串字面量**使用**双引号**标记，不同于字符字面量使用单引号。

字符串字面量有两种类型：①**常规字符串字面量 Regular string literals**；②**逐字字符串字面量 Verbatim string literals**。

常规字符串字面量可以包含：字符、简单转义序列、十六进制转义序列和Unicode转义序列。例如：  
`string st1 = "Hi there!";`  
`string st2 = "Val1\t5, Val2\t10";`  
`string st3 = "Add\x000ASome\u0007Interest";`

逐字字符串字面量是以 @ 字符为前缀的常规字符串字面量，逐字字符串字面量中字符串不会被转义。逐字字符串字面量的唯一例外就是相邻的双引号组，被解释为单个双引号字符。

``` C#
string rst1 = "Hi there!";
string vst1 = @"Hi there!";

string rst2 = "It started, \"Four score and seven...\"";
string vst2 = @"It started, ""Four score and seven...""";

string rst3 = "Value 1 \t 5, Val2 \t 10";
string vst3 = @"Value 1 \t 5, Val2 \t 10";

string rst4 = "C:\\Program Files\\Microsoft\\";
string vst4 = @"C:\Program Files\Microsoft\";

string rst5 = " Print \x000A Multiple \u000A Lines";

string vst5 = @" Print
Multiple
Lines";
```

打印这些字符串会产生以下输出：

``` console
Hi there!
Hi there!

It started, "Four score and seven..."
It started, "Four score and seven..."

Value 1 5, Val2 10
Value 1 \t 5, Val2 \t 10

C:\Program Files\Microsoft\
C:\Program Files\Microsoft\

Print
Multiple
Lines

Print
Multiple
Lines
```

## 求值顺序
表达式可以有很多嵌套的子表达式构成，求值顺序可以是表达式最终值发生变化。

### 优先级
优先级从高到低如下表所示：

| 分类 | 运算符 |
| :---- | :---- |
| 初级运算符 <font face= "Arial"> Primary </font> | <font face= "Arial"> a.x, f(x), a[x], x + +, x - -, new, typeof, checked, unchecked </font> |
| 一元运算符 <font face= "Arial">Unary</font> | <font face= "Arial">+, -, !, ~, + + x, - - x, (T)x</font> |
| 乘法 <font face= "Arial">Multiplicative</font> | <font face= "Arial"> *, /, % </font> |
| 加法 <font face= "Arial">Additive</font> | <font face= "Arial">+, -</font> |
| 移位 <font face= "Arial">Shift</font> | <font face= "Arial"><<, >></font> |
| 关系和类型 <font face= "Arial">Relational and type</font> | <font face= "Arial"><, >, <=, >=, is, as</font> |
| 相等 <font face= "Arial">Equality</font> | <font face= "Arial">==, !=</font> |
| 位与 <font face= "Arial">Logical AND</font> | <font face= "Arial">&</font> |
| 位异或 <font face= "Arial">Logical XOR</font> | <font face= "Arial">^</font> |
| 位或 <font face= "Arial">Logical OR</font> | <font face= "Arial">&#124;</font> |
| 条件与 <font face= "Arial">Conditional AND</font> | <font face= "Arial">&&</font> |
| 条件或 <font face= "Arial">Conditional OR</font> | <font face= "Arial">&#124;&#124;</font> |
| 条件选择 <font face= "Arial">Conditional</font> | <font face= "Arial">?:</font> |
| 赋值运算符 <font face= "Arial">Assignment</font> | <font face= "Arial">=, *=, /=, %=, +=, -=, <<=, >>=, &=, ^=, &#124;=</font> |

### 结合性 Associativity
如果有连续的运算符有相同的优先级别，求值顺序由**操作结合性 operator associativity** 决定，比如 `2/6*4` 求值顺序有2种。

运算符结合性重要特征：①左结合运算符从左至右求值；②右结合运算符从右至左求值；  

| 运算符类型 | 结合性 |
| :---- | :---- |
| 赋值运算符 | 右结合 |
| 其他二元运算符 | 左结合 |
| 条件运算符 | 右结合 |

所以 `2/6*4` 应该是从左到右，得到 4/3 。

可以直接使用**圆括号**来显式地设定子表达式求值顺序，并覆盖优先级和结合性规则。

## 简单算术运算符
简单算术运算符包括 `+` 、`-` 、`*` 、`/` 。这些运算符都是二元左结合运算符。对于除法，要注意整数除法，直接截取整数部分。

## 求余运算符 The Remainder Operator
求余运算符 `%` ，返回余数。

求余运算符还可以用于实数以得到实余数 real remainders。

``` C#
Console.WriteLine("0.0f % 1.5f is {0}" , 0.0f % 1.5f);
Console.WriteLine("0.5f % 1.5f is {0}" , 0.5f % 1.5f);
Console.WriteLine("1.0f % 1.5f is {0}" , 1.0f % 1.5f);
Console.WriteLine("1.5f % 1.5f is {0}" , 1.5f % 1.5f);
Console.WriteLine("2.0f % 1.5f is {0}" , 2.0f % 1.5f);
Console.WriteLine("2.5f % 1.5f is {0}" , 2.5f % 1.5f);
```

得到：

``` console
0.0f % 1.5f is 0 
0.5f % 1.5f is 0.5 
1.0f % 1.5f is 1 
1.5f % 1.5f is 0 
2.0f % 1.5f is 0.5 
2.5f % 1.5f is 1 
```

## 关系比较运算符和相等比较运算符
关系比较运算符和相等比较运算符是二元运算符，比较它们的操作数并返回 bool 型值，它们都是左结合运算符。包括 `<` , `>` , `<=` , `>=` , `==` , `!=` 。

> 与 C 和 C++ 不同，**在 C# 中数字不具有布尔意义**。

### 比较操作和相等性操作
对于大多数引用类型来说，比较它们的相等性时，只比较它们的引用。  
①如果引用相等，即指向内存中相同的对象，那么相等性比较为 true，否则为 false 。这称为**浅比较 shallow comparison** 。  
② string 类型对象也是引用类型，但是比较字符串的相等性时，若两个字符串有相同的长度和内容（区分大小写），则返回 true ，即使它们占有不同的内存区域。这称为**深比较 deep comparison** 。

委托也是深比较，见第14章，若两个委托都是 null ，或两者的调用列表中有相同数目的成员，并且调用列表相匹配，则比较返回 true 。

比较数值表达式时，比较类型和值；比较 enum 类型，比较操作数的实际值，枚举见第12章。

## 递增运算符和递减运算符 Increment and Decrement Operators
递增运算符和递减运算符是一元的，有2种形式，**前置**形式和**后置**形式，产生不同效果：

| 运算符 | 名称 | 描述 |
| :---- | :---- | :---- |
| <font face= "Arial">++</font> | 前置递增 <font face= "Arial">++var</font> | 变量的值加1并保存，返回变量的新值 |
| <font face= "Arial">++</font> | 后置递增 <font face= "Arial">var++</font> | 变量的值加1并保存，返回变量递增之前的旧值 |
| <font face= "Arial">\-\-</font> | 前置递减 <font face= "Arial">\-\-var</font> | 变量的值减1并保存，返回变量的新值 |
| <font face= "Arial">\-\-</font> | 后置递减 <font face= "Arial">var\-\-</font> | 变量的值减1并保存，返回变量递增之前的旧值 |

| | 表达式：x=10 | 返回给表达式的值 | 计算后变量的值 |
| :---- | :---- | :---- | :---- |
| 前置递增 | <font face= "Arial">++x</font> | 11 | 11 |
| 后置递增 | <font face= "Arial">x++</font> | 10 | 11 |
| 前置递减 | <font face= "Arial">\-\-x</font> | 9 | 9 |
| 后置递减 | <font face= "Arial">x\-\-</font> | 10 | 9 |

## 条件逻辑运算符 Conditional Logical Operators
逻辑运算符包括逻辑与 AND 、逻辑或 OR 、逻辑非 NOT 。逻辑与和逻辑或运算符是二元左结合运算符。逻辑非是一元运算符。

| 运算符 | 名称 | 描述 |
| :---- | :---- | :---- |
| && | 与 | 如果两个操作数都是true，结果为true；否则为false |
| &#124;&#124; | 或 | 如果至少一个操作数是true，结果为true；否则为false |
| ! | 非 | 如果操作数是false，结果为true；否则为false |

条件逻辑运算符使用 **“短路” short-circuit** 模式操作，即若计算第一个操作数之后就能确定值，就会跳过第二个操作数的计算。比如下面代码，变量 iVal 的后置递增不会被执行，因为执行了第一个子表达式后，可以确定返回值是 false 。

``` C#
bool bVal; int iVal = 10;

    bVal = (1 == 2) && (9 == iVal++); //结果：bVal = False, iVal = 10
```

## 逻辑运算符 Logical Operators
按位逻辑运算符如下表，除按位非运算符以外，这些运算符都是二元左结合运算符，按位非运算符是一元运算符：

| 运算符 | 名称 | 描述 |
| :---- | :---- | :---- |
| & | 位与 Bitwise AND | 仅当两个操作数都为1时，位的结果为1 |
| &#124; | 位或 Bitwise OR | 只要任意一个操作数为1时，位的结果为1 |
| ^ | 位异或 Bitwise XOR | 仅当一个而不是两个操作数为1时，位的结果为1 |
| ~ | 位非 Bitwise negation | 得到操作数的二进制反码 |

<div  align="center">  
<img src="https://s2.loli.net/2023/01/05/I7cKHLZrNB9sbn4.png" width = "60%" height = "60%" alt="图46 - 按位逻辑操作示例"/>
</div>

## 移位运算符 Shift Operators
移位运算符是二元左结合运算符：

| 运算符 | 名称 | 描述 |
| :---- | :---- | :---- |
| << | 左移 | 将位组向左移动给定数目个位置。位从左边移出并丢失，右边的位位置用0填充 |
| >> | 右移 | 将位组向右移动给定数目个位置。位从右边移出并丢失 |

底层硬件使用二进制补码 two’s complement 的形式表示有符号二进制数。在二进制补码表示法中，负数最左侧的位位置是1，正数的补码和原码一致，负数的补码是原码的基础上对各个位取反后加1。所以要把一个正数转换成负数，要把这个数按位取反再加1，反之亦然。

位移有符号的数字，左移一位的结果与把它乘以2的结果相同，右移一位的结果和除以2相同。然而如果右移一个负数，最左边位用0填充，会让数字变成正数，为了应对这种情形，当操作数是有符号的整数时，如果操作数最左边的位是1，在左边移开的位位置用1而不是0填充，这保持了正确的二进制补码表示法。

<div  align="center">  
<img src="https://s2.loli.net/2023/01/05/Gf4H6V7msDu5pvt.png" width = "65%" height = "65%" alt="图47 - 移位"/>
</div>

## 赋值运算符 Assignment Operators
赋值运算符先将运算符右侧的表达式求值，并用该值设置运算符左边的变量的值，故赋值运算符是二元右结合运算符：

| 运算符 | 描述 |
| :---- | :---- |
| = | 简单赋值; 计算右边表达式的值，并把返回值赋给左边的变量或表达式 |
| \*= | 复合赋值; var \*= expr 等价于 var = var \* (expr) |
| /= | 复合赋值; var /= expr 等价于 var = var / (expr) |
| %= | 复合赋值; var %= expr 等价于 var= var % (expr) |
| += | 复合赋值; var += expr 等价于 var = var + (expr) |
| -= | 复合赋值; var -= expr 等价于 var = var- (expr) |
| <<= | 复合赋值; var <<= expr 等价于 var = var << (expr) |
| >>= | 复合赋值; var >>= expr 等价于 var = var >> (expr) |
| &= | 复合赋值; var &= expr 等价于 var = var & (expr) |
| ^= | 复合赋值; var ^= expr 等价于 var = var ^ (expr) |
| &#124;= | 复合赋值; var &#124;= expr 等价于 var = var &#124; (expr) |

对于复合赋值：

``` C#
x += y – z; //等价于 x = x + (y – z);
x *= y – z; //等价于 x = x * (y – z);
x /= y – z; //等价于 x = x / (y – z);
```

## 条件运算符 The Conditional Operator
条件运算符是三元运算符，语法如下：`Condition ? Expression1 : Expression2`，包含一个测试表达式和两个结果表达式：  
① Condition 必须返回一个 bool 类型的值；  
② 如果 Condition 求值为 true ，那么对 Expression1 求值并返回，否则，对 Expression2 求值并返回；

``` C#
if ( x < y )
    intVar = 5;
else
    intVar = 10;
```

上述代码等价于 `intVar = x < y ? 5 : 10;`，或者如下：

``` C#
intVar = x < y
        ? 5
        : 10;
```

## 一元算术运算符 Unary Arithmetic Operators
就是数学的正负号，比如 `int x = +10;` `int y = -x;`

## 用户定义的类型转换
用户定义的类型转换详见第17章，这里提一下是因为它们是运算符：

可以为自己的类和结构定义隐式转换和显式转换：  
①对于隐式转换，编译器会根据特定上下文决定使用特定的类型，并进行自动转换；  
②对于显式转换，编译器只在使用显式转换运算符时才执行转换。

声明隐式转换的语法如下，public 和 static 修饰符是必需的，TargetType 为目标类型，SourceType Identifier 为源数据：

``` C#
public static implicit operator TargetType ( SourceType Identifier )
{
    ...
    return ObjectOfTargetType;
}
```

显式转换语法相同，但用 explicit 替换 implicit 。

隐式转换示例如下：

``` C#
class LimitedInt
{
    const int MaxValue = 100;
    const int MinValue = 0;

    public static implicit operator int (LimitedInt li) //将LimitedInt转换为int
    {
        return li.TheValue;
    }

    public static implicit operator LimitedInt (int x) //将int转换为LimitedInt
    {
        LimitedInt li = new LimitedInt();
        li.TheValue = x;
        return li;
    }

    private int mTheValue = 0;
    public int TheValue {
        get { return mTheValue; }
        set
        {
            if (value < MinValue)
                mTheValue = 0;
            else
                mTheValue = value > MaxValue
                                ? MaxValue
                                : value;
        }
    }
}

class Program {
    static void Main()
    {
        LimitedInt li = 500; //将500转换为LimitedInt
        int value = li; //将LimitedInt转换为int

        Console.WriteLine($"li: { li.TheValue }, value: { value }");
    }
}
```

运行结果如下：

``` console
li: 100, value: 100
```

### 显式转换和强制转换运算符
