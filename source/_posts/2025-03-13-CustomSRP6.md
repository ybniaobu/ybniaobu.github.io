---
title: Unity Custom SRP 基础（六）
date: 2025-03-13 20:44:31
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2025/03/13/LozNxAmnlEJSOyV.gif
mathjax: true
description: 本笔记的主要内容包含 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX。
---

> 本笔记是关于 Unity 的**自定义可编程渲染管线**的入门基础，即 **SRP (Scriptable Rendering Pipeline)**，主要参考了著名的教程 https://catlikecoding.com/ 的 Custom SRP Tutorial，以及知乎上各位图形学大神们的文章。  
>    
> 笔者使用的 Unity 版本是 6000.0.27f1，Core RP Library 的版本是 17.0.3。

# HDR
到目前为止，我们输出到相机的帧缓冲仍然是 LDR 格式，即 B8G8R8A8_SRGB 格式。这意味着输出的颜色都会被限制在 0.0 到 1.0 之间，任何大于 1.0 的颜色值都会被 clamp 到 1.0，相当于在片元着色器函数的结尾做了一次 `saturate()`。但是在 Shader 里计算时，部分像素的颜色值很可能会高于 1.0，特别是在多光源的情况下，这就会造成部分区域非常白，导致场景细节的丢失。

为了解决这一问题，我们就需要使用 **HDR (High Dynamic Range，高动态范围)** 的帧缓冲了，一般 HDR 会使用 R16G16B16A16_FLOAT 的格式（最大值为 65504），也有为了减少带宽的开销，而压缩成 R11G11B10_FLOAT 格式的。这样子大于 1.0 的颜色值就可以存储在纹理当中了，从而获取更大范围的黑暗或明亮值。但是大部分显示器仍然只能显示 sRGB 色彩空间的颜色（这里暂时不讨论支持 HDR 输出的显示器），即 [0, 255] 或 [0.0, 1.0] 范围的值，此时就需要将 HDR 重新映射回 LDR 值，而这个操作就叫做**色调映射 Tone Mapping**，该操作的主要目的就是尽可能地保留场景的黑暗与明亮细节，所以它本质上就是增强明暗的对比度，呈现出来的映射关系曲线是一个 S 形曲线（后面具体讲 Tone Mapping 时有图片）。

> 注意区分 Tone Mapping 和 **Gamma 校正**，这两个操作是相互独立的，Tonemapping 将 HDR 颜色转换到 LDR 颜色，但两者仍然都在线性空间，之后仍然需要做 Gamma 校正。  

## 支持 HDR rendering
我们可以在 RenderPipelineAsset 里面增加一个 bool 字段，用于控制 HDR 的开启。然后在创建 FrameBuffer 的地方根据该字段生成 HDR 格式：  

``` C#
data.buffer.GetTemporaryRT(RenderTargetIDs.k_FrameBufferId, data.camera.pixelWidth, data.camera.pixelHeight, 32, FilterMode.Bilinear, asset.enableHDR ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
```

default HDR 格式就是 R16G16B16A16_FLOAT。这样子，我们的场景就会使用 HDR 渲染，打开 Frame Debugger，可以看到在最后输出之前渲染出来的图片颜色变深了，这就是因为渲染到了 HDR 的线性空间当中，所以看起来变暗了。但是我们不用关心最后输出时的 gamma 校正，因为在线性空间的设置下，Unity 会自动处理 gamma 校正问题。

## HDR Bloom
之前 LDR Bloom 的预过滤和采样过程中，都是将中间结果输出到 LDR 贴图当中的。那么我们首先应该将它们改为 HDR 贴图：  

``` C#
public override void Render(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    // do bloom at half or quarter resolution
    ...
    // Determine the iteration count
    ...
    // Shader property and keyword setup
    ...

    // HDR
    RenderTextureFormat format = asset.enableHDRFrameBufferFormat ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default;

    // Prefilter
    data.buffer.GetTemporaryRT(k_BloomPrefilterId, width, height, 0, FilterMode.Bilinear, format);
    ...

    // Downsample - gaussian pyramid
    int sourceId = k_BloomPrefilterId;
    for (int i = 0; i < iterationCount; i++)
    {
        data.buffer.GetTemporaryRT(m_BloomPyramidUpIds[i], width, height, 0, FilterMode.Bilinear, format);
        data.buffer.GetTemporaryRT(m_BloomPyramidDownIds[i], width, height, 0, FilterMode.Bilinear, format);
        ...
    }

    // Upsample - bilinear or bicubic
    ...
    // Final Blit
    ...
    // Release RT
    ...
}
```

这样子 Addictive Bloom 就可以在 HDR 下正常工作了。HDR Bloom 和 LDR Bloom 的重要区别在于，HDR Bloom 中一个特别大的值会影响到一个非常大的区域，即使是一个像素，也可能会产生非常高亮的 Bloom 区域。产生这个现象的原因就是平均值的极端值效应，本来 4 个像素平均，LDR 下无论怎么平均都是小于 1 的平均数，现在 HDR 下，4 个像素中一个像素值为 10，其他像素值再小，平均值也会被拉得很大。于是乎，就产生了 HDR Bloom 的一个最大弊端，也是必须要克服的弊端，即闪烁现象。

### Bloom 闪烁问题
HDR Bloom 的闪烁问题在镜头移动的情况下会格外严重，我这里 gif 就不放出来了，URP 下该现象就挺严重的（看了下 URP 的 Bloom Shader，确实没解决闪烁问题）。而解决方案是在 Prefilter 阶段做一次模糊处理，并使用以下权重做平均来降低动态范围，这个方法叫做 **Karis Average**：  

$$ weight = \cfrac {1} {1 + luminance} $$

在该权重下，亮度越高，权重越低。这个方法虽然损失一部分的 bloom 范围和亮度，但是能在一定程度减少 Bloom 闪烁问题，虽然做不到完全解决，完全解决可以说是不可能的。该方法的实现如下：①将 Prefilter 的 Bilinear 2 × 2 采样扩展为 6 × 6 的 box 核，在采样时（模糊平均前）应用 bloom threshold 提取较亮区域。②使用 Karis Average 在模糊时做加权平均，替代 box 核的算术平均，对颜色进行修正。

    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

    float4 BloomPrefilterFrag(Varyings IN) : SV_TARGET
    {
        float3 color = float3(0.0, 0.0, 0.0);
        float2 offsets[9] = { float2(0.0, 0.0), float2(-1.0, -1.0), float2(-1.0, 1.0), float2(1.0, -1.0), float2(1.0, 1.0), float2(-1.0, 0.0), float2(1.0, 0.0), float2(0.0, -1.0), float2(0.0, 1.0)};

        UNITY_UNROLL
        for (int i = 0; i < 9; i++)
        {
            float2 offset = offsets[i] * _BlitTexture_TexelSize.xy * 2.0;
            float3 c = ApplyBloomThreshold(SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv + offset, 0).rgb);
            float w = 1.0 / (Luminance(c) + 1.0);
            color += c * w;
            weight += w;
        }
        color /= weight;

        color = max(color, 0.0);
        return float4(color, 1.0);
    }

亮度的计算之前《Unity Shader入门精要》读书笔记（四）中也讲过，Core RP Library 的 Color.hlsl 也提供了相关的函数。上面之所以在 offset 中乘以 2.0 是因为我们使用的是 bilinear 采样器，采样一次可以覆盖 2 × 2 个像素，这样我们使用一个 3 × 3 的像素之间距离为 2 的 box 核，就可以覆盖到 6 × 6 个像素。最后一定要将颜色 clamp 到 0 以上，否则画面有可能会出现黑块。

这样子就可以解决大部分的闪烁问题了。但上面代码还可以再优化一步，因为下采样阶段使用了高斯模糊，我们可以将上述代码再减少 4 次采样，即与中心点相邻的 4 个采样点：  

    float4 BloomPrefilterFrag(Varyings IN) : SV_TARGET
    {
        ...
        float2 offsets[5] = { float2(0.0, 0.0), float2(-1.0, -1.0), float2(-1.0, 1.0), float2(1.0, -1.0), float2(1.0, 1.0)};

        for (int i = 0; i < 5; i++)
        {
            ...
        }
        ...
    }

这将会使 Prefilter 阶段产生的结果中一个较亮像素变为 x 形状，可以点开 Frame Debugger 查看。但是经过一次下采样，这种图案样式就会消失。


# Scattering Bloom
Scattering Bloom 和 Additive Bloom 在实现方法上是非常类似的，但是对于各自所想要呈现的效果却有所不同，这两种方法的出发点是不同的，故它们之间没有优劣之分。**Addictive Bloom** 更偏向艺术化的表达，相对 Scattering Bloom 更不遵守能量守恒，因为我们在上采样阶段不断叠加会导致 bloom 区域亮度超过了原本图片中的亮度。而 **Scattering Bloom** 考虑了能量守恒，它只模糊但不添加额外的亮度，这使得特别是在灯光或者发光物体使用物理光照单位时，能够更正确地表现出其原本拥有的亮度值。

Scattering Bloom 的实现步骤也比较简单，就是在上采样阶段使用 Scatter 属性在 high-resolution 和 low-resolution 的贴图之间做 lerp，而不是直接相加。这样我们上采样阶段最后得到的贴图的亮度值就不会发生变化，最后在叠加到 frame buffer 时（final blit 阶段）先将 Prefilter 阶段提取的较亮区域抠出来，再将上采样阶段得到的贴图贴上去。

## Scatter
首先我们要为上采样阶段添加一个新的 Pass，我命名为了 BloomScatteringUpsampleFrag，
