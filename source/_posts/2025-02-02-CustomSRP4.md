---
title: Unity Custom SRP 基础（四）
date: 2025-02-02 14:35:41
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2025/02/02/aLrYVUITs8tnuOw.gif
mathjax: true
description: 本笔记的主要内容包含XXXXXXXXXXXXXXXXXXXXXXXXXX。
---

> 本笔记是关于 Unity 的**自定义可编程渲染管线**的入门基础，即 **SRP (Scriptable Rendering Pipeline)**，主要参考了著名的教程 https://catlikecoding.com/ 的 Custom SRP Tutorial，以及知乎上各位图形学大神们的文章。  
>    
> 笔者使用的 Unity 版本是 6000.0.27f1，Core RP Library 的版本是 17.0.3。

# Punctual Lights
本章节讲解如何在 SRP 中支持 2 种最常见的**精确光源 Punctual Light**，即**点光源 Point Light** 和**聚光灯 Spot Light**。这两种光源的计算方法本质上其实是一样的，在 Shader 中遍历 Punctual Light 无需区分具体是哪种光源，只不过 Spot Light 多了一个**角度衰减 Angle Attenuation** 的计算，而 Point Light 的 Angle Attenuation 会被设置为 1。而两种光源都遵守 [Inverse-square law](https://en.wikipedia.org/wiki/Inverse-square_law)，即需要计算**距离衰减 Distance Attenuation**。角度衰减和距离衰减的逻辑在我的文章 [Unity URP 基础](https://ybniaobu.github.io/2024/02/23/2024-02-23-URP%E5%9F%BA%E7%A1%80/#%E9%99%84%E5%8A%A0%E5%85%89%E6%BA%90%E6%8E%A5%E5%8F%97%E9%98%B4%E5%BD%B1)都有讲过，故下面讲得不会特别详细，同时我也会将 Point Light 和 Spot Light 放在一起讲。

> 精确光源 Punctual Light 表示有明确位置的光源，通常包括 Point Light、Spot Light，但是在有些文献中可能会包括 Directional Light，这就要看该术语使用者对术语的具体定义了。

## CPU 中具体实现
跟 Directional Light 一样，我们首先要设置一个精确光的最大支持数量，64 个精确光源基本足够使用了：  

``` C#
private const int m_MaxDirectionalLightCount = 1;
private const int m_MaxPunctualLightCount = 64;
```

然后跟 Directional Light 一样需要传递数据给 GPU，这些数据有如下：

``` C#
private static readonly int m_PunctualLightCountId = Shader.PropertyToID("_PunctualLightCount");
private static readonly int m_PunctualLightColorsId = Shader.PropertyToID("_PunctualLightColors");
private static readonly int m_PunctualLightPositionsId = Shader.PropertyToID("_PunctualLightPositions");
private static readonly int m_SpotLightDirectionsId = Shader.PropertyToID("_SpotLightDirections");
private static readonly int m_SpotLightParamsId = Shader.PropertyToID("_SpotLightParams");

private Vector4[] m_PunctualLightColors = new Vector4[m_MaxPunctualLightCount];
private Vector4[] m_PunctualLightPositions = new Vector4[m_MaxPunctualLightCount];
private Vector4[] m_SpotLightDirections = new Vector4[m_MaxPunctualLightCount];
private Vector4[] m_SpotLightParams = new Vector4[m_MaxPunctualLightCount];
```

①`_PunctualLightCount` 即场景中可见的精确光数量，传递该数据有两个用途：一是减少 Shader 中遍历的次数，不传递就需要遍历 64 次；二是确保精确光打开后又关闭时，遗留在 Constant Buffer 中的数据不影响到场景；  
②`_PunctualLightColors` 和 `_PunctualLightPositions` 就是传递颜色和光源位置，`_PunctualLightPositions.w` 则额外传递了 Light Range 的平方的倒数，这是用来计算 Distance Attenuation 的，后面会讲到；  
③ Spot Light 需要计算 Angle Attenuation，而 Angle Attenuation 的计算需要用到三个参数：光源方向（光源位置减着色点位置）、聚光灯的朝向、聚光灯内外角相关参数。光源方向可以通过 `_PunctualLightPositions` 计算出来，聚光灯的朝向通过 `_SpotLightDirections` 传递，聚光灯内外角相关参数通过 `_SpotLightParams` 传递。  

接下来就是记录上述数据并传递（这里函数名可能会和之前的文章不一样，但逻辑是一样的）：  

``` C#
...
private int m_PunctualLightCount;
...

private void RecordLightData(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    NativeArray<VisibleLight> visibleLights = data.cullingResults.visibleLights;
    ...
    m_PunctualLightCount = 0;
    ...

    for (int i = 0; i < visibleLights.Length; i++)
    {
        VisibleLight visibleLight = visibleLights[i];
        Light light = visibleLight.light;

        if (visibleLight.lightType == LightType.Directional)
        {
          ...
        }
        else if (visibleLight.lightType == LightType.Point)
        {
            if (m_PunctualLightCount >= m_MaxPunctualLightCount) continue;

            m_PunctualLightColors[m_PunctualLightCount] = visibleLight.finalColor;
            Vector4 position = visibleLight.localToWorldMatrix.GetColumn(3);
            position.w = 1.0f / Mathf.Max(visibleLight.range * visibleLight.range, 0.0001f);
            m_PunctualLightPositions[m_PunctualLightCount] = position;
            
            m_SpotLightParams[m_PunctualLightCount] = new Vector4(0.0f, 1.0f);
            
            m_PunctualLightCount++;
        }
        else if (visibleLight.lightType == LightType.Spot)
        {
            if (m_PunctualLightCount >= m_MaxPunctualLightCount) continue;

            m_PunctualLightColors[m_PunctualLightCount] = visibleLight.finalColor;
            Vector4 position = visibleLight.localToWorldMatrix.GetColumn(3);
            position.w = 1.0f / Mathf.Max(visibleLight.range * visibleLight.range, 0.0001f);
            m_PunctualLightPositions[m_PunctualLightCount] = position;

            m_SpotLightDirections[m_PunctualLightCount] = -visibleLight.localToWorldMatrix.GetColumn(2);
            
            float cosInnerAngle = Mathf.Cos(Mathf.Deg2Rad * 0.5f * light.innerSpotAngle);
            float cosOuterAngle = Mathf.Cos(Mathf.Deg2Rad * 0.5f * visibleLight.spotAngle);
            float invAngleRange = 1.0f / Mathf.Max(cosInnerAngle - cosOuterAngle, 0.0001f);
            m_SpotLightParams[m_PunctualLightCount] = new Vector4(invAngleRange, -cosOuterAngle * invAngleRange);
            
            m_PunctualLightCount++;
        }
    }
}

private void DeliverLightData(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    if (m_SunLightCount > 0)
    {
        ...
    }
    
    data.buffer.SetGlobalInt(m_PunctualLightCountId, m_PunctualLightCount);
    if (m_PunctualLightCount > 0)
    {
        data.buffer.SetGlobalVectorArray(m_PunctualLightColorsId, m_PunctualLightColors);
        data.buffer.SetGlobalVectorArray(m_PunctualLightPositionsId, m_PunctualLightPositions);
        data.buffer.SetGlobalVectorArray(m_SpotLightDirectionsId, m_SpotLightDirections);
        data.buffer.SetGlobalVectorArray(m_SpotLightParamsId, m_SpotLightParams);
    }
}
```

①`m_PunctualLightColors` 的获取跟 Directional Light 一样；  
②`m_PunctualLightPositions` 可以通过 localToWorld 矩阵的第四列获取，也就是齐次坐标扩展的那一列。当然也可以通过 `visibleLight.light.transform.position` 获取。至于 w 分量则额外传递计算 Distance Attenuation 所需参数，为什么这么计算详见 GPU 中具体实现小节，或者看之前的文章；  
③`m_SpotLightDirections` 之前的文章有讲过，Spot Light 的默认照明方向是朝着 z 轴正方向照明，所以取模型空间到世界空间的矩阵的第三列，又因为我们需要的是指向光源的方向，所以取反；  
④`m_SpotLightParams` 的 x、y 分量存储计算 Angle Attenuation 所需的聚光灯内外角相关参数，分别是 invAngleRange 和 -cosOuterAngle * invAngleRange，还是详见 GPU 中具体实现小节或者看之前的文章。z、w 分量暂不存储数据。顺便提一下，Point Light 需要将 x、y 分量设置为 0 和 1 以便 Point Light 的 Angle Attenuation 计算出来为 1。  

## GPU 中具体实现

### Distance Attenuation

### Angle Attenuation
