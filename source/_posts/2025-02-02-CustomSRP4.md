---
title: Unity Custom SRP 基础（四）
date: 2025-02-02 14:35:41
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2025/02/02/aLrYVUITs8tnuOw.gif
mathjax: true
description: 本笔记的主要内容包含精确光（包括聚光灯和点光源）的光照实现和阴影实现（不包括 PCSS 的实现），并简单说明了 Unity 的 Per-Object Light Indices 技术以及烘焙精确光。
---

> 本笔记是关于 Unity 的**自定义可编程渲染管线**的入门基础，即 **SRP (Scriptable Rendering Pipeline)**，主要参考了著名的教程 https://catlikecoding.com/ 的 Custom SRP Tutorial，以及知乎上各位图形学大神们的文章。  
>    
> 笔者使用的 Unity 版本是 6000.0.27f1，Core RP Library 的版本是 17.0.3。

# Punctual Lights
本章节讲解如何在 SRP 中支持 2 种最常见的**精确光源 Punctual Light**，即**点光源 Point Light** 和**聚光灯 Spot Light**。这两种光源的计算方法本质上其实是一样的，在 Shader 中遍历 Punctual Light 无需区分具体是哪种光源，只不过 Spot Light 多了一个**角度衰减 Angle Attenuation** 的计算，而 Point Light 的 Angle Attenuation 会被设置为 1。而两种光源都遵守 [Inverse-square law](https://en.wikipedia.org/wiki/Inverse-square_law)，即需要计算**距离衰减 Distance Attenuation**。角度衰减和距离衰减的逻辑在我的文章 [Unity URP 基础](https://ybniaobu.github.io/2024/02/23/2024-02-23-URP%E5%9F%BA%E7%A1%80/#%E9%99%84%E5%8A%A0%E5%85%89%E6%BA%90%E6%8E%A5%E5%8F%97%E9%98%B4%E5%BD%B1)都有讲过，故下面讲得不会特别详细，同时我也会将 Point Light 和 Spot Light 放在一起讲。

> 精确光源 Punctual Light 表示有明确位置的光源，通常包括 Point Light、Spot Light，但是在有些文献中可能会包括 Directional Light，这就要看该术语使用者对术语的具体定义了。

## CPU 中具体实现
跟 Directional Light 一样，我们首先要设置一个精确光的最大支持数量，这个最大数量是每一帧支持的数量而不是整个场景的，Unity 会将 VisibleLight 按重要性排序，超过最大数量的 VisibleLight 在计算中就会被我们忽略。一帧 64 个精确光源基本已经足够使用了：  

``` C#
private const int m_MaxDirectionalLightCount = 1;
private const int m_MaxPunctualLightCount = 64;
```

然后跟 Directional Light 一样需要传递数据给 GPU，只不过方向光传递方向，精确光传递位置，方向光无衰减，精确光有衰减，这些数据有如下：  

``` C#
private static readonly int m_PunctualLightCountId = Shader.PropertyToID("_PunctualLightCount");
private static readonly int m_PunctualLightColorsId = Shader.PropertyToID("_PunctualLightColors");
private static readonly int m_PunctualLightPositionsId = Shader.PropertyToID("_PunctualLightPositions");
private static readonly int m_SpotLightDirectionsId = Shader.PropertyToID("_SpotLightDirections");
private static readonly int m_SpotLightParamsId = Shader.PropertyToID("_SpotLightParams");

private Vector4[] m_PunctualLightColors = new Vector4[m_MaxPunctualLightCount];
private Vector4[] m_PunctualLightPositions = new Vector4[m_MaxPunctualLightCount];
private Vector4[] m_SpotLightDirections = new Vector4[m_MaxPunctualLightCount];
private Vector4[] m_SpotLightParams = new Vector4[m_MaxPunctualLightCount];
```

①`_PunctualLightCount` 即场景中可见的精确光数量，传递该数据有两个用途：一是减少 Shader 中遍历的次数，不传递就需要遍历 64 次；二是确保精确光打开后又关闭时，遗留在 Constant Buffer 中的数据不影响到场景；  
②`_PunctualLightColors` 和 `_PunctualLightPositions` 就是传递颜色和光源位置。`_PunctualLightPositions.w` 则额外传递了 Light Range 的平方的倒数，这是用来计算 Distance Attenuation 的，后面会讲到；  
③ Spot Light 需要计算 Angle Attenuation，而 Angle Attenuation 的计算需要用到三个参数：光源方向（光源位置减着色点位置）、聚光灯的朝向、聚光灯内外角相关参数。光源方向可以通过 `_PunctualLightPositions` 计算出来，聚光灯的朝向通过 `_SpotLightDirections` 传递，聚光灯内外角相关参数通过 `_SpotLightParams` 传递。  

接下来就是记录上述数据并传递（这里函数名可能会和之前的文章不一样，但逻辑是一样的）：  

``` C#
...
private int m_PunctualLightCount;
...

private void RecordLightData(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    NativeArray<VisibleLight> visibleLights = data.cullingResults.visibleLights;
    ...
    m_PunctualLightCount = 0;
    ...

    for (int i = 0; i < visibleLights.Length; i++)
    {
        VisibleLight visibleLight = visibleLights[i];
        Light light = visibleLight.light;

        if (visibleLight.lightType == LightType.Directional)
        {
          ...
        }
        else if (visibleLight.lightType == LightType.Point)
        {
            if (m_PunctualLightCount >= m_MaxPunctualLightCount) continue;

            m_PunctualLightColors[m_PunctualLightCount] = visibleLight.finalColor;
            Vector4 position = visibleLight.localToWorldMatrix.GetColumn(3);
            position.w = 1.0f / Mathf.Max(visibleLight.range * visibleLight.range, 0.0001f);
            m_PunctualLightPositions[m_PunctualLightCount] = position;
            
            m_SpotLightParams[m_PunctualLightCount] = new Vector4(0.0f, 1.0f);
            
            m_PunctualLightCount++;
        }
        else if (visibleLight.lightType == LightType.Spot)
        {
            if (m_PunctualLightCount >= m_MaxPunctualLightCount) continue;

            m_PunctualLightColors[m_PunctualLightCount] = visibleLight.finalColor;
            Vector4 position = visibleLight.localToWorldMatrix.GetColumn(3);
            position.w = 1.0f / Mathf.Max(visibleLight.range * visibleLight.range, 0.0001f);
            m_PunctualLightPositions[m_PunctualLightCount] = position;

            m_SpotLightDirections[m_PunctualLightCount] = -visibleLight.localToWorldMatrix.GetColumn(2);
            
            float cosInnerAngle = Mathf.Cos(Mathf.Deg2Rad * 0.5f * light.innerSpotAngle);
            float cosOuterAngle = Mathf.Cos(Mathf.Deg2Rad * 0.5f * visibleLight.spotAngle);
            float invAngleRange = 1.0f / Mathf.Max(cosInnerAngle - cosOuterAngle, 0.0001f);
            m_SpotLightParams[m_PunctualLightCount] = new Vector4(invAngleRange, -cosOuterAngle * invAngleRange);
            
            m_PunctualLightCount++;
        }
    }
}

private void DeliverLightData(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    if (m_SunLightCount > 0)
    {
        ...
    }
    
    data.buffer.SetGlobalInt(m_PunctualLightCountId, m_PunctualLightCount);
    if (m_PunctualLightCount > 0)
    {
        data.buffer.SetGlobalVectorArray(m_PunctualLightColorsId, m_PunctualLightColors);
        data.buffer.SetGlobalVectorArray(m_PunctualLightPositionsId, m_PunctualLightPositions);
        data.buffer.SetGlobalVectorArray(m_SpotLightDirectionsId, m_SpotLightDirections);
        data.buffer.SetGlobalVectorArray(m_SpotLightParamsId, m_SpotLightParams);
    }
}
```

①`m_PunctualLightColors` 的获取跟 Directional Light 一样；  
②`m_PunctualLightPositions` 可以通过 localToWorld 矩阵的第四列获取，也就是齐次坐标扩展的那一列。当然也可以通过 `visibleLight.light.transform.position` 获取。至于 w 分量则额外传递计算 Distance Attenuation 所需参数，为什么这么计算详见 GPU 中具体实现小节，或者看之前的文章；  
③`m_SpotLightDirections` 之前的文章有讲过，Spot Light 的默认照明方向是朝着 z 轴正方向照明，所以取模型空间到世界空间的矩阵的第三列，又因为我们需要的是指向光源的方向，所以取反；  
④`m_SpotLightParams` 的 x、y 分量存储计算 Angle Attenuation 所需的聚光灯内外角相关参数，分别是 invAngleRange 和 -cosOuterAngle * invAngleRange，还是详见 GPU 中具体实现小节或者看之前的文章。z、w 分量暂不存储数据。顺便提一下，Point Light 需要将 x、y 分量设置为 0 和 1 以便 Point Light 的 Angle Attenuation 计算出来为 1。  

## GPU 中具体实现
首先在 YPipelineInput.hlsl 中定义上一小节提到的几个变量，与 CPU 传入的参数相匹配：  

    #define MAX_DIRECTIONAL_LIGHT_COUNT 1 // Only Support One Directional Light - Sunlight
    #define MAX_PUNCTUAL_LIGHT_COUNT 64

    CBUFFER_START(DirectLighting)
        // Sun Light
        ...

        // Punctual Lights
        float4 _PunctualLightColors[MAX_PUNCTUAL_LIGHT_COUNT]; // xyz: color * intensity, w: shadow strength
        float4 _PunctualLightPositions[MAX_PUNCTUAL_LIGHT_COUNT]; // xyz: punctual light position, w: 1.0 / punctual light range square
        float4 _SpotLightDirections[MAX_PUNCTUAL_LIGHT_COUNT]; // xyz: spot light direction, w: 0
        float4 _SpotLightParams[MAX_PUNCTUAL_LIGHT_COUNT]; // x: invAngleRange, y: -cosOuterAngle * invAngleRange
        int _PunctualLightCount;
    CBUFFER_END

拿到数据后，就可以计算精确光的光照了，跟方向光一样，使用了相同的结构体 LightParams 来存储用于计算光照模型的参数：  

    struct LightParams
    {
        float3 color;
        float4 positionWS;
        float3 L;
        float3 H;
        float distanceAttenuation;
        float angleAttenuation;
        float shadowAttenuation;
    };

然后初始化这些参数：  

    int GetPunctualLightCount()
    {
        return _PunctualLightCount.x;
    }

    float3 CalculateLightRadiance(LightParams lightParams)
    {
        float3 irradiance = lightParams.color * lightParams.shadowAttenuation * lightParams.distanceAttenuation * lightParams.angleAttenuation;
        return irradiance;
    }

    void InitializePunctualLightParams(out LightParams punctualLightParams, int lightIndex, float3 V, float3 positionWS)
    {
        punctualLightParams.color = _PunctualLightColors[lightIndex].rgb;
        punctualLightParams.positionWS = _PunctualLightPositions[lightIndex];
        
        float3 lightVector = punctualLightParams.positionWS.xyz - positionWS;
        punctualLightParams.L = normalize(lightVector);
        punctualLightParams.H = normalize(punctualLightParams.L + V);
        
        punctualLightParams.distanceAttenuation = GetDistanceAttenuation(lightVector, punctualLightParams.positionWS.w);
        float3 spotDirection = _SpotLightDirections[lightIndex].xyz;
        float2 spotAngleFalloffParams = _SpotLightParams[lightIndex].xy;
        punctualLightParams.angleAttenuation = GetAngleAttenuation(punctualLightParams.L, spotDirection, spotAngleFalloffParams);

        punctualLightParams.shadowAttenuation = 1.0;
    }

`GetDistanceAttenuation()` 和 `GetAngleAttenuation()` 函数分别计算距离衰减和角度衰减，shadowAttenuation 暂时为 1。得到这些计算光照的参数后，就可以在 shader 里循环计算多个精确光了：  

    int punctualLightsCount = GetPunctualLightCount();
    
    for (int i = 0; i < punctualLightsCount; ++i)
    {
        LightParams punctualLightParams = (LightParams) 0;
        InitializePunctualLightParams(punctualLightParams, i, standardPBRParams.V, IN.positionWS);
        
        BRDFParams punctualBRDFParams = (BRDFParams) 0;
        InitializeBRDFParams(punctualBRDFParams, standardPBRParams.N, punctualLightParams.L, standardPBRParams.V, punctualLightParams.H);
        
        renderingEquationContent.directPunctualLights += CalculateLightRadiance(punctualLightParams) * StandardPBR_EnergyCompensation(punctualBRDFParams, standardPBRParams, energyCompensation);
    }

效果如下：  

<div  align="center">  
<img src="https://s2.loli.net/2025/02/13/7FkYItfGdhNlmxB.png" width = "45%" height = "45%" alt="图68 - 左：Point Light；右：Spot Light"/>
</div>

下面我再略微补充一下距离衰减和角度衰减如何计算。

### Distance Attenuation
精确光源都服从 inverse square law，光照强度会和与光线接受者的距离的平方成反比（Irradiance Falloff）。故点光源的反射方程可以写为如下：  

$$ \Phi = \int_{\Omega} I dl = \int_0^{2\pi} \int_0^{\pi} I d\theta d\phi = 4 \pi I $$
$$ L_{out} = f(v,l) \cfrac {\Phi}{4 \pi d^2} n \cdot l = f(v,l) \cfrac {I}{ d^2 } n \cdot l $$

$\,\Phi\,$ 为辐射通量 Luminous/Radiant Power，$\,I\,$ 为辐射强度 Luminous/Radiant Intensity。在实现中，我们一般会将灯光颜色值乘上灯光强度作为辐射强度。但上述公式在实现中也存在问题，光照的影响仍然是无限远的，并且当光线接受者跟灯光接触时，分母会变为 0。为了解决上述问题，需要引入 Light Range/Radius 的概念，用于控制灯光的影响范围，以便对灯光进行剔除。同时 Epic 的 Karis 大佬提出以下公式，保留了大部分 inverse square law 的影响：  

$$ E = \cfrac {I}{max(d^2, 0.01^2)} (1 - \cfrac {d^4}{r^4})^2 $$

$\,E\,$ 为辐射照度 Illuminance/Irradiance，r 为 Light Range/Radius。这个公式和 Unity URP 基础文章中提到的公式是一模一样的，写成代码如下：  

    float GetDistanceAttenuation(float3 lightVector, float invLightRangeSqr) // lightVector is unnormalized light direction(L).
    {
        float distanceSquare = dot(lightVector, lightVector);
        float factor = distanceSquare * invLightRangeSqr;
        float smoothFactor = max(1.0 - factor * factor, 0.0);
        return (smoothFactor * smoothFactor) / max(distanceSquare, 1e-4);
    }

函数参数 `invLightRangeSqr` 就是通过 `_PunctualLightPositions.w` 传递过来的，就是 Light Range/Radius 的平方的倒数：  

``` C#
position.w = 1.0f / Mathf.Max(visibleLight.range * visibleLight.range, 0.0001f);
```

### Angle Attenuation
Spot Light 相对复杂一点，除了距离衰减还有角度衰减。聚光灯除了有一个固定位置，还有一个照明方向和两个光锥角度，$\,\theta_{inner}\,$ 和 $\,\theta_{outer}\,$。照明方向和光锥角度共同定义了角度衰减，如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2025/02/13/1yYGbPwzKudVZRO.png" width = "40%" height = "40%" alt="图69 - Spot Light 示意图"/>
</div>

而聚光灯的 Luminous/Radiant Power 和 Luminous/Radiant Intensity 之间的关系可以写为：  

$$ \Phi = \int_{\Omega} I dl = \int_0^{2\pi} \int_0^{\theta_{outer}} I d\theta d\phi = 2 \pi (1 - cos \cfrac {\theta_{outer}}{2})I $$

$$ I = \cfrac {\Phi} {2 \pi (1 - cos \cfrac {\theta_{outer}}{2})} $$

上述公式虽然物理正确，但是会让艺术家很难使用，因为改变 Outer Angle 的角度就会直接改变光照的亮度，当角度越来越小，亮度就会越来越大。所以在实际实现中，仍然会直接将灯光颜色值乘上灯光强度作为 I，以确保接受光照平面的亮度不会跟着角度变化而变化。当然也可以在计算 Angle Attenuation 的时候考虑上述公式（注意角度 $\,\theta_{outer} / 2\,$ 是边缘到边缘角度的 1/4），我试了以下，控制效果确实不太舒服。

若要确保亮度不受角度影响，聚光灯的反射方程最终可以写为：  

$$ L_{out} = f(v,l) \cfrac {I}{ d^2 } n \cdot l \lambda(l) $$

这个 $\,\lambda(l)\,$ 就是 angle attenuation factor，公式如下：  

$$ \lambda(l) = \cfrac {l \cdot spotDirection - cos \theta_{outer}}{cos \theta_{inner} - cos \theta_{outer}} $$

这个公式和 Unity URP 基础文章中提到的公式也是一模一样的，为了方便数据传递，上述公式也可以写为：  

$$ invAngleRange = \cfrac {1} {cosInnerAngle - cosOuterAngle} $$
$$ angleAttenuation = SdotL * invAngleRange + (-cosOuterAngle * invAngleRange) $$

`invAngleRange` 和 `-cosOuterAngle * invAngleRange` 就是 `_SpotLightParams` 的 x、y 传递的参数：  

``` C#
float cosInnerAngle = Mathf.Cos(Mathf.Deg2Rad * 0.5f * light.innerSpotAngle);
float cosOuterAngle = Mathf.Cos(Mathf.Deg2Rad * 0.5f * visibleLight.spotAngle);
float invAngleRange = 1.0f / Mathf.Max(cosInnerAngle - cosOuterAngle, 0.0001f);
m_SpotLightParams[m_PunctualLightCount] = new Vector4(invAngleRange, -cosOuterAngle * invAngleRange);
```

注意，角度要乘上 0.5，因为获取到的角度是一个光锥边缘到边缘的大角度，我们需要的是光锥边缘到 spotDirection 的角度，上述的所有角度都是光锥边缘到 spotDirection 的角度。最后计算 Angle Attenuation 的函数可以写为如下（将 attenuation 平方处理可以加强效果，比不平方效果好）：  

    float GetAngleAttenuation(float3 L, float3 spotDirection, float2 spotAngleAttenuationParams) // only for spot lights
    {
        float SdotL = dot(spotDirection, L);
        float attenuation = saturate(SdotL * spotAngleAttenuationParams.x + spotAngleAttenuationParams.y);
        return attenuation * attenuation;
    }

Point Light 需要把 `_SpotLightParams` 的 x、y 设置为 0 和 1，这样 Point Light 的 AngleAttenuation 计算出来就为 1.0，使其不受角度衰减影响：  

``` C#
m_SpotLightParams[m_PunctualLightCount] = new Vector4(0.0f, 1.0f);
```

### 配置 Inner Angle
Unity 默认的 Light Inspector 中不存在 inner angle 属性，该属性是在 URP 之后才引入的，默认情况下我们无法调节，需要自定义 GUI，首先在 Custom RP 下的 Editor 文件夹中创建一个 CustomLightEditor 的脚本，继承 `LightEditor` 并覆写 `OnInspectorGUI()` 方法：  

``` C#
using UnityEngine;
using UnityEditor;

[CanEditMultipleObjects]
[CustomEditor(typeof(Light))]
[SupportedOnRenderPipeline(typeof(YRenderPipelineAsset))]
public class YPipelineLightEditor : LightEditor
{
    public override void OnInspectorGUI() 
    {
        base.OnInspectorGUI();
        DrawInnerAndOuterSpotAngle();
    }

    private void DrawInnerAndOuterSpotAngle()
    {
        if (!settings.lightType.hasMultipleDifferentValues && (LightType)settings.lightType.enumValueIndex == LightType.Spot)
        {
            settings.DrawInnerAndOuterSpotAngle();
            settings.ApplyModifiedProperties();
        }
    }
}
```

在函数 `DrawInnerAndOuterSpotAngle()` 中先确认选择的灯光中没有多种灯光类型，且灯光类型为聚光灯。若是，则调用 settings 的 `DrawInnerAndOuterSpotAngle()` 在 Inspector 中增加 inner/outer spot angle 的滑动条。然后，调用 `ApplyModifiedProperties()` 应用滑动条的任何变化。

<div  align="center">  
<img src="https://s2.loli.net/2025/02/13/bzi79GK2dPue5M3.jpg" width = "60%" height = "60%" alt="图70 - 增加的 inner/outer spot angle 滑动条"/>
</div>

# 烘焙精确光
如何支持 Lightmap 系统，之前基本上都已经实现了（精确光 Shadowmask 下的 Mixed 模式还需要再修改部分代码，在第三小节讲），所以将 Light Mode 改为 Baked 就可以烘焙 Point Light 和 Spot Light 了。还有就是，Point Light 和 Spot Light 默认的 Shadow Type 是 No Shadows，要想要烘焙阴影别忘了开启阴影（目前还没支持精确光的实时阴影）。虽然已经可以烘焙了，但是由于 Lightmap 系统的历史遗留问题，烘焙的精确光的光线衰减和我们上一章节的公式是不一样的，这就导致了烘焙的精确光过亮的问题，和我们的实时精确光不匹配，为了解决这个问题，我们需要使用 `UnityEngine.Experimental.GlobalIllumination` 里的 API 对烘焙光照数据进行修改。同时还可以解决之前提到过的，LightMap 系统和我们使用的 PBR 模型在亮度上存在一个 PI 的差异的问题。

## 修改 Lightmap 的光线衰减
为了修改光线衰减，我们需要给 `Lightmapping.RequestLightsDelegate` 委托添加方法去修改，并在 Unity 在编辑器进行烘焙前调用该委托。具体调用我们不需要做，只需要使用 `Lightmapping.SetDelegate(Lightmapping.SetDelegate del)` 传递委托即可。

首先我们可以把我们的 CustomRenderPipeline 类变为 Partial Class，然后在构造函数中调用 `InitializeLightmapper()` 方法传递委托：  

``` C#
public partial class YRenderPipeline : RenderPipeline
{
    ...
    public YRenderPipeline(YRenderPipelineAsset asset)
    {
        ...
#if UNITY_EDITOR
        InitializeLightmapper();
#endif
    }
}
```

然后再创建一个 CustomRenderPipeline.Editor 文件，专门写只在 Editor 中运行的类成员，比如 `Lightmapping.RequestLightsDelegate` 委托（该委托的代码也可以参考 URP 的 Runtime / UniversalRenderPipelineCore.cs 文件），以及上面调用的用于传递该委托的方法 `InitializeLightmapper()`。我们先写委托，这里使用了 lambda 表达式，注意签名匹配，这个方法的主要目的就是将 Light 数组转换为烘焙系统能够使用的 `NativeArray<LightDataGI>` 数据：  

``` C#
using Unity.Collections;
using UnityEngine;
using UnityEngine.Experimental.GlobalIllumination;
using LightType = UnityEngine.LightType;

public partial class YRenderPipeline
{
#if UNITY_EDITOR
    private static Lightmapping.RequestLightsDelegate lightsDelegate = (Light[] lights, NativeArray<LightDataGI> output) => 
    {

    }

    private void InitializeForEditor() {};
#endif
}
```

我们需要配置每盏灯的 LightDataGI 结构体并传递给 output，使用一个循环遍历 Light 数组的所有灯光，默认情况下我们需要调用 `LightDataGI.InitNoBake()` 告诉 Unity 不要烘焙该灯光：  

``` C#
private static Lightmapping.RequestLightsDelegate lightsDelegate = (Light[] lights, NativeArray<LightDataGI> output) => 
{
    LightDataGI lightData = new LightDataGI();
    for (int i = 0; i < lights.Length; i++)
    {
        Light light = lights[i];
        switch(light.type)
        {
            default:
                lightData.InitNoBake(light.GetInstanceID());
                break;
        }
        output[i] = lightData;
    }
}
```

因为 lightData 无法直接获取灯光的数据，我们需要使用 `LightmapperUtils.Extract()` 将 Light 结构的数据传递给专门的结构体，然后调用 `LightDataGI.Init()` 将该结构体数据转换为烘焙系统可以识别的结构体：  

``` C#
switch (light.type)
{
    case LightType.Directional:
        DirectionalLight directionalLight = new DirectionalLight();
        LightmapperUtils.Extract(light, ref directionalLight);
        lightData.Init(ref directionalLight);
        break;
    case LightType.Point:
        PointLight pointLight = new PointLight();
        LightmapperUtils.Extract(light, ref pointLight);
        lightData.Init(ref pointLight);
        break;
    case LightType.Spot:
        SpotLight spotLight = new SpotLight();
        LightmapperUtils.Extract(light, ref spotLight);
        lightData.Init(ref spotLight);
        break;
    case LightType.Rectangle:
        RectangleLight rectangleLight = new RectangleLight();
        LightmapperUtils.Extract(light, ref rectangleLight);
        lightData.Init(ref rectangleLight);
        break;
    default:
        lightData.InitNoBake(light.GetInstanceID());
        break;
}
```

接下来就是修改灯光数据了，首先设置聚光灯的 inner angle 和 angle falloff 模式：  

``` C#
case LightType.Spot:
    SpotLight spotLight = new SpotLight();
    LightmapperUtils.Extract(light, ref spotLight);
    spotLight.innerConeAngle = light.innerSpotAngle * Mathf.Deg2Rad;
    spotLight.angularFalloff = AngularFalloffType.AnalyticAndInnerAngle;
    lightData.Init(ref spotLight);
    break;
```

目前还不支持 Area Light 的实时模式，先强制 Area Light 的模式为烘焙模式：  

``` C#
case LightType.Rectangle:
    RectangleLight rectangleLight = new RectangleLight();
    LightmapperUtils.Extract(light, ref rectangleLight);
    rectangleLight.mode = LightMode.Baked;
    lightData.Init(ref rectangleLight);
    break;
```

然后就是设置所有灯光的 falloff 模式为 `FalloffType.InverseSquared`：  

``` C#
lightData.falloff = FalloffType.InverseSquared;
output[i] = lightData;
```

最后别忘了在 `InitializeLightmapper()` 里使用 `Lightmapping.SetDelegate()` 传递委托：  

``` C#
private void InitializeLightmapper()
{
    Lightmapping.SetDelegate(lightsDelegate);
}
```

当我们修改 RenderPipelineAsset 里的设置时，Unity 会释放当前的 RenderPipelineInstance 并重新创建一个新的 RenderPipelineInstance，这样子会重复 SetDelegate，所以我们要覆写 `Dispose()` 方法，并调用 `Lightmapping.ResetDelegate` 方法重置委托：  

``` C#
protected override void Dispose (bool disposing) 
{
    base.Dispose(disposing);
    Lightmapping.ResetDelegate();
}
```

这样子烘焙光的光线衰减就和实时的是一致的了。

## 修改 Lightmap 和 PBR 的亮度差异
LightMap 系统和我们使用的 PBR 模型在亮度上存在一个 PI 的差异的问题，之前在使用 Mixed 模式烘焙时，为了间接光强度和直接光强度保持一致，是将灯光强度手动除以 PI 后再烘焙的，烘焙完再将强度设置回去，这样操作太麻烦。现在就可以利用上面说的委托来解决了，解决起来也比较简单，将传递给烘焙系统的结构体的光照强度数据除以 PI 即可，还是在委托的匿名方法里：  

``` C#
case LightType.Directional:
    DirectionalLight directionalLight = new DirectionalLight();
    LightmapperUtils.Extract(light, ref directionalLight);
    directionalLight.color.intensity /= Mathf.PI;
    directionalLight.indirectColor.intensity /= Mathf.PI;
    lightData.Init(ref directionalLight);
    break;
case LightType.Point:
    PointLight pointLight = new PointLight();
    LightmapperUtils.Extract(light, ref pointLight);
    pointLight.color.intensity /= Mathf.PI;
    pointLight.indirectColor.intensity /= Mathf.PI;
    lightData.Init(ref pointLight);
    break;
case LightType.Spot:
    SpotLight spotLight = new SpotLight();
    LightmapperUtils.Extract(light, ref spotLight);
    spotLight.color.intensity /= Mathf.PI;
    spotLight.indirectColor.intensity /= Mathf.PI;
    spotLight.innerConeAngle = light.innerSpotAngle * Mathf.Deg2Rad;
    spotLight.angularFalloff = AngularFalloffType.AnalyticAndInnerAngle;
    lightData.Init(ref spotLight);
    break;
```

这样子烘焙亮度和实时亮度就可以保持一致了。

## 精确光的 ShadowMask 烘焙模式
若精确光模式为 Mixed，其阴影也会被烘焙进 Shadow Mask 贴图，就跟方向光一样。Shadow Mask 贴图有四个通道，理论上只能支持 4 盏灯，但是因为精确光的影响范围是有限的，所以有可能多盏精确光会共享一个通道，只要这些精确光的影响范围不重叠，这就意味着 Shadow Mask 贴图的每个纹素至多支持 4 盏灯，若重叠，其余灯光会被强制转换至 Baked 模式。

为了能让 Shader 知道该采样 Shadow Mask 贴图的哪一个通道，我们需要传递通道（之前在方向光的实现中通过  `_SunLightShadowFadeParams.w ` 传递），我将 `_SpotLightParams` 改为了 `_PunctualLightParams`，并将通道数字存储在了 z 通道：  

``` C#
for (int i = 0; i < visibleLights.Length; i++)
{
    ...
    float shadowMaskChannel = -1.0f;
    ...

    ...
    else if (visibleLight.lightType == LightType.Point)
    {
        if (m_PunctualLightCount >= m_MaxPunctualLightCount) continue;

        m_PunctualLightColors[m_PunctualLightCount] = visibleLight.finalColor;
        m_PunctualLightColors[m_PunctualLightCount].w = 0;
        Vector4 position = visibleLight.localToWorldMatrix.GetColumn(3);
        position.w = 1.0f / Mathf.Max(visibleLight.range * visibleLight.range, 0.0001f);
        m_PunctualLightPositions[m_PunctualLightCount] = position;
        
        m_PunctualLightParams[m_PunctualLightCount] = new Vector4(0.0f, 1.0f);

        if (light.shadows != LightShadows.None && light.shadowStrength > 0f)
        {
            m_PunctualLightColors[m_PunctualLightCount].w = light.shadowStrength;
            LightBakingOutput lightBaking = light.bakingOutput;
            if (lightBaking.lightmapBakeType == LightmapBakeType.Mixed && lightBaking.mixedLightingMode == MixedLightingMode.Shadowmask)
            {
                m_UseShadowMask = true;
                shadowMaskChannel = lightBaking.occlusionMaskChannel;
            }
        }

        m_PunctualLightParams[m_PunctualLightCount].z = shadowMaskChannel;
        m_PunctualLightCount++;
    }
    else if (visibleLight.lightType == LightType.Spot)
    {
        if (m_PunctualLightCount >= m_MaxPunctualLightCount) continue;

        m_PunctualLightColors[m_PunctualLightCount] = visibleLight.finalColor;
        m_PunctualLightColors[m_PunctualLightCount].w = 0;
        Vector4 position = visibleLight.localToWorldMatrix.GetColumn(3);
        position.w = 1.0f / Mathf.Max(visibleLight.range * visibleLight.range, 0.0001f);
        m_PunctualLightPositions[m_PunctualLightCount] = position;
        m_SpotLightDirections[m_PunctualLightCount] = -visibleLight.localToWorldMatrix.GetColumn(2);
        
        float cosInnerAngle = Mathf.Cos(Mathf.Deg2Rad * 0.5f * light.innerSpotAngle);
        float cosOuterAngle = Mathf.Cos(Mathf.Deg2Rad * 0.5f * visibleLight.spotAngle);
        float invAngleRange = 1.0f / Mathf.Max(cosInnerAngle - cosOuterAngle, 0.0001f);
        m_PunctualLightParams[m_PunctualLightCount] = new Vector4(invAngleRange, -cosOuterAngle * invAngleRange);
        
        if (light.shadows != LightShadows.None && light.shadowStrength > 0f)
        {
            m_PunctualLightColors[m_PunctualLightCount].w = light.shadowStrength;
            LightBakingOutput lightBaking = light.bakingOutput;
            if (lightBaking.lightmapBakeType == LightmapBakeType.Mixed && lightBaking.mixedLightingMode == MixedLightingMode.Shadowmask)
            {
                m_UseShadowMask = true;
                shadowMaskChannel = lightBaking.occlusionMaskChannel;
            }
        }
        
        m_PunctualLightParams[m_PunctualLightCount].z = shadowMaskChannel;
        m_PunctualLightCount++;
    }
}
```

接下来就是 Shader 里的工作了，因为目前没有实现精确光的实时阴影，先不混合阴影，直接通过传递的通道采样 Shadow Mask 贴图：

    float GetPunctualLightShadowAttenuation(int lightIndex, float2 lightMapUV)
    {
        float shadowStrength = _PunctualLightColors[lightIndex].w;

        #if defined(_SHADOW_MASK_DISTANCE) || defined(_SHADOW_MASK_NORMAL)
            return lerp(1.0, SampleShadowmask(lightMapUV, _PunctualLightParams[lightIndex].z), shadowStrength);
        #else
            return 1.0;
        #endif
    }

然后在 `InitializePunctualLightParams()` 函数中把之前默认 shadowAttenuation 为 1.0，改为使用上述函数：  

    void InitializePunctualLightParams(out LightParams punctualLightParams, int lightIndex, float2 lightMapUV, float3 V, float3 positionWS)
    {
        ...
        punctualLightParams.shadowAttenuation = GetPunctualLightShadowAttenuation(lightIndex, lightMapUV);
    }

这样子 Mixed Mode 的精确光就有烘焙阴影和实时光照了，如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2025/02/14/RfNJvDVKlpyh83e.jpg" width = "50%" height = "50%" alt="图71 - Mixed Mode 下精确光的烘焙阴影"/>
</div>

# Per Object Lights
目前每个像素都会计算所有的可见光，但并非所有可见光的都会影响到某一像素，这就造成了计算浪费。Unity 对此的一种解决方案是使用 per-object light indices，即在 CPU 中判断出某一物体会被哪些光影响，并将该信息传递给 GPU，在 GPU 计算中我们只计算这些能影响到该物体的光。但是这样，光是基于 per-object 而非 per-fragment，对于小型物体来说效果是没问题的，但是对于大型物体来说，因为限制了每个物体能接受多少盏光，这就会导致灯光的缺失。因为这项技术的效果没有这么理想，并且会在一定程度上降低 GPU instancing 的效率，虽然不会影响 SRP batcher，而且 **Tiled Based Rendering** 和 **Clustered Based Rendering** 能更好地完成光照计算浪费的优化（之后肯定要实现的），所以我不会在自己的管线中支持 per-object light indices，下面只是简单记录如何实现：  

## 传递 Per-Object LightData
首先我们要在 XXRenderPipelineAsset 里添加字段 `enablePerObjectLights` 用于配置是否开启 Per-Object Lights：  

``` C#
public class XXRenderPipelineAsset : RenderPipelineAsset
{
    public bool enablePerObjectLights = false;
}
```

然后在 `DrawingSettings` 里根据字段激活 `PerObjectData.LightData` 和 `PerObjectData.LightIndices`：

``` C#
private void RenderOpaque(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    PerObjectData lightsPerObjectFlags = asset.enablePerObjectLights ?
			PerObjectData.LightData | PerObjectData.LightIndices :
			PerObjectData.None;
    ...
    DrawingSettings opaqueDrawing = new DrawingSettings(m_ForwardLitShaderTagId, opaqueSorting)
    {
        enableInstancing = asset.enableGPUInstancing,
        perObjectData = PerObjectData.ReflectionProbes | PerObjectData.Lightmaps | PerObjectData.ShadowMask | PerObjectData.LightProbe | PerObjectData.OcclusionProbe | lightsPerObjectFlags
    };
    ...
}
```

## 清理 Light Indices 列表
Unity 的 `CullingResults.GetLightIndexMap` 会创建一个所有激活的灯光索引的列表，并按他们的重要性排序。这个列表无视灯光的可见性，也包含方向光，所以我们需要对这个列表进行清理，让它只包含可见非方向光的索引。首先我们在遍历所有可见光的函数中，在遍历前先获取该列表：  

``` C#
private void RecordLightData(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    NativeArray<int> indexMap = asset.enablePerObjectLights ? cullingResults.GetLightIndexMap(Allocator.Temp) : default;
    NativeArray<VisibleLight> visibleLights = data.cullingResults.visibleLights;
    ...
}
```

对于所有可见光，我们只需要精确光的索引，其他光应该被略过。并将其他可见光的索引改为 -1，精确光的索引重新排序：  

``` C#
for (int i = 0; i < visibleLights.Length; i++)
{
    int newIndex = -1;
    VisibleLight visibleLight = visibleLights[i];
    Light light = visibleLight.light;
    ...

    if (visibleLight.lightType == LightType.Directional)
    {
        ...
    }
    else if (visibleLight.lightType == LightType.Point)
    {
        if (m_PunctualLightCount >= m_MaxPunctualLightCount) continue;
        newIndex = m_PunctualLightCount;
        ...
        m_PunctualLightCount++;
    }
    else if (visibleLight.lightType == LightType.Spot)
    {
        if (m_PunctualLightCount >= m_MaxPunctualLightCount) continue;
        newIndex = otherLightCount;
        ...
        m_PunctualLightCount++;
    }

    if (asset.enablePerObjectLights) 
    {
        indexMap[i] = newIndex;
    }
}
```

同时，我们还需设置所有不可见光的索引为 -1，当可见光的列表遍历完，再继续遍历。设置完后，需要将修改好的列表传递回 Unity，通过调用 `CullingResults.SetLightIndexMap()` 传递。最后需要一个 shader keyword 来控制 Shader 是否使用 Per-Object LightData：  

``` C#
private const string m_PerObjectLights = "_PER_OBJECT_LIGHTS";
private static GlobalKeyword _PerObjectLights = GlobalKeyword.Create(m_PerObjectLights);
...
    int i;
    for (i = 0; i < visibleLights.Length; i++) 
    {
        ...
    }

    if (asset.enablePerObjectLights) 
    {
        for (; i < indexMap.Length; i++) 
        {
            indexMap[i] = -1;
        }
        cullingResults.SetLightIndexMap(indexMap);
        indexMap.Dispose();
        Shader.EnableKeyword(_PerObjectLights);
    }
    else
    {
        Shader.DisableKeyword(_PerObjectLights);
    }
```

## 使用 Light Indices
接下来就是 Shader 里的工作了，首先设置关键字：  

    #pragma multi_compile _ _PER_OBJECT_LIGHTS

LightData 和 LightIndices 是通过 `unity_LightData` 和 `unity_LightIndices` 传递的，是 UnityPerDraw cbuffer 中数据的一部分，一定要放在 `unity_WorldTransformParams` 后面。`unity_LightData` 的 y 分量存储的是灯的数量；`unity_LightIndices` 是一个长度为 2 的数组，一共 8 个分量存储的是灯光索引，所以最多支持 8 盏灯光 per object：  

    CBUFFER_START(UnityPerDraw)
        ...
        float4 unity_WorldTransformParams;
        
        float4 unity_LightData;
        float4 unity_LightIndices[2];
        ...
    CBUFFER_END

然后实现方法就跟之前 URP 是一样的了，首先灯光数量在 `unity_LightData.y`，对于该物体的可见光的索引在 `unity_LightIndices` 里：  

    int GetPunctualLightCount_PerObjectLights()
    {
        return int(min(_PunctualLightCount, unity_LightData.y));
    }

    int GetPunctualLightIndex(uint loopIndex)
    {
        float4 indices = unity_LightIndices[loopIndex / 4];
        return int(indices[loopIndex % 4]);
    }

然后在 Shader 中遍历所有精确光计算：

    #if defined(_LIGHTS_PER_OBJECT)
        int punctualLightsCount = GetPunctualLightCount_PerObjectLights();
        for (int i = 0; i < punctualLightsCount; ++i)
        {
            int lightIndex = GetPunctualLightIndex(i);
            LightParams punctualLightParams = (LightParams) 0;
            InitializePunctualLightParams(punctualLightParams, lightIndex, standardPBRParams.V, IN.positionWS);
            
            ...
        }
    #else
        ...
    #endif

这样就可以实现 Per Object Lights 了。


# Punctual Light Shadows
之前的方向光阴影是通过 texture atlas 实现的，我后来改为了 texture array，虽然没有在文章中记录。这里精确光阴影的实现也将通过 texture array，只不过聚光灯通过 Texture2DArray，点光源通过 TextureCubeArray，故会和教程会不太一样，但整体逻辑是一样的。聚光灯是朝一个方向以 Outer angle 为 FOV 进行拍照记录深度，而点光源是朝上下左右前后 6 个方向以 90 度 FOV 进行拍照记录深度，所以一个采用 Texture2D，一个采用 TextureCube（当然点光源使用 Texture2DArray 替代 TextureCube 也可以，只不过 Texture2DArray 无法对面与面的接缝处进行 bilinear 采样）。

因为聚光灯和点光源的阴影是通过两个不同的纹理实现的，而之前遍历精确光进行光照计算是不区分聚光灯和点光源的，这就产生了冲突，因为利用一个参数记录精确光的类型，再使用 if 分支对阴影贴图进行采样比较蠢，所以我干脆将聚光灯和点光源的光照计算也分开了，也就改变了一些本篇文章最上面的章节 Punctual Lights 的代码，因为逻辑真的没有特别大的变化，我就不做记录了。下面只记录聚光灯和点光源的阴影实现，重要的是逻辑，方法都是可以修改的。

> 我查看了微软的文档里面说：Texture2DArray and TextureCubeArray are available in Shader Model 4.1 or higher，Shader Model 4.1 is available in Direct3D 10.1 or higher。即在 Unity Shader 中对应 `#pragma target 4.5`。DirectX 11 是 2009 年发布的，GTX 470 是首代支持 DX11/Shader Model 5.0 的，所以不用特别担心 Texture2DArray 和 TextureCubeArray 在显卡中的支持问题。

## Spot Light Shadows
### CPU 中具体实现
我设置了最大支持的聚光灯数量为 64，最大支持的可投射阴影的聚光灯数量为 32：  

``` C#
private const int k_MaxSpotLightCount = 64;
private const int k_MaxShadowingSpotLightCount = 32;
```

而需要向 GPU 传递的数据有如下，我又将数据分为了 per setting 和 per frame 的数据，per setting 就是每次在 RenderPipelineAsset 设置改变一次传递一次的数据，因为这些数据不会在游戏运行时改变，我就专门用一个 CBuffer 存储。而每帧都需要变化的数据，就是 per frame 数据，用另外一个 CBuffer 存储：  

``` C#
// Global Params Per Setting
...
private static readonly int k_PunctualLightShadowSettingsID = Shader.PropertyToID("_PunctualLightShadowSettings");

// Spot Light Params Per Frame
private static readonly int k_PunctualLightCountId = Shader.PropertyToID("_PunctualLightCount");

private static readonly int k_SpotLightShadowArrayID = Shader.PropertyToID("_SpotLightShadowArray");
private static readonly int k_SpotLightColorsId = Shader.PropertyToID("_SpotLightColors");
private static readonly int k_SpotLightPositionsId = Shader.PropertyToID("_SpotLightPositions");
private static readonly int k_SpotLightDirectionsId = Shader.PropertyToID("_SpotLightDirections");
private static readonly int k_SpotLightParamsId = Shader.PropertyToID("_SpotLightParams");
private static readonly int k_SpotLightShadowMatricesID = Shader.PropertyToID("_SpotLightShadowMatrices");

...

private int m_SpotLightCount;
private int m_ShadowingSpotLightCount;
private Vector4[] m_SpotLightColors = new Vector4[k_MaxSpotLightCount];
private Vector4[] m_SpotLightPositions = new Vector4[k_MaxSpotLightCount];
private Vector4[] m_SpotLightDirections = new Vector4[k_MaxSpotLightCount];
private Vector4[] m_SpotLightParams = new Vector4[k_MaxSpotLightCount];
private Matrix4x4[] m_SpotLightShadowMatrices = new Matrix4x4[k_MaxShadowingSpotLightCount];
private int[] m_ShadowingSpotLightIndices = = new int[k_MaxShadowingSpotLightCount]; // store shadowing spot light visible light index
```

①`_PunctualLightShadowSettings`：x 分量为 shadow map size，y 分量为 sample number，z 分量为 penumbra width, w 分量为 0。这些数据都是用于计算 PCF 的；  
②`_PunctualLightCount`：x 分量为 spot light count，y 分量为 point light count；  
③`_SpotLightParams`：x 分量为 1.0 / spot light radius square，y 分量为 invAngleRange，z 分量为 cosOuterAngle, w 分量为 shadowing spot light index。xyz 分量在光照实现中都讲过。w 分量有两个用途：一是用来索引 `_SpotLightShadowMatrices` 的，因为光源阴影矩阵只存储了最大可投射阴影的数量，其他参数都存储了最大支持的灯数量，在 Shader 中遍历计算时需要一个参数来获取到当前灯光对应的光源阴影矩阵，当然也可以将光源阴影矩阵的数量设置为最大支持的灯数量，这样就不需要这个额外参数了，直接遍历的时候用 i 获取矩阵就行；二是用于不投射阴影的聚光灯跳过阴影计算，我会将不投射阴影的聚光灯的 w 分量设置为 -1；  
④`_SpotLightShadowMatrices` 就不用说了，就是光源 VP 矩阵；  
⑤ Shader Property ID 下面的参数都是用于存储数据，方便我们向 GPU 传递数据。`m_SpotLightCount` 记录场景中有多少个聚光灯， `m_ShadowingSpotLightCount` 记录场景中有多少个可投射阴影的聚光灯，Colors、Positions、Directions、Params 和 ShadowMatrices 就不用多说了。`m_ShadowingSpotLightIndices` 是记录可投射阴影的聚光灯对应的 Visible Light Index 的，这个数据不用传递给 GPU，但是后面绘制阴影贴图时的 `ShadowDrawingSettings` 和 `cullingResults.ComputeSpotShadowMatricesAndCullingPrimitives` 需要使用。

***一、记录 `_SpotLightParams.w`***  
还是在 `RecordLightData()` 函数中做这件事：  

``` C#
private void RecordLightData(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    NativeArray<VisibleLight> visibleLights = data.cullingResults.visibleLights;
    ...
    m_SpotLightCount = 0;
    m_ShadowingSpotLightCount = 0;
    ...
    for (int i = 0; i < visibleLights.Length; i++)
    {
        VisibleLight visibleLight = visibleLights[i];
        Light light = visibleLight.light;
        ...
        if (visibleLight.lightType == LightType.Directional) {...}
        else if (visibleLight.lightType == LightType.Spot)
        {
            if (m_SpotLightCount >= k_MaxSpotLightCount) continue;

            ... // 记录计算光照所需参数
            m_SpotLightParams[m_SpotLightCount] = new Vector4(invRadiusSquare, invAngleRange, cosOuterAngle, -1.0f);

            if (light.shadows != LightShadows.None && light.shadowStrength > 0f)
            {
                if (data.cullingResults.GetShadowCasterBounds(i, out Bounds outBounds) && m_ShadowingSpotLightCount <= k_MaxShadowingSpotLightCount)
                {
                    m_SpotLightParams[m_SpotLightCount].w = m_ShadowingSpotLightCount;
                    m_ShadowingSpotLightIndices[m_ShadowingSpotLightCount] = i;
                    m_ShadowingSpotLightCount++;
                }
                
                m_SpotLightColors[m_SpotLightCount].w = light.shadowStrength;
                
                ... // 设置 ShadowMask
            }
            m_SpotLightPositions[m_SpotLightCount].w = shadowMaskChannel;
            m_SpotLightCount++;
        }
    }
}
```

可投射阴影聚光灯的 index，即 `_SpotLightParams.w`，默认为 -1，这样做的目的是让不投射阴影的聚光灯跳过阴影计算。然后判断聚光灯是否能影响到开启了阴影投射的物体以及已经记录的可投射阴影聚光灯是否还没超过最大支持数量，若都是，则记录下当前可投射阴影聚光灯的 index 以及它在 Visible Light 的 Index。传递参数的工作我就不做记录了。

***二、创建 Shadow Array***  

``` C#
private void CreateAndRenderPunctualLightShadowArray(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    if (m_ShadowingSpotLightCount > 0)
    {
        data.buffer.GetTemporaryRTArray(k_SpotLightShadowArrayID, asset.punctualLightShadowArraySize, asset.punctualLightShadowArraySize, m_ShadowingSpotLightCount, 32, FilterMode.Bilinear, RenderTextureFormat.Shadowmap);
        RenderSpotLightShadowArray(asset,ref data);
    }
    else
    {
        data.buffer.GetTemporaryRTArray(k_SpotLightShadowArrayID, 1, 1
            ,1, 32, FilterMode.Bilinear, RenderTextureFormat.Shadowmap);
    }
}
```

这里和方向光没什么大区别，只是换为了 `CommandBuffer.GetTemporaryRTArray()` API，参数详见官方文档，最后别忘了 `ReleaseTemporaryRT` 就行。

***三、渲染至 Shadow Array***  

``` C#
private void RenderSpotLightShadowArray(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    for (int i = 0; i < m_ShadowingSpotLightCount; i++)
    {
        ShadowDrawingSettings shadowDrawingSettings = new ShadowDrawingSettings(data.cullingResults, m_ShadowingSpotLightIndices[i]);
        data.cullingResults.ComputeSpotShadowMatricesAndCullingPrimitives(m_ShadowingSpotLightIndices[i], out Matrix4x4 viewMatrix, out Matrix4x4 projectionMatrix, out ShadowSplitData splitData);
        shadowDrawingSettings.splitData = splitData;
        
        m_SpotLightShadowMatrices[i] = ShadowUtility.GetWorldToLightScreenMatrix(projectionMatrix * viewMatrix);
        
        data.buffer.SetViewProjectionMatrices(viewMatrix, projectionMatrix);
        data.buffer.SetRenderTarget(new RenderTargetIdentifier(k_SpotLightShadowArrayID, 0, CubemapFace.Unknown, i), RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);
        data.buffer.ClearRenderTarget(true, false, Color.clear);
        RendererList shadowRendererList = data.context.CreateShadowRendererList(ref shadowDrawingSettings);
        data.buffer.DrawRendererList(shadowRendererList);
    }
}
```

这个函数就是遍历场景中可投射阴影的聚光灯，将每一个可投射阴影聚光灯渲染至 Shadow Array 的 Slice。`ShadowDrawingSettings` 和 `ComputeSpotShadowMatricesAndCullingPrimitives` 之前说过要传入当前可投射阴影聚光灯的 Visible Light Index。后面和方向光阴影的实现区别不大，只是我们要在每次遍历时都设置一次 RenderTarget，对应 Shadow Array 的每一个 Slice，并 ClearRenderTarget，然后再绘制。最后别忘了传递 `_SpotLightShadowMatrices`，代码就不放出了。

### GPU 中具体实现
先在 CBuffer 里定义变量和 Shadow Array 以接受数据：  

    #define MAX_SPOT_LIGHT_COUNT                64
    #define MAX_SHADOWING_SPOT_LIGHT_COUNT      32

    CBUFFER_START(LightParamsPerSetting)
        ...
        float4 _PunctualLightShadowSettings; // x: shadow map size, y: sample number, z: penumbra width, w: 0
    CBUFFER_END

    CBUFFER_START(LightParamsPerFrame)
        ...
        float4 _PunctualLightCount; // x: spot light count, y: point light count, z: 0, w: 0
        float4 _SpotLightColors[MAX_SPOT_LIGHT_COUNT]; // xyz: color * intensity, w: shadow strength
        float4 _SpotLightPositions[MAX_SPOT_LIGHT_COUNT]; // xyz: spot light position, w: shadow mask channel
        float4 _SpotLightDirections[MAX_SPOT_LIGHT_COUNT]; // xyz: spot light direction, w: 0
        float4 _SpotLightParams[MAX_SPOT_LIGHT_COUNT]; // x: 1.0 / spot light radius square, y: invAngleRange, z: cosOuterAngle, w: shadowing spot light index
        float4x4 _SpotLightShadowMatrices[MAX_SHADOWING_SPOT_LIGHT_COUNT];
        ...
    CBUFFER_END

    ...
    #define SPOT_LIGHT_SHADOW_ARRAY         _SpotLightShadowArray
    #define SHADOW_SAMPLER                  sampler_PointClampCompare
    TEXTURE2D_ARRAY_SHADOW(SPOT_LIGHT_SHADOW_ARRAY);

然后就是阴影采样了，步骤和之前方向光的阴影区别不大，但特别需要注意的是，获取阴影贴图坐标的计算方式发生了细微变化，就是要多一次**透视除法 perspective division**，因为之前方向光是平行投影，无需做透视除法，之前讲解实现原理的时候也提过一嘴，但是 Point Light 和 Spot Light 都是透视投影，所以在计算阴影贴图的 uv 坐标时要除以 w 分量（w 分量不会受到我们更改了 vp 矩阵而受到影响，可以回去看看方向光阴影实现里的矩阵说明），代码如下：  

    float3 TransformWorldToSpotLightShadowCoord(float3 positionWS, int shadowingLightIndex)
    {
        // SS: shadow space
        float4 positionSS_BeforeDivision = mul(_SpotLightShadowMatrices[shadowingLightIndex], float4(positionWS, 1.0));
        float3 positionSS = positionSS_BeforeDivision.xyz / positionSS_BeforeDivision.w;
        return positionSS;
    }

然后就可以采样 Shadow Array 了：  

    float SampleShadowArray_Compare(float3 positionSS, float elementIndex, TEXTURE2D_ARRAY_SHADOW(shadowMap), SAMPLER_CMP(shadowMapSampler))
    {
        float shadowAttenuation = SAMPLE_TEXTURE2D_ARRAY_SHADOW(shadowMap, shadowMapSampler, positionSS, elementIndex);
        return shadowAttenuation;
    }

    float GetSpotLightShadowAttenuation(int lightIndex, float2 lightMapUV, float3 positionWS)
    {
        float shadowStrength = _SpotLightColors[lightIndex].w;
        float shadowingSpotLightIndex = _SpotLightParams[lightIndex].w;
        float3 positionSS = TransformWorldToSpotLightShadowCoord(positionWS, shadowingSpotLightIndex);
        float shadowAttenuation = SampleShadowArray_Compare(positionSS, shadowingSpotLightIndex, SPOT_LIGHT_SHADOW_ARRAY, SHADOW_SAMPLER);
        return lerp(1.0, shadowAttenuation, shadowStrength);
    }

然后就可以在 `InitializeSpotLightParams()` 函数中将 punctualLightParams.shadowAttenuation 的计算补上了，因为阴影的计算特别耗费性能，特别是实现了 PCF 或者 PCSS 后，因为要采样贴图多次，所以最好尽可能地跳过阴影计算，比如 distanceAttenuation 和 spotLightParams.angleAttenuation 都已经为 0 了，此时 shadowAttenuation 计算为多少都一样，此时可以跳过阴影计算。还有就是 `_SpotLightParams[lightIndex].w` 为 -1 时，之前已经说过，即为不投射阴影的聚光灯时，跳过阴影计算。

    void InitializeSpotLightParams(out LightParams spotLightParams, int lightIndex, float2 lightMapUV, float3 V, float3 normalWS, float3 positionWS)
    {
        ...
        [branch]
        if (spotLightParams.distanceAttenuation * spotLightParams.angleAttenuation <= 0.0 || _SpotLightParams[lightIndex].w < 0.0)
        {
            spotLightParams.shadowAttenuation = 1.0;
        }
        else
        {
            spotLightParams.shadowAttenuation = GetSpotLightShadowAttenuation(lightIndex, lightMapUV, positionWS);
        }
    }

这样子就可以渲染出阴影了，只不过还是有很多阴影质量问题，因为我们没做 Shadow Bias 和 PCF，如下：  

<div  align="center">  
<img src="https://s2.loli.net/2025/02/20/RSO6omaGE49XWZr.png" width = "40%" height = "40%" alt="图72 - 充满阴影质量问题的聚光灯阴影"/>
</div>

### Shadow Bias 和 PCF
PCF 其实和方向光的实现没有区别，直接用方向光里使用的 PCF 函数即可，重点是 Shadow Bias。计算 Shadow Bias 首先要计算阴影贴图的一个纹素在世界空间下的大小，即 texelSize。方向光计算 texelSize 相对容易，因为方向光是正交投影，通过投影矩阵的 $\,m_{00}\,$ 分量，或者 culling sphere 的半径都可以获得阴影贴图在世界空间的大小，除以贴图的分辨率即一个纹素在世界空间下的大小。但是聚光灯的视锥体是个梯形体，一个纹素在世界空间下的大小是由它相对于灯光的线性深度决定的，公式如下：  

$$ texel Size = \cfrac {2 * Linear Depth * tan \cfrac {FOV}{2}} {shadowMapSize} $$

Linear Depth 可以直接通过着色点的世界坐标 positionWS 经过光源 vp 矩阵转换后的 w 分量获取；$\,\frac {FOV} {2}\,$ 就是聚光灯的 outerAngle（注意我们传递 outerAngle 时已经除以 2 过了），就是 `_SpotLightParams` 的 z 分量（这个分量被我修改为 cosOuterAngle 了，之前传递的是 -cosOuterAngle * invAngleRange，所以计算 AngleAttenuation 的函数也修改了）。当然 $\,\frac {FOV} {2}\,$ 也可以通过投影矩阵的 $\,m_{00}\,$ 分量的倒数获取，只不过这就需要额外传递参数了。

> 教程里提到 Linear Depth 还有更方便的计算方式，我当时没想到，就是 lightVector 和 `_SpotLightDirection` 点乘的绝对值，lightVector 是光源世界空间坐标减去着色点世界空间坐标，即未归一化的 L。`_SpotLightDirection` 是被归一化过的，故点乘就是 Linear Depth。我这里代码没改为这种更方便的方式，建议更改。

texelSize 这样就可以计算了，另外还需要计算半影宽度 penumbraWidth，之前方向光也说过，PCF 会加剧自阴影现象，需要将偏移值额外增加半影宽度的长度，代码如下：  

> 关于 Punctual Light 的 Shadow Bias 有一点需要额外提到的是 L 的方向。之前方向光只有一个方向，并且方向光的方向和阴影贴图是垂直的。但是现在 Punctual Light 有两个方向，阴影贴图垂直的方向（对于 Spot Light 来说就是 `_SpotLightDirection`），以及着色点到光源的方向（L）。从理论上来说，应该选用阴影贴图垂直的方向，但是我实际实验下来，使用阴影贴图垂直的方向，调整聚光灯方向到一些特殊角度会出现阴影错误，怎么调整 Shadow Bias 都不能很好地解决，最终还是选用了着色点到光源的方向（L）。

    float3 ApplyShadowBias(float3 positionWS, float texelSize, float penumbraWidth,  float3 normalWS, float3 L)
    {
        float cosTheta = saturate(dot(normalWS, L));
        float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
        float tanTheta = clamp(sinTheta / cosTheta, 0.0, 50.0); // maxBias

        float3 depthBias = texelSize * (1.0 + penumbraWidth) * _ShadowBias.x * L;
        float3 scaledDepthBias = texelSize * (1.0 + penumbraWidth) * tanTheta * _ShadowBias.y * L;
        float3 normalBias = texelSize * (1.0 + penumbraWidth) * _ShadowBias.z * normalWS;
        float3 scaledNormalBias = texelSize * (1.0 + penumbraWidth) * sinTheta * _ShadowBias.w * normalWS;
        
        return positionWS + depthBias + scaledDepthBias + normalBias + scaledNormalBias;
    }

但是我们是希望半影宽度自适应变化的，之前方向光是不想让半影宽度跟着不同级联阴影的不同纹素大小的变化而变化，所以将半影宽度除以了 texelSize 以剔除影响，但是聚光灯这里这样操作就会导致一个问题，就是无论怎么移动聚光灯，阴影的半影宽度是不会变的，这不是我们想要的结果，我们希望半影宽度不随着 shadowMapSize 的变化而变化，但随着距离光源的深度的变化而变化，计算如下代码注释：  

> 这样子处理半影宽度后，基本上半影宽度相对光源距离的变化和 Unty URP 的效果很接近了。但是这种效果从理论上来说是错误的，要想获得更好的半影宽度的效果，还是得实现 PCSS，对于 PCSS 的实现我放在了在后面一篇文章中。

    //float penumbraWidth = GetPunctualLightShadowPenumbraWidth() / texelSize * 2.0 * ComputeTanHalfFOV(lightIndex) * linearDepth;
    float penumbraWidth = GetPunctualLightShadowPenumbraWidth() * GetPunctualLightShadowArraySize();

所以半影宽度相当于乘以了 shadowMapSize，而在 PCF 中我们对 uv 偏移时，除以了 shadowMapSize，一乘一除抵消掉了，所以剔除了 shadowMapSize 的影响，所有代码如下：  

    float ApplyPCF(float index, TEXTURE2D_ARRAY_SHADOW(shadowMap), float shadowArraySize, float sampleNumber, float penumbra, float3 positionWS, float3 positionSS)
    {
        uint hash1 = Hash_Jenkins(asuint(positionWS));
        uint hash2 = Hash_Jenkins(asuint(positionSS));
        float random = floatConstruct(hash1);
        float randomRadian = random * TWO_PI;
        float2x2 rotation = float2x2(cos(randomRadian), -sin(randomRadian), sin(randomRadian), cos(randomRadian));
        
        float shadowAttenuation = 0.0;
        for (float i = 0; i < sampleNumber; i++)
        {
            float2 offset = mul(rotation, InverseSampleCircle(Sobol_Scrambled(i, hash1, hash2))) / shadowArraySize;
            offset = offset * penumbra;
            float2 uv = positionSS.xy + offset;
            shadowAttenuation += SampleShadowArray_Compare(float3(uv, positionSS.z), index, shadowMap, SHADOW_SAMPLER);
        }
        return shadowAttenuation / sampleNumber;
    }

    float GetSpotLightShadowAttenuation(int lightIndex, float2 lightMapUV, float3 positionWS, float3 normalWS, float3 L)
    {
        float shadowStrength = GetSpotLightShadowStrength(lightIndex);
        float shadowingSpotLightIndex = GetShadowingSpotLightIndex(lightIndex);
        float linearDepth = mul(GetSpotLightShadowMatrix(shadowingSpotLightIndex), float4(positionWS, 1.0)).w;
        float texelSize = 2.0 * ComputeTanHalfFOV(lightIndex) * linearDepth / GetPunctualLightShadowArraySize();
        float penumbraWidth = GetPunctualLightShadowPenumbraWidth() * GetPunctualLightShadowArraySize();

        float3 positionWS_Bias = ApplyShadowBias(positionWS, texelSize, penumbraWidth, normalWS, L);
        float3 positionSS = TransformWorldToSpotLightShadowCoord(positionWS_Bias, shadowingSpotLightIndex);
        float shadowAttenuation = ApplyPCF(shadowingSpotLightIndex, SPOT_LIGHT_SHADOW_ARRAY, GetPunctualLightShadowArraySize(), GetPunctualLightShadowSampleNumber(), penumbraWidth, positionWS, positionSS);
        return lerp(1.0, shadowAttenuation, shadowStrength);
    }

额外提一下，这样子计算会使方向光和聚光灯的 PenumbraWidth 在数值单位上存在差异，所以我在传递时会额外乘上一个固定数值：  

``` C#
buffer.SetGlobalVector(k_SunLightShadowSettingsID, new Vector4(asset.sunLightShadowArraySize, asset.sunLightShadowSampleNumber, asset.sunLightPenumbraWidth * 0.02f, 0.0f)); 
buffer.SetGlobalVector(k_PunctualLightShadowSettingsID, new Vector4(asset.punctualLightShadowArraySize, asset.punctualLightShadowSampleNumber, asset.punctualLightPenumbra * 0.004f, 0.0f));
```

最终聚光灯的阴影效果如下：  

<div  align="center">  
<img src="https://s2.loli.net/2025/02/21/suxfiJYNMQHZlFT.png" width = "60%" height = "60%" alt="图73 - 聚光灯阴影，半影随着距离的增大而增大"/>
</div>

### No Pancaking
现在聚光灯还存在一个问题，会漏光，如下：  

<div  align="center">  
<img src="https://s2.loli.net/2025/02/21/8qD34fiupQlWBR9.jpg" width = "30%" height = "30%" alt="图74 - 开启了  pancaking 导致的漏光问题"/>
</div>

产生这个现象的原因是，之前处理方向光的 Shadow pancaking 问题时，在 ShadowCaster pass 中的顶点着色器改变了裁切空间中的深度值：  

    #if UNITY_REVERSED_Z
        OUT.positionHCS.z = min(OUT.positionHCS.z, OUT.positionHCS.w * UNITY_NEAR_CLIP_VALUE);
    #else
        OUT.positionHCS.z = max(OUT.positionHCS.z, OUT.positionHCS.w * UNITY_NEAR_CLIP_VALUE);
    #endif

我们知道 Shadow pancaking 产生的原因是，较长的物体超过了光源视锥体的范围从而在渲染阴影贴图时被裁切掉了，所以我们让顶点深度不得小于近裁切平面的深度，以防止被裁切。但是现在是聚光灯，较长的物体超过了光源视锥体的范围的部分不会被灯光所影响，此时再将顶点深度改为近裁切平面的深度会影响到顶点插值计算像素深度的值，导致上图中墙下面的 4 个顶点深度是正常深度，上面的 4 个顶点的深度因为比光源近裁切平面深度更浅，被设置到了光源近裁切平面，这就导致墙的每个像素的深度都更深了，这就会产生漏光现象。解决方法朴实无华，就是取消改变裁切空间中的深度值的操作。我们需要传递一个向量用于区分什么时候需要，什么时候不需要：  

``` C#
// Params Per Shadow Caster
private static readonly int k_ShadowPancakingId = Shader.PropertyToID("_ShadowPancaking");
```

注意这个参数是每次绘制阴影贴图时就传递一次的，即在一帧内会传递多次：  

``` C#
private void RenderSunLightShadowArray(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    data.buffer.SetGlobalFloat(k_ShadowPancakingId, 0.0f);
    ...
}

private void RenderSpotLightShadowArray(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    data.buffer.SetGlobalFloat(k_ShadowPancakingId, 0.0f);
    ...
}
```

然后改一下 ShadowCaster pass 中的顶点着色器就可以了：  

    ...
    CBUFFER_START(PerShadowDraw)
        float _ShadowPancaking;
    CBUFFER_END
    ...
    Varyings ShadowCasterVert(Attributes IN)
    {
        Varyings OUT;
        OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);

        #if UNITY_REVERSED_Z
            float clamped = min(OUT.positionHCS.z, OUT.positionHCS.w * UNITY_NEAR_CLIP_VALUE);
        #else
            float clamped = max(OUT.positionHCS.z, OUT.positionHCS.w * UNITY_NEAR_CLIP_VALUE);
        #endif

        OUT.positionHCS.z = lerp(OUT.positionHCS.z, clamped, _ShadowPancaking);
        
        return OUT;
    }
    ...

### 其他
教程中还提到了一个问题，因为聚光灯渲染阴影的视锥体是紧贴着光锥体的，所以使用 PCF 和 Shadow Bias 会导致采样到 Shadow Atlas 的其他 tile 上去，从而错误采样到了其他灯的阴影。但是因为我们使用的是 Shadow Array 所以不存在这样的问题，只不过会导致阴影贴近光锥体边缘时阴影范围略微变大的问题，但这个现象只有 outerAngle 和 innerAngle 特别接近时才会较为明显，在实际使用中一般不会将 outerAngle 和 innerAngle 设置为一致，故无需处理。我这里也不摘抄 Shadow Atlas 对此的处理方法了。

## Point Light Shadows
点光源相当于 6 盏 FOV 为 90 度的聚光灯，所以逻辑上和聚光灯几乎没什么区别，只是因为阴影贴图是 TextureCubeArray 的缘故，在代码实现上有些许区别。

### CPU 中具体实现
首先是最大支持数量，以及要向 GPU 传递的数据：  

``` C#
private const int k_MaxPointLightCount = 32;
private const int k_MaxShadowingPointLightCount = 8;

private static readonly int k_PointLightShadowMapID = Shader.PropertyToID("_PointLightShadowMap");
private static readonly int k_PointLightColorsId = Shader.PropertyToID("_PointLightColors");
private static readonly int k_PointLightPositionsId = Shader.PropertyToID("_PointLightPositions");
private static readonly int k_PointLightParamsId = Shader.PropertyToID("_PointLightParams");
private static readonly int k_PointLightShadowMatricesID = Shader.PropertyToID("_PointLightShadowMatrices");

private int m_PointLightCount;
private int m_ShadowingPointLightCount;
private Vector4[] m_PointLightColors = new Vector4[k_MaxPointLightCount];
private Vector4[] m_PointLightPositions = new Vector4[k_MaxPointLightCount];
private Vector4[] m_PointLightParams = new Vector4[k_MaxPointLightCount];
private Matrix4x4[] m_PointLightShadowMatrices = new Matrix4x4[k_MaxShadowingPointLightCount * 6];
private int[] m_ShadowingPointLightIndices = new int[k_MaxShadowingPointLightCount];
```

这些参数基本和聚光灯一致，除了 Shadow Matrix 因为每盏灯有 6 个面，即 6 个转换矩阵，故总共需要透视阴影的灯光数量乘上 6 个转换矩阵。另外 `RecordLightData()` 函数中要做的事情和聚光灯几乎没有区别，而且要记录的数据还少了，所以我这里就不摘抄了，直接跳到创建与绘制 Shadow CubeArray。

``` C#
private void CreateAndRenderPunctualLightShadowArray(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    // Spot Light
    ...

    // Point Light
    if (m_ShadowingPointLightCount > 0)
    {
        data.buffer.GetTemporaryRT(k_PointLightShadowMapID, new RenderTextureDescriptor()
        {
            colorFormat = RenderTextureFormat.Shadowmap,
            depthBufferBits = 32,
            dimension = TextureDimension.CubeArray,
            width = asset.punctualLightShadowArraySize,
            height = asset.punctualLightShadowArraySize,
            volumeDepth = m_ShadowingPointLightCount * 6,
            msaaSamples = 1
        });
        RenderPointLightShadowArray(asset,ref data);
    }
}
```

注意 volumeDepth 别忘了乘以 6 否则会报错。接下来就是 `RenderPointLightShadowArray()` 函数：  

``` C#
private void RenderPointLightShadowArray(YRenderPipelineAsset asset, ref PipelinePerFrameData data)
{
    data.buffer.SetGlobalFloat(k_ShadowPancakingId, 0.0f);
    for (int i = 0; i < m_ShadowingPointLightCount; i++)
    {
        ShadowDrawingSettings shadowDrawingSettings = new ShadowDrawingSettings(data.cullingResults, m_ShadowingPointLightIndices[i]);

        for (int j = 0; j < 6; j++)
        {
            data.cullingResults.ComputePointShadowMatricesAndCullingPrimitives(m_ShadowingPointLightIndices[i], (CubemapFace) j, 0f, out Matrix4x4 viewMatrix, out Matrix4x4 projectionMatrix, out ShadowSplitData splitData);
            shadowDrawingSettings.splitData = splitData;
            viewMatrix.m11 = -viewMatrix.m11;
            viewMatrix.m12 = -viewMatrix.m12;
            viewMatrix.m13 = -viewMatrix.m13;
            m_PointLightShadowMatrices[i * 6 + j] = ShadowUtility.GetWorldToLightScreenMatrix(projectionMatrix * viewMatrix);
        
            data.buffer.SetViewProjectionMatrices(viewMatrix, projectionMatrix);
            data.buffer.SetRenderTarget(new RenderTargetIdentifier(k_PointLightShadowMapID, 0, CubemapFace.Unknown, i * 6 + j), RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);
            data.buffer.ClearRenderTarget(true, false, Color.clear);
            RendererList shadowRendererList = data.context.CreateShadowRendererList(ref shadowDrawingSettings);
            data.buffer.DrawRendererList(shadowRendererList);
        }
    }
}
```

这个函数和聚光灯的主要差别在于，因为有 6 个面，所以每盏灯再遍历 6 次，调用 `ComputePointShadowMatricesAndCullingPrimitives` 计算观察投影矩阵，这个函数对比聚光灯的版本多了两个参数，第一个是 Cubemap 的哪一面，第二个是 FOV bias，FOV bias 先设置为 0。这里计算观察投影矩阵需要说明的是，它会无视点光源的旋转，也就是说，Cubemap 始终朝向 xyz 轴的某一轴，并且顺序为 +x、-x、+y、-y、+z、-z。下面之所以将观察矩阵的第二行取反，是因为 Unity 原本渲染点光源时，改变了面的 winding order，相当于渲染它们的背面（即常规 Cull Back 变为了 Cull Front），这样子做可以一定程度上减少 shadow acne 但是会增加漏光现象，我们可以通过把第二行取反，取消掉这个方法带来的影响，这里是一个很有意思的数学技巧：将第二行取反相当于改变了 y 轴的正负号，那么在齐次除法之前 y 轴正负颠倒就是相当于将物体上下颠倒，这样就改变了物体三角面的 winding order，本来渲染背面，现在只渲染正面。后面的代码就没什么大区别了，就是注意一下 SetRenderTarget 的 CubemapFace 是 CubemapFace.Unknown，depthSlice 是 i * 6 + j。

### GPU 中具体实现
首先是 CBuffer 中的参数：  

    #define MAX_POINT_LIGHT_COUNT               32
    #define MAX_SHADOWING_POINT_LIGHT_COUNT     8

    CBUFFER_START(LightParamsPerFrame)
        float4 _PunctualLightCount; // x: spot light count, y: point light count, z: 0, w: 0

        // Sun Light
        ...
        // Spot Light
        ...
        // Point Light
        float4 _PointLightColors[MAX_POINT_LIGHT_COUNT]; // xyz: color * intensity, w: shadow strength
        float4 _PointLightPositions[MAX_POINT_LIGHT_COUNT]; // xyz: point light position, w: shadow mask channel
        float4 _PointLightParams[MAX_POINT_LIGHT_COUNT]; // x: 1.0 / point light radius square, y: 0, z: 0, w: shadowing point light index
        float4x4 _PointLightShadowMatrices[MAX_SHADOWING_POINT_LIGHT_COUNT * 6];
    CBUFFER_END

    ...
    #define POINT_LIGHT_SHADOW_MAP          _PointLightShadowMap
    TEXTURECUBE_ARRAY_SHADOW(POINT_LIGHT_SHADOW_MAP);

这些参数没什么好说的，下面阴影采样和聚光灯的主要区别在于，cubemap 是拿采样点到光源的方向（L）进行采样，而不是经过阴影矩阵变换后的 uv 坐标。所以我们要计算出着色点经过阴影矩阵变化后得到的深度值跟采样 cubemap 得到的深度值做比较。但是一个点光源有 6 个方向，即 6 个阴影矩阵，我们要先根据着色点到光源的方向（L）来判断出当前着色点应该采样 cubemap 的哪个面，Unity 帮我们做了这个工作，我们可以使用 Core RP Library 的 Common.hlsl 中的函数 `CubeMapFaceID()`：  

    float faceIndex = CubeMapFaceID(-pointLightParams.L);

之所以用 L 的反方向是因为 L 是指向光源的，跟采样方向是相反的。拿到 faceIndex 就可以索引到正确的阴影矩阵，并阴影矩阵变换了，代码如下：  

    float3 TransformWorldToPointLightShadowCoord(float3 positionWS, int shadowingLightIndex, float faceIndex)
    {
        // SS: shadow space
        float4 positionSS_BeforeDivision = mul(GetPointLightShadowMatrix(shadowingLightIndex * 6 + faceIndex), float4(positionWS, 1.0));
        float3 positionSS = positionSS_BeforeDivision.xyz / positionSS_BeforeDivision.w;
        return positionSS;
    }

然后就可以计算 shadow attenuation 了：  

    float SampleShadowCubeArray_Compare(float3 sampleDir, float z, float elementIndex, TEXTURECUBE_ARRAY_SHADOW(shadowMap), SAMPLER_CMP(shadowMapSampler))
    {
        float shadowAttenuation = SAMPLE_TEXTURECUBE_ARRAY_SHADOW(shadowMap, shadowMapSampler, float4(sampleDir, z), elementIndex);
        return shadowAttenuation;
    }

    float GetPointLightShadowAttenuation(int lightIndex, float faceIndex, float2 lightMapUV, float3 positionWS, float3 L)
    {
        float shadowStrength = GetPointLightShadowStrength(lightIndex);
        float shadowingPointLightIndex = GetShadowingPointLightIndex(lightIndex);
        float3 positionSS = TransformWorldToPointLightShadowCoord(positionWS, shadowingPointLightIndex, faceIndex);
        float shadowAttenuation = SampleShadowCubeArray_Compare(-L, positionSS.z, shadowingPointLightIndex, POINT_LIGHT_SHADOW_MAP, SHADOW_SAMPLER);
        return lerp(1.0, shadowAttenuation, shadowStrength);
    }

这样子就可以渲染出阴影了，只不过还是有很多阴影质量问题，因为我们没做 Shadow Bias 和 PCF，如下：

<div  align="center">  
<img src="https://s2.loli.net/2025/02/24/bde2EaqpfPnAVY3.jpg" width = "45%" height = "45%" alt="图75 - 充满阴影质量问题的点光源阴影"/>
</div>

### Shadow Bias 和 PCF
逻辑和聚光灯差不多，首先计算 Linear Depth 可以通过着色点的世界坐标 positionWS 经过光源 vp 矩阵转换后的 w 分量获取，也可以通过 lightVector（光源世界空间坐标减去着色点世界空间坐标，即未归一化的 L）和当前 cubemap 面的方向点乘的绝对值获取。这里记录了第二种，上面聚光灯是第一种方法：  

    static const float3 k_CubeMapFaceDir[6] =
    {
        float3(1.0, 0.0, 0.0),
        float3(-1.0, 0.0, 0.0),
        float3(0.0, 1.0, 0.0),
        float3(0.0, -1.0, 0.0),
        float3(0.0, 0.0, 1.0),
        float3(0.0, 0.0, -1.0)
    };

    void InitializePointLightParams(out LightParams pointLightParams, int lightIndex, float2 lightMapUV, float3 V, float3 normalWS, float3 positionWS)
    {
        ...
        float3 lightVector = pointLightParams.positionWS.xyz - positionWS;
        ...
        [branch]
        if (pointLightParams.distanceAttenuation <= 0.0 || GetShadowingPointLightIndex(lightIndex) < 0.0)
        {
            pointLightParams.shadowAttenuation = 1.0;
        }
        else
        {
            float faceIndex = CubeMapFaceID(-pointLightParams.L);
            float linearDepth = abs(dot(lightVector, k_CubeMapFaceDir[faceIndex]));
            pointLightParams.shadowAttenuation = GetPointLightShadowAttenuation(lightIndex, faceIndex, lightMapUV, positionWS, normalWS, pointLightParams.L, linearDepth);
        }
    }

计算 texelSize 和 penumbraWidth 和聚光灯没什么区别，就是点光源的 FOV 都是 90，也就说 $\,tan \frac {FOV}{2}\,$ 都是 1，在计算 texelSize 时可以少计算一个参数。最后和聚光灯最大的区别就在于采样方向以及 PCF 对采样方向的偏移，第一点：我们将 positionWS 经过 shadow bias 偏移后，减去灯光位置就可以得到 shadow bias 偏移后的采样方向：  

    float3 sampleDir = normalize(positionWS_Bias - GetPointLightPosition(lightIndex));

第二点，因为 PCF 多次采样，每次采样都对 uv 偏移了一定的单位。但是现在是方向采样，并且有 6 个面，每次偏移的分量不一样，比如 x 方向，应该偏移采样方向的 y、z 方向。这就需要额外的函数来判断偏移的分量：  

    float3 GetCubeMapOffset(float faceIndex, float2 offset)
    {
        float3 cubeMapOffset;
        if (faceIndex >= -0.1f && faceIndex <= 1.1f)
        {
            cubeMapOffset = float3(0.0, offset.x, offset.y);
        }
        else if (faceIndex >= 1.9f && faceIndex <= 3.1f)
        {
            cubeMapOffset = float3(offset.x, 0, offset.y);
        }
        else
        {
            cubeMapOffset = float3(offset.y, offset.x, 0);
        }
        return cubeMapOffset;
    }

还有一点就是采样方向的分量范围是 [-1, 1]，而 uv 的范围是 [0, 1]，故需要将偏移值乘以 2，这样可以确保在相同的半影宽度设置下，点光源和聚光灯的半影宽度是一样的。最终 PCF 函数如下：  

    float ApplyPCF_CubeArray(float index, float faceIndex, TEXTURECUBE_ARRAY_SHADOW(shadowMap), float shadowArraySize, float sampleNumber, float penumbra, float3 sampleDir, float3 positionWS, float3 positionSS)
    {
        uint hash1 = Hash_Jenkins(asuint(positionWS));
        uint hash2 = Hash_Jenkins(asuint(positionSS));
        float random = floatConstruct(hash1);
        float randomRadian = random * TWO_PI;
        float2x2 rotation = float2x2(cos(randomRadian), -sin(randomRadian), sin(randomRadian), cos(randomRadian));
        
        float shadowAttenuation = 0.0;
        for (float i = 0; i < sampleNumber; i++)
        {
            float2 offset = mul(rotation, InverseSampleCircle(Sobol_Scrambled(i, hash1, hash2))) / shadowArraySize;
            offset = offset * penumbra;
            float3 sampleDir_Offset = sampleDir + GetCubeMapOffset(faceIndex, offset) * 2;
            shadowAttenuation += SampleShadowCubeArray_Compare(sampleDir_Offset, positionSS.z, index, shadowMap, SHADOW_SAMPLER);
        }
        return shadowAttenuation / sampleNumber;
    }

    float GetPointLightShadowAttenuation(int lightIndex, float faceIndex, float2 lightMapUV, float3 positionWS, float3 normalWS, float3 L, float linearDepth)
    {
        float shadowStrength = GetPointLightShadowStrength(lightIndex);
        
        float shadowingPointLightIndex = GetShadowingPointLightIndex(lightIndex);
        //float linearDepth = mul(GetPointLightShadowMatrix(shadowingPointLightIndex * 6 + faceIndex), float4(positionWS, 1.0)).w;
        float texelSize = 2.0 * linearDepth / GetPunctualLightShadowArraySize();
        float penumbraWidth = GetPunctualLightShadowPenumbraWidth() * GetPunctualLightShadowArraySize();
        float3 positionWS_Bias = ApplyShadowBias(positionWS, texelSize, penumbraWidth, normalWS, L);
        float3 sampleDir = normalize(positionWS_Bias - GetPointLightPosition(lightIndex));
        float3 positionSS = TransformWorldToPointLightShadowCoord(positionWS_Bias, shadowingPointLightIndex, faceIndex);
        float shadowAttenuation = ApplyPCF_CubeArray(shadowingPointLightIndex, faceIndex, POINT_LIGHT_SHADOW_MAP, GetPunctualLightShadowArraySize(), GetPunctualLightShadowSampleNumber(), penumbraWidth, sampleDir, positionWS, positionSS);
        return lerp(1.0, shadowAttenuation, shadowStrength);
    }

最终点光源的阴影效果如下：  

<div  align="center">  
<img src="https://s2.loli.net/2025/02/24/VP2tyXHFEjaQCwz.jpg" width = "50%" height = "50%" alt="图76 - 点光源阴影效果"/>
</div>

### FOV Bias
点光源的阴影效果有一点小瑕疵，就是 Cubemap 面与面之间的衔接会有点小问题，对于 texture atlas 的方法来说，这个问题较难解决，因为没法在不同的面之间采样做插值。而我们上面使用的是 Cubemap 相对来说这个问题没有这么明显，只有在视角特别近的时候才较为明显，视角拉远基本上就看不出来了，如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2025/02/24/97385OpEAGIyqDZ.jpg" width = "40%" height = "40%" alt="图77 - Cubemap 阴影的衔接问题"/>
</div>

Unity 还提供了一个解决方式，就是 `ComputePointShadowMatricesAndCullingPrimitives` 的 FOV bias 参数，它可以让 FOV 变得更大一点。对于使用了 texture atlas 的实现来说，这个 FOV bias 可以让阴影衔接问题变得没这么突兀。但是对于 Cubemap 的实现来说，这个 FOV bias 反而会增加衔接问题，还是设置为 0 比较好。

## Mix baked and realtime shadow
因为我想放弃 Unity 的 LightMap 系统，它的精确光烘焙阴影效果很一般，只有 PCF 的效果，没有 PCSS 的效果，之后实现 PCSS 后和它就很不搭，而且对精确光的超远距离的阴影渲染需求也没有这么大。我暂时打算只支持方向光的阴影烘焙（间接光漫反射方向光和精确光都是支持的），以实现超远距离的阴影效果，之后肯定要全部弃用 Unity 的 LightMap 系统的。弃用后，对于间接光漫反射，可以通过 LightProbe 去实现，效果也不差，而且之后肯定要实现更好的全局光照方案的。至于超远距离的阴影，以后真的碰到需求再处理，肯定有实现的办法的。所以混合烘焙阴影与实时阴影的代码我这里就不摘抄了，真要实现的话，跟方向光的实现没什么太大区别。