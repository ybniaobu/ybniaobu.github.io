---
title: Unity Custom SRP 基础（八）
date: 2025-04-29 20:00:38
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2025/04/29/IHYjvyKDR2uoGEt.gif
mathjax: true
description: 本笔记的主要内容包含XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX。
---

> 本笔记是关于 Unity 的**自定义可编程渲染管线**的入门基础，即 **SRP (Scriptable Rendering Pipeline)**，主要参考了著名的教程 https://catlikecoding.com/ 的 Custom SRP Tutorial，以及知乎上各位图形学大神们的文章。  
>    
> 笔者使用的 Unity 版本是 6000.0.27f1，Core RP Library 的版本是 17.0.3。

# Render Graph
**Render Graph / Frame Graph** 最早由寒霜引擎于 GDC 2017 提出，PPT 详见：https://www.slideshare.net/slideshow/framegraph-extensible-rendering-architecture-in-frostbite/72795495 。Unity 也因此实现了一套自己的 Render Graph，在 Core RP Library 内，命名空间为 `UnityEngine.Rendering.RenderGraphModule`。

> 下面参考了几篇文章：https://zhuanlan.zhihu.com/p/582415505 ，https://zhuanlan.zhihu.com/p/425830762 。

## Render Graph 基本概念
随着现代游戏引擎渲染效果的不断丰富，Pass 的数量日益增多、逻辑日益复杂，传统的 Immediate mode 下的渲染管线具有诸多挑战：比如各功能之间存在强耦合、开发者需要手动管理资源的生命周期、功能的拓展具有局限性以及难以 Debug 等等，因此寒霜对渲染 **passes** 以及 **resources** 的管理提出了更高程度的抽象，即 Frame Graph。

**Pass** 指一组渲染操作或者函数，每个 Pass 可以负责渲染特定的内容或物体，或仅用于设置全局状态。Pass 可以接受一个或多个输入资源，调用自己内部的执行函数，并产生一个或多个输出资源。现代游戏引擎的 pass 可能会达到数十个或上百个。

<div  align="center">  
<img src="https://s2.loli.net/2025/05/21/CrLNshp7aGgKZTw.png" width = "60%" height = "60%" alt="图144 - 战地 4 的 Passes"/>
</div>

**Resources** 指 Buffer 以及 Texture。这些资源在用完之后若不能及时收回，那将会导致 GPU 的内存利用率降低，甚至是 GPU 内存泄露，所以资源的及时回收非常得重要。对于大部分的 Texture 的生命周期只会在一帧之内，即**临时资源 Transient Resource**。

与此同时，现代图形 API（如 Vulkan、Metal 或 DirectX 12）暴露了更多底层的 API 接口，对比 DirectX 11 时代图形开发人员往往需要先提前设定好或加载好所有需要的东西，最后才去执行它们，即延迟执行。DirectX 11 依赖驱动程序自动优化资源管理，渲染逻辑通常集中在单个线程。而 DirectX 12 开发者需要直接管理硬件资源，同时引入了**命令队列 Command Queue** 和**命令列表 Command List**，允许多线程并行生成渲染指令，另外开发者需手动管理资源状态（如使用**资源屏障 Resource Barrier**），避免不必要的状态切换，提升效率，故增加了代码的复杂度。

所以 Render Graph 的产生可以更好地调配、跟踪、管理、回收资源，并且自动管理资源而非手动管理。此外 Render Graph 的目标还有①简化资源的管理；②简化渲染管线的配置；③简化多线程计算以及资源屏障；④独立有效的渲染单元；⑤渲染管线可视化以及更容易 Debug。

## Render Graph 的设计
Render Graph 将渲染代码分为一个个 Pass，每个 Pass 相互独立，不存在相互调用。Render Graph 主要分为三个阶段：**Setup Phase**、**Compile Phase**、**Execute Phase**。

**①Setup Phase** 中主要定义 render passes 或者 compute passes，并为每个 pass 定义输入和输出资源，然后对这些资源定义执行哪种操作，比如 **read**、**write**、**create**。对于一些外部永久资源（生命周期大于一帧），需要**导入 import**，比如 backbuffer、TAA 的历史帧等等。寒霜的示例代码如下：   

``` C++
RenderPass::RenderPass(FrameGraphBuilder& builder)
{
  // Declare new transient resource
  FrameGraphTextureDesc desc;
  desc.width = 1280;
  desc.height = 720;
  desc.format = RenderFormat_D32_FLOAT;
  desc.initialSate = FrameGraphTextureDesc::Clear;
  m_renderTarget = builder.createTexture(desc);
}

RenderPass::RenderPass(FrameGraphBuilder& builder,
  FrameGraphResource input,
  FrameGraphMutableResource renderTarget)
{
  // Declare resource dependencies
  m_input = builder.read(input, readFlags);
  m_renderTarget = builder.write(renderTarget, writeFlags);
}
```

pass 对于 resource 的声明，能够让 Render Graph 帮我们确定 resource 的生命周期，resource 应该在何时被分配，应该在何时被回收，Render Graph 会自动帮我们计算，并使 resource 的生命周期尽可能得短。同时在 setup 阶段，resource 还没有被分配空间，因为该阶段并没有使用到 resource。

**②Compile Phase**，该阶段主要**裁剪 Cull** 未引用的 resource 和 pass，留下真正需要执行的部分。同时对 resource 的生命周期进行计算，确定 resource 应该在何时分配资源、何时被回收。

**③Execute Phase** 就是开始执行每个未裁剪 Pass 的回调函数，并真正为 Setup Phase 申明的资源分配 GPU 资源。

## Render Graph 的其他优化
**①Asynchronous Compute**  
程序优化的一个大方向就是提高并行度，即使在执行很密集的渲染任务时，GPU 的绝大部分时间都是闲置状态。现在的渲染管线需要处理大量的多边形和像素，处理得越快得到的结果质量就会越高，因为 GPU 的渲染管线的各个部分（顶点着色、光栅化、片元着色等）都是有专门的运算单元负责的，管线中的任意一个阶段出现瓶颈都会使其他阶段不能充分利用，每个阶段的吞吐量 Throughput 还依赖于其他阶段。这也是 Forward Rendering 的弊端之一，因为 Forward Rendering 在片元着色阶段具有一定的瓶颈。

与此同时，现代 GPU 通常包括多个独立的 Engine 来提供专用的功能。很多 GPU 包含一个 （3D）Graphic Engine、一个 Compute Engine、一个或多个 Copy Engine。Engine 本质上就是 Command Processor，它们可以并行处理命令。3D Engine 包括 VS、光栅化、PS 等；Compute Engine 执行的就是 Compute Shader；Copy Engine 则用来拷贝资源。

在 DirectX 12 中提供了三种 Command Queue 驱动这三个 Engine，3D (Graphic) Queue 可以驱动这三个 Engine，Compute Queue 可以驱动 Compute 和 Copy Engine，Copy Queue 只能驱动 Copy Engine。向 3D Queue 提交一个 3D Command List，向 Compute Queue 提交一个 Compute Command List，这样的结果就是 3D Queue 驱动 3D Engine，同时 Compute Queue 驱动 Compute Engine，这种行为就叫做 **Async Compute**。Async Compute 的目的是让开发者在比线程更高的层次上实现并行，提高 GPU 的利用率。

<div  align="center">  
<img src="https://s2.loli.net/2025/05/21/c6yxaid3WBSFzJ9.png" width = "50%" height = "50%" alt="图145 - Async Compute"/>
</div>

需要注意的是要让 Graphic Queue 和 Compute Queue 利用不同的 GPU 资源，比如 Shadow maps 的瓶颈在光栅化这些固定功能单元，这时执行计算任务是很合适的，如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2025/05/21/7bXleEs6xnrMfo1.png" width = "60%" height = "60%" alt="图146 - Shadow Maps Async Compute（Deferred Rendering 下）"/>
</div>

但如果将 SSAO 和 Shading 异步执行，可能效率还不如不用 Async Compute。甚至让多帧重叠也可以进一步提高利用率，比如上图中 Post-Processing 和 G-Buffer 阶段异步执行。在使用 Asyn Compute 时，Render Graph 可以帮助我们自动调度 Async Compute、处理同步点，降低了维护成本，使开发者可以专注图形特性的开发。

**②Resource Barrier**  
在 DirectX 11 及 OpenGL 中，资源状态管理是隐式进行的，大部分状态管理工作是由驱动程序自动完成的。每当应用程序执行一个操作，如绘制调用或资源绑定，驱动程序需要检查所涉及资源的当前状态，并确定是否需要进行状态转换。就和 GC 一样系统为了安全，牺牲了一部分性能。但在 DirectX 12 中，


