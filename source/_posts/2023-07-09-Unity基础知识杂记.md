---
title: Unity基础知识杂记
date: 2023-07-09 15:48:32
categories: 
  - [unity, unity基础]
tags:
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2023/07/09/Vl2zrXehUWiSvfn.gif
mathjax: true
---

> 由于知识量太大，对于 unity 的基础知识不做系统性的记录。只记录一些常用的重要的，以便后续查找。

# 脚本
为了连接到 Unity 的内部架构，脚本需要实现一个类，此类从称为 MonoBehaviour 的内置类派生而来。可以将类视为一种蓝图，用于创建可附加到游戏对象的新组件类型。每次将脚本组件附加到游戏对象时，都会创建该蓝图定义的对象的新实例。类的名称取自创建文件时提供的名称。类名和文件名必须相同才能使脚本组件附加到游戏对象。（如果在 Unity 里更改了 C# 文件的名称，脚本的类名不会一起改变，此时需要在脚本里改类名）
## 脚本的生命周期
摘自 Unity 官方文档，方便查阅，引用版本：[Unity 官方手册 ver. 2023.1](https://docs.unity3d.com/2023.1/Documentation/Manual/ExecutionOrder.html)

![脚本生命周期流程图](/images/Unity_ScriptLifecycle.svg)

一、初始化阶段  
场景开始时将调用以下函数（为场景中的每个对象调用一次）：  
①**Awake**：当一个脚本实例被载入时 Awake 被调用，无论脚本是否可用，只要物体被加载就会调用，Awake 常用于在游戏开始之前初始化变量或游戏状态，可以判断当满足条件后执行此脚本。（**只调用一次**）  
②**OnEnable**：（仅在对象处于可用或激活状态时调用）在启用对象后立即调用此函数。（**可多次调用**）  
③**Reset**：在编辑模式时，当脚本被附上对象或用户点击检视面板的 Reset 按钮时，Reset 被调用。  
④**Start**：当脚本实例处于可用或激活状态时，Start 在 Update 函数第一次被调用前（第一帧更新前）调用一次，且仅调用一次；Awake 总是在 Start 之前执行。（**只调用一次**）

二、物理阶段  
①**FixedUpdate**（固定间隔执行）  
FixedUpdate 基于一个可靠的定时器被调用，独立于渲染帧率之外，所以在 FixedUpdate 内应用运动计算时，无需将值乘以 Time.deltaTime 。默认频率大概为 0.02s ，可在 Edit --> Project Setting --> Time --> Fixed Timestep 中修改。如果 Fixed Timestep 小于实际的帧更新时间，那么每帧的物理循环可能会发生不止一次。如果帧率很高，可能在帧之间完全不调用该函数。

处理物体的物理属性(Rigidbody、Force、Collider)或者输入事件时，需要用 FixedUpdate 代替 Update ，以使物体的物理表现更平滑。实际上，FixedUpdate 并不是真的按照现实时间间隔执行的，而是按照 Timer 时间间隔执行的，但 Timer 并不是真正意义上的现实时间，它的作用是在运行环境下创造一个与现实时间高度相近的变量来实现物理帧的逻辑稳定。因为 FixedUpdate 的这个特质，强烈建议在此环节只做物理相关的处理，不要把其他类型(如网络帧同步)的处理也放入此步骤。

②**OnTriggerXXX**：触发器被触发时调用。  
③**OnCollisionXXX**：产生碰撞事件时调用。

三、输入事件阶段  
鼠标、键盘、触屏、手柄等各类输入事件会在这个阶段触发，这个时间点物理更新已经执行（如果需要物理更新的话），而逻辑更新和渲染并未执行，要了解这个触发的时机，才能更好的掌握代码逻辑。

四、游戏逻辑阶段  
①**Update**（执行间隔不固定）  
Update 是真正的每个渲染帧调用的，由于系统性能以及游戏体量的区别，每一帧的刷新频率也是不同的。  
②**LateUpdate**  
每帧 Update 方法调用之后会调用本方法，适用于跟随逻辑。因为游戏开发过程中经常会有一个二次计算的情况，比如主角移动，相机跟着移动。如果相机也在主角移动时跟随，当有物体跟玩家之间产生了相位，就可能会出现抽搐抖动等情况（因为并没有在这一帧逻辑完全结束后调用跟随）。所以 LateUpdate 的出现能够使程序更加顺畅。

五、渲染阶段  
①**OnWillRenderObject**：当即将渲染物体时调用。  
②**OnPreCull**：这个函数仅用于宿主为摄像机的脚本。当此摄像机剔除了某个渲染场景时候触发此消息。  
③**OnBecameVisable**：当物体的 Mesh Renderer 在任何相机可见时调用。  
④**OnBecameInvisible**：当物体的 Mesh Renderer 在任何相机不可见时调用。  
⑤**OnPreRender**：这个函数仅用于宿主为摄像机的脚本。当此摄像机开始渲染某个场景时候触发此消息。  
⑥**OnRenderObject**：这个函数仅用于宿主为摄像机的脚本。当使用Graphics.DrawMeshNow 或者其他函数绘制自己建立的物体渲染完毕时触发。  
⑦**OnPostRender**：这个函数仅用于宿主为摄像机的脚本。当此摄像机范围内所有渲染都完成时候触发此消息。  
⑧**OnRenderImage**：当所有渲染完成image的postprocessing effects（只有pro版支持）后触发。  
⑨**OnDrawGizmos**（Gizmos渲染）：Gizmos一般是为开发者使用的，指的是开发时场景编辑器中所展示的那些相机、线框之类的物体。所以此方法里的内容一般不会需要发布到生产环境中。  

六、暂停阶段  
①**OnApplicationPause**：应用暂停时会调用此方法，取消暂停后会从 FixedUpdate 开始重新执行。

七、退出阶段  
①**OnDisable**：在对象变为不可用或附属游戏对象非激活状态时，调用此函数。  
②**OnDestroy**：当物体被销毁时调用，一般用于清理内存。  
③**OnApplicationQuit**：当应用退出时调用，但有时会失效，此方法为不稳定的方法，正常情况下可以用于保存退出前的信息，但最好使用更稳妥的方式，因为此方法有时不会被调用，比如 Android 环境。

## 调试
一、Unity调试器调试  
在脚本代码中用 `Debug.Log();` 或 `print();` 进行打印调试

二、使用代码编辑器调试
在可能出错的行添加断点 --> 启动调试 --> 在 Unity 中 Play 场景 --> 在编辑器中按 F11 逐条调试 --> 调试完毕后退出调试

也可以在调试时右键 --> 快速监视，在快速监视面板便捷的调试和查看数据。还可以在即时窗口输入代码进行调试。

因为 Update 和其他方法不同，它是逐帧运行的，所以在调试时需要单帧调试。步骤：启动调试 --> 运行场景 --> 暂停游戏 --> 加断点 --> 单帧执行 --> 结束

## 常用 API

<div  align="center">  
<img src="https://s2.loli.net/2023/07/31/uzlm2T9Zax7qNIo.png" width = "90%" height = "90%" alt="核心类"/>
</div>

API 常用方法和属性不做记录，直接查阅[官方文档 ver. 2023.2](https://docs.unity3d.com/cn/2023.2/ScriptReference/index.html)

①**GameObject**：提供了修改 GameObject 状态相关的属性，查找、创建和销毁 GameObject 的功能（有些功能继承自 Object 类）。所有 GameObject 都在 Inspector 顶部共享一组与场景中 GameObject 状态相关的控件，这些控件可以通过 GameObject 的脚本 API 进行控制。  
②**Component**：提供了添加、获取和移除组件的方法。  
③**Transform**：提供多种方式来通过脚本处理游戏对象的位置、旋转和缩放，以及与父和子游戏对象的层级关系（查找父、根、子变换组件）。  
④**Vector2**、**Vector3** 和 **Vector4** ：用于表达和操作 2D、3D 和 4D 点、线和方向的类。  
⑤**Quaternion**描述从一个方向到另一个方向的相对旋转。  
⑥**Time**：用于测量和控制时间，并管理项目的帧率。  
⑦**Mathf**（Math Function）：提供了一组常见的数学函数，包括三角函数、对数函数以及游戏和应用开发中常用的其他函数。  

# 三维数学基础
这里只记录简单的数学知识以及代码操作，复杂的详见线性代数、3D 数学基础等相关数学文章。
## 向量基础
一、向量相关API  
`Vector3.magnitude` 返回向量长度（模长）；`Vector3.normalized` 返回单位向量（即向量除以向量长度）。向向量方向移动，可以使用 `Transform.Translate` ，也可以直接向量相加。

二、向量**点乘 dot product**  
又称 *点积* 、 *内积* 或者 *数量积* ，点乘结果为**标量 scalar**，公式为：  
$$\vec a \cdot \vec b = a_1 b_1 + a_2 b_2 + \cdots + a_n b_n $$  
或者（θ 为向量 a 和向量 b 之间的夹角）：  
$$\vec a \cdot \vec b = \left| a \right| \left| b \right| \cos( \theta )$$  

三角形余弦定理：$c^2 = a^2 + b^2 - 2 \left| a \right| \left| b \right| \cos( \theta ) $，根据关系 $c = a - b$（a、b、c为三角形的三个边向量），可得：  
$$(a-b) \cdot (a-b) = a^2 + b^2 - 2 a \cdot b = a^2 + b^2 - 2 \left| a \right| \left| b \right| \cos( \theta )$$  
故若向量 a，b 已知，可以得到夹角 θ：  
$$ \theta = \arccos( \frac { \vec a \cdot \vec b } {\left| a \right| \left| b \right|} )$$

点乘的几何意义以及应用：  
①向量 b 在 向量 a 上的投影的长度（模）和向量 a 的长度（模）的乘积；  
②可以计算向量 a 和向量 b 之间的夹角，从而判断两个向量是否方向一致或者正交（垂直）：  
&emsp;&emsp; - $a \cdot b \gt 0$：向量方向一致，夹角为 0° 到 90° 之间；  
&emsp;&emsp; - $a \cdot b = 0$：向量正交，相互垂直；  
&emsp;&emsp; - $a \cdot b \lt 0$：向量方向相反，夹角为 90° 到 180° 之间；  

**Unity API：`Vector3.Dot(a, b)`**，可以直接利用单位向量来获取夹角余弦值：`Vector3.Dot(Vector3.normalized, Vector3.normalized)`

三、向量**叉乘 cross product**  
又称 *叉积* 、 *外积* 或者 *向量积* ，叉乘结果为**向量 vector**，并且结果向量（向量 c）与向量 a 和向量 b 组成的平面垂直，即**法向量**，在右手坐标系下方向遵守右手定则（四指从向量 a 旋转到向量 b，那么大拇指为向量 c 的方向）。由于 Unity 是左手坐标系，需要用左手确定方向。若 $\vec a = ( a_1, a_2, a_3 )$，$\vec b = ( b_1, b_2, b_3 )$，i、j、k 分别为X、Y、Z 轴方向的单位向量，公式为：  
$$\vec a \times \vec b = det {\begin{vmatrix} \vec i & \vec j & \vec k \\ a_1 & a_2 & a_3 \\ b_1 & b_2 & b_3 \end{vmatrix}} = (a_2b_3 - a_3b_2)\vec i - (a_1b_3 - a_3b_1)\vec j + (a_1b_2 - a_2b_1)\vec k $$  
即，向量 c 为：  
$$\vec c = \vec a \times \vec b = (a_2b_3 - a_3b_2,\ -a_1b_3 + a_3b_1,\ a_1b_2 - a_2b_1)$$

向量 C 的模长可被定义为：  
$$ \left| \vec c \right| = \left| \vec a \times \vec b \right| = \left| a \right| \left| b \right| \sin( \theta )$$

向量 c 的模长也就是向量 a 和 向量 b 构成的平行四边形的面积。据此可以得出**混合积**（三重积）的几何意义，x、y、z 为空间中三个向量：$ [x\ y\ z] = x \cdot (y \times z) = y \cdot (z \times x) = z \cdot (x \times y)$，其结果为三个向量定义的平行六面体的体积。

叉乘的几何意义以及应用：  
①求解向量 a 和向量 b 构成的平面的法线；
②计算点到线的距离，向量 a 的顶点到向量 b 的距离，即：  
$$\left| a \right| * \sin( \theta ) = \frac {\left| a \times b \right|} {\left| b \right|}$$  
③利用平面方程（即三元一次方程），计算点到面的距离，假设点 p 为 $( x_0, y_0, z_0 )$，则点 p 到向量 a 和向量 b 构成的平面的距离求解顺序如下：  
&emsp;&emsp; - 先求解向量 a 和向量 b 构成平面的法向量：$ \vec n = (A,\ B,\ C)$ ；  
&emsp;&emsp; - 再求解平面方程为 $Ax + By + Cz + D = 0$（D 由向量 a 和 b 代入可得）；  
&emsp;&emsp; - 点 p 到 $Ax + By + Cz + D = 0$ 平面的距离：  
$$d = \frac { \left| Ax_0 + By_0 + Cz_0 + D \right| } {\sqrt{A^2 + B^2 + C^2}} $$  

**Unity API：`Vector3.Cross(a, b)`**，可以利用单位向量来获取夹角正弦值：`Vector3.Cross(Vector3.normalized, Vector3.normalized).magnitude`。根据叉乘方向可以判断，向量与向量的左右位置信息。

## 三角函数
一、角度与弧度的转换  
PI 弧度 = 180° 即 1弧度 = 180/PI 角度，1° = PI/180 弧度  
=> 角度到弧度（degree to radian）：`角度 * Mathf.Deg2Rad` 等同于 `角度 * Mathf.PI/180`
=> 弧度到角度（radian to degree）：`角度 * Mathf.Rad2Deg` 等同于 `角度 * 180/Mathf.PI`

二、正弦余弦正切  
`Mathf.Sin(float radian)`；`Mathf.Cos(float radian)`；`Mathf.Tan(float radian)`  
`Mathf.ASin(float f)`；`Mathf.ACos(float f)`；`Mathf.ATan(float f)`

# 待梳理知识点

Unity 的**预制件 Prefab** 系统允许创建、配置和存储游戏对象及其所有组件、属性值和子游戏对象作为可重用资源。预制件资源充当模板，在此模板的基础之上可以在场景中创建新的预制件实例。


[SerializeField]  
[HideInInspector]  
[Range(num01,num02)]

# 记录可能很有用的方法
建议以后熟悉了unity后，全过一遍官方文档，记录一下不熟悉但是可能会很有用的方法

MonoBehaviour 的 Invoke 相关的方法
MonoBehaviour 的 Coroutine 相关的方法