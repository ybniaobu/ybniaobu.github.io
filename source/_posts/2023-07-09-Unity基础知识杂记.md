---
title: Unity基础知识杂记
date: 2023-07-09 15:48:32
categories: 
  - [unity, unity基础]
tags:
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2023/07/09/Vl2zrXehUWiSvfn.gif
mathjax: true
---

> 由于知识量太大，对于 unity 的基础知识不做系统性的记录。只记录一些常用的重要的，以便后续查找。

# 脚本
为了连接到 Unity 的内部架构，脚本需要实现一个类，此类从称为 MonoBehaviour 的内置类派生而来。可以将类视为一种蓝图，用于创建可附加到游戏对象的新组件类型。每次将脚本组件附加到游戏对象时，都会创建该蓝图定义的对象的新实例。类的名称取自创建文件时提供的名称。类名和文件名必须相同才能使脚本组件附加到游戏对象。

> 如果在 Unity 里更改了 C# 文件的名称，脚本的类名不会一起改变，此时需要在脚本里改类名  

## 脚本的生命周期
摘自 Unity 官方文档，方便查阅，引用版本：[Unity 官方手册 ver. 2023.1](https://docs.unity3d.com/2023.1/Documentation/Manual/ExecutionOrder.html)

![脚本生命周期流程图](/images/Unity_ScriptLifecycle.svg)

一、初始化阶段  
场景开始时将调用以下函数（为场景中的每个对象调用一次）：  
①**Awake**：当一个脚本实例被载入时 Awake 被调用，无论脚本是否可用，只要物体被加载就会调用，Awake 常用于在游戏开始之前初始化变量或游戏状态，可以判断当满足条件后执行此脚本。（**只调用一次**）  
②**OnEnable**：（仅在对象处于可用或激活状态时调用）在启用对象后立即调用此函数。（**可多次调用**）  
③**Reset**：在编辑模式时，当脚本被附上对象或用户点击检视面板的 Reset 按钮时，Reset 被调用。  
④**Start**：当脚本实例处于可用或激活状态时，Start 在 Update 函数第一次被调用前（第一帧更新前）调用一次，且仅调用一次；Awake 总是在 Start 之前执行。（**只调用一次**）

二、物理阶段  
①**FixedUpdate**（固定间隔执行）  
FixedUpdate 基于一个可靠的定时器被调用，独立于渲染帧率之外，所以在 FixedUpdate 内应用运动计算时，无需将值乘以 Time.deltaTime 。默认频率大概为 0.02s ，可在 Edit --> Project Setting --> Time --> Fixed Timestep 中修改。如果 Fixed Timestep 小于实际的帧更新时间，那么每帧的物理循环可能会发生不止一次。如果帧率很高，可能在帧之间完全不调用该函数。

处理物体的物理属性(Rigidbody、Force、Collider)或者输入事件时，需要用 FixedUpdate 代替 Update ，以使物体的物理表现更平滑。实际上，FixedUpdate 并不是真的按照现实时间间隔执行的，而是按照 Timer 时间间隔执行的，但 Timer 并不是真正意义上的现实时间，它的作用是在运行环境下创造一个与现实时间高度相近的变量来实现物理帧的逻辑稳定。因为 FixedUpdate 的这个特质，强烈建议在此环节只做物理相关的处理，不要把其他类型(如网络帧同步)的处理也放入此步骤。

②**OnTriggerXXX**：触发器被触发时调用。  
③**OnCollisionXXX**：产生碰撞事件时调用。

三、输入事件阶段  
鼠标、键盘、触屏、手柄等各类输入事件会在这个阶段触发，这个时间点物理更新已经执行（如果需要物理更新的话），而逻辑更新和渲染并未执行，要了解这个触发的时机，才能更好的掌握代码逻辑。

四、游戏逻辑阶段  
①**Update**（执行间隔不固定）  
Update 是真正的每个渲染帧调用的，由于系统性能以及游戏体量的区别，每一帧的刷新频率也是不同的。  
②**LateUpdate**  
每帧 Update 方法调用之后会调用本方法，适用于跟随逻辑。因为游戏开发过程中经常会有一个二次计算的情况，比如主角移动，相机跟着移动。如果相机也在主角移动时跟随，当有物体跟玩家之间产生了相位，就可能会出现抽搐抖动等情况（因为并没有在这一帧逻辑完全结束后调用跟随）。所以 LateUpdate 的出现能够使程序更加顺畅。

五、渲染阶段  
①**OnWillRenderObject**：当即将渲染物体时调用。  
②**OnPreCull**：这个函数仅用于宿主为摄像机的脚本。当此摄像机剔除了某个渲染场景时候触发此消息。  
③**OnBecameVisable**：当物体的 Mesh Renderer 在任何相机可见时调用。  
④**OnBecameInvisible**：当物体的 Mesh Renderer 在任何相机不可见时调用。  
⑤**OnPreRender**：这个函数仅用于宿主为摄像机的脚本。当此摄像机开始渲染某个场景时候触发此消息。  
⑥**OnRenderObject**：这个函数仅用于宿主为摄像机的脚本。当使用Graphics.DrawMeshNow 或者其他函数绘制自己建立的物体渲染完毕时触发。  
⑦**OnPostRender**：这个函数仅用于宿主为摄像机的脚本。当此摄像机范围内所有渲染都完成时候触发此消息。  
⑧**OnRenderImage**：当所有渲染完成image的postprocessing effects（只有pro版支持）后触发。  
⑨**OnDrawGizmos**（Gizmos渲染）：Gizmos一般是为开发者使用的，指的是开发时场景编辑器中所展示的那些相机、线框之类的物体。所以此方法里的内容一般不会需要发布到生产环境中。  

六、暂停阶段  
①**OnApplicationPause**：应用暂停时会调用此方法，取消暂停后会从 FixedUpdate 开始重新执行。

七、退出阶段  
①**OnDisable**：在对象变为不可用或附属游戏对象非激活状态时，调用此函数。  
②**OnDestroy**：当物体被销毁时调用，一般用于清理内存。  
③**OnApplicationQuit**：当应用退出时调用，但有时会失效，此方法为不稳定的方法，正常情况下可以用于保存退出前的信息，但最好使用更稳妥的方式，因为此方法有时不会被调用，比如 Android 环境。

## 调试
一、Unity调试器调试  
在脚本代码中用 `Debug.Log();` 或 `print();` 进行打印调试

二、使用代码编辑器调试
在可能出错的行添加断点 --> 启动调试 --> 在 Unity 中 Play 场景 --> 在编辑器中按 F11 逐条调试 --> 调试完毕后退出调试

也可以在调试时右键 --> 快速监视，在快速监视面板便捷的调试和查看数据。还可以在即时窗口输入代码进行调试。

因为 Update 和其他方法不同，它是逐帧运行的，所以在调试时需要单帧调试。步骤：启动调试 --> 运行场景 --> 暂停游戏 --> 加断点 --> 单帧执行 --> 结束

## 常用 API

<div  align="center">  
<img src="https://s2.loli.net/2023/07/31/uzlm2T9Zax7qNIo.png" width = "90%" height = "90%" alt="核心类"/>
</div>

API 常用方法和属性不做记录，直接查阅[官方文档 ver. 2023.2](https://docs.unity3d.com/cn/2023.2/ScriptReference/index.html)

①**GameObject**：提供了修改 GameObject 状态相关的属性，查找、创建和销毁 GameObject 的功能（有些功能继承自 Object 类）。所有 GameObject 都在 Inspector 顶部共享一组与场景中 GameObject 状态相关的控件，这些控件可以通过 GameObject 的脚本 API 进行控制。  
②**Component**：提供了添加、获取和移除组件的方法。  
③**Transform**：提供多种方式来通过脚本处理游戏对象的位置、旋转和缩放，以及与父和子游戏对象的层级关系（查找父、根、子变换组件）。  
④**Vector2**、**Vector3** 和 **Vector4** ：用于表达和操作 2D、3D 和 4D 点、线和方向的类。  
⑤**Quaternion**描述从一个方向到另一个方向的相对旋转。  
⑥**Time**：用于测量和控制时间，并管理项目的帧率。  
⑦**Mathf**（Math Function）：提供了一组常见的数学函数，包括三角函数、对数函数以及游戏和应用开发中常用的其他函数。  

# 三维数学基础
这里只记录简单的数学知识以及代码操作，复杂的详见线性代数、3D 数学基础等相关数学文章。
## 向量基础
一、向量相关API  
`Vector3.magnitude` 返回向量长度（模长）；`Vector3.normalized` 返回单位向量（即向量除以向量长度）。向向量方向移动，可以使用 `Transform.Translate` ，也可以直接向量相加。

二、向量**点乘 dot product**  
又称 *点积* 、 *内积* 或者 *数量积* ，点乘结果为**标量 scalar**，公式为：  
$$\vec a \cdot \vec b = a_1 b_1 + a_2 b_2 + \cdots + a_n b_n $$  
或者（θ 为向量 a 和向量 b 之间的夹角）：  
$$\vec a \cdot \vec b = \left| a \right| \left| b \right| \cos( \theta )$$  

三角形余弦定理：$c^2 = a^2 + b^2 - 2 \left| a \right| \left| b \right| \cos( \theta ) $，根据关系 $c = a - b$（a、b、c为三角形的三个边向量），可得：  
$$(a-b) \cdot (a-b) = a^2 + b^2 - 2 a \cdot b = a^2 + b^2 - 2 \left| a \right| \left| b \right| \cos( \theta )$$  
故若向量 a，b 已知，可以得到夹角 θ：  
$$ \theta = \arccos( \frac { \vec a \cdot \vec b } {\left| a \right| \left| b \right|} )$$

点乘的几何意义以及应用：  
①向量 b 在 向量 a 上的投影的长度（模）和向量 a 的长度（模）的乘积；  
②可以计算向量 a 和向量 b 之间的夹角，从而判断两个向量是否方向一致或者正交（垂直）：  
&emsp;&emsp; - $a \cdot b \gt 0$：向量方向一致，夹角为 0° 到 90° 之间；  
&emsp;&emsp; - $a \cdot b = 0$：向量正交，相互垂直；  
&emsp;&emsp; - $a \cdot b \lt 0$：向量方向相反，夹角为 90° 到 180° 之间；  

**Unity API：`Vector3.Dot(a, b)`**，可以直接利用单位向量来获取夹角余弦值：`Vector3.Dot(Vector3.normalized, Vector3.normalized)`

三、向量**叉乘 cross product**  
又称 *叉积* 、 *外积* 或者 *向量积* ，叉乘结果为**向量 vector**，并且结果向量（向量 c）与向量 a 和向量 b 组成的平面垂直，即**法向量**，在右手坐标系下方向遵守右手定则（四指从向量 a 旋转到向量 b，那么大拇指为向量 c 的方向）。由于 Unity 是左手坐标系，需要用左手确定方向。若 $\vec a = ( a_1, a_2, a_3 )$，$\vec b = ( b_1, b_2, b_3 )$，i、j、k 分别为X、Y、Z 轴方向的单位向量，公式为：  
$$\vec a \times \vec b = det {\begin{vmatrix} \vec i & \vec j & \vec k \\ a_1 & a_2 & a_3 \\ b_1 & b_2 & b_3 \end{vmatrix}} = (a_2b_3 - a_3b_2)\vec i - (a_1b_3 - a_3b_1)\vec j + (a_1b_2 - a_2b_1)\vec k $$  
即，向量 c 为：  
$$\vec c = \vec a \times \vec b = (a_2b_3 - a_3b_2,\ -a_1b_3 + a_3b_1,\ a_1b_2 - a_2b_1)$$

向量 C 的模长可被定义为：  
$$ \left| \vec c \right| = \left| \vec a \times \vec b \right| = \left| a \right| \left| b \right| \sin( \theta )$$

向量 c 的模长也就是向量 a 和 向量 b 构成的平行四边形的面积。据此可以得出**混合积**（三重积）的几何意义，x、y、z 为空间中三个向量：$ [x\ y\ z] = x \cdot (y \times z) = y \cdot (z \times x) = z \cdot (x \times y)$，其结果为三个向量定义的平行六面体的体积。

叉乘的几何意义以及应用：  
①求解向量 a 和向量 b 构成的平面的法线；
②计算点到线的距离，向量 a 的顶点到向量 b 的距离，即：  
$$\left| a \right| * \sin( \theta ) = \frac {\left| a \times b \right|} {\left| b \right|}$$  
③利用平面方程（即三元一次方程），计算点到面的距离，假设点 p 为 $( x_0, y_0, z_0 )$，则点 p 到向量 a 和向量 b 构成的平面的距离求解顺序如下：  
&emsp;&emsp; - 先求解向量 a 和向量 b 构成平面的法向量：$ \vec n = (A,\ B,\ C)$ ；  
&emsp;&emsp; - 再求解平面方程为 $Ax + By + Cz + D = 0$（D 由向量 a 和 b 代入可得）；  
&emsp;&emsp; - 点 p 到 $Ax + By + Cz + D = 0$ 平面的距离：  
$$d = \frac { \left| Ax_0 + By_0 + Cz_0 + D \right| } {\sqrt{A^2 + B^2 + C^2}} $$  

**Unity API：`Vector3.Cross(a, b)`**，可以利用单位向量来获取夹角正弦值：`Vector3.Cross(Vector3.normalized, Vector3.normalized).magnitude`。根据叉乘方向可以判断，向量与向量的左右位置信息。

## 三角函数
一、角度与弧度的转换  
PI 弧度 = 180° 即 1弧度 = 180/PI 角度，1° = PI/180 弧度  
=> 角度到弧度（degree to radian）：`角度 * Mathf.Deg2Rad` 等同于 `角度 * Mathf.PI/180`
=> 弧度到角度（radian to degree）：`角度 * Mathf.Rad2Deg` 等同于 `角度 * 180/Mathf.PI`

二、正弦余弦正切  
`Mathf.Sin(float radian)`；`Mathf.Cos(float radian)`；`Mathf.Tan(float radian)`  
`Mathf.ASin(float f)`；`Mathf.ACos(float f)`；`Mathf.ATan(float f)`

## 欧拉角 Euler angle
Unity 中的 Transform 面板里的 Rotaton 即表示**欧拉角**，即使用三个角度来描述物体在三维空间中的旋转。API 为`Vector3 eulerAngle = transform.eulerAngles`。注意，不是`transform.rotation`，rotation 是**四元数 Quaternion**。

旋转的顺序不同会导致不同的结果。但是在面板中，无论你按照 XYZ、ZXY、ZYX 等任何顺序输入，你会看到模型的结果都是一样的，这是因为 Unity 中的欧拉角采用的是 YXZ 的层次关系（或者说是按 ZXY 顺序旋转而得，即 Z 轴层级最低，Y 轴层级最高）。也就是说，Inspector 面板上显示的并不是物体绕自身局部坐标轴旋转的度数，也不是绕全局坐标轴旋转的度数，而是隐藏的**万向节 gimbal** 旋转轴旋转的度数，Z 在最底层，X 是 Z 的父项，Y 是 X 的父项。当我们旋转万向节中的三个轴时，会有以下现象：Z 轴旋转时，另外两个轴不旋转；X 轴旋转时，Z 轴随 X 轴旋转而旋转（Z 与 X 保持相对静止），Y 轴不动；Y 轴旋转时，X、Z 都随 Y 轴旋转而旋转（保持相对静止）。

> 区分万向节旋转轴、局部坐标系、全局坐标系的 X、Y、Z。刚开始初始状态下(0, 0, 0)，物体的万向节系统的三个轴不仅是和物体的全局坐标轴重合，也是和物体的局部坐标轴重合的。区别在于，物体绕局部坐标轴某个轴旋转，局部坐标系的另外两个轴也会旋转。物体绕全局坐标系某个轴旋转，物体局部坐标系的轴会旋转，全局坐标系不会跟着旋转。而物体根据欧拉角即面板调节，旋转情况如上面所示，这就会导致3个坐标系不统一的现象。  

> 总结：欧拉角由三个旋转值组成，三个旋转值会根据万向节的规则确定。Unity 中 Inspector 面板上的 rotation 的三个值对应的是物体的欧拉角，即通过万向节规则确定的三个旋转值。当我们调节 Inspector 面板上的 rotation 的值时，Unity 根据万向节规则计算出物体当前的朝向。**Unity 中的欧拉角采用 Y(Heading)--> X(Pitch) --> Z(Bank) 的欧拉角轴嵌套顺序**。

由于 Unity 是按照 ZXY 的顺序来旋转的，所以按照 Unity 的计算方式，总是最后再绕 Y 轴旋转。所以，当你滑动 Y ，连续改变欧拉角时，看来像是再绕着世界坐标系的 Y 轴旋转，而不是绕模型的局部坐标系的 Y 轴来旋转。所以你在 Unity 中，无论 XZ 的值时怎样的，只要你滑动 Y ，Unity 计算欧拉角的方式给你呈现的视觉效果就是像围绕世界坐标系的 Y 轴来旋转一样。

而当你滑动 Z 时，由于 Unity 总是先旋转绕 Z 轴旋转的，所以给你呈现的视觉效果是滑动 Z 时在场景中看到模型真的在绕模型的局部坐标系的 Z 轴旋转。而有时你滑动 X 呢，你会发现模型既不绕世界坐标系的 X 轴旋转，也不绕模型的局部坐标系的 X 轴旋转。

***欧拉角加深理解一：旋转1***  
`transform.Rotate(Vector3 eulers, Space relativeTo = Space.Self);`，Transform 的 Rotate 可以选择根据 Space.World，即世界坐标系，或根据 Space.Self，即自身局部坐标系，旋转：

代码1：`transform.Rotate(new Vector3(60, 45, 90), Space.Self);`  
代码2：`transform.Rotate(new Vector3(0, 0, 90), Space.Self);`，`transform.Rotate(new Vector3(45, 0, 0), Space.Self);`，`transform.Rotate(new Vector3(0, 60, 0), Space.Self);`

这两者所得结果不同，在代码1中是按照物体的万向节轴向（Space.Self 可理解为万向节轴向和局部坐标系重合）先绕 Z 轴旋转 90°，再绕 X 轴旋转 45°，再绕 Y 轴旋转 60°。在代码2中，先按照物体的局部坐标系旋转 90°，此时物体的局部坐标系改变了；之后以改变了的局部坐标系再旋转，绕 X 轴旋转 45°，旋转后，物体的局部坐标系又改变了；最后，绕改变后的轴向的 Y 轴旋转 60°。

代码3：`transform.Rotate(new Vector3(60, 45, 90), Space.World);`

代码3和代码1的结果是一致的，因为都是按照物体的万向节轴向先绕 Z 轴旋转 90°，再绕 X 轴旋转 45°，再绕 Y 轴旋转 60°，并且刚开始的局部坐标和全局坐标重合。可以尝试初始局部坐标和全局坐标不重合的情况下，使用代码3和代码1，结果不一致。

代码4：`transform.Rotate(new Vector3(0, 0, 90), Space.World);`，`transform.Rotate(new Vector3(45, 0, 0), Space.World);`，`transform.Rotate(new Vector3(0, 60, 0), Space.World);`

代码3和代码4的结果一样，因为根据万向轴顺序，并且初始状态下万向节旋转轴、局部坐标系、全局坐标系相互重合，先 Z 轴另外两个轴不旋转等同于先绕全局坐标系 Z 轴旋转。此时，因为万向轴 Z 轴变动后，X、Y 仍然和全局坐标系重合，此时万向节 X 轴旋转等同于绕全局坐标系 X 轴旋转。Y 轴同理。

> 注：代码4顺序变了，得到的结果也不一样的。旋转顺序不同会导致不同的结果，即使是跟着不变的全局坐标系旋转。这和矩阵变换没有交换律是一样的道理。

***欧拉角加深理解二：万向节锁 gimbal lock***  
万向节的特点是轴与轴之间存在父子关系，每个轴对另外两个轴的影响各不相同，也正是因为这个特点，导致出现了一些缺点。比如当我们将 X 轴旋转 90° 后，Z 轴和 Y 轴会变成平行状态，然后我们会发现旋转 Z 轴和 Y 轴的效果竟然是一模一样的。

***欧拉角加深理解三：旋转2***  
当我们在 Inspector 面板上按照 Z、X、Y 的顺序调整 rotation 的值时会发现，此时场景中物体的旋转效果是绕着物体的全局坐标轴进行旋转的。这是因为初始状态下(0, 0, 0)，物体的万向节系统的三个轴是和物体的全局坐标轴重合的，旋转 Z 轴不影响 X、Y 轴的位置和角度，所以旋转完 Z 轴后，X、Y 轴依然与惯性坐标轴重合。 

当我们在 Inspector 面板上按照 Y、X、Z 的顺序调整 rotation 的值时会发现，此时场景中物体的旋转效果是绕着物体的局部坐标轴进行旋转的。这是因为初始状态下(0, 0, 0)，物体的万向节系统的三个轴不仅是和物体的全局坐标轴重合，也是和物体的局部坐标轴重合的。旋转 Y 轴时会带动 X 和 Z 轴旋转，三个轴保持相对静止，X、Z 轴和局部坐标轴重合。同理往下。

***欧拉角优缺点***  
①仅使用三个数字表达方位，占用空间小；  
②三个角度（沿坐标轴旋转的单位）组成，直观，容易理解；  
③可以进行从一个方向到另一个方向旋转大于180度的角度；  
④存在万向节死锁问题；  
⑤对于一个方位，存在多个欧拉角描述，因此无法判断多个欧拉角代表的角位移是否相同。比如（250，0，0）与（290，180，180）为同一个欧拉角；  
⑥因为 Unity 的底层是通过四元数记录物体旋转的，并通过矩阵和四元数实现物体的旋转及插值。为了避免无穷种表示，Unity 引擎限制了角度范围，即沿 X 轴旋转限制在 -90 到 90 之间，沿 Y 与 Z 轴旋转限制在 0 到 360 之间（Inspector 面板显示为 -180 到 180），用脚本时会有这个限制，并且在万向节死锁的情况下，Z 轴旋转为 0（Inspector 面板显示 Y 轴为 0）。但在 Inspector 面板中直接调节没有这个限制，transfrom.eulerAngles 获取到的值，和在 Inspector 窗口的 Transfrom 组件中看到的旋转数值是不一样的，Unity 编辑器又经过了额外的封装，允许超限角度的显示输出和设定。

## 四元数 Quaternion


# 待梳理知识点

Unity 的**预制件 Prefab** 系统允许创建、配置和存储游戏对象及其所有组件、属性值和子游戏对象作为可重用资源。预制件资源充当模板，在此模板的基础之上可以在场景中创建新的预制件实例。


[SerializeField]  
[HideInInspector]  
[Range(num01,num02)]

# 记录可能很有用的方法
建议以后熟悉了unity后，全过一遍官方文档，记录一下不熟悉但是可能会很有用的方法

MonoBehaviour 的 Invoke 相关的方法
MonoBehaviour 的 Coroutine 相关的方法