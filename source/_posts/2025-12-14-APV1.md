---
title: Custom SRP 接入 Unity APV（一）
date: 2025-12-14 19:52:47
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2025/12/14/nqFkiKMduaWEc13.jpg
description: 本笔记的主要内容有 XXXXXXXXXXXXX。
---

> 在 YPipeline 中实现了 SSAO 相关算法之后，本想直接开始实现 SSGI（已经鸽了无数次了，笑）。然而，由于屏幕空间光照信息的缺失，屏幕空间的全局光照算法的效果较不稳定。所以最好的方式是将 SSGI 和其他基于世界空间的预烘焙全局光照技术相互结合，SSGI 来补充预烘焙光照缺失的高频信息，这样的 Hybrid Diffuse Global Illumination 效果更好。而之前 YPipeline 只实现了 Unity 内置的 Light Map 和 Light Probe Groups，然而这两个技术都是 Per Object 的，无法直接作为 SSGI 的 Fallback，为此我打算先接入 Per Pixel 的**自适应探针体积 Adaptive Probe Volumes (APV)**，当然 Reflection Probe 作为 SSGI fallback 也是可以的，但是 YPipeline 目前也只支持了 Per Object 的 Reflection Probe，也暂时无法使用，并且 Reflection Probe 作为 fallback 会有跳变的缺点，故我选择先了解和实现 APV。实现 Per Pixel 的 Reflection Probe 我打算在后面实现镜面反射全局光照算法时（比如 SSR 等）一同解决。同时了解 APV 也可以为日后理解其他 Probe-Based GI 比如 **PRTGI（Precomputed Radiance Transfer）**甚至是 **DDGI（Dynamic Diffuse Global Illumination）** 打下一定的基础。  
>   
> 本篇文章使用的 Unity 版本为 6000.3.1f1，SRP Core 版本为 17.3.0。

# APV 介绍
Unity APV 全名 **Adaptive Probe Volumes**，本质上属于 **Irradiance Volume** 技术。故这里先简单介绍一下 Irradiance Volume，参考的资料有如下：  

> **① Shirley, Peter. “The Irradiance Volume.” IEEE Computer Graphics and Applications, 1998.** ：https://www.sci.utah.edu/~bigler/images/msthesis/The%20irradiance%20volume.pdf ；  
> **② Irradiance Volumes for Games（GDC 2005）**：https://www.chrisoat.com/papers/Oat_GDC2005_IrradianceVolumesForGames.pdf ；  
> ③ Volumetric Global Illumination At Treyarch（SIGGRAPH 2016）：https://www.activision.com/cdn/research/Volumetric_Global_Illumination_at_Treyarch.pdf ；  
> ④ Multi-Scale Global Illumination in Quantum Break (SIGGRAPH 2015)：https://advances.realtimerendering.com/s2015/SIGGRAPH_2015_Remedy_Notes.pdf 。
> 因为 Irradiance Volume 即使时至今日都可以说是主流的全局光照技术，相关的演讲或文章是比较多的，SIGGRAPH、GDC 中关于 Global Illumination 的演讲多多少少都会提到 Irradiance Volume，有兴趣可以自己去查阅，但核心都是基于第一篇文章。

## Irradiance Volume 简单介绍
Irradiance Volume 也是基于 Light Probe 的技术，只不过使用 3D 纹理来存储数据，由此可以在 GPU 中逐像素地获取 Irradiance，而传统 Light Probe 只能逐物体地在 CPU 中插值。除此之外，还有烘焙速度快，自动化 Probes 摆放，更好地支持 Geometry LOD 以及可以让体积雾应用烘焙光照等优点。

根据论文（参考资料 ①），Irradiance Volume 实现的基本步骤如下：  
①将场景的包围盒分为多个统一大小的**网格 Grids**，称为 **first-level grid**，然后对于包含几何体的**网格单元 Cells** 进行再次划分，新划分出来的区域称为 **second-level grid**，这个方法其实就是**稀疏体素八叉树 Sparse Voxel Octree, SVO**。然后在网格的顶点位置放置光照探针，用于烘焙 irradiance 信息，如下图：  

<div align="center">  
<img src="https://s2.loli.net/2025/12/16/KycNjF94BhsImEg.png" width = "60%" height = "60%" alt="图1 - 使用双层网格划分区域，中图展示了 first-level grid，右图为 second-level grid。"/>
</div>

②然后就是在每个光照探针处向一定数量的方向采样 radiance，并计算存储 irradiance distribution function。论文因为比较早，用 uv 贴图的方式存储 irradiance，当时球谐光照应该还不成熟（球谐光照论文的公开是在 2003 年的，Precomputed Radiance Transfer 的公开在 SIGGRAPH 2001-2002）。现在最常用的存储 illumination/irradiance 的方式就是球谐函数，只不过在 Light Probe 中，我们常常使用三阶球谐系数来表示光照。在 Irridiance Volume 中，因为内存空间有限，我们一般会使用二阶球谐或者压缩的二阶球谐来存储光照信息。  
③查询 Irradiance Volume：Irridiance Volume 中的数据结构可分为 samples, cells, grids。Sample 就是存储 irradiance 的探针，Cell 就是包含 8 个探针的 box，Grid 则是三维 cell 序列。首先在 first-level grid 查找哪个 cell 包含了采样点，若 cell 中包含了 grid，则在 second-level grid 查找哪个 cell 包含了采样点，最后根据 cell 上的 samples 三线性插值出采样点的 irradiance。

## APV 的大致实现细节
Unity APV 正是基于 Irradiance Volume 开发的，在 2022 年以实验性包的形式出现，并推出了名为 Enemies – real-time cinematic teaser 的 demo 展示了 APV 的效果，以及在 SIGGRAPH 2022 的演讲 [Probe-based lighting, strand-based hair system, and physical hair shading in Unity’s ‘Enemies’](https://advances.realtimerendering.com/s2022/SIGGRAPH2022-Advances-Enemies-Ciardi%20et%20al.pdf) 中介绍了 APV 技术，最后于 Unity 6 版本正式推出。下面就根据演讲的 PPT 大致说明一下 APV 中的一些基本概念或技术实现细节。 

### APV 数据结构
①自适应摆放：靠近 geometry 的 probe 密度会更高，艺术家可以自己摆放额外的 probe volumes（local volume）作为应该摆放 probe 区域的标记，但是 volume 的所有数据都是存储在一个全局结构里的；  
②Bricks and Cells：probe 会被放置在称为 **Brick** 的基本单位当中，每个 Brick 最小包含 4 × 4 × 4 个 probes。注意这个 Brick 应该是 Irradiance Volume 中的概念 first-level grid 和 second-level grid 的合体，也就是 Grid，但是划分层级会更多。我实际测试下来，Brick 会根据设置的 probe 最小最大摆放距离被细分为 3 到 6 个层级，源码中我看到最大细分层级为 7。Brick 的具体划分是通过 SDF 实现的，靠近 geometry 时会被更精细地划分。然后 Brick 中的数据会被打包进名为 **Cell** 的单位，而 cell 是可流式加载的基本单元，数据会通过少量 CPU 暂存内存从硬盘加载至 GPU。

<div align="center">  
<img src="https://s2.loli.net/2025/12/18/9HF6Wd3Mz1XrBYm.png" width = "70%" height = "70%" alt="图2 - 左：Bricks，右：Cells"/>
</div>

③数据结构被分为了两部分：  
&emsp;&emsp; - **球谐池**：球谐纹理池是一组固定大小的 3D 纹理，纹理深度一定是 4（最小 Brick 的深度）。池的限制是每个 brick 中的数据必须是连续的，以便进行过滤和索引操作，但其他数据可以是相互脱节的，比如 Brick 存放的纹理位置。同时 SH 的数据会被压缩，压缩方式参考了 [Precomputed Global Illumination in Frostbite (GDC 2018)](https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/gdc2018-precomputedgiobalilluminationinfrostbite.pdf) ，L0 用更高的精度存储，L1/L2 用基于 L0 的函数表达，因此可以以更低精度存储。  
&emsp;&emsp; - **An indirection buffer**：包括一个 global cell indirection structure 和 per-cell brick indirection structure，这个 indirection buffer 的主要目的是从世界坐标索引至球谐池。  
&emsp;&emsp;&emsp;&emsp; 1. **Global Cell Indirection Structure**：这个数据结构用于存储每个 cell 的信息，每个 cell 都拥有一个条目，包括 cell 包含的 brick 的最高细分级别、cell 中所有 brick 的 AABB 以及指向 per-cell brick indirection 的索引。根据源码，我猜测就是名为 `_APVResCellIndices` 的 Structured Buffer，C# 代码在 SRP core -> Runtime -> Lighting -> ProbeVolume -> ProbeIndexOfIndices.cs 里；  
&emsp;&emsp;&emsp;&emsp; 2. **Per-Cell Brick Indirection structure**：这个数据结构用于存储每个 cell 中的 brick 的信息，每一个潜在的 brick 都拥有一个条目。比如，假设一个 cell 的三个维度都是 81 米，在 cell 内最小的 brick 是 3 米，那么这个 cell 就拥有 27 × 27 × 27 个条目，每个条目都存储了它在球谐纹理的位置坐标，以及该 brick 所处的细分级别 Subdivision Level。同时 Buffer 中 brick 的顺序是根据它相对于 cell 中心点的位置来决定的。根据源码，我猜测就是名为 `_APVResIndex` 的 Structured Buffer，C# 代码在 ProbeBrickIndex.cs 里；  

> 不得不吐槽 Unity 代码的命名 ε=( o｀ω′)ノ。  

④运行时采样：GPU 中计算索引的代码如下：  

<div align="center">  
<img src="https://s2.loli.net/2025/12/18/UH2FkzSxLoTnmRB.png" width = "70%" height = "70%" alt="图3 - GPU Runtime Sampling"/>
</div>

&emsp;&emsp; 1. 通过世界坐标可以计算出采样点位于哪个 cell 当中，由此可以获得其在 Global Cell Indirection Structure 中正确的条目；  
&emsp;&emsp; 2. 



## 如何使用 APV





# 在 SRP 中接入 APV

## CPU 中的工作

## GPU 中的工作