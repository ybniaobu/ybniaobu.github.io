---
title: Custom SRP 接入 Unity APV（一）
date: 2025-12-14 19:52:47
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2025/12/14/nqFkiKMduaWEc13.jpg
description: 本笔记的主要内容有 XXXXXXXXXXXXX。
---

> 在 YPipeline 中实现了 SSAO 相关算法之后，本想直接开始实现 SSGI（已经鸽了无数次了，笑）。然而，由于屏幕空间光照信息的缺失，屏幕空间的全局光照算法的效果较不稳定。所以最好的方式是将 SSGI 和其他基于世界空间的预烘焙全局光照技术相互结合，SSGI 来补充预烘焙光照缺失的高频信息，这样的 Hybrid Diffuse Global Illumination 效果更好。而之前 YPipeline 只实现了 Unity 内置的 Light Map 和 Light Probe Groups，然而这两个技术都是 Per Object 的，无法直接作为 SSGI 的 Fallback，为此我打算先接入 Per Pixel 的**自适应探针体积 Adaptive Probe Volumes (APV)**，当然 Reflection Probe 作为 SSGI fallback 也是可以的，但是 YPipeline 目前也只支持了 Per Object 的 Reflection Probe，也暂时无法使用，并且 Reflection Probe 作为 fallback 会有跳变的缺点，故我选择先了解和实现 APV。实现 Per Pixel 的 Reflection Probe 我打算在后面实现镜面反射全局光照算法时（比如 SSR 等）一同解决。同时了解 APV 也可以为日后理解其他 Probe-Based GI 比如 **PRTGI（Precomputed Radiance Transfer）**甚至是 **DDGI（Dynamic Diffuse Global Illumination）** 打下一定的基础。  
>   
> 本篇文章使用的 Unity 版本为 6000.3.1f1，SRP Core 版本为 17.3.0。

# APV 介绍
Unity APV 全名 **Adaptive Probe Volumes**，本质上属于 **Irradiance Volume** 技术。故这里先简单介绍一下 Irradiance Volume，参考的资料有如下：  

> **① Shirley, Peter. “The Irradiance Volume.” IEEE Computer Graphics and Applications, 1998.** ：https://www.sci.utah.edu/~bigler/images/msthesis/The%20irradiance%20volume.pdf ；  
> **② Irradiance Volumes for Games（GDC 2005）**：https://www.chrisoat.com/papers/Oat_GDC2005_IrradianceVolumesForGames.pdf ；  
> ③ Volumetric Global Illumination At Treyarch（SIGGRAPH 2016）：https://www.activision.com/cdn/research/Volumetric_Global_Illumination_at_Treyarch.pdf ；  
> ④ Multi-Scale Global Illumination in Quantum Break (SIGGRAPH 2015)：https://advances.realtimerendering.com/s2015/SIGGRAPH_2015_Remedy_Notes.pdf 。
> 因为 Irradiance Volume 即使时至今日都可以说是主流的全局光照技术，相关的演讲或文章是比较多的，SIGGRAPH、GDC 中关于 Global Illumination 的演讲多多少少都会提到 Irradiance Volume，有兴趣可以自己去查阅，但核心都是基于第一篇文章。

## Irradiance Volume 简单介绍
Irradiance Volume 也是基于 Light Probe 的技术，只不过使用 3D 纹理来存储数据，由此可以在 GPU 中逐像素地获取 Irradiance，而传统 Light Probe 只能逐物体地在 CPU 中插值。除此之外，还有烘焙速度快，自动化 Probes 摆放，更好地支持 Geometry LOD 以及可以让体积雾应用烘焙光照等优点。

根据论文（参考资料 ①），Irradiance Volume 实现的基本步骤如下：  
①将场景的包围盒分为多个统一大小的**网格 Grids**，称为 **first-level grid**，然后对于包含几何体的**网格单元 Cells** 进行再次划分，新划分出来的区域称为 **second-level grid**，这个方法其实就是**稀疏体素八叉树 Sparse Voxel Octree, SVO**。然后在网格的顶点位置放置光照探针，用于烘焙 irradiance 信息，如下图：  

<div align="center">  
<img src="https://s2.loli.net/2025/12/16/KycNjF94BhsImEg.png" width = "60%" height = "60%" alt="图1 - 使用双层网格划分区域，中图展示了 first-level grid，右图为 second-level grid。"/>
</div>

②然后就是在每个光照探针处向一定数量的方向采样 radiance，并计算存储 irradiance distribution function。论文因为比较早，用 uv 贴图的方式存储 irradiance，当时球谐光照应该还不成熟（球谐光照论文的公开是在 2003 年的，Precomputed Radiance Transfer 的公开在 SIGGRAPH 2001-2002）。现在最常用的存储 illumination/irradiance 的方式就是球谐函数，只不过在 Light Probe 中，我们常常使用三阶球谐系数来表示光照。在 Irridiance Volume 中，因为内存空间有限，我们一般会使用二阶球谐或者压缩的二阶球谐来存储光照信息。  
③查询 Irradiance Volume：Irridiance Volume 中的数据结构可分为 samples, cells, grids。Sample 就是存储 irradiance 的探针，Cell 就是包含 8 个探针的 box，Grid 则是三维 cell 序列。首先在 first-level grid 查找哪个 cell 包含了采样点，若 cell 中包含了 grid，则在 second-level grid 查找哪个 cell 包含了采样点，最后根据 cell 上的 samples 三线性插值出采样点的 irradiance。

## APV 的大致实现细节
Unity APV 正是基于 Irradiance Volume 开发的，在 2022 年以实验性包的形式出现，并推出了名为 Enemies – real-time cinematic teaser 的 demo 展示了 APV 的效果，以及在 SIGGRAPH 2022 的演讲 [Probe-based lighting, strand-based hair system, and physical hair shading in Unity’s ‘Enemies’](https://advances.realtimerendering.com/s2022/SIGGRAPH2022-Advances-Enemies-Ciardi%20et%20al.pdf) 中介绍了 APV 技术，最后于 Unity 6 版本正式推出。下面就根据演讲的 PPT 大致说明一下 APV 中的一些基本概念或技术实现细节。 

### APV 数据结构
①自适应摆放：靠近 geometry 的 probe 密度会更高，艺术家可以自己摆放额外的 probe volumes（local volume）作为应该摆放 probe 区域的标记，用于改变 probe 的稀疏，但是 volume 的所有数据都是存储在一个全局结构里的；  
②Bricks and Cells：probe 会被放置在称为 **Brick** 的基本单位当中，每个 Brick 最小包含 4 × 4 × 4 个 probes。注意这个 Brick 应该是 Irradiance Volume 中的概念 first-level grid 和 second-level grid 的合体，也就是 Grid，但是划分层级会更多。我实际测试下来，Brick 会根据设置的 probe 最小最大摆放距离被细分为 3 到 6 个层级，源码中我看到最大细分层级为 7。Brick 的具体划分是通过 SDF 实现的，靠近 geometry 时会被更精细地划分。然后 Brick 中的数据会被打包进名为 **Cell** 的单位，而 cell 是可流式加载的基本单元，数据会通过少量 CPU 暂存内存从硬盘加载至 GPU。

<div align="center">  
<img src="https://s2.loli.net/2025/12/18/9HF6Wd3Mz1XrBYm.png" width = "70%" height = "70%" alt="图2 - 左：Bricks，右：Cells"/>
</div>

③数据结构被分为了两部分：  
&emsp;&emsp; - **球谐池**：球谐纹理池是一组固定大小的 3D 纹理，纹理深度一定是 4（最小 Brick 的深度）。池的限制是每个 brick 中的数据必须是连续的，以便进行过滤和索引操作，但其他数据可以是相互脱节的，比如 Brick 存放的纹理位置。同时 SH 的数据会被压缩，压缩方式参考了 [Precomputed Global Illumination in Frostbite (GDC 2018)](https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/gdc2018-precomputedgiobalilluminationinfrostbite.pdf) ，L0 用更高的精度存储，L1/L2 用基于 L0 的函数表达，因此可以以更低精度存储。  
&emsp;&emsp; - **An indirection buffer**：包括一个 global cell indirection structure 和 per-cell brick indirection structure，这个 indirection buffer 的主要目的是从世界坐标索引至球谐池。  
&emsp;&emsp;&emsp;&emsp; 1. **Global Cell Indirection Structure**：这个数据结构用于存储每个 cell 的信息，每个 cell 都拥有一个条目，包括 cell 包含的 brick 的最高细分级别、cell 中所有 brick 的 AABB 以及指向 per-cell brick indirection 的索引。根据源码，我猜测就是名为 `_APVResCellIndices` 的 Structured Buffer，C# 代码在 SRP core -> Runtime -> Lighting -> ProbeVolume -> ProbeIndexOfIndices.cs 里；  
&emsp;&emsp;&emsp;&emsp; 2. **Per-Cell Brick Indirection structure**：这个数据结构用于存储每个 cell 中的 brick 的信息，每一个潜在的 brick 都拥有一个条目。比如，假设一个 cell 的三个维度都是 81 米，在 cell 内最小的 brick 是 3 米，那么这个 cell 就拥有 27 × 27 × 27 个条目，每个条目都存储了它在球谐纹理的位置坐标，以及该 brick 所处的细分级别 Subdivision Level。同时 Buffer 中 brick 的顺序是根据它相对于 cell 中心点的位置来决定的。根据源码，我猜测就是名为 `_APVResIndex` 的 Structured Buffer，C# 代码在 ProbeBrickIndex.cs 里；  

> 不得不吐槽 Unity 代码的命名 ε=( o｀ω′)ノ。  

④运行时采样：GPU 中计算索引的代码如下（这部分代码是在 PPT 里的，和目前版本的 SRP Core 里的有较大不同，但大致逻辑是相同的）  

<div align="center">  
<img src="https://s2.loli.net/2025/12/19/4rSgAoLUHQuI92B.png" width = "65%" height = "65%" alt="图3 - GPU Runtime Sampling"/>
</div>

代码 1、2 就是通过世界坐标可以计算出采样点位于哪个 cell 当中，由此可以获得其在 Global Cell Indirection Structure 中正确的索引，从而找到对应的 Per-Cell Brick Indirection structure。代码 3 就是计算采样点在 Brick 中的索引，从而获取其在 per cell indirection buffer 中的数据，即球谐纹理坐标（brickUVM）。代码 4 就是采样球谐数据。

### 解决 Artifact
①**Borders of Levels**：这个 artifact 的来源就是相邻的采样点周围的 probe 位于不同的细分层级，这会导致接缝现象，图片我就不展示了，解决方案就是增加 noise；  
②**Probes Within Geometry**：probe 可能会被摆放到几何体内部，Unity 会根据烘焙时 probe 可以看到多少 backface 来计算一个有效性分数，根据分数阈值（Lighting -> Probe Invalidity Settings -> Validity Threshold）来判断 Probe 是否是有效的。这个 artifact 的解决方案有两个，就是 Probe Invalidity Settings 中的两个，一为 **扩大 Dilation**，二为 **虚拟偏移 Virtual Offset**：  
&emsp;&emsp; - **Dilation**：就是在烘焙期间，无效的 probe 从其周围有效的数个 probe 中获取数据，并使用距离平方的倒数作为权重。这个方法的缺点是会加剧漏光 Leak 现象，因为无效的 probe 很可能会从室内扩大到室外场景。  
&emsp;&emsp; - **Virtual Offset**：就是烘焙期间，将几何体内部 probe 推出几何体。这个方法的缺点是推出的方向不可控，很有可能推到一个不好的位置，导致新的漏光现象，所以 Unity 建议 Dilation 和 Virtual Offset 一起使用。  
③**Light Leak**：漏光现象，Unity 解决漏光现象的方案都是运行时的方案，有如下：  
&emsp;&emsp; - **Biases**：跟 Shadow Map 类似，就是将采样点往法线或视角方向推，即 **Normal Bias** 和 **View Bias**，Unity 中在后处理 volume 中的 Adaptive Probe Volumes Options 就有这两个数据可以调整；  
&emsp;&emsp; - **Warping of Trilinear Sample Location**：就是通过改变三线性插值的位置来改变权重的大小，就是 Adaptive Probe Volumes Options 中的 **Leak Reduction Mode**，建议使用 Quality Mode，效果比较好。具体改变权重的方法是根据 probe 是否有效来计算的，即 Validity Based Weighting。

除了上述方法外，Unity 还提供了一个艺术家可以控制的 volume（PPT 里称为 Touch-up Volume），就是 Light -> **Probe Adjustment Volume**。Probe Adjustment Volume 可以覆盖指定区域的一些设置，比如无效化该区域的 probe，让更细粒度的控制成为了可能。

## 如何使用 APV
### 烘焙流程
这里以 URP 为基础，大致阐述一下如何进行 Irradiance Volume 烘焙。Irradiance Volume 烘焙本质上也使用了 Progressive Lightmapper 系统，流程跟 Lightmap 烘焙是基本一样的：  
①首先要在 URP Asset 里面将 **Light Probe System 改为 Adaptive Probe Volumes**；  
②在场景中**添加 Adaptive Probe Volume** 物体（在 Light 里），Mode 有三个，测试的话随便选一个就行。Global Mode 的意思就是 Volume 会包含所有 Baking Set 场景中的 Contribute Global Illumination 的 renderers；Scene Mode 就是包含当前场景中的 renderers；Local Mode 就是自己设置 volume 大小，当然 Local Mode 也可以用于调整不同区域的 probe 的密度；  
③将需要烘焙的光源设置为 **Mixed 或 Baked** 模式，并将场景中的物体的 MeshRenderer 组件中勾选上 **Contribute Global Illumination** 选项，并将 Receive Global Illumination 改为 **Light Probes**；  
④打开 Window > Rendering > Lighting 激活 **Baked Global Illumination**，然后 Generate Lighting 就可以烘焙了。注意，Lightmapping Settings 里的参数是会对烘焙效果产生影响的，建议将值都拉高。

我在 URP 建立了一个 ‌Cornell Box 场景，烘焙效果如下（Dilation 和 Virtual Offset 都开了，然后 Leak Reduction Mode 是 Quality，Sampling Noise 拉到了最大，只使用了 Normal Bias）：  

<div align="center">  
<img src="https://s2.loli.net/2025/12/19/NGf1hynRKUB7iv4.png" width = "50%" height = "50%" alt="图4 - URP 中 APV 测试效果"/>
</div>

我感觉效果还是挺好的，虽然有些许光照瑕疵的，可以尝试使用 Probe Adjustment Volume 调整，我这里就不尝试了。

### 其他说明
**① Baking Sets**  
如果同时加载了多个场景，此时就需要将这些场景都加入同一个 Baking Set，这样才能同时烘焙这些场景。创建 Baking Set 就在 Window > Rendering > Lighting 里，将 Baking Mode 设置为 Baking Set，创建新的 Baking Set 添加场景即可。  

**② 光照变换**  
因为 Irradiance Volume 本质上是静态的，所以实现运行时改变光照或者 time of day 需要额外的支持。对此 Unity 提供了两个不同的方案，一是**光照场景 Lighting Scenarios**，二是**天空遮蔽 Sky Occlusion**。  
&emsp;&emsp; - **Lighting Scenarios**：【书签】  
&emsp;&emsp; - **Sky Occlusion**：  
Lighting Scenarios 和 Sky Occlusion 可以搭配使用，Lighting Scenarios 更新太阳的位置，Sky Occlusion 更新天空光。


# 在 SRP 中接入 APV

## CPU 中的工作

## GPU 中的工作