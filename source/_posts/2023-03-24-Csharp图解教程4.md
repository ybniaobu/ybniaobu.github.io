---
title: 《C#图解教程》读书笔记（四）
date: 2023-03-24 22:56:39
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：XXXXXXXXXXXXXXXX 。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第二十一章 异步编程
## 什么是异步 Asynchrony
启动程序时，系统会在内存中创建一个新的**进程 process**。进程是构成运行程序的资源的集合，这些资源包括虚地址空间、文件句柄等等。

在进程内部，系统创建了一个**内核 kernal 对象**，叫做**线程 thread**，代表了真正执行的程序。一旦进程建立，系统会在 Main 方法的第一行语句处开始线程的执行。

关于线程的有关知识点：  
①默认情况下，一个进程只包含一个线程，从程序的开始一直执行到结束；  
②线程可以派生其他线程，因此在任意时刻，一个进程都可能包含不同状态的多个线程，它们执行程序的不同部分；  
③如果一个进程拥有多个线程，它们共享进程的资源；  
④系统为处理器执行所调度的单元是线程，不是进程。

本章将学习**异步编程**。在异步程序中，程序代码不需要按照编写的顺序严格执行。有时需要在一个新的线程中运行一部分代码，有时无需创建新的线程，但为了更好地利用单个线程的能力，需要改变代码的执行顺序。

我们先来看看 C#5.0 引入的一个用来构建异步方法的新特性 **async/await** 。接下来学习一些可实现其他形式的异步编程的特性，这些特性是 .NET 框架的一部分，但没有嵌入 C# 语言。相关主题包括 BackgroundWorker 类和 .NET 任务并行库。两者均通过新建线程来实现异步。本章最后会介绍编写异步程序的其他方式。

### 示例
为了演示和比较，先看一个不使用异步的示例。然后再看一个实现类似功能的异步程序。

在下面的代码示例中，MyDownloadString 类的方法 DoRun 执行以下任务：  
①创建 Stopwatch 类（位于 System.Diagnostics 命名空间）的一个实例并启动。该 Stopwatch 计时器用来测量代码中不同任务的执行时间；  
②然后两次调用 CountCharacters 方法，下载某网站的内容，并返问该网站包含的字符数。网站由 URL 字符串指定，作为第二个参数传入；
③接着四次调用 CountToALargeNumber 方法。该方法仅执行一个消耗一定时间的任务，并循环指定次数
④最后，打印两个网站的字符数。

``` C#
using System;
using System.Net;
using System.Diagnostics;

class MyDownloadString {
    Stopwatch sw = new Stopwatch();

    public void DoRun() {
        const int LargeNumber = 6_000_000;
        sw.Start();
        int t1 = CountCharacters( 1, "http://www.google.com" );
        int t2 = CountCharacters( 2, "http://www.illustratedcsharp.com" );
        CountToALargeNumber( 1, LargeNumber );
        CountToALargeNumber( 2, LargeNumber );
        CountToALargeNumber( 3, LargeNumber );
        CountToALargeNumber( 4, LargeNumber );

        Console.WriteLine($"Chars in http://www.google.com : { t1 }");
        Console.WriteLine($"Chars in http://www.illustratedcsharp.com: { t2 }");
    } 

    private int CountCharacters(int id, string uriString ) {
        WebClient wc1 = new WebClient();
        Console.WriteLine( "Starting call {0} : {1, 4:N0} ms",
                          id, sw.Elapsed.TotalMilliseconds );
        string result = wc1.DownloadString( new Uri( uriString ) );
        Console.WriteLine( " Call {0} completed: {1, 4:N0} ms",
                          id, sw.Elapsed.TotalMilliseconds );
        return result.Length;
    }

    private void CountToALargeNumber( int id, int value ) {
        for ( long i=0; i < value; i++ )
            ;
        Console.WriteLine( " End counting {0} : {1, 4:N0} ms",
                          id, sw.Elapsed.TotalMilliseconds );
    }
}

class Program
{
    static void Main() {
        MyDownloadString ds = new MyDownloadString();
        ds.DoRun();
    }
}
```

运行结果如下：

``` console
Starting call 1 :    6 ms
 Call 1 completed:  205 ms
Starting call 2 :  205 ms
 Call 2 completed:  695 ms
 End counting 1 :  713 ms
 End counting 2 :  733 ms
 End counting 3 :  751 ms
 End counting 4 :  767 ms
Chars in http://www.google.com : 49672
Chars in http://www.illustratedcsharp.com: 5164
```

如同结果所示，Call 1 和 Call 2 占用了大部分时间，不管哪次调用，大部分时间都浪费在了等待网站的响应上。

如果先发起两个 CountCharacter 调用，不先等待结果，同时执行4个 CountToALargeNumber 调用，然后在两个 CountCharacter 方法调用结束之后再获取结果就可以提升性能。

C# 最新的 async/await 特性就允许我们这么做。可以重写代码以运用该特性，如下所示：  
①当 DoRun 调用 CountCharactersAsync 时，CountCharactersAsync 将立即返回，然后才真正开始下载字符。它向调用方法返回的是一个 Task&lt;int&gt; 类型的占位符对象，表示它计划进行的工作。这个占位符最终将“返回”一个 int ；  
②这使得 DoRun 不用等待实际工作完成就可继续执行。下一条语句是再次调用 CountCharactersAsync ，同样会返回一个 Task&lt;int&gt; 对象；  
③接着，DoRun 可以继续执行，调用4次 CountToALargeNumber，同时 CountCharactersAsync 的两次调用继续它们的工作，基本上是等待（网站的响应）；  
④ DoRun 的最后两行从 CountCharactersAsync 调用返回的 Tasks 中获取结果。如果还没有结果，将阻塞并等待。

``` C#
using System.Threading.Tasks;

class MyDownloadString
{
    Stopwatch sw = new Stopwatch();

    public void DoRun() {
        const int LargeNumber = 6_000_000;
        sw.Start();

        Task<int> t1 = CountCharactersAsync( 1, "http://www.google.com" ); //保存结果的对象
        Task<int> t2 = CountCharactersAsync( 2, "http://www.illustratedcsharp.com" );
        CountToALargeNumber( 1, LargeNumber );
        CountToALargeNumber( 2, LargeNumber );
        CountToALargeNumber( 3, LargeNumber );
        CountToALargeNumber( 4, LargeNumber );

        Console.WriteLine( "Chars in http://www.google.com : {0}", t1.Result ); //获取结果
        Console.WriteLine( "Chars in http://www.illustratedcsharp.com: {0}", t2.Result );
    }

    private async Task<int> CountCharactersAsync( int id, string site ) { //上下文关键字async，Task<int>表示正在执行的工作，最终将返回int
        WebClient wc = new WebClient();
        Console.WriteLine( "Starting call {0} : {1, 4:N0} ms",
                            id, sw.Elapsed.TotalMilliseconds );

        string result = await wc.DownloadStringTaskAsync( new Uri( site ) ); //上下文关键字await
        Console.WriteLine( " Call {0} completed: {1, 4:N0} ms",
                            id, sw.Elapsed.TotalMilliseconds );
        return result.Length;
    }

    private void CountToALargeNumber( int id, int value ) {
        for ( long i=0; i < value; i++ ) ;
        Console.WriteLine( " End counting {0} : {1, 4:N0} ms",
                            id, sw.Elapsed.TotalMilliseconds );
    }
}

class Program {
    static void Main() {
        MyDownloadString ds = new MyDownloadString();
        ds.DoRun();
    }
}
```

运行结果如下：

``` console
Starting call 1 :    6 ms
Starting call 2 :  111 ms
 End counting 1 :  128 ms
 End counting 2 :  143 ms
 End counting 3 :  163 ms
 End counting 4 :  181 ms
 Call 1 completed:  244 ms
Chars in http://www.google.com : 49657
 Call 2 completed:  642 ms
Chars in http://www.illustratedcsharp.com: 5164
```

修改后的程序比原来快，因为 CountToALargeNumber 的4次调用是在 CountCharactersAsync 方法调用等待网络响应的时候进行的。所有这些工作都是在主线程完成的，没有创建任何额外的线程。

## async/await 特性的结构
如果一个程序调用某个方法，并在等待方法执行所有处理后才继续执行，我们称这种方法是**同步的 synchronous**。相反，**异步 asynchronous** 的方法在完成其所有工作之前就返回到调用方法。利用 C# 的 async/await 可以创建并使用异步方法。该特性由3个部分组成：  
①调用方法，该方法调用异步方法，然后在异步方法执行其任务的时候继续执行（可能在相同的线程上，也可能在不同的线程上）；  
②异步 async 方法，该方法异步执行其工作，然后立即返回到调用方法；  
③ await 表达式，用于异步方法内部，指明需要异步执行的任务。一个异步方法可以包含任意多个 await 表达式，不过如果一个都不包含，编译器会发出警告。

``` C#
class Program
{
    static void Main() //调用方法
    {
        ...
        Task<int> value = DoAsyncStuff.CalculateSumAsync(5, 6);
        ...
    }
}

static class DoAsyncStuff 
{
    public static async Task<int> CalculateSumAsync( int i1, int i2) //异步方法
    {
        int sum = await TaskEx.Run( () => GetSum( i1, i2 ) ); //await表达式
        return sum;
    }
    ...
}
```

## 什么是异步方法
异步方法在完成其工作之前即返回到调用方法，然后在调用方法继续执行的时候完成其工作。

在语法上，异步方法具有以下特点：  
①方法头中包含 async 方法修饰符；  
②包含一个或多个 await 表达式，表示可以异步完成的任务；  
③必须具备以下几种返回类型之一：void 、Task 、Task&lt;T&gt; 、ValueTask&lt;T&gt; 。第二种 Task 和第三种 Task&lt;T&gt; 的返回对象表示将在未来完成的工作，调用方法和异步方法可以继续执行；  
④任何具有公开可访问的 GetAwaiter 方法的类型；  
⑤异步方法的形参可以为任意类型、任意数量，但不能为 out 或 ref 参数；  
⑥按照约定，异步方法的名称应该以 Async 为后缀；  
⑦除了方法外，Lambda 表达式和匿名方法也可以作为异步对象。

``` C#
async Task<int> CountCharacterAsync( int id, string site ) //关键字async和返回类型Task<int>
{
    Console.WriteLine( "Starting CountCharacters" );
    WebClient wc = new WebClient();

    string result = await wc.DowloadStringTaskAsync( new Uri( site ) ); //await表达式

    Console.WriteLine( "CountCharacters Completed" );
    return result.Length;
}
```

***1. async 关键字***  
①异步方法在方法头中必须包含 async 关键字，且必须位于返回类型之前；  
②该修饰符只是标识该方法包含一个或多个 await 表达式。也就是说，它本身并不能创建任何异步操作；  
③ async 关键字是一个上下文关键字，也就是说除了作为方法修饰符（或 Lambda 表达式修饰符、匿名方法修饰符）之外，async 还可用作标识符。

***2. 返回类型必须是以下类型之一***  
① Task：如果调用方法不需要从异步方法中返回某个值，但需要检测异步方法的状态，那么异步方法可以返回一个 Task 类型的对象。在这种情况下，如果异步方法中包含任何 return 语句，则它们不能返回任何东西。下面的代码来自一个调用方法：

``` C#
Task someTask = DoStuff.CalculateSumAsync(5, 6);
...
someTask.Wait();
```

② Task&lt;T&gt;：如果调用方法要从调用中获取一个 T 类型的值，异步方法的返回类型就必须是Task&lt;T&gt;。调用方法将通过读取 Task 的 Result 属性来获取这个 T 类型的值。下面的代码来自一个调用方法，阐明了这一点：

``` C#
Task<int> value = DoStuff.CalculateSumAsync( 5, 6 );
...
Console.WriteLine($"Value: { value.Result }");
```

③ ValueTask&lt;T&gt;：这是一个值类型对象，它与 Task&lt;T&gt; 类似，但用于任务结果可能已经可用的情况。因为它是一个值类型，所以它可以放在栈上，而无须像 Task&lt;T&gt; 对象那样在堆上分配空间。因此在某些情况下可以提供性能。  

④ void：如果调用方法仅仅想执行异步方法，而不需要与它做任何进一步的交互时[这称为调用并忘记(fire and forget)]，异步方法可以返回 void 类型。这时，与上一种情况类似，即使异步方法中包含任何 return 语句，也不会返回任何东西。

⑤任何具有可访问的 GetAwaiter 方法的类型。

如本小节开头的代码，异步方法的返回类型为 Task&lt;int&gt; ，但方法体中不包含任何返回 Task&lt;int&gt; 类型对象的 return 语句。相反，方法最后的 return 语句返回了一个 int 类型的值。任何返回了 Task&lt;T&gt; 类型的异步方法，其返回值必须为 T 类型或可以隐式转换为 T 的类型。

***3. 以下代码，阐明了调用方法和异步方法在使用以上返回类型进行交互时所需的体系结构：*** 

①使用返回 Task&lt;int&gt; 对象的异步方法：

``` C#
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Task<int> value = DoAsyncStuff.CalculateSumAsync( 5,6 );
        //处理其他事情
        Console.WriteLine( "Value: {0}",value.Result );
    }
}

static class DoAsyncStuff
{
    public static async Task<int> CalculateSumAsync( int i1,int i2 )
    {
        int sum = await Task.Run( () => GetSum( i1, i2 ) );
        return sum;
    }
    private static int GetSum( int i1,int i2 )
    {
        return i1 + i2;
    }
}
```

②使用返回 Task 对象的异步方法：

``` C#
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Task someTask = DoAsyncStuff.CalculateSumAsync( 5, 6 );
        //处理其他事情
        someTask.Wait();
        Console.WriteLine( "Async stuff is done" );
    }
}
static class DoAsyncStuff
{
    public static async Task CalculateSumAsync( int i1, int i2 )
    {
        int value = await Task.Run( () => GetSum( i1, i2 ) );
        Console.WriteLine( "Value: {0}", value );
    }
    private static int GetSum( int i1, int i2 ) 
    {
        return i1 + i2;
    }
}
```

③使用“调用并忘记”的异步方法，并且使用了 Thread.Sleep 方法来暂停主线程，这样它就不会在异步方法完成之前退出：  

``` C#
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        DoAsyncStuff.CalculateSumAsync( 5, 6 );
        //处理其他事情
        Thread.Sleep( 200 );
        Console.WriteLine( "Program Exiting" );
    }
}
static class DoAsyncStuff
{
    public static async void CalculateSumAsync( int i1, int i2 )
    {
        int value = await Task.Run( () => GetSum( i1, i2 ) );
        Console.WriteLine( "Value: {0}",value );
    }
    private static int GetSum( int i1, int i2 )
    {
        return i1 + i2;
    }
}
```

④使用返回 ValueTask&lt;int&gt; 对象的异步方法：

``` C#
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        ValueTask<int> value = value = DoAsyncStuff.CalculateSumAsync( 0, 6 );
        //处理其他事情
        Console.WriteLine( $"Value: { value.Result }" );
        value = DoAsyncStuff.CalculateSumAsync( 5, 6 );
        //处理其他事情
        Console.WriteLine( $"Value: { value.Result }" );
    }

    static class DoAsyncStuff
    {
        public static async ValueTask<int> CalculateSumAsync( int i1, int i2 )
        {
            if (i1 == 0) //如果i1 == 0，则可以避免长时间运行任务
            {
                return i2;
            }
            int sum = await Task<int>.Run( () => GetSum( i1, i2 ) );
            return sum;
        }

        private static int GetSum( int i1, int i2 ) { return i1 + i2; }
    }
}
```

### 异步方法的控制流
异步方法的结构包含三个不同的区域：  
①第一个 await 表达式之前的部分：从方法开头到第一个 await 表达式之前的所有代码。这一部分应该只包含少量无须长时间处理的代码；  
② await 表达式：表示被异步执行的代码；  
③后续部分：await 表达式之后的方法中的其余代码。包括其执行环境，如所在线程信息、目前作用域内的变量值，以及当 await 表达式完成后重新执行时所需的其他信息。

``` C#
async Task<int> CountCharactersAsync( int id, string site )
{
    //第一个 await 表达式之前的部分
    Console.WriteLine( "Starting CountCharacters" );
    WebCline wc = new WebCline();

    //await 表达式
    string result = await wc.DownloadStringTaskAsync( new Uri( site ) );

    //后续部分
    Console.WriteLine( "CountCharacters Completed" );
    return result.Length;
}
```

<div  align="center">  
<img src="https://s2.loli.net/2023/04/02/Ag7VSjdKPB6srCG.png" width = "75%" height = "75%" alt="图99 - 贯穿一个异步方法的控制流"/>
</div>

上图阐明了一个异步方法的控制流。它从第一个 await 表达式之前的代码开始，正常 (同步地）执行直到遇见第一个 await 。这一区域实际上在第一个 await 表达式处结束，此时 await 任务还没有完成（大多数情况下如此)。当 await 的任务完成时，方法将继续同步执行。如果还有其他 await ，就重复上述过程。当达到 await 表达式时，异步方法将控制返回到调用方法。如果方法的返回类型为 Task 或 Task&lt;T&gt; 类型，将创建一个 Task 对象，表示需异步完成的任务和后续，然后将该 Task 返回到调用方法。

目前有两个控制流：一个异步方法内的和一个调用方法内的。异步方法内的代码完成以下工作：  
①异步执行 await 表达式的**等候任务 awaitable task** ；  
②当 await 表达式完成后，执行后续部分。后续部分本身也可能包含其他 await 表达式，这些表达式也将按照相同的方式处理，即异步执行 await 表达式，然后执行后续部分；  
③当后续部分遇到 return 语句或到达方法末尾时：如果方法返回类型为 void ，控制流将退出；如果方法返冋类型为 Task ，则后续部分设置 Task 的状态属性并退出。如果返回类型为 Task&lt;T&gt; 或 ValueTask&lt;T&gt; ，后续部分还将设置 Task 对象的 Result 属性。

同时，调用方法中的代码将继续其进程，从异步方法获取 Task&lt;T&gt; 或 ValueTask&lt;T&gt; 对象。当需要实际值时，就引用 Task 或 ValueTask 对象的 Result 属性。届时，如果异步方法设置了该属性，调用方法就能获得该值并继续。否则，它将暂停并等待该属性被设置，然后再继续执行。

异步方法第一次遇到 await 时所返回对象的类型，就是异步方法头中的返回类型，它与 await 表达式的返回值类型一点关系也没有。例如下面的代码，await 表达式返回一个 string 。但在方法的执行过程中，当到达 await 表达式时，异步方法返回到调用方法的是一个 Task&lt;int&gt; 对象，这正是该方法的返回类型：

``` C#
private async Task<int> CountCharactersAsync( string site )
{
    WebClient wc = new WebClient();

    string result = await wc.DownloadStringTaskAsync( new Uri( site ) );

    return result.Length;
}
```

异步方法的 return 语句也是如此，它并没有真正地返回某个值，它只是退出了。

***await 表达式***
await 表达式指定了一个异步执行的任务，语法：`await task`，由 await 关键字和一个**等候对象 awaitable object**（称为任务 task ）组成。这个任务可能是一个 Task 类型的对象，也可能不是。默认情况下，这个任务在当前线程异步运行。

一个**等候对象 awaitable object** 即是一个**等候类型 awaitable type** 的实例。awaitable 类型是指包含 GetAwaiter 方法的类型，该方法没有参数，返回一个 awaiter 类型的对象。

awaiter 类型包含以下成员：  
①`bool IsCompleted { get; }`  
②`void OnCompleted(Action);`  
③`void GetResult();`  
④`T GetResult();` T 为任意类型。

然而实除上，很少需要构建自己的 awaitable 。相反，应该使用 Task 或 ValueTask 类，它们可能是大多数程序员唯一需要使用的 awaitable 类型。

在 .NET 4.5 中，微软发布了大量新的和修订的异步方法（在 BCL 中），它们可返回 Task&lt;T&gt; 类型的对象。将这些放到 await 表达式中，它们将在当前线程中异步执行。比如在之前的很多示例中的 WebClient.DownloadStringTaskAsync 方法，它也是这些异步方法中的一个。以下代码阐明了其用法：

``` C#
Uri site = new Uri("http://www.illustratedcsharp.com" );
WebClient wc = new WebClient();
string result = await wc.DownloadStringTaskAsync( site );
```

尽管目前 BCL 中存在很多返回 Task&lt;T&gt; 类型对象的方法，可能仍然需要编写自己的方法，作为 await 表达式的任务。最简单的方式是在方法中使用 Task.Run 方法来创建一个 Task 。关于 Task.Run ，有一点非常重要，即它是在不同的线程上运行你的方法。

Task.Run 的一个签名如下，以 Func&lt;TReturn&gt; 委托为参数。如第20章所述，Func&lt;TReturn&gt; 是一个预定义的委托，它不包含任何参数，返回值的类型为 TReturn ：`Task Run( Func<TReturn> func )`

因此，要将你的方法传递给 Task.Run 方法，需要基于该方法创建一个委托。下面的代码展示了三种实现方式。其中，Get10 与 Func&lt;int&gt; 委托兼容，因为它没有参数并且返回 int ：  
①第一个实例（ DoWorkAsync 方法的前两行）使用 Get10 创建名为 ten 的 Func&lt;int&gt; 委托。然后在下一行将该委托用于 Task.Run 方法；  
②第二个实例在 Task.Run 方法的参数列表中创建 Func&lt;int&gt; 委托；  
③第三个实例没有使用 Get10 方法。而是使用了组成 Get10 方法体的 return 语句，将其用于与 Func&lt;int&gt; 委托兼容的 Lambda 表达式。该 Lambda 表达式将隐式转换为该委托。

``` C#
class MyClass
{
    public int Get10() //与Func<int>兼容
    {
        return 10;
    }

    public async Task DoWorkAsync()
    {
        Func<int> ten = new Func<int>(Get10);
        int a = await Task.Run(ten);
        
        int b = await Task.Run(new Func<int>(Get10));
        
        int c = await Task.Run(()=>{ return 10; });

        Console.WriteLine($"{ a } { b } { c }");
    }
}

class Program
{
    static void Main()
    {
        Task t = (new MyClass()).DoWorkAsync();
        t.Wait();
    }
}
```

运行结果如下：

``` console
10 10 10
```

在上面的示例中，使用的 Task.Run 的签名以 Func&lt;TResult&gt; 为参数。该方法共有8个重载，如下表所示：

| 返回类型 | 签名 |
| :---- | :---- |
| Task | Run( Action action ) |
| Task | Run( Action action, CancellationToken token ) |
| Task&lt;TResult&gt; | Run( Func&lt;TResult&gt; function ) |
| Task&lt;TResult&gt; | Run( Func&lt;TResult&gt; function, CancellationToken token ) |
| Task | Run( Func&lt;Task&gt; function ) |
| Task | Run( Func&lt;Task&gt; function, CancellationToken token ) |
| Task&lt;TResult&gt; | Run( Func&lt;Task&lt;TResult&gt;&gt; function ) |
| Task&lt;TResult&gt; | Run( Func&lt;Task&lt;TResult&gt;&gt; function, CancellationToken token ) |

下表展示了可作为 Task.Run 方法第一个参数的4个委托类型的签名:

| 委托类型 | 签名 | 含义 |
| :---- | :---- | :---- |
| Action | void Action( ) | 不需要参数且无返回值的方法 |
| Func&lt;TResult&gt; | TResult Func( ) | 不需要参数，但返回TResult类型对象的方法 |
| Func&lt;Task&gt; | Task Func( ) | 不需要参数，但返回简单Task对象的方法 |
| Func&lt;Task&lt;TResult&gt;&gt; | Task&lt;TResult&gt; Func( ) | 不需要参数，但返回Task&lt;T&gt;类型对象的方法 |

下面的代码展示了4个 await 语句，使用 Task.Run 方法来运行4种不同的委托类型所表示的方法：

