---
title: 《C#图解教程》读书笔记（四）
date: 2023-03-24 22:56:39
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：异步；命名空间与程序集；异常。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第二十一章 异步编程
## 什么是异步 Asynchrony
启动程序时，系统会在内存中创建一个新的**进程 process**。进程是构成运行程序的资源的集合，这些资源包括虚地址空间、文件句柄等等。

在进程内部，系统创建了一个**内核 kernal 对象**，叫做**线程 thread**，代表了真正执行的程序。一旦进程建立，系统会在 Main 方法的第一行语句处开始线程的执行。

关于线程的有关知识点：  
①默认情况下，一个进程只包含一个线程，从程序的开始一直执行到结束；  
②线程可以派生其他线程，因此在任意时刻，一个进程都可能包含不同状态的多个线程，它们执行程序的不同部分；  
③如果一个进程拥有多个线程，它们共享进程的资源；  
④系统为处理器执行所调度的单元是线程，不是进程。

本章将学习**异步编程**。在异步程序中，程序代码不需要按照编写的顺序严格执行。有时需要在一个新的线程中运行一部分代码，有时无需创建新的线程，但为了更好地利用单个线程的能力，需要改变代码的执行顺序。

我们先来看看 C#5.0 引入的一个用来构建异步方法的新特性 **async/await** 。接下来学习一些可实现其他形式的异步编程的特性，这些特性是 .NET 框架的一部分，但没有嵌入 C# 语言。相关主题包括 BackgroundWorker 类和 .NET 任务并行库。两者均通过新建线程来实现异步。本章最后会介绍编写异步程序的其他方式。

### 示例
为了演示和比较，先看一个不使用异步的示例。然后再看一个实现类似功能的异步程序。

在下面的代码示例中，MyDownloadString 类的方法 DoRun 执行以下任务：  
①创建 Stopwatch 类（位于 System.Diagnostics 命名空间）的一个实例并启动。该 Stopwatch 计时器用来测量代码中不同任务的执行时间；  
②然后两次调用 CountCharacters 方法，下载某网站的内容，并返问该网站包含的字符数。网站由 URL 字符串指定，作为第二个参数传入；
③接着四次调用 CountToALargeNumber 方法。该方法仅执行一个消耗一定时间的任务，并循环指定次数
④最后，打印两个网站的字符数。

``` C#
using System;
using System.Net;
using System.Diagnostics;

class MyDownloadString {
    Stopwatch sw = new Stopwatch();

    public void DoRun() {
        const int LargeNumber = 6_000_000;
        sw.Start();
        int t1 = CountCharacters( 1, "http://www.google.com" );
        int t2 = CountCharacters( 2, "http://www.illustratedcsharp.com" );
        CountToALargeNumber( 1, LargeNumber );
        CountToALargeNumber( 2, LargeNumber );
        CountToALargeNumber( 3, LargeNumber );
        CountToALargeNumber( 4, LargeNumber );

        Console.WriteLine($"Chars in http://www.google.com : { t1 }");
        Console.WriteLine($"Chars in http://www.illustratedcsharp.com: { t2 }");
    } 

    private int CountCharacters(int id, string uriString ) {
        WebClient wc1 = new WebClient();
        Console.WriteLine( "Starting call {0} : {1, 4:N0} ms",
                          id, sw.Elapsed.TotalMilliseconds );
        string result = wc1.DownloadString( new Uri( uriString ) );
        Console.WriteLine( " Call {0} completed: {1, 4:N0} ms",
                          id, sw.Elapsed.TotalMilliseconds );
        return result.Length;
    }

    private void CountToALargeNumber( int id, int value ) {
        for ( long i=0; i < value; i++ )
            ;
        Console.WriteLine( " End counting {0} : {1, 4:N0} ms",
                          id, sw.Elapsed.TotalMilliseconds );
    }
}

class Program
{
    static void Main() {
        MyDownloadString ds = new MyDownloadString();
        ds.DoRun();
    }
}
```

运行结果如下：

``` console
Starting call 1 :    6 ms
 Call 1 completed:  205 ms
Starting call 2 :  205 ms
 Call 2 completed:  695 ms
 End counting 1 :  713 ms
 End counting 2 :  733 ms
 End counting 3 :  751 ms
 End counting 4 :  767 ms
Chars in http://www.google.com : 49672
Chars in http://www.illustratedcsharp.com: 5164
```

如同结果所示，Call 1 和 Call 2 占用了大部分时间，不管哪次调用，大部分时间都浪费在了等待网站的响应上。

如果先发起两个 CountCharacter 调用，不先等待结果，同时执行4个 CountToALargeNumber 调用，然后在两个 CountCharacter 方法调用结束之后再获取结果就可以提升性能。

C# 最新的 async/await 特性就允许我们这么做。可以重写代码以运用该特性，如下所示：  
①当 DoRun 调用 CountCharactersAsync 时，CountCharactersAsync 将立即返回，然后才真正开始下载字符。它向调用方法返回的是一个 Task&lt;int&gt; 类型的占位符对象，表示它计划进行的工作。这个占位符最终将“返回”一个 int ；  
②这使得 DoRun 不用等待实际工作完成就可继续执行。下一条语句是再次调用 CountCharactersAsync ，同样会返回一个 Task&lt;int&gt; 对象；  
③接着，DoRun 可以继续执行，调用4次 CountToALargeNumber，同时 CountCharactersAsync 的两次调用继续它们的工作，基本上是等待（网站的响应）；  
④ DoRun 的最后两行从 CountCharactersAsync 调用返回的 Tasks 中获取结果。如果还没有结果，将阻塞并等待。

``` C#
using System.Threading.Tasks;

class MyDownloadString
{
    Stopwatch sw = new Stopwatch();

    public void DoRun() {
        const int LargeNumber = 6_000_000;
        sw.Start();

        Task<int> t1 = CountCharactersAsync( 1, "http://www.google.com" ); //保存结果的对象
        Task<int> t2 = CountCharactersAsync( 2, "http://www.illustratedcsharp.com" );
        CountToALargeNumber( 1, LargeNumber );
        CountToALargeNumber( 2, LargeNumber );
        CountToALargeNumber( 3, LargeNumber );
        CountToALargeNumber( 4, LargeNumber );

        Console.WriteLine( "Chars in http://www.google.com : {0}", t1.Result ); //获取结果
        Console.WriteLine( "Chars in http://www.illustratedcsharp.com: {0}", t2.Result );
    }

    private async Task<int> CountCharactersAsync( int id, string site ) { //上下文关键字async，Task<int>表示正在执行的工作，最终将返回int
        WebClient wc = new WebClient();
        Console.WriteLine( "Starting call {0} : {1, 4:N0} ms",
                            id, sw.Elapsed.TotalMilliseconds );

        string result = await wc.DownloadStringTaskAsync( new Uri( site ) ); //上下文关键字await
        Console.WriteLine( " Call {0} completed: {1, 4:N0} ms",
                            id, sw.Elapsed.TotalMilliseconds );
        return result.Length;
    }

    private void CountToALargeNumber( int id, int value ) {
        for ( long i=0; i < value; i++ ) ;
        Console.WriteLine( " End counting {0} : {1, 4:N0} ms",
                            id, sw.Elapsed.TotalMilliseconds );
    }
}

class Program {
    static void Main() {
        MyDownloadString ds = new MyDownloadString();
        ds.DoRun();
    }
}
```

运行结果如下：

``` console
Starting call 1 :    6 ms
Starting call 2 :  111 ms
 End counting 1 :  128 ms
 End counting 2 :  143 ms
 End counting 3 :  163 ms
 End counting 4 :  181 ms
 Call 1 completed:  244 ms
Chars in http://www.google.com : 49657
 Call 2 completed:  642 ms
Chars in http://www.illustratedcsharp.com: 5164
```

修改后的程序比原来快，因为 CountToALargeNumber 的4次调用是在 CountCharactersAsync 方法调用等待网络响应的时候进行的。所有这些工作都是在主线程完成的，没有创建任何额外的线程。

## async/await 特性的结构
如果一个程序调用某个方法，并在等待方法执行所有处理后才继续执行，我们称这种方法是**同步的 synchronous**。相反，**异步 asynchronous** 的方法在完成其所有工作之前就返回到调用方法。利用 C# 的 async/await 可以创建并使用异步方法。该特性由3个部分组成：  
①调用方法，该方法调用异步方法，然后在异步方法执行其任务的时候继续执行（可能在相同的线程上，也可能在不同的线程上）；  
②异步 async 方法，该方法异步执行其工作，然后立即返回到调用方法；  
③ await 表达式，用于异步方法内部，指明需要异步执行的任务。一个异步方法可以包含任意多个 await 表达式，不过如果一个都不包含，编译器会发出警告。

``` C#
class Program
{
    static void Main() //调用方法
    {
        ...
        Task<int> value = DoAsyncStuff.CalculateSumAsync(5, 6);
        ...
    }
}

static class DoAsyncStuff 
{
    public static async Task<int> CalculateSumAsync( int i1, int i2) //异步方法
    {
        int sum = await TaskEx.Run( () => GetSum( i1, i2 ) ); //await表达式
        return sum;
    }
    ...
}
```

## 什么是异步方法
异步方法在完成其工作之前即返回到调用方法，然后在调用方法继续执行的时候完成其工作。

在语法上，异步方法具有以下特点：  
①方法头中包含 async 方法修饰符；  
②包含一个或多个 await 表达式，表示可以异步完成的任务；  
③必须具备以下几种返回类型之一：void 、Task 、Task&lt;T&gt; 、ValueTask&lt;T&gt; 。第二种 Task 和第三种 Task&lt;T&gt; 的返回对象表示将在未来完成的工作，调用方法和异步方法可以继续执行；  
④任何具有公开可访问的 GetAwaiter 方法的类型；  
⑤异步方法的形参可以为任意类型、任意数量，但不能为 out 或 ref 参数；  
⑥按照约定，异步方法的名称应该以 Async 为后缀；  
⑦除了方法外，Lambda 表达式和匿名方法也可以作为异步对象。

``` C#
async Task<int> CountCharacterAsync( int id, string site ) //关键字async和返回类型Task<int>
{
    Console.WriteLine( "Starting CountCharacters" );
    WebClient wc = new WebClient();

    string result = await wc.DowloadStringTaskAsync( new Uri( site ) ); //await表达式

    Console.WriteLine( "CountCharacters Completed" );
    return result.Length;
}
```

***1. async 关键字***  
①异步方法在方法头中必须包含 async 关键字，且必须位于返回类型之前；  
②该修饰符只是标识该方法包含一个或多个 await 表达式。也就是说，它本身并不能创建任何异步操作；  
③ async 关键字是一个上下文关键字，也就是说除了作为方法修饰符（或 Lambda 表达式修饰符、匿名方法修饰符）之外，async 还可用作标识符。

***2. 返回类型必须是以下类型之一***  
① Task：如果调用方法不需要从异步方法中返回某个值，但需要检测异步方法的状态，那么异步方法可以返回一个 Task 类型的对象。在这种情况下，如果异步方法中包含任何 return 语句，则它们不能返回任何东西。下面的代码来自一个调用方法：

``` C#
Task someTask = DoStuff.CalculateSumAsync(5, 6);
...
someTask.Wait();
```

② Task&lt;T&gt;：如果调用方法要从调用中获取一个 T 类型的值，异步方法的返回类型就必须是Task&lt;T&gt;。调用方法将通过读取 Task 的 Result 属性来获取这个 T 类型的值。下面的代码来自一个调用方法，阐明了这一点：

``` C#
Task<int> value = DoStuff.CalculateSumAsync( 5, 6 );
...
Console.WriteLine($"Value: { value.Result }");
```

③ ValueTask&lt;T&gt;：这是一个值类型对象，它与 Task&lt;T&gt; 类似，但用于任务结果可能已经可用的情况。因为它是一个值类型，所以它可以放在栈上，而无须像 Task&lt;T&gt; 对象那样在堆上分配空间。因此在某些情况下可以提供性能。  

④ void：如果调用方法仅仅想执行异步方法，而不需要与它做任何进一步的交互时[这称为调用并忘记(fire and forget)]，异步方法可以返回 void 类型。这时，与上一种情况类似，即使异步方法中包含任何 return 语句，也不会返回任何东西。

⑤任何具有可访问的 GetAwaiter 方法的类型。

如本小节开头的代码，异步方法的返回类型为 Task&lt;int&gt; ，但方法体中不包含任何返回 Task&lt;int&gt; 类型对象的 return 语句。相反，方法最后的 return 语句返回了一个 int 类型的值。任何返回了 Task&lt;T&gt; 类型的异步方法，其返回值必须为 T 类型或可以隐式转换为 T 的类型。

***3. 以下代码，阐明了调用方法和异步方法在使用以上返回类型进行交互时所需的体系结构：*** 

①使用返回 Task&lt;int&gt; 对象的异步方法：

``` C#
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Task<int> value = DoAsyncStuff.CalculateSumAsync( 5,6 );
        //处理其他事情
        Console.WriteLine( "Value: {0}",value.Result );
    }
}

static class DoAsyncStuff
{
    public static async Task<int> CalculateSumAsync( int i1,int i2 )
    {
        int sum = await Task.Run( () => GetSum( i1, i2 ) );
        return sum;
    }
    private static int GetSum( int i1,int i2 )
    {
        return i1 + i2;
    }
}
```

②使用返回 Task 对象的异步方法：

``` C#
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        Task someTask = DoAsyncStuff.CalculateSumAsync( 5, 6 );
        //处理其他事情
        someTask.Wait();
        Console.WriteLine( "Async stuff is done" );
    }
}
static class DoAsyncStuff
{
    public static async Task CalculateSumAsync( int i1, int i2 )
    {
        int value = await Task.Run( () => GetSum( i1, i2 ) );
        Console.WriteLine( "Value: {0}", value );
    }
    private static int GetSum( int i1, int i2 ) 
    {
        return i1 + i2;
    }
}
```

③使用“调用并忘记”的异步方法，并且使用了 Thread.Sleep 方法来暂停主线程，这样它就不会在异步方法完成之前退出：  

``` C#
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        DoAsyncStuff.CalculateSumAsync( 5, 6 );
        //处理其他事情
        Thread.Sleep( 200 );
        Console.WriteLine( "Program Exiting" );
    }
}
static class DoAsyncStuff
{
    public static async void CalculateSumAsync( int i1, int i2 )
    {
        int value = await Task.Run( () => GetSum( i1, i2 ) );
        Console.WriteLine( "Value: {0}",value );
    }
    private static int GetSum( int i1, int i2 )
    {
        return i1 + i2;
    }
}
```

④使用返回 ValueTask&lt;int&gt; 对象的异步方法：

``` C#
using System;
using System.Threading.Tasks;

class Program
{
    static void Main()
    {
        ValueTask<int> value = value = DoAsyncStuff.CalculateSumAsync( 0, 6 );
        //处理其他事情
        Console.WriteLine( $"Value: { value.Result }" );
        value = DoAsyncStuff.CalculateSumAsync( 5, 6 );
        //处理其他事情
        Console.WriteLine( $"Value: { value.Result }" );
    }

    static class DoAsyncStuff
    {
        public static async ValueTask<int> CalculateSumAsync( int i1, int i2 )
        {
            if (i1 == 0) //如果i1 == 0，则可以避免长时间运行任务
            {
                return i2;
            }
            int sum = await Task<int>.Run( () => GetSum( i1, i2 ) );
            return sum;
        }

        private static int GetSum( int i1, int i2 ) { return i1 + i2; }
    }
}
```

### 异步方法的控制流
异步方法的结构包含三个不同的区域：  
①第一个 await 表达式之前的部分：从方法开头到第一个 await 表达式之前的所有代码。这一部分应该只包含少量无须长时间处理的代码；  
② await 表达式：表示被异步执行的代码；  
③后续部分：await 表达式之后的方法中的其余代码。包括其执行环境，如所在线程信息、目前作用域内的变量值，以及当 await 表达式完成后重新执行时所需的其他信息。

``` C#
async Task<int> CountCharactersAsync( int id, string site )
{
    //第一个 await 表达式之前的部分
    Console.WriteLine( "Starting CountCharacters" );
    WebCline wc = new WebCline();

    //await 表达式
    string result = await wc.DownloadStringTaskAsync( new Uri( site ) );

    //后续部分
    Console.WriteLine( "CountCharacters Completed" );
    return result.Length;
}
```

<div  align="center">  
<img src="https://s2.loli.net/2023/04/02/Ag7VSjdKPB6srCG.png" width = "75%" height = "75%" alt="图99 - 贯穿一个异步方法的控制流"/>
</div>

上图阐明了一个异步方法的控制流。它从第一个 await 表达式之前的代码开始，正常 (同步地）执行直到遇见第一个 await 。这一区域实际上在第一个 await 表达式处结束，此时 await 任务还没有完成（大多数情况下如此)。当 await 的任务完成时，方法将继续同步执行。如果还有其他 await ，就重复上述过程。当达到 await 表达式时，异步方法将控制返回到调用方法。如果方法的返回类型为 Task 或 Task&lt;T&gt; 类型，将创建一个 Task 对象，表示需异步完成的任务和后续，然后将该 Task 返回到调用方法。

目前有两个控制流：一个异步方法内的和一个调用方法内的。异步方法内的代码完成以下工作：  
①异步执行 await 表达式的**等候任务 awaitable task** ；  
②当 await 表达式完成后，执行后续部分。后续部分本身也可能包含其他 await 表达式，这些表达式也将按照相同的方式处理，即异步执行 await 表达式，然后执行后续部分；  
③当后续部分遇到 return 语句或到达方法末尾时：如果方法返回类型为 void ，控制流将退出；如果方法返冋类型为 Task ，则后续部分设置 Task 的状态属性并退出。如果返回类型为 Task&lt;T&gt; 或 ValueTask&lt;T&gt; ，后续部分还将设置 Task 对象的 Result 属性。

同时，调用方法中的代码将继续其进程，从异步方法获取 Task&lt;T&gt; 或 ValueTask&lt;T&gt; 对象。当需要实际值时，就引用 Task 或 ValueTask 对象的 Result 属性。届时，如果异步方法设置了该属性，调用方法就能获得该值并继续。否则，它将暂停并等待该属性被设置，然后再继续执行。

异步方法第一次遇到 await 时所返回对象的类型，就是异步方法头中的返回类型，它与 await 表达式的返回值类型一点关系也没有。例如下面的代码，await 表达式返回一个 string 。但在方法的执行过程中，当到达 await 表达式时，异步方法返回到调用方法的是一个 Task&lt;int&gt; 对象，这正是该方法的返回类型：

``` C#
private async Task<int> CountCharactersAsync( string site )
{
    WebClient wc = new WebClient();

    string result = await wc.DownloadStringTaskAsync( new Uri( site ) );

    return result.Length;
}
```

异步方法的 return 语句也是如此，它并没有真正地返回某个值，它只是退出了。

***await 表达式***
await 表达式指定了一个异步执行的任务，语法：`await task`，由 await 关键字和一个**等候对象 awaitable object**（称为任务 task ）组成。这个任务可能是一个 Task 类型的对象，也可能不是。默认情况下，这个任务在当前线程异步运行。

一个**等候对象 awaitable object** 即是一个**等候类型 awaitable type** 的实例。awaitable 类型是指包含 GetAwaiter 方法的类型，该方法没有参数，返回一个 awaiter 类型的对象。

awaiter 类型包含以下成员：  
①`bool IsCompleted { get; }`  
②`void OnCompleted(Action);`  
③`void GetResult();`  
④`T GetResult();` T 为任意类型。

然而实除上，很少需要构建自己的 awaitable 。相反，应该使用 Task 或 ValueTask 类，它们可能是大多数程序员唯一需要使用的 awaitable 类型。

在 .NET 4.5 中，微软发布了大量新的和修订的异步方法（在 BCL 中），它们可返回 Task&lt;T&gt; 类型的对象。将这些放到 await 表达式中，它们将在当前线程中异步执行。比如在之前的很多示例中的 WebClient.DownloadStringTaskAsync 方法，它也是这些异步方法中的一个。以下代码阐明了其用法：

``` C#
Uri site = new Uri("http://www.illustratedcsharp.com" );
WebClient wc = new WebClient();
string result = await wc.DownloadStringTaskAsync( site );
```

尽管目前 BCL 中存在很多返回 Task&lt;T&gt; 类型对象的方法，可能仍然需要编写自己的方法，作为 await 表达式的任务。最简单的方式是在方法中使用 Task.Run 方法来创建一个 Task 。关于 Task.Run ，有一点非常重要，即它是在不同的线程上运行你的方法。

Task.Run 的一个签名如下，以 Func&lt;TReturn&gt; 委托为参数。如第20章所述，Func&lt;TReturn&gt; 是一个预定义的委托，它不包含任何参数，返回值的类型为 TReturn ：`Task Run( Func<TReturn> func )`

因此，要将你的方法传递给 Task.Run 方法，需要基于该方法创建一个委托。下面的代码展示了三种实现方式。其中，Get10 与 Func&lt;int&gt; 委托兼容，因为它没有参数并且返回 int ：  
①第一个实例（ DoWorkAsync 方法的前两行）使用 Get10 创建名为 ten 的 Func&lt;int&gt; 委托。然后在下一行将该委托用于 Task.Run 方法；  
②第二个实例在 Task.Run 方法的参数列表中创建 Func&lt;int&gt; 委托；  
③第三个实例没有使用 Get10 方法。而是使用了组成 Get10 方法体的 return 语句，将其用于与 Func&lt;int&gt; 委托兼容的 Lambda 表达式。该 Lambda 表达式将隐式转换为该委托。

``` C#
class MyClass
{
    public int Get10() //与Func<int>兼容
    {
        return 10;
    }

    public async Task DoWorkAsync()
    {
        Func<int> ten = new Func<int>(Get10);
        int a = await Task.Run(ten);
        
        int b = await Task.Run(new Func<int>(Get10));
        
        int c = await Task.Run(()=>{ return 10; });

        Console.WriteLine($"{ a } { b } { c }");
    }
}

class Program
{
    static void Main()
    {
        Task t = (new MyClass()).DoWorkAsync();
        t.Wait();
    }
}
```

运行结果如下：

``` console
10 10 10
```

在上面的示例中，使用的 Task.Run 的签名以 Func&lt;TResult&gt; 为参数。该方法共有8个重载，如下表所示：

| 返回类型 | 签名 |
| :---- | :---- |
| Task | Run( Action action ) |
| Task | Run( Action action, CancellationToken token ) |
| Task&lt;TResult&gt; | Run( Func&lt;TResult&gt; function ) |
| Task&lt;TResult&gt; | Run( Func&lt;TResult&gt; function, CancellationToken token ) |
| Task | Run( Func&lt;Task&gt; function ) |
| Task | Run( Func&lt;Task&gt; function, CancellationToken token ) |
| Task&lt;TResult&gt; | Run( Func&lt;Task&lt;TResult&gt;&gt; function ) |
| Task&lt;TResult&gt; | Run( Func&lt;Task&lt;TResult&gt;&gt; function, CancellationToken token ) |

下表展示了可作为 Task.Run 方法第一个参数的4个委托类型的签名:

| 委托类型 | 签名 | 含义 |
| :---- | :---- | :---- |
| Action | void Action( ) | 不需要参数且无返回值的方法 |
| Func&lt;TResult&gt; | TResult Func( ) | 不需要参数，但返回TResult类型对象的方法 |
| Func&lt;Task&gt; | Task Func( ) | 不需要参数，但返回简单Task对象的方法 |
| Func&lt;Task&lt;TResult&gt;&gt; | Task&lt;TResult&gt; Func( ) | 不需要参数，但返回Task&lt;T&gt;类型对象的方法 |

下面的代码展示了4个 await 语句，使用 Task.Run 方法来运行4种不同的委托类型所表示的方法：

``` C#
static class MyClass
{
    public static async Task DoWorkAsync()
    {
        await Task.Run(() => Console.WriteLine(5.ToString())); //Action

        Console.WriteLine((await Task.Run(() => 6)).ToString()); //TResult Func()

        await Task.Run(() => Task.Run(() => Console.WriteLine(7.ToString()))); //Task Func()

        int value = await Task.Run(() => Task.Run(() => 8)); //Task<TResult> Func()
        Console.WriteLine(value.ToString());
    }
}

class Program
{
    static void Main()
    {
        Task t = MyClass.DoWorkAsync();
        t.Wait();
        Console.WriteLine("Press Enter key to exit");
        Console.Read();
    }
}
```

运行结果如下：

``` console
5
6
7
8
Press Enter key to exit
```

在能使用任何其他表达式的地方，都可以使用 await 表达式（只要位于异步方法内）。在上面的代码中，4个await表达式用在了3个不同的位置：①第一个和第三个实例将 await 表达式用作语句；②第二个实例将 await 表达式用作 WriteLine 方法的参数；③第四个实例将 await 表达式用作赋值语句的右端。

假设我们的某个方法不符合这4种委托形式。例如，假设有一个 GetSum 方法以两个 int 值作为输入，并返回这两个值的和。这与上述4个可接受的委托都不兼容，因为该方法有参数，而上面4个可接受的委托都不需要参数。要解决这个问题，可以用可接受的 Func 委托的形式创建一个 Lambda 函数，其唯一的行为就是运行 GetSum 方法，如该代码所示：`int value = await Task.Run(() => GetSum(5, 6));`。Lambda 函数 ( )=>GetSum(5, 6) 满足 Func&lt;TResult&gt; 委托，因为它没有参数，且返回单一的值。完整的示例如下：

``` C#
static class MyClass
{
    private static int GetSum(int i1, int i2)
    {
        return i1 + i2;
    }
    public static async Task DoWorkAsync()
    {
        int value = await Task.Run( ()=>GetSum(5, 6) ); //TResult Func()
        Console.WriteLine(value.ToString());
    }
}
class Program
{
    static void Main()
    {
        Task t = MyClass.DoWorkAsync();
        t.Wait();
        Console.WriteLine("Press Enter key to exit"); 
        Console.Read();
    }
}
```

运行结果如下：

``` console
11
Press Enter key to exit
```

### 取消一个异步操作
一些 .NET 异步方法允许你请求终止执行。你同样也可以在自己的异步方法中加入这个特性。System.Threading.Tasks 命名空间中有两个类是为此目的而设计的：CancellationToken 和 CancellationTokenSource ：  
① CancellationToken 对象包含一个任务是否应被取消的信息；  
② 拥有 CancellationToken 对象的任务需要定期检查其令牌（token）状态。如果 CancellationToken 对象的 IsCancellationRequested 属性为 true ，任务需停止其操作并返回；  
③ CancellationToken 是不可逆的，并且只能使用一次。也就是说，一旦 IsCancellationRequested 属性被设置为 true ，就不能更改了；  
④ CancellationTokenSource 对象创建可分配给不同任务的 CancellationToken 对象。任何持有 CancellationTokenSource 的对象都可以调用其 Cancel 方法，这会将 CancellationToken 的 IsCancellationRequested 属性设置为 true 。

下面的代码展示了如何使用 CancellationTokenSource 和 CancellationToken 来实现取消操作。注意，该过程是协同 cooperative 的，即调用 CancellationTokenSource 的 Cancel 时，它本身并不会执行取消操作，而是会将 CancellationToken 的 IsCancellationRequested 属性设置为 true 。包含 CancellationToken 的代码负责检查该属性，并判断是否需要停止执行并返回。

下面的代码展示了如何使用这两个取消类。如下所示代码并没有取消异步方法，而是在 Main 方法中间包含两行被注释的代码，它们触发了取消行为：

``` C#
class Program
{
    static void Main()
    {
        CancellationTokenSource cts = new CancellationTokenSource();
        CancellationToken token = cts.Token;

        MyClass mc = new MyClass();
        Task t = mc.RunAsync( token );

        //Thread.Sleep( 3000 ); //等待3秒
        //cts.Cancel(); //取消操作

        t.Wait();
        Console.WriteLine($"Was Cancelled: { token.IsCancellationRequested }");
    }
}

class MyClass
{
    public async Task RunAsync( CancellationToken ct )
    {
        if ( ct.IsCancellationRequested )
            return;
        await Task.Run( () => CycleMethod( ct ), ct );
    }

    void CycleMethod( CancellationToken ct )
    {
        Console.WriteLine( "Starting CycleMethod" );
        const int max = 5;
        for ( int i=0; i < max; i++ )
        {
            if ( ct.IsCancellationRequested ) //监控CancellationToken.
                return;
            Thread.Sleep( 1000 );
            Console.WriteLine($" { i+1 } of { max } iterations completed");
        }
    }
}
```

第一次运行时保留注释的代码，不会取消任务，产生的结果如下：

``` console
Starting CycleMethod
 1 of 5 iterations completed
 2 of 5 iterations completed
 3 of 5 iterations completed
 4 of 5 iterations completed
 5 of 5 iterations completed
Was Cancelled: False
```

如果运行 Main 方法中 Thread.Sleep 和 Cancel 语句，任务将在3秒后取消，产生的结果如下：

``` console
Starting CycleMethod
 1 of 5 iterations completed
 2 of 5 iterations completed
 3 of 5 iterations completed
Was Cancelled: True
```

***异常处理和 await 表达式***
将 await 表达式放在 try 语句内，使用 try...catch...finally 结构：

``` C#
class Program
{
    static void Main(string[] args)
    {
        Task t = BadAsync();
        t.Wait();
        Console.WriteLine($"Task Status : { t.Status }");
        Console.WriteLine($"Task IsFaulted: { t.IsFaulted }");
    }

    static async Task BadAsync()
    {
        try
        {
            await Task.Run(() => { throw new Exception(); });
        }
        catch
        {
            Console.WriteLine("Exception in BadAsync");
        }
    }
}
```

运行结果如下：

``` console
Exception in BadAsync
Task Status : RanToCompletion
Task IsFaulted: False
```

注意，尽管 Task 抛出了一个 Exception ，但在 Main 的最后，Task 的状态仍然 RanToCompletion 。这会让人感到很意外，因为异步方法抛出了异常。原因是以下两个条件成立：①Task 没有被取消，②没有未处理的异常。类似地，IsFaulted 属性为 False ，因为没有未处理的异常。

### 在调用方法中同步地等待任务
调用方法可以调用任意多个异步方法并接收它们返回的 Task 对象。然后你的代码会继续执行其他任务，但在某个点上可能会需要等待某个特殊 Task 对象完成，然后再继续。为此，Task 类提供了一个实例方法 **Wait** ，可以在 Task 对象上调用该方法。

``` C#
using System.Net;

static class MyDownloadString
{
    public static void DoRun()
    {
        Task<int> t = CountCharactersAsync( "http://www.illustratedcsharp.com" );

        t.Wait(); //等待任务t结束
        Console.WriteLine($"The task has finished, returning value { t.Result }.");
    }

    private static async Task<int> CountCharactersAsync( string site )
    {
        string result = await new WebClient().DownloadStringTaskAsync( new Uri( site ) );
        return result.Length;
    }
}

class Program
{
    static void Main()
    {
        MyDownloadString.DoRun();
    }
}
```

运行结果如下：

``` console
The task has finished, returning value 5164.
```

Wait 方法既可用于单一 Task 对象，也可以等待一组 Task 对象。对于一组 Task，有两种静态方法：① **WaitAll**：等待所有任务都结束；② **WaitAny**：等待某一个任务结束。这两个方法是同步方法且没有返回值。

比如以下这个简单的程序，它包含一个 DoRun 方法，该方法两次调用一个异步方法并获取其返回的两个 Task&lt;int&gt; 对象。然后，方法继续执行，检査任务是否完成并打印。方法最后会等待调用 Console.Read，该方法等待并接受键盘输入的字符。把它放在这里是因为不然的话，main 方法会异步任务完成前退出：

``` C#
using System.Net;
using System.Diagnostics;

class MyDownloadString
{
    Stopwatch sw = new Stopwatch();

    public void DoRun()
    {
        sw.Start();

        Task<int> t1 = CountCharactersAsync( 1, "http://www.google.com" );
        Task<int> t2 = CountCharactersAsync( 2, "http://www.illustratedcsharp.com" );

        //Task.WaitAll( t1, t2 );
        //Task.WaitAny( t1, t2 );

        Console.WriteLine( "Task 1: {0}Finished", t1.IsCompleted ? "" : "Not " );
        Console.WriteLine( "Task 2: {0}Finished", t2.IsCompleted ? "" : "Not " );
        Console.Read();
    }

    private async Task<int> CountCharactersAsync( int id, string site )
    {
        WebClient wc = new WebClient();
        string result = await wc.DownloadStringTaskAsync( new Uri( site ) );
        Console.WriteLine( " Call {0} completed: {1, 4:N0} ms",
                                        id, sw.Elapsed.TotalMilliseconds );
        return result.Length;
    }
}

class Program
{
    static void Main()
    {
        MyDownloadString ds = new MyDownloadString();
        ds.DoRun();
    }
}
```

代码产生的结果如下。注意，在检査这两个 Task 的 IsCompleted 方法时，没有一个是完成的：

``` console
Task 1: Not Finished
Task 2: Not Finished
 Call 1 completed:  222 ms
 Call 2 completed:  627 ms
```

如果取消 DoRun 中那两行代码中第一个的注释，代码会停止并等待任务全部完成，然后继续执行：

``` console
 Call 1 completed:  226 ms
 Call 2 completed:  601 ms
Task 1: Finished
Task 2: Finished
```

如果注释掉 WaitAll 方法，取消 WaitAny 方法调用的注释，代码结果如下：

``` console
 Call 1 completed:  227 ms
Task 1: Finished
Task 2: Not Finished
 Call 2 completed:  651 ms
```

WaitAll 和 WaitAny 分别还包含4个重载，除了完成任务之外，还允许以不同的方式继续执行，比如设置超时时间或使用 CancellationToken 来强制执行处理的后续部分。下表展示了这些重载方法：

| 签名 | 描述 |
| :---- | :---- |
| void WaitAll(params Task[ ] tasks ) | 等待所有任务完成 |
| bool WaitAll(Task[ ] tasks, int millisecondsTimeout ) | 等待所有任务完成。如果在超时时限内没有全部完成，则返回false并继续执行 |
| void WaitAll(Task[ ] tasks, CancellationToken token ) | 等待所有任务完成，或等待CancellationToke发出取消信号 |
| bool WaitAll(Task[ ] tasks, TimeSpan span ) | 等待所有任务完成。如果在超时时限内没有全部完成，则返回false并继续执行 |
| bool WaitAll(Task[ ] tasks, int millisecondsTimeout, CancellationToken token ) | 等待所有任务完成，或等待CancellationToke发出取消信号。如果在超时时限内没有发生上述情况，则返回false并继续执行 |
| void WaitAny(params Task[ ] tasks ) | 等待任意一个任务完成 |
| bool WaitAny (Task[ ] tasks, int millisecondsTimeout ) | 等待任意一个任务完成。如果在超时时限内没有全部完成，则返回false并继续执行 |
| void WaitAny (Task[ ] tasks, CancellationToken token ) | 等待任意一个任务完成，或等待CancellationToke发出取消信号 |
| bool WaitAny (Task[ ] tasks, TimeSpan span ) | 等待任意一个任务完成。如果在超时时限内没有全部完成，则返回false并继续执行 |
| bool WaitAny (Task[ ] tasks, int millisecondsTimeout, CancellationToken token ) | 等待任意一个任务完成，或等待CancellationToke发出取消信号。如果在超时时限内没有发生上述情况，则返回false并继续执行 |

### 在异步方法中异步地等待任务
有时在异步方法中，会希望用 await 表达式来等待 Task 。这时异步方法会返回到调用方法，但该异步方法会等待一个或所有任务完成。可以通过 **Task.WhenAll** 和 **Task.WhenAny** 方法来实现。这两个方法称为**组合子 combinator**。

下面的代码展示了一个使用 Task.WhenAll 方法的示例。该方法异步地等待所有与之相关的 Task 完成，不会占用主线程的时间。注意，await 表达式的任务就是调用 Task.WhenAll ：

``` C#
using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;

class MyDownloadString
{
    public void DoRun()
    {
        Task<int> t = CountCharactersAsync( "http://www.google.com",
                                        "http://www.illustratedcsharp.com");

        Console.WriteLine( "DoRun: Task {0}Finished", t.IsCompleted ? "" : "Not " );
        Console.WriteLine( "DoRun: Result = {0}", t.Result );
    }

    private async Task<int> CountCharactersAsync(string site1, string site2 )
    {
        WebClient wc1 = new WebClient();
        WebClient wc2 = new WebClient();
        Task<string> t1 = wc1.DownloadStringTaskAsync( new Uri( site1 ) );
        Task<string> t2 = wc2.DownloadStringTaskAsync( new Uri( site2 ) );

        List<Task<string>> tasks = new List<Task<string>>();
        tasks.Add( t1 );
        tasks.Add( t2 );

        await Task.WhenAll( tasks );

        Console.WriteLine( " CCA: T1 {0}Finished", t1.IsCompleted ? "" : "Not " );
        Console.WriteLine( " CCA: T2 {0}Finished", t2.IsCompleted ? "" : "Not " );

        return t1.IsCompleted ? t1.Result.Length : t2.Result.Length;
    }
}

class Program
{
    static void Main()
    {
        MyDownloadString ds = new MyDownloadString();
        ds.DoRun();
    }
}
```

运行结果如下：

``` console
DoRun: Task Not Finished
 CCA: T1 Finished
 CCA: T2 Finished
DoRun: Result = 49830
```

Task.WhenAny 组合子会异步地等待与之相关的某个 Task 完成。如果将上面的 await 表达式由调用 Task.WhenAll 改为调用 Task.WhenAny，并返回到程序，将产生以下输出结果：

``` console
DoRun: Task Not Finished
 CCA: T1 Finished
 CCA: T2 Not Finished
DoRun: Result = 49858
```

### Task.Delay 方法
Task.Delay 方法创建一个 Task 对象，该对象将暂停其在线程中的处理，并在一定时间之后完成。然而与 Thread.Sleep 阻塞线程不同的是，Task.Delay 不会阻塞线程，线程可以继续处理其他工作。代码如下：

``` C#
using System.Diagnostics;

class Simple
{
    Stopwatch sw = new Stopwatch();

    public void DoRun()
    {
        Console.WriteLine( "Caller: Before call" );
        ShowDelayAsync();
        Console.WriteLine( "Caller: After call" );
    }

    private async void ShowDelayAsync ( )
    {
        sw.Start();
        Console.WriteLine($" Before Delay: { sw.ElapsedMilliseconds }");
        await Task.Delay( 1000 );
        Console.WriteLine($" After Delay : { sw.ElapsedMilliseconds }");
    }
}

class Program
{
    static void Main()
    {
        Simple ds = new Simple ();
        ds.DoRun();
        Console.Read();
    }
}
```

运行结果如下：

``` console
Caller: Before call
 Before Delay: 0
Caller: After call
 After Delay : 991
```

Delay 方法包含4个重载，允许以不同方式来指定时间周期，同时还允许使用 CancellationToken 对象，如下表所示：

| 签名 | 描述 |
| :---- | :---- |
| Task Delay(int millisecondsDelay) | 在以毫秒表示的延迟时间到期后，返回完成的Task对象 |
| Task Delay(TimeSpan delay) | 在以.NET TimeSpan 对象表示的延迟时间到期后，返回完成的Task对象 |
| Task Delay(int millisecondsDelay, CancellationToken token) | 在以毫秒表示的延迟时间到期后，返回完成的Task对象。可通过取消令牌来取消该操作 |
| Task Delay(TimeSpan delay, CancellationToken token) | 在以.NET TimeSpan 对象表示的延迟时间到期后，返回完成的Task对象。可通过取消令牌来取消该操作 |

## GUI 程序中的异步操作
尽管本章目前的所有代码均为控制台应用程序，但实际上异步方法在 GUI 程序中尤为有用。

原因是 GUI 程序在设计上就要求所有的显示变化都必须在主 GUI 线程中完成，如点击按钮、展示标签、移动窗体等。Windows 程序是通过消息来实现这一点的，消息被放入由**消息泵 message pump** 管理的消息队列中。消息泵从队列中取出一条消息，并调用它的处理程序 handler 代码。当处理程序代码完成时，消息泵获取下一条消息并循环这个过程。

由于这种架构，处理程序代码就必须快捷，这样才不至于挂起并阻碍其他 GUI 行为的处理。如果某个消息的处理程序代码耗时过长，消息队列中的消息会产生积压，程序将失去响应，因为在那个长时间运行的处理程序完成之前，无法处理任何消息。

> 书中展示的是一个 WPF 程序，WPF 是微软替代 Windows Form 的 GUI 编程框架，需要使用 Visual Studio 来创建 WPF 程序，故暂不抄录。需要学习桌面应用程序时，再学习即可。目前主流为基于 Web 技术的桌面应用开发，而不是传统的 GUI 程序。

### Task.Yield 方法
Task.Yield 方法创建一个立即返回的 awaitable 。等待一个 Yield 可以让异步方法在执行后续部分的同时返回到调用方法。可以将其理解成离开当前的消息队列，回到队列末尾，让处理器有时间处理其他任务。

下面的示例代码展示了一个异步方法，程序每执行某个循环1000次就移交一次控制权。每次执行 Yield 方法，都会允许线程中的其他任务得以执行：

``` C#
static class DoStuff
{
    public static async Task<int> FindSeriesSum( int i1 )
    {
        int sum = 0;
        for ( int i=0; i < i1; i++ )
        {
            sum += i;
            if ( i % 1000 == 0 )
                await Task.Yield();
        }
        return sum;
    }
}

class Program
{
    static void Main()
    {
        Task<int> value = DoStuff.FindSeriesSum( 1_000_000 );
        CountBig( 100_000 ); CountBig( 100_000 );
        CountBig( 100_000 ); CountBig( 100_000 );
        Console.WriteLine( $"Sum: { value.Result }");
    }

    private static void CountBig( int p )
    {
        for ( int i=0; i < p; i++ )
            ;
    }
}
```

运行结果如下：

``` console
Sum: 1783293664
```

Yield 方法在 GUI 程序中非常有用，可以中断大量工作，让其他任务使用处理器。

## 使用异步 Lambda 表达式
到目前为止，本章只介绍了异步方法。但还可以使用异步匿名方法和异步 Lambda 表达式。这种构造尤其适合那些只有很少工作的事件处理程序。下面的代码片段将一个 Lambda 表达式注册为一个按钮点击事件的事件处理程序：

``` C#
startWorkButton.Click += async (sender,e )=> // Async lambda 表达式
    {  
        //处理点击处理程序工作
    }
```

> 未摘抄书中展示的简短的 WPF 程序示例。

## 一个完整的 GUI 示例
以下为一个完整的 WPF GUI 程序，包含一个状态条和取消操作。

下图左侧为示例程序的截图。点击按钮，程序将开始处理并更新进度条。处理过程完成将显示右上角的消息框。如果在处理完成前点击 Cancel 按钮，程序将显示右下角的消息框。

<div  align="center">  
<img src="https://s2.loli.net/2023/04/15/87YA3bfkg5QytC4.png" width = "60%" height = "60%" alt="图100 - 实现了状态条和取消操作的简单WPF程序的截图"/>
</div>

我们首先创建一个名为 WpfAwait 的 WPF 应用程序。按如下的代码修改 MainWindow.xaml 中的 XAML 标记：

```
<Window x:Class="WpfAwait.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Process and Cancel" Height="150 " Width="250">
    <StackPanel>
        <Button Name="btnProcess" Width="100" Click="btnProcess_Click"
            HorizontalAlignment="Right" Margin="10,15,10,10">Process</Button>
        <Button Name="btnCancel" Width="100" Click="btnCancel_Click"
            HorizontalAlignment="Right" Margin="10,0">Cancel</Button>
        <ProgressBar Name="progressBar" Height="20" Width="200" Margin="10"
            HorizontalAlignment="Right"/>
    </StackPanel>
</Window>
```

按如下的代码修改后台代码文件 MainWindow.xaml.cs ：

``` C#
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
namespace WpfAwait
{
    public partial class MainWindow : Window
    {
        CancellationTokenSource cancellationTokenSource;
        CancellationToken cancellationToken;

        public MainWindow()
        { InitializeComponent(); }

        private async void btnProcess_Click( object sender, RoutedEventArgs e )
        {
        btnProcess.IsEnabled = false;

        cancellationTokenSource = new CancellationTokenSource();
        cancellationToken = cancellationTokenSource.Token;

        int completedPercent = 0;

        for ( int i = 0; i < 10; i++ )
        {
            if ( cancellationToken.IsCancellationRequested )
                break;
            try
            {
                await Task.Delay( 500, cancellationToken );
                completedPercent = ( i + 1 ) * 10;
            }   
            catch ( TaskCanceledException ex )
            { completedPercent = i * 10; }
            progressBar.Value = completedPercent;
        }
        string message = cancellationToken.IsCancellationRequested
                ? string.Format( $"Process was cancelled at { completedPercent }%." )
                : "Process completed normally.";
        MessageBox.Show( message, "Completion Status" );

        progressBar.Value = 0;
        btnProcess.IsEnabled = true;
        btnCancel.IsEnabled = true;
        }

        private void btnCancel_Click( object sender, RoutedEventArgs e )
        {
            if ( !btnProcess.IsEnabled )
            {
                btnCancel.IsEnabled = false;
                cancellationTokenSource.Cancel();
            }
        }
    }
}
```

## BackgroundWorker 类
前面几节介绍了如何使用 async/await 特性来异步地处理任务。本节将学习另一种实现异步工作的方式，即**后台线程**。async/await 特性更适合那些需要在后台完成的不相关的小任务。

但有时候可能需要另建一个线程，在后台持续运行以完成某项工作，并不时地与主线程进行通信。 BackgroundWorker 类就是为此而生的。下图展示了此类的主要成员：

<div  align="center">  
<img src="https://s2.loli.net/2023/04/15/OjNhbVsfpX5SZo1.png" width = "70%" height = "70%" alt="图101 - BackgroundWorker 类的主要成员"/>
</div>

①图中的前两个属性用于设置后台任务是否可以把它的进度汇报给主线程以及是否支持从主线程取消。可以用第三个属性来检査后台任务是否正在运行；  
②类有三个事件，用于发送不同的程序事件和状态。需要写这些事件的事件处理方法来执行适合程序的行为：  
&emsp;&emsp;- 在后台线程开始的时候触发 DoWork ；  
&emsp;&emsp;- 在后台任务汇报状态的时候触发 ProgressChanged 事件；  
&emsp;&emsp;- 后台工作线程退出的时候触发 RunWorkerCompleted 事件；  
③三个方法用于初始化行为或改变状态：  
&emsp;&emsp;- 调用 RunWorkerAsync 方法获取后台线程并且执行 DoWork 事件处理程序；  
&emsp;&emsp;- 调用 CancelAsync 方法把 CancellationPending 属性设置为 true 。DoWork 事件处理程序需要检查这个属性来决定是否应该停止处理；  
&emsp;&emsp;- DoWork 事件处理程序（在后台线程）在希望向主线程汇报进度的时候，调用 ReportProgress 方法；  

<div  align="center">  
<img src="https://s2.loli.net/2023/07/03/epraFydsWv5m9Ow.png" width = "80%" height = "80%" alt="图102 - 控制任务执行流程的事件处理程序"/>
</div>

如上图，要使用 BackgroundWorker 类对象，需要写如上图所示的事件处理程序。第一个事件是必需的，因为它包含你希望在后台线程执行的代码，另外两个是可选的，是否使用取决于程序需要：  
①附加到 DoWork 事件的处理程序包含你希望在后台独立线程上执行的代码：  
&emsp;&emsp;- DoTheWork 的处理程序用渐变的方块表示，表明它在后台线程中执行；  
&emsp;&emsp;- 主线程调用 RunWorkerAsync 方法的时候触发 DoWork 事件；  
②这个后台线程通过调用 ReportProgress 方法与主线程通信。届时将触发 ProgressChanged 事件，主线程可以用附加到 ProgressChanged 事件上的处理程序处理事件；  
③附加到 RunWorkerCompleted 事件的处理程序应该包含后台线程完成 DoWork 事件处理程序的执行之后需要执行的代码。  

这些事件处理程序的委托如下，每一个任务都接受一个 object 对象的引用作为第一个参数，以及 EventArgs 类的特定子类作为第二个参数：

``` C#
void DoWorkEventHandler ( object sender, DoWorkEventArgs e )
void ProgressChangedEventHandler ( object sender, ProgressChangedEventArgs e )
void RunWorkerCompletedEventHandler ( object sender, RunWorkerCompletedEventArgs e)
```

下图演示了这些事件处理程序的 EventArgs 类的结构：

<div  align="center">  
<img src="https://s2.loli.net/2023/07/03/vjdTMipSPUBcCLZ.png" width = "80%" height = "80%" alt="图103 - BackgroundWorker事件处理程序使用的EventArgs类"/>
</div>

如果你编写了这些事件处理程序并将其附加到相应的事件，就可以这样使用这个类：  
①从创建 BackgroundWorker 类的对象并且对它进行配置开始：  
&emsp;&emsp;- 如果希望工作线程为主线程汇报进度，需要把 WorkerReportsProgress 属性设置为true；  
&emsp;&emsp;- 如果希望从主线程取消工作线程，就把 WorkerSupportsCancellation 属性设置为true；  
&emsp;&emsp;- 如果已经启用了 WorkerSupportsCancellation 属性，就可以调用对象的 CancelAsync 方法。该方法也不会取消后台线程，而是将对象的 CancellationPending 属性设置为 true 。运行在后台线程中的 DoWork 事件处理程序代码需要定期检査 CancellationPending 属性，来判断是否需要退出；  
②既然对象已经配置好了，我们就可以通过调用 RunWorkerAsync 方法来启动它。它会开一个后台线程并且发起 DoWork 事件并在后台执行事件处理程序。

同时，后台线程继续执行其计算任务，并且做以下几件事情：  
①如果 WorkerReportsProgress 属性是 true 并且后台线程需要为主线程汇报进度的话，它必须调用 BackgroundWorker 对象的 ReportProgress 方法。这会触发主线程的 ProgressChanged 事件，从而运行相应的事件处理程序；  
②如果 WorkerSupportsCancellation 属性启用的话，DoWork 事件处理程序代码应该定期检测 CancellationPending 属性来确定是否已经取消了；  
③如果后台线程没有取消，而是完成了其进程的话，可以通过设置 DoWorkEventArgs 参数的 Result 字段来返回结果给主线程；  
④在后台线程退出的时候会触发 RunWorkerCompleted 事件，其事件处理程序在主线程上执行。RunWorkerCompletedEventArgs 参数可以包含已完成后台线程的一些信息，比如返回值以及线程是否被取消了。

### 在 WPF 程序中使用 BackgroundWorker 类的示例代码
BackgroundWorker 类主要用于 GUI 程序，下面的程序展示了一个简单的 WPF 程序。该程序会生成下图中左图所示的窗体。点击 Process 按钮将开启后台线程，每半秒向主线程报告一次，并使进度条增长10%。最终，将展示右图所示的对话框。要创建这个 WPF 程序，需要在 Visual Studio 中创建名为 SimpleWorker 的 WPF 应用程序。将 MainWindow.xaml 文件中的代码修改为：

``` XML
<Window x:Class="SimpleWorker.MainMindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="l50" Width="250">
    <StackPanel>
        <ProgressBar Name="progressBar" Height="20" Width="200" Margin="10"/>
        <Button Name="btnProcess" Width="l00" Click="btnProcess_Click"  Margin="5">Process</Button>
        <Button Name="btnCancel" Width="l00" Click="btnCancel_Click" Margin="5">Cancel</Button>
    </StackPanel>
</Window>
```

将 MainWindow.xaml.cs 文件中的代码修改为：

``` C#
using System.Windows;
using System.ComponentModel;
using System.Threading;

namespace SimpleWorker
{
    public partial class MainWindow : Window
    {
        BackgroundWorker bgWorker = new BackgroundWorker();

        public MainWindow()
        {
            InitializeComponent();

            //设置BackgroundWorker属性
            bgWorker.WorkerReportsProgress = true;
            bgWorker.WorkerSupportsCancellation = true;

            //连接BackgroundWorker对象的处理程序
            bgWorker.DoWork +=  DoWork_Handler;
            bgWorker.ProgressChanged += ProgressChanged_Handler;
            bgWorker.RunWorkerCompleted += RunWorkerCompleted_Handler;
        }

        private void btnProcess_Click( object sender, RoutedEventArgs e)
        {
            if ( !bgWorker.IsBusy )
                bgWorker.RunWorkerAsync();
        }
        
        private void ProgressChanged_Handler( object sender,ProgressChangedEventArgs args )
        {
            progressBar.Value = args.ProgressPercentage;
        }

        private void DoWork_Handler( object sender, DoWorkEventArgs args )
        {
            BackgroundWorker worker = sender as BackgroundWorker;

            for ( int i = 1; i <= 10; i++ )
            {
                if ( worker.CancellationPending )
                {
                    args.Cancel = true; 
                    break;
                }
                else
                {
                    worker.ReportProgress( i * 10 );
                    Thread.Sleep( 500 );
                }
            }
        }

        private void RunWorkerCompleted_Handler( object sender,RunWorkerCompletedEventArgs args )
        {
            progressBar.Value = 0;

            if ( args.Cancelled )
                MessageBox.Show( "Process was cancelled.", "Process Cancelled");
            else
                MessageBox.Show( "Process completed normally.", "Process Completed" );
        }

        private void btnCancel_Click( object sender, RoutedEventArgs e )
        {
            bgWorker.CancelAsync();
        }
    }
}
```

## 并行循环
本节将简要介绍任务并行库（ Task Parellel Library )。它是 BCL 中的一个类库，极大地简化了并行编程。其细节比本章要介绍的多得多，这里只介绍其中的两个简单的结构：**Parallel.For** 循环和 **Parallel.ForEach** 循环。这两个结构位于 System.Threading.Tasks 命名空间中。

标准的 for 和 foreach 循环结构，每次迭代都依赖于上次迭代。如果迭代之间彼此独立，并且程序运行在多核处理器的机器上，若能将不同的迭代放在不同的处理器上并行处理的话，可以节省不少时间。Parallel.For 循环和 Parallel.ForEach 循环结构可以这么做。

这两个结构的形式是包含输入参数的方法。Parallel.For 方法有12个重载，最简单的签名如下：`void Parallel.For( int fromInclusive, int toExclusive, Action<int> body );`  
①fromInclusive 参数是迭代系列的第一个整数；  
②toExclusive 参数是比迭代系列最后一个索引号大1的整数。也就是说，和表达式 index&lt;ToExclusive&gt; 一样；  
③body 是接受单个输入参数的委托，body 的代码在每一次迭代中执行一次。

如下代码：

``` C#
using System;
using System.Threading.Tasks; //必须使用该命名空间

namespace ExampleParallelFor
{
    class Program
    {
        static void Main( )
        {
            Parallel.For( 0, 15, i =>
                Console.WriteLine($"The square of { i } is { i * i }"));
        }
    }
}
```

运行结果如下，注意，不能确保迭代的执行次序：

``` console
The square of 2 is 4
The square of 0 is 0
The square of 9 is 81
The square of 10 is 100
The square of 11 is 121
The square of 12 is 144
The square of 13 is 169
The square of 14 is 196
The square of 8 is 64
The square of 1 is 1
The square of 3 is 9
The square of 4 is 16
The square of 5 is 25
The square of 7 is 49
The square of 6 is 36
```

另一个示例如下，以并行方式填充一个整数数组，把值设置为迭代索引号的平方。在本例中，即使迭代在执行时可能为并行并且为任意顺序，但是最后结果始终是一个包含前50个平方数的数组，并且按顺序排列：

``` C#
class Program
{
    static void Main()
    {
        const int maxValues=50;
        int[] squares = new int[maxValues];

        Parallel.For( 0, maxValues, i => squares[i]=i*i );
    }
}
```

另外一个并行循环结构是 Parallel.ForEach 方法。该方法有相当多的重载，其中最简单的如下：`static ParallelLoopResult ForEach<TSource>( IEnumerable<TSource> source,
Action<TSource> body)`  
①TSource 是集合中对象的类型；  
②source 是一组 TSource 对象的集合；  
③body 是要应用到集合中每一个元素的 Lambda 表达式。

代码示例如下，TSource 是 string ，source 是 string[ ] ：

``` C#
using System;
using System.Threading.Tasks;

namespace ParallelForeach1
{
    class Program
    {
        static void Main()
        {
            string[] squares=new string[] 
                    {"We", "hold", "these", "truths", "to", "be", "self-evident",
                    "that", "all", "men", "are", "created", "equal"};

            Parallel.ForEach(squares,
                s => Console.WriteLine
                        ( string.Format($"\"{ s }\" has { s.Length } letters") ));
        }
    }
}
```

## 其他异步编程模式
除了上面介绍的 async/await 特性和 BackgroundWorker 类，或者任务并行库。还可以使用旧模式来产生异步代码。

当委托对象调用时，它调用了其调用列表中包含的方法。就像程序调用方法一样，这是同步完成的。如果委托对象在调用列表中只有一个方法（之后会叫做**引用方法 referenced method**），它就可以异步执行这个方法。委托类有两个方法，叫做 **BeginInvoke** 和 **EndInvoke** ，它们就是用来实现这个目的的。这两个方法以如下方式使用：  
①调用委托的 BeginInvoke 方法时，它开始在一个独立线程上执行引用方法，并且立即返回到原始线程。原始线程可以继续，而引用方法会在线程池的线程中并行执行；  
②当程序希望获取已完成的异步方法的结果时，可以检查 BeginInvoke 返回的 IAsyncResult 的 IsCompleted 属性，或调用委托的 EndInvoke 方法来等待委托完成。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/03/cTU3vd4wHlOWGSj.png" width = "80%" height = "80%" alt="图104 - 异步方法调用的标准模式"/>
</div>

上图展示了使用上述过程的三种标准模式，这些模式的区别在于原始线程如何知道发起的线程已经完成：  
①在**等待直到完成 wait-until-done** 模式中，在发起了异步方法以及做了一些其他处理之后，原始线程就中断并且等异步方法完成之后再继续；  
②在**轮询 polling** 模式中，原始线程定期检查发起的线程是否完成，如果没有则可以继续做一些其他的事情；  
③在**回调 callback** 模式中，原始线程一直执行，无需等待或检査发起的线程是否完成。在发起的线程中的引用方法完成之后，发起的线程就会调用回调方法，由回调方法在调用 EndInvoke 之前处理异步方法的结果。

## BeginInvoke 和 EndInvoke
有关 BeginInvoke 的重要事项如下：  
①在调用 BeginInvoke 时，参数列表中的实际参数组成如下：  
&emsp;&emsp;- 引用方法需要的参数；  
&emsp;&emsp;- 两个额外的参数 —— callback 参数和 state 参数；  
②BeginInvoke 从线程池中获取一个线程并且让引用方法在新的线程中开始运行；  
③BeginInvoke 返回给调用线程一个实现 IAsyncResult 接口的对象的引用。这个接口引用包含了在线程池线程中运行的异步方法的当前状态，原始线程然后可以继续执行。

如下代码所示，它从线程池中获取一个线程并且在新的线程上开始运行 Sum 方法，将3和5作为实参；它收集新线程的状态信息并且把 IAsyncResult 接口的引用返回给调用线程来提供这些信息。调用线程把它保存在一个叫做iar的变量中：

``` C#
delegate long MyDel( int first, int second ); //委托声明
...
static long Sum(int x, int y){ return x + y; } //方法匹配委托
...
MyDel del = new MyDel(Sum); //创建委托对象
IAsyncResult iar = del.BeginInvoke( 3, 5, null, null ); //调用了委托对象的BeginInvoke方法并且提供了两个委托参数3和5，以及两个BeginInvoke的参数callback和state，在本例中都设为null
```

EndInvoke 方法用来获取由异步方法调用返回的值，并且释放线程使用的资源。EndInvoke 有如下的特性：  
①它接受一个由 BeginInvoke 方法返回的 IAsyncResult 对象的引用作为参数，并找到它关联的线程；  
②如果线程池的线程已经退出，则 EndInvoke 做如下的事情：  
&emsp;&emsp;- 清理退出线程的状态并释放资源；  
&emsp;&emsp;- 找到引用方法返回的值并且把它作为返回值返回。  
③如果当 EndInvoke 被调用时线程池的线程仍然在运行，调用线程就会停止并等待它完成，然后再清理并返回值。因为 EndInvoke 是为开启的线程进行清理，所以必须确保对每一个 BeginInvoke 都调用EndInvoke ；  
④如果异步方法触发了异常，在调用 EndInvoke 时会抛出异常。

如下的代码行给出了一个调用 EndInvoke 并从异步方法获取值的示例。我们必须把 IAsyncResult 对象的引用作为参数：`long result = del.EndInvoke( iar );`

EndInvoke 提供了从异步方法调用的所有输出，包括 ref 和 out 参数。如果委托的引用方法有 ref 或 out 参数，它们必须包含在 EndInvoke 的参数列表中，并且在 IAsyncResult 对象引用之前，如下所示：`long result = del.EndInvoke(out someInt, iar);`

### 等待直到完成模式
如下是一个使用该模式的示例：

``` C#
using System;
using System.Threading;  //For Thread.Sleep()

delegate long MyDel( int first, int second );   //声明委托类型

class Program
{
    static long Sum(int x, int y) //声明异步方法
    {
        Console. WriteLine("                Inside Sum");
        Thread.Sleep(100);

        return x + y;
    }

    static void Main( )
    {
        MyDel del = new MyDel(Sum);

        Console.WriteLine( "Before BeginInvoke");
        IAsyncResult iar = del.BeginInvoke(3, 5, null, null); //开抬异步调用
        Console.WriteLine( "After BeginInvoke");

        Console.WriteLine( "Doing stuff" ); 

        long result = del.EndInvoke( iar ); //等待结果并获取结果
        Console.WriteLine( "After EndInvoke: {0}", result );
    }
}
```

输出如下：

``` console
Before BeginInvoke
After BeginInvoke
Doing stuff
                Inside Sum
After EndInvoke: 8
```

> .NET Core 不支持 BeginInvoke 和 EndInvoke ，需要使用 .NET Framework

### AsyncResult 类
BeginInvoke 返回一个 IASyncResult 接口的引用（该接口由一个 AsyncResult 类型的类实现）。AsyncResult 类代表了异步方法的状态。下图演示了该类中的一些重要部分：

<div  align="center">  
<img src="https://s2.loli.net/2023/07/03/f5eAkrGPEM7ZFI1.png" width = "60%" height = "60%" alt="图105 - AsyncResult 类对象"/>
</div>

有关该类的重要事项如下：  
①当调用委托对象的 BeginInvoke 方法时，系统创建了一个 AsyncResult 类的对象。然而，它不返回类对象的引用，而是返回对象中包含的 IAsyncResult 接口的引用；  
②AsyncResult 对象包含一个叫做 AsyncDelegate 的属性，它返回一个指向被调用来启动异步方法的委托的引用。但是，这个属性是类对象的一部分而不是接口的一部分；  
③IsCompleted 属性返回一个布尔值，表示异步方法是否完成；  
④AsyncState 属性返回对象的一个引用，作为 BeginInvoke 方法调用时的 state 参数。它返回 object 类型的引用，在回调模式一节中解释这部分内容。

### 轮询模式
在轮询模式中，原始线程发起了异步方法的调用，做一些其他处理，然后使用 IAsyncResult 对象的 IsComplete 属性来定期检査开启的线程是否完成。如果异步方法已经完成，原始线程就调用 EndInvoke 并继续。否则，它做一些其他处理，然后过一会儿再检査。在下面的示例中，“处理” 仅仅是由0数到10 000 000：

``` C#
delegate long MyDel(int first, int second);

class Program
{
    static long Sum(int x, int y)
    {
        Console.WriteLine("               Inside Sum");
        Thread.Sleep(100);

        return x + y;
    }

    static void Main()
    {
        MyDel del = new MyDel(Sum);
        
        IAsyncResult iar = del.BeginInvoke(3, 5, null, null); //开始异步调用
        Console.WriteLine("After BeginInvoke");
        
        while ( !iar.IsCompleted ) //检查异步方法是否完成
        {
            Console.WriteLine("Not Done");

            //继续处理
            for (long i = 0; i < 10000000; i++)
                ; //空语句
        }

        Console.WriteLine("Done");
        
        long result = del.EndInvoke(iar); //调用EndInvoke来获取接口并进行清理
        Console.WriteLine("Result: {0}", result);
    }
}
```

输出如下：

``` console
After BeginInvoke
Not Done
               Inside Sum
Not Done
Not Done
Done
Result: 8
```

### 回调模式
在之前的等待直到完成 wait-until-done 模式以及轮询 polling 模式中，初始线程仅在知道开启的线程已经完成之后才继续它的控制流程。然后，它获取结果并继续。

回调 callback 模式的不同之处在于，一旦初始线程发起了异步方法，它就自己管自己了，不再考虑同步。当异步方法调用结束之后，系统调用一个用户自定义的方法来处理结果，并且调用委托的 EndInvoke 方法。这个用户自定义的方法叫做**回调方法 callback method** 或回调。

BeginInvoke 参数列表中最后的两个额外参数由回调方法使用：  
①第一个参数 callback 是回调方法的名字；  
②第二个参数 state 可以是 null 或要传入回调方法的一个对象的引用。可以通过使用 IAsyncResult 参数的 AsyncState 属性来获取这个对象，参数的类型是 object 。

***1.回调方法***  
回调方法的签名和返回类型必须和 AsyncCallback 委托类型所描述的形式一致。这需要方法接受一个 IAsyncResult 类型的参数并且返回类型是 void ，如下所示：`void AsyncCallback( IAsyncResult iar )`

有多种方式可以为 BeginInvoke 方法提供回调方法。由于 BeginInvoke 中的 callback 参数是 AsyncCallback 类型的委托，可以以委托形式提供；或者也可以只提供回调方法名称，让编译器创建委托，两种形式是完全等价的：

``` C#
IAsyncResult iar1 = del.BeginInvoke(3, 5, new AsyncCallback(CallWhenDone), null); //使用回调方法创建委托

IAsyncResult iar2 = del.BeginInvoke(3, 5, CallWhenDone, null); //只需要用回调方法的名字
```

BeginInvoke 的另一个额外参数用来向回调方法发送对象。它可以是任何类型的对象，因为参数类型是 object ，所以在回调方法中，必须将其转换成正确的类型。

***2.在回调方法内调用 EndInvoke***
在回调方法内，代码应该调用委托的 EndInvoke 方法来处理异步方法执行后的输出值。要调用委托的 EndInvoke 方法，肯定需要委托对象的引用，而它在初始线程中，不在开启的线程中。

如果不将 BeginInvoke 的 state 参数作其他目的，可以使用它给回调方法发生委托的引用，如下所示：`IAsyncResult iar = del.BeginInvoke(3, 5, CallWhenDone, del); //把委托对象作为状态参数发送`。否则，可以从作为参数发送给方法的 IAsyncResult 对象中提取出委托的引用，如下代码和图所示：

<div  align="center">  
<img src="https://s2.loli.net/2023/07/04/AawS7OGcDJs4l8L.png" width = "70%" height = "70%" alt="图106 - 从回调方法内部提取出委托的引用"/>
</div>

``` C#
using System.Runtime.Remoting.Messaging;  //包含AsyncResult类

void CallWhenDone( IAsyncResult iar )
{
    AsyncResult ar = (AsyncResult) iar; //获取类对象的引用
    MyDel del = (MyDel) ar.AsyncDelegate; //获取委托的引用

    long Sum = del.EndInvoke( iar );      //调用 EndInvoke
    ...
}
```

上述代码的说明：  
①给回调方法的参数只有一个，就是刚结束的异步方法的 IAsyncResult 接口的引用。请记住，IAsyncResult 接口对象在 AsyncResult 类对象内部；  
②尽管 IAsyncResult 接口没有委托对象的引用，封装它的 AsyncResult 类对象却有委托对象的引用。所以，示例代码方法体的第一行就通过转换接口引用为类类型来获取类对象的引用。变量 ar 现在就有类对象的引用；  
③有了类对象的引用，就可以使用类对象的 AsyncDelegate 属性并且把它转化为合适的委托类型。这样就得到了委托引用，我们可以用它来调用 EndInvoke 。

把上面知识点汇总的使用回调模式的示例如下：

``` C#
using System;
using System.Runtime.Remoting.Messaging; //调用AsyncResult类型
using System.Threading;

delegate long MyDel(int first, int second);

class Program
{
    static long Sum(int x, int y)
    {
        Console.WriteLine("              Inside Sum");
        Thread.Sleep(100);
        return x + y;
    }
    static void CallWhenDone(IAsyncResult iar)
    {
        Console.WriteLine("              Inside CallWhenDone.");
        AsyncResult ar = (AsyncResult) iar;
        MyDel del = (MyDel)ar.AsyncDelegate;

        long result = del.EndInvoke(iar);
        Console.WriteLine("              The result is: {0}.",result);
    }
    static void Main()
    {
        MyDel del = new MyDel(Sum);

        Console.WriteLine("Before BeginInvoke");
        IAsyncResult iar =
            del.BeginInvoke(3, 5, new AsyncCallback(CallWhenDone), null);

        Console.WriteLine("Doing more work in Main.");
        Thread.Sleep(500);
        Console.WriteLine("Done with Main. Exiting.");
    }
}
```

运行结果如下：

``` console
Before BeginInvoke
Doing more work in Main.
              Inside Sum
              Inside CallWhenDone.
              The result is: 8.
Done with Main. Exiting.
```

## 计时器
计时器提供了另外一种定期地重复运行异步方法的方式。尽管在 .NET BCL 中有好几个可用的 Timer 类，但在这里只会介绍 System.Threading 命名空间中的那个。

有关计时器类需要了解的重要事项如下：  
①计时器在每次到期之后调用回调方法。回调方法必须是 TimerCallback 委托形式的，结构为`void TimerCallback( object state )`。它接受一个 object 类型作为参数，并且返回类型是 void ；  
②当计时器到期之后，系统会从线程池中的一个线程上设置回调方法，提供 state 对象作为其参数，并且开始运行；  
③可以设置的计时器的一些特性如下：  
&emsp;&emsp;- dueTime 是回调方法首次被调用之前的时间。如果 dueTime 被设为特殊的值 Timeout.Infinite ，则计时器不会开始。如果被设置为0，则回调函数会被立即调用；  
&emsp;&emsp;- period 是两次成功调用回调函数之间的时间间隔。如果它的值设置为 Timeout.Infinite ，则回调在首次被调用之后不会再被调用；  
&emsp;&emsp;- state 可以是 null 或在每次回调方法执行时要传入的对象的引用。

Timer 类的构造函数接受回调方法名称、dueTime 、period 以及 state 作为参数。Timer 有很多构造函数，最为常用的形式为：`Timer( TimerCallback callback, object state, uint dueTime, uint period )`

一旦 Timer 对象被创建，可以使用 Change 方法来改变它的 dueTime 或 period 方法。示例如下：

``` C#
using System;
using System.Threading;

namespace Timers
{
    class Program
    {
        int TimesCalled = 0;

        void Display(object state)
        {
            Console.WriteLine("{0} {1}", (string)state, ++TimesCalled);
        }

        static void Main()
        {
            Program p = new Program();

            Timer myTimer = new Timer     //2s后第一次调用，每1s重复一次
                (p.Display, "Processing timer event", 2000, 1000);
            Console.WriteLine("Timer started.");

            Console.ReadLine();
        }
    }
}
```

运行结果如下：

``` console
Timer started.
Processing timer event 1
Processing timer event 2
Processing timer event 3
Processing timer event 4
Processing timer event 5
```


# 第二十二章 命名空间和程序集

## 引用其他程序集
之前讲过，编译器接受源代码文件并生成一个名为**程序集 assembly** 的输出文件。这一章将详细阐述程序集以及它们是如何生成和部署的，还会看到命名空间是如何帮助组织类型的。

在项目中，可能会使用来自其他程序集的类或类型。这些程序集可能来自 BCL 或第三方供应商，或是自己创建的（编译器可以把 .cs 编译为 .dll）。这些程序集称为**类库 class libraries** ，而且它们的程序集文件的名称通常以 **.dll 扩展名**而不是 .exe 扩展名结尾。

如果要使用定义在其他程序集中的类，需要给编译器一个到该程序集的引用，给出它的名称和位置。在 Visual Studio 中，可以用下面的方法把引用添加到项目：  
①选择 Solution Explorer ，并在该项目名下找到 References 目录。References 目录包含项目使用的程序集的列表；  
②右键单击 References 目录并选择 Add Reference 。有5个标签页，可以以不同的方法找到类库；  
③可以选择 Browse 标签，选择需要的 DLL 文件，点击 OK 按钮，引用就被加入到项目了。

### mscorlib 库
Console 类被定义在名称为 mscorlib 的程序集中的 mscorlib.dll 的文件里。然而，你不会看到这个程序集被列在 References 目录中。程序集 mscorlib.dll 含有 C# 类型以及大部分 .NET 语言的基本类型的定义。在编译 C# 程序时，它必须总是被引用，所以 Visual Studio 不把它显示在 References 目录中。

## 命名空间
如果使用了多个不同的程序集，可能会遇到类名重复的问题，从而导致类名冲突。这就带来了命名空间名和**命名空间 namespaces** 的定义：  
①可以把命名空间名视为一个字符串（在字符串中可以使用点），它加在类名或类型名的前面并且通过点进行分隔；  
②包括命名空间名、分隔点，以及类名的完整字符串叫做类的**完全限定名 fully qualified name**；  
③命名空间是共享命名空间名的一组类和类型。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/04/kYGBqH6dn8lcDos.png" width = "75%" height = "75%" alt="图107 - 命名空间是共享同一命名空间名的一组类型定义"/>
</div>

可以通过在包含类型声明的源文件中声明命名空间来创建命名空间。如下代码演示了声明命名空间的语法，然后在命名空间声明的大括号中声明你的所有类和其他类型，那么这些类型就是这个命名空间的成员了：

``` C#
namespace NamespaceName //关键字和命名空间名
{
    TypeDeclarations
}
```

在本章稍后会阐述 using 别名指令，以解决不得不在完全限定名称中重复输入的麻烦。

### 命名空间名称
命名空间名称的一些要点如下：  
①命名空间名称可以是任何有效标识符，并且区分大小写；  
②另外，*命名空间名称可以包括句点符号*，用于把类型组织成层次。

这里列出了一些在 .NET BCL 中的命名空间的名称：System ；System.Data ；System.Drawing ；System.IO ； Microsoft.CSharp ； Microsoft.VisualBasic 。

下面是命名空间命名指南：①以公司名称开头；②在公司名之后跟着技术名称；③不要与类或类型名相同。例如，Acme Widget 公司的软件开发部门在下面3个命名空间中开发软件，如下面的代码所示：AcmeWidgets.SuperWidget 、 AcmeWidgets.Media 、AcmeWidgets.Games

### 命名空间补充
关于命名空间的一些其他要点如下：  
①在命名空间内，每个类型名必须有别于所有其他类型；  
②命名空间内的类型称为命名空间的成员，不同命名空间内的类型可以重名；
③一个源文件可以包含任意数目的命名空间声明，可以顺序也可以嵌套。

.NET 框架 BCL 提供了数千个已定义的类和类型以供生成程序时选择。为了帮助组织这组有用的功能，相关功能的类型被声明在相同的命名空间里。BCL 使用超过100个命名空间来组织它的类型。

### 命名空间跨文件伸展
命名空间不是封闭的。这意味着可以在该源文件的后面或另一个源文件中再次声明它，以对它增加更多的类型声明。可以将类在不同的源文件中声明在相同的命名空间中，而且多个该源文件可以被编译成单个程序集，当然也可以各自编译为独立的程序集。

### 嵌套命名空间
命名空间可以嵌套，从而产生嵌套的命名空间。嵌套命名空间允许你创建类型的概念层次。有两种方法声明一个嵌套的命名空间，如下所示：  
①文本嵌套：可以把命名空间的声明放在一个封装的命名空间声明体内部，从而创建一个嵌套的命名空间。下图的左边阐明了这种方法。在这个示例中，命名空间 OtherNs 嵌套在命名空间 MyNamespace 中；  
②分离的声明：也可以为嵌套命名空间创建单独的声明，但必须在声明中使用它的完全限定名称。下图的右边阐明了这种方法。注意在嵌套命名空间 OtherNs 的声明中，使用完全限定名 MyNamespace.OtherNs。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/04/uFgZph2cGRW9zkY.png" width = "75%" height = "75%" alt="图108 - 声明嵌套命名空间的两种形式是等价的"/>
</div>

虽然嵌套命名空间位于父命名空间内部，但是其成员并不是父命名空间的成员。一个常见的误解是，既然嵌套的命名空间位于父命名空间内部，其成员也是父命名空间的子集，这是不正确的，命名空间之间是相互独立的。

## using 指令
完全限定名可能相当长，在代码中通篇使用它们十分繁琐。然而，有两个编译器指令，可以避免使用完全限定名：**using 命名空间指令 the using namespace directive**和 **using 别名指令 the using alias directive**。

关于 using 指令的两个要点如下：  
①它们必须放在源文件的顶端，在任何类型声明之前；  
②它们应用于当前源文件中的所有命名空间。

### using 命名空间指令
using 命名空间指令通知编译器你将要使用来自某个指定命名空间的类型。然后你可以使用简单类名而不必完全限定。

当编译器遇到一个不在当前命名空间的名称时，它检査在 using 命名空间指令中给出的命名空间列表，并把该未知名称加到列表中的第一个命名空间后面。如果结果完全限定名匹配了这个程序集或引用程序集中的一个类，编译器将使用那个类。如果不匹配，那么它试验列表中下一个命名空间。

using 命名空间指令由关键字 using 跟着一个命名空间标识符组成：`using System;`。

WriteLine 方法，就是类 Console 的成员，在 System 命名空间中。如下代码所示：

``` C#
using System;  //using命名空间指令
…
System.Console.WriteLine("This is text 1");  //使用完全限定名
COnsole.WriteLine("This is text 2");  //使用指令
```

### using 别名指令
using 别名指令允许起一个別名给命名空间或者命名空间内的一个类型。

例如，下面的代码展示了两个 using 别名指令的使用。第一个指令告诉编译器标识符 Syst 是命名空间 System 的别名。第二个指令表明标识符 SC 是类 System.Console 的别名：

``` C#
using Syst = System;
using SC = System.Console;
```

下面的代码使用这些别名。在 Main 中3行代码都调用 System.Console.WriteLine 方法：

``` C#
using Syst = System;  //using别名指令
using SC = System.Console;  //using别名指令

namespace MyNamespace
{
    class SomeClass
    {
        static void Main()
        {
            Syst.Console.WriteLine("Using the namespace alias.");  //命名空间System的别名
            System.Console.WriteLine("Using fully qualified name.");  //方法的完全限定名
            SC.WriteLine("Using the type alias"); //类Console的别名
        }
    }
}
```

### using static 指令
如第6章和第7章所诉，可以使用 using static 指令引用命名空间中的特定类、结构体或枚举，这样就可以不带任何前缀地访问该类、结构体或枚举的静态成员。

using static 指令的示例：`using static System.Math;`

using static 指令指定的类本身可以不是静态的。任何此种类型都可以包含实例成员，但这些实例成员不会由 using static 指令导入。虽然包含了指定类型中声明的嵌套类型，但是被继承的成员不会被导入。using static 指令的主要优点是排除了属于同一命名空间的其他类、结构体或枚举的成员。using static 指令仅仅包含指定类、结构体或枚举的静态成员，给定类型是静态的并不意味着它所有的成员也都是静态的。

## 程序集的结构
程序集不包含本地机器代码，而是包含公共中间语言代码 Common Intermediate Language (CIL)。它还包含实时编译器（JIT）在运行时将 CIL 转换为本机代码所需的一切，包括对它所引用的其他程序集的引用。程序集的文件扩展名通常为 .exe 或 .dll 。

大部分程序集由一个单独的文件构成：  
①程序集的清单 manifest ，包含以下：  
&emsp;&emsp;- 程序集标识符；  
&emsp;&emsp;- 组成程序集的文件列表；  
&emsp;&emsp;- 一个指示程序集中内容在哪里的地图；  
&emsp;&emsp;- 关于引用的其他程序集的信息。  
②类型元数据部分包含该程序集中定义的所有类型的信息。这些信息包含关于每个类型的所有事情；  
③CIL 部分包含程序集的所有中间代码；  
④资源部分是可选的，但可以包含图形或语言资源。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/05/hVxTMY5ZWzruDml.png" width = "75%" height = "75%" alt="图109 - 单文件程序集的结构"/>
</div>

程序集代码文件称为**模块 module**。尽管大部分程序集由单文件组成，但有些也有多个文件。对于有多个模块的程序集，一个文件是主模块 primary module ，而其他的是次要模块 secondary modules ：  
①主模块含有程序集的清单和到次要模块的引用；  
②次要模块的文件名以扩展名 .netmodule 结尾；  
③多文件程序集被视为一个单元。它们一起部署并一起定版。

下图阐明了一个带次要模块的多文件程序集：

<div  align="center">  
<img src="https://s2.loli.net/2023/07/05/LYJvBqbP3tfVoUW.png" width = "50%" height = "50%" alt="图110 - 多文件程序集"/>
</div>

## 程序集标识符
在 .NET 框架中，程序集的文件名不像在其他操作系统和环境中那么重要，更重要的是程序集的标识符 identity 。

程序集的标识符有4个组成部分，它们一起唯一标识了该程序集：  
①简单名称：这只是不带文件扩展名的文件名。每个程序集都有一个简单名称。它也被称为程序集名或友好名称 friendly name；  
②版本号：它由4个用句点分隔的整数组成，形式为 MajorVersion.MinorVersion.Build.Revision，例如 2.0.35.9 ；  
③文化信息：它是一个字符串，由2~5个字符组成，代表一种语言，或代表一种语言和一个国家或地区。例如，在美国使用英语的文化名是 en-US 。在中国使用中文，它是 zh-CN ；  
④公钥：这个128字节字符串应该是生产该程序集的公司唯一的。

公钥是**公钥/私钥对 public/private key pair** 的一部分，它们是两个非常大的、特别选择的数字，可以用于创建安全的数字签名。公钥，顾名思义，可以被公开。私钥必须被拥有者保护起来。公钥是程序集标识符的一部分。稍后会在本章看到私钥的使用。

程序集的完全限定名称是由简单名称、版本、文化和表示为16字节公钥凭据的公钥组成的文本列表。

## 强命名程序集
**强命名 strongly named** 程序集有一个唯一的数字签名。强命名程序集比没有强名称的程序集更加安全，原因有以下两点：  
①强名称唯一标识了程序集。其他人无法创建一个与之有相同名称的程序集，所以用户可以确信该程序集来自于其声称的来源；  
②如果没有 CLR 安全组件来捕获更改，带强名称的程序集的内容就不能被改变。

**弱命名 weakly named** 程序集是没有被强命名的程序集。由于弱命名程序集没有数字签名，它天生是不安全的。因为一根链的强度只和它最弱的一环相同，所以强命名程序集默认只能访问其他强命名程序集（还存在一种方法允许“部分授信的调用者”，但这里不做阐述）。

程序员不产生强名称。编译器通过接受关于程序集的信息，并散列化这些信息以创建一个唯一的数据签名依附到该程序集来产生强名称。它在散列处理中使用的信息如下：组成程序集的字节序列；简单名称；版本号；文化信息；公钥/私钥对。

### 创建强命名程序集
这里不摘抄。日后有需求了解即可。

## 私有程序集的部署
要在目标机器上部署一个程序，只需在该机器上创建一个目录并把应用程序复制过去。如果应用程序不需要其他程序集（比如 DLL），或如果所需的 DLL 在同一目录下，那么程序应该会就在它所在的地方良好工作。这种方法部署的程序集称为**私有程序集**，而且这种部署方法称为**复制文件** XCopy 部署。

私有程序集几乎可以被放在任何目录中，而且只要它们依赖的文件都在同一目录或子目录下就足够了。事实上，可以在文件系统的不同部分有多个目录，每个目录都有同样的一组程序集，并且它们都会在它们各自不同的位置良好工作。

关于私有程序集部署的一些重要事情如下：  
①私有程序集所在的目录被称为应用程序目录；  
②私有程序集可以是强命名的也可以是弱命名的；  
③没有必要在注册表中注册组件；  
④要卸载一个私有程序集，只要从文件系统中删除它即可。

## 共享程序集和 GAC
私有程序集是非常有用的，但有时你会想把一个 DLL 放在一个中心位置，这样一个副本就能被系统中其他的程序集共享。.NET 有这样的贮藏库，称为**全局程序集缓存 GAC (global assembly cache)**。放进 GAC 的程序集称为**共享程序集**。关于 GAC 的一些重要内容如下：  
①只有强命名程序集能被添加到 GAC ；  
②GAC 的早期版本只接受带 .dll 扩展名的文件，现在也可以添加带 .exe 扩展名的程序集了；  
③GAC 位于 Windows 系统目录的子目录中。从 .NET 4.0 开始位于 \Windows\Microsoft.NET\assembly 中。

### 把程序集安装到 GAC
当试图安装一个程序集到 GAC 时，CLR 的安全组件首先必须检验程序集上的数字签名是否有效。如果没有数字签名，或数字签名无效，系统将不会把它安装到 GAC 。

然而，这是个一次性检査。在程序集已经在 GAC 内之后，当它被一个正在运行的程序引用时，不再需要进一步的检査。

gacutil.exe 命令行工具允许从 GAC 添加或删除程序集，并列出 GAC 包含的程序集。它的3个最有用的参数标记如下所示：/i: 把一个程序集插人 GAC ；/u: 从 GAC 卸载一个程序集；/l: 列出 GAC 中的程序集。

### GAC 内的并肩执行
在程序集部署到 GAC 之后，它就能被系统中其他程序集使用了。然而，请记住程序集的标识符由完全限定名称的全部4个部分组成。所以，如果一个库的版本号改变了，或如果它有一个不同的公钥，则这些区别会导致指定不同的程序集。

结果就是在 GAC 中可以有许多不同的程序集，它们有相同的文件名。虽然它们有相同的文件名，但它们是不同的程序集而且在 GAC 中完美地共存。这使不同的应用程序在同一时间很容易使用不同版本的同一 DLL ，因为它们是带不同标识符的不同程序集。这被称为**并肩执行 side-by-side Execution**。

## 配置文件
配置文件含有关于应用程序的信息，供 CLR 在运行时使用。它们可以指示 CLR 去做这样的事情，比如使用一个不同版本的 DLL ，或搜索程序引用的 DLL 时在附加目录中查找。

**配置文件 Configuration files** 由 XML 代码组成，并不包含 C# 代码。它们的一种用途是*更新一个应用程序集以使用新版本的 DLL* 。

例如，假设有一个应用程序引用了 GAC 中的一个 DLL 。在应用程序的清单中，该引用的标识符必须完全匹配 GAC 中程序集的标识符。如果一个新版本的 DLL 发布了，它可以被添加到 GAC 中，在那里它可以和老版本共存。然而，应用程序仍然在它的清单中包括老版本 DLL 的标识符。除非重新编译应用程序并使它引用新版本的 DLL ，否则它会继续使用老版本。如果你不想重新编译程序但又希望它使用新的 DLL ，那么你可以更新配置文件中的信息，告诉 CLR 去使用新的版本而不是旧版本。配置文件被放在应用程序目录中。注意配置文件的名称由执行文件的全名（包括扩展名）加上附加扩展名 .config 组成。

## 延迟签名
公司小心地保护它们官方的公钥/私钥对是非常重要的，否则，如果不可靠的人得到了它，就可以发布伪装成该公司的代码。为了避免这种情况，公司显然不能允许自由访问含有它们的公钥/私钥对的文件。在大公司中，最终程序集的强命名经常在开发过程的结尾由有密钥访问权限的特殊小组执行。

可是，由于一些原因，这会在开发和测试过程中导致问题。首先，由于公钥是程序集标识符的4个部分之一，所以直到提供了公钥才能设置标识符。其次，弱命名的程序集不能被部署到 GAC 。开发人员和测试人员都需要能够按照发布时部署的方式编译和测试代码，包括它的标识符和在 GAC 中的位置。  

为此，有一种修改了的分配强命名的形式，称为**延迟签名 delayed signing** 或**部分签名 partial signing**，它克服了这些问题，而且没有释放对私钥的访问。

在延迟签名中，编译器只使用公钥/私钥对中的公钥。然后可以将公钥放入清单，以完成程序集的标识符。延迟签名还使用一个为0的块保留数字签名的位置。

要创建一个延迟签名的程序集，必须做两件事情。第一，创建一个密钥文件的一个副本，它只有公钥而不是公钥/私钥对。第二，为程序集范围内的源代码添加一个名称为 DelaySignAttribute 的附加特性，并把它的值设为 true 。

下图展示了生成一个延迟签名程序集的输人和输出，注意图中下面的内容：  
①在输人中，DelaySignAttribute 位于源文件中，而且密钥文件只含有公钥；  
②在输出中，在程序集的底部有一个数字签名的保留空间。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/05/V8lagNcvBKTJQLR.png" width = "70%" height = "70%" alt="图111 - 创建延迟签名程序集"/>
</div>

如果你试图部署延迟签名的程序集到 GAC ，CLR 不会允许，因为它不是强命名的。要在一台机器上部署它，必须首先使用命令行指令取消在这台机器上该程序集的 GAC 签名验证，并允许它被装在 GAC 中。要做到这点，从 Visual Studio 命令提示中执行下面的命令：`sn -vr MyAssembly.dll`

现在，你已经看到弱命名程序集、延迟签名程序集和强签名程序集。下图总结了它们的结构区别：

<div  align="center">  
<img src="https://s2.loli.net/2023/07/05/TH5R4QIEAdgWtPX.png" width = "70%" height = "70%" alt="图112 - 不同程序集签名阶段的结构"/>
</div>


# 第二十三章 异常
## 什么是异常
**异常 exception** 是程序中的运行时错误。例如，程序试图将一个数除以0或试图写入一个只读文件。当这些发生时，系统捕获错误并**抛出 raise** 一个异常。如果程序没有提供处理该异常的代码，系统会挂起这个程序。

## try 语句
try 语句用来指明为避免出现异常而被保护的代码段，并在发生异常时提供代码处理异常。try 语句由3个部分组成，如下图所示：  
① try 块包含为避免出现异常而被保护的代码；  
② catch 子句部分含有一个或多个 catch 子句。这些是处理异常的代码段，它们也称为是异常处理程序；  
③ finally 块含有在所有情况下都要被执行的代码，无论有没有异常发生。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/05/sLWlR4K1MqYGD53.png" width = "80%" height = "80%" alt="图113 - try 语句的结构"/>
</div>

### 处理异常
用 catch 子句处理异常的实例如下：

``` C#
static void Main()
{
    int x = 10；

    try
    {
        int y = 0;
        x /= y; //抛出异常
    }
    catch
    {
        ...  //异常处理代码
        Console.WriteLine("Handling all exceptions - keep on Running");
    }
}
```

运行结果如下：

``` console
Handling all exceptions - Keep on Running
```

## 异常类
BCL定义了许多异常类，每一个类代表一种指定的异常类型。当一个异常发生时，CLR 创建该类型的异常对象并寻找合适的 catch 子句以处理它。

所有异常类都派生自 System.Exception 类，而 System.Exception 类派生自 System.Object 。异常继承层次的一部分如下图所示：

<div  align="center">  
<img src="https://s2.loli.net/2023/07/05/kmCFAZLRIywvMrW.png" width = "60%" height = "60%" alt="图114 - 异常层次的结构"/>
</div>

异常对象含有只读属性，带有导致该异常的异常信息。这些信息有助于调试应用程序，这些属性的其中一些如下表所示：

| 属性 | 类型 | 描述 |
| :---- | :---- | :---- |
| Message | string | 这个属性含有解释异常原因的错误消息 |
| StackTrace | string | 这个属性含有描述异常发生在何处的信息 |
| InnerException | Exception | 如果当前异常是由另一个异常引起的，则这个属性包含前一个异常的引用 |
| Source | string | 如果没有被应用程序定义的异常设定，那么这个属性含有异常所在的程序集的名称 |


## catch 子句
catch 子句处理异常。它有4种形式，允许不同级別的处理。这些形式如下图所示：

<div  align="center">  
<img src="https://s2.loli.net/2023/07/05/RV9G3UaqxoIYpE7.png" width = "80%" height = "80%" alt="图115 - catch子句的4种形式"/>
</div>

如上图，这里先介绍前三种形式：  
①*一般 catch 子句*能接受任何异常，但不能确定引发异常的异常类型。这只能对任何可能发生的异常进行普通处理和清理；  
②*特定 catch 子句*形式把一个异常类的名称作为参数。它匹配该指定类或派生自它的异常类的异常；  
③*带对象的特定 catch 子句*提供的关于异常的信息最多。它匹配该指定类的异常，或派生自它的异常类的异常。它还给出一个对 CLR 创建的异常对象的引用（通过将其赋给异常变量）。可以在 catch 子句块内部访问异常变量的属性，以获取关于抛出异常的详细信息。

例如，下面的代码处理 IndexOutOfRangeException 类型的异常。当异常发生时，一个实际异常对象的引用被参数名 e 传入代码。3个 WriteLine 语句都从异常对象中读取一个字符串字段：

``` C#
catch( DivideByZeroException e ) //异常类型以及异常变量
{
    Console.WriteLine("Message: {0}", e.Message); //访问异常变量
    Console.WriteLine("Source:  {0}", e.Source);
    Console.WriteLine("Stack:   {0}", e.StackTrace);
}
```

### 使用特定 catch 子句的示例

``` C#
int x = 10;

try
{
    int y = 0;
    x /= y;  //抛出一个异常
}

//特定 catch 子句
catch( DivideByZeroException )
{
    …
    Console.WriteLine("Handling an exception.");
}

//或者使用带对象的特定 catch 子句
catch( DivideByZeroException e )
{
    Console.WriteLine("Message: {0}", e.Message);
    Console.WriteLine("Source:  {0}", e.Source);
    Console.WriteLine("Stack:   {0}", e.StackTrace);
}
```

使用带对象的特定 catch 子句的运行结果如下：  

``` console
Message: Attempted to divide by zero.
Source:  Exceptions 1
Stack:      at Program.Main() in C:\Users\XXXX\Desktop\Exceptions 1\Program.cs:line 9
```

## 异常过滤器
第四种形式的 catch 子句，跟第三种形式一样，异常对象被传递给处理程序，但在这种情况下，对象还必须满足特定条件，这个条件被称为**过滤器 filter**。因此，对于一个异常类型可以有多个处理程序，而不必由一个处理程序处理这个异常类型的所有可能异常。如下示例，注意如果 Message 字段同时包含301和307，则只调用第一个 catch 子句，因为无论可能匹配多少个子句，都只执行第一个匹配成功的子句：

``` C#
try
{
    ... 执行某个Web请求
}
catch ( HttpRequestException e ) when ( e.Message.Contains("307") )
{
    ... 采取某种行动
}
catch ( HttpRequestException e ) when ( e.Message.Contains("301") )
{
    ... 采取其他行动
}
```

过滤器的 when 子句的重要特性如下：  
①它必须包含**谓语 predicate 表达式**，该表达式返回布尔值；  
②它不能是异步的；  
③不应使用任何需要长时间运行的操作；  
④谓语表达式中发生的任何异常都会被忽略。这使得调试谓词表达式变得更加困难，但它保留了调试原始应用程序错误所需的信息。

## catch 子句段
如果 catch 子句接受一个参数，那么系统会把这个异常变量设置为对异常对象的引用，这样就可以检査它并确定异常的原因。如果异常是前一个异常引起的，可以通过异常变量的 InnerException 属性来获得对前一个异常对象的引用。catch 子句段可以包含多个 catch 子句。下图显示了 catch 子句段：

<div  align="center">  
<img src="https://s2.loli.net/2023/07/06/sLaDeFqpE2RhW6M.png" width = "70%" height = "70%" alt="图116 - try语句的catch子句段结构"/>
</div>

当异常发生时，系统按顺序搜索 catch 子句的列表，第一个匹配该异常对象类型的 catch 子句被执行。因此，catch 子句的排序有两个重要的规则。具体如下：  
①特定 catch 子句必须以一种顺序排列，即最特定的异常类型第一，最普通的类型排最后；  
②如果有一个一般 catch 子句，它必须是最后一个，并且在所有特定 catch 子句之后。不鼓励使用一般 catch 子句，因为当代码应该以特定方式处理错误的时候，它允许程序继续执行从而隐藏了错误，让程序处于一种未知的状态。应尽可能使用特定 catch 子句。

## finally 块
如果程序的控制流进人了一个带 finally 块的 try 语句，那么 finally 始终会被执行：  
①如果在 try 块内部没有异常发生，那么在 try 块的结尾，控制流跳过任何 catch 子句并到 finally 块；  
②如果在 try 块内部发生了异常，那么在 catch 子句段中适当的 catch 子句被执行，接着就是 finally 块的执行。

即使 try 块中有 return 语句或在 catch 块中抛出一个异常，finally 块也总是会在返回到调用代码之前执行。例如，在下面的代码中，在 try 块的中间有一条 return 语句，它在某条件下被执行。
这不会使它绕过 finally 语句：

``` C#
try
{
    if (inVal < 10) {
        Console.Write("First Branch - ");
        return;
    }
    else
        Console.Write("Second Branch - ");
}
finally
{
    Console.WriteLine("In finally statement");
}
```

这段代码在 inVal 值为5时产生以下输出：  

``` console
First Branch - In finally statement
```

## 为异常寻找处理程序
当程序抛出异常时，系统查看该程序是否为它提供了处理程序：  
①如果在 try 块内发生了异常，系统会査看是否有任何一个 catch 子句能处理该异常；  
②如果找到了适当的 catch 子句，以下会发生：  
&emsp;&emsp;- 该 catch 子句被执行；  
&emsp;&emsp;- 如果有 finally 块，那么它被执行；  
&emsp;&emsp;- 执行在 try 语句的尾部之后继续（也就是说，在 finally 块之后，或如果没有 finally 块，就在最后一个 catch 子句之后）。

## 进一步搜索
如果异常在一个没有被 try 语句保护的代码段中产生，或如果 try 语句没有匹配的异常处理程序，系统将不得不更进一步寻找匹配的处理代码。为此它会按顺序搜索调用栈，查看是否存在带匹配的处理程序的封装 try 块。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/07/UIG7bkzAwtLn8ic.png" width = "75%" height = "75%" alt="图117 - 搜索调用栈"/>
</div>

上图阐明了这个搜索过程。图左边是代码的调用结构，右边是调用栈。该图显示 Method2 被从 Method1 的 try 块内部调用。如果异常发生在 Method2 内的 try 块内部，系统会执行以下操作：  
①首先査看 Method2 是否有能处理该异常的异常处理程序；  
&emsp;&emsp;- 如果有，Method2 处理它，程序继续执行；  
&emsp;&emsp;- 如果没有，系统再沿着调用栈找到 Method1 ，搜寻适当的处理程序；  
②如果 Method1 有一个适当的 catch 子句，那么系统将：  
&emsp;&emsp;- 回到栈顶，那里是 Method2 ；  
&emsp;&emsp;- 执行 Method2 的 finally 块，并把 Method2 弹出栈；  
&emsp;&emsp;- 执行 Method1 的 catch 子句和它的 finally 块。  
③如果 Method1 没有适当的 catch 子句，系统会继续搜索调用栈。

### 一般法则

<div  align="center">  
<img src="https://s2.loli.net/2023/07/07/8K7DOxj4LaANBSP.png" width = "70%" height = "70%" alt="图118 - 处理异常的一般法则"/>
</div>

### 搜索调用栈的示例

``` C#
class Program
{
    static void Main()
    {
        MyClass MCls = new MyClass();
        try
            { MCls.A(); }
        catch ( DivideByZeroException )
            { Console.WriteLine("catch clause in Main()"); }
        finally
            { Console.WriteLine("finally clause in Main()"); }
        Console.WriteLine("After try statement in Main.");
        Console.WriteLine(" -- Keep running.");
    }
}

class MyClass
{
    public void A()
    {
        try
            { B(); }
        catch ( NullReferenceException )
            { Console.WriteLine("catch clause in A()"); }
        finally
            { Console.WriteLine("finally clause in A()"); }
    }

    void B()
    {
        int x = 10, y = 0;
        try
            { x /= y; }
        catch ( IndexOutOfRangeException )
            { Console.WriteLine("catch clause in B()"); }
        finally
            { Console.WriteLine("finally clause in B()"); }
    }
}
```

运行结果如下：

``` console
finally clause in B()
finally clause in A()
catch clause in Main()
finally clause in Main()
After try statement in Main.
 -- Keep running.
```

①Main 调用 A ，A 调用 B ，B 遇到一个 DivideByZeroException 异常；  
②系统检查 B 的 catch 段寻找匹配的 catch 子句。虽然它有一个 IndexOutOfRangeException 的 catch 子句，但没有 DivideByZeroException 的子句；  
③系统然后沿着调用栈向下移动并检査 A 的 catch 段，在那里它发现 A 也没有匹配的 catch 子句；  
④系统继续沿调用栈向下，并检查 Main 的 catch 子句部分，在那里它发现 Main 确实有一个 DivideByZeroException 的 catch 子句；  
⑤尽管匹配的 catch 子句现在被定位了，但并不执行。相反，系统回到栈的顶端，执行 B 的 finally 子句，并把 B 从调用栈中弹出；  
⑥系统移动到 A ，执行它的 finally 子句，并把 A 从调用栈中弹出；  
⑦最后，Main 的匹配 catch 子句被执行，接着是它的 finally 子句。然后执行在 Main 的 try 语句结尾之后继续。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/07/AQbCZocEhkzsw1n.png" width = "70%" height = "70%" alt="图119 - 搜索栈以寻找一个异常处理程序"/>
</div>

## 抛出异常
可以使用 **throw 语句**使代码显式地抛出异常。throw 语句的语法为：`throw ExceptionObject;`

示例如下：  

``` C#
class MyClass
{
    public static void PrintArg(string arg)
    {
        try
        {
            if (arg == null)
            {
                ArgumentNullException myEx = new ArgumentNullException("arg"); //提供null参数
                throw myEx;
            }
            Console.WriteLine(arg);
        }
        catch (ArgumentNullException e)
        {
            Console.WriteLine($"Message: { e.Message }");
        }
    }
}
class Program
{
    static void Main()
    {
        string s = null;
        MyClass.PrintArg(s);
        MyClass.PrintArg("Hi there!");
    }
}
```

运行结果如下：  

``` console
Message: Value cannot be null. (Parameter 'arg')
Hi there!
```

## 不带异常对象的抛出
throw 语句还可以在 catch 块内部不带异常对象使用：  
①这种形式重新抛出当前异常，系统继续搜索，为该异常寻找另外的处理程序；  
②这种形式只能用在 catch 语句内部。

例如，下面的代码从第一个 catch 子句内部重新抛出异常：

``` C#
class MyClass
{
    public static void PrintArg(string arg)
    {
        try
        {
            try
            {
                if (arg == null)
                {
                    ArgumentNullException myEx = new ArgumentNullException("arg");  //提供null参数
                    throw myEx;
                }
                Console.WriteLine(arg);
            }
            catch (ArgumentNullException e)
            {
                Console.WriteLine($"Inner Catch: { e.Message }");
                throw;  //重新抛出异常，没有附加参数
            }
        }
        catch
        {
            Console.WriteLine("Outer Catch: Handling an Exception.");
        }
    }
}

class Program {
    static void Main() {
        string s = null;
        MyClass.PrintArg(s);
        MyClass.PrintArg("Hi there!");
    }
}
```

运行结果如下：

``` console
Inner Catch: Value cannot be null. (Parameter 'arg')
Outer Catch: Handling an Exception.
Hi there!
```

## throw 表达式
C# 包含语句和表达式。代码中有些地方不允许使用语句，只能使用表达式，反之亦然。本章的前几节都是在语句中使用 throw 。从 C# 7.0 开始，可以在只能使用表达式的地方使用 throw 了。

throw 语句和 throw 表达式的语法相同。例如，可以把 throw 语句作为空接合运算符的第二个操作数。**空接合运算符**是由两个以 ?? 分隔的操作数组成。第一个操作数必须是可空的，并且经过测试以确定它是否为空。如果第一个操作数不为空，则使用其值。但是如果第一个操作数为空，则使用第二个操作数：

``` C#
private int mSecurityCode;
public int SecurityCode
{
    get => mSecurityCode;
    set => mSecurityCode = value ??
                throw new ArgumentNullException("Security Code may not be null");
}
```

在 C# 中，另一个需要使用表达式的构造是条件运算符。throw 表达式可在条件运算符中用作第二个或第三个操作数，如下代码所示：  

``` C#
class Program
{
    static string SecretCode { get { return "Roses are red"; } }
    static void Main()
    {
        bool safe = false;
        try
        {
            string secretCode = safe
                ? SecretCode
                : throw new Exception("Not safe to get code.");
            Console.WriteLine($"Code is: {secretCode}.");
        }
        catch (Exception e)
        {
            Console.WriteLine($"{ e.Message }");
        }
    }
}
```

运行结果如下：  

``` console
Not safe to get code.
```