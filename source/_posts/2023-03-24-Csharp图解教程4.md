---
title: 《C#图解教程》读书笔记（四）
date: 2023-03-24 22:56:39
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：XXXXXXXXXXXXXXXX 。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第二十一章 异步编程
## 什么是异步 Asynchrony
启动程序时，系统会在内存中创建一个新的**进程 process**。进程是构成运行程序的资源的集合，这些资源包括虚地址空间、文件句柄等等。

在进程内部，系统创建了一个**内核 kernal 对象**，叫做**线程 thread**，代表了真正执行的程序。一旦进程建立，系统会在 Main 方法的第一行语句处开始线程的执行。

关于线程的有关知识点：  
①默认情况下，一个进程只包含一个线程，从程序的开始一直执行到结束；  
②线程可以派生其他线程，因此在任意时刻，一个进程都可能包含不同状态的多个线程，它们执行程序的不同部分；  
③如果一个进程拥有多个线程，它们共享进程的资源；  
④系统为处理器执行所调度的单元是线程，不是进程。

本章将学习**异步编程**。在异步程序中，程序代码不需要按照编写的顺序严格执行。有时需要在一个新的线程中运行一部分代码，有时无需创建新的线程，但为了更好地利用单个线程的能力，需要改变代码的执行顺序。

我们先来看看 C#5.0 引入的一个用来构建异步方法的新特性 **async/await** 。接下来学习一些可实现其他形式的异步编程的特性，这些特性是 .NET 框架的一部分，但没有嵌入 C# 语言。相关主题包括 BackgroundWorker 类和 .NET 任务并行库。两者均通过新建线程来实现异步。本章最后会介绍编写异步程序的其他方式。

### 示例
为了演示和比较，先看一个不使用异步的示例。然后再看一个实现类似功能的异步程序。

在下面的代码示例中，MyDownloadString 类的方法 DoRun 执行以下任务：  
①创建 Stopwatch 类（位于 System.Diagnostics 命名空间）的一个实例并启动。该 Stopwatch 计时器用来测量代码中不同任务的执行时间；  
②然后两次调用 CountCharacters 方法，下载某网站的内容，并返问该网站包含的字符数。网站由 URL 字符串指定，作为第二个参数传入；
③接着四次调用 CountToALargeNumber 方法。该方法仅执行一个消耗一定时间的任务，并循环指定次数
④最后，打印两个网站的字符数。

``` C#
using System;
using System.Net;
using System.Diagnostics;

class MyDownloadString {
    Stopwatch sw = new Stopwatch();

    public void DoRun() {
        const int LargeNumber = 6_000_000;
        sw.Start();
        int t1 = CountCharacters( 1, "http://www.google.com" );
        int t2 = CountCharacters( 2, "http://www.illustratedcsharp.com" );
        CountToALargeNumber( 1, LargeNumber );
        CountToALargeNumber( 2, LargeNumber );
        CountToALargeNumber( 3, LargeNumber );
        CountToALargeNumber( 4, LargeNumber );

        Console.WriteLine($"Chars in http://www.google.com : { t1 }");
        Console.WriteLine($"Chars in http://www.illustratedcsharp.com: { t2 }");
    } 

    private int CountCharacters(int id, string uriString ) {
        WebClient wc1 = new WebClient();
        Console.WriteLine( "Starting call {0} : {1, 4:N0} ms",
                          id, sw.Elapsed.TotalMilliseconds );
        string result = wc1.DownloadString( new Uri( uriString ) );
        Console.WriteLine( " Call {0} completed: {1, 4:N0} ms",
                          id, sw.Elapsed.TotalMilliseconds );
        return result.Length;
    }

    private void CountToALargeNumber( int id, int value ) {
        for ( long i=0; i < value; i++ )
            ;
        Console.WriteLine( " End counting {0} : {1, 4:N0} ms",
                          id, sw.Elapsed.TotalMilliseconds );
    }
}

class Program
{
    static void Main() {
        MyDownloadString ds = new MyDownloadString();
        ds.DoRun();
    }
}
```

运行结果如下：

``` console
Starting call 1 :    6 ms
 Call 1 completed:  205 ms
Starting call 2 :  205 ms
 Call 2 completed:  695 ms
 End counting 1 :  713 ms
 End counting 2 :  733 ms
 End counting 3 :  751 ms
 End counting 4 :  767 ms
Chars in http://www.google.com : 49672
Chars in http://www.illustratedcsharp.com: 5164
```

如同结果所示，Call 1 和 Call 2 占用了大部分时间，不管哪次调用，大部分时间都浪费在了等待网站的响应上。

如果先发起两个 CountCharacter 调用，不先等待结果，同时执行4个 CountToALargeNumber 调用，然后在两个 CountCharacter 方法调用结束之后再获取结果就可以提升性能。

C# 最新的 async/await 特性就允许我们这么做。可以重写代码以运用该特性，如下所示：  
①当 DoRun 调用 CountCharactersAsync 时，CountCharactersAsync 将立即返回，然后才真正开始下载字符。它向调用方法返回的是一个 Task&lt;int&gt; 类型的占位符对象，表示它计划进行的工作。这个占位符最终将“返回”一个 int ；  
②这使得 DoRun 不用等待实际工作完成就可继续执行。下一条语句是再次调用 CountCharactersAsync ，同样会返回一个 Task&lt;int&gt; 对象；  
③接着，DoRun 可以继续执行，调用4次 CountToALargeNumber，同时 CountCharactersAsync 的两次调用继续它们的工作，基本上是等待（网站的响应）；  
④ DoRun 的最后两行从 CountCharactersAsync 调用返回的 Tasks 中获取结果。如果还没有结果，将阻塞并等待。

``` C#
using System.Threading.Tasks;

class MyDownloadString
{
    Stopwatch sw = new Stopwatch();

    public void DoRun() {
        const int LargeNumber = 6_000_000;
        sw.Start();

        Task<int> t1 = CountCharactersAsync( 1, "http://www.google.com" ); //保存结果的对象
        Task<int> t2 = CountCharactersAsync( 2, "http://www.illustratedcsharp.com" );
        CountToALargeNumber( 1, LargeNumber );
        CountToALargeNumber( 2, LargeNumber );
        CountToALargeNumber( 3, LargeNumber );
        CountToALargeNumber( 4, LargeNumber );

        Console.WriteLine( "Chars in http://www.google.com : {0}", t1.Result ); //获取结果
        Console.WriteLine( "Chars in http://www.illustratedcsharp.com: {0}", t2.Result );
    }

    private async Task<int> CountCharactersAsync( int id, string site ) { //上下文关键字async，Task<int>表示正在执行的工作，最终将返回int
        WebClient wc = new WebClient();
        Console.WriteLine( "Starting call {0} : {1, 4:N0} ms",
                            id, sw.Elapsed.TotalMilliseconds );

        string result = await wc.DownloadStringTaskAsync( new Uri( site ) ); //上下文关键字await
        Console.WriteLine( " Call {0} completed: {1, 4:N0} ms",
                            id, sw.Elapsed.TotalMilliseconds );
        return result.Length;
    }

    private void CountToALargeNumber( int id, int value ) {
        for ( long i=0; i < value; i++ ) ;
        Console.WriteLine( " End counting {0} : {1, 4:N0} ms",
                            id, sw.Elapsed.TotalMilliseconds );
    }
}

class Program {
    static void Main() {
        MyDownloadString ds = new MyDownloadString();
        ds.DoRun();
    }
}
```

运行结果如下：

``` console
Starting call 1 :    6 ms
Starting call 2 :  111 ms
 End counting 1 :  128 ms
 End counting 2 :  143 ms
 End counting 3 :  163 ms
 End counting 4 :  181 ms
 Call 1 completed:  244 ms
Chars in http://www.google.com : 49657
 Call 2 completed:  642 ms
Chars in http://www.illustratedcsharp.com: 5164
```

修改后的程序比原来快，因为 CountToALargeNumber 的4次调用是在 CountCharactersAsync 方法调用等待网络响应的时候进行的。所有这些工作都是在主线程完成的，没有创建任何额外的线程。

## async/await 特性的结构
