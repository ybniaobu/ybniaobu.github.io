---
title: IBL 基于图像的光照（二）
date: 2024-08-16 12:43:39
categories: 
  - [图形学]
tags:
  - 图形学
  - 游戏开发
top_img: /images/black.jpg
cover: https://s2.loli.net/2024/08/16/KQGyA6zfCW74dYw.gif
mathjax: true
description: 本笔记的主要内容有镜面反射环境光的实现：包括 XXXXXXXXX 的实现。
---

> 本篇文章主要参考了著名的 LearnOpenGL 教程：https://learnopengl-cn.github.io/ 或 https://learnopengl.com/ 、著名图形学书籍《Real-Time Rendering 4th》以及谷歌的 Filament PBR 白皮书：https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf 。

# 镜面反射 BRDF 积分
之前讲到的**环境映射 Environment Mapping** 最早是用作镜面渲染的技术，即根据视角的反射方向（入射方向）来对 radiance map 进行采样。当用于模拟无限远处光源的镜面效果时，这样的环境贴图也被称为**高光探针 Specular light probes**。

我们也可以将镜面反射扩展到**光泽 Glossy** 材质上，用于模拟材质表面的粗糙度。一个简单的方法就是对环境贴图进行**预滤波 prefilter**，即进行模糊处理，我们可以创建一个环境贴图的 mipmap 链，用于存储不同模糊程度的环境贴图。在使用时，对于越粗糙的表面使用越模糊的环境贴图。当然，这就是经验主义的近似做法，因为这跟 BRDF 没有关系。

而考虑 BRDF 函数时，我们需要考虑反射的形状，即**镜面波瓣 specular lobe**，而这个波瓣形状取决于粗糙度、观察方向、法线方向、入射方向。而粗糙度越大，波瓣越大，如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2024/08/16/DVuBnlJNHG68awp.png" width = "80%" height = "80%" alt="图15 - 镜面波瓣与粗糙度的关系"/>
</div>

当然我们为所有的参数组合存储环境贴图是不现实的事情，出于性能问题，也无法实时求解镜面反射的积分。为了解决问题，出现了很多 BRDF 近似方案，比如下面要讲到的**预过滤环境映射 Prefiltered environment mapping**、**分解求和近似 Split-sum approximation**（主流解决方案）以及**非对称与各向异性波瓣 Asymmetric and Anisotropic lobes**。

## Prefiltered environment mapping
这个方案是比较传统的，基于宏观表面 BRDF 而非微表面 BRDF 的近似方案，故只做简单介绍。其不考虑微表面的阴影遮挡项，以及将菲涅耳项放到了积分外部，并且该菲涅耳项是基于 $\,n \cdot v\,$ 的，而非基于微表面 BRDF 的 $\,v \cdot h\,$，故误差较大，如下式：

$$ L_o(p, \omega_o) = \int_{\Omega} f_r(p, \omega_i, \omega_o) L_i(p, \omega_i) n \cdot \omega_i d\omega_i \approx F(n,v) \int_{\Omega} D(\omega_i, \omega_o) L_i(\omega_i) n \cdot \omega_i d\omega_i $$

而这个 $\,D(\omega_i, \omega_o)\,$ 正是控制镜面波瓣形状的函数，对比上面说过的简单的模糊卷积核的方案的区别就在于更容易对波瓣形状进行控制，使得波瓣在反射向量周围径向对称。而传统的控制波瓣形状的模型就是 Phong 模型和 Blinn-Phong 模型，这两个模型都是幂次的余弦波瓣，只不过 Phong 模型是基于反射向量和观察向量点乘，Blinn-Phong 模型是半角向量和法线点乘。

为了模拟表面的粗糙度，还是会使用 mipmap，较高级别的 mipmap 用于存储更宽的余弦波瓣，即更粗糙的表面。接下来就是积分问题了，最常用的还是采用蒙特卡洛积分，但实际上我们不需要对所有样本进行采样，特别是当 $\,D(\omega_i, \omega_o) \approx 0\,$ 的时候。所以可以使用**重要性采样 importance sampling**，让概率分布更贴合镜面波瓣的形状，以减少采样需要的样本数。

但上述方法最适用的还是 Phong 模型，因为只有 Phong 模型可以简化成只跟反射向量和观察向量相关，这样就可以保存成一个二维的环境贴图。而其他模型还需要更多的假设（比如 v = n）或者使用一系列跟观察方向相关的贴图。

因为 IBL 对真实感十分重要，因此有了更多的技术来减少上述方法内含的 BRDF 近似误差问题。比如 Epic Games 提出的**分割求和近似 Spilt sum approximation**，其适用于微表面 BRDF。

## Spilt sum approximation

> 这里主要参考了 Epic Games 的文章《Real Shading in Unreal Engine 4》：https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf

Karis 的**分割求和近似 Spilt sum approximation** 方案将渲染方程的蒙特卡洛数值积分拆分为了 radiance 均值和环境 BRDF 两项，公式如下：  

$$ \begin{align*} \int_{\Omega} L_i(p, \omega_i) f_r(p, \omega_o, \omega_i) n \cdot \omega_i d \omega_i &\approx \cfrac {1} {N} \sum_{k=1}^N \cfrac {L_i(p, \omega_i^k) f_r(p, \omega_o, \omega_i^k) n \cdot \omega_i^k } {\rho(\omega_i^k)} \\ &\approx \left( \cfrac {1} {N} \sum_{k=1}^N L_i(p, \omega_i^k) \right) \left( \cfrac {1} {N} \sum_{k=1}^N \cfrac { f_r(p, \omega_o, \omega_i^k) n \cdot \omega_i^k } {\rho(\omega_i^k)} \right) \end{align*} $$

---

该近似方案的推导过程如下（懒得看的话就直接跳过，直接看后面对该近似的应用）：  
①首先将 $\,L\,$ 项提出：  

$$ L_o(p, \omega_o) = L_c \int_{\Omega} f_r(p, \omega_o, \omega_i) n \cdot \omega_i d \omega_i $$

其中：

$$ L_c = \cfrac {\int_{\Omega} L_i(p, \omega_i) f_r(p, \omega_o, \omega_i) n \cdot \omega_i d \omega_i} {\int_{\Omega} f_r(p, \omega_o, \omega_i) n \cdot \omega_i d \omega_i} $$

②将 $\,L_c\,$ 转换为蒙特卡洛积分的式子：  

$$ L_c = \cfrac {\frac {1} {N} \sum_{k = 1}^N \cfrac{ f_r L_i(p, \omega_i) n \cdot \omega_i } {\rho(\omega_i)}} {\frac {1} {N} \sum_{k = 1}^N \cfrac{ f_r n \cdot \omega_i } {\rho(\omega_i)}} = \cfrac {\frac {1} {N} \sum_{k = 1}^N \cfrac{ D(\omega_h) F(\omega_h, \omega_o) G(\omega_i, \omega_o) L_i(p, \omega_i) n \cdot \omega_i } {4 (n \cdot \omega_i)(n \cdot \omega_o) \rho(\omega_i)}} {\frac {1} {N} \sum_{k = 1}^N \cfrac{ D(\omega_h) F(\omega_h, \omega_o) G(\omega_i, \omega_o) n \cdot \omega_i } {4 (n \cdot \omega_i)(n \cdot \omega_o) \rho(\omega_i)}} $$

③接下来就是选择一个合适的概率密度函数 $\,\rho(\omega_i)\,$，因为在实践中我们会使用**重要性采样 importance sampling** 来加快收敛的速度，我们很容易就想到微表面的法线分布函数 $\,D(\omega_h)\,$。但是之前介绍 BRDF 的时候说过，法线分布函数不是真正意义上的概率密度函数，它实际表示的是**单位面积，单位立体角的微平面的面积**。而之前有提到过法线分布函数的一个限制：  

$$ \int_{\Omega} D(\omega_h) n \cdot \omega_h d\omega_h = 1 $$

然后就可以发现这个限制，和概率密码函数的定义：$\,\int_{\Omega} \rho(\omega_i) d\omega_i = 1 \,$ 几乎是一样的，唯一的区别就是需要将法线分布函数的 $\,d\omega_h\,$ 转换为概率密度函数的 $\,d\omega_i\,$。在 Cook Torrance BRDF 的公式的推导中（之前的 BRDF 文章里没有提到，这里也不打算详细介绍了，有兴趣额外去查阅），有个公式：

$$ d\omega_h = \cfrac {1} {4(\omega_o \cdot \omega_h)} d\omega_i $$

那么就可以得到：  

$$ \rho(\omega_i) = \cfrac {D(\omega_h)(n \cdot \omega_h)} {4(\omega_o \cdot \omega_h)} $$

④将概率密度函数 $\,\rho(\omega_i)\,$ 代入回之前的式子：  

$$ L_c = \cfrac {\frac {1} {N} \sum_{k = 1}^N \cfrac{ D(\omega_h) F(\omega_h, \omega_o) G(\omega_i, \omega_o) L_i(p, \omega_i) n \cdot \omega_i } {4 (n \cdot \omega_i)(n \cdot \omega_o) \cfrac {D(\omega_h)(n \cdot \omega_h)} {4(\omega_o \cdot \omega_h)}}} {\frac {1} {N} \sum_{k = 1}^N \cfrac{ D(\omega_h) F(\omega_h, \omega_o) G(\omega_i, \omega_o) n \cdot \omega_i } {4 (n \cdot \omega_i)(n \cdot \omega_o) \cfrac {D(\omega_h)(n \cdot \omega_h)} {4(\omega_o \cdot \omega_h)}}} = \cfrac {\frac {1} {N} \sum_{k = 1}^N \cfrac{ F(\omega_h, \omega_o) G(\omega_i, \omega_o) L_i(p, \omega_i) } {4 (n \cdot \omega_o) \cfrac {(n \cdot \omega_h)} {4(\omega_o \cdot \omega_h)}}} {\frac {1} {N} \sum_{k = 1}^N \cfrac{ F(\omega_h, \omega_o) G(\omega_i, \omega_o) } {4 (n \cdot \omega_o) \cfrac {(n \cdot \omega_h)} {4(\omega_o \cdot \omega_h)}}} $$

⑤接下来对式子的简化需要更多的假设，首先是令 $\,\omega_o\,$ = $\,n\,$ = $\,r\,$，其中 $\,r\,$ 是反射视角方向（根据该方向对 Pre-Filtered Environment Map 采样，具体解释见后面的几个小节），这个假设是整个方案误差的最大来源。这样上面的式子可以进一步化简为：  

$$ L_c = \cfrac {\frac {1} {N} \sum_{k = 1}^N F(\omega_h, \omega_o) G(\omega_i, \omega_o) L_i(p, \omega_i) } {\frac {1} {N} \sum_{k = 1}^N  F(\omega_h, \omega_o) G(\omega_i, \omega_o) } $$

⑥至于 $\,F\,$ 项和 $\,G\,$ 项，也都是简单粗暴地假设为 1，在实践中发现 $\,F\,$ 项 影响不大。至于 $\,G\,$ 项 ，Epic Games 在实践中发现用权重函数 $\,W(\omega_i) = n \cdot \omega_i\,$，替代直接假设 $\,G\,$ 项 为 1，可以得到更好的效果。所以最终公式如下（最上面提到的 Spilt sum approximation 的公式是简易版本，实际在代码中乘上了权重函数）： 

$$ L_c = \cfrac {\frac {1} {N} \sum_{k = 1}^N n \cdot \omega_i L_i(p, \omega_i) } {\frac {1} {N} \sum_{k = 1}^N n \cdot \omega_i } $$

---

综上所述，该近似方案是一个具有较多假设的，具有一定误差的非物理的方案，但总体得到的结果是可以接受的。接下来就是应用的问题，先考虑 $\,L_c\,$ 项，即如何对环境贴图存储的 radiance 进行卷积，以便根据不同的 roughness 把结果存储到不同 mip-map 级别的 cubemap 中，最后在使用时进行采样。因为这个方案使用的是微表面 BRDF 模型，故使用 **GGX 重要性采样**，让采样方向更加贴合镜面波瓣的形状，以便更快地收敛，那么我们在下一节首先先了解一下 GGX 重要性采样。

但即使是重要性采样，也几乎只能用于离线操作，故需要把结果存储到 **Pre-Filtered Environment Map**。当然也有实时更新环境贴图并快速卷积的技术，该技术适用于移动的物体，比如从一个房间进入另一个房间，日后有需求建议额外了解（可以找找那些知名游戏的方案）。

### GGX Importance Sampling
#### GGX 逆变换采样推导
在已知宏观法线 $\,n\,$ 情况下，可以根据 GGX 概率密度函数生成微平面法线/半角向量 $\,h\,$ 的分布，再利用 $\,h\,$ 与 $\,v\,$ 和 $\,l\,$ 的关系反求出入射方向 $\,l\,$，就可以得到入射光线的分布。

那么根据之前提到过的 GGX 概率密度函数：  

$$ \int_{\Omega} D(\omega_h) n \cdot \omega_h d\omega_h = 1 $$

①我们首先要先将其转换至球坐标下的函数（下面展示的是以 n 为 z 轴的右手球坐标系的计算结果，即切线空间，其中 $\,\theta\,$ 是半角向量 h 和 n 之间的夹角）：

$$ d\omega_h = sin\theta d\theta d\phi $$
$$ \Rightarrow \rho(w_h) = D(\omega_h) cos\theta sin\theta $$

②而 GGX 分布的公式为：  

$$ D(\omega_h) = \cfrac {\alpha^2} {\pi( (n \cdot \omega_h)^2(\alpha^2 - 1) + 1)^2} $$

那么概率密度函数可以写为：  

$$ \rho(w_h) = \rho(\theta, \phi) = \cfrac {\alpha^2 cos\theta sin\theta} {\pi( cos^2\theta(\alpha^2 - 1) + 1)^2} $$

③接着就是求出对于 $\,\theta\,$、$\,\phi\,$ 的边缘概率密度函数：

$$ \rho_\theta(\theta, \phi) = \int_0^{2 \pi} \cfrac {\alpha^2 cos\theta sin\theta} {\pi( cos^2\theta(\alpha^2 - 1) + 1)^2} d\phi = \cfrac {2 \alpha^2 cos\theta sin\theta} {( cos^2\theta(\alpha^2 - 1) + 1)^2} $$

$$ \rho_\phi(\theta, \phi) = \int_0^{\pi / 2} \cfrac {\alpha^2 cos\theta sin\theta} {\pi( cos^2\theta(\alpha^2 - 1) + 1)^2} d\theta $$

这里化简比较复杂，对 $\,cos^2\theta\,$ 求导可得：  

$$ \cfrac {dcos^2 \theta} {d\theta} = 2 cos\theta (-sin\theta) = -2 cos\theta sin\theta $$

$$ cos\theta sin\theta d\theta = - \cfrac {1} {2} dcos^2 \theta $$

故上面的 $\,\rho_\phi(\theta, \phi)\,$ 可以进一步简化为：  

$$ \rho_\phi(\theta, \phi) = \cfrac {\alpha^2} {2 \pi} \int^0_{\pi / 2} \cfrac {dcos^2 \theta}{( cos^2\theta(\alpha^2 - 1) + 1)^2} $$

接着用换元法，将 $\,cos^2 \theta = t\,$：  

$$ \rho_\phi(\theta, \phi) = \cfrac {\alpha^2} {2 \pi} \int^1_0 \cfrac {dt}{( t(\alpha^2 - 1) + 1)^2} $$

还是求导，对 $\,t(\alpha^2 - 1) + 1\,$ 求导：  

$$ d(t(\alpha^2 - 1) + 1) = (\alpha^2 - 1) dt$$

故：  

$$ \rho_\phi(\theta, \phi) = \cfrac {\alpha^2} {2 \pi (\alpha^2 - 1)} \int^1_0 \cfrac {d(t(\alpha^2 - 1) + 1)}{( t(\alpha^2 - 1) + 1)^2} $$

继续换元，令 $\,t(\alpha^2 - 1) + 1 = x\,$：  

$$ \rho_\phi(\theta, \phi) = \cfrac {\alpha^2} {2 \pi (\alpha^2 - 1)} \int^{\alpha^2}_1 \cfrac {dx}{x^2} = \cfrac {\alpha^2} {2 \pi (\alpha^2 - 1)} \left. \cfrac {1}{x} \right\rvert_{\alpha^2}^1 = \cfrac {\alpha^2} {2 \pi (\alpha^2 - 1)} \left( 1 - \cfrac {1} {\alpha^2}\right) = \cfrac {1} {2\pi} $$

④再求出对于 $\,\theta\,$、$\,\phi\,$ 的边缘累计密度函数：  

$$ CDF_\phi(\theta, \phi) = \int_0^\phi \cfrac {1} {2\pi} d\phi = \cfrac {\phi} {2\pi} $$

$$ CDF_\theta(\theta, \phi) = \int_0^\theta \cfrac {2 \alpha^2 cos\theta sin\theta} {( cos^2\theta(\alpha^2 - 1) + 1)^2} d\theta = \alpha^2 \int_\theta^0 \cfrac {dcos^2\theta} {( cos^2\theta(\alpha^2 - 1) + 1)^2} = \alpha^2 \int_{cos^2 \theta}^1 \cfrac {dt} {( t(\alpha^2 - 1) + 1)^2} $$

$$ = \cfrac {\alpha^2} {\alpha^2 - 1} \int_{cos^2 \theta}^1 \cfrac {d(t(\alpha^2 - 1) + 1)} {( t(\alpha^2 - 1) + 1)^2} = \cfrac {\alpha^2} {\alpha^2 - 1} \int_{cos^2 \theta (\alpha^2 - 1) + 1}^{\alpha^2} \cfrac {dx}{x^2} = \cfrac {\alpha^2} {\alpha^2 - 1} \left. \cfrac {1} {x} \right\rvert_{\alpha^2}^{cos^2 \theta (\alpha^2 - 1) + 1} $$

$$= \cfrac {\alpha^2}{cos^2 \theta (\alpha^2 - 1)^2 + (\alpha^2 - 1) } - \cfrac {1} {\alpha^2 - 1} $$

⑤最后求出反函数：  

$$ \phi = 2 \pi \xi_1 $$
$$ \theta = arccos \sqrt{\cfrac {1 - \xi_2} {1 + (\alpha^2 - 1)\xi_2}} $$

#### GGX 重要性采样代码
UE4 中的 HLSL 代码如下（右手坐标系）：  

``` C
float3 ImportanceSampleGGX( float2 Xi, float Roughness, float3 N )
{
    float a = Roughness * Roughness;

    float Phi = 2 * PI * Xi.x;
    float CosTheta = sqrt( (1 - Xi.y) / ( 1 + (a*a - 1) * Xi.y ) );
    float SinTheta = sqrt( 1 - CosTheta * CosTheta );

    float3 H;
    H.x = SinTheta * cos( Phi );
    H.y = SinTheta * sin( Phi );
    H.z = CosTheta;

    float3 UpVector = abs(N.z) < 0.999 ? float3(0,0,1) : float3(1,0,0);
    float3 TangentX = normalize( cross( UpVector, N ) );
    float3 TangentY = cross( N, TangentX );
    // Tangent to world space
    return TangentX * H.x + TangentY * H.y + N * H.z;
}
```

用 Python 的 matplotlib 库绘制的微观法线向量分布图如下：  

<div  align="center">  
<img src="https://s2.loli.net/2024/08/28/VCj9lD2Qpy7ZcFi.png" width = "80%" height = "80%" alt="图16 - 左图：粗糙度为 0；中图：粗糙度为 0.5；右图：粗糙度为 1"/>
</div>

可以看到粗糙度为 0 的时候，微观法线就是宏观法线方向。

> 其实根据 GGX 重要性采样，我们可以强行实时计算镜面反射 BRDF，代码可以参考上面发的《Real Shading in Unreal Engine 4》这篇文章，就不在这里摘抄了。当然即使是重要性采样，实时运算依旧困难，故主流方案还是对环境贴图进行预滤波并存储起来。

#### 低差异序列
在回到 Spilt sum approximation 之前，我们补充一个生成伪随机数的方法（上面代码中的 `Xi` 就是逆变换采样公式中的随机值 $\,\xi_1\,$ 和 $\,\xi_2\,$）。

之前在 Irradiance map 中使用的生成随机样本向量的方法是**完全（伪）随机 completely（pseudo）random** 的，但是这样生成的样本并不够均匀。所以我们可以使用一种叫做**低差异序列 Low-discrepancy sequence** 的方法生成**半随机 semi-random** 或称**准随机 quasi-random** 的样本，这种方法生成的样本更加均匀，如下图所示：  

<div  align="center">  
<img src="https://s2.loli.net/2024/08/29/gGDlE9AJ1mx3QhL.png" width = "60%" height = "60%" alt="图17 - 左图：伪随机序列；右图：低差异序列"/>
</div>

这种利用低差异序列生成蒙特卡洛样本的数值积分方法也成为**准蒙特卡洛积分 Quasi-Monte Carlo Integration**。准蒙特卡洛积分具有更快的收敛速度。

常见的低差异序列包括：**Halton sequence**、**Hammersley sequence**、**Sobol sequence** 等等（Halton sequence 和 Hammersley sequence 都是高维的 **Van der Corput sequence**）。

这里只摘抄一下，**Hammersley sequence** 的实现代码，具体原理逻辑有需求再去详细了解，以下为 GLSL 代码：  

``` C
float RadicalInverse_VdC(uint bits) 
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}

vec2 Hammersley(uint i, uint N)
{
    return vec2(float(i)/float(N), RadicalInverse_VdC(i));
}

const uint SAMPLE_COUNT = 4096u;
for(uint i = 0u; i < SAMPLE_COUNT; ++i)
{
    vec2 Xi = Hammersley(i, SAMPLE_COUNT);
    ...
}
```

以下为使用 Python 的 matplotlib 库绘制的 Hammersley sequence 生成的球面采样和 GGX 采样图：

<div  align="center">  
<img src="https://s2.loli.net/2024/08/29/3hW42EFHqUiSL1s.png" width = "60%" height = "60%" alt="图18 - 左图：使用 Hammersley sequence 生成样本的球面逆变换采样；右图：使用 Hammersley sequence 生成样本的 GGX 逆变换采样"/>
</div>


### Pre-Filtered Environment Map
既然实时求积分基本上做不到，那我们回到 Spilt sum approximation 的 $\,L_c\,$ 项，我们的方案是通过根据不同粗糙度的 GGX 重要性采样预计算 $\,L_c\,$ 项，并存储在不同 mipmap 级别的 Pre-Filtered Environment Map 中，然后在渲染时，根据反射视角方向 $\,R\,$ 对贴图进行采样获取存储的 radiance 均值。那么为什么可以这么做呢？

我们知道粗糙度影响着 GGX 分布，即微观法线的分布，从而影响到特定观察方向上接收到的入射光镜面波瓣的大小，而这个镜面波瓣（或着说镜面 BRDF）只会在视角反射方向 $\,R\,$ 附近有值，如下图所示：  

<div  align="center">  
<img src="https://s2.loli.net/2024/08/29/HKvA9pDBSeJINbX.png" width = "50%" height = "50%" alt="图19 - 左图：完美镜面反射采样环境贴图；右图：镜面波瓣采样环境贴图"/>
</div>

之前也说过，问题就在于这个镜面波瓣形状跟宏观法线方向和观察方向都相关，我们也不可能预计算出对于每一个法线方向和观察方向的 N 张 Cubemap。这就用到了我们之前推导公式时，所使用的假设，即令 $\,\omega_o = n = R\,$（这里的 $\,R\,$ 是根据宏观法线 n 和观察方向得到的视角反射方向，和上面那张图镜面波瓣的产生是因为微表面法线 m 导致的视角反射方向分散之间注意区分），如下图所示：  

<div  align="center">  
<img src="https://s2.loli.net/2024/08/29/Ci2GUpzqwrVOWlx.png" width = "60%" height = "60%" alt="图20 - v = n = r"/>
</div>

这里对镜面波瓣的近似，忽略了 $\,\omega_o\,$ 和 $\,n\,$ 的具体方向，假设视角永远垂直于表面，是整个近似方案误差的最大来源。而这个误差具体表现为缺少了镜面反射时的拉伸效应，特别是在接近掠射角 grazing angle 方向的时候，如下图所示：  

<div  align="center">  
<img src="https://s2.loli.net/2024/08/29/jmBpzNb8KAfwqSX.png" width = "90%" height = "90%" alt="图21 - 假设 v = n = r 所产生的误差"/>
</div>

#### 预过滤代码
在写代码前，我们重新梳理下逻辑（要区分渲染时的向量和预过滤时的向量，否则逻辑会捋不顺）：

我们对环境贴图进行预过滤，首先要明确 Pre-Filtered Environment Map 记录的是什么信息，其记录的是视角反射方向 $\,r\,$ 周围入射光线 $\,\omega_i\,$（即镜面波瓣）的 Radiance 的加权平均值，这也是为什么我们使用预过滤环境贴图能直接拿渲染时的视角反射方向 $\,r\,$ 采样获取信息。

但是在预过滤时，我们不知道要渲染的像素点的宏观法线方向 $\,n\,$ 和视角方向 $\,\omega_o\,$，故无法知道视角反射方向 $\,r\,$，就无法得到视角反射方向周围的镜面波瓣。这时就需要我们的假设 $\,v = n = r\,$ 了，这个假设本质上改变了预过滤时的（贴图记录时的）物体表面的朝向和视角方向，也某种程度地改变了镜面波瓣的形状从而产生了误差。这样我们就可以根据每一个 $\,r\,$ 方向（其实就是球内任意方向）去记录这个近似的镜面波瓣的 Radiance 加权平均值。

而这个加权平均值是 GGX 重要性采样产生的样本计算而得。首先 GGX 重要性采样是根据宏观法线方向 $\,n\,$ 生成微平面法线 $\,m\,$ 或 $\,h\,$ 的分布，我们再根据我们假设的视角方向 $\,\omega_o\,$，其实就是 $\,n\,$，生成入射方向 $\,\omega_i\,$ 的分布，从而获取到 Radiance 的值（预过滤时不用太过纠结 $\,\omega_o\,$ 和 $\,n\,$ 和 $\,r\,$ 的区别，因为遍历 $\,r\,$ 方向就是遍历 $\,n\,$ 方向）。当然不同的粗糙度会有不同的 GGX 分布，所以需要使用 mipmap 记录不同的粗糙度的贴图。

这样在渲染时，我们根据采样点的法线方向 $\,n\,$ 和摄像机观察方向 $\,\omega_o\,$ ，计算出视角反射方向 $\,r\,$ 对预过滤的环境贴图采样即可。

UE4 中的 HLSL 代码如下： 

``` C
float3 PrefilterEnvMap( float Roughness, float3 R )
{
    float3 N = R;
    float3 V = R;

    float3 PrefilteredColor = 0;

    const uint NumSamples = 1024;
    for( uint i = 0; i < NumSamples; i++ )
    {
        float2 Xi = Hammersley( i, NumSamples );
        float3 H = ImportanceSampleGGX( Xi, Roughness, N );
        float3 L = 2 * dot( V, H ) * H - V;

        float NoL = saturate( dot( N, L ) );
        if( NoL > 0 )
        { 
            PrefilteredColor += EnvMap.SampleLevel( EnvMapSampler, L, 0 ).rgb * NoL;
            TotalWeight += NoL;
        }
    }

    return PrefilteredColor / TotalWeight;
}
```

我用 Unity 按不同粗糙度预过滤的环境贴图如下（代码就不摘抄出来了）：  

<div  align="center">  
<img src="https://s2.loli.net/2024/08/30/rmYSaIFhARE2qjx.png" width = "100%" height = "100%" alt="图22 - 不同粗糙度的预过滤环境贴图"/>
</div>

实际上以不同粗糙度存储预过滤环境贴图时，mipmap 级别越高存储的贴图分辨率越小。同时，若我们仔细看上面粗糙度为 1 的预过滤环境贴图，是可以看到一些点状图案的，这是由于高频信息多，采样不足而产生的，我们可以通过加大采样解决，还有一个解决方案就是根据粗糙度采样原环境贴图的 mipmap（有需求自行查阅如何实现）。

### Environment BRDF
接下来就是 Spilt sum approximation 的后半部分 **Environment BRDF 项**：  

$$ \int_{\Omega} f_r(p, \omega_o, \omega_i) n \cdot \omega_i d \omega_i $$

我们需要对该式进行化简，首先将 $\,F\,$ 从镜面 BRDF 提取出来：  

$$ \int_{\Omega} f_r(p, \omega_o, \omega_i) n \cdot \omega_i d \omega_i = \int_{\Omega} \cfrac {f_r(p, \omega_o, \omega_i)} {F(\omega_o, \omega_h)} F(\omega_o, \omega_h) n \cdot \omega_i d \omega_i $$

$$ = \int_{\Omega} \cfrac {f_r(p, \omega_o, \omega_i)} {F(\omega_o, \omega_h)} (F_0 + (F_{90} - F_0)(1 - \omega_o \cdot \omega_h)^5) n \cdot \omega_i d \omega_i $$

用 $\,\alpha\,$ 替换 $\,(1 - \omega_o \cdot \omega_h)^5\,$ 得到：  

$$ \Rightarrow \int_{\Omega} \cfrac {f_r(p, \omega_o, \omega_i)} {F(\omega_o, \omega_h)} (F_0 + (F_{90} - F_0) \alpha) n \cdot \omega_i d \omega_i = \int_{\Omega} \cfrac {f_r(p, \omega_o, \omega_i)} {F(\omega_o, \omega_h)} (F_0(1 - \alpha) + F_{90} \alpha) n \cdot \omega_i d \omega_i $$

将加法从积分中拆分出来：  

$$ \Rightarrow \int_{\Omega} \cfrac {f_r(p, \omega_o, \omega_i)} {F(\omega_o, \omega_h)} F_0(1 - \alpha) n \cdot \omega_i d \omega_i + \int_{\Omega} \cfrac {f_r(p, \omega_o, \omega_i)} {F(\omega_o, \omega_h)} F_{90} \alpha n \cdot \omega_i d \omega_i $$

最后把 $\,F_0\,$、$\,F_{90}\,$ 提出来：  

$$ \Rightarrow F_0 \int_{\Omega} \cfrac {f_r(p, \omega_o, \omega_i)} {F(\omega_o, \omega_h)} (1 - (1 - \omega_o \cdot \omega_h)^5) n \cdot \omega_i d \omega_i + F_{90} \int_{\Omega} \cfrac {f_r(p, \omega_o, \omega_i)} {F(\omega_o, \omega_h)} (1 - \omega_o \cdot \omega_h)^5 n \cdot \omega_i d \omega_i $$

$$ \Rightarrow F_0 \times scale + F_{90} \times bias $$

而这个 scale 和 bias 可以用类似于 $\,L_c\,$ 类似的化简方法，即根据 GGX 重要性采样的蒙特卡洛积分化简，以 scale 为例：  

$$ \begin{align*} scale &\approx \frac {1} {N} \sum_{k = 1}^N \cfrac{ D(\omega_h) G(\omega_i, \omega_o) (1 - (1 - \omega_o \cdot \omega_h)^5) n \cdot \omega_i } {4 (n \cdot \omega_i)(n \cdot \omega_o) \rho(\omega_i)} \\ &= \frac {1} {N} \sum_{k = 1}^N \cfrac{ D(\omega_h) G(\omega_i, \omega_o) (1 - (1 - \omega_o \cdot \omega_h)^5) n \cdot \omega_i } {4 (n \cdot \omega_i)(n \cdot \omega_o) \cfrac {D(\omega_h)(n \cdot \omega_h)} {4(\omega_o \cdot \omega_h)}} \\ &= \frac {1} {N} \sum_{k = 1}^N \cfrac{ G(\omega_i, \omega_o) (1 - (1 - \omega_o \cdot \omega_h)^5) \omega_o \cdot \omega_h } { (n \cdot \omega_o) (n \cdot \omega_h) } \end{align*} $$

bias 也类似。这样我们就可以根据两个参数 $\,cos\theta\,$（$\,\theta\,$ 是 $\,\omega_o\,$ 和 $\,n\,$ 的夹角）以及 roughness 构建一个二维纹理来存储积分的结果，这个纹理即 **2D LUT，Look Up Texture**，其中 scale 存储为 R 通道，bias 存储为 G 通道，roughness 为 uv 的 v，$\,cos\theta\,$ 是 uv 的 u。

#### 2D LUT
我们可以看到 scale 或 bias 的简化后的式子里，有变量 $\,n \cdot \omega_o\,$、$\,n \cdot \omega_h\,$、$\,n \cdot \omega_i\,$（$\,G\,$ 项里）、$\,\omega_o \cdot \omega_h\,$，那么为什么只需要存储一个 $\,cos\theta\,$。因为上述变量都是角度的余弦值，我们不需要对具体方向上进行采样，所以我们不用关心 n 的具体方向。我们可以假定一个 n 的具体方向，比如 (0, 0, 1)，根据 $\,cos\theta\,$，计算出 $\,\omega_o\,$。再根据 GGX 分布得到 $\,\omega_h\,$ 的分布，也可以计算出 $\,\omega_i\,$ 了。那么存储一个 $\,cos\theta\,$ 相当于存储了 4 个角度余弦值。

UE4 的 HLSL 实现代码如下（文章里建议用 16 位图存储，而不是一般使用的 8 位图，因为精度对效果比较重要）：  

``` C
float2 IntegrateBRDF( float Roughness, float NoV )
{
    float3 V;
    V.x = sqrt( 1.0f - NoV * NoV ); // sin
    V.y = 0;
    V.z = NoV; // cos

    float A = 0;
    float B = 0;

    const uint NumSamples = 1024;
    for( uint i = 0; i < NumSamples; i++ )
    {
        float2 Xi = Hammersley( i, NumSamples );
        float3 H = ImportanceSampleGGX( Xi, Roughness, N );
        float3 L = 2 * dot( V, H ) * H - V;

        float NoL = saturate( L.z );
        float NoH = saturate( H.z );
        float VoH = saturate( dot( V, H ) );

        if( NoL > 0 )
        {
            float G = G_Smith( Roughness, NoV, NoL );
            float G_Vis = G * VoH / (NoH * NoV);
            float Fc = pow( 1 - VoH, 5 );
            A += (1 - Fc) * G_Vis;
            B += Fc * G_Vis;
        }
    }
    return float2( A, B ) / NumSamples;
}
```

代码中的 G_Smith 函数，由于 Epic Games 的这篇文章发表于 2013 年，故使用的是 Smith 分离的遮蔽阴影函数，可以把它替换为后面主流的 Smith 相关的遮蔽阴影函数。故得到的 2D LUT 会有略微的不同之处。

> 顺便提一下，使用遮蔽阴影函数的时候要注意得到的是 V 项还是 G 项。LearnOpenGL 的教程里还提到 UE4 的 IBL 使用的 G_Smith 函数的 $\,k = roughness^2 / 2\,$，和直接光的 G_Smith 函数的 $\,k = (roughness + 1)^2 / 8\,$ 不一样。使用 $\,k = roughness^2 / 2\,$ 可以得到文章中同样的 2D LUT 图。

我使用 Unity 的 Compute Shader 生成了分别使用 Smith 分离的遮蔽阴影函数和 Smith 相关的遮蔽阴影函数的 2D LUT 图，如下。理论上要生成的是 16 位的线性 EXR 图，在代码里我是这样写的，但是由于我用的图床不支持上传 EXR，故展示的是 SRGB 的 png 格式（相比于线性来说看起来颜色会暗一点）。代码我放在了后面，作为汇总。

<div  align="center">  
<img src="https://s2.loli.net/2024/08/30/OKY17eqxThJMHRt.png" width = "100%" height = "100%" alt="图23 - Smith 分离的遮蔽阴影函数生成的 2D LUT"/>
</div>

<div  align="center">  
<img src="https://s2.loli.net/2024/08/30/OSIMdFwy5NapW6G.png" width = "100%" height = "100%" alt="图24 - Smith 相关的遮蔽阴影函数生成的 2D LUT"/>
</div>

可以看到 Smith 相关的遮蔽阴影函数生成的 2D LUT 比 Smith 分离的遮蔽阴影函数生成的的左上角要稍微亮一点。

#### 解析拟合
> Call of Duty: Black Ops 的文章：https://blog.selfshadow.com/publications/s2013-shading-course/lazarov/s2013_pbs_black_ops_2_notes.pdf  

解析拟合是通过数学工具拟合出 2D LUT 的曲线，这样就不需要额外的贴图采样，是有效的优化方案。最早由 Call of Duty: Black Ops 提出（注意 g 是 gloss，等于 1 - roughness，该代码应该是使用 Blinn-Phong 分布采样，拟合 Smith 分离的遮蔽阴影函数所产生的结果）：  

``` C
float3 EnvironmentBRDF( float g, float NoV, float3 rf0 )
{
    float4 t = float4( 1/0.96, 0.475, (0.0275 - 0.25 * 0.04)/0.96, 0.25 );
    t *= float4( g, g, g, g );
    t += float4( 0, 0, (0.015 - 0.75 * 0.04)/0.96, 0.75 );
    float a0 = t.x * min( t.y, exp2( -9.28 * NoV ) ) + t.z;
    float a1 = t.w;
    return saturate( a0 + rf0 * ( a1 - a0 ) );
}
```

https://knarkowicz.wordpress.com/2014/12/27/analytical-dfg-term-for-ibl/ 这篇文章提出了基于 GGX 分布的解析拟合版本（拟合应该是 Smith 相关的遮蔽阴影函数）：  

``` C
float3 EnvDFGLazarov( float3 specularColor, float gloss, float ndotv )
{
    float4 p0 = float4( 0.5745, 1.548, -0.02397, 1.301 );
    float4 p1 = float4( 0.5753, -0.2511, -0.02066, 0.4755 );
 
    float4 t = gloss * p0 + p1;
 
    float bias = saturate( t.x * min( t.y, exp2( -7.672 * ndotv ) ) + t.z );
    float delta = saturate( t.w );
    float scale = delta - bias;
 
    bias *= saturate( 50.0 * specularColor.y );
    return specularColor * scale + bias;
}
```

而后来 UE 也有一个类似的代码（文章在 https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile ，不知道拟合的是 Smith 相关的遮蔽阴影函数还是分离的，文章里没说，感觉根据时间应该也是 Smith 相关的遮蔽阴影函数），如下：  

``` C
//UE4 Black Ops II modify version
float2 EnvBRDFApproxLazarov(float Roughness, float NoV)
{
    // Adaptation to fit our G term.
    const float4 c0 = {-1, -0.0275, -0.572, 0.022};
    const float4 c1 = {1, 0.0425, 1.04, -0.04};
    float4 r = Roughness * c0 + c1;
    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;
    float2 AB = float2(-1.04, 1.04) * a004 + r.zw;
    return AB;
}

float3 EnvBRDFApprox(float3 SpecularColor, float Roughness, float NoV)
{
    float2 AB = EnvBRDFApproxLazarov(Roughness, NoV);

    // Anything less than 2% is physically impossible and is instead considered to be shadowing
	// Note: this is needed for the 'specular' show flag to work, since it uses a SpecularColor of 0
	float F90 = saturate( 50.0 * SpecularColor.g );

    return SpecularColor * AB.x + F90 * AB.y;
}
```

#### Unity 生成 2D LUT 代码
C# 部分代码：  

``` C#
using UnityEngine;
using UnityEditor;
using System.IO;
using Sirenix.OdinInspector;
using Sirenix.OdinInspector.Editor;

public class EnvBRDFLUT : OdinEditorWindow
{
    [MenuItem("Tools/Environment BRDF 2D LUT")]
    private static void ShowWindow()
    {
        EnvBRDFLUT window = OdinEditorWindow.GetWindow<EnvBRDFLUT>();
        window.Show();
    }
    
    public ComputeShader envBRDFLUTComputeShader;
    
    private RenderTexture m_EnvBRDFMap;
    [InlineEditor(InlineEditorModes.LargePreview)]
    public Texture2D outputTexture;
    
    public int sampleNumber = 1024;
    public int lutImageSize = 1024;
    
    [Button(ButtonSizes.Large), GUIColor(0.4f, 0.8f, 1)]
    private void PreintegrateBRDF()
    {
        m_EnvBRDFMap = new RenderTexture(lutImageSize, lutImageSize, 32, RenderTextureFormat.ARGBHalf);
        m_EnvBRDFMap.enableRandomWrite = true;
        m_EnvBRDFMap.Create();
        
        int kernelIndex = envBRDFLUTComputeShader.FindKernel("PreintegrateBRDF");
        
        envBRDFLUTComputeShader.SetTexture(kernelIndex, "envBRDFMap", m_EnvBRDFMap);
        envBRDFLUTComputeShader.SetInt("sampleNumber", sampleNumber);
        envBRDFLUTComputeShader.SetInt("lutImageSize", lutImageSize);
        envBRDFLUTComputeShader.Dispatch(kernelIndex, lutImageSize / 32, lutImageSize / 16, 1);

        outputTexture = new Texture2D(lutImageSize, lutImageSize, TextureFormat.RGBAHalf, false);
        Graphics.CopyTexture(m_EnvBRDFMap, outputTexture);
        
        RenderTexture.active = m_EnvBRDFMap;
        outputTexture.ReadPixels(new Rect(0, 0, m_EnvBRDFMap.width, m_EnvBRDFMap.height), 0, 0);
        RenderTexture.active = null;
        
        var bytes = ImageConversion.EncodeToEXR(outputTexture, Texture2D.EXRFlags.CompressZIP);
        File.WriteAllBytes(Application.dataPath + "/2DLUT.exr", bytes);
    }
}
```

以下是 Computer Shader 的 HLSL 代码：  

``` C
#pragma kernel PreintegrateBRDF

RWTexture2D<float4> envBRDFMap;
int sampleNumber;
int lutImageSize;

float RadicalInverse_VdC(uint bits) 
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10;
}

float2 Hammersley(uint i, uint N)
{
    return float2(float(i)/float(N), RadicalInverse_VdC(i));
}

float3 ImportanceSampleGGX( float2 Xi, float Roughness, float3 N )
{
    float a = Roughness * Roughness;
    float Phi = 2 * PI * Xi.x;
    float CosTheta = sqrt( (1 - Xi.y) / ( 1 + (a*a - 1) * Xi.y ) );
    float SinTheta = sqrt( 1 - CosTheta * CosTheta );
    
    float3 H;
    H.x = SinTheta * cos( Phi );
    H.y = SinTheta * sin( Phi );
    H.z = CosTheta;
    
    float3 UpVector = abs(N.z) < 0.999 ? float3(0,0,1) : float3(1,0,0);
    float3 TangentX = normalize( cross( UpVector, N ) );
    float3 TangentY = cross( N, TangentX );
    // Tangent to world space
    return TangentX * H.x + TangentY * H.y + N * H.z;
}

float Vis_SmithJointApprox( float roughness, float NoV, float NoL )
{
    float a = roughness * roughness;
    float Vis_SmithV = NoL * ( NoV * ( 1 - a ) + a );
    float Vis_SmithL = NoV * ( NoL * ( 1 - a ) + a );
    return 0.5 * rcp( Vis_SmithV + Vis_SmithL );
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float a = roughness;
    float k = (a * a) / 2.0;

    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return nom / denom;
}

float GeometrySmith( float NdotV, float NdotL, float roughness)
{
    float ggx2 = GeometrySchlickGGX(NdotV, roughness);
    float ggx1 = GeometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
} 

float2 IntegrateBRDF( float Roughness, float NoV )
{
    float3 V;
    V.x = sqrt( 1.0f - NoV * NoV ); // sin
    V.y = 0;
    V.z = NoV; // cos

    float3 N = float3(0, 0, 1);
    float A = 0;
    float B = 0;
    const uint NumSamples = 1024;
    for( uint i = 0; i < NumSamples; i++ )
    {
        float2 Xi = Hammersley( i, NumSamples );
        float3 H = ImportanceSampleGGX( Xi, Roughness, N );
        float3 L = 2 * dot( V, H ) * H - V;
        float NoL = saturate( L.z );
        float NoH = saturate( H.z );
        float VoH = saturate( dot( V, H ) );
        if( NoL > 0 )
        {
            float V = Vis_SmithJointApprox( Roughness, NoV, NoL );
            float G = V * 4 * NoL * NoV;
            // float G = GeometrySmith(NoV, NoL, Roughness);
            float G_Vis = G * VoH / (NoH * NoV);
            float Fc = pow( 1 - VoH, 5 );
            A += (1 - Fc) * G_Vis;
            B += Fc * G_Vis;
        }
    }
    return float2( A, B ) / NumSamples;
}

[numthreads(32,16,1)]
void PreintegrateBRDF (uint3 id : SV_DispatchThreadID)
{
    float2 data = IntegrateBRDF(float(id.y)/(lutImageSize - 1), float(id.x)/(lutImageSize - 1));
    envBRDFMap[id.xy] = float4(data[0], data[1], 0.0, 1.0);
}
```

### IBL 最终渲染时实现
由此一来，对于镜面反射环境光，我们就得到了两类贴图，一个是 PreFiltered Environment Map，另一个就是 Environment BRDF 的 2D LUT 图。再加上漫反射环境光的 Irradiance map（当然球谐函数只保存了 27 个参数），一共三张贴图。这样我们就可以计算出环境光照了，最终近似公式如下（Irradiancemap 里乘进去了 $\,1/\pi\,$）：  

$$ L(w_o) = k_d^*\,c\,Irradiancemap(n) + L_c(r, roughness) \times (F_0 scale + F_{90} bias) $$

$\,F_{90}\,$ 一般都假设为 1，故代码（GLSL）如下：  

    \\上一篇文章的漫反射环境光部分
    vec3 F = FresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);

    vec3 kS = F;
    vec3 kD = 1.0 - kS;
    kD *= 1.0 - metallic; 

    vec3 irradiance = texture(irradianceMap, N).rgb;
    vec3 diffuse    = irradiance * albedo;

    \\镜面反射环境光部分
    vec3 R = reflect(-V, N);

    const float MAX_REFLECTION_LOD = 4.0;
    vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;   
    vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;
    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);

    \\最终环境光
    vec3 ambient = (kD * diffuse + specular) * ao;

## Asymmetric and Anisotropic lobes

# Unity URP 的镜面反射 IBL 实现