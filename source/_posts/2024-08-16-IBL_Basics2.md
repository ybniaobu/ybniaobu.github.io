---
title: IBL 基于图像的光照（二）
date: 2024-08-16 12:43:39
categories: 
  - [图形学]
tags:
  - 图形学
  - 游戏开发
top_img: /images/black.jpg
cover: https://s2.loli.net/2024/08/16/KQGyA6zfCW74dYw.gif
mathjax: true
description: 本笔记的主要内容有镜面反射环境光的实现：包括 XXXXXXXXX 的实现。
---

> 本篇文章主要参考了著名的 LearnOpenGL 教程：https://learnopengl-cn.github.io/ 或 https://learnopengl.com/ 、著名图形学书籍《Real-Time Rendering 4th》以及谷歌的 Filament PBR 白皮书：https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf 。

# 镜面反射 BRDF 积分
之前讲到的**环境映射 Environment Mapping** 最早是用作镜面渲染的技术，即根据视角的反射方向（入射方向）来对 radiance map 进行采样。当用于模拟无限远处光源的镜面效果时，这样的环境贴图也被称为**高光探针 Specular light probes**。

我们也可以将镜面反射扩展到**光泽 Glossy** 材质上，用于模拟材质表面的粗糙度。一个简单的方法就是对环境贴图进行**预滤波 prefilter**，即进行模糊处理，我们可以创建一个环境贴图的 mipmap 链，用于存储不同模糊程度的环境贴图。在使用时，对于越粗糙的表面使用越模糊的环境贴图。当然，这就是经验主义的近似做法，因为这跟 BRDF 没有关系。

而考虑 BRDF 函数时，我们需要考虑反射的形状，即**镜面波瓣 specular lobe**，而这个波瓣形状取决于粗糙度、观察方向、法线方向、入射方向。而粗糙度越大，波瓣越大，如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2024/08/16/DVuBnlJNHG68awp.png" width = "80%" height = "80%" alt="图15 - 镜面波瓣与粗糙度的关系"/>
</div>

当然我们为所有的参数组合存储环境贴图是不现实的事情，出于性能问题，也无法实时求解镜面反射的积分。为了解决问题，出现了很多 BRDF 近似方案，比如下面要讲到的**预过滤环境映射 Prefiltered environment mapping**、**分解求和近似 Split-sum approximation**（主流解决方案）以及**非对称与各向异性波瓣 Asymmetric and Anisotropic lobes**。

## Prefiltered environment mapping
这个方案是比较传统的，基于宏观表面 BRDF 而非微表面 BRDF 的近似方案，故只做简单介绍。其不考虑微表面的阴影遮挡项，以及将菲涅耳项放到了积分外部，并且该菲涅耳项是基于 $\,n \cdot v\,$ 的，而非基于微表面 BRDF 的 $\,v \cdot h\,$，故误差较大，如下式：

$$ L_o(p, \omega_o) = \int_{\Omega} f_r(p, \omega_i, \omega_o) L_i(p, \omega_i) n \cdot \omega_i d\omega_i \approx F(n,v) \int_{\Omega} D(\omega_i, \omega_o) L_i(\omega_i) n \cdot \omega_i d\omega_i $$

而这个 $\,D(\omega_i, \omega_o)\,$ 正是控制镜面波瓣形状的函数，对比上面说过的简单的模糊卷积核的方案的区别就在于更容易对波瓣形状进行控制，使得波瓣在反射向量周围径向对称。而传统的控制波瓣形状的模型就是 Phong 模型和 Blinn-Phong 模型，这两个模型都是幂次的余弦波瓣，只不过 Phong 模型是基于反射向量和观察向量点乘，Blinn-Phong 模型是半角向量和法线点乘。

为了模拟表面的粗糙度，还是会使用 mipmap，较高级别的 mipmap 用于存储更宽的余弦波瓣，即更粗糙的表面。接下来就是积分问题了，最常用的还是采用蒙特卡洛积分，但实际上我们不需要对所有样本进行采样，特别是当 $\,D(\omega_i, \omega_o) \approx 0\,$ 的时候。所以可以使用**重要性采样 importance sampling**，让概率分布更贴合镜面波瓣的形状，以减少采样需要的样本数。

但上述方法最适用的还是 Phong 模型，因为只有 Phong 模型可以简化成只跟反射向量和观察向量相关，这样就可以保存成一个二维的环境贴图。而其他模型还需要更多的假设（比如 v = n）或者使用一系列跟观察方向相关的贴图。

因为 IBL 对真实感十分重要，因此有了更多的技术来减少上述方法内含的 BRDF 近似误差问题。比如 Epic Games 提出的**分割求和近似 Spilt sum approximation**，其适用于微表面 BRDF。

## Spilt sum approximation

> 这里主要参考了 Epic Games 的文章《Real Shading in Unreal Engine 4》：https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf

Karis 的**分割求和近似 Spilt sum approximation** 方案将渲染方程的蒙特卡洛数值积分拆分为了 radiance 均值和环境 BRDF 两项，公式如下：  

$$ \begin{align*} \int_{\Omega} L_i(p, \omega_i) f_r(p, \omega_o, \omega_i) n \cdot \omega_i d \omega_i &\approx \cfrac {1} {N} \sum_{k=1}^N \cfrac {L_i(p, \omega_i^k) f_r(p, \omega_o, \omega_i^k) n \cdot \omega_i^k } {\rho(\omega_i^k)} \\ &\approx \left( \cfrac {1} {N} \sum_{k=1}^N L_i(p, \omega_i^k) \right) \left( \cfrac {1} {N} \sum_{k=1}^N \cfrac { f_r(p, \omega_o, \omega_i^k) n \cdot \omega_i^k } {\rho(\omega_i^k)} \right) \end{align*} $$

---

该近似方案的推导过程如下（懒得看的话就直接跳过，直接看后面对该近似的应用）：  
①首先将 $\,L\,$ 项提出：  

$$ L_o(p, \omega_o) = L_c \int_{\Omega} f_r(p, \omega_o, \omega_i) n \cdot \omega_i d \omega_i $$

其中：

$$ L_c = \cfrac {\int_{\Omega} L_i(p, \omega_i) f_r(p, \omega_o, \omega_i) n \cdot \omega_i d \omega_i} {\int_{\Omega} f_r(p, \omega_o, \omega_i) n \cdot \omega_i d \omega_i} $$

②将 $\,L_c\,$ 转换为蒙特卡洛积分的式子：  

$$ L_c = \cfrac {\frac {1} {N} \sum_{k = 1}^N \cfrac{ f_r L_i(p, \omega_i) n \cdot \omega_i } {\rho(\omega_i)}} {\frac {1} {N} \sum_{k = 1}^N \cfrac{ f_r n \cdot \omega_i } {\rho(\omega_i)}} = \cfrac {\frac {1} {N} \sum_{k = 1}^N \cfrac{ D(\omega_h) F(\omega_h, \omega_o) G(\omega_i, \omega_o) L_i(p, \omega_i) n \cdot \omega_i } {4 (n \cdot \omega_i)(n \cdot \omega_o) \rho(\omega_i)}} {\frac {1} {N} \sum_{k = 1}^N \cfrac{ D(\omega_h) F(\omega_h, \omega_o) G(\omega_i, \omega_o) n \cdot \omega_i } {4 (n \cdot \omega_i)(n \cdot \omega_o) \rho(\omega_i)}} $$

③接下来就是选择一个合适的概率密度函数 $\,\rho(\omega_i)\,$，因为在实践中我们会使用**重要性采样 importance sampling** 来加快收敛的速度，我们很容易就想到微表面的法线分布函数 $\,D(\omega_h)\,$。但是之前介绍 BRDF 的时候说过，法线分布函数不是真正意义上的概率密度函数，它实际表示的是**单位面积，单位立体角的微平面的面积**。而之前有提到过法线分布函数的一个限制：  

$$ \int_{\Omega} D(\omega_h) n \cdot \omega_h d\omega_h = 1 $$

然后就可以发现这个限制，和概率密码函数的定义：$\,\int_{\Omega} \rho(\omega_i) d\omega_i = 1 \,$ 几乎是一样的，唯一的区别就是需要将法线分布函数的 $\,d\omega_h\,$ 转换为概率密度函数的 $\,d\omega_i\,$。在 Cook Torrance BRDF 的公式的推导中（之前的 BRDF 文章里没有提到，这里也不打算详细介绍了，有兴趣额外去查阅），有个公式：

$$ d\omega_h = \cfrac {1} {4(\omega_o \cdot \omega_h)} d\omega_i $$

那么就可以得到：  

$$ \rho(\omega_i) = \cfrac {D(\omega_h)(n \cdot \omega_h)} {4(\omega_o \cdot \omega_h)} $$

④将概率密度函数 $\,\rho(\omega_i)\,$ 代入回之前的式子：  

$$ L_c = \cfrac {\frac {1} {N} \sum_{k = 1}^N \cfrac{ D(\omega_h) F(\omega_h, \omega_o) G(\omega_i, \omega_o) L_i(p, \omega_i) n \cdot \omega_i } {4 (n \cdot \omega_i)(n \cdot \omega_o) \cfrac {D(\omega_h)(n \cdot \omega_h)} {4(\omega_o \cdot \omega_h)}}} {\frac {1} {N} \sum_{k = 1}^N \cfrac{ D(\omega_h) F(\omega_h, \omega_o) G(\omega_i, \omega_o) n \cdot \omega_i } {4 (n \cdot \omega_i)(n \cdot \omega_o) \cfrac {D(\omega_h)(n \cdot \omega_h)} {4(\omega_o \cdot \omega_h)}}} = \cfrac {\frac {1} {N} \sum_{k = 1}^N \cfrac{ F(\omega_h, \omega_o) G(\omega_i, \omega_o) L_i(p, \omega_i) } {4 (n \cdot \omega_o) \cfrac {(n \cdot \omega_h)} {4(\omega_o \cdot \omega_h)}}} {\frac {1} {N} \sum_{k = 1}^N \cfrac{ F(\omega_h, \omega_o) G(\omega_i, \omega_o) } {4 (n \cdot \omega_o) \cfrac {(n \cdot \omega_h)} {4(\omega_o \cdot \omega_h)}}} $$

⑤接下来对式子的简化需要更多的假设，首先是令 $\,\omega_o\,$ 和 $\,n\,$ 都等于 $\,r\,$，其中 $\,r\,$ 是反射视角方向（根据该方向对 Pre-Filtered Environment Map 采样，具体解释见后面的几个小节），这个假设是整个方案误差的最大来源。这样上面的式子可以进一步化简为：  

$$ L_c = \cfrac {\frac {1} {N} \sum_{k = 1}^N F(\omega_h, \omega_o) G(\omega_i, \omega_o) L_i(p, \omega_i) } {\frac {1} {N} \sum_{k = 1}^N  F(\omega_h, \omega_o) G(\omega_i, \omega_o) } $$

⑥至于 $\,F\,$ 项和 $\,G\,$ 项，也都是简单粗暴地假设为 1，在实践中发现 $\,F\,$ 项 影响不大。至于 $\,G\,$ 项 ，Epic Games 在实践中发现用权重函数 $\,W(\omega_i) = n \cdot \omega_i\,$，替代直接假设 $\,G\,$ 项 为 1，可以得到更好的效果。所以最终公式如下（最上面提到的 Spilt sum approximation 的公式是简易版本，实际在代码中乘上了权重函数）： 

$$ L_c = \cfrac {\frac {1} {N} \sum_{k = 1}^N n \cdot \omega_i L_i(p, \omega_i) } {\frac {1} {N} \sum_{k = 1}^N n \cdot \omega_i } $$

---

综上所述，该近似方案是一个具有较多假设的，具有一定误差的非物理的方案，但总体得到的结果是可以接受的。接下来就是应用的问题，先考虑 $\,L_c\,$ 项，即如何对环境贴图存储的 radiance 进行卷积，以便根据不同的 roughness 把结果存储到不同 mip-map 级别的 cubemap 中，最后在使用时进行采样。因为这个方案使用的是微表面 BRDF 模型，故使用 **GGX 重要性采样**，让采样方向更加贴合镜面波瓣的形状，以便更快地收敛，具体如下小节。但即使是重要性采样，也几乎只能用于离线操作，故需要把结果存储到 **Pre-Filtered Environment Map**。当然也有实时更新环境贴图并快速卷积的技术，该技术适用于移动的物体，比如从一个房间进入另一个房间，日后有需求建议额外了解（可以找找那些知名游戏的方案）。

### GGX Importance Sampling
#### GGX 逆变换采样推导
我们要在已知宏观法线 $\,n\,$ 和观察方向 $\,v\,$ 的情况下，根据 GGX 概率密度函数生成半角向量 $\,h\,$ 的分布，再利用 $\,h\,$ 与 $\,v\,$ 和 $\,l\,$ 的关系反求出入射方向 $\,l\,$，得到入射光线的分布。

那么根据之前提到过的 GGX 概率密度函数：  

$$ \int_{\Omega} D(\omega_h) n \cdot \omega_h d\omega_h = 1 $$

①我们首先要先将其转换至球坐标下的函数（下面展示的是以 n 为 z 轴的右手球坐标系的计算结果，即切线空间，其中 $\,\theta\,$ 是半角向量 h 和 n 之间的夹角）：

$$ d\omega_h = sin\theta d\theta d\phi $$
$$ \Rightarrow \rho(w_h) = D(\omega_h) cos\theta sin\theta $$

②而 GGX 分布的公式为：  

$$ D(\omega_h) = \cfrac {\alpha^2} {\pi( (n \cdot \omega_h)^2(\alpha^2 - 1) + 1)^2} $$

那么概率密度函数可以写为：  

$$ \rho(w_h) = \rho(\theta, \phi) = \cfrac {\alpha^2 cos\theta sin\theta} {\pi( cos^2\theta(\alpha^2 - 1) + 1)^2} $$

③接着就是求出对于 $\,\theta\,$、$\,\phi\,$ 的边缘概率密度函数：

$$ \rho_\theta(\theta, \phi) = \int_0^{2 \pi} \cfrac {\alpha^2 cos\theta sin\theta} {\pi( cos^2\theta(\alpha^2 - 1) + 1)^2} d\phi = \cfrac {2 \alpha^2 cos\theta sin\theta} {( cos^2\theta(\alpha^2 - 1) + 1)^2} $$

$$ \rho_\phi(\theta, \phi) = \int_0^{\pi / 2} \cfrac {\alpha^2 cos\theta sin\theta} {\pi( cos^2\theta(\alpha^2 - 1) + 1)^2} d\theta $$

这里化简比较复杂，对 $\,cos^2\theta\,$ 求导可得：  

$$ \cfrac {dcos^2 \theta} {d\theta} = 2 cos\theta (-sin\theta) = -2 cos\theta sin\theta $$

$$ cos\theta sin\theta d\theta = - \cfrac {1} {2} dcos^2 \theta $$

故上面的 $\,\rho_\phi(\theta, \phi)\,$ 可以进一步简化为：  

$$ \rho_\phi(\theta, \phi) = \cfrac {\alpha^2} {2 \pi} \int^0_{\pi / 2} \cfrac {dcos^2 \theta}{( cos^2\theta(\alpha^2 - 1) + 1)^2} $$

接着用换元法，将 $\,cos^2 \theta = t\,$：  

$$ \rho_\phi(\theta, \phi) = \cfrac {\alpha^2} {2 \pi} \int^1_0 \cfrac {dt}{( t(\alpha^2 - 1) + 1)^2} $$

还是求导，对 $\,t(\alpha^2 - 1) + 1\,$ 求导：  

$$ d(t(\alpha^2 - 1) + 1) = (\alpha^2 - 1) dt$$

故：  

$$ \rho_\phi(\theta, \phi) = \cfrac {\alpha^2} {2 \pi (\alpha^2 - 1)} \int^1_0 \cfrac {d(t(\alpha^2 - 1) + 1)}{( t(\alpha^2 - 1) + 1)^2} $$

继续换元，令 $\,t(\alpha^2 - 1) + 1 = x\,$：  

$$ \rho_\phi(\theta, \phi) = \cfrac {\alpha^2} {2 \pi (\alpha^2 - 1)} \int^{\alpha^2}_1 \cfrac {dx}{x^2} = \cfrac {\alpha^2} {2 \pi (\alpha^2 - 1)} \left. \cfrac {1}{x} \right\rvert_{\alpha^2}^1 = \cfrac {\alpha^2} {2 \pi (\alpha^2 - 1)} \left( 1 - \cfrac {1} {\alpha^2}\right) = \cfrac {1} {2\pi} $$

④再求出对于 $\,\theta\,$、$\,\phi\,$ 的边缘累计密度函数：  

$$ CDF_\phi(\theta, \phi) = \int_0^\phi \cfrac {1} {2\pi} d\phi = \cfrac {\phi} {2\pi} $$

$$ CDF_\theta(\theta, \phi) = \int_0^\theta \cfrac {2 \alpha^2 cos\theta sin\theta} {( cos^2\theta(\alpha^2 - 1) + 1)^2} d\theta = \alpha^2 \int_\theta^0 \cfrac {dcos^2\theta} {( cos^2\theta(\alpha^2 - 1) + 1)^2} = \alpha^2 \int_{cos^2 \theta}^1 \cfrac {dt} {( t(\alpha^2 - 1) + 1)^2} $$

$$ = \cfrac {\alpha^2} {\alpha^2 - 1} \int_{cos^2 \theta}^1 \cfrac {d(t(\alpha^2 - 1) + 1)} {( t(\alpha^2 - 1) + 1)^2} = \cfrac {\alpha^2} {\alpha^2 - 1} \int_{cos^2 \theta (\alpha^2 - 1) + 1}^{\alpha^2} \cfrac {dx}{x^2} = \cfrac {\alpha^2} {\alpha^2 - 1} \left. \cfrac {1} {x} \right\rvert_{\alpha^2}^{cos^2 \theta (\alpha^2 - 1) + 1} $$

$$= \cfrac {\alpha^2}{cos^2 \theta (\alpha^2 - 1)^2 + (\alpha^2 - 1) } - \cfrac {1} {\alpha^2 - 1} $$

⑤最后求出反函数：  

$$ \phi = 2 \pi \xi_1 $$
$$ \theta = arccos \sqrt{\cfrac {1 - \xi_2} {1 + (\alpha^2 - 1)\xi_2}} $$

#### GGX 重要性采样代码
UE4 中的 HLSL 代码如下（右手坐标系）：  

``` C
float3 ImportanceSampleGGX( float2 Xi, float Roughness, float3 N )
{
    float a = Roughness * Roughness;

    float Phi = 2 * PI * Xi.x;
    float CosTheta = sqrt( (1 - Xi.y) / ( 1 + (a*a - 1) * Xi.y ) );
    float SinTheta = sqrt( 1 - CosTheta * CosTheta );

    float3 H;
    H.x = SinTheta * cos( Phi );
    H.y = SinTheta * sin( Phi );
    H.z = CosTheta;

    float3 UpVector = abs(N.z) < 0.999 ? float3(0,0,1) : float3(1,0,0);
    float3 TangentX = normalize( cross( UpVector, N ) );
    float3 TangentY = cross( N, TangentX );
    // Tangent to world space
    return TangentX * H.x + TangentY * H.y + N * H.z;
}
```

用 Python 的 matplotlib 库绘制的微观法线向量分布图如下：  

<div  align="center">  
<img src="https://s2.loli.net/2024/08/28/VCj9lD2Qpy7ZcFi.png" width = "80%" height = "80%" alt="图16 - 左图：粗糙度为 0；中图：粗糙度为 0.5；右图：粗糙度为 1"/>
</div>

可以看到粗糙度为 0 的时候，微观法线就是宏观法线方向。

> 其实根据 GGX 重要性采样，我们可以强行实时计算镜面反射 BRDF，代码可以参考上面发的《Real Shading in Unreal Engine 4》这篇文章，就不在这里摘抄了。当然即使是重要性采样，实时运算依旧困难，故主流方案还是对环境贴图进行预滤波并存储起来。

### Pre-Filtered Environment Map
既然实时求积分基本上做不到，那我们回到 Spilt sum approximation 的 $\,L_c\,$ 项，我们的方案是通过根据不同粗糙度的 GGX 重要性采样预计算 $\,L_c\,$ 项，并存储在不同 mipmap 级别的 Pre-Filtered Environment Map 中，然后在渲染时，根据反射视角方向 $\,R\,$ 对贴图进行采样获取存储的 radiance 均值。那么为什么可以这么做呢？

我们知道粗糙度影响着 GGX 分布，即微观法线的分布，从而影响到特定观察方向上接收到的入射光镜面波瓣的大小，而这个镜面波瓣（或着说镜面 BRDF）只会在视角反射方向 $\,R\,$ 附近有值，如下图所示：  

<div  align="center">  
<img src="https://s2.loli.net/2024/08/28/hjeb1qEBZHsAoLC.png" width = "50%" height = "50%" alt="图17 - 左图：完美镜面反射采样环境贴图；右图：镜面波瓣采样环境贴图"/>
</div>

之前也说过，问题就在于这个镜面波瓣形状跟宏观法线方向和观察方向都相关，我们也不可能预计算出对于每一个法线方向和观察方向的 N 张 Cubemap。这就用到了我们之前推导公式时，所使用的假设，即令 $\,\omega_o = n = R\,$（这里的 $\,R\,$ 是根据宏观法线 n 和观察方向得到的视角反射方向，和上面那张图镜面波瓣的产生是因为微表面法线 m 导致的视角反射方向分散之间注意区分），如下图所示：  

<div  align="center">  
<img src="https://s2.loli.net/2024/08/28/yEil3Dtp9Ujc7LJ.png" width = "60%" height = "60%" alt="图18 - v = n = r"/>
</div>

这里的镜面波瓣的近似，忽略了 $\,\omega_o\,$ 和 $\,n\,$ 的具体方向，是整个近似方案误差的最大来源。而这个误差具体表现为缺少了镜面反射时的拉伸效应，特别是在接近掠射角 grazing angle 方向的时候，如下图所示：  

**【书签】**


在写代码前，我们重新梳理下逻辑
我们根据采样点的法线方向 $\,n\,$ 和摄像机观察方向 $\,\omega_o\,$ ，计算出 R，根据近似波瓣的假设，令 v = n = r，使用这个近似的 n 通过不同粗糙度的 GGX 重要性采样获取一个近似波瓣的微表面法线分布 h，再通过 h 和 v 获取到近似波瓣的反射视角方向（同时也是入射方向）$\,\omega_i\,$ 的分布，然后使用入射方向对环境贴图采样，然后对 radiance 求平均记录在 Pre-Filtered Environment Map 里。

#### 低差异序列

#### 预过滤代码

#### 假设产生的误差

### Environment BRDF
