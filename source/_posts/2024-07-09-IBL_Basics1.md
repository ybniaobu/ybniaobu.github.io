---
title: IBL 基于图像的光照（一）
date: 2024-07-09 15:25:54
categories: 
  - [图形学]
tags:
  - 图形学
  - 游戏开发
top_img: /images/black.jpg
cover: https://s2.loli.net/2024/07/22/nD1y67NcRpQOHbS.gif
mathjax: true
description: 本笔记的主要内容有 XXXXXXXXXXXXXX
---

> 本篇文章主要参考了著名的 LearnOpenGL 教程：https://learnopengl-cn.github.io/ 或 https://learnopengl.com/ 、著名图形学书籍《Real-Time Rendering 4th》以及谷歌的 Filament PBR 白皮书：https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf 。

# Image based lights (IBL) 介绍
## 前言
$$ 光照模型 = 直接光漫反射 + 直接光镜面反射 + 间接光漫反射 + 间接光镜面反射 $$

**直接光漫反射 + 直接光镜面反射**就是上一篇文章《PBR 理论基础（BRDF）》介绍的，本篇文章介绍的就是**间接光漫反射 + 间接光镜面反射**。

在之前的文章 PBR 理论基础（BRDF）有提到过，对于一个点光源来说，当我们为一个表面上的特定的点 $\,p\,$ 着色时，在其半球领域 $\,\Omega\,$ 的所有可能的入射方向上，只有一个入射方向向量 $\,\omega_i\,$ 直接来自于该点光源。

在实现上来说，对于直接点光源的情况，计算**入射辐射亮度 radiance**，即 $\,L_i(p, \omega_i)\,$，先获取光源的颜色值，然后按照光源和某点 $\,p\,$ 的距离进行衰减，接着按照 $\,n \cdot \omega_i\,$ 缩放，写成代码如下：  

    vec3  lightColor  = vec3(r, g, b);
    vec3  wi          = normalize(lightPos - fragPos);
    float cosTheta    = max(dot(N, Wi), 0.0);
    float attenuation = calculateAttenuation(fragPos, lightPos);
    float radiance    = lightColor * attenuation * cosTheta;

> 这里 NdotL 若在 radiance 里乘了，就不要在运用反射方程的时候再乘一次了。我对颜色的理解是，辐射通量可以用颜色 RGB 表示，我们要计算的 radiance 是单位立体角单位接受面积的辐射通量。因为辐射强度，即单位立体角辐射通量，不会产生衰减，无论我们从哪个角度观察点光源，它总具有相同的辐射强度，我们可以有效地将其辐射强度建模为其辐射通量，即 RGB 颜色常量。真正的光线衰减产生自辐射照度 Irradiance，即单位接受面积辐射通量，若忘了详见《GAMES101-图形学入门公开课笔记（二）》第十四课 Ray Tracing II 中的辐射度量学。所以在计算 radiance 需要考虑颜色在距离上的衰减。

若场景中有多个光源，为了满足反射率方程，我们只需要循环遍历每一个光源，计算他们各自的辐射亮度然后求和，接着根据 BRDF 和光源的入射角和法线夹角进行缩放即可。我们不需要去尝试去求解对于表面的半球领域 $\,\Omega\,$ 的积分。而当我们之后把**环境照明 IBL** 也考虑在内，就必须采取积分去计算了，这是因为光线可能会在任何一个方向入射。

## IBL 简介
在真实世界中，光要么直接来自光源，要么间接来自环境中经过多次弹射后的光（会被部分吸收）。太阳光受到大气介质以及云层的散射后，会间接对物体进行照射，此时整个天空可以被看做是一个巨大的光源。

故物体周围的环境可以被视为一个光源，**图像 Images**（**立方体贴图 Cubemap** 或者**等距柱状投影图 Equirectangular image**）可以有效地捕捉**环境光照 Environment light**，这就被称为**基于图像的光照 Image Based Lighting (IBL)** 或**间接光照 Indirect Lighting**。

这些环境贴图要么需要从真实世界中拍摄获取，要么在游戏引擎中生成。我们可以将环境贴图的每个像素视为光源，在渲染方程中直接使用它，故基于图像的光照可以说是一种全局光照的粗略近似。

在现代游戏引擎中，有四种常见的 IBL 技术：  
①**全局/远处光照探针 Distant light probes**：用于捕捉无限距离上的光照信息，包括天空、地形建筑等光照信息，一般使用**高动态范围图像 HDRI**；  
②**局部光照探针 Local light probes**：用于捕捉某一特定地点的光照信息，通过投射到立方体或球上来捕捉到周围的几何信息（就是 Unity 的 Reflection Probe）。局部光照探针经常用于给材质增加局部反射信息；  
③**平面反射 Planar reflections**：该技术仅限于平坦的表面比如地板、路面或者水面等等，来渲染反射的场景；  
④**屏幕空间反射 Screen space reflection**：使用深度缓存构建世界坐标，利用光线步进的方法在屏幕空间中捕获反射信息，可以得到较好的反射信息但较为昂贵。

本文主要讲解 **Distant light probes**。

> Distant light probes 是从无限远的地方接受 radiance 对物体表面进行着色，它和真正意义上的全局光照的本质区别就是，它没有考虑场景中物体之间的遮挡以及光线的反弹，所以会出现一些不正确的渲染效果，比如一个室内的金属球会反射整个屋子外的天空，此时就需要用到上面说到的其他三种技术了。

## IBL 计算
IBL 对 PBR 很有意义，当我们将环境光纳入计算之后，物体在物理方面看起来会更加准确。那么将 IBL 引入 PBR 系统，先回忆一下反射方程：  

$$ L_o(p, \omega_o) = \int_{\Omega}(k_d \cfrac {c} {\pi} + k_s \cfrac {DFG} {4 (\omega_o \cdot n)(\omega_i \cdot n)}) L_i(p,\omega_i) n \cdot \omega_i d \omega_i $$

> 整个环境对某一特定像素点的光照贡献即**辐射照度 Irradiance**，弹射出该像素点的某一出射方向上的光线或射入该像素点的某一入射方向上的光线即**辐射亮度 Radiance/Luminance**。

我们的主要目标是计算半球 $\,\Omega\,$ 上所有入射光方向 $\,\omega_i\,$ 的积分。那么我们要解决两个问题：  
**①**在给定任何方向向量 $\,\omega_i\,$，我们首先需要获取这个方向上场景的 Radiance/Luminance，即 $\,L_i(p,\omega_i)\,$；  
**②**在实时渲染的前提下，解决积分问题。

第一点：这一点比较容易，使用方向向量 $\,\omega_i\,$ 对**环境贴图 Environment Map** 进行采样即可：  

    vec3 radiance =  texture(_cubemapEnvironment, w_i).rgb;

第二点：由于积分操作十分昂贵，无法直接在实时渲染中暴力计算实现，所以我们需要进行**预处理或预计算**，并将结果存储在 **Irradiance Map** 当中，以方便在运行时进行采样获取。

为了方便计算，我们可以将积分分成两部分，即 BRDF 的漫反射项和镜面反射项：  

$$ L_o(p, \omega_o) = \int_{\Omega}(k_d \cfrac {c} {\pi}) L_i(p,\omega_i) n \cdot \omega_i d \omega_i + \int_{\Omega}(k_s \cfrac {DFG} {4 (\omega_o \cdot n)(\omega_i \cdot n)}) L_i(p,\omega_i) n \cdot \omega_i d \omega_i $$

通过将积分分成两部分，我们可以分开研究漫反射和镜面反射部分，而这两部分主要使用的技术有：  
①漫反射部分：**辐射照度/辉度 Irradiance mapping**：主要包括**黎曼和 Riemann Sum**、**蒙特卡洛积分 Monte Carlo Integration** 这两种方法进行预积分；或者使用**球面或半球面函数 Spherical or Hemispherical Functions** 使用多个基函数用以表示原函数（类似于傅里叶级数）：主要有**球谐函数 Spherical harmonics**、**球面高斯 Spherical Gaussians**、**半球球谐/H-基 H-basis** 等方法。  
②镜面反射部分：**预过滤重要性采样 Pre-filtered importance sampling**；**分解求和近似 Split-sum approximation**；**非对称与各向异性波瓣 Asymmetric and Anisotropic lobes**。

# 环境映射 Environment Mapping
**环境映射 Environment mapping** 也称为反射映射 Reflection mapping，是 IBL 技术的基础，因为需要将环境贴图作为光照的来源照亮场景。环境贴图的每个纹素记录的是 Radiance/Luminance，环境贴图既可以从真实世界用特制的全景相机来获取，也可以搭建场景离线渲染出来。我们常使用的 HDRI 就是环境贴图的一种，常见的 HDRI 的存储格式有 **.exr**、**.hdr**、**.tif(.tiff)**。这里不对这些格式进行说明，建议额外去了解。

> HDRI 往往非常大，一张图片往往几百 Mb，可以使用基于物理的天空来替代，也建议额外去了解。

那么如何从环境贴图采样来获取 Radiance/Luminance 信息？一般步骤如下：  
①根据视角方向计算反射视角方向：$\,r = 2(n \cdot v) n - v\,$;  
②将反射视角向量 $\,( x,y,z )\,$ 转换为环境贴图的 uv 坐标 $\,( u,v )\,$。

<div  align="center">  
<img src="https://s2.loli.net/2024/07/22/L6AU91VvpJSzg3r.png" width = "70%" height = "70%" alt="图1 - 环境贴图采样步骤"/>
</div>

但是不同形式的环境贴图具有不同的投影/映射方式，这就决定了第二步的转换方式。

## 经纬映射 Latitude-Longitude Mapping
**经纬投影 Latitude-Longitude projection**（又称**等距柱状投影 Equirectangular projection**），类似于地图常用的**墨卡托投影 Mercator projection**（又称**等角柱状投影 Conformal cylindrical projection**）。经纬投影和墨卡托投影的区别在于墨卡托投影的纬度是不均匀的，在两个极点的维度间隔会趋于无穷大，而经纬投影的经维度间隔都是均匀的。

<div  align="center">  
<img src="https://s2.loli.net/2024/07/22/ErVUbRljTYq8PxX.png" width = "100%" height = "100%" alt="图2 - 经纬投影（不是墨卡托投影）"/>
</div>

这两种投影都具有同一个问题，就是越接近极点，图像拉扯越严重，所使用的像素点也越多。所以整个环境贴图是不均匀的，图像过滤的时候会出问题。直接采样也需要耗费额外的性能，因为需要额外的坐标变换以及使用反三角函数这样的**超越函数 transcendental function**，所以一般在渲染引擎中，会提前将**等距柱状投影图 Equirectangular map** 转换为 Cubemap 以便进行卷积操作或者在运行时使用。

直接采样的方法如下：首先先将视角反射方向向量 $\,( x,y,z )\,$ 给归一化，得到归一化方向向量 $\,( r_x,r_y,r_z )\,$，然后计算球坐标系下的坐标（右手坐标系下，物理学约定下的球坐标）：$\,\theta = acos(r_z)\,$，$\,\phi = atan2(r_y,r_x)\,$。最后将**天顶角 Polar angle** $\,\theta\,$ 和**方位角 Azimuthal angle** $\,\phi\,$ 映射至 UV 坐标下（$\,\theta\,$ 相当于维度，其弧度值范围为 $\,[0,\pi]\,$；$\,\phi\,$ 相当于经度，其其弧度值范围为 $\,[-\pi,\pi]\,$）：  

$$ u = \cfrac {\phi}{2 \pi} + 0.5, v = \cfrac{\theta}{\pi} + 0.5 $$

> 我们一般使用的 HDRI 贴图就是**等距柱状投影图 Equirectangular image**，也可以称为**全景图 panorama**。在 Unity 中可以有两种方式使用它，一种是使用 Skybox/Cubemap shader，另外一种是 Skybox/Panoramic shader。第一种，我们导入 HDRI 贴图时，Texture Shape 需要使用 Cube，Mapping 使用 Latitude-Longitude Layout（Cylindrical），这样 HDRI 就转换成了 Cubemap，再在 shader 里使用就行。第二种，我们导入 HDRI 贴图时，Texture 使用 2D，贴图导入 shader 里，在 shader 里的 Mapping 选择  Latitude-Longitude Layout。**建议使用第一种方式**，因为第二种在 Shader 里进行坐标转换，而第一种方式是运行外转换。

## 球面映射 Sphere Mapping
**球面映射 Sphere mapping** 假定观察者以正交投影的方式观察一个完美反射的球体，这个球体捕捉各个方向上的光照信息。

<div  align="center">  
<img src="https://s2.loli.net/2024/07/23/wSHuI7Nya3rBUPj.png" width = "60%" height = "60%" alt="图3 - 球面贴图（左）和经纬度映射的等效贴图（右）"/>
</div>

反射球只会在球的正面显示整个环境，它会将每个反射观察方向映射到球面二维图像上的一个点，如下图所示：  

<div  align="center">  
<img src="https://s2.loli.net/2024/07/23/t8xP3rfk5qK7IdU.png" width = "35%" height = "35%" alt="图4 - 球面映射的方式，图中还展示了球面贴图空间中 h 的坐标和球面贴图的纹理坐标 v（和观察向量 v 区分）之间的关系。"/>
</div>

在给定的球面贴图空间中，球面上的法线 $\,n\,$ 是反射观察向量 $\,r\,$ 与原始观察向量 $\,v\,$ 之间的半角向量，观察向量 $\,v\,$ 在球面贴图空间中坐标为 $\,(0,0,1)\,$。因此这里的球面法线 $\,n\,$ 是原始观察向量 $\,v\,$ 和反射观察向量 $\,r\,$ 的和，即 $\,(x,y,z + 1)\,$。将球面法线归一化得到单位球面法线：  

$$ n = \left( \cfrac{x} {m}, \cfrac{y} {m}, \cfrac{z + 1} {m} \right), \text{where} \,\,\, {m = \sqrt{x^2 + y^2 +(z + 1)^2}} $$

对于位于原点的单位球（半径为 1）来说，交点 $\,h\,$ 与单位法线向量 $\,n\,$ 具有相同的坐标。因为球面贴图空间球的值范围在 $\,[-1,1]\,$，将其映射至 uv 坐标即可：  

$$ u = \cfrac {n_x}{2} + 0.5, v = \cfrac {n_y}{2} + 0.5 $$

球面映射虽然简单，缺点就是其所捕获的环境贴图仅对单一观察方向有效，若根据新的观察方向重新计算纹理坐标会出现一些视觉瑕疵，除非根据新的观察方向生成一张新的贴图。因此球形贴图一般只适用于观察方向不会变化的场合。

球面映射很少在环境光照中使用，更多是用在 **Matcap（Material Capture）** 技术中。因为球面贴图每个点定义了表面法线的方向以及反射方向，我们可以把 BRDF 的结果存储在球面贴图当中，只要观察方向不变，就可以获取到一个廉价但还不错的材质效果。这个技术最早是 Zbrush 在使用的，这也是为什么 Zbrush 几百万面不会卡的原因。

## 立方体映射 Cube Mapping
**立方体贴图 Cubemap** 是最为广泛应用的方法。通过将环境投影到以相机位置为中心的立方体侧面，来创建一个立方体贴图，然后将立方体表面上的图像用作环境贴图。立方体贴图会被存储为 6 个正方形纹理。

立方体贴图的生成方式就是：将相机放置在立方体的中心，面向立方体六个面设置六个不同的视图矩阵，给定投影矩阵的 fov 为 90 度以捕捉整个面，并渲染立方体六次。

与球面映射不同，立方体映射是与视角无关的。立方体贴图也具有比经纬度映射更加均匀的采样特征。对立方体贴图采样也比较简单，可以直接将输入向量作为纹理坐标，在其所指的方向上获取数据。

> Unity URP 里可以使用 `SAMPLE_TEXTURECUBE(textureName, sampler_textureName, dir)` 采样，故不在这里对采样方法做详细说明了。

## 其他投影方法
其他投影方法主要包括：  
①**双抛物面映射 Dual paraboloid mapping** 使用两个抛物线投影创建两个半球贴图。《GTA5》、《荒野大嫖客2》和《赛博朋克2077》都有使用到，主要是为了降低开销；  
②**八面体映射 Octahedral mapping** 就是将环境映射到一个八面体当中，这个八面体的八个三角面正好可以排列在一张贴图中。

这些方法不再这里多做阐述，日后有需求再去详细了解。


# 漫反射 BRDF 积分
## Irradiance mapping
观察漫反射积分，可以发现兰伯特项是一个常数项，不依赖于任何积分变量。将常数项移出漫反射积分：  

$$ L_o(p, \omega_o) = k_d^* \cfrac {c} {\pi} \int_{\Omega} L_i(p,\omega_i) n \cdot \omega_i d \omega_i $$

> 理论上，$\,k_d\,$ 不能直接移出积分，$\,k_d = 1 - F\,$，而 $\,F = F_0 + (1 - F_0)(1 - v \cdot h)^5\,$，但是为了简化计算，我们通常用法线 n 替代微平面法线 h，用以体现宏观上的菲涅耳效应。因为在宏观层面下，环境光来自半球内围绕法线 n 的所有方向，因此没有一个确定的半角向量来计算菲涅耳效应。这样我们就可以用法线和视线之间的夹角计算出的 $\,k_d^*\,$ 直接在积分外部计算以对环境光的漫反射部分进行加权。

由于环境光是无穷远的，所以可以忽略位置信息而只考虑法线信息，可以认为着色点就位于天空盒的中心点，也就是采样的 $\,L_i(p,\omega_i)\,$ 就跟位置 p 无关了。而 $\,\Omega\,$ 是半球空间，即和法线 n 点积为正的部分，那么可以发现漫反射 BRDF 积分的结果就只跟法线 n 相关。于是就可以**计算每一个法线 n 对应的积分结果，即 Irradiance，并将结果存储在一张 Cubemap 里，然后在使用的时候只需要用法线对贴图进行采样即可**。这样的 Cubemap 也称为**辐射照度图 Irradiance map**。

为了计算积分值，计算上又不可能从半球 $\,\Omega\,$ 的每个可能的方向采样环境光照，理论上可能的方向数量是无限的。不过我们可以对有限数量的方向采样以近似求解，在半球内均匀间隔或随机取方向可以获得一个相当精确的辐照度近似值，从而离散地计算积分。所以我们要做的就是在半球 $\,\Omega\,$ 上的所有方向对原 Cubemap 的每个纹素进行离散采样，并按照余弦进行加权并求和。这也相当于一个非常宽的**滤波器 filter**或者**卷积 convolution** 操作，这个滤波器覆盖整个半球范围，还包含余弦因子。而主要的采样方法包括**黎曼和 Riemann Sum**、**蒙特卡洛积分 Monte Carlo Integration**。

### 黎曼和 Riemann Sum
漫反射 BRDF 积分是定义在立体角上的积分，为了避免对难处理的立体角求积分，我们需要其转换到球面坐标系下的两重积分进行求解。对于围绕半球大圆的方位角 $\,\phi\,$，在 0 到 2π 内采样，而对于天顶角 $\,\theta\,$ 在 0 到 1/2π 内采样：  

$$ \int_{\Omega}dw = \int_0^{2\pi} \int_0^{1/2\pi} sin \theta d \theta d \phi = 2 \pi $$

于是（把 $\,\cfrac {1}{\pi}\,$ 放入 Irradiance map 中，这样采样的时候就不用除以 $\,\pi\,$ 了）：

$$ \cfrac {1}{\pi} \int_{\Omega} L_i(p,\omega_i) n \cdot \omega_i d \omega_i = \cfrac {1}{\pi} \int_0^{2\pi} \int_0^{1/2\pi} L_i(p,\theta_i, \phi_i) cos \theta sin \theta d \theta d \phi $$

将 $\,\phi\,$ 和 $\,\theta\,$ 分别划分为 $\,n_1\,$，$\,n_2\,$ 等份，即转为黎曼和形式（可以看作为一种特殊的蒙特卡洛积分）：  

$$ \begin{align*} \cfrac {1}{\pi} \int_{\Omega} L_i(p,\omega_i) n \cdot \omega_i d \omega_i & \approx \cfrac {1}{\pi} \cdot \cfrac {2\pi - 0}{n_1} \cdot \cfrac {1/2\pi - 0}{n_2} \sum^{n_1}_{a = 0} \sum^{n_2}_{b = 0} L_i(p,\theta_b, \phi_a) cos \theta_b sin \theta_b \\ &= \cfrac {\pi}{n_1n_2} \sum^{n_1}_{a = 0} \sum^{n_2}_{b = 0} L_i(p,\theta_b, \phi_a) cos \theta_b sin \theta_b \end{align*} $$

> 黎曼和是一种简单的估计积分的方法，简单地来讲就是把面积分为 N 等份。比如 $\,\int_a^b g(x) dx\,$，求解它可以将 $\,(a,b)\,$ 划分为 N 等份，每份长度 $\,\Delta x = \cfrac {b - a}{N}\,$。这样这个积分的黎曼和为：  
> $$ S = \Delta x [g(a) + g(a + \Delta x) + g(a + 2 \Delta x) + \cdots + g(b - \Delta x)] $$  
> 当 N 趋向于无穷大时，黎曼和就趋向于定积分的值。

在 Unity 实现代码如下：  



# 镜面反射 BRDF 积分

# Unity 的光照系统