---
title: GAMES101-图形学入门公开课笔记（一）
date: 2024-04-05 19:16:20
categories: 
  - [图形学]
tags:
  - 图形学
  - 游戏开发
top_img: /images/black.jpg
cover: https://s2.loli.net/2024/04/05/bQhEat4gmx9UWIX.gif
mathjax: true
description: 本笔记的主要内容为 GAMES101 的第一课到第xx课，包括XXXXXXX
---

> GAMES101 是一门现代计算机图形学入门课程，全名为**现代计算机图形学入门**，本课程将全面而系统地介绍现代计算机图形学的四大组成部分：①光栅化成像，②几何表示，③光的传播理论，以及④动画与模拟。由加州大学圣芭芭拉分校 UCSB 的闫令琪教授讲解，他的科研成果被直接应用于工业界，如影片《猩球崛起3：终极之战》与《狮子王2019》，以及与 NVIDIA 合作推动了实时光线追踪技术的产生。  
> b 站视频 BV 号：BV1X7411F744

# 第一课 Overview of Computer Graphics
GAMES101 课程的主要内容为：  
①**Rasterization 光栅化**，即将**几何图元 geometry primitives**（包括线段、直线、射线、平面、多边形等），转换为**片元 fragments**（**像素 pixels**）并投影在屏幕上；  
②**Curves and Meshes**，几何相关内容，即如何在电脑中表示**几何 geometry**；  
③**Ray Tracing** 光线追踪，从相机发射经过每个像素的射线，计算交接 intersection 和着色 shading，直到光线反射到光源；  
④**Animation / Simulation** 包括 **key-frame Animation 关键帧动画** 和 **Mass-spring System 质量弹簧系统**（用于 **cloth simulation 布料仿真模拟**）

# 第二课 Review of Linear Algebra
向量、矩阵乘法内容都比较基础，不多做记录了，这里只补充一下数学运算定律相关内容：  
①向量点乘满足交换律、分配律和结合律：  
&emsp;&emsp; - $\,a \cdot b = b \cdot a\,$  
&emsp;&emsp; - $\,a \cdot (b + c) = a \cdot b + a \cdot c\,$  
&emsp;&emsp; - $\,(ka) \cdot b = a \cdot (kb) = k(a \cdot b)\,$  
②向量点乘不满足交换律，满足分配律和结合律：  
&emsp;&emsp; - $\,a \times b = - b \times a\,$  
&emsp;&emsp; - $\,a \times (b + c) = a \times b + a \times c\,$  
&emsp;&emsp; - $\,(ka) \times b = a \times (kb) = k(a \times b)\,$  
③矩阵与矩阵乘法不满足交换律，满足分配律和结合律：  
&emsp;&emsp; - $\,AB \neq BA\,$  
&emsp;&emsp; - $\,(AB)C = A(BC)\,$  
&emsp;&emsp; - $\,A(B + C) = AB + AC\,$  
&emsp;&emsp; - $\,(A + B)C = AC + BC\,$  

---

向量叉乘可以表示为矩阵形式：  

$$ a \times b = Ab = \begin{bmatrix} 0 & -z_a & y_a \\ z_a & 0 & -x_a \\ -y_a & x_a & 0 \end{bmatrix} \begin{bmatrix} x_b \\ y_b \\ z_b \end{bmatrix} = \begin{bmatrix} y_az_b - y_bz_a \\ x_bz_a - x_az_b \\ x_ay_b - y_ax_b \end{bmatrix} $$

其他内容若忘了，可以看 [Unity 基础 - 三维数学基础](https://ybniaobu.github.io/2023/07/09/2023-07-09-Unity%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9D%82%E8%AE%B0/#三维数学基础)


# 第三课 Transformation
①缩放变换 Scale (Non-Uniform)

$$ \begin{bmatrix} x' \\ y' \end{bmatrix} = \begin{bmatrix} s_x & 0 \\ 0 & s_y \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix} $$

②镜像变换 Reflection (Horizontal)

$$ \begin{bmatrix} x' \\ y' \end{bmatrix} = \begin{bmatrix} -1 & 0 \\ 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix} $$

③切变变换 Shear

<div  align="center">  
<img src="https://s2.loli.net/2024/04/15/HE1leN7pULujac2.png" width = "60%" height = "60%" alt="图1 - Shear"/>
</div>

$$ \begin{bmatrix} x' \\ y' \end{bmatrix} = \begin{bmatrix} 1 & a \\ 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix} $$

④旋转变换 Rotation (Counterclockwise)

$$ \begin{bmatrix} x' \\ y' \end{bmatrix} = \begin{bmatrix} cos \theta & -sin \theta \\ sin \theta & cos \theta \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix} $$

---

齐次坐标相关内容不多做记录了。知道一下 **Affine Transformations 仿射变换**（仿射映射）就是一个向量空间进行一次线性变换并接上一个平移，变换为另一个向量空间。即 Affine map = linear map + translation。

还有一个关于齐次坐标的要注意一下，因为齐次坐标的向量是 $\,(x, y ,0)^T\,$，坐标点是 $\,(x, y ,1)^T\,$。而向量加上向量得到的是 $\,(x', y' ,0)^T\,$ 也为向量，点减去点是 $\,(x', y' ,0)^T\,$ 为向量，点加上向量得到的是 $\,(x', y' ,1)^T\,$ 为点。这些都符合定义。但是点加上点，却没有意义，这样会得到 $\,(x', y' ,2)^T\,$，为了扩充定义，若 $\,w \neq 0 \,$，则在齐次坐标下的 $\,(x, y ,w)^T\,$ 表示的都是点 $\,(x/w, y/w ,1)^T\,$。这样在齐次坐标下，点加上点得到的是两个点的中点。


# 第四课 Transformation II
## 3D Transformation
**①Rotation around x-, y-, or z-axis**  

$$ R_x(\alpha) = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & cos \alpha & -sin \alpha & 0 \\ 0 & sin \alpha & cos \alpha & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} $$

$$ R_y(\alpha) = \begin{bmatrix} cos \alpha & 0 & sin \alpha & 0 \\ 0 & 1 & 0 & 0 \\ -sin \alpha & 0 & cos \alpha & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} $$

$$ R_z(\alpha) = \begin{bmatrix} cos \alpha & -sin \alpha & 0 & 0 \\ sin \alpha & cos \alpha & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} $$

左右手系旋转矩阵都是一样的，但**右手坐标系逆时针旋转为正，左手坐标系顺时针旋转为正**。

**②罗德里格旋转公式 Rodrigues’ Rotation Formula**

设 v 是一个三维空间向量，k 是旋转轴的单位向量，则 v 在右手螺旋定则意义下绕旋转轴 k 旋转角度 θ 得到的向量可以由三个不共面的向量，即原向量，旋转轴及它们叉积表示：  

$$ v_{rotation} = cos \theta v + (1 - cos \theta)(v \cdot k) k + sin \theta k \times v $$

矩阵形式表示为：  

$$ R(k, \theta) = cos \theta I + (1 - cos \theta)kk^T + sin \theta \begin{bmatrix} 0 & -z_a & y_a \\ z_a & 0 & -x_a \\ -y_a & x_a & 0 \end{bmatrix} $$

这里的旋转 θ 角度指的是向量 v 投影至垂直于 ($\,\bot\,$) 旋转轴的分量旋转的角度，平行于 ($\,||\,$) 旋转轴的分量不变。

<div  align="center">  
<img src="https://s2.loli.net/2024/04/15/4KGFNwOS5gIu1qQ.png" width = "30%" height = "30%" alt="图2 - Rodrigues’ Rotation"/>
</div>

> 这节课不说四元数，但是老师补充了一句是：比如矩阵旋转 25 度，和旋转 5 度，矩阵平均不能得到 15 度，即矩阵不能插值。但是四元数可以，方便了计算。

## Viewing transformation
Viewing transformation 观测变换，包括：  
①View/ Camera transformation 观察变换；  
②Projection transformation 投影变换  
&emsp;&emsp; - Orthographic projection 正交投影  
&emsp;&emsp; - Perspective projection 透视投影

### View Transformation
观察变换其实就是摄像机带着其他模型一起变换，将摄像机放置在原地，面朝着 -z 方向，即《Unity Shader入门精要》提到的观察变换中的方法二。这些内容《Unity Shader入门精要》也有讲过，不再重复说明了。额外提一句，观察变换还可以用如下的理解方式：观察变换其实就是摄像机空间，即摄像机自己的模型空间，转换到世界空间的逆矩阵，而观察变换不考虑缩放，若只考虑向量方向的话，直接转置就是逆矩阵，因为旋转矩阵是正交矩阵。这和冯乐乐提到的观察矩阵的理解的两种方法逻辑是一样的，忘了可以回去看看。

### Orthographic projection
正交投影就是将裁切后得到的**长方体 cuboid** 映射至**标准立方体 canonical cube**，即范围在 [-1, 1]。

<div  align="center">  
<img src="https://s2.loli.net/2024/04/16/JMEtuOm1UVHATkx.png" width = "70%" height = "70%" alt="图3 - Orthographic projection"/>
</div>

长方体 cuboid 的 n 即 near，f 即 far，l 即 left，r 即 right，t 即 top，b 即 bottom。

为了得到正交投影投影矩阵，需要将长方体 cuboid 先平移再缩放，矩阵如下：  

$$ \begin{align*} M_{ortho} &= \begin{bmatrix} \cfrac {2} {r - l} & 0 & 0 & 0 \\ 0 & \cfrac {2} {t - b} & 0 & 0 \\ 0 & 0 & \cfrac {2} {n - f} & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} 1 & 0 & 0 & -\cfrac {r + l} {2} \\ 0 & 1 & 0 & -\cfrac {t + b} {2} \\ 0 & 0 & 1 & -\cfrac {n + f} {2} \\ 0 & 0 & 0 & 1 \end{bmatrix} \\ &= \begin{bmatrix} \cfrac {2} {r - l} & 0 & 0 & -\cfrac {r + l} {r - l} \\ 0 & \cfrac {2} {t - b} & 0 & -\cfrac {t + b} {t - b} \\ 0 & 0 & \cfrac {2} {n - f} & -\cfrac {n + f} {n - f} \\ 0 & 0 & 0 & 1 \end{bmatrix} \end{align*} $$

这个矩阵其实和《Unity Shader入门精要》中的是一样的，t - b 就是 ClipPlaneHeight 即 2 · Size，r - l 即横纵比 Aspect 乘上 ClipPlaneHeight。又因为是先经过观察变换得到的长方体 cuboid，所以对于 Unity 来说 r 和 l 互为相反数，t 和 b 也互为相反数，即 r + l 为 0，t + b 也为 0。可以对比看看。

### Perspective projection
透视投影其实就是把远平面“挤压”到近平面的大小，即把**视锥体 Frustum** 先变换为**长方体 cuboid**，然后再做正交投影。这个挤压其实就是一个线性函数关系，对远平面的 x、y 做变换，z 轴不变：$\,x' = \cfrac {n} {z} x\,$，$\,y' = \cfrac {n} {z} y\,$。

<div  align="center">  
<img src="https://s2.loli.net/2024/04/16/J2vzwUFqBysX6OE.png" width = "70%" height = "70%" alt="图4 - squish the frustum into a cuboid"/>
</div>

但这样 x' 和  y' 就出现了两个未知数，而使用矩阵做的计算是 a\*x + b\*y + c\*z + d。无法使用上面的映射关系，这时候就需要用到齐次坐标系的 w 值了，在齐次坐标系中：  

$$ \begin{bmatrix} nx/z \\ ny/z \\ unknown \\ 1 \end{bmatrix} == \begin{bmatrix} nx \\ ny \\ unknown \\ z \end{bmatrix} $$

裁切空间坐标的这个 z 的来源终于找到了，所以 Unity 会把它称之为 HCS，即齐次裁切空间，而做齐次除法的原因也是因为这个 z。所以这个 “squish” (persp to ortho) projection 做了如下行为：  

$$ M_{persp \to ortho}^{(4 \times 4)} \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} = \begin{bmatrix} nx \\ ny \\ unknown \\ z \end{bmatrix} $$

出现的这个 near 就是导致出现 tan(FOV/2) 的原因。这个 unknown 的 z' 值是非线性的，可以通过解方程算出，我们代入近裁切平面和远裁切平面的点，首先是近裁切平面，使用 n 代替 z：

$$ M_{persp \to ortho}^{(4 \times 4)} \begin{bmatrix} x \\ y \\ n \\ 1 \end{bmatrix} = \begin{bmatrix} n & 0 & 0 & 0 \\ 0 & n & 0 & 0 \\ ? & ? & ? & ? \\ 0 & 0 & 1 & 0 \end{bmatrix} \begin{bmatrix} x \\ y \\ n \\ 1 \end{bmatrix} = \begin{bmatrix} nx \\ ny \\ n^2 \\ n \end{bmatrix} $$

我们只看矩阵的第三行，形式肯定是 $\,\begin{bmatrix} 0 & 0 & A & B \end{bmatrix}\,$，即：  

$$ \begin{bmatrix} 0 & 0 & A & B \end{bmatrix} \begin{bmatrix} x \\ y \\ n \\ 1 \end{bmatrix} = n^2 $$

$$ \Rightarrow An + B = n^2 $$

然后代入远裁切平面，使用 f 代替 z：

$$ \begin{bmatrix} 0 & 0 & A & B \end{bmatrix} \begin{bmatrix} x \\ y \\ f \\ 1 \end{bmatrix} = f^2 $$
$$ \Rightarrow Af + B = f^2 $$

解方程可以得到：$\,A = n + f\,$，$\,B = -nf\,$。这样就可以推出透视投影矩阵了，这里就不推导了，逻辑理解即可。


# 第五课 Rasterization
该课一开始的视口变换 Viewport transformation 不重复说明了。

## Rasterizing triangles into pixels
Raster 在德语中就是屏幕、网格的意思，所以 Rasterize 光栅化就是画上屏幕。

三角形是最基本的形状图元，可以组成任意多边形。三角形可以保证平面是平的，同时可以很好的利用**重心坐标插值 barycentric interpolation**。

光栅化一个三角形的输入是顶点的屏幕坐标，输出则是屏幕上的一堆近似三角形的像素。重点就是判断像素中心点与三角形的位置关系，基本的方法就叫**采样 Sampling**。

**采样 Sampling** 指给定一个连续的函数，根据不同的点去获取一个值。所以可以通过采样去**离散化 discretize** 一个函数。三角形可以理解为一个函数，然后根据像素中心点进行采样，去输出 0 和 1。至于这个判断三角形内外的函数就是利用了三次叉乘来判断（三个叉乘同号则在内部）。

为了减少判断次数，会先根据三角形三个顶点的最大最小 x 和 y 值来定义出一个**边界框 bounding box**。边界框外的像素一定不在三角形内部。

最终得到的三角形可能会产生**锯齿 jaggies**，如下图：

<div  align="center">  
<img src="https://s2.loli.net/2024/04/17/Ot2SFVevRjaPpDA.png" width = "30%" height = "30%" alt="图5 - jaggies"/>
</div>

锯齿是光栅化图形学一直致力解决的严重问题。锯齿产生的原因是因为采样率对于信号来说是不够高的，从而产生的信号的**走样 Aliasing** 问题。**抗锯齿**即**反走样 Anti-aliasing**。详见下节课内容。

# 第六课 Rasterization II
## Antialiasing
### Sampling theory
**Sampling Artifacts** 在图形学中指一切采样出现的不如意的地方（Errors / Mistakes / Inaccuracies）。**走样 Aliasing** 的原因本质就是因为信号变化太快（信号频率高），采样效率（采样频率低）跟不上。而**反走样 Anti-aliasing** 就是在采样之前做一个**模糊 blurring**，或者叫做**前置滤波 Pre-filtering**。这个模糊操作让三角形边缘有了颜色过渡，如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2024/04/17/nfSq7GRp8KmuCFw.png" width = "50%" height = "50%" alt="图6 - Antialiased Sampling"/>
</div>

接下来说明频率的问题，首先傅里叶变换可以把信号分解到不同频率（时域变频域），而高频率需要更快的采样的原因如下图所示：

<div  align="center">  
<img src="https://s2.loli.net/2024/04/17/vfK5mV7Q2lFhNXO.png" width = "70%" height = "70%" alt="图7 - Undersampling"/>
</div>

高频率信号受到不充分的采样会让得到信号像一个低频率的信号。使用一个采样率采样两种频率的信号，但无法区分它们，就被称为**走样 Aliasing**。而**滤波**的目的就是把特定的频率去除掉。

**傅立叶变换**可以把图片从时域变换到频域，如下图（一般图片都是低频信息多，高频信息少，亮度表示信息，图像频率就是灰度变化的剧烈程度）：  

<div  align="center">  
<img src="https://s2.loli.net/2024/04/17/FPvTqj3eZwzYpQx.png" width = "60%" height = "60%" alt="图8 - Visualizing Image Frequency Content"/>
</div>

如果我们通过滤波去掉低频信息，就可以得到图像的边缘，如下图的**高通滤波 High-pass filter**（高频率可以通过）：

<div  align="center">  
<img src="https://s2.loli.net/2024/04/17/s1aZMurjXEh5LU9.png" width = "60%" height = "60%" alt="图9 - High-pass filter"/>
</div>

如果我们通过滤波去掉高频信息，就可以得到模糊的图像（Blur），如下图的**低通滤波 Low-pass filter**（低频率可以通过）：

<div  align="center">  
<img src="https://s2.loli.net/2024/04/17/XW85MpDbcSsYywF.png" width = "60%" height = "60%" alt="图10 - Low-pass filter"/>
</div>

高通锐化，低通模糊。想要更深地学习这方面知识需要学习**数字图像处理**相关课程（现在更多地图像操作是根据机器学习来操作的）。

---

**滤波 Filtering** 就是**卷积 Convolution**，可以理解为平均的意思。**卷积定理**指出**在时域上的卷积操作等于在频域上的乘积**，时域上的乘积等于频域上的卷积。所以我们可以直接选择在时域上做卷积操作，从而可以简化操作。原操作需要三步：先用傅里叶变换把时域转换至频域，再乘上卷积核的傅里叶变换，最后逆傅里叶变换回时域。如下图：  




### Antialiasing in practice

## Z-Buffering