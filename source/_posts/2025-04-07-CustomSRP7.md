---
title: Unity Custom SRP 基础（七）
date: 2025-04-07 20:57:36
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2025/04/07/2zi6pj3XtAPHvmy.gif
mathjax: true
description: 本笔记的主要内容包含自定义 Particle System 的 Unlit Shader；Depth & Color Texture 的创建以及通过它们实现的特殊粒子效果；Depth Prepass 的实现；如何修改 Render Scale；FXAA Quality 和 Console 的实现。
---

> 本笔记是关于 Unity 的**自定义可编程渲染管线**的入门基础，即 **SRP (Scriptable Rendering Pipeline)**，主要参考了著名的教程 https://catlikecoding.com/ 的 Custom SRP Tutorial，以及知乎上各位图形学大神们的文章。  
>    
> 笔者使用的 Unity 版本是 6000.0.27f1，Core RP Library 的版本是 17.0.3。

# Particles
Unity 自带的**内置 Particle System** 大部分工作都是 CPU 计算的，而实现项目 CPU 瓶颈居多，所以它只适用于一些只使用少量粒子（数千以内）的简单特效，比如烟雾、火焰、爆炸等。而 **Visual Effect Graph** 是基于 GPU 计算，适合需要高质量、复杂粒子效果的场景。教程中只涉及内置 Particle System，没有涉及如何接入 Visual Effect Graph，需要自行研究如何接入。

其实什么都不用做就已经可以使用 Particle System 了，通过 GameObject / Effects / Particle System 创建即可。Particle System 可以使用任意材质，只不过使用并非专门为内置粒子系统而写的任意材质会带有一定的限制。教程中也只涉及 Particle System 的 Unlit Shader，不涉及 Particle Lit Shader ，但 Lit 跟 Unlit 类似，只是多了光照计算等，可以查阅 URP 或 HDRP。

## Unlit Particles Shader
我们先将自己的 Unlit Shader 全部复制出来，新建一个 ParticlesUnlit.Shader 然后粘贴进去，将 Shader 菜单路径改一下就行：  

    Shader "Custom RP/Particles/Unlit"
    {
        ...
    }

顺便提一下，对于内置粒子系统，GPU instancing 是不起作用的。然后将自己的 ParticlesUnlit.Shader 附给 Particle System 的 Renderer 就可以渲染粒子了：  

> 教程里说 Particle System 不支持 GPU instancing，但是我看官方文档时，发现是可以支持的，详见：https://docs.unity3d.com/Manual/gpu-instancing-particle-systems.html 。只是需要将 Particle System 的 Renderer 模式改为 Mesh，点击 Enable GPU Instancing，并且需要一个支持 Particle GPU instancing 的 Shader。

<div  align="center">  
<img src="https://s2.loli.net/2025/04/09/1dkv7G9OBUXMqi4.jpg" width = "60%" height = "60%" alt="图115 - 使用了一张圆形渐变贴图的 billboard particles"/>
</div>

## Vertex Color
Particle System 里面的很多颜色属性都是通过顶点色来传递的，比如 Start Color、Color over Lifetime、Color by Speed 等等，所以我们要为 Particle Unlit Shader 增加顶点色以使用这些属性：  

    struct Attributes
    {
        ...
        float4 color : COLOR;
        ...
    };

    struct Varyings
    {
        ...
        float4 color : COLOR;
        ...
    };

    Varyings ParticlesUnlitVert(Attributes IN)
    {
        Varyings OUT;
        ...
        OUT.color = IN.color;
        ...
        return OUT;
    }

    float4 ParticlesUnlitFrag(Varyings IN) : SV_Target
    {
        ...
        return float4(albedo.rgb * IN.color.rgb + emission * IN.color.rgb, albedo.a * IN.color.a);
    }

当然你也可以为顶点色和 base color 的混合做正片叠底 Multiply 以外的混合方式。

<div  align="center">  
<img src="https://s2.loli.net/2025/04/10/4jfHxRgLF5AUvzl.jpg" width = "60%" height = "60%" alt="图116 - Start Color 选择 Random Color 设置从黑到白渐变的粒子效果"/>
</div>

还有一点就是，当粒子有不同的颜色时，排序上就会出现问题，这点跟透明物体的排序问题是一致的。所以我们最好在 Particle System 的 Renderer 中将 Sort Mode 改为 By Distance。

## Flipbooks
Flipbooks 就是粒子的序列帧动画，让每个粒子播放一段动画。其实不用做任何事情就已经可以使用 Flipbooks 了，我们点开 Particle System 的 Texture Sheet Animation 就可以，并将 Shader 赋予如下贴图：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/10/bhZ3VTRavrOuzmI.jpg" width = "25%" height = "25%" alt="图117 - flipbook texture"/>
</div>

这张贴图是 4 × 4 的，故 Texture Sheet Animation 里的 Tiles 属性也要设置为 4 × 4。然后就会出现类似一下效果，我特意把循环速度调慢了以降低动画播放速度方便看清：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/10/CyU4bZnsNmKXvf9.gif" width = "60%" height = "60%" alt="图118 - flipbook particle 效果"/>
</div>

可以看到每个粒子的动画播放速度非常得慢，并且帧与帧之间衔接不是很顺畅，这就需要对帧与帧之间做混合。

### Flipbook Blending
为了方便混合，我们需要传递第二套 uv 以及一个 animation blend 参数给 Shader，同时我们需要在 Particle System 的 Renderer 里面勾选上 Custom Vertex Streams 并添加 UV2 和 AnimBlend，如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/10/2ASenfjD4R59pVs.jpg" width = "40%" height = "40%" alt="图119 - Custom Vertex Streams"/>
</div>

然后我们就要去 Shader 里添加这些属性，首先添加一个 Flipbook Blending 的开关，如下：  

    Shader "YPipeline/Particles/Unlit"
    {
        Properties
        {
            ...
            [Toggle(_FLIPBOOK_BLENDING)] _FlipbookBlending ("Flipbook Blending", Float) = 0.0
        }

        SubShader
        {
            Pass
            {
                ...
                #pragma shader_feature_local _FLIPBOOK_BLENDING
                ...
            }
        }
    }

之后 Pass 里的修改如下：  

    struct Attributes
    {
        ...
        #if defined(_FLIPBOOK_BLENDING)
            float4 uv : TEXCOORD0;
            float uvBlend : TEXCOORD1;
        #else
            float2 uv : TEXCOORD0;
        #endif
    }

    struct Varyings
    {
        ...
        float2 uv : TEXCOORD0;

        #if defined(_FLIPBOOK_BLENDING)
            float3 uv2AndBlend : TEXCOORD1;
        #endif
    };

    Varyings ParticlesUnlitVert(Attributes IN)
    {
        ...
        float4 baseST = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseTex_ST);
        OUT.uv = IN.uv.xy * baseST.xy + baseST.zw;
        #if defined(_FLIPBOOK_BLENDING)
            OUT.uv2AndBlend.xy = IN.uv.zw * baseST.xy + baseST.zw;
            OUT.uv2AndBlend.z = IN.uvBlend;
        #endif
        return OUT;
    }

    float4 ParticlesUnlitFrag(Varyings IN) : SV_Target
    {
        ...
        #if defined(_FLIPBOOK_BLENDING)
            albedo = lerp(albedo, SAMPLE_TEXTURE2D(_BaseTex, sampler_Trilinear_Repeat_BaseTex, IN.uv2AndBlend.xy), IN.uv2AndBlend.z);
        #endif
        ...
    }

效果如下：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/10/6FSR5ng9CrQo43j.gif" width = "60%" height = "60%" alt="图120 - Flipbook Blending"/>
</div>

可以看到粒子动画帧与帧之间的衔接变得舒服很多。

## Fading Near Camera
当摄像机在粒子发射的区域内部，由于粒子会离摄像机很近，从而占据画面的大部分并影响到玩家观察场景。Particle System 中 Renderer 的 Max Particle Size 可以限制粒子最大能占据画面的百分比，但是该属性会导致，当粒子达到最大大小并逐渐接近近裁切平面时，粒子看起来在变小，所以效果并不是很好。

另外一个方案就是，我们可以让粒子根据深度进行渐变，越接近屏幕越透明，这样子当模拟大气效果时，会有个更好的效果。首先我们为 Particle Unlit Shader 添加 `_CAMERA_NEAR_FADE` 关键字开关属性，以及一个距离和距离范围属性：  

    [Toggle(_CAMERA_NEAR_FADE)] _CameraFading ("Camera Fading", Float) = 0.0
    _NearFadeDistance ("Near Fade Distance", Range(0.0, 10.0)) = 1
    _NearFadeRange ("Near Fade Range", Range(0.0, 10.0)) = 1

别忘了加上 shader_feature：  

    #pragma shader_feature _NEAR_FADE

然后在 Pass 里，根据深度值和 Distance 以及 Range 属性进行 lerp 改变 alpha 的值，深度值可以根据 SV_POSITION 语义来获取，如何获取就不解释了，忘了看之前相关文章，就是正交投影需要注意一下，代码如下（`unity_OrthoParams` 和 `_ProjectionParams` 都是 UnityInput）：  

    UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)
        ...
        UNITY_DEFINE_INSTANCED_PROP(float, _NearFadeDistance)
        UNITY_DEFINE_INSTANCED_PROP(float, _NearFadeRange)
        ...
    UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)

    float GetViewDepthFromSVPosition(float4 positionHCS)
    {
        if (unity_OrthoParams.w < 0.5f) // Perspective
        {
            return positionHCS.w;
        }
        else // Orthographic
        {
            float normalizedDepth = positionHCS.z;

            #if UNITY_REVERSED_Z
                normalizedDepth = 1.0 - normalizedDepth;
            #endif

            return (_ProjectionParams.z - _ProjectionParams.y) * normalizedDepth + _ProjectionParams.y;
        }
    }

    ...

    float4 ParticlesUnlitFrag(Varyings IN) : SV_Target
    {
        ...
        #if defined(_CAMERA_NEAR_FADE)
            float depth = GetViewDepthFromSVPosition(IN.positionHCS);
            float nearFadeDistance = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _NearFadeDistance);
            float nearFadeRange = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _NearFadeRange);
            float nearAttenuation = (depth - nearFadeDistance) / nearFadeRange;
            albedo.a *= saturate(nearAttenuation);
        #endif
        ...
    }

开启 _CAMERA_NEAR_FADE 后，改变 NearFadeDistance 效果如下：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/11/2ZClqOErxANXIR7.gif" width = "60%" height = "60%" alt="图121 - NearFadeDistance 逐渐变大的 Camera Near Fade 效果"/>
</div>

## Soft Particles
当粒子和非透明物体重合交叠时，部分粒子在物体前部分粒子在物体后，就会显得特别突兀。为了解决这个问题，我们需要对比粒子和物体的深度，当物体在粒子背后很近时，将粒子 fade out，于是就需要采样 depth texture，depth texture 的相关前置内容见下一章节的 Copy Depth 小节。

### 重构 View Space Depth
这部分内容的逻辑 [《Unity Shader入门精要》读书笔记（四）](https://ybniaobu.github.io/2023/12/19/2023-12-19-UnityShader4/#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86) 里面已经讲得很详细了，就不再赘述了。下面就简单记录下步骤：  

因为我们要用屏幕空间的 uv 坐标对 `_CameraDepthTexture` 进行采样，最简单的计算屏幕 uv 的方式是使用带 SV_POSITION 语义的 PositionHCS 的 xy 分量除以屏幕分辨率，屏幕分辨率可以通过 UnityInput 的 `_ScreenParams` 获取，我们需要添加在 UnityInput 里。与此同时，我们重构 View Space Depth 需要用到远近裁切平面的相关参数，需要使用到 `_ZBufferParams`，也要添加在 UnityInput 里：  

    ...
    float4 _ProjectionParams;
    // x = width
    // y = height
    // z = 1 + 1.0/width
    // w = 1 + 1.0/height
    float4 _ScreenParams;
    // x = 1-far/near
    // y = far/near
    // z = x/far
    // w = y/far
    // or in case of a reversed depth buffer (UNITY_REVERSED_Z is 1)
    // x = -1+far/near
    // y = 1
    // z = x/far
    // w = 1/far
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    ...

然后因为 Unity 内置的使用 _ZBufferParams 的 `LinearEyeDepth()` 函数不适用于正交投影的情形下，需要区分：  

    float GetViewDepthFromDepthTexture(float sampledDepth)
    {
        if (unity_OrthoParams.w < 0.5f) // Perspective
        {
            return LinearEyeDepth(sampledDepth, _ZBufferParams);
        }
        else // Orthographic
        {
            #if UNITY_REVERSED_Z
            sampledDepth = 1.0 - sampledDepth;
            #endif
            return (_ProjectionParams.z - _ProjectionParams.y) * sampledDepth + _ProjectionParams.y;
        }
    }

### Soft Particles Fading
可以获取到深度了，就可以实现 Soft Particles 的效果了。首先为 Soft Particles 添加几个 Shader 参数：  

    [Toggle(_SOFT_PARTICLES)] _SoftParticles ("Soft Particles", Float) = 0
    _SoftParticlesDistance ("Soft Particles Distance", Range(0.0, 10.0)) = 0
    _SoftParticlesRange ("Soft Particles Range", Range(0.01, 10.0)) = 1

别忘了添加 shader feature：  

    #pragma shader_feature _SOFT_PARTICLES

然后在 UnityPerMaterial 里加上上面说的参数变量，片元着色器里的计算跟 Camera Near Fade 很类似：  

    float viewDepth = GetViewDepthFromSVPosition(IN.positionHCS);
    #if defined(_SOFT_PARTICLES)
        float2 screenUV = IN.positionHCS.xy / _ScreenParams.xy;
        float sampledDepth = SAMPLE_DEPTH_TEXTURE_LOD(_CameraDepthTexture, sampler_CameraDepthTexture, screenUV, 0);
        float viewSampledDepth = GetViewDepthFromDepthTexture(sampledDepth);
        float depthDelta = abs(viewSampledDepth - viewDepth);
        float softParticlesDistance = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _SoftParticlesDistance);
        float softParticlesRange = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _SoftParticlesRange);
        float softParticlesAttenuation = (depthDelta - softParticlesDistance) / softParticlesRange;
        albedo.a *= saturate(softParticlesAttenuation);
    #endif

从不开启 Soft Particles 到开启后的效果如下： 

<div  align="center">  
<img src="https://s2.loli.net/2025/04/17/JRPLleGKdHscoDT.gif" width = "60%" height = "60%" alt="图122 - 前半为关闭 Soft Particles 的效果，后半为开启 Soft Particles 的效果"/>
</div>

## Distortion
跟 Soft Particles 类似，Soft Particles 需要 Depth 信息，Distortion 这种透明效果则需要场景颜色信息。所以需要采样 Color Texture，Color Texture 的前置知识详见下一章节的 Copy Color 小节。

### Distortion Map
Distortion Map 是一个类似于法线贴图的贴图，它可以用于随机化采样场景颜色的 uv 从而达到一种扭曲的效果，类似如下贴图：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/17/guX4UYb5sGRljdp.png" width = "15%" height = "15%" alt="图123 - Round Particle Distortion Map"/>
</div>

接下来就是为 Distortion 添加 Shader 参数：  

    [Toggle(_DISTORTION)] _Distortion ("Distortion", Float) = 0.0
    [NoScaleOffset] _DistortionTex ("Distortion Texture", 2D) = "bump" {}
    _DistortionStrength ("Distortion Strength", Range(0.0, 2.0)) = 0.1
    
别忘了添加 shader feature：

    #pragma shader_feature _DISTORTION

然后为这些参数添加变量。使用 Distortion Map 跟 Normal Map 类似，需要解码，解码后我们只需要 xy 分量对 uv 进行偏移，并使用偏移后的 uv 对 `_CameraColorTexture` 进行采样，先直接输出采样的颜色：  

    #if defined(_DISTORTION)
        float4 packedDistortion = SAMPLE_TEXTURE2D(_DistortionTex, sampler_Trilinear_Repeat_BaseTex, IN.uv);
        #if defined(_FLIPBOOK_BLENDING)
            float4 packedDistortion2 = SAMPLE_TEXTURE2D(_DistortionTex, sampler_Trilinear_Repeat_BaseTex, IN.uv2AndBlend.xy);
            packedDistortion = lerp(packedDistortion, packedDistortion2, IN.uv2AndBlend.z);
        #endif
        float distortionStrength = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _DistortionStrength);
        float3 distortion = UnpackNormalScale(packedDistortion, distortionStrength);
    
        float3 sampledColor = SAMPLE_TEXTURE2D_LOD(_CameraColorTexture, sampler_LinearClamp, screenUV + distortion * albedo.a, 0).rgb;
        albedo.rgb = sampledColor;
    #endif

这样就可以有扭曲空间的效果了：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/17/sroxIVtXEFcHyeB.gif" width = "60%" height = "60%" alt="图124 - Round Particle Distortion Effect"/>
</div>

### Distortion Blend
之前因为我们直接输出了采样的 `_CameraColorTexture` 的颜色，但是有时候我们想要粒子原来的颜色，这时候我们可以使用 `_DistortionBlend` 在两者之间做混合：  

    _DistortionBlend("Distortion Blend", Range(0.0, 1.0)) = 1

当 `_DistortionBlend` 为 1 时，只能看到 Distortion 的效果；当 `_DistortionBlend` 为 0 时，能看到 Distortion 和粒子原来颜色混合的效果。并且我们希望粒子原来的 alpha 越小，即越透明 Distortion 效果越弱：  

    #if defined(_DISTORTION)
        ...
        float3 sampledColor = SAMPLE_TEXTURE2D_LOD(_CameraColorTexture, sampler_LinearClamp, screenUV + distortion * albedo.a, 0).rgb;
        float distortionBlend = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _DistortionBlend);
        albedo.rgb = lerp(sampledColor, albedo.rgb, saturate(albedo.a - distortionBlend));
    #endif

下面的效果是上面讲 Flipbook 时的那张 Flipbook Map 和它对应的 Flipbook Distortion Map 共同产生的，Flipbook Distortion Map 在教程里有，我这里就不放出来了：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/17/yGLZNih6I3c4nbf.gif" width = "60%" height = "60%" alt="图125 - Filpbook Particle Distortion Blend Effect（关闭了 Camera Near Fade）"/>
</div>

# Depth & Color Texture
我们之前只使用了一张 frame buffer，同时包含了颜色和深度信息。但其实深度模板缓冲区和目标视图缓冲区（color buffer）的资源是分开的，即**颜色附件 Color Attachment** 和**深度/模板附件 Depth/Stencil Attachment**，我们可以根据需求分别创建。

首先替换之前的 `_CameraFrameBuffer` 相关代码：  

``` C#
public static readonly int k_ColorBufferId = Shader.PropertyToID("_CameraColorBuffer");
public static readonly int k_DepthBufferId = Shader.PropertyToID("_CameraDepthBuffer");

...
{
    data.buffer.GetTemporaryRT(RenderTargetIDs.k_ColorBufferId, data.camera.pixelWidth, data.camera.pixelHeight, 0, FilterMode.Bilinear, asset.enableHDRFrameBufferFormat ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
    data.buffer.GetTemporaryRT(RenderTargetIDs.k_DepthBufferId, data.camera.pixelWidth, data.camera.pixelHeight, 32, FilterMode.Point, RenderTextureFormat.Depth);
    data.buffer.SetRenderTarget(new RenderTargetIdentifier(RenderTargetIDs.k_ColorBufferId), 
                                RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store,
                                new RenderTargetIdentifier(RenderTargetIDs.k_DepthBufferId),
                                RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);
}
```

然后别忘了 ReleaseTemporaryRT。

## Depth Prepass
教程中没有提到 Depth Prepass，这个技术是一个较为简单的优化技术，在复杂场景中能有效地提升性能，故顺便在这里实现一下。

### 基本原理
首先需要注意区分 **Early-Z** 和 **Depth Prepass**（Z-Prepass）：  
**①Early-Z** 是一个移动设备 GPU 的 TBR/TBDR 架构下的硬件技术（但是好像现在大部分 GPU 都支持，网上的资料都有点老了），它在硬件层面上修改了渲染管线，在光栅化阶段和片元着色器阶段中间，加入了一个 Early-Z 阶段，这个阶段进行的操作和原本逐片元操作/输出合并阶段的 z-test（为了与 early-z 区别，这个阶段也会被成为 **Late-Z**）操作完全一样。这样做的目的是为了提前剔除掉被遮挡的片元，减少 over-draw 从而节省 GPU 性能。Early-Z 的问题在于，若开启了 alpha test ，或者有丢弃像素的操作，又或者在片元着色器开启了深度写入，就会使 Early-Z 失效，所以一般情况下会配合软件层面的 Depth Prepass 使用。  
**②Depth Prepass** 是一个软件技术，其做法就是使用两个 pass，第一个 pass 渲染物体的深度（即 Depth Prepass），第二个 pass 渲染该物体的颜色。在渲染深度时，只开启 Zwrite 和 ZTest 渲染物体的深度；在渲染颜色时，关闭 Zwrite，并将 ZTest 设置为 **Equal**，注意这里深度比较函数必须是 Equal 不能是 LessEqual，Equal 下性能是最优的。Depth Prepass 可以有效地减少片元着色器的工作，特别适用于复杂的片元着色器（比如 PBR）以及复杂的场景（比如场景中有较多的花草树木，以及头发渲染）。

### 实现
***①第一步 Depth Prepass：***  
首先为 Opaque 和 AlphaTest 的物体准备一个 Depth Prepass，Shader 里类似如下：  

    Pass
    {
        Name "Depth"
        
        Tags { "LightMode" = "Depth" }
        
        ZWrite On
        ColorMask 0
        Cull [_Cull]
        
        HLSLPROGRAM
        #pragma target 4.5

        #pragma vertex DepthVert
        #pragma fragment DepthFrag

        #pragma shader_feature_local_fragment _CLIPPING

        #pragma multi_compile _ LOD_FADE_CROSSFADE

        #include "StandardForwardDepthPass.hlsl"
        ENDHLSL
    }

然后只需要在片元着色器中做裁切就行，大致如下：  

    struct Attributes
    {
        float4 positionOS   : POSITION;
        float2 uv           : TEXCOORD0;
    };

    struct Varyings
    {
        float4 positionHCS  : SV_POSITION;
        float2 uv           : TEXCOORD0;
    };

    Varyings DepthVert(Attributes IN)
    {
        Varyings OUT;
        OUT.uv = TRANSFORM_TEX(IN.uv, _BaseTex);
        OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);
        return OUT;
    }

    float DepthFrag(Varyings IN) : SV_DEPTH
    {
        float baseTexAlpha = SAMPLE_TEXTURE2D(_BaseTex, sampler_Trilinear_Repeat_BaseTex, IN.uv).a;
        float opacityTexAlpha = SAMPLE_TEXTURE2D(_OpacityTex, sampler_Trilinear_Repeat_BaseTex, IN.uv).r;
        float alpha = baseTexAlpha * opacityTexAlpha * _BaseColor.a;

        #if defined(_CLIPPING)
            clip(alpha - _Cutoff);
        #endif
            
        #if defined(LOD_FADE_CROSSFADE)
            float dither = InterleavedGradientNoise(IN.positionHCS.xy, 0);
            float isNextLodLevel = step(unity_LODFade.x, 0);
            dither = lerp(-dither, dither, isNextLodLevel);
            clip(unity_LODFade.x + dither);
        #endif

        return IN.positionHCS.z;
    }

***②第二步修改渲染颜色的 Pass：***  
这一步只需要将原先渲染颜色的 Pass 的 ZWrite 关闭，ZTest 设置为 **Equal** 即可：  

    Pass 
    {
        ...
        ZWrite Off
        ZTest Equal
        Cull [_Cull]
        ...
    }


***③第三步在 SRP 中提交绘制指令：***  
首先为 Depth Prepass 创建一个 ShaderTagId：  

``` C#
public static ShaderTagId k_DepthShaderTagId = new ShaderTagId("Depth");
```

然后就是绘制，Filtering & Sorting Settings 可以和 Draw Opaque、alphaTest 流程中的局部参数共用，流程就不重复说明了，详见第一篇文章。这里要注意一下的是绘制时无需传递 perObjectData，还有就是因为只写入深度，ClearRenderTarget 时只需要清除深度：  

``` C#
// Filtering & Sorting
FilteringSettings opaqueFiltering = 
    new FilteringSettings(new RenderQueueRange(2000, 2449));

FilteringSettings alphaTestFiltering =
    new FilteringSettings(new RenderQueueRange(2450, 2499));

SortingSettings opaqueSorting = new SortingSettings(data.camera)
{
    criteria = SortingCriteria.CommonOpaque
};

SortingSettings alphaTestSorting = new SortingSettings(data.camera)
{
    criteria = SortingCriteria.OptimizeStateChanges
};

// Depth PrePass
data.buffer.BeginSample("Depth PrePass");
data.buffer.SetRenderTarget(new RenderTargetIdentifier(RenderTargetIDs.k_DepthBufferId), RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);
data.buffer.ClearRenderTarget(true, false, data.camera.backgroundColor.linear);

DrawingSettings depthOpaqueDrawing = new DrawingSettings(k_DepthShaderTagId, opaqueSorting)
{
    enableInstancing = asset.enableGPUInstancing,
    perObjectData = PerObjectData.None
};

DrawingSettings depthAlphaTestDrawing = new DrawingSettings(k_DepthShaderTagId, alphaTestSorting)
{
    enableInstancing = asset.enableGPUInstancing,
    perObjectData = PerObjectData.None
};

RendererListParams depthOpaqueRendererListParams =
    new RendererListParams(data.cullingResults, depthOpaqueDrawing, opaqueFiltering);

RendererListParams depthAlphaTestRendererListParams =
    new RendererListParams(data.cullingResults, depthAlphaTestDrawing, alphaTestFiltering);

RendererList depthOpaqueRendererList = data.context.CreateRendererList(ref depthOpaqueRendererListParams);
RendererList depthAlphaTestRendererList = data.context.CreateRendererList(ref depthAlphaTestRendererListParams);

data.buffer.DrawRendererList(depthOpaqueRendererList);
data.buffer.DrawRendererList(depthAlphaTestRendererList);

data.buffer.EndSample("Depth PrePass");
```

最后在渲染颜色阶段，即 Draw Opaque、alphaTest 时，将渲染好的 DepthBuffer 与 ColorBuffer 同时设置为 RenderTarget，并且 Depth Buffer 的 RenderBufferLoadAction 是 Load，然后 ClearRenderTarget 只需要清除颜色即可：  

``` C#
data.buffer.SetRenderTarget(new RenderTargetIdentifier(RenderTargetIDs.k_ColorBufferId), 
                RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store,
                new RenderTargetIdentifier(RenderTargetIDs.k_DepthBufferId),
                RenderBufferLoadAction.Load, RenderBufferStoreAction.Store);
            
data.buffer.ClearRenderTarget(false, true, data.camera.backgroundColor.linear);
```

大致测试了下面渲染场景的帧率变化（在一个点光源下，开了后处理）：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/17/LzruBWN9wt6mKRc.png" width = "100%" height = "100%" alt="图126 - 左图：无 Depth PrePass 时总消耗 5.3 ms；右图：Depth PrePass 后总消耗 3.5 ms"/>
</div>

## Copy Depth
我们在渲染的时候，有时候需要采样 depth buffer，比如之前的 Soft Particles 效果、SSAO 等等。但是当我们以 depth buffer 作为 render target 的时候，不能同时对 depth buffer 进行采样，所以我们需要将 depth buffer 复制到 depth texture 里，Unity URP 的 CopyDepth 阶段就是在做这件事情。我们新创建一个 `_CameraDepthTexture` 的 RT 资源，创建的过程就不再赘述了，跟上面 `_CameraDepthBuffer` 一样。

我们之前后处理中提到的 Copy Shader 复制的是整个 Color Buffer，我们现在要创建一个复制 Depth Buffer 的版本，即 Copy Depth Shader，Shader 代码大致如下，将 ColorMask 设置为 0，开启深度写入：  

    Shader "Hidden/YPipeline/CopyDepth"
    {
        SubShader
        {
            Tags
            {
                "RenderType" = "Opaque"
            }
            
            ZTest Always
            ZWrite On
            ColorMask 0
            Cull Off

            Pass
            {
                Name "CopyDepth"
                
                HLSLPROGRAM
                #pragma target 3.5
                
                #pragma vertex CopyDepthVert
                #pragma fragment CopyDepthFrag

                #include "CopyDepthPass.hlsl"
                ENDHLSL
            }
        }
    }

然后顶点着色器跟之前的 Copy Shader 一样，片元着色器目标是 SV_DEPTH，而不是 SV_TARGET：  

    TEXTURE2D(_CameraDepthBuffer);
    SAMPLER(sampler_CameraDepthBuffer);

    struct Varyings
    {
        float4 positionHCS  : SV_POSITION;
        float2 uv           : TEXCOORD0;
    };

    Varyings CopyDepthVert(uint vertexID : SV_VertexID)
    {
        Varyings OUT;
        OUT.uv = float2((vertexID << 1) & 2, vertexID & 2);
        OUT.positionHCS = float4(OUT.uv * 2.0 - 1.0, UNITY_NEAR_CLIP_VALUE, 1.0);
        
        if (_ProjectionParams.x < 0.0) OUT.uv.y = 1.0 - OUT.uv.y;
        
        // #if UNITY_UV_STARTS_AT_TOP
        //     OUT.uv.y = 1.0 - OUT.uv.y;
        // #endif
        
        return OUT;
    }

    float CopyDepthFrag(Varyings IN) : SV_DEPTH
    {
        return SAMPLE_TEXTURE2D_LOD(_CameraDepthBuffer, sampler_CameraDepthBuffer, IN.uv, 0).r;
    }

具体什么时候 Copy Depth 我是参考了 URP 放在 Depth Prepass 和 Draw Opaque & AlphaTest 之间。


## Gizmos and Depth
之前在 Post Processing 时提到过，Gizmo 的绘制依赖于原来的 CameraTarget 中的深度信息。若没有深度信息，gizmos 就不会被物体遮挡。现在我们可以将深度信息复制进 CameraTarget 了：  

``` C#
if (Handles.ShouldRenderGizmos())
{
    BlitUtility.CopyDepth(data.buffer, RenderTargetIDs.k_DepthBufferId, BuiltinRenderTextureType.CameraTarget);
    RendererList gizmosRendererList = data.context.CreateGizmoRendererList(data.camera, GizmoSubset.PreImageEffects);
    data.buffer.DrawRendererList(gizmosRendererList);
}
```

这样子就可以看到 Gizmo 被正确地遮挡了：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/17/WGaoFULMK1l9JjR.jpg" width = "15%" height = "15%" alt="图127 - Gizmos recognizing depth"/>
</div>

教程中有提到，虽然 Unity 将 Gizmos 的绘制分为了 pre-FX 和 post-FX，但是教程作者并没有发现任何 pre-FX gizmos，所以可以将 pre-FX 和 post-FX 合并在一起在最后（即 Post Processing 后）绘制。

## Copy Color
很多透明物体的效果都需要用到场景颜色信息，比如透明物体的折射、透视、扭曲等等，简单使用透明度混合的透明效果其实不是很好，不能很好地做到玻璃、水面等效果。此时我们可以在 Opaque、AlphaTest 和 Skybox 渲染完成后，将 Color Buffer 复制到 `_CameraColorTexture` 纹理当中，然后在实现透明物体的效果时，采样它。创建 `_CameraColorTexture` 纹理跟上面 `_CameraDepthTexture` 类似，然后在 Skybox 渲染后进行复制即可：  

``` C#
data.buffer.BeginSample("Copy Color");
data.buffer.GetTemporaryRT(RenderTargetIDs.k_ColorTextureId, data.camera.pixelWidth, data.camera.pixelHeight, 0, FilterMode.Bilinear, 
    asset.enableHDRFrameBufferFormat ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
BlitUtility.BlitTexture(data.buffer, RenderTargetIDs.k_ColorBufferId, RenderTargetIDs.k_ColorTextureId);

data.buffer.EndSample("Copy Color");
```

还是别忘了 ReleaseTemporaryRT。这里顺便提一下，教程中类似于 URP 在 PipelineAsset 里提供了一个选项用于是否开启 Copy Color（Copy Depth 也有一个选项，即 URP 中的 Depth Texture 和 Opaque Texture 选项），若不开启则将 `_CameraColorTexture` 设置为纯灰贴图。因为我觉得 URP 是通用渲染管线，所以它给了这个选项，而我们的渲染管线完全可以根据项目需求选择是否 Copy Color，所以我没有添加这个选项，若不需要 Copy Color，完全可以注释掉这些代码。


# Render Scale
这一章节主要讲调整渲染分辨率，这样可以让低分辨率的画面呈现在高分辨率的屏幕上，即像素风格。或者对更高分辨率的渲染图进行超采样 supersample，从而减少走样问题，即 **Super Sampling Anti-Aliasing (SSAA) 超采样抗锯齿**。

## Buffer Size
首先在 PipelineAsset 里添加 renderScale 属性用于控制渲染分辨率：  

``` C#
[Range(0.1f, 2f)] 
public float renderScale = 1.0f;
```

最大值设置为 2 是因为我们采样时用的 bilinear，renderScale 大于 2 了会导致下采样至 cameraTarget 时有些像素被完全抛弃，从而反而恶化渲染质量。当然你也可以自己写个 8×SSAA 的采样方式。然后我们给 Color Attachment 和 Depth Attachment 设置新的分辨率：  

``` C#
Vector2Int bufferSize = new Vector2Int((int) (camera.pixelWidth * asset.renderScale), (int) (camera.pixelHeight * asset.renderScale));

data.buffer.GetTemporaryRT(YPipelineShaderIDs.k_ColorBufferID, bufferSize.x, bufferSize.y, 0, FilterMode.Bilinear, 
    data.asset.enableHDRFrameBufferFormat ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
data.buffer.GetTemporaryRT(YPipelineShaderIDs.k_DepthBufferID, bufferSize.x, bufferSize.y, 32, FilterMode.Point, 
    RenderTextureFormat.Depth);
data.buffer.GetTemporaryRT(YPipelineShaderIDs.k_ColorTextureID, bufferSize.x, bufferSize.y, 0, FilterMode.Bilinear, 
    data.asset.enableHDRFrameBufferFormat ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
data.buffer.GetTemporaryRT(YPipelineShaderIDs.k_DepthTextureID, bufferSize.x, bufferSize.y, 32, FilterMode.Point, 
    RenderTextureFormat.Depth);
```

在 Unity URP 中，Scene 窗口的渲染不会受到 renderScale 的影响，我觉得这样没有必要，若是想要 Scene 窗口的渲染不受到影响，可以当摄像机为 SceneView 时，不使用 renderScale：  

``` C#
if (camera.cameraType == CameraType.SceneView)
{
    ...
}
```

## 对 Shader 的影响
之前 particle shader 的某些效果采样了 ColorTexture 或 DepthTexture，但是使用的是 UnityInput 里的 `_ScreenParams`，这个参数是 CameraTarget 的分辨率，而不是我们设置的渲染分辨率。为了让 particle shader 效果不出错误，我们需要自己传递渲染分辨率：  

``` C#
public static readonly int k_BufferSizeID = Shader.PropertyToID("_CameraBufferSize");
...

Vector2Int bufferSize = new Vector2Int((int) (camera.pixelWidth * asset.renderScale), (int) (camera.pixelHeight * asset.renderScale));
data.buffer.SetGlobalVector(YPipelineShaderIDs.k_BufferSizeID, new Vector4(1f / bufferSize.x, 1f / bufferSize.y, bufferSize.x, bufferSize.y));
```

然后计算 ScreenUV 时讲 `_ScreenParams` 改为 `_CameraBufferSize`：  

    float2 screenUV = IN.positionHCS.xy * _CameraBufferSize.xy;

除了 particle shader，后处理中的 Bloom 也要修改分辨率：  

``` C#
// do bloom at half or quarter resolution
int width;
int height;
if (m_Bloom.ignoreRenderScale.value)
{
    width = data.camera.pixelWidth >> (int) m_Bloom.bloomDownscale.value;
    height = data.camera.pixelHeight >> (int) m_Bloom.bloomDownscale.value;
}
else
{
    width = data.bufferSize.x >> (int) m_Bloom.bloomDownscale.value;
    height = data.bufferSize.y >> (int) m_Bloom.bloomDownscale.value;
}
```

因为 Bloom 是一个跟分辨率相关的效果，调整 RenderScale 会影响到 Bloom 的表现，降低 RenderScale 会使 Bloom 效果变大，增加 RenderScale 会使 Bloom 效果变小。所以可以在 Bloom 的 Volume Component 里添加了 ignoreRenderScale 的 bool 属性，即上面代码 if 语句中的控制变量，用于控制 Bloom 是否受到渲染分辨率的影响。

## Rescaling
改变渲染分辨率后，当上采样或下采样到最终的 CameraTarget 时，会有一些额外的副作用。主要有两点，第一点是 HDR 颜色因为数值太大，导致其对 Bilinear 插值的结果造成了显著的影响；第二点是当 color correction 时，有可能会产生意外的颜色带，比如改变 midtone 后物体边界产生颜色带：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/25/3ciAFzNtWIdjoLD.png" width = "40%" height = "40%" alt="图128 - 上：render scale 0.5 和 2 时 HDR 产生的颜色带；下：render scale 0.5, 1, 以及 2 时，Strong red midtones 调整后产生的颜色带"/>
</div>

产生这个现象的原因是，我们在 color correction 和 tone mapping 前对渲染图进行了 Bilinear 采样。解决方案就是在 color correction 和 tone mapping 前使用 Point 采样，然后将 Post Processing 的结果不直接输出到 CameraTarget，而是使用 finalPost Shader 额外复制一次，使用 Bilinear 复制进 CameraTarget。finalPost 的采样方式除了 Bilinear 还可以选择 Bicubic 以及其他采样方式，特别是在上采样的时候可以提高渲染质量（即 render scale 小于 1 时）。具体实现也比较简单，我这里就不摘抄了。

上述问题解决的主要还是 3D 像素风游戏的问题，即 render scale 小于 1 时。若是没有做 3D 像素风游戏的需求，其实可以完全不添加这些功能，毕竟 URP 添加这些功能的主要原因是它是通用引擎。


# FXAA
由于最终输出的分辨率有限，图像上会有很多**锯齿 jaggies**。上面提到的 **SSAA** 虽然能有效处理锯齿问题，但是它是非常耗费性能的，4X SSAA 的计算量就是原来的 4 倍。除了硬件 MSAA 外，常见的主流抗锯齿有 **FXAA（快速近似抗锯齿 Fast Approximate Anti-Aliasing）**、**SMAA（增强型子像素形态抗锯齿 Enhanced Subpixel Morphological Anti-Aliasing）**、**TAA (时间抗锯齿 Temporal Anti-Aliasing)** 等等。这里只介绍最简单的性能最好的方法，即 FXAA，当然它从效果上而言相对也比较一般，它最大的问题就是看起来会变得模糊，但是由于它性能开销较低，适用于性能较低的设备，比如手机。

**FXAA** 是一个基于后处理的屏幕空间的抗锯齿技术，它是由 NVIDIA 的 Timothy Lottes 开发的，受到了 **MLAA（形态抗锯齿 Morphological Anti-Aliasing）**的启发。形态抗锯齿的主要原理就是检测物体或颜色边缘然后选择性地模糊，FXAA 和 SMAA 都是形变抗锯齿的一种。教程中介绍的 FXAA 版本是 3.11（应该就是最终版本了），它是质量最高的版本，能够一定程度上缓解长边的锯齿问题。Unity URP 有把 NVIDIA 的实现全部复制下来，详见 `com.unity.render-pipelines.universal/Shaders/PostProcessing/FXAA3_11.hlsl`。

> 有关 FXAA 的资料有：https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf 、https://www.iryoku.com/aacourse/downloads/09-FXAA-3.11-in-15-Slides.pdf 、https://gist.github.com/kosua20/0c506b81b3812ac900048059d2383126 。

FXAA 3.11 有两个版本，其中 Quality 版本是较注重抗锯齿质量的版本，Console 版本是较注重抗锯齿速度的版本。教程中主要讲解的是 Quality 版本。

> 下面代码有个小问题是使用的 TexelSize 应该是基于输出的分辨率，而不是基于输入的。否则调小 Render Scale 会出现奇怪图案。

## FXAA Quality
FXAA 应该发生在 color grading 的后面，但是有些后处理应该放在 FXAA 后面，比如 Film Grain 胶片颗粒效果，具体顺序可以参考 URP 或 HDRP。我跟 URP 或 HDRP 一样，将 FXAA 放在了 FinalPost Shader 中处理。

### Luma Contrast
FXAA 通过确定水平和垂直方向上像素点的亮度差，来计算对比值，当对比度值较大时，则进行抗锯齿处理。而亮度可以通过 $\,Y = 0.2126 R + 0.7152 G + 0.0722 B\,$ 计算，但是 FXAA 的白皮书里提到，FXAA 需要的是 Non-Linear RGB 的输入，因为我们需要根据感知上的差异大小以获取更优秀的抗锯齿效果。教程中也提到了这一点，所以需要计算 **Gamma-Adjusted Luminance**，即 **Luma**。我实际测试了一下，使用 Luma 确实会比 Luminance 效果好一点点，但是肉眼还是很难区分出区别，特别是当输出分辨率较高时，我看知乎上很多 FXAA 教程也没有将使用 Luma，都是直接使用 Luminance。

    float GetLuma(float3 rgb)
    {
        return sqrt(Luminance(rgb));
    }

还有就是因为人眼对绿色的亮度最为敏感，我们可以直接使用绿色来替代 Luma 作为亮度以节省性能。亮度值也可以在上一个 Pass 中处理时，写入到 alpha 通道中，这样可以减少采样时亮度的计算，因为采样的时候可能会重复采样从而重复计算亮度。

采样的位置是下图所示，分别得到中间点 M 和周围四个点 N、E、W、S 的亮度值：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/28/OSvIorZFNbdnauC.png" width = "20%" height = "20%" alt="图129 - FXAA Neighborhood Samples"/>
</div>

    float4 SampleOffset(float2 uv, float uOffset, float vOffset)
    {
        uv += float2(uOffset, vOffset) * _BlitTexture_TexelSize.xy;
        return SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, uv, 0);
    }

    float3 ApplyFXAAQuality(float2 uv, float4 middleColor)
    {
        float M = GetLuma(middleColor);
        float N = GetLuma(SampleOffset(uv, 0, 1));
        float E = GetLuma(SampleOffset(uv, 1, 0));
        float S = GetLuma(SampleOffset(uv, 0, -1));
        float W = GetLuma(SampleOffset(uv, -1, 0));
    }

然后就是计算出这 5 个值中的最大值和最小值，相减得到**对比值 Contrast**：  

    float3 ApplyFXAAQuality(float2 uv, float4 middleColor)
    {
        ...
        // Calculate Contrast
        float maxLuma = max(max(max(N, E), max(W, S)), M);
        float minLuma = min(min(min(N, E), min(W, S)), M);
        float contrast = maxLuma - minLuma;
    }

直接输出 Contrast，相当于提取了基于颜色的边缘，边缘正好会是两个像素点宽度，如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/28/AKNpUuGHSf6WmTl.jpg" width = "25%" height = "25%" alt="图130 - Luma Contrast Visualization"/>
</div>

### Threshold
为了防止模糊到非边缘的像素点，我们需要给 Contrast 设置一个 Threshold，只要超过 Threshold 的像素点才需要做抗锯齿处理，这种 Threshold 称为 **Contrast Threshold** 或者 **Fixed Threshold**。还有一种 Threshold 称为 **Relative Threshold**，它是根据亮度的最大值的比例来拒绝像素点的。白皮书中对 Contrast Threshold 和 Relative Threshold 的值的规定和说明如下：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/28/K7zsdMU8JaDhLc1.jpg" width = "40%" height = "40%" alt="图131 - FXAA Threshold，上为 Relative Threshold，下位 Contrast Threshold"/>
</div>

Contrast Threshold 值范围在 0.03125 ~ 0.08333 之间，Relative Threshold 值范围在 0.0625 ~ 0.3333 之间。我们可以根据 Relative Threshold 和 Contrast Threshold 的较大值作为基准来判断是否跳过该像素：  

    float4 _FXAAParams; // x: contrastThreshold, y: relativeThreshold, z: blendFactor

    float3 ApplyFXAAQuality(float2 uv, float4 middleColor)
    {
        ...
        // Threshold
        if (contrast < max(_FXAAParams.x, maxLuma * _FXAAParams.y)) return middleColor;
    }

### Blend Factor
接下来就是确定要进行抗锯齿处理的像素点进行混合（模糊）时的系数，混合系数是根据原像素点（中间像素点）的亮度和周围像素点的亮度平均值的差异来确定的。计算周围像素点亮度的平均值时，简单的算术平均效果肯定没这么好，为了更好地效果，需要再额外采样并得到斜对角上四个点的亮度值，即 NW、NE、SW、SE 点，对角像素距离中心像素比较远，所以权重会比周围 4 个低，滤波核如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/28/WnjMxZ69os3TmlX.png" width = "20%" height = "20%" alt="图132 - FXAA Filter Kernel"/>
</div>

为了使混合权重更加平滑，我们对得到的混合权重再用 smoothstep 处理一下，再将结果进行平方处理，代码如下：  

    float3 ApplyFXAAQuality(float2 uv, float4 middleColor)
    {
        ...
        float NW = GetLuma(SampleOffset(uv, -1, 1));
        float NE = GetLuma(SampleOffset(uv, 1, 1));
        float SW = GetLuma(SampleOffset(uv, -1, -1));
        float SE = GetLuma(SampleOffset(uv, 1, -1));
        ...
        // Blend Factor Calculation
        float filter = 2.0 * (N + E + S + W) + NE + NW + SE + SW;
        filter = filter / 12.0;
        filter = abs(filter - M);
        filter = saturate(filter / contrast);
        float blendFactor = smoothstep(0.0, 1.0, filter);
        blendFactor = blendFactor * blendFactor;
    }

### Blend Direction
然后就是确定进行混合计算的方向（锯齿边界的方向）。FXAA 会混合中间像素和 N、E、S、W 中的一个像素，选择哪个像素取决于锯齿边界的方向：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/28/wOpCnoZU8Rfv94W.png" width = "30%" height = "30%" alt="图133 - Four Possible Blend Directions"/>
</div>

当然锯齿边界不会是完美的水平或者垂直方向，下面的方法只是寻找一个最接近的方向，如果是一条水平锯齿边，那么中间像素的上下像素的对比值应该很高，如果是一条垂直锯齿边，那么中间像素的左右像素的对比值应该很高。那么一个简单的判断，如下：  

    // Measure Blend Direction
    float horizontal = abs(N + S - 2.0 * M);
    float vertical   = abs(E + W - 2.0 * M);
    bool isHorizontal = horizontal > vertical;

但是这样只比较了上下左右四个像素，我们还可以把 NE、NW、SE、SW 也都考虑进去，同时算上权重，如下：  

    // Measure Blend Direction
    float horizontal = abs(N + S - 2.0 * M) * 2.0 + abs(NE + SE - 2.0 * E) + abs(NW + SW - 2.0 * W);
    float vertical   = abs(E + W - 2.0 * M) * 2.0 + abs(NE + NW - 2.0 * N) + abs(SE + SW - 2.0 * S);
    bool isHorizontal = horizontal > vertical;

将 isHorizontal 输出为红色如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/28/TkQp37qVLK1iJBU.jpg" width = "40%" height = "40%" alt="图134 - Horizontal edges are red, Vertical edges are white"/>
</div>

可以看到方向大致判断没错。判断完方向后，我们就可以知道要混合的像素是在 u 方向还是 v 方向了：  

    float2 pixelStep = isHorizontal ? float2(0, _BlitTexture_TexelSize.y) : float2(_BlitTexture_TexelSize.x, 0);

当然我们还需要判断正负方向，只需要比较正负方向的亮度与中间像素的亮度的差值的大小即可：  

    float positive = abs((isHorizontal ? N : E) - M);
    float negative = abs((isHorizontal ? S : W) - M);
    if (positive < negative) pixelStep = -pixelStep;

拿到了混合方向和混合系数后，就可以混合了，将 BlendFactor 乘上 pixelStep 加在原 uv 上，进行采样即可，这里是利用了 Bilinear 采样器的混合效果：  

    return SampleOffsetZero(uv + pixelStep * blendFactor).rgb;

最终效果对比如下（这个是个光滑的球，由于使用的是寒霜的 Renormalized Disney diffuse，在边缘有条暗边，加剧了抗锯齿的需求，汗）：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/28/LpqYJNdj4IlXuRc.png" width = "40%" height = "40%" alt="图135 - 左：无 FXAA；右：FXAA Blending"/>
</div>

我们可以为 Blend Factor 设置一个 Strength 参数，在 NVIDIA FXAA 3.11 的实现中对该参数的说明如下：  

    // It is here now to allow easier tuning.
    // Choose the amount of sub-pixel aliasing removal.
    // This can effect sharpness.
    //   1.00 - upper limit (softer)
    //   0.75 - default amount of filtering
    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)
    //   0.25 - almost off
    //   0.00 - completely off

因为 FXAA 经常被诟病太模糊，所以可以通过该参数来减轻模糊，乘在 blendFactor 里就行：  

### Edge Blend
上述的 Blend Factor 只是根据中间像素点周围 3 × 3 的像素点进行采样分析，并且假设锯齿边界是完全垂直或者水平的，但是很多时候，我们的锯齿边界是带有角度的。这样，要得到得到正确的混合系数，就需要将采样范围扩展到 3 × 3 像素块之外。

<div  align="center">  
<img src="https://s2.loli.net/2025/04/28/nsXUu1C9iEgqcjz.png" width = "25%" height = "25%" alt="图136 - 最下为理想情况下的抗锯齿效果"/>
</div>

为了进一步确定边缘，我们需要使用之前计算的待混合像素点与中间像素的亮度的差值（即上面的 positive 或 negative，又称为**梯度值 Gradient**）以及待混合像素点的亮度：  

    // if (positive < negative) pixelStep = -pixelStep;

    // Reserve Blending Pixel Gradient & Luma
    float gradient, oppositeLuma;
    if (positive > negative)
    {
        gradient = positive;
        oppositeLuma = isHorizontal ? N : E;
    }
    else
    {
        pixelStep = -pixelStep;
        gradient = negative;
        oppositeLuma = isHorizontal ? S : W;
    }

接下来就是沿着边界两侧的方向，进行搜索，直到找到锯齿边界终点为止。判断边界的方式是计算两侧的亮度值的差，是否和当前的亮度变化梯度值符合，如下图所示：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/28/5NQub23jWcYULDe.png" width = "30%" height = "30%" alt="图137 - Searching for the end pixel"/>
</div>

但是其实不需要每次采样两个点，可以利用双线性插值，在边界处采样，这样也足以判断出边界的终点，如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/28/olvienRMAwjVd42.png" width = "30%" height = "30%" alt="图138 - Searching for the end pixel"/>
</div>

所以我们首先得确定采样的 uv，以及每次采样的步长：  

    // Edge Factor Calculation
    float2 edgeUV = uv;
    edgeUV += pixelStep * 0.5f;
    float2 edgeStep = isHorizontal ? float2(_BlitTexture_TexelSize.x, 0) : float2(0, _BlitTexture_TexelSize.y);

然后先算出中间像素点和待混合像素点的平均亮度值，沿着两侧进行搜索采样时，计算当前采样点平均值和中间像素点平均值的亮度差，若亮度差超过了 0.25 倍的梯度值，则认为是到达了锯齿边界的终点，代码大致如下：  

    float edgeLuma = (M + oppositeLuma) * 0.5f;
    float gradientThreshold = gradient * 0.25f;

    float2 uvP = edgeUV + edgeStep;
	float lumaGradientP = abs(GetLuma(SampleOffsetZero(uvP)) - edgeLuma);
	bool atEndP = lumaGradientP > gradientThreshold;

当然只做一步是不够的，我们需要循环遍历，将上面代码删除。因为不可能无限循环去搜索，我们需要假设一个最大循环步长，先假设为 10 步，我们需要向两端都进行搜索，并记录两端的像素距离，同时若搜索步长超过了 10 步还是没有找到边界，则默认边界像素距离长度额外加 8：  

    #define EXTRA_EDGE_STEPS 10
    #define LAST_EDGE_STEP_GUESS 8.0
    ...

    float edgeLuma = (M + oppositeLuma) * 0.5f;
    float gradientThreshold = gradient * 0.25f;

    float2 uvP = edgeUV;
    float2 uvN = edgeUV;
    float lumaDeltaP, lumaDeltaN, distanceP, distanceN;
    int i;
    
    UNITY_UNROLL
    for (i = 1; i <= EXTRA_EDGE_STEPS; i++)
    {
        uvP += edgeStep;
        lumaDeltaP = GetLuma(SampleOffsetZero(uvP)) - edgeLuma;
        if (abs(lumaDeltaP) > gradientThreshold) break;
    }
    if (i == EXTRA_EDGE_STEPS + 1)
    {
        uvP += LAST_EDGE_STEP_GUESS * edgeStep;
    }
    
    UNITY_UNROLL
    for (i = 1; i <= EXTRA_EDGE_STEPS; i++)
    {
        uvN -= edgeStep;
        lumaDeltaN = GetLuma(SampleOffsetZero(uvN)) - edgeLuma;
        if (abs(lumaDeltaN) > gradientThreshold) break;
    }
    if (i == EXTRA_EDGE_STEPS + 1)
    {
        uvP -= LAST_EDGE_STEP_GUESS * edgeStep;
    }

    if (isHorizontal)
    {
        distanceP = uvP.x - uv.x;
        distanceN = uv.x - uvN.x;
    }
    else
    {
        distanceP = uvP.y - uv.y;
        distanceN = uv.y - uvN.y;
    }

接下来就是计算 Edge 混合系数了，我们可以根据锯齿边界最近端的像素距离占总长度的比例来计算出一个基于 Edge 的混合系数。但是在此之前，我们还需要判断一下混合的方向是否和当前需要计算的一致，这里是通过比较相对亮度的正负值来实现的。比如下图中的锯齿边界，在水平的锯齿边界上计算时，两个黄色的点是现在我们要计算混合系数的目标像素点，两个红色标记的点是我们期望进行混合的点。因为左边的混合方向其实应该是向上的，因此这种情况下就不需要进行计算，而是在处理上面红色像素点时进行计算。而右边的黄色标记目标像素点，是需要在当前处理的。

<div  align="center">  
<img src="https://s2.loli.net/2025/04/29/fwAi1HCWdI4GFxL.png" width = "60%" height = "60%" alt="图139 - Blending on a Single Side"/>
</div>

如果判断出边界方向不符合时，就直接设 Edge 混合系数为 0，边界方向符合时，按照相对的距离，来估算混合系数：  

    float edgeFactor;
    if (distanceP < distanceN)
    {
        if (sign(lumaDeltaP) == sign(M - edgeLuma))
        {
            edgeFactor = 0;
        }
        else
        {
            edgeFactor = 0.5f - distanceP / (distanceP + distanceN);
        }
    }
    else
    {
        if (sign(lumaDeltaN) == sign(M - edgeLuma))
        {
            edgeFactor = 0;
        }
        else
        {
            edgeFactor = 0.5f - distanceN / (distanceP + distanceN);
        }
    }

最终取 Edge Factor 和 Blend Factor 的最大值作为最终混合系数：  

    float finalFactor = max(blendFactor, edgeFactor);
    return SampleOffsetZero(uv + pixelStep * finalFactor).rgb;

最终效果如下：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/29/9tfrdN1XSUZAQPl.png" width = "40%" height = "40%" alt="图140 - 左：无 FXAA；右：FXAA finalFactor"/>
</div>

### Edge Quality
我们可以为 Edge 的搜索设置步长来限制性能消耗（步长可以参考 NVIDIA FXAA 3.11 的实现中的部分预设），如下：  

    #if defined(FXAA_QUALITY_LOW)
        #define EXTRA_EDGE_STEPS 5
        #define EDGE_STEP_SIZES 1.0, 1.5, 2.0, 2.0, 2.0
        #define LAST_EDGE_STEP_GUESS 8.0
    #elif defined(FXAA_QUALITY_MEDIUM)
        #define EXTRA_EDGE_STEPS 8
        #define EDGE_STEP_SIZES 1.0, 1.5, 2.0, 2.0, 2.0, 2.0, 2.0, 4.0
        #define LAST_EDGE_STEP_GUESS 8.0
    #else
        #define EXTRA_EDGE_STEPS 12
        #define EDGE_STEP_SIZES 1.0, 1.0, 1.0, 1.0, 1.0, 1.5, 1.5, 2.0, 2.0, 2.0, 2.0, 4.0
        #define LAST_EDGE_STEP_GUESS 8.0
    #endif

    static const float EdgeStepSizes[EXTRA_EDGE_STEPS] = { EDGE_STEP_SIZES };

    ···
    float3 ApplyFXAAQuality(float2 uv, float4 middleColor)
    {
        ...
        UNITY_UNROLL
        for (i = 1; i <= EXTRA_EDGE_STEPS; i++)
        {
            uvP += EdgeStepSizes[i - 1] * edgeStep;
            lumaDeltaP = GetLuma(SampleOffsetZero(uvP)) - edgeLuma;
            if (abs(lumaDeltaP) > gradientThreshold) break;
        }
        ...
    }

因为图片会压缩以及采样，上述三种预设质量效果的差别不是很能展示出来，故我就不展示了。我实测下来，FXAA_QUALITY_LOW 的质量会比较差，FXAA_QUALITY_MEDIUM 和 FXAA_QUALITY_HIGH 的差别肉眼不是很能察觉得出来，但是其实 FXAA_QUALITY_MEDIUM 和 FXAA_QUALITY_HIGH 的性能差距也不会很大，所以默认开 FXAA_QUALITY_HIGH 就行。

## FXAA Console
FXAA Quality 版本需要的采样次数是比较多的，Console 版本每个像素点最多只需要进行 9 次采样，比 Quality 版本要少很多，当然效果也会差一点。FXAA Console 的主要逻辑是计算锯齿边的法线方向，然后根据法线方向做混合。

首先还是采样周围像素点，然后做阈值判断，只不过 Console 版本只采样对角线上 4 个点，并且这里的偏移只有半个像素，如下：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/29/yBT8NCVrsM2ObSQ.png" width = "20%" height = "20%" alt="图141 - FXAA Console Sampling Pixels"/>
</div>

    float M  = GetLuma(middleColor);
    float NW = GetLuma(SampleOffset(uv, -0.5,  0.5));
    float NE = GetLuma(SampleOffset(uv,  0.5,  0.5));
    float SW = GetLuma(SampleOffset(uv, -0.5, -0.5));
    float SE = GetLuma(SampleOffset(uv,  0.5, -0.5));

    // Calculate Contrast
    float maxLuma = max(max(NW, NE), max(SW, SE));
    float minLuma = min(min(NW, NE), min(NW, NE));
    float contrast = max(maxLuma, M) - min(minLuma, M);
    
    // Threshold
    if (contrast < max(FXAA_CONSOLE_CONTRAST_THRESHOLD, maxLuma * FXAA_CONSOLE_RELATIVE_THRESHOLD)) return middleColor.rgb;

注意 Console 版本的 Contrast Threshold（fxaaConsoleEdgeThresholdMin）和 Relative Threshold（fxaaConsoleEdgeThreshold）的数值预设和 Quality 版本不太一样：  

    //   0.125 leaves less aliasing, but is softer (default!!!)
    //   0.25 leaves more aliasing, and is sharper
    FxaaFloat fxaaConsoleEdgeThreshold,
    //   0.06 - faster but more aliasing in darks
    //   0.05 - default
    //   0.04 - slower and less aliasing in darks
    FxaaFloat fxaaConsoleEdgeThresholdMin,

然后就是计算当前亮度变化的梯度，亮度变化最快的方向，就是锯齿边界的法线方向，如下图所示：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/29/mgsj4P1NIrqdkGE.png" width = "20%" height = "20%" alt="图142 - Determine Blending Direction"/>
</div>

如上图中红色箭头的方向就是亮度变化的梯度方向，即法线方向，锯齿方向是和法线方向垂直的绿色箭头的方向。我们之后混合的是沿着锯齿方向的前后两个像素，故需要求绿色箭头的方向：  

    // Determine Blending Direction
    float2 dir;
    dir.x = -((NW + NE) - (SW + SE));
    dir.y = ((NE + SE) - (NW + SW));
    dir = normalize(dir);

沿着锯齿方向分别向正负方向偏移 uv，进行两次采样，再平均后作为抗锯齿的结果。

    float2 dir1 = dir * TEXEL_SIZE.xy * FXAA_CONSOLE_SCALE;
    float4 rgbN1 = SampleOffsetZero(uv - dir1);
    float4 rgbP1 = SampleOffsetZero(uv + dir1);
    float4 rgbA = (rgbN1 + rgbP1) * 0.5;

`FXAA_CONSOLE_SCALE` 是个可控制的变量，NVIDIA FXAA 3.11 中的参数建议如下，建议默认值为 0.5：  

    // N = 0.50 (default)
    // N = 0.33 (sharper)
    // {x___} = -N/screenWidthInPixels  
    // {_y__} = -N/screenHeightInPixels
    // {__z_} =  N/screenWidthInPixels  
    // {___w} =  N/screenHeightInPixels 
    FxaaFloat4 fxaaConsoleRcpFrameOpt,

不过这样做的问题就是，这种方式对于斜向的锯齿比较友好，但是对于水平和垂直方向的锯齿，却不是很友好。因为水平和垂直方向的锯齿，计算的方向的一个维度会是 0，会导致两次采样几乎没有覆盖到应该要混合区域的区域。因此我们要进行一次额外的计算，将偏移距离延伸至更远处，具体的做法就是使用 dir 向量分量的最小值的倒数，将 dir 进行缩放。这样如果 dir 的最小分量的值越小，就能采样到越远的地方：

    float dirAbsMinTimesC = min(abs(dir.x), abs(dir.y)) * FXAA_CONSOLE_EDGE_SHARPNESS;
    float2 dir2 = clamp(dir / dirAbsMinTimesC, -2.0, 2.0) * 2.0;
    float4 rgbN2 = SampleOffsetZero(uv - dir2 * TEXEL_SIZE.xy);
    float4 rgbP2 = SampleOffsetZero(uv + dir2 * TEXEL_SIZE.xy);
    float4 rgbB = rgbA * 0.5 + (rgbN2 + rgbP2) * 0.25;

为了防止 dir2 采样到亮度变化较大的区域，产生噪点，这里我们再对 dir2 采样到的亮度值进行一次判断，如果得到的结果超过了周围最小最大的亮度范围，则丢弃新的采样的结果：  

    float newLum = GetLuma(rgbB);
    if((newLum > minLuma) && (newLum < maxLuma))
    {
        rgbA = rgbB;
    }
    return rgbA.rgb;

FXAA Quality 和 FXAA Console 对比如下（实测下来感觉 FXAA Quality 即使是 Low 的预设也会比 Console 略微好一点）：  

<div  align="center">  
<img src="https://s2.loli.net/2025/04/29/cWn2ixg5Z3Hqzjy.png" width = "100%" height = "100%" alt="图143 - 上：无 FXAA；左：FXAA Console；右：FXAA Quality"/>
</div>

图片上可能看不太出来区别，最好还是实践看效果。