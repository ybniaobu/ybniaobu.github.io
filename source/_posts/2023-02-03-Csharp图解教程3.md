---
title: 《C#图解教程》读书笔记（三）
date: 2023-02-03 19:53:13
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：XXXXXXXXXXXXX。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第十六章 接口
## 什么是接口
**接口 interface**是指定一组函数成员但不实现它们的引用类型，所以只能用类和结构来实现接口。

接口的用途可以通过下面2个例子介绍，第一个例子不使用接口：

``` C#
class CA {
    public string Name;
    public int Age;
}

class CB {
    public string First;
    public string Last;
    public double PersonsAge;
}

class Program {
    static void PrintInfo( CA item ) {
        Console.WriteLine($"Name: { item.Name }, Age: { item.Age }");
    }

    static void Main() {
        CA a = new CA() { Name = "John Doe", Age = 35 };
        PrintInfo( a );
    }
}
```

上述代码只要传入 CA 类型对象，PrintInfo 方法就能工作正常。但传入 CB 类型对象就不行，而且 CB 的结构、字段名称和类型都可能与 CA 不一样。而接口可以使不管传入 PrintInfo 的类的结构是什么样的，都能正常处理：

``` C#
interface IInfo
{
    string GetName(); //返回string的方法
    string GetAge(); //返回string的方法
}

class CA : IInfo //声明实现接口的CA类
{
    public string Name;
    public int Age;
    public string GetName() { return Name; } //实现两个接口方法
    public string GetAge() { return Age.ToString( ); } //实现两个接口方法
}

class CB : IInfo //声明实现接口的CB类
{
    public string First;
    public string Last;
    public double PersonsAge;
    public string GetName() { return First + " " + Last; } //实现两个接口方法
    public string GetAge() { return PersonsAge.ToString(); } //实现两个接口方法
}

class Program
{
    static void PrintInfo( IInfo item ) //传入接口的引用
    {
        Console.WriteLine( "Name:{0}, Age {1}", item.GetName(), item.GetAge() );
    }

    static void Main()
    {
        CA a = new CA() { Name = "John Doe", Age = 35 };
        CB b = new CB() { First = "Jane", Last = "Doe", PersonsAge = 33 };

        PrintInfo(a); //对象的引用能自动转换为它们实现的接口的引用
        PrintInfo(b);
    }
}
```

运行结果如下：

``` console
Name:John Doe, Age 35
Name:Jane Doe, Age 33
```

### 使用 IComparable 接口的示例
通过以下示例来更好地了解接口：

``` C#
var myInt = new [] { 20, 4, 16, 9, 2 }; //创建int数组

Array.Sort(myInt); //按大小排序

foreach (var i in myInt) //输出
    Console.Write($"{ i } ");
```

Array 类的 Sort 方法可以运行在 int 数组上，但是在类数组上无法运行，如下：

``` C#
class MyClass
{
    public int TheValue;
}
    ...
MyClass[] mc = new MyClass[5]; //创建有5个元素的数组
    ...
Array.Sort(mc); //尝试使用Sort时抛出异常
```

Array 类的 Sort 方法实际上依赖一个叫做 **IComparable** 的接口，它声明在 BCL 中，包含唯一的方法 CompareTo 。下面代码展示了 IComparable 接口的声明，包含 CompareTo 方法的声明，该方法接受一个 object 类型的参数，并且没有实现，即实现用分号表示：

``` C#
public interface IComparable
{
    int CompareTo( object obj );
}
```

尽管在接口声明中没有为 CompareTo 方法提供实现，但 IComparable 接口的 .NET 文档描述了该方法应该做的事情。在调用 CompareTo 方法时，它应该返回以下几个值之一：  
①负数值，如果当前对象小于参数对象；  
②正数值，如果当前对象大于参数对象；  
③零，如果两个对象在比较时相等。

Sort 使用的算法依赖于使用元素的 CompareTo 方法来决定两个元素的次序，int 类型实现了 IComparable，但是 MyClass 没有。我们可以通过让类实现 IComparable，让 Sort 方法可以用于 MyClass 类型的对象。要实现这一接口，类或结构要①在基类列表中列出接口名称，②为接口的每一个成员提供实现。如下：

``` C#
class MyClass : IComparable //基类列表中的接口名称
{
    public int TheValue;

    public int CompareTo(object obj) //实现CompareTo方法以遵循接口文档的定义，参数类型和返回类型与接口成员一致
    {
        MyClass mc = (MyClass)obj;
        if (this.TheValue < mc.TheValue) return -1;
        if (this.TheValue > mc.TheValue) return 1;
        return 0;
    }
}
```

下图，展示了更新后的类，从有阴影的接口方法指向类方法的箭头表示接口方法不包含代码，而是在类级别的方法实现：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/04/jeamyQVskX6HzAR.png" width = "60%" height = "60%" alt="图71 - 在MyClass中实现IComparable"/>
</div>

既然 MyClass 实现了 IComparable 接口，就可以使用 Sort 了，如下：

``` C#
class MyClass : IComparable //类实现接口
{
    public int TheValue;
    public int CompareTo(object obj) //实现方法
    {
        MyClass mc = (MyClass)obj;
        if (this.TheValue < mc.TheValue) return -1;
        if (this.TheValue > mc.TheValue) return 1;
        return 0;
    }
}

class Program {
    static void PrintOut(string s, MyClass[] mc)
    {
        Console.Write(s);
        foreach (var m in mc)
            Console.Write($"{ m.TheValue } ");
        Console.WriteLine("");
    }

    static void Main()
    {
        var myInt = new [] { 20, 4, 16, 9, 2 };

        MyClass[] mcArr = new MyClass[5]; //创建MyClass对象的数组
        for (int i = 0; i < 5; i++) //初始化数组
        {
            mcArr[i] = new MyClass();
            mcArr[i].TheValue = myInt[i];
        }

        PrintOut("Initial Order: ", mcArr);
        Array.Sort(mcArr);
        PrintOut("Sorted Order: ", mcArr);
    }
}
```

运行结果如下：

``` console
Initial Order: 20 4 16 9 2 
Sorted Order: 2 4 9 16 20 
```

## 声明接口
声明接口的重要事项：  
①接口声明不能包括数据成员和静态成员；  
②接口声明只能包含方法、属性、事件和索引器这几个非静态成员函数；  
③上述函数成员的声明不能包含任何实现代码，必须使用分号代替主体；  
④按照惯例，接口名称必须从大写的 I 开始，比如 ISaveable ；  
⑤与类和结构一样，接口的声明可以分隔成分部接口声明。

``` C#
interface IMyInterface1
{
    int DoStuff ( int nVar1, long lVar2 ); //分号代替了主体
    double DoOtherStuff( string s, long x );
}
```

**接口的访问性**和接口成员的访问性之间的区别：  
①接口声明可以有任何的访问修饰符：public、protected、internal 或 private；  
②然而接口成员是隐式 public 的，不允许有任何访问修饰符，包括 public。

``` C#
public interface IMyInterface2 //接口可以有访问修饰符
{
    private int Method1( int nVar1, long lVar2 ); //错误，接口成员不能有访问修饰符
}
```

## 实现接口
只有类和结构能实现接口，要实现接口，类或结构必须：  
①在基类列表中包含接口名称；  
②为每一个接口成员提供实现。

关于实现接口的其他重要事项：  
①如果类实现了接口，它必须实现接口的**所有成员**；  
②如果类派生自基类并且实现了接口，基类列表中的基类名称必须放在所有接口之前，如下（只能有一个基类，所有其他类型必须为接口）：

``` C#
class Derived : MyBaseClass, IIfc1, IEnumerable, IComparable //基类必须放在最前面
{
    ...
}
```

### 简单接口的示例

``` C#
interface IIfc1 //声明接口
{
    void PrintOut(string s); //分号代替主体
}

class MyClass : IIfc1 //声明类，实现接口
{
    public void PrintOut(string s) //实现接口成员
    {
        Console.WriteLine($"Calling through: { s }");
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass(); //创建实例
        mc.PrintOut("object"); //调用方法
    }
}
```

运行结果如下：

``` console
Calling through: object
```

## 接口是引用类型
接口是引用类型。不能直接通过类对象的成员来访问接口，可以通过把类对象引用强制转换为接口类型来获取指向接口的引用。一旦有了接口的引用，就可以使用点语法来调用接口的成员。示例如下：

``` C#
interface IIfc1
{
    void PrintOut(string s);
}

class MyClass : IIfc1
{
    public void PrintOut(string s)
    {
        Console.WriteLine($"Calling through: { s }");
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();
        mc.PrintOut("object");

        IIfc1 ifc = (IIfc1)mc; //将对象的引用转换为接口类型的引用
        ifc.PrintOut("interface"); //调用接口方法
    }
}
```

运行结果如下：

``` console
Calling through: object
Calling through: interface
```

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/3BXYFrgSocITWPf.png" width = "50%" height = "50%" alt="图72 - 类对象的引用以及接口的引用"/>
</div>

## 接口和 as 运算符
可以使用 **as 运算符**来代替使用强制转换运算符来获取对象接口的引用。as 运算符与接口配合使用更好，详见第17章。如果尝试将类对象引用强制转换为类未实现的接口的引用，强制转换操作会抛出一个异常。使用 as 运算符可以避免这个问题，若类实现了接口，表达式返回指向接口的引用，若类没有实现接口，表达式返回 null 而不是抛出异常。如下：

`ILiveBirth b = a as ILiveBirth;`  
b 是接口引用，a 是类对象引用，跟 `cast: (ILiveBirth)a` 一样。

## 实现多个接口
①类或结构可以实现任意数量的接口；  
②所有实现的接口必须列在基类列表中并以逗号分隔（若有基类，在其之后）

``` C#
interface IDataRetrieve { int GetData(); } //声明接口
interface IDataStore { void SetData( int x ); } //声明接口

class MyData: IDataRetrieve, IDataStore 
{
    int Mem1;
    public int GetData() { return Mem1; }
    public void SetData( int x ) { Mem1 = x; }
}
class Program
{
    static void Main()
    {
        MyData data = new MyData();
        data.SetData( 5 );
        Console.WriteLine($"Value = { data.GetData() }");
    }
}
```

## 实现具有重复成员的接口
如果一个类实现了多个接口，并且其中一些接口成员具有相同的签名和返回类型，那么类可以实现单个成员来满足所有包含重复成员的接口。示例如下：

``` C#
interface IIfc1 { void PrintOut(string s); }
interface IIfc2 { void PrintOut(string t); }

class MyClass : IIfc1, IIfc2
{
    public void PrintOut(string s)
    {
        Console.WriteLine($"Calling through: { s }");
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();
        mc.PrintOut("object");
    }
}
```

运行结果如下：

``` console
Calling through: object
```

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/ax513qpkCXBcyiv.png" width = "60%" height = "60%" alt="图73 - 由同一个类成员实现多个接口"/>
</div>

## 多个接口的引用
如果类实现了多个接口，可以获取每一个接口的独立引用。如下，可以以三种方式调用 PrintOut，通过类对象，通过指向 IIfc1 接口的引用，通过指向 IIfc2 接口的引用：

``` C#
interface IIfc1 { void PrintOut(string s); }
interface IIfc2 { void PrintOut(string s); }

class MyClass : IIfc1, IIfc2
{
    public void PrintOut(string s)
    {
        Console.WriteLine($"Calling through: { s }");
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();

        IIfc1 ifc1 = (IIfc1) mc; //获取IIfc1的引用
        IIfc2 ifc2 = (IIfc2) mc; //获取IIfc2的引用

        mc.PrintOut("object"); //从类对象调用

        ifc1.PrintOut("interface 1"); //从IIfc1调用
        ifc2.PrintOut("interface 2"); //从IIfc2调用
    }
}
```

## 派生成员作为实现
实现接口的类可以从它的基类继承实现代码，如下：

``` C#
interface IIfc1 { void PrintOut(string s); }

class MyBaseClass
{
    public void PrintOut(string s)
    {
        Console.WriteLine($"Calling through: { s }");
    }
}

class Derived : MyBaseClass, IIfc1 {}

class Program {
    static void Main()
    {
        Derived d = new Derived();
        d.PrintOut("object.");
    }
}
```

IIfc1 接口指向基类的 PrintOut 方法。

## 显式接口成员实现
单个类可以实现多个接口，若要让接口分开实现，可以创建**显式接口成员 explicit interface member implementations**，它使用限定接口名称来声明，由接口名称和成员名称以及中间的点构成：

``` C#
interface IIfc1 { void PrintOut(string s); } 
interface IIfc2 { void PrintOut(string t); } 

class MyClass : IIfc1, IIfc2
{
    void IIfc1.PrintOut(string s) //显式接口成员实现
    {
        Console.WriteLine($"IIfc1: { s }");
    }

    void IIfc2.PrintOut(string s) //显式接口成员实现
    {
        Console.WriteLine($"IIfc2: { s }");
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();

        IIfc1 ifc1 = (IIfc1) mc;
        ifc1.PrintOut("interface 1");

        IIfc2 ifc2 = (IIfc2) mc;
        ifc2.PrintOut("interface 2");
    }
}
```

注意：上述代码，不能使用 mc 引用来调用 PrintOut 方法，因为不存在类级别的 PrintOut 方法。当然可以添加类级别的实现。

### 访问显式接口成员实现
显式接口成员实现只能通过指向接口的引用来访问，如前例，类的其他成员也不能直接访问他们，会产生编译错误，需要强制转换当前对象的引用（用 this ）：

``` C#
class MyClass : IIfc1
{
    void IIfc1.PrintOut(string s) //显式接口实现
    {
        Console.WriteLine("IIfc1");
    }

    public void Method1()
    {
        PrintOut("..."); //编译错误
        this.PrintOut("..."); //编译错误

        ((IIfc1)this).PrintOut("..."); //转换为接口引用，并调用方法
    }
}
```

这个限制对继承产生了重要影响。由于其他类成员不能直接访问显式接口成员实现，派生类的成员也不能直接访问它们。它们必须总是通过接口的引用来访问。

## 接口可以继承接口
接口本身可以从一个或多个接口继承而来，如下：

``` C#
interface IDataRetrieve { int GetData(); }
interface IDataStore { void SetData( int x ); }

//从前两个接口继承而来
interface IDataIO: IDataRetrieve, IDataStore { }

class MyData: IDataIO
{
    int nPrivateData;
    public int GetData()
        { return nPrivateData; }
    public void SetData( int x )
        { nPrivateData = x; }
}

class Program
{
    static void Main()
    {
        MyData data = new MyData();
        data.SetData( 5 );
        Console.WriteLine("{0}", data.GetData());
    }
}
```

## 不同类实现一个接口的示例

``` C#
interface ILiveBirth { string BabyCalled(); }

class Animal { } //基类

class Cat : Animal, ILiveBirth
{
    string ILiveBirth.BabyCalled()
    { return "kitten"; }
}

class Dog : Animal, ILiveBirth
{
    string ILiveBirth.BabyCalled()
    { return "puppy"; }
}

class Bird : Animal
{
}

class Program
{
    static void Main()
    {
        Animal[] animalArray = new Animal[3];
        animalArray[0] = new Cat();
        animalArray[1] = new Bird();
        animalArray[2] = new Dog();
        foreach( Animal a in animalArray )
        {
            ILiveBirth b = a as ILiveBirth;
            if (b != null)
                Console.WriteLine($"Baby is called: { b.BabyCalled() }");
        }
    }
}
```

运行结果如下：

``` console
Baby is called: kitten
Baby is called: puppy
```


# 第十七章 转换
## 什么是转换
若要把一个变量（源）的值，赋值给另外一个变量（目标），在赋值之前，源的值必须转换为目标类型的值。转换后的值应和源值一致，但其类型为目标类型。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/24nuRkv5XPVSfoH.png" width = "70%" height = "70%" alt="图74 - 从short转换为sbyte"/>
</div>

## 隐式转换
有些类型的转换不会丢失数据和精度，比如8位的值转换为16位：  
①语言会自动做这些转换，这叫做**隐式转换**；  
②从位数更少的源类型转换为位数更多的目标类型时，多出来的位用0或1填充；  
③当从更小的无符号类型转换为更大的无符号类型时，目标类型多出来的最高位都以0进行填充，称为**零扩展 zero extension**。
④对于有符号类型的转换，额外的最高位用源表达式的符号位填充，这样可以维持被转换值的正确符号和大小，叫做**符号扩展 sign extension**，如下图：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/RYw6FQchEmBj35q.png" width = "60%" height = "60%" alt="图75 - 有符号转换中的符号扩展"/>
</div>

## 显式转换和强制转换
若将长类型转换为短类型，不是源值的所有最高位都适合目标类型，会导致**溢出 overflow** 或**数据丢失**。如下图：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/76z9FslyoKeRCAi.png" width = "60%" height = "60%" alt="图76 - 尝试把ushort转换为byte"/>
</div>

### 强制转换
对于预定义类型，C# 会自动将一个数据类型转换为另一个数据类型，前提是从源类型转换为目标类型不会发生数据丢失。即 C# 不会提供会丢失值情形的自动转换，这时候必须使用显式转换，即**强制转换表达式 cast expression** 。如果使用强制转换表达式，意味着要承担操作后引起的数据丢失的后果，如下图：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/PR4sMQimxULHn2G.png" width = "80%" height = "80%" alt="图77 - 强制把ushort转换为byte"/>
</div>

## 转换的类型
①除了标准转换，还可以为用户自定义类型定义隐式类型和显式类型；  
②还有一个预定义的转换类型，叫**装箱 boxing**，它可以将任何值类型转换为 object 类型或 System.ValueType 类型；  
③**拆箱 unboxing** 可以将一个装箱的值转换为原始类型。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/9HB1i2WA7ZLVNgx.png" width = "50%" height = "50%" alt="图78 - 转换的类型"/>
</div>

## 数字的转换
任何数字类型都可以转换为其他数字类型，一些转换是隐式的，另外一些转换必须是显式的。
### 隐式数字转换
如下图，若存在箭头，则存在从源类型到目标类型的隐式转换；若不存在，则需要使用显式转换：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/TU3OPZ8YMIkptVy.png" width = "45%" height = "45%" alt="图79 - 隐式数字转换"/>
</div>

### 溢出检测上下文
对于整数类型（包括sbyte、byte、short、ushort、int、uint、long、ulong），C# 允许选择运行时是否应该在进行类型转换时检测溢出，可以通过 **checked 运算符**和 **checked 语句**来实现。

代码片段无论是否被检测都称为**溢出检测上下文 overflow checking context** 。默认的溢出检测上下文是不检查。  
①如果我们指定一个表达式或一段代码为 checked ，CLR 会在转换产生溢出时抛出一个 OverflowException 异常；  
②如果代码不是 checked ，转换会继续而不管是否溢出。

***1、checked 和 unchecked 运算符***
checked 和 unchecked 运算符控制表达式的溢出检测上下文，表达式放置在一对圆括号内，并且不能是一个方法：`checked ( Expression )` 或 `unchecked ( Expression )`。

``` C#
ushort sh = 2000;
byte sb;

sb = unchecked ( (byte) sh ); //忽略溢出
Console.WriteLine($"sb: { sb }");

sb = checked ( (byte) sh ); //抛出 OverflowException 异常
Console.WriteLine($"sb: { sb }");
```

运行结果如下：

``` console
sb: 208
Unhandled exception. System.OverflowException: Arithmetic operation resulted in an overflow.
```

***2、checked 语句和 unchecked 语句***
checked 语句和 unchecked 语句控制的是一块代码中的所有转换，而不是单个表达式。它们可以被嵌套在任意层次，如下：

``` C#
byte sb;
ushort sh = 2000;

checked
{
    unchecked
    {
        sb = (byte) sh;
        Console.WriteLine( $"sb: { sb }" );
    }

    sb = checked((byte) sh);
    Console.WriteLine( $"sb: { sb }" );
}
```

运行结果与上面相同，只不过这里影响的是一段代码而不是一个表达式。

### 显式数字转换
***1、整数类型到整数类型***  
如果转换会丢失数据，checked ：OverflowException 异常；unchecked ：丢失的位不会发出警告。

***2、float 或 double 转到整数类型***  
当把浮点类型转换为整数类型时，值会舍掉小数点，截断为最接近的整数。如果截断后的值不在目标类型的范围内：checked ：OverflowException 异常；unchecked ：C# 将不定义它的值应该是什么。

***3、decimal 到整数类型***  
如果结果值不在目标类型的范围内，CLR 会抛出 OverflowException 异常。

***4、double 到 float***  
float 类型的值占32位，而 double 类型的值占64位。double 类型的值被舍入到最接近的 float 类型的值。①如果值太小而不能用 float 表示，那么值会被设置为正或负0；②如果值太大而不能用 float 表示，那么值会被设置为正无穷大或负无穷大。

***5、float 或 double 到 decimal***  
如果值太小而不能用 decimal 类型表示，那么值会被设置为0；如果值太大，那么 CLR 会抛出 OverflowException 异常。

***6、decimal 到 float 或 double***  
从 decimal 类型转换到浮点数类型总会成功，然而可能会损失精度，即截断值到最接近的 float 或 double 值。

## 引用转换
引用转换接受源引用并返回一个指向堆中同一位置的引用，只是把引用“标记”为其他类型。

``` C#
class A { public int Field1; }

class B: A { public int Field2; }

class Program
{
    static void Main( )
    {
        B myVar1 = new B();
        A myVar2 = (A) myVar1; //返回指向myVar1的引用作为A类的引用

        Console.WriteLine($"{ myVar2.Field1 }"); //正确
        Console.WriteLine($"{ myVar2.Field2 }"); //编译错误，Field2对myVar2不可见
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2023/02/08/doaBWsuXMOmgbS3.png" width = "70%" height = "70%" alt="图80 - 引用转换返回与对象关联的不同类型"/>
</div>

对于 myVar2 ，它实际上指向 B 类型的对象，但它看不到 B 扩展 A 部分，因此看不到 Field2 。

### 隐式引用转换
①所有引用类型可以被隐式转换为 object 类型；  
②任何接口可以隐式转换为它继承的接口；  
③类可以隐式转换为它继承链中任何的类以及它实现的任何接口。
④委托可以隐式转换成如下图所示的 .NET BCL 类和接口：
⑤ Array 数组，比如下图的 ArrayS 数组（S for source，其中元素为 Ts 类型），可以隐式转换为如下图所示的 .NET BCL 类和接口，或者另一个数组，比如下图的 ArrayT 数组（T for target，其中元素为 Tt 类型）， ArrayT 数组必须满足：两个数组维度一样；Ts 和 Tt 都是引用类型；Ts 和 Tt 之间存在隐式转换。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/08/CZ1hvJaREHfVLxq.png" width = "70%" height = "70%" alt="图81 - 委托和数组的隐式转换"/>
</div>

### 显式引用转换
上面所述隐式转换的相反转换，需要显式引用转换，比如从 object 到任何引用类型的转换或从基类到派生自它的类的转换。

但是如果转换的类型没有限制，可能会导致尝试去引用内存中实际不存在的类成员，虽然编译器允许这样的转换，但如果运行时遇到它们，会抛出异常，如下：

``` C#
class A { public int Field1; }

class B: A { public int Field2; }

class Program
{
    static void Main( )
    {
        A myVar1 = new A();
        B myVar2 = (B) myVar1; //在运行时抛出InvalidCastException异常
    }
}
```

①若 myVar2 尝试访问 Field2，它会尝试访问对象中“ B 部分”（不在内存中），这会导致内存错误；
②运行时会捕获这种错误的强制转换并抛出 InvalidCastException 异常，它不会导致编译错误。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/08/o2MAUtmqbWfQEVK.png" width = "40%" height = "40%" alt="图82 - 无效的转换抛出运行时异常"/>
</div>

### 有效显式引用转换
在运行时能够成功进行的显式转换有以下3种情况：

第一种情况：显式转换没有必要，即可以隐式转换的情况，如下：

``` C#
class A { public int Field1; }
class B: A { public int Field2; }
...
B myVar1 = new B();
A myVar2 = (A) myVar1; //不必转换，因为A是B的基类
```

第二种情况：源引用是 null 。即使转换基类的引用到派生类的引用通常是不安全的，但是由于源引用是 null ，这种转换是允许的，如下：

``` C#
class A { public int Field1; }
class B: A { public int Field2; }
...
A myVar1 = null;
B myVar2 = (B) myVar1; //允许转换，因为myVar1为空
```

第三种情况：源引用指向的实际数据安全地进行隐式转换后，可以转回原类型：

``` C#
class A { public int Field1; }
class B: A { public int Field2; }
...
B myVar1 = new B();
A myVar2 = myVar1; //将myVar1隐式转换为A类型
B myVar3 = (B) myVar2; //该转换是允许的，因为数据是B类型的
```

①第二行隐式转换，看似使 myVar2 指向 A 类型的数据，实际上指向的是 B 类型的数据；  
②第三行中的显式转换把基类引用强制转换为它的派生类的引用，这通常会产生异常，但这里由于指向的对象实际就是 B 类型的数据项，所以允许转换。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/08/PWS8RLs9tgQHX4K.png" width = "70%" height = "70%" alt="图83 - 强制转换到安全类型"/>
</div>

## 装箱变换 Boxing Conversions
所有 C# 类型都派生自 object 类型，包括值类型，虽然 object 本身是引用类型。值类型在默认情况下在堆上不包括它们的对象组件，可以使用**装箱 boxing**（一种隐式转换），接受值类型，根据这个值在堆上创建一个完整的引用类型对象并返回对象引用，如下：

``` C#
int i = 12;
object oi = null;
oi = i;
```

系统将 i 的值装箱如下：  
①在堆上创建了 int 类型的对象；  
②将 i 的值复制到 int 对象；  
③返回 int 对象的引用，让 oi 作为引用保存。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/10/tIpGFHRgKxdLfVZ.png" width = "30%" height = "30%" alt="图84 - 装箱从值类型创建了完整的引用类型"/>
</div>

### 装箱是创建副本
装箱后返回的是值的引用类型副本。原始值类型和引用类型副本都可以独立操作，如下：

``` C#
int i = 10;
object oi = i;
Console.WriteLine($"i: { i }, io: { oi }");

i = 12;
oi = 15;
Console.WriteLine($"i: { i}, io: {oi }");
```

运行结果如下：

``` console
i: 10, io: 10
i: 12, io: 15
```

### 装箱转换
任何值类型 ValueTypeS 都可以被隐式转换为 object、System.ValueType 或 InterfaceT 类型（如果 ValueTypeS 实现了 InterfaceT ）。

## 拆箱转换 Unboxing Conversions
**拆箱 unboxing** 是把装箱后的对象转换回值类型的过程：  
①拆箱是显式转换；  
②系统在把值拆箱成 ValueTypeT 时执行了如下的步骤：  
&ensp;&ensp;&ensp;&ensp;- 它检测到要拆箱的对象实际是 ValueTypeT 的装箱值；  
&ensp;&ensp;&ensp;&ensp;- 它把对象的值复制到变量。  

``` C#
static void Main()
{
    int i = 10;
    object oi = i; //对i装箱并把引用赋值给oi
    int j = (int) oi; //对oi拆箱并把值赋值给j
    Console.WriteLine($"i: { i }, oi: { oi }, j: { j }");
}
```

运行结果如下：

``` console
i: 10, oi: 10, j: 10
```

尝试将一个值拆箱为非原始类型时，会抛出 InvalidCastException 异常。

## 用户自定义转换
除了标准转换外，可以为类或结构定义隐式和显式转换。

用户自定义转换的语法如下：  
①除了 **implicit** 或 **explicit 关键字**外，隐式转换和显式转换的声明语法是一样的；  
②需要 **public** 和 **static 修饰符**。

``` C#
public static implicit operator TargetType ( SourceType Identifier )
{
    ...
    return ObjectOfTargetType;
}
```

### 用户自定义转换的约束
①只可以为类或结构定义用户自定义转换；  
②不能重定义标准隐式或显式转换；  
③对于源类型 S 和目标类型 T：S 和 T 必须是不同类型。S 和 T 不能通过继承关联，即 S 不能派生自 T，而 T 也不能派生自 S 。S 和 T 都不能是接口类型或者 object 类型。转换运算符必须是 S 或 T 的成员；  
④不能同时对同一源和目标类型声明两种转换，即不能同时声明隐式和显式转换。

### 用户自定义转换的示例

``` C#
class Person
{
    public string Name;
    public int Age;
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    public static implicit operator int(Person p) //将Person转换为int
    {
        return p.Age;
    }

    public static implicit operator Person(int i) //将int转换为Person
    {
        return new Person("Nemo", i);
    }
}

class Program
{
    static void Main()
    {
        Person bill = new Person( "bill", 25);

        int age = bill; //把Person对象转换为int
        Console.WriteLine($"Person Info: { bill.Name }, { age }");

        Person anon = 35; //把int转换为Person对象
        Console.WriteLine($"Person Info: { anon.Name }, { anon.Age }");
    }
}
```

运行结果如下：

``` console
Person Info: bill, 25
Person Info: Nemo, 35
```

如果使用 explicit 运算符来定义相同转换，需要使用强制转换表达式来进行转换：

``` C#
    ...
public static explicit operator int( Person p )
{
    return p.Age;
}
...

static void Main( )
{
    ...
    int age = (int) bill;
    ...
}
```

### 多步用户自定义转换
上面讨论的用户自定义转换都是单步内直接把源类型转换为目标类型对象。但是，用户自定义转换在完整转换中最多可以有3个步骤：①预备标准转换；②用户自定义转换；③后续标准转换。这个链不可能有一个以上的用户自定义转换。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/10/WF45ydOzgBiUC1s.png" width = "70%" height = "70%" alt="图85 - 多步用户自定义转换"/>
</div>

### 多步用户自定义转换的示例

``` C#
class Employee : Person { }

class Person
{
    public string Name;
    public int Age;

    //将Person对象转换为int
    public static implicit operator int(Person p)
    {
        return p.Age;
    }
}

class Program
{
    static void Main( )
    {
        Employee bill = new Employee();
        bill.Name = "William";
        bill.Age = 25;

        float fVar = bill; //把Employee转换为float

        Console.WriteLine($"Person Info: { bill.Name }, { fVar }");
    }
}
```

运行结果如下：

``` console
Person Info: William, 25
```

<div  align="center">  
<img src="https://s2.loli.net/2023/02/10/9CGMNEyoaBWYen7.png" width = "70%" height = "70%" alt="图86 - 从Employee转换为float"/>
</div>

①上述代码声明了一个从 Person 类到 int 的用户自定义转换。由于从 Employee 到 Person 以及从 int 到 float 有标准转换，所以可以直接从 Employee 转换到 float ：  
&ensp;&ensp;&ensp;&ensp;- 由于 Employee 继承自 Person，从Employee 到 Person 有标准转换；  
&ensp;&ensp;&ensp;&ensp;- 从 int 到 float 有隐式数字转换，也是标准转换。
②由于链中的3个部分都存在，所以可以从 Employee 转换到 float 。

## is 运算符
可以使用 **is 运算符**来检查转换是否会成功完成。is 运算符的语法如下，其中 Expr 是源表达式：`Expr is TargetType`，该表达式返回 bool 类型。

如果 Expr 可以通过以下方式成功转换为目标类型，则运算符返回 true ：①引用转换；②装箱转换；③拆箱转换。

``` C#
class Employee : Person { }
class Person
{
    public string Name = "Anonymous";
    public int Age = 25;
}

class Program
{
    static void Main()
    {
        Employee bill = new Employee();

        //检测变量bill是否能转换为Person类型
        if( bill is Person )
        {
            Person p = bill;
            Console.WriteLine($"Person Info: { p.Name }, { p.Age }");
        }
    }
}
```

is 运算符只可以用于引用转换以及装箱和拆箱转换，不能用于用户自定义转换。

## as 运算符
**as 运算符**和强制转换运算符类似，只是不抛出异常，如果转换失败，它返回 null 。as 运算符的语法如下，其中 Expr 是源表达式，TargetType 是目标类型，它必须是引用类型：`Expr as TargetType`。

由于 as 运算符返回引用表达式，它可以用作赋值操作中的源，如下：

``` C#
class Employee : Person { }

class Person
{
    public string Name = "Anonymous";
    public int Age = 25;
}

class Program
{
    Employee bill = new Employee();
    Person p;

    p = bill as Person;
    if( p != null )
    {
        Console.WriteLine($"Person Info: { p.Name }, { p.Age }");
    }
}
```

as 运算符只可以用于引用转换以及装箱转换，不能用于用户自定义转换或到值类型的转换。


# 第十八章 泛型
## 什么是泛型
到现在为止，所有在类声明中用到的类型都是特定的类型，要么是程序员定义的，要么是语言或 BCL 定义的。然而，很多时候，我们需要把类的行为提取或重构出来，使之不仅能用到它们编码的数据类型上，还能应用到其他类型上。**泛型 generics**可以做到这一点，我们可以重构代码并额外增加一个抽象层，数据类型就不用硬编码了。这是专门为多段代码在不同的数据类型上执行相同指令的情况专门设计的。

### 一个栈的示例
如下，声明了 MyIntStack 的类，实现了一个 int 类型的栈，允许我们把 int 压入栈中，或弹出：

``` C#
class MyIntStack //int类型的栈
{
    int StackPointer = 0;
    int[] StackArray; //int类型的数组

    public void Push( int x ) { ... } //输入类型：int
    public int Pop() { ... } //返回类型：int
}
```

但是如果希望相同的功能应用于 float 类型的值，其中一种方式是剪切并粘贴 MyIntStack 类的代码，把类名改为 MyFloatStack ，把整个类声明中相应的 int 声明改为 float 声明。

这个方法可行，但是有很多缺点：需要仔细检查类的每一个部分来看哪些类型的声明需要修改，哪些需要保留；每次需要新类型的栈类时，需要重复这个过程，这就意味着具有很多相同代码的副本，占据了额外空间；并且很难调试和维护，修复问题需要一个个修改，很麻烦。

## C# 中的泛型
**泛型 generics**可以让多个类型共享一组代码。泛型允许声明**类型参数化 type-parameterized** 的代码，用不同类型进行实例化。即可以使用**类型占位符 placeholders for types** 来写代码，然后在创建类的实例时指明真实的类型。

***类型不是对象，而是对象或者实例的模板；而泛型类型不是类型，而是类型的模板。***

C# 提供了5种泛型：类、结构、接口、委托和方法。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/11/k1o2XvBEa9MnHPs.png" width = "50%" height = "50%" alt="图87 - 泛型和用户定义类型"/>
</div>

### 继续栈的示例
通过以下步骤可以从 MyIntStack 创建一个泛型类，T 为标识符：  
①使用类型占位符 T 而不是 int 或 float 等；  
②修改类名称为 Mystack ；  
③在类名后放置 `<T>`。

``` C#
class MyStack<T>
{
    int StackPointer = 0;
    T [] StackArray;

    public void Push(T x ) {...}
    public T Pop() {...}
}
```

## 泛型类
创建和使用非泛型的类有2个步骤：声明类和创建类的实例。但是泛型类是类的模板，所以要先从泛型类构建实际的类类型，然后创建这个类类型的引用和实例。步骤如下：  
①使用占位符声明泛型类型；  
②为占位符提供真实类型，通过提供真实类型创建**构造类型 constructed type** ;  
③创建构造类型的实例。

### 声明泛型类
声明一个泛型类和声明普通类差不多，区别如下：  
①在类名后放置一组尖括号，在尖括号中用逗号分隔的占位符字符串表示需要提供的类型，叫做**类型参数 type parameters** 。  
②在泛型类声明的主体中使用参数类型来表示替代的类型。

``` C#
class SomeClass < T1, T2 >
{
    public T1 SomeVar;
    public T2 OtherVar;
}
```

### 创建构造类型
一旦声明了泛型类型，我们需要告诉编译器能使用哪些真实类型来替代占位符（类型参数）。编译器获取真实类型并创建构建类型（用来创建真实类对象的模板）。

创建构建类型语法：`SomeClass< short, int >`，替代类型参数的真实类型叫做**类型实参 type argument** 。编译器接受了类型实参并且替代泛型类主体中的相应类型参数，产生了构造类型，然后通过构造类型创建真实类型的实例。

### 创建变量和实例
在创建引用和实例方面，构造类类型和常规类型差不多，如下：  
①第一行显示了普通非泛型类型对象的创建；  
②第二行显示了泛型类型的创建；
③第三行用 var 关键字让编译器使用类型引用。

``` C#
MyNonGenClass         myNGC = new MyNonGenClass        ();
SomeClass<short, int> mySc1 = new SomeClass<short, int>();
var                   mySc2 = new SomeClass<short, int>();
```

和非泛型类一样，引用和实例可以分开创建，如下：
①泛型类声明下面的第一行在栈上为 myInst 分配了一个引用，值为 null ；  
②第二行在堆上分配实例，并且把引用赋值给变量。

``` C#
class SomeClass < T1, T2 > //泛型类声明
{
    public T1 SomeVar;
    public T2 OtherVar;
}

SomeClass<short, int> myInst; //分配类变量
myInst = new SomeClass<short, int>(); //分配实例
```

可以从同一个泛型类构建出很多不同的类类型，每一个都是独立的类类型。

### 使用泛型的栈的示例

``` C#
class MyStack<T>
{
    T[] StackArray;
    int StackPointer = 0;

    public void Push(T x)
    {
        if ( !IsStackFull )
            StackArray[StackPointer++] = x;
    }

    public T Pop()
    {
        return ( !IsStackEmpty )
            ? StackArray[--StackPointer]
            : StackArray[0];
    }

    const int MaxStack = 10;
    bool IsStackFull { get{ return StackPointer >= MaxStack; } }
    bool IsStackEmpty { get{ return StackPointer <= 0; } }

    public MyStack()
    {
        StackArray = new T[MaxStack];
    }

    public void Print()
    {
        for (int i = StackPointer-1; i >= 0 ; i--)
            Console.WriteLine($" Value: { StackArray[i] }");
    }
}

class Program
{
    static void Main( )
    {
        MyStack<int> StackInt = new MyStack<int>();
        MyStack<string> StackString = new MyStack<string>();

        StackInt.Push(3);
        StackInt.Push(5);
        StackInt.Push(7);
        StackInt.Push(9);
        StackInt.Print();

        StackString.Push("This is fun");
        StackString.Push("Hi there! ");
        StackString.Print();
    }
}
```

运行结果如下：

``` console
 Value: 9
 Value: 7
 Value: 5
 Value: 3
 Value: Hi there!
 Value: This is fun
```

## 类型参数的约束
上述泛型栈的示例，没有做其他需要用到项本身的运算符的事情，因为泛型栈不知道它们保存的项的类型是什么，也就不知道这些项实现的成员。然而，由于 C# 对象都是从 object 继承，所以这些保存的项实现了 object 类的成员，包括 ToString、Equals 以及 GetType 方法，除此之外，它不知道还有哪些成员可用。

只要代码不访问它处理的一些类型的对象，泛型类就可以处理任意类型。符合这种约束的类型参数称为**未绑定的类型参数 unbounded type parameters** 。但是如果代码尝试访问其他成员，编译器会产生一个错误消息，示例如下：

``` C#
class Simple<T>
{
    static public bool LessThan(T i1, T i2)
    {
        return i1 < i2; //错误，因为不是所有类型都实现了小于运算符
    }
    ...
}
```

要让泛型变得更有用，需要提供额外的信息让编译器知道参数可以接受哪些类型，这种额外信息叫做**约束 constraint** 。只有符合约束的类型才能替代给定的类型参数来产生构造类型。

### where 子句
约束使用 **where 子句**列出：  
①每一个有约束的类型参数都有自己的 where 子句；  
②如果参数有多个约束，它们在 where 子句中使用逗号分隔。

语法：`where TypeParam : constraint, constraint, ...`

关于 where 子句的事项如下：  
①它们在类型参数列表的关闭尖括号之后列出；  
②不使用分隔符；  
③可以以任意次序列出；  
④ where 是上下文关键字，所以可以在其他上下文中使用。

如下泛型类有3个类型参数，T1 是未绑定的类型参数。对于 T2 ，只有 Customer 类型的类或从 Customer 派生的类才能用作类型实参。对于 T3 ，只有实现 IComparable 接口的类才能用作类型实参：

``` C#
class MyClass < T1, T2, T3 >
                where T2: Customer //T2的约束
                where T3: IComparable //T3的约束
{
    ...
}
```

### 约束类型和次序
共有5种约束类型，如下表：

| 约束类型 | 描述 |
| :---- | :---- |
| 类名 ClassName | 只有这个类型的类或从它派生的类才能用作类型实参 |
| class | 任何引用类型，包括类、数组、委托和接口都可以用作类型实参 |
| struct | 任何值类型都可以用作类型实参 |
| 接口名 InterfaceName | 只有这个接口或实现这个接口的类型才能用作类型实参，约束接口也可以是泛型的 |
| new( ) | 任何带有无参公共构造函数的类型都可以用作类型实参。这叫构造函数约束 |

where 子句可以以任意次序列出。然而，where 子句中的约束必须有特定的顺序：  
①最多只能有一个主约束，而且放在第一位；  
②可以有任意多的接口名称约束；  
③如果存在构造函数约束，则必须放在后面。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/14/hKjGeR4WStPpiqY.png" width = "50%" height = "50%" alt="图88 - 如果类型参数有多个约束，必须遵循这个顺序"/>
</div>

``` C#
class SortedList<S>
    where S: IComparable<S> { ... }

class LinkedList<M,N>
    where M : IComparable<M>
    where N : ICloneable { ... }

class MyDictionary<KeyType, ValueType>
    where KeyType : IEnumerable,
    new()               { ... }
```

## 泛型方法
与其他泛型不同，方法是成员，不是类型。**泛型方法**可以在泛型类和非泛型类以及结构和接口中声明。

### 声明泛型方法
泛型方法有两个参数列表和可选的约束，包括封闭在圆括号里的方法参数列表和封闭在尖括号的类型参数列表。要声明泛型方法，在方法名和方法参数列表中间放置类型参数列表，方法参数列表后放置可选的约束子句。

``` C#
public void PrintData<S, T> ( S p, T t ) where S: Person
{
    ...
}
```

### 调用泛型方法

``` C#
void DoStuff<T1, T2>( T1 t1, T2 t2 )
{
    T1 someVar = t1;
    T2 otherVar = t2;
    ...
}

DoStuff<short, int>( sVal, iVal ); //调用泛型方法
DoStuff<int, long>( iVal, lVal ); //调用泛型方法
```

如果我们为方法传入参数，编译器有时可以从方法参数的类型中推断出类型参数的类型。如下：

``` C#
public void MyMethod <T> (T myVal) { ... }

int myInt = 5;
MyMethod <int> (myInt); //两个都是int，类型参数的信息就多余了

//由于编译器可以从方法参数中推断出类型参数，可以省略类型参数和调用中的尖括号
MyMethod(myInt);
```

### 泛型方法的示例

``` C#
class Simple //非泛型类
{
    static public void ReverseAndPrint<T>(T[] arr) //泛型方法
    {
        Array.Reverse(arr);
        foreach (T item in arr) //使用类型参数T
            Console.Write( $"{item.ToString()}, " );
        Console.WriteLine("");
    }
}

class Program
{
    static void Main()
    {
        //创建各种类型的数组
        var intArray = new int[] { 3, 5, 7, 9, 11 };
        var stringArray = new string[] { "first", "second", "third" };
        var doubleArray = new double[] { 3.567, 7.891, 2.345 };

        Simple.ReverseAndPrint<int>(intArray);
        Simple.ReverseAndPrint(intArray);

        Simple.ReverseAndPrint<string>(stringArray);
        Simple.ReverseAndPrint(stringArray);

        Simple.ReverseAndPrint<double>(doubleArray);
        Simple.ReverseAndPrint(doubleArray);
    }
}
```

运行结果如下：

``` console
11, 9, 7, 5, 3, 
3, 5, 7, 9, 11,
third, second, first,
first, second, third,
2.345, 7.891, 3.567, 
3.567, 7.891, 2.345,
```

## 扩展方法和泛型类
第8章介绍了扩展方法，它也可以与泛型类结合使用。它允许将类中的静态方法关联到不同的泛型类上，还允许像调用类实例方法来调用方法。和非泛型类一样，泛型类的扩展方法必须声明为 static ，必须是静态类的成员，第一个参数类型中必须有关键字 this ，后面是扩展的泛型类名字。

``` C#
static class ExtendHolder
{
    public static void Print<T>(this Holder<T> h)
    {
        T[] vals = h.GetValues();
        Console.WriteLine($"{ vals[0] },\t{ vals[1] },\t{ vals[2] }");
    }
}

class Holder<T>
{
    T[] Vals = new T[3];

    public Holder(T v0, T v1, T v2)
    { Vals[0] = v0; Vals[1] = v1; Vals[2] = v2; }

    public T[] GetValues() { return Vals; }
}

class Program
{
    static void Main(string[] args) {
        var intHolder = new Holder<int>(3, 5, 7);
        var stringHolder = new Holder<string>("a1", "b2", "c3");
        intHolder.Print();
        stringHolder.Print();
    }
}
```

运行结果如下：

``` console
3,      5,      7
a1,     b2,     c3
```

## 泛型结构
泛型结构的规则与泛型类一样。

``` C#
struct PieceOfData<T> //泛型结构
{
    public PieceOfData(T value) { _data = value; }
    private T _data;
    public T Data
    {
        get { return _data; }
        set { _data = value; }
    }
}

class Program
{
    static void Main()
    {
        var intData = new PieceOfData<int>(10);
        var stringData = new PieceOfData<string>("Hi there.");

        Console.WriteLine($"intData = { intData.Data }");
        Console.WriteLine($"stringData = { stringData.Data }");
    }
}
```

运行结果如下：

``` console
intData = 10
stringData = Hi there.
```

## 泛型委托
声明泛型委托的语法：`delegate R MyDelegate<T, R>( T value );`，其中 R 为返回类型，`<T, R>`为类型参数，`( T value )`为委托形参。T 与 R 都为类型占位符。

``` C#
delegate void MyDelegate<T>(T value);  //泛型委托

class Simple
{
    static public void PrintString(string s) //方法匹配委托
    {
        Console.WriteLine( s );
    }

    static public void PrintUpperString(string s) //方法匹配委托
    {
        Console.WriteLine($"{ s.ToUpper() }");
    }
}

class Program
{
    static void Main( )
    {
        var myDel = new MyDelegate<string>(Simple.PrintString); //创建委托的实例
        myDel += Simple.PrintUpperString; //添加方法
        myDel("Hi There."); //调用委托
    }
}
```

运行结果如下：

``` console
Hi There.
HI THERE.
```

### 另一个泛型委托示例
C# 的 LINQ 特性大量使用了泛型委托，在介绍之前，有必要给出以下示例。第20章详细介绍 LINQ 。

``` C#
public delegate TR Func<T1, T2, TR>(T1 p1, T2 p2); //泛型委托

class Simple
{
    static public string PrintString(int p1, int p2) //方法匹配委托
    {
        int total = p1 + p2;
        return total.ToString();
    }
}

class Program
{
    static void Main()
    {
        var myDel = new Func<int, int, string>(Simple.PrintString); //创建委托实例

        Console.WriteLine($"Total: { myDel(15, 13) }"); //调用委托
    }
}
```

运行结果如下：

``` console
Total: 28
```

## 泛型接口
泛型接口声明需要在接口名称之后的尖括号中放置类型参数：

``` C#
interface IMyIfc<T> //泛型接口
{
    T ReturnIt(T inValue);
}

class Simple<S> : IMyIfc<S> //泛型类
{
    public S ReturnIt(S inValue) //实现泛型接口
    { return inValue; }
}

class Program
{
    static void Main()
    {
        var trivInt = new Simple<int>();
        var trivString = new Simple<string>();

        Console.WriteLine($"{ trivInt.ReturnIt(5) }");
        Console.WriteLine($"{ trivString.ReturnIt("Hi there.") }");
    }
}
```

运行结果如下：

``` console
5
Hi there.
```

### 使用泛型接口的示例
以下示例展示了泛型接口的另外两个能力：  
①与其他泛型相似，用不同类型参数实例化的泛型接口的实例是不同的接口；  
②可以在非泛型类型中实现泛型接口。

``` C#
interface IMyIfc<T> //泛型接口
{
    T ReturnIt(T inValue);
}

class Simple : IMyIfc<int>, IMyIfc<string> //非泛型类，实现源于同一泛型接口的两个不同接口
{
    public int ReturnIt(int inValue) //实现int类型接口
    { return inValue; }

    public string ReturnIt(string inValue) //实现string类型接口
    { return inValue; }
}

class Program
{
    static void Main()
    {
        Simple trivial = new Simple();

        Console.WriteLine($"{ trivial.ReturnIt(5) }");
        Console.WriteLine($"{ trivial.ReturnIt("Hi there.") }");
    }
}
```

### 泛型接口的实现必须唯一
实现泛型类型接口时，必须保证类型实参的组合不会在类型中产生两个重复的接口。

如下示例，会产生编译时错误，因为 Simple 有可能会有两个相同类型的接口，这是不允许的：

``` C#
interface IMyIfc<T>
{
    T ReturnIt(T inValue);
}

class Simple<S> : IMyIfc<int>, IMyIfc<S> //错误
{
    public int ReturnIt(int inValue) //实现第一个接口
    {
        return inValue;
    }

    public S ReturnIt(S inValue) //实现第二个接口
    {
        return inValue;
    }
}
```

> 泛型接口的名字不会和非泛型冲突。例如，上面的代码可以再声明一个名为 ImyIfc 的非泛型接口。

## 协变和逆变 Covariance and Contravariance
这个主题叫做**可变性 variance**，分为**协变 covariance** 、**逆变 contravariance** 、**不变 invariance** ：  
①在 C# 中，协变和逆变能够实现数组类型、委托类型和泛型类型参数的隐式引用转换。  
②如果泛型接口或委托的泛型参数被声明为协变或逆变，该泛型接口或委托则被称为**变体**。  
③协变和逆变都是术语，前者指能够使用比原始指定的派生类型的派生程度更大（更具体的）的类型，后者指能够使用比原始指定的派生类型的派生程度更小（不太具体的）的类型。  
④想要深入了解协变、逆变、不变，详见官方 .NET 文档。

### 协变 Covariance
每一个变量都有一种类型，可以将派生类型的对象赋值给基类型的变量，这叫做**赋值兼容性 assignment compatibility** 。如下：

``` C#
class Animal
{ public int NumberOfLegs = 4; }

class Dog : Animal
{ }

class Program
{
    static void Main( )
    {
        Animal a1 = new Animal( );
        Animal a2 = new Dog( );

        Console.WriteLine($"Number of dog legs: { a2.NumberOfLegs }");
    }
}
```

运行结果如下：

``` console
Number of dog legs: 4
```

下面的例子为上面进行了扩展，但 Main 的第二行代码会产生一条编译错误，不能隐式得把右边的类型转换为左边的类型：  

``` C#
class Animal { public int Legs = 4; } //基类
class Dog : Animal { } //派生类

delegate T Factory<T>( ); //委托

class Program
{
    static Dog MakeDog( ) //匹配委托的方法
    {
        return new Dog( );
    }

    static void Main( )
    {
        Factory<Dog> dogMaker = MakeDog; //创建委托对象，并保存方法的引用
        Factory<Animal> animalMaker = dogMaker; //尝试赋值委托对象

        Console.WriteLine( animalMaker( ).Legs.ToString( ) );
    }
}
```

上述代码产生编译错误的原因是尽管 Dog 是 Animal 的派生类，但是委托 Factory&lt;Dog&gt; 没有从委托 Factory&lt;Animal&gt; 派生。这两个委托对象是同级的，都从 delegate 类型派生，又派生于 object 类型。两者之间没有派生关系，因此赋值兼容性不适用。

在上面示例的代码中，执行 animalMaker 委托是希望返回一个 Animal 对象的引用，所以如果返回 Dog 对象的引用也是可以的，因为赋值兼容性，但是委托类型不匹配，所以无法赋值。

可以启用委托之间的隐式转换，以便在具有泛型类型参数所指定的不同类型按变体的要求继承自对方时，可以将这些类型的泛型委托分配给对方。若要启用隐式转换，必须使用 in 或 out 关键字将委托中的泛型参数显式声明为协变或逆变。

如果通过增加 **out 关键字** 改变上面例子中的委托声明，代码就可以通过编译了：`delegate T Factory<out T>( );`，out 关键字指定了类型参数的协变。

### 逆变 Contravariance
逆变关键字为 **in** ，如下：

``` C#
class Animal { public int NumberOfLegs = 4; }
class Dog : Animal { }

class Program
{
    delegate void Action1<in T>( T a ); //in关键字

    static void ActOnAnimal( Animal a ) { Console.WriteLine( a.NumberOfLegs ); }

    static void Main( )
    {
        Action1<Animal> act1 = ActOnAnimal;
        Action1<Dog> dog1 = act1;
        dog1( new Dog() );
    }
}
```

虽然委托 dog1 的方法接受 Animal 类对象，但是由于 Dog 类对象（派生程度更高）是 Animal 类派生的对象（派生程度更低），所以可以接受。

可以使用 **in 关键字**将泛型类型参数声明为逆变，来启用委托之间的隐式转换。

### 接口的协变和逆变
示例如下：

``` C#
class Animal { public string Name; }
class Dog : Animal { }

interface IMyIfc<out T>
{
    T GetFirst();
}

class SimpleReturn<T>: IMyIfc<T>
{
    public T[] items = new T[2];
    public T GetFirst() { return items[0]; }
}

class Program
{
    static void DoSomething(IMyIfc<Animal> returner)
    {
        Console.WriteLine( returner.GetFirst().Name );
    }

    static void Main( )
    {
        SimpleReturn<Dog> dogReturner = new SimpleReturn<Dog>();
        dogReturner.items[0] = new Dog() { Name = "Avonlea" };

        IMyIfc<Animal> animalReturner = dogReturner;

        DoSomething(dogReturner);
    }   
}
```

运行结果如下：

``` console
Avonlea
```

### 关于可变性的其他内容
可以将具有匹配签名的方法分配给委托，还可以将返回派生程度较大的派生类型的方法分配给委托（协变），或者如果方法所接受参数的派生类型所具有的派生程度小于委托类型指定的程度（逆变），也可将其分配给委托。方法签名与委托类型之间存在隐式转换，无需 out 或 in 关键字。如下：

``` C#
class Animal { public int Legs = 4; }
class Dog : Animal { }

class Program
{
    delegate T Factory<out T>();

    static Dog MakeDog() { return new Dog(); }

    static void Main()
    {
        Factory<Animal> animalMaker1 = MakeDog; //隐式转换
        Factory<Dog> dogMaker = MakeDog;

        Factory<Animal> animalMaker2 = dogMaker; //需要out关键字
        Factory<Animal> animalMaker3 = new Factory<Dog>(MakeDog); //需要out关键字
    }
}
```

其他有关可变性的重要事项：  
①可变性只适用于引用类型，不能从值类型派生其他类型。  
②使用 in 和 out 关键字的显式变化只适用于接口和委托，不适用于类、结构和方法；  
③不包括 in 和 out 关键字的委托和接口类型参数是**不变**的，这些参数不能用于协变或逆变。


# 第十九章 枚举器和迭代器
## 枚举器和可枚举类型 Enumerators and Enumerable Types
当为数组使用 foreach 语句：

``` C#
int [] arr1 = { 10, 11, 12, 13 };

foreach (int item in arr1)  //枚举元素
    Console.WriteLine($"Item value: { item }");
```

之所以可以循环打印这些值，是因为数组可以按需提供一个叫做**枚举器 enumerator** 的对象。枚举器可以依次返回请求的数组中的元素。获取对象枚举器的方法是调用对象的 **GetEnumerator 方法**。实现 GetEnumerator 方法的类型叫做**可枚举类型 enumerable**。枚举器和可枚举类型的关系如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2023/03/04/Z5iezdoncO7XARU.png" width = "55%" height = "55%" alt="图89 - 枚举器和可枚举类型"/>
</div>

foreach 结构被设计与可枚举类型一起使用，只有给它的遍历对象是可枚举类型，比如数组，它就会执行如下行为：  
①通过调用 GetEnumerator 方法获取对象的枚举器；  
②从枚举器中请求每一项并且把它作为**迭代变量 iteration variable**，代码可以读取该变量但不可以改变。

## IEnumerator 接口
实现 **IEnumerator 接口**的枚举器包含3个函数成员：Current、MoveNext 以及 Reset。  
① Current 是返回序列中当前位置项的属性；  
&emsp;&emsp;- 它是只读属性，返回 object 类型的引用，可能返回任意类型的对象。  
② MoveNext 是把迭代器位置前进到集合中下一项的方法。它也返回布尔值，指示新的位置是有效位置还是已经超过了序列的尾部。  
&emsp;&emsp;- 如果新位置有效，方法返回 true 。无效则返回 false 。枚举器的原始位置在序列中的第一项之前，因此 MoveNext 必须在第一次使用 Current 之前调用。  
③ Reset 是把位置重置为原始状态的方法。

下图显示了3个项的集合，右边显示了枚举器。在下图中，枚举器是一个叫作 ArrEnumerator 类的实例：  

<div  align="center">  
<img src="https://s2.loli.net/2023/03/04/U5nE3NTkyDal2Xj.png" width = "70%" height = "70%" alt="图90 - 小集合的枚举器"/>
</div>

有了集合的枚举器，可以使用上述成员来模仿 foreach 循环遍历集合中的项。

``` C#
using System.Collections;

static void Main()
{
    int[] arr1 = { 10, 11, 12, 13 };

    IEnumerator ie = arr1.GetEnumerator(); //获取并存储枚举器

    while ( ie.MoveNext() ) //移到下一项
    {
        int item = (int) ie.Current; //获取当前项
        Console.WriteLine($"Item value: { item }");
    }
}
```

运行结果和内嵌的 foreach 语句一样：  

``` console
Item value: 10
Item value: 11
Item value: 12
Item value: 13
```

## IEnumerable 接口
可枚举类是指实现了 **IEnumerable 接口**的类。IEnumerable 接口只有一个成员： GetEnumerator 方法，它返回对象的枚举器。

<div  align="center">  
<img src="https://s2.loli.net/2023/03/04/TsJoLhBuP23SEY4.png" width = "50%" height = "50%" alt="图91 - GetEnumerator 方法返回类的一个枚举器对象"/>
</div>

``` C#
using System.Collections;

class MyColors: IEnumerable //实现 IEnumerable 接口
{
    string[] Colors = { "Red", "Yellow", "Blue" };

    public IEnumerator GetEnumerator() //返回 IEnumerator 类型的对象
    {
        return new ColorEnumerator(Colors); //枚举器类的实例
    }
}
```

### 使用 IEnumerable 和 IEnumerator 的示例

``` C#
using System;
using System.Collections;

class ColorEnumerator : IEnumerator
{
    string[] Colors;
    int Position = -1;

    public ColorEnumerator( string[] theColors )
    {
        Colors = new string[theColors.Length];
        for ( int i = 0; i < theColors.Length; i++ )
            Colors[i] = theColors[i];
    }

    public object Current
    {
        get
        {
            if ( Position == -1 )
                throw new InvalidOperationException();
            if ( Position >= Colors.Length )
                throw new InvalidOperationException();
        
            return Colors[Position];
        }
    }

    public bool MoveNext()
    {
        if ( Position < Colors.Length - 1 )
        {
            Position++;
            return true;
        }
        else
            return false;
    }

    public void Reset()
    {
        Position = -1;
    }
}

class Spectrum : IEnumerable
{
    string[] Colors = { "violet", "blue", "cyan", "green", "yellow", "orange", "red" };

    public IEnumerator GetEnumerator()
    {
        return new ColorEnumerator( Colors );
    }
}

class Program
{
    static void Main()
    {
        Spectrum spectrum = new Spectrum();
        foreach ( string color in spectrum )
            Console.WriteLine( color );
    }
}
```

运行结果如下：

``` console
violet
blue
cyan
green
yellow
orange
red
```

## 泛型枚举接口
上述提到的都是非泛型版本，大多数情况应该使用泛型版本 **IEnumerable&lt;T&gt;** and **IEnumerator&lt;T&gt;**。两者之间的差别如下：  
①对于非泛型接口形式：  
&emsp;&emsp;- IEnumerable 接口的 GetEnumerator 方法返回实现 IEnumerator 的枚举器类的实例；  
&emsp;&emsp;- 实现 IEnumerator 的类实现了 Current 属性，它返回了 object 类型的引用，然后必须把它转换为对象的实际类型。  
②泛型接口继承自非泛型接口。对于泛型接口形式：  
&emsp;&emsp;- IEnumerable&lt;T&gt;接口的 GetEnumerator 方法返回实现 IEnumerator&lt;T&gt; 的枚举器类的实例；  
&emsp;&emsp;- 实现 IEnumerator&lt;T&gt; 的类实现了 Current 属性，它返回实际类型的实例，而不是 object 基类的引用。  
&emsp;&emsp;- 这些是协变接口，所以他们的实际声明是 IEnumerable&lt;out T&gt; 和 IEnumerator&lt;out T&gt; 。

非泛型接口的实现不是类型安全的，它们返回 object 类型的引用，然后必须转换为实际类型。而泛型接口的枚举器是类型安全的，它返回实际类型的引用。如果要创建自己的可枚举类，应该实现这些泛型接口。

<div  align="center">  
<img src="https://s2.loli.net/2023/03/04/WljoyYb3ftNrUua.png" width = "70%" height = "70%" alt="图92 - 实现 IEnumerator<T> 接口的类的结构"/>
</div>

<div  align="center">  
<img src="https://s2.loli.net/2023/03/04/imKBweqSZFPdzNU.png" width = "60%" height = "60%" alt="图93 - 实现 IEnumerable<T> 接口的类的结构"/>
</div>

## 迭代器 Iterators
**迭代器 Iterators** 这种结构可以让编译器把手动编码的可枚举类型和枚举器替换为由迭代器生成的可枚举类型和枚举器。示例如下：  

``` C#
public IEnumerator<string> BlackAndWhite() //版本1，返回泛型枚举器，它返回的是字符串对象
{
    yield return "black";
    yield return "gray";
    yield return "white";
}

//另外一个版本，输出同样的结果：
public IEnumerator<string> BlackAndWhite() //版本2，返回泛型枚举器，它返回的是字符串对象
{
    string[] theColors = { "black", "gray", "white" };

    for (int i = 0; i < theColors.Length; i++)
        yield return theColors[i];
}
```

### 迭代器块
**迭代器块**是有一个或多个 **yield 语句**的代码块。方法、访问器和运算符都可以是迭代器块。

迭代器块与其他代码块不同。其他块包含的语句是命令式的，即先执行代码块的第一个语句，然后执行后面的语句，最后控制离开块。迭代器块不是需要在同一时间执行的一串命令式命令，而是声明性的，描述了如何枚举元素：  
① **yield return** 语句指定了序列中要返回的下一项；  
② **yield break** 语句指定了在序列中没有更多的其他项。  
编译器得到有关如何枚举项的描述后，使用它来构建包含所有需要的方法和属性实现的枚举器类。产生的类被嵌套包含在声明迭代器的类中。根据迭代器的返回类型，可以让迭代器产生枚举器或可枚举类型。

### 使用迭代器来创建枚举器

``` C#
class MyClass
{
    public IEnumerator<string> GetEnumerator()
    { return BlackAndWhite(); } //返回枚举器

    public IEnumerator<string> BlackAndWhite() //返回枚举器的迭代器
    {
        yield return "black";
        yield return "gray";
        yield return "white";
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();

        foreach (string shade in mc)
            Console.WriteLine(shade);
    }
}
```

运行结果如下：

``` console
black
gray
white
```

### 使用迭代器来创建可枚举类型

``` C#
class MyClass
{
    public IEnumerator<string> GetEnumerator()
    {
        IEnumerable<string> myEnumerable = BlackAndWhite(); //获取可枚举类型
        return myEnumerable.GetEnumerator(); //获取枚举器
    }

    public IEnumerable<string> BlackAndWhite()
    {
        yield return "black";
        yield return "gray";
        yield return "white";
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();

        foreach (string shade in mc)
            Console.Write($"{ shade } ");
        
        foreach (string shade in mc.BlackAndWhite()) //使用类枚举器方法
            Console.Write($"{ shade } ");
    }
}
```

运行结果如下：

``` console
black gray white black gray white 
```

## 常见迭代器模式
总结上述的创建迭代器来返回可枚举类型或者枚举器：  
①当实现返回枚举器的迭代器时，必须通过实现 GetEnumerator 来让类可枚举，它返回由迭代器返回的枚举器；  
②在类中实现返回可枚举类型的迭代器时，可以让类实现 GetEnumerator 来让类本身可枚举，也可以不实现 GetEnumerator 。  
&emsp;&emsp;- 如果实现 GetEnumerator ，让它调用迭代器方法以获取自动生成的实现 IEnumerable 的类示例。然后，从 IEnumerable 对象返回由 GetEnumerator 创建的枚举器；  
&emsp;&emsp;- 如果不实现 GetEnumerator ，仍然可以使用由迭代器返回的可枚举类，只需直接调用迭代器方法。

## 产生多个可枚举类型
如下示例，尽管有两个方法返回可枚举类型，但类本身不是可枚举类型，因为它没有实现 GetEnumerator ：

``` C#
using System.Collections.Generic;

class Spectrum
{
    string[] colors = { "violet", "blue", "cyan", "green", "yellow", "orange", "red" };

    public IEnumerable<string> UVtoIR() //返回一个可枚举类型
    {
        for ( int i=0; i < colors.Length; i++ )
            yield return colors[i];
    }

    public IEnumerable<string> IRtoUV() //返回一个可枚举类型
    {
        for ( int i=colors.Length - 1; i >= 0; i-- )
            yield return colors[i];
    }
}

class Program
{
    static void Main()
    {
        Spectrum spectrum = new Spectrum();

        foreach ( string color in spectrum.UVtoIR() )
            Console.Write($"{ color } " );
        Console.WriteLine();

        foreach ( string color in spectrum.IRtoUV() )
            Console.Write($"{ color } " );
        Console.WriteLine();
    }
}
```

运行结果如下：

``` console
violet blue cyan green yellow orange red 
red orange yellow green cyan blue violet
```

## 将迭代器作为属性
将迭代器实现为属性而不是方法，示例如下：

``` C#
using System.Collections.Generic;

class Spectrum {
    bool _listFromUVtoIR;

    string[] colors = { "violet", "blue", "cyan", "green", "yellow", "orange", "red" };

    public Spectrum( bool listFromUVtoIR )
    {
        _listFromUVtoIR = listFromUVtoIR;
    }

    public IEnumerator<string> GetEnumerator()
    {
        return _listFromUVtoIR
                    ? UVtoIR
                    : IRtoUV;
    }

    public IEnumerator<string> UVtoIR
    {
        get
        {
            for ( int i=0; i < colors.Length; i++ )
                yield return colors[i];
        }
    }

    public IEnumerator<string> IRtoUV
    {
        get
        {
            for ( int i=colors.Length - 1; i >= 0; i-- )
                yield return colors[i];
        }
    }
}

class Program
{
    static void Main()
    {
        Spectrum startUV = new Spectrum( true );
        Spectrum startIR = new Spectrum( false );

        foreach ( string color in startUV )
            Console.Write($"{ color } " );
        Console.WriteLine();

        foreach ( string color in startIR )
            Console.Write($"{ color } " );
        Console.WriteLine();
    }
}
```

运行结果如下：

``` console
violet blue cyan green yellow orange red 
red orange yellow green cyan blue violet
```

## 迭代器的实质
①迭代器需要 System.Collections.Generic 命名空间，需要 using 指令；  
②在编译器生成的枚举器中，不支持 Reset 方法。当它被接口需要时会实现但是会抛出 System.NotSupportedException 异常。

在后台，由编译器生成的枚举器类是包含4个状态的状态机：  
① Before，首次调用 MoveNext 之前的初始状态；  
② Runing，调用 MoveNext 之后进入这个状态。在这个状态中，枚举器检测并设置下一项的位置。在遇到 yield return、yield break 或在迭代器体结束时，退出状态；  
③ Suspended，状态机等待下次调用 MoveNext 的状态；  
④ After，没有更多项可以枚举的状态。
如果状态机在 Before 或 Suspended 状态时调用了 MoveNext 方法，就转到 Running 状态。在 Running 状态中，它检测集合的下一项并设置位置。如果有更多项，状态机会转入 Suspended 状态；如果没有更多项，它转入并保持在 After 状态。


# 第二十章 LINQ
## 什么是 LINQ
在关系型数据库中，数据被放入规范化的表里，通过 SQL 来进行访问。然后，和数据库相反，在程序中，数据被保存在差异很大的类对象或结构中。因此，使用 LINQ 可以轻松地查询对象集合。  
① LINQ 代表**语言集成查询 Language Integrated Query** ；  
② LINQ 是 .NET 框架的扩展，允许使用像 SQL 查询数据库的类似方式来查询数据集合；  
③ 使用 LINQ，可以从数据库、对象集合以及 XML 文档等查询数据。

一个简单的示例如下，该例中，被查询的数据源是 int 数组。查询的定义就是带有 from 和 select 关键字的语句。尽管查询在语句中定义，直到最后的 foreach 语句请求其结果时才会执行：  

``` C#
static void Main()
{
    int[] numbers = { 2, 12, 5, 15 };

    IEnumerable<int> lowNums = //定义并存储查询
                        from n in numbers
                        where n < 10
                        select n;
    
    foreach (var x in lowNums) //执行查询
        Console. Write($"{ x }, ");
}
```

运行结果如下：

``` console
2, 5, 
```

## LINQ 提供程序
LINQ 除了可以查询程序在内存中的对象，还可以查询 SQL 数据库、XML 文档等等。对于每一个数据源类型，一定有根据该数据源类型实现 LINQ 查询的代码模块。这些模块叫做 **LINQ 提供程序 provider** 。微软为一些常见的数据源类型提供了 LINQ 提供程序；可以使用任何支持 LINQ 的语言，比如 C# ，来查询有 LINQ 提供程序的数据源类型。

<div  align="center">  
<img src="https://s2.loli.net/2023/03/05/JyGjXQL4bot537p.png" width = "60%" height = "60%" alt="图94 - LINQ 的体系结构"/>
</div>

本章主要介绍 LINQ to object 和 XML 。

### 匿名类型
**匿名类型 anonymous type** 经常用于 LINQ 查询的结果之中。创建匿名类型的变量与对象初始化语句相同，但是没有类名和构造函数，语法如下：`new { FieldProp = InitExpr, FieldProp = InitExpr, ...}`

``` C#
static void Main( )
{
    var student = new {Name="Mary Jones", Age=19, Major="History"}; //必须使用var

    Console.WriteLine($"{ student.Name }, Age { student.Age }, Major: {student.Major}");
}
```

运行结果如下：

``` console
Mary Jones, Age 19, Major: History
```

关于匿名类型的重要事项如下：  
①匿名类型只能用于局部变量，不能用于类成员；  
②由于匿名函数没有名字，必须使用 var 关键字作为变量类型；  
③不能设置匿名类型对象的属性。编译器为匿名类型创建的属性是只读的；  
④对于每一个成员初始化语句（即 FieldProp = InitExpr ），编译器推断其类型并创建一个只读属性来访问它的值。

除了对象初始化语句的赋值形式，匿名类型的对象初始化语句还有两个形式：简单标识符和成员访问表达式。这两种形式叫做**投影初始化语句 projection initializers** 。如下，展示了3种形式，第一个成员初始化语句是赋值形式，第二个是成员访问表达式，第三个是标识符形式：

``` C#
class Other
{
    static public string Name = "Mary Jones";
}

class Program
{
    static void Main()
    {
        string Major = "History";

        var student = new { Age = 19, Other.Name, Major}; //分别为赋值、成员访问、标识符

        Console.WriteLine($"{student.Name }, Age {student.Age }, Major: {student.Major}");
    }
}
```

运行结果如下：

``` console
Mary Jones, Age 19, Major: History
```

如果编译器遇到另一个具有相同的参数名、相同的推断类型和相同顺序的匿名类型对象初始化语句，它会重用这个类型并直接创建新的实例，不会创建新的匿名类型。

## 方法语法和查询语法
使用 LINQ 查询时可以使用两种形式的语法：查询语法和方法语法。  
①**方法语法 method syntax**：使用标准的方法调用，这些方法是一组叫作标准查询运算符的方法，见后面；方法语法是**命令式的 imperative** 的，它指明了查询方法调用的顺序。  
②**查询语法 query syntax**：与 SQL 语句类似，使用查询表达式形式书写；查询语法是**声明式 declarative** 的，即查询描述的是想返回的但并没指明如何执行查询。
在一个查询中可以组合两种形式。编译器会将查询语法翻译为方法调用的形式，这两种形式在运行上没有性能差异。

微软推荐使用查询语法，因为易读清晰，但一些表达式必须用方法语法来书写。

示例如下，注意方法语法的 Where 方法的参数使用了 Lambda 表达式：

``` C#
static void Main( )
{
    int[] numbers = { 2, 5, 28, 31, 17, 16, 42 };

    var numsQuery = from n in numbers //查询语法
                    where n < 20
                    select n;
    
    var numsMethod = numbers.Where(N => N < 20); //方法语法

    int numsCount = (from n in numbers //两种形式的合并
                    where n < 20
                    select n).Count();
    
    foreach (var x in numsQuery)
        Console.Write($"{ x }, ");
    Console.WriteLine();

    foreach (var x in numsMethod)
        Console.Write($"{ x }, ");
    Console.WriteLine();

    Console.WriteLine(numsCount);
}
```

运行结果如下：

``` console
2, 5, 17, 16, 
2, 5, 17, 16,
4
```

## 查询变量
LINQ 查询返回两种类型的结果：枚举 enumeration （不是枚举类型），即满足查询参数的项列表；标量 scalar ，单一值，满足查询条件的结果的某种形式。

示例如下，第二个语句指定了一个 LINQ 查询，它可以用来枚举查询的结果；第三个语句调用 LINQ 方法，即 Count ，来返回从查询返回的项的总数：

``` C#
int[] numbers = { 2, 5, 28 };

IEnumerable<int> lowNums = from n in numbers //返回一个枚举
                            where n < 20
                            select n;

int numsCount = (from n in numbers //返回一个整数
                            where n < 20
                            select n).Count();
```

第二条和第三条语句等号左边的变量叫做**查询变量 query variable** 。虽然示例显示定义了查询变量类型，还是可以使用 var 关键字让编译器自行推断。

在执行前面的代码后，查询变量 lowNums 不会包含查询的结果，编译器会创建能够执行这个查询的代码；查询变量 numCount 包含真实的整数值。差异总结如下：  
①如果查询表达式返回枚举，则查询一直到处理枚举时才会执行；  
②如果枚举被处理多次，查询就会执行多次；  
③如果在枚举返回之后、查询执行之前数据有改动，则查询会使用新的数据；  
④如果查询表达式返回标量，查询立即执行，并且把结果保存在查询变量中。

## 查询表达式的结构
**查询表达式 Query Expressions** 由 from 子句和查询主体组成。重要事项如下：  
①子句必须按照一定顺序出现；  
② from 子句和 select...group 子句这两部分是必需的；  
③其他子句是可选的；  
④在 LINQ 查询表达式中，select 子句在表达式最后。这与 SQL 的 SELECT 语句在查询的开始处不一样；  
⑤可以有任意多的 from...let...where 子句，如下图：

<div  align="center">  
<img src="https://s2.loli.net/2023/03/07/ybF7U8GiZxmXHeR.png" width = "65%" height = "65%" alt="图95 - 查询语句的结构"/>
</div>

### from 子句
from 子句的语法：`from Type Item in Items`  
① Type 是集合中元素的类型，这是可选的，因为编译器可以从集合中判断类型；  
② Item 是迭代变量的名称，迭代变量逐个表示数据源的每一个元素；  
③ Items 是要查询的集合的名字，集合必须是可枚举的。

示例如下，这段代码没有指明迭代变量的可选类型 int ：

``` C#
int[] arr1 = {10, 11, 12, 13};

var query = from item in arr1
            where item < 13
            select item;

foreach( var item in query )
Console.Write( $"{item },");
```

运行结果如下：

``` console
10,11,12,
```

from 子句可以有任意多个可选 join 子句：`from Type Identifier in Expression JoinClause` , join 子句见下一小节。

LINQ 的 from 子句和 foreach 语句很像，但不同点如下：  
① foreach 语句命令式地指定了要从第一个到最后一个按顺序访问集合中的项；而 from 子句声明式地规定集合中的每一项都要被访问，但是没有假定顺序。  
② foreach 语句在遇到代码时就执行其主体，而 from 子句什么也不执行。from 子句创建可执行查询的后台代码对象。只有在程序的控制流遇到访问查询变量的语句时，才会执行查询。

### join 子句
LINQ 中的 join 子句和 SQL 中的 JOIN 子句很相似，不同的是不但可以在数据库的表上执行**联结 join** ，还可以在集合对象上进行这个操作。可以使用联结来结合两个或更多集合中的数据，联结操作接受两个集合，然后创建一个临时的对象集合，其中每一个对象包含两个原始集合对象中的所有字段。

联结的语法如下，它指定了第二个集合要和之前子句中的集合进行联结，注意必须使用上下文关键字 equals 来比较字段，不能用 == 运算符：`join Identifier in Collection2 on Field1 equals Field2`。

一个 join 子句的示例：

``` C#
var query = from s in students
            join c in studentsInCourses on s.StID equals c.StID
```

### 什么是联结
联结就是基于集合之间的共同字段连接集合方便查询，示例如下：

``` C#
class Program
{
    public class Student {
        public int StID;
        public string LastName;
    }

    public class CourseStudent {
        public string CourseName;
        public int StID;
    }

    static Student[] students = new Student[] {
        new Student { StID = 1, LastName = "Carson" },
        new Student { StID = 2, LastName = "Klassen" },
        new Student { StID = 3, LastName = "Fleming" },
    };

    static CourseStudent[] studentsInCourses = new CourseStudent[] {
        new CourseStudent { CourseName = "Art", StID = 1 },
        new CourseStudent { CourseName = "Art", StID = 2 },
        new CourseStudent { CourseName = "History", StID = 1 },
        new CourseStudent { CourseName = "History", StID = 3 },
        new CourseStudent { CourseName = "Physics", StID = 3 },
    };

    static void Main( )
    {
        //查找所有选择了历史课的学生的姓氏
        var query = from s in students
                    join c in studentsInCourses on s.StID equals c.StID
                    where c.CourseName == "History"
                    select s.LastName;
        
        //显示所有选择了历史课的学生的名字
        foreach (var q in query)
            Console.WriteLine($"Student taking History: { q }");
    }
}
```

运行结果如下：

``` console
Student taking History: Carson
Student taking History: Fleming
```

### 查找主体中的 from...let...where 片段
可选的 from...let...where 部分是查询主体的第一部分，可以由任意数量的3种子句构成：from 子句、let 子句和 where 子句。

**1、 from 子句**  
查询表达式从必需的 from 子句开始，后面跟着查询主体。主体本身可以从任何数量的其他 from 子句开始，每一个子句都指定了一个额外的源数据集合并引入了在之后运算的迭代变量。

示例如下，第一个 from 子句是查询表达式必需的子句，第二个 from 子句是第一个子句的查询主体，select 子句创建了一个匿名类型的对象：

``` C#
static void Main()
{
    var groupA = new[] { 3, 4, 5, 6 };
    var groupB = new[] { 6, 7, 8, 9 };

    var someInts = from a in groupA //必需的第一个 from 子句
                    from b in groupB //查询主体的第一个子句
                    where a > 4 && b <= 8
                    select new {a, b, sum = a + b}; //匿名类型对象
    
    foreach (var x in someInts)
        Console.WriteLine(x);
}
```

运行结果如下：

``` console
{ a = 5, b = 6, sum = 11 }
{ a = 5, b = 7, sum = 12 }
{ a = 5, b = 8, sum = 13 }
{ a = 6, b = 6, sum = 12 }
{ a = 6, b = 7, sum = 13 }
{ a = 6, b = 8, sum = 14 }
```

**2、let 子句**  
let 子句接受一个表达式的运算并且把它赋值给一个需要在其他运算中使用的标识符。let 子句的语法如下：`let Identifier = Expression`。示例如下：

``` C#
static void Main()
{
    var groupA = new[] { 3, 4, 5, 6 };
    var groupB = new[] { 6, 7, 8, 9 };

    var someInts = from a in groupA
                    from b in groupB
                    let sum = a + b //在新的变量中保存结果
                    where sum == 12
                    select new {a, b, sum};
    
    foreach (var a in someInts)
        Console.WriteLine(a);
}
```

运行结果如下：

``` console
{ a = 3, b = 9, sum = 12 }
{ a = 4, b = 8, sum = 12 }
{ a = 5, b = 7, sum = 12 }
{ a = 6, b = 6, sum = 12 }
```

**3、where 子句**  
where 子句根据之后的运算来去除不符合指定条件的项，语法如下：`where BooleanExpression`。只要是在 from...let...where 部分中，查询表达式可以有任意多个 where 子句，一个项必须满足所有 where 子句才能避免在之后被去除。示例如下：

``` C#
static void Main()
{
    var groupA = new[] { 3, 4, 5, 6 };
    var groupB = new[] { 6, 7, 8, 9 };

    var someInts = from int a in groupA
                    from int b in groupB
                    let sum = a + b
                    where sum >= 11 //条件1
                    where a == 4 //条件2
                    select new {a, b, sum};
    
    foreach (var a in someInts)
        Console.WriteLine(a);
}
```

运行结果如下：

``` console
{ a = 4, b = 7, sum = 11 }
{ a = 4, b = 8, sum = 12 }
{ a = 4, b = 9, sum = 13 }
```

### orderby 子句
orderby 子句接受一个表达式并根据表达式按顺序返回结果项。语法为：`orderby Expression ascending/descending ,`。其中表达式通常是项的一个字段，可以是数值字段，也可以是字符串。orderby 子句的默认排序是升序，可选的 ascending 和 descending 关键字显式地设置元素的排序为升序或降序。可以有任意的 orderby 子句，它们必须用逗号分隔。示例如下：

``` C#
static void Main( ) {
    var students = new [] //匿名类型的对象数组
    {
        new { LName="Jones", FName="Mary", Age=19, Major="History" },
        new { LName="Smith", FName="Bob", Age=20, Major="CompSci" },
        new { LName="Fleming", FName="Carol", Age=21, Major="History" }
    };

    var query = from student in students
                orderby student.Age
                select student;

    foreach (var s in query) {
        Console.WriteLine($"{ s.LName }, { s.FName }: { s.Age }, { s.Major }");
    }
}
```

运行结果如下：

``` console
Jones, Mary: 19, History
Smith, Bob: 20, CompSci
Fleming, Carol: 21, History
```

### select...group 子句
select...group 由两种类型的子句组成：select 子句和 group...by 子句。  
① select 子句指定应该选择所选对象的哪些部分，可以指定整个数据项、数据项的一个字段或者数据项中几个字段组成的新对象（见下面查询中的匿名类型）。  
② group...by 子句是可选的，用来指定选择的项如何被分组，见后面。

``` C#
class Program {
    static void Main() {
        var students = new[] //匿名类型的对象数组
        {
            new { LName="Jones", FName="Mary", Age=19, Major="History" },
            new { LName="Smith", FName="Bob", Age=20, Major="CompSci" },
            new { LName="Fleming", FName="Carol", Age=21, Major="History" }
        };

        var query1 = from s in students
                    select s; //选择整个数据项

        foreach (var q in query1)
            Console.WriteLine($"{ q.LName }, { q.FName }: { q.Age }, { q.Major }");

        var query2 = from s in students
                    select s.LName; //选择对象的某些字段
        
        foreach (var q in query2)
            Console.WriteLine(q);
    }
}
```

运行结果如下：

``` console
Jones, Mary: 19, History
Smith, Bob: 20, CompSci
Fleming, Carol: 21, History
Jones
Smith
Fleming
```

### 查询中的匿名类型
查询结果可以由原始集合的项、原始集合中项的字段或匿名类型组成。可以通过在 select 子句中把希望在类型中包括的字段以逗号分隔，并以大括号包围来创建匿名类型，语法如下：

``` C#
class Program
{
    static void Main()
    {
        var students = new[] //匿名类型的对象数组
        {
            new { LName="Jones", FName="Mary", Age=19, Major="History" },
            new { LName="Smith", FName="Bob", Age=20, Major="CompSci" },
            new { LName="Fleming", FName="Carol", Age=21, Major="History" }
        };

        var query = from s in students
                    select new { s.LName, s.FName, s.Major }; //创建匿名类型

        foreach (var q in query)
            Console.WriteLine($"{ q.FName } { q.LName } -- { q.Major}"); //匿名类型的访问字段
    }
}
```

运行结果如下：

``` console
Mary Jones -- History
Bob Smith -- CompSci
Carol Fleming -- History
```

### group 子句
group 子句根据指定的标准对选择的对象进行分组。  
①如果项包含在查询的结果中，它们就可以根据某个字段的值进行分组，作为分组依据的数据叫做**键 key** ；  
② group 子句返回的不是原始数据源中项的枚举，而是返回可以枚举的已经形成的项的分组可枚举类型；  
③分组本身是可枚举类型，它们可以枚举实际的项。

``` C#
static void Main( )
{
    var students = new[] //匿名类型的对象数组
    {
        new { LName="Jones", FName="Mary", Age=19, Major="History" },
        new { LName="Smith", FName="Bob", Age=20, Major="CompSci" },
        new { LName="Fleming", FName="Carol", Age=21, Major="History" }
    };

    var query = from student in students
                group student by student.Major;
    
    foreach (var g in query) //枚举分组
    {
        Console.WriteLine("{0}", g.Key);

        foreach (var s in g) //枚举分组中的项
            Console.WriteLine($" { s.LName }, { s.FName }");
    }
}
```

运行结果如下：

``` console
History
 Jones, Mary
 Fleming, Carol
CompSci
 Smith, Bob
```

下图演示了从查询表达式返回并保存于查询变量中的对象：  
①从查询表达式返回的对象是从查询中枚举分组结果的可枚举类型；  
②每一个分组由一个叫做键的字段区分；  
③每一个分组本身是可枚举类型并且可以枚举它的项。

<div  align="center">  
<img src="https://s2.loli.net/2023/03/11/qVzFHNBl5svUwky.png" width = "65%" height = "65%" alt="图96 - group子句返回对象集合的集合"/>
</div>

### 查询延续：into 子句
查询延续子句可以接受查询的一部分的结果并赋予一个名字，从而可以在查询的另一部分中使用，示例如下：  

``` C#
static void Main()
{
    var groupA = new[] { 3, 4, 5, 6 };
    var groupB = new[] { 4, 5, 6, 7 };

    var someInts = from a in groupA
                    join b in groupB on a equals b
                    into groupAandB //查询延续
                    from c in groupAandB
                    select c;

    foreach (var v in someInts)
        Console.Write($"{ v } ");
}
```

运行结果如下：

``` console
4 5 6
```

## 标准查询运算符
标准查询运算符由一系列 API 方法组成，可以查询任何 .NET 数组或集合。标准查询运算符的重要特性如下：  
①标准查询运算符使用方法语法；  
②一些运算符返回 IEnumerable 对象，而其他运算符返回标量。返回标量的运算符立即执行查询，并返回一个值，而不是一个可枚举类型对象。ToArray( )、ToList( )等 ToCollection 运算符也会立即执行；  
③很多操作都是以一个谓词作为参数。**谓词 predicate** 是一个方法，它以对象为参数，根据对象是否满足某个条件而返回 true 或 false 。
④被查询的集合对象叫作**序列 sequence** ，它必须实现 IEnumerable&lt;T&gt;接口。

示例如下，用作方法的运算符直接作用于序列对象，在这里就是 numbers 数组，返回类型是 int ：

``` C#
class Program
{
    static int[] numbers = new int[] {2, 4, 6};

    static void Main( )
    {
        int total = numbers.Sum();
        int howMany = numbers.Count();

        Console.WriteLine($"Total: { total }, Count: { howMany }");
    }
}
```

运行结果如下：

``` console
Total: 12, Count: 3
```

有大量标准查询运算符，可用来操作一个或多个序列。序列指实现了 IEnumerable&lt; &gt;接口的类，包括 List&lt; &gt;、Dictionary&lt; &gt;、Stack&lt; &gt;、Array 等。如下表，列出了这些运算符：

| 运算符名 | 描述 |
| :---- | :---- |
| Where | 根据给定的谓词对序列进行过滤 |
| Select | 指定要包含一个对象或对象的一部分 |
| SelectMany | 一种查询类型，返回集合的集合。该方法将这些结果合并为一个单独的集合 |
| Take | 接受一个输出参数count，返回序列中的前count个对象 |
| Skip | 接受一个输出参数count，跳过序列中的前count个对象，返回剩余对象 |
| TakeWhile | 接受一个谓词，开始迭代序列，只要谓词对当前项的计算结果为true，就选择该项。在谓词返回第一个false时，该项和其余项都被丢弃 |
| SkipWhile | 接受一个谓词，开始迭代序列，只要谓词对当前项的计算结果为true，就跳过该项。在谓词返回第一个false时，该项和其余项都被选择 |
| Join | 对两个序列执行内联结 |
| GroupJoin | 可以产生层次结果的联结，第一个序列中的各个元素都与第二个序列中的元素集合相关联 |
| Concat | 连接两个序列 |
| OrderBy/ThenBy | 根据一个或多个键对序列中的元素按升序排序 |
| Reverse | 反转序列中的元素 |
| GroupBy | 分组序列中的元素 |
| Distinct | 去除序列中的重复项 |
| Union | 返回两个序列的并集 |
| Intersect | 返回两个序列的交集 |
| Except | 操作两个序列。返回的是第一个序列中不重复的元素减去同样位于第二个序列中的元素 |
| AsEnumerable | 将序列作为IEnumerable&lt;TSource&gt;返回 |
| AsQueryable | 将IEnumerable转换为IQueryable |
| ToArray | 将序列作为数组返回 |
| ToList | 将序列作为List&lt;T&gt;返回 |
| ToDictionary | 将序列作为Dictionary&lt;TKey, TElement&gt;返回 |
| ToLookup | 将序列作为LookUp&lt;TKey, TElement&gt;返回 |
| OfType | 返回的序列中的元素是指定的类型 |
| Cast | 将序列中所有元素强制转换为给定的类型 |
| SequenceEqual | 返回一个布尔值，指定两个序列是否相等 |
| First | 返回序列中第一个与谓词匹配的元素。如果没有元素与谓词匹配，就抛出InvalidOperationException |
| FirstOrDefault | 返回序列中第一个与谓词匹配的元素。如果没有给出谓词，方法返回序列的第一个元素。如果没有元素与谓词匹配，就使用该类型的默认值 |
| Last | 返回序列中最后一个与谓词匹配的元素。如果没有元素与谓词匹配，就抛出InvalidOperationException |
| LastOrDefault | 返回序列中最后一个与谓词匹配的元素。如果没有元素与谓词匹配，就使用该类型的默认值 |
| Single | 返回序列中与谓词匹配的单个元素。如果没有元素匹配，或多于一个元素匹配，就抛出异常 |
| SingleOrDefault | 返回序列中与谓词匹配的单个元素。如果没有元素匹配，或多于一个元素匹配，就返回默认值 |
| ElementAt | 给定一个参数n，返回序列中第n+1个元素 |
| ElementAtOrDefault | 给定一个参数n，返回序列中第n+1个元素。如果索引超出范围，就返回默认值 |
| DefaultIfEmpty | 提供一个在序列为空时的默认值 |
| Range | 给定一个start整形和count整形，该方法返回的序列包含count个整形，其中第一个元素的值为start，每个后续元素都比前一个大1 |
| Repeat | 给定一个T类型的element和一个count整数，该方法返回的序列具有count个element副本 |
| Empty | 返回给定类型T的空序列 |
| Any | 返回一个布尔值，指明序列中是否存在满足谓词的元素 |
| All | 返回一个布尔值，指明序列中的全部元素是否都满足谓词 |
| Contains | 返回一个布尔值，指明序列中是否包含给定的元素 |
| Count | 返回序列中元素的个数（int）。它的重载可以接受一个谓词，并返回序列中满足谓词的元素个数 |
| Sum | 返回序列中值的总数 |
| Min | 返回序列中最小的值 |
| Max | 返回序列中最大的值 |
| Average | 返回序列中的平均值 |
| Aggregate | 连续对序列中的各个元素应用给定的函数 |

### 标准查询运算符的签名
System.Linq.Enumerable 类声明了标准查询运算符方法。然而，这些方法不仅仅是普通方法，它们是扩展了 IEnumerable&lt;T&gt;泛型类的扩展方法。第8章和第18章中介绍了扩展方法，但本节更为详细。

扩展方法是公有的静态方法，尽管定义在一个类中，但目的是为另一个类（第一个形参）增加功能，该参数前必须有关键字 this 。

有关签名的重要事项：  
①由于运算符是泛型方法，因此每个方法名都具有相关的泛型参数（T）；  
②由于运算符是扩展 IEnumerable 类的扩展方法，必须声明为 public 和 static ，在第一个参数前有 this 扩展指示器，把 IEnumerable&lt;T&gt;作为第一个参数类型。

``` C#
public static      int       Count<T>( this IEnumerable<T> source );
public static       T        First<T>( this IEnumerable<T> source );
public static IEnumerable<T> Where<T>( this IEnumerable<T> source, ... );
```

如下代码，演示了直接调用扩展方法和将其作为扩展进行调用的区别。前两次的直接调用和普通方法类似，传入数组名字作为第一个参数。方法语法调用和扩展语法调用在语义上完全相等，只是语法不同：

``` C#
using System.Linq;
    ...
static void Main( )
{
    int[] intArray = new int[] { 3, 4, 5, 6, 7, 9 };

    var count1 = Enumerable.Count(intArray); //方法语法
    var firstNum1 = Enumerable.First(intArray); //方法语法

    var count2 = intArray.Count(); //扩展语法
    var firstNum2 = intArray.First(); //扩展语法

    Console.WriteLine($"Count: { count1 }, FirstNumber: { firstNum1 }");
    Console.WriteLine($"Count: { count2 }, FirstNumber: { firstNum2 }");
}
```

运行结果如下：

``` console
Count: 6, FirstNumber: 3
Count: 6, FirstNumber: 3
```

### 查询表达式和标准查询运算符
每一个查询表达式都可以使用带有标准查询运算符的方法语法来编写。编译器把每一个查询表达式翻译成标准查询运算符的形式。由于所有查询表达式都被翻译成标准查询运算符，因此运算符可以执行由查询表达式完成的任何操作，而且运算符还有查询表达式形式所不能提供的附加功能。例如，在之前示例中使用的 Sum 和 Count 运算符，可以只用方法语法来表示。

查询表达式和方法语法这两种表达式也可以组合，示例如下：

``` C#
static void Main()
{
    var numbers = new int[] { 2, 6, 4, 8, 10 };

    int howMany = (from n in numbers
                   where n < 7
                   select n).Count();

    Console.WriteLine($"Count: { howMany }");
}
```

运行结果如下：

``` console
Count: 3
```

### 将委托作为参数
每一个运算符的第一个参数是 IEnumerable&lt;T&gt; 对象的引用，之后的参数可以是任何类型。很多运算符接受泛型委托作为参数，泛型委托用于给运算符提供用户定义的代码，解释如下：

比如 Count 运算符被重载且有两种形式。第一种形式，即之前的示例，它有一个参数，返回集合中元素的个数，签名如下：`public static int Count<T>(this IEnumerable<T> source);`

但若希望计算数组中奇数元素的总数，需为 Count 方法提供检测整数是否为奇数的代码，为此要使用 Count 方法的第二种形式，它接受一个泛型委托作为其第二个参数。调用时，必须提供一个接受单个 T 类型的输入参数并返回布尔值的委托对象，委托代码的返回值必须指定元素是否应包含在总数中：`public static int Count<T>(this IEnumerable<T> source, Func<T, bool> predicate );`

示例如下，对于集合的每次遍历，Count 调用 Lambda 表达式表示的方法并把当前值作为输入，如果输入的是奇数，方法返回 true，Count 会把这个元素包含在总数中：

``` C#
static void Main()
{
    int[] intArray = new int[] { 3, 4, 5, 6, 7, 9 };

    var countOdd = intArray.Count(n => n % 2 == 1);

    Console.WriteLine($"Count of odd numbers: { countOdd }");
}
```

运行结果如下：

``` console
Count of odd numbers: 4
```

### LINQ 预定义的委托类型
和前面的 Count 运算符类似，很多 LINQ 运算符需要提供代码来指示运算符如何执行它的操作，通过把委托对象作为参数来实现。.NET 框架定义了两套泛型委托来用于标准查询运算符，即 **Func 委托**和 **Action 委托**，各有19个成员。用作运算符实参的委托对象必须是这些形式之一。

下面列出了前4个泛型 Func 委托。TR 表示返回值，总是类型参数列表中的最后一个。&lt; &gt; 里的为类型参数，( ) 里的为方法参数：

``` C#
public delegate TR Func<out TR>                     ( );
public delegate TR Func<in T1, out TR >             ( T1 a1 );
public delegate TR Func<in T1, in T2, out TR >      ( T1 a1, T2 a2 );
public delegate TR Func<in T1, in T2, in T3, out TR>( T1 a1, T2 a2, T3 a3 );
```

注意返回类型参数有一个 out 关键字，使之可以协变。输入参数有个 in 关键字，使之可以逆变。

Count 的声明（第二种形式）里，第二个参数必须是上面说的委托对象，它接受单个 T 类型的值作为方法参数并且返回一个 bool 类型的值。如之前所说，这种形式的委托称为**谓词**。

以下是前4个 Action 委托，与 Func 委托类似，但没有返回值：  

``` C#
public delegate void Action                     ( );
public delegate void Action<in T1>              ( T1 a1 );
public delegate void Action<in T1, in T2>       ( T1 a1, T2 a2 );
public delegate void Action<in T1, in T2, in T3>( T1 a1, T2 a2, T3 a3 );
```

### 使用委托参数的示例
以下代码先声明了 IsOdd 方法，接受单个 int 类型的参数，并且返回表示输入参数是否为奇数的 bool 值，并且使用该方法来初始化名称为 MyDel 的委托对象。不需要声明 Func 委托类型，因为 .NET 框架已经预定义了：

``` C#
class Program
{
    static bool IsOdd(int x) //委托对象使用的方法
    {
        return x % 2 == 1; //如果x是奇数，返回true
    }

    static void Main()
    {
        int[] intArray = new int[] { 3, 4, 5, 6, 7, 9 };

        Func<int, bool> myDel = new Func<int, bool>(IsOdd); //委托对象
        var countOdd = intArray.Count(myDel); //使用委托

        Console.WriteLine($"Count of odd numbers: { countOdd }");
    }
}
```

运行结果如下：

``` console
Count of odd numbers: 4
```

### 使用 Lambda 表达式参数的示例
之前的示例使用独立的方法和委托来把代码附加到运算符上，这需要声明方法和委托对象，然后把委托对象传递给运算符。也可以使用 Lambda 表达式来给运算符提供代码，使用 Lambda 表达式修改之前的示例如下：

``` C#
class Program
{
    static void Main()
    {
        int[] intArray = new int[] { 3, 4, 5, 6, 7, 9 };

        var countOdd = intArray.Count( x => x % 2 == 1 );

        Console.WriteLine($"Count of odd numbers: { countOdd }");
    }
}
```

运行结果如下：

``` console
Count of odd numbers: 4
```

也可以使用匿名方法，见第14章委托，来代替 Lambda 表达式，但是不如 Lambda 表达式简洁：

``` C#
class Program
{
    static void Main( )
    {
        int[] intArray = new int[] { 3, 4, 5, 6, 7, 9 };

        Func<int, bool> myDel = delegate(int x)
                                {
                                    return x % 2 == 1;
                                };

        var countOdd = intArray.Count(myDel);

        Console.WriteLine($"Count of odd numbers: { countOdd }");
    }
}
```

## LINQ to XML
**可扩展标记语言 Extensible Markup Language ( XML )** 是存储和交换数据的重要方法。LINQ 为该语言增加了一些特性，简化了 XML 的创建、查询和操作：  
①可以使用单一语句自顶而下创建 XML 树；  
②可以在不使用包含树的 XML 文档在内存中创建并操作 XML ；  
③可以不使用 Text 子节点来创建和操作字符串节点；  
④搜索 XML 树时，不需要遍历它。只需要查询树并让它返回想要的结果。

### 标记语言
**标记语言 markup language** 是文档中的一组标签，它提供有关文档的信息并组织其内容。即标记语言不是文档的数据，它们包含关于数据的数据(元数据)。标记语言是定义的一组标签，旨在传递有关文档内容的特定类型的元数据，比如 HTML 的标签中的元数据包含了 Web 页面如何在浏览器中呈现以及如何使用超链接在页面中导航的信息。

大部分标记语言包含一组预定义的标签，而 XML 只包含少量预定义的标签，其他由程序员定义，用来表示特定文档类型需要的任何元数据。

### XML 基础
XML 文档中的数据包含在一个 XML 数中，XML 树主要由嵌套元素组成。**元素**是 XML 树的基本要素。每个元素都有名字且包含数据，一些元素还包含其他被嵌套元素。元素由开始和关闭标签进行划分。任何元素包含的数据都必须介于开始和关闭标签之间：  
①开始标签：`<PhoneNumber>`；  
②关闭标签：`</PhoneNumber>`；  
③没有内容的元素可以直接由单个标签表示：`<PhoneNumber />`

有关 XML 的重要事项：  
① XML 文档必须有一个根元素来包含所有其他元素；  
② XML 标签必须合理嵌套；  
③与 HTML 标签不同，XML 标签是区分大小写的；  
④ XML 特性是名字/值的配对，它包含了元素的额外元数据。特性的值部分必须包含在引号内，单引号双引号皆可；  
⑤ XML 文档中的空格是有效的。这与把空格作为单个空格输出的 HTML 不同。

如下示例，包含了一个 Employees 类型的根节点，它包含了两个 Employee 类型的子节点：

``` XML
<Employees>
    <Employee>
        <Name>Bob Smith</Name>
        <PhoneNumber>408-555-1000</PhoneNumber>
        <CellPhone />
    </Employee>
    <Employee>
        <Name>Sally Jones</Name>
        <PhoneNumber>415-555-2000</PhoneNumber>
        <PhoneNumber>415-555-2001</PhoneNumber>
    </Employee>
</Employees>
```

<div  align="center">  
<img src="https://s2.loli.net/2023/03/18/PHKWjBJ2Qukweh8.png" width = "65%" height = "65%" alt="图97 - 示例的 XML 树的层次结构"/>
</div>

### XML 类
LINQ to XML 可以用两种方式用于 XML 。第一种是简化的 XML API 操作(LINQ to XML API)，第二种为之前的 LINQ 查询工具。

LINQ to XML API 由很多表示 XML 树组件的类组成。我们会使用 3 个最重要的类包括 XElement、XAttribute 和 XDocument。

下图演示了用于构造 XML 树的类以及它们如何被嵌套：  

<div  align="center">  
<img src="https://s2.loli.net/2023/03/18/NTrSxoJGkaPtO4U.png" width = "75%" height = "75%" alt="图98 - XML 节点的容器结构"/>
</div>

① XDocument 节点中 XDeclaration 节点、XDocumentType 节点以及 XElement 节点的每一个节点类型最多有一个，XProcessingInstruction 节点可以为任意数量；  
②如果在 XDocument 下有最高级别的 XElement 节点，那么它就是 XML 树中其他元素的根；  
③根元素可以包含任意数量的嵌套 XElement、XComment 或 XProcessingInstruction 节点，并且可以在任何级别上嵌套。

除了 XAttribute 类，大多数用于创建 XML 树的类都从一个叫做 XNode 的类继承，或叫做 XNodes 。上图中，白色背景的为 XNode 类，灰色背景的为 XAttribute 类。

***1. 创建、保存、加载和显示 XML 文档***  
示例如下，创建了一个简单的包含一个 Employees 节点的 XML 树：  
①树使用一条语句来创建，并同时在适当的位置创建所有的嵌套元素，叫做**函数式构造 functional construction** ；  
②每一个元素由对象创建表达式在适当的位置创建，使用了节点类型的构造函数。

``` C#
using System;
using System.Xml.Linq; //需要的命名空间

class Program {
    static void Main( ) {
        XDocument employees1 =
            new XDocument( //创建 XML 文档
                new XElement("Employees", //创建根元素
                    new XElement("Name", "Bob Smith"), //创建元素
                    new XElement("Name", "Sally Jones") //创建元素
                )
            );

        employees1.Save("EmployeesFile.xml"); //保存到文件

        //将保存的文档加载到新变量中
        XDocument employees2 = XDocument.Load("EmployeesFile.xml"); //静态方法

        Console.WriteLine(employees2); //显示文档
    }
}
```

运行结果如下：

``` console
<Employees>
  <Name>Bob Smith</Name>
  <Name>Sally Jones</Name>
</Employees>
```

***2. 创建 XML 树***  
对于 XDocument 和 XElement 的构造函数：  
①第一个参数都是对象名；  
②第二个参数以及之后的参数包含了 XML 树的节点。构造函数的第二个参数是一个 params 参数，即任意多的参数。

``` C#
using System;
using System.Xml.Linq; //此命名空间是必需的

class Program {
    static void Main( ) {
        XDocument employeeDoc =
            new XDocument( //创建文档
                new XElement("Employees", //创建根元素
                    new XElement("Employee", //第一个employee元素
                        new XElement("Name", "Bob Smith"),
                        new XElement("PhoneNumber", "408-555-1000") ),

                    new XElement("Employee", //第二个employee元素
                        new XElement("Name", "Sally Jones"),
                        new XElement("PhoneNumber", "415-555-2000"),
                        new XElement("PhoneNumber", "415-555-2001") )
                )
            );
        Console.WriteLine(employeeDoc); //显示文档
    }
}
```

运行结果如下：

``` console
<Employees>
  <Employee>
    <Name>Bob Smith</Name>
    <PhoneNumber>408-555-1000</PhoneNumber>
  </Employee>
  <Employee>
    <Name>Sally Jones</Name>
    <PhoneNumber>415-555-2000</PhoneNumber>
    <PhoneNumber>415-555-2001</PhoneNumber>
  </Employee>
</Employees>
```

***3. 使用 XML 树的值***
可以遍历 XML 树来获取或修改值，下表列出了用于获取数据的主要方法：

| 方法名称 | 类 | 返回类型 | 描述 |
| :---- | :---- | :---- | :---- |
| Nodes | XDocument、XElement | IEnumerable&lt;object&gt; | 返回当前节点的所有子节点 |
| Elements | XDocument、XElement | IEnumerable&lt;XElement&gt; | 返回当前节点的 XElement 子节点，或所有具有某个名字的子节点 |
| Element | XDocument、XElement | XElement | 返回当前节点的第一个 XElement 子节点，或具有某个名字的子节点 |
| Descendants | XElement | IEnumerable&lt;XElement&gt; | 返回所有的 XElement 子代节点，或所有具有某名字的 XElement 子代节点，不管它们处于当前节点下什么嵌套级别 |
| DescendantsAndSelf | XElement | IEnumerable&lt;XElement&gt; | 和 Descendents 一样，但是包括当前节点 |
| Ancestors | XElement | IEnumerable&lt;XElement&gt; | 返回所有上级 XElement 节点，或者所有具有某个名字的上级 XElement 节点 |
| AncestorsAndSelf | XElement | IEnumerable&lt;XElement&gt; | 和 Ancestors 一样，但是包含当前节点 |
| Parent | XElement | XElement | 返回当前节点的父节点 |

① Nodes：Nodes 方法返回 IEnumerable&lt;object&gt; 类型的对象，因为返回的节点可能是不同的类型，比如 XElement、XComment 等。我们可以使用以类型作为参数的方法 OfType(type) 来指定返回某类型的节点。例如，如下代码只能获取 XComment 节点：`IEnumerable<XComment> comments = xd.Nodes().OfType<XComment>();`  
② Elements：由于获取 XElements 是非常普遍的需求，就出现了 Nodes.OfType(XElement)() 表达式的简短形式，即 Elements 方法：  
&emsp;&emsp;- 无参数的 Elements 方法返回所有子 XElements；  
&emsp;&emsp;- 单个 name 参数的 Elements 方法只返回具有这个名字的子 XElements 。例如，如下代码返回具有名字 PhoneNumber 的子 XElement 节点：`IEnumerable<XElement> empPhones = emp.Elements("PhoneNumber");`  
③ Element：这个方法只获取当前节点的第一个子 XElement 。如果无参数，获取第一个子 XElement 节点，如果带一个名字参数，获取第一个具有该名字的子 XElement；  
④ Descendants 和 Ancestors：这些方法和 Elements 以及 Parent 方法差不多，只不过它们不返回直接的子元素和父元素，而是忽略嵌套级别，包括所有当前节点之下或者之上的节点。

如下代码演示了 Element 和 Elements 方法：

``` C#
using System;
using System.Collections.Generic;
using System.Xml.Linq;

class Program {
    static void Main( ) {
        XDocument employeeDoc =
            new XDocument(
                new XElement("Employees",
                    new XElement("Employee",
                        new XElement("Name", "Bob Smith"),
                        new XElement("PhoneNumber", "408-555-1000")),
                    new XElement("Employee",
                        new XElement("Name", "Sally Jones"),
                        new XElement("PhoneNumber", "415-555-2000"),
                        new XElement("PhoneNumber", "415-555-2001"))
                )
            );

        XElement root = employeeDoc.Element("Employees");
        IEnumerable<XElement> employees = root.Elements();

        foreach (XElement emp in employees)
        {
            XElement empNameNode = emp.Element("Name");
            Console.WriteLine(empNameNode.Value);

            IEnumerable<XElement> empPhones = emp.Elements("PhoneNumber");
            foreach (XElement phone in empPhones)
                Console.WriteLine($" { phone.Value }");
        }
    }
}
```

运行结果如下：

``` console
Bob Smith
 408-555-1000
Sally Jones
 415-555-2000
 415-555-2001
```

***4. 增加节点以及操作 XML***  
