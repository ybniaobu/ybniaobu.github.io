---
title: 《C#图解教程》读书笔记（三）
date: 2023-02-03 19:53:13
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：XXXXXXXXXXXXX。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第十六章 接口
## 什么是接口
**接口 interface**是指定一组函数成员但不实现它们的引用类型，所以只能用类和结构来实现接口。

接口的用途可以通过下面2个例子介绍，第一个例子不使用接口：

``` C#
class CA {
    public string Name;
    public int Age;
}

class CB {
    public string First;
    public string Last;
    public double PersonsAge;
}

class Program {
    static void PrintInfo( CA item ) {
        Console.WriteLine($"Name: { item.Name }, Age: { item.Age }");
    }

    static void Main() {
        CA a = new CA() { Name = "John Doe", Age = 35 };
        PrintInfo( a );
    }
}
```

上述代码只要传入 CA 类型对象，PrintInfo 方法就能工作正常。但传入 CB 类型对象就不行，而且 CB 的结构、字段名称和类型都可能与 CA 不一样。而接口可以使不管传入 PrintInfo 的类的结构是什么样的，都能正常处理：

``` C#
interface IInfo
{
    string GetName(); //返回string的方法
    string GetAge(); //返回string的方法
}

class CA : IInfo //声明实现接口的CA类
{
    public string Name;
    public int Age;
    public string GetName() { return Name; } //实现两个接口方法
    public string GetAge() { return Age.ToString( ); } //实现两个接口方法
}

class CB : IInfo //声明实现接口的CB类
{
    public string First;
    public string Last;
    public double PersonsAge;
    public string GetName() { return First + " " + Last; } //实现两个接口方法
    public string GetAge() { return PersonsAge.ToString(); } //实现两个接口方法
}

class Program
{
    static void PrintInfo( IInfo item ) //传入接口的引用
    {
        Console.WriteLine( "Name:{0}, Age {1}", item.GetName(), item.GetAge() );
    }

    static void Main()
    {
        CA a = new CA() { Name = "John Doe", Age = 35 };
        CB b = new CB() { First = "Jane", Last = "Doe", PersonsAge = 33 };

        PrintInfo(a); //对象的引用能自动转换为它们实现的接口的引用
        PrintInfo(b);
    }
}
```

运行结果如下：

``` console
Name:John Doe, Age 35
Name:Jane Doe, Age 33
```

### 使用 IComparable 接口的示例
通过以下示例来更好地了解接口：

``` C#
var myInt = new [] { 20, 4, 16, 9, 2 }; //创建int数组

Array.Sort(myInt); //按大小排序

foreach (var i in myInt) //输出
    Console.Write($"{ i } ");
```

Array 类的 Sort 方法可以运行在 int 数组上，但是在类数组上无法运行，如下：

``` C#
class MyClass
{
    public int TheValue;
}
    ...
MyClass[] mc = new MyClass[5]; //创建有5个元素的数组
    ...
Array.Sort(mc); //尝试使用Sort时抛出异常
```

Array 类的 Sort 方法实际上依赖一个叫做 **IComparable** 的接口，它声明在 BCL 中，包含唯一的方法 CompareTo 。下面代码展示了 IComparable 接口的声明，包含 CompareTo 方法的声明，该方法接受一个 object 类型的参数，并且没有实现，即实现用分号表示：

``` C#
public interface IComparable
{
    int CompareTo( object obj );
}
```

尽管在接口声明中没有为 CompareTo 方法提供实现，但 IComparable 接口的 .NET 文档描述了该方法应该做的事情。在调用 CompareTo 方法时，它应该返回以下几个值之一：  
①负数值，如果当前对象小于参数对象；  
②正数值，如果当前对象大于参数对象；  
③零，如果两个对象在比较时相等。

Sort 使用的算法依赖于使用元素的 CompareTo 方法来决定两个元素的次序，int 类型实现了 IComparable，但是 MyClass 没有。我们可以通过让类实现 IComparable，让 Sort 方法可以用于 MyClass 类型的对象。要实现这一接口，类或结构要①在基类列表中列出接口名称，②为接口的每一个成员提供实现。如下：

``` C#
class MyClass : IComparable //基类列表中的接口名称
{
    public int TheValue;

    public int CompareTo(object obj) //实现CompareTo方法以遵循接口文档的定义，参数类型和返回类型与接口成员一致
    {
        MyClass mc = (MyClass)obj;
        if (this.TheValue < mc.TheValue) return -1;
        if (this.TheValue > mc.TheValue) return 1;
        return 0;
    }
}
```

下图，展示了更新后的类，从有阴影的接口方法指向类方法的箭头表示接口方法不包含代码，而是在类级别的方法实现：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/04/jeamyQVskX6HzAR.png" width = "60%" height = "60%" alt="图71 - 在MyClass中实现IComparable"/>
</div>

既然 MyClass 实现了 IComparable 接口，就可以使用 Sort 了，如下：

``` C#
class MyClass : IComparable //类实现接口
{
    public int TheValue;
    public int CompareTo(object obj) //实现方法
    {
        MyClass mc = (MyClass)obj;
        if (this.TheValue < mc.TheValue) return -1;
        if (this.TheValue > mc.TheValue) return 1;
        return 0;
    }
}

class Program {
    static void PrintOut(string s, MyClass[] mc)
    {
        Console.Write(s);
        foreach (var m in mc)
            Console.Write($"{ m.TheValue } ");
        Console.WriteLine("");
    }

    static void Main()
    {
        var myInt = new [] { 20, 4, 16, 9, 2 };

        MyClass[] mcArr = new MyClass[5]; //创建MyClass对象的数组
        for (int i = 0; i < 5; i++) //初始化数组
        {
            mcArr[i] = new MyClass();
            mcArr[i].TheValue = myInt[i];
        }

        PrintOut("Initial Order: ", mcArr);
        Array.Sort(mcArr);
        PrintOut("Sorted Order: ", mcArr);
    }
}
```

运行结果如下：

``` console
Initial Order: 20 4 16 9 2 
Sorted Order: 2 4 9 16 20 
```

## 声明接口
声明接口的重要事项：  
①接口声明不能包括数据成员和静态成员；  
②接口声明只能包含方法、属性、事件和索引器这几个非静态成员函数；  
③上述函数成员的声明不能包含任何实现代码，必须使用分号代替主体；  
④按照惯例，接口名称必须从大写的 I 开始，比如 ISaveable ；  
⑤与类和结构一样，接口的声明可以分隔成分部接口声明。

``` C#
interface IMyInterface1
{
    int DoStuff ( int nVar1, long lVar2 ); //分号代替了主体
    double DoOtherStuff( string s, long x );
}
```

**接口的访问性**和接口成员的访问性之间的区别：  
①接口声明可以有任何的访问修饰符：public、protected、internal 或 private；  
②然而接口成员是隐式 public 的，不允许有任何访问修饰符，包括 public。

``` C#
public interface IMyInterface2 //接口可以有访问修饰符
{
    private int Method1( int nVar1, long lVar2 ); //错误，接口成员不能有访问修饰符
}
```

## 实现接口
只有类和结构能实现接口，要实现接口，类或结构必须：  
①在基类列表中包含接口名称；  
②为每一个接口成员提供实现。

关于实现接口的其他重要事项：  
①如果类实现了接口，它必须实现接口的**所有成员**；  
②如果类派生自基类并且实现了接口，基类列表中的基类名称必须放在所有接口之前，如下（只能有一个基类，所有其他类型必须为接口）：

``` C#
class Derived : MyBaseClass, IIfc1, IEnumerable, IComparable //基类必须放在最前面
{
    ...
}
```

### 简单接口的示例

``` C#
interface IIfc1 //声明接口
{
    void PrintOut(string s); //分号代替主体
}

class MyClass : IIfc1 //声明类，实现接口
{
    public void PrintOut(string s) //实现接口成员
    {
        Console.WriteLine($"Calling through: { s }");
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass(); //创建实例
        mc.PrintOut("object"); //调用方法
    }
}
```

运行结果如下：

``` console
Calling through: object
```

## 接口是引用类型
