---
title: 《C#图解教程》读书笔记（三）
date: 2023-02-03 19:53:13
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：XXXXXXXXXXXXX。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第十六章 接口
## 什么是接口
**接口 interface**是指定一组函数成员但不实现它们的引用类型，所以只能用类和结构来实现接口。

接口的用途可以通过下面2个例子介绍，第一个例子不使用接口：

``` C#
class CA {
    public string Name;
    public int Age;
}

class CB {
    public string First;
    public string Last;
    public double PersonsAge;
}

class Program {
    static void PrintInfo( CA item ) {
        Console.WriteLine($"Name: { item.Name }, Age: { item.Age }");
    }

    static void Main() {
        CA a = new CA() { Name = "John Doe", Age = 35 };
        PrintInfo( a );
    }
}
```

上述代码只要传入 CA 类型对象，PrintInfo 方法就能工作正常。但传入 CB 类型对象就不行，而且 CB 的结构、字段名称和类型都可能与 CA 不一样。而接口可以使不管传入 PrintInfo 的类的结构是什么样的，都能正常处理：

``` C#
interface IInfo
{
    string GetName(); //返回string的方法
    string GetAge(); //返回string的方法
}

class CA : IInfo //声明实现接口的CA类
{
    public string Name;
    public int Age;
    public string GetName() { return Name; } //实现两个接口方法
    public string GetAge() { return Age.ToString( ); } //实现两个接口方法
}

class CB : IInfo //声明实现接口的CB类
{
    public string First;
    public string Last;
    public double PersonsAge;
    public string GetName() { return First + " " + Last; } //实现两个接口方法
    public string GetAge() { return PersonsAge.ToString(); } //实现两个接口方法
}

class Program
{
    static void PrintInfo( IInfo item ) //传入接口的引用
    {
        Console.WriteLine( "Name:{0}, Age {1}", item.GetName(), item.GetAge() );
    }

    static void Main()
    {
        CA a = new CA() { Name = "John Doe", Age = 35 };
        CB b = new CB() { First = "Jane", Last = "Doe", PersonsAge = 33 };

        PrintInfo(a); //对象的引用能自动转换为它们实现的接口的引用
        PrintInfo(b);
    }
}
```

运行结果如下：

``` console
Name:John Doe, Age 35
Name:Jane Doe, Age 33
```

### 使用 IComparable 接口的示例
通过以下示例来更好地了解接口：

``` C#
var myInt = new [] { 20, 4, 16, 9, 2 }; //创建int数组

Array.Sort(myInt); //按大小排序

foreach (var i in myInt) //输出
    Console.Write($"{ i } ");
```

Array 类的 Sort 方法可以运行在 int 数组上，但是在类数组上无法运行，如下：

``` C#
class MyClass
{
    public int TheValue;
}
    ...
MyClass[] mc = new MyClass[5]; //创建有5个元素的数组
    ...
Array.Sort(mc); //尝试使用Sort时抛出异常
```

Array 类的 Sort 方法实际上依赖一个叫做 **IComparable** 的接口，它声明在 BCL 中，包含唯一的方法 CompareTo 。下面代码展示了 IComparable 接口的声明，包含 CompareTo 方法的声明，该方法接受一个 object 类型的参数，并且没有实现，即实现用分号表示：

``` C#
public interface IComparable
{
    int CompareTo( object obj );
}
```

尽管在接口声明中没有为 CompareTo 方法提供实现，但 IComparable 接口的 .NET 文档描述了该方法应该做的事情。在调用 CompareTo 方法时，它应该返回以下几个值之一：  
①负数值，如果当前对象小于参数对象；  
②正数值，如果当前对象大于参数对象；  
③零，如果两个对象在比较时相等。

Sort 使用的算法依赖于使用元素的 CompareTo 方法来决定两个元素的次序，int 类型实现了 IComparable，但是 MyClass 没有。我们可以通过让类实现 IComparable，让 Sort 方法可以用于 MyClass 类型的对象。要实现这一接口，类或结构要①在基类列表中列出接口名称，②为接口的每一个成员提供实现。如下：

``` C#
class MyClass : IComparable //基类列表中的接口名称
{
    public int TheValue;

    public int CompareTo(object obj) //实现CompareTo方法以遵循接口文档的定义，参数类型和返回类型与接口成员一致
    {
        MyClass mc = (MyClass)obj;
        if (this.TheValue < mc.TheValue) return -1;
        if (this.TheValue > mc.TheValue) return 1;
        return 0;
    }
}
```

下图，展示了更新后的类，从有阴影的接口方法指向类方法的箭头表示接口方法不包含代码，而是在类级别的方法实现：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/04/jeamyQVskX6HzAR.png" width = "60%" height = "60%" alt="图71 - 在MyClass中实现IComparable"/>
</div>

既然 MyClass 实现了 IComparable 接口，就可以使用 Sort 了，如下：

``` C#
class MyClass : IComparable //类实现接口
{
    public int TheValue;
    public int CompareTo(object obj) //实现方法
    {
        MyClass mc = (MyClass)obj;
        if (this.TheValue < mc.TheValue) return -1;
        if (this.TheValue > mc.TheValue) return 1;
        return 0;
    }
}

class Program {
    static void PrintOut(string s, MyClass[] mc)
    {
        Console.Write(s);
        foreach (var m in mc)
            Console.Write($"{ m.TheValue } ");
        Console.WriteLine("");
    }

    static void Main()
    {
        var myInt = new [] { 20, 4, 16, 9, 2 };

        MyClass[] mcArr = new MyClass[5]; //创建MyClass对象的数组
        for (int i = 0; i < 5; i++) //初始化数组
        {
            mcArr[i] = new MyClass();
            mcArr[i].TheValue = myInt[i];
        }

        PrintOut("Initial Order: ", mcArr);
        Array.Sort(mcArr);
        PrintOut("Sorted Order: ", mcArr);
    }
}
```

运行结果如下：

``` console
Initial Order: 20 4 16 9 2 
Sorted Order: 2 4 9 16 20 
```

## 声明接口
声明接口的重要事项：  
①接口声明不能包括数据成员和静态成员；  
②接口声明只能包含方法、属性、事件和索引器这几个非静态成员函数；  
③上述函数成员的声明不能包含任何实现代码，必须使用分号代替主体；  
④按照惯例，接口名称必须从大写的 I 开始，比如 ISaveable ；  
⑤与类和结构一样，接口的声明可以分隔成分部接口声明。

``` C#
interface IMyInterface1
{
    int DoStuff ( int nVar1, long lVar2 ); //分号代替了主体
    double DoOtherStuff( string s, long x );
}
```

**接口的访问性**和接口成员的访问性之间的区别：  
①接口声明可以有任何的访问修饰符：public、protected、internal 或 private；  
②然而接口成员是隐式 public 的，不允许有任何访问修饰符，包括 public。

``` C#
public interface IMyInterface2 //接口可以有访问修饰符
{
    private int Method1( int nVar1, long lVar2 ); //错误，接口成员不能有访问修饰符
}
```

## 实现接口
只有类和结构能实现接口，要实现接口，类或结构必须：  
①在基类列表中包含接口名称；  
②为每一个接口成员提供实现。

关于实现接口的其他重要事项：  
①如果类实现了接口，它必须实现接口的**所有成员**；  
②如果类派生自基类并且实现了接口，基类列表中的基类名称必须放在所有接口之前，如下（只能有一个基类，所有其他类型必须为接口）：

``` C#
class Derived : MyBaseClass, IIfc1, IEnumerable, IComparable //基类必须放在最前面
{
    ...
}
```

### 简单接口的示例

``` C#
interface IIfc1 //声明接口
{
    void PrintOut(string s); //分号代替主体
}

class MyClass : IIfc1 //声明类，实现接口
{
    public void PrintOut(string s) //实现接口成员
    {
        Console.WriteLine($"Calling through: { s }");
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass(); //创建实例
        mc.PrintOut("object"); //调用方法
    }
}
```

运行结果如下：

``` console
Calling through: object
```

## 接口是引用类型
接口是引用类型。不能直接通过类对象的成员来访问接口，可以通过把类对象引用强制转换为接口类型来获取指向接口的引用。一旦有了接口的引用，就可以使用点语法来调用接口的成员。示例如下：

``` C#
interface IIfc1
{
    void PrintOut(string s);
}

class MyClass : IIfc1
{
    public void PrintOut(string s)
    {
        Console.WriteLine($"Calling through: { s }");
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();
        mc.PrintOut("object");

        IIfc1 ifc = (IIfc1)mc; //将对象的引用转换为接口类型的引用
        ifc.PrintOut("interface"); //调用接口方法
    }
}
```

运行结果如下：

``` console
Calling through: object
Calling through: interface
```

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/3BXYFrgSocITWPf.png" width = "50%" height = "50%" alt="图72 - 类对象的引用以及接口的引用"/>
</div>

## 接口和 as 运算符
可以使用 **as 运算符**来代替使用强制转换运算符来获取对象接口的引用。as 运算符与接口配合使用更好，详见第17章。如果尝试将类对象引用强制转换为类未实现的接口的引用，强制转换操作会抛出一个异常。使用 as 运算符可以避免这个问题，若类实现了接口，表达式返回指向接口的引用，若类没有实现接口，表达式返回 null 而不是抛出异常。如下：

`ILiveBirth b = a as ILiveBirth;`  
b 是接口引用，a 是类对象引用，跟 `cast: (ILiveBirth)a` 一样。

## 实现多个接口
①类或结构可以实现任意数量的接口；  
②所有实现的接口必须列在基类列表中并以逗号分隔（若有基类，在其之后）

``` C#
interface IDataRetrieve { int GetData(); } //声明接口
interface IDataStore { void SetData( int x ); } //声明接口

class MyData: IDataRetrieve, IDataStore 
{
    int Mem1;
    public int GetData() { return Mem1; }
    public void SetData( int x ) { Mem1 = x; }
}
class Program
{
    static void Main()
    {
        MyData data = new MyData();
        data.SetData( 5 );
        Console.WriteLine($"Value = { data.GetData() }");
    }
}
```

## 实现具有重复成员的接口
如果一个类实现了多个接口，并且其中一些接口成员具有相同的签名和返回类型，那么类可以实现单个成员来满足所有包含重复成员的接口。示例如下：

``` C#
interface IIfc1 { void PrintOut(string s); }
interface IIfc2 { void PrintOut(string t); }

class MyClass : IIfc1, IIfc2
{
    public void PrintOut(string s)
    {
        Console.WriteLine($"Calling through: { s }");
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();
        mc.PrintOut("object");
    }
}
```

运行结果如下：

``` console
Calling through: object
```

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/ax513qpkCXBcyiv.png" width = "60%" height = "60%" alt="图73 - 由同一个类成员实现多个接口"/>
</div>

## 多个接口的引用
如果类实现了多个接口，可以获取每一个接口的独立引用。如下，可以以三种方式调用 PrintOut，通过类对象，通过指向 IIfc1 接口的引用，通过指向 IIfc2 接口的引用：

``` C#
interface IIfc1 { void PrintOut(string s); }
interface IIfc2 { void PrintOut(string s); }

class MyClass : IIfc1, IIfc2
{
    public void PrintOut(string s)
    {
        Console.WriteLine($"Calling through: { s }");
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();

        IIfc1 ifc1 = (IIfc1) mc; //获取IIfc1的引用
        IIfc2 ifc2 = (IIfc2) mc; //获取IIfc2的引用

        mc.PrintOut("object"); //从类对象调用

        ifc1.PrintOut("interface 1"); //从IIfc1调用
        ifc2.PrintOut("interface 2"); //从IIfc2调用
    }
}
```

## 派生成员作为实现
实现接口的类可以从它的基类继承实现代码，如下：

``` C#
interface IIfc1 { void PrintOut(string s); }

class MyBaseClass
{
    public void PrintOut(string s)
    {
        Console.WriteLine($"Calling through: { s }");
    }
}

class Derived : MyBaseClass, IIfc1 {}

class Program {
    static void Main()
    {
        Derived d = new Derived();
        d.PrintOut("object.");
    }
}
```

IIfc1 接口指向基类的 PrintOut 方法。

## 显式接口成员实现
单个类可以实现多个接口，若要让接口分开实现，可以创建**显式接口成员 explicit interface member implementations**，它使用限定接口名称来声明，由接口名称和成员名称以及中间的点构成：

``` C#
interface IIfc1 { void PrintOut(string s); } 
interface IIfc2 { void PrintOut(string t); } 

class MyClass : IIfc1, IIfc2
{
    void IIfc1.PrintOut(string s) //显式接口成员实现
    {
        Console.WriteLine($"IIfc1: { s }");
    }

    void IIfc2.PrintOut(string s) //显式接口成员实现
    {
        Console.WriteLine($"IIfc2: { s }");
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();

        IIfc1 ifc1 = (IIfc1) mc;
        ifc1.PrintOut("interface 1");

        IIfc2 ifc2 = (IIfc2) mc;
        ifc2.PrintOut("interface 2");
    }
}
```

注意：上述代码，不能使用 mc 引用来调用 PrintOut 方法，因为不存在类级别的 PrintOut 方法。当然可以添加类级别的实现。

### 访问显式接口成员实现
显式接口成员实现只能通过指向接口的引用来访问，如前例，类的其他成员也不能直接访问他们，会产生编译错误，需要强制转换当前对象的引用（用 this ）：

``` C#
class MyClass : IIfc1
{
    void IIfc1.PrintOut(string s) //显式接口实现
    {
        Console.WriteLine("IIfc1");
    }

    public void Method1()
    {
        PrintOut("..."); //编译错误
        this.PrintOut("..."); //编译错误

        ((IIfc1)this).PrintOut("..."); //转换为接口引用，并调用方法
    }
}
```

这个限制对继承产生了重要影响。由于其他类成员不能直接访问显式接口成员实现，派生类的成员也不能直接访问它们。它们必须总是通过接口的引用来访问。

## 接口可以继承接口
接口本身可以从一个或多个接口继承而来，如下：

``` C#
interface IDataRetrieve { int GetData(); }
interface IDataStore { void SetData( int x ); }

//从前两个接口继承而来
interface IDataIO: IDataRetrieve, IDataStore { }

class MyData: IDataIO
{
    int nPrivateData;
    public int GetData()
        { return nPrivateData; }
    public void SetData( int x )
        { nPrivateData = x; }
}

class Program
{
    static void Main()
    {
        MyData data = new MyData();
        data.SetData( 5 );
        Console.WriteLine("{0}", data.GetData());
    }
}
```

## 不同类实现一个接口的示例

``` C#
interface ILiveBirth { string BabyCalled(); }

class Animal { } //基类

class Cat : Animal, ILiveBirth
{
    string ILiveBirth.BabyCalled()
    { return "kitten"; }
}

class Dog : Animal, ILiveBirth
{
    string ILiveBirth.BabyCalled()
    { return "puppy"; }
}

class Bird : Animal
{
}

class Program
{
    static void Main()
    {
        Animal[] animalArray = new Animal[3];
        animalArray[0] = new Cat();
        animalArray[1] = new Bird();
        animalArray[2] = new Dog();
        foreach( Animal a in animalArray )
        {
            ILiveBirth b = a as ILiveBirth;
            if (b != null)
                Console.WriteLine($"Baby is called: { b.BabyCalled() }");
        }
    }
}
```

运行结果如下：

``` console
Baby is called: kitten
Baby is called: puppy
```


# 第十七章 转换
## 什么是转换
若要把一个变量（源）的值，赋值给另外一个变量（目标），在赋值之前，源的值必须转换为目标类型的值。转换后的值应和源值一致，但其类型为目标类型。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/24nuRkv5XPVSfoH.png" width = "70%" height = "70%" alt="图74 - 从short转换为sbyte"/>
</div>

## 隐式转换
有些类型的转换不会丢失数据和精度，比如8位的值转换为16位：  
①语言会自动做这些转换，这叫做**隐式转换**；  
②从位数更少的源类型转换为位数更多的目标类型时，多出来的位用0或1填充；  
③当从更小的无符号类型转换为更大的无符号类型时，目标类型多出来的最高位都以0进行填充，称为**零扩展 zero extension**。
④对于有符号类型的转换，额外的最高位用源表达式的符号位填充，这样可以维持被转换值的正确符号和大小，叫做**符号扩展 sign extension**，如下图：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/RYw6FQchEmBj35q.png" width = "60%" height = "60%" alt="图75 - 有符号转换中的符号扩展"/>
</div>

## 显式转换和强制转换
若将长类型转换为短类型，不是源值的所有最高位都适合目标类型，会导致**溢出 overflow** 或**数据丢失**。如下图：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/76z9FslyoKeRCAi.png" width = "60%" height = "60%" alt="图76 - 尝试把ushort转换为byte"/>
</div>

### 强制转换
对于预定义类型，C# 会自动将一个数据类型转换为另一个数据类型，前提是从源类型转换为目标类型不会发生数据丢失。即 C# 不会提供会丢失值情形的自动转换，这时候必须使用显式转换，即**强制转换表达式 cast expression** 。如果使用强制转换表达式，意味着要承担操作后引起的数据丢失的后果，如下图：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/PR4sMQimxULHn2G.png" width = "80%" height = "80%" alt="图77 - 强制把ushort转换为byte"/>
</div>

## 转换的类型
①除了标准转换，还可以为用户自定义类型定义隐式类型和显式类型；  
②还有一个预定义的转换类型，叫**装箱 boxing**，它可以将任何值类型转换为 object 类型或 System.ValueType 类型；  
③**拆箱 unboxing** 可以将一个装箱的值转换为原始类型。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/9HB1i2WA7ZLVNgx.png" width = "50%" height = "50%" alt="图78 - 转换的类型"/>
</div>

## 数字的转换
任何数字类型都可以转换为其他数字类型，一些转换是隐式的，另外一些转换必须是显式的。
### 隐式数字转换
如下图，若存在箭头，则存在从源类型到目标类型的隐式转换；若不存在，则需要使用显式转换：

<div  align="center">  
<img src="https://s2.loli.net/2023/02/07/TU3OPZ8YMIkptVy.png" width = "45%" height = "45%" alt="图79 - 隐式数字转换"/>
</div>

### 溢出检测上下文
对于整数类型（包括sbyte、byte、short、ushort、int、uint、long、ulong），C# 允许选择运行时是否应该在进行类型转换时检测溢出，可以通过 **checked 运算符**和 **checked 语句**来实现。

代码片段无论是否被检测都称为**溢出检测上下文 overflow checking context** 。默认的溢出检测上下文是不检查。  
①如果我们指定一个表达式或一段代码为 checked ，CLR 会在转换产生溢出时抛出一个 OverflowException 异常；  
②如果代码不是 checked ，转换会继续而不管是否溢出。

***1、checked 和 unchecked 运算符***
checked 和 unchecked 运算符控制表达式的溢出检测上下文，表达式放置在一对圆括号内，并且不能是一个方法：`checked ( Expression )` 或 `unchecked ( Expression )`。

``` C#
ushort sh = 2000;
byte sb;

sb = unchecked ( (byte) sh ); //忽略溢出
Console.WriteLine($"sb: { sb }");

sb = checked ( (byte) sh ); //抛出 OverflowException 异常
Console.WriteLine($"sb: { sb }");
```

运行结果如下：

``` console
sb: 208
Unhandled exception. System.OverflowException: Arithmetic operation resulted in an overflow.
```

***2、checked 语句和 unchecked 语句***
checked 语句和 unchecked 语句控制的是一块代码中的所有转换，而不是单个表达式。它们可以被嵌套在任意层次，如下：

``` C#
byte sb;
ushort sh = 2000;

checked
{
    unchecked
    {
        sb = (byte) sh;
        Console.WriteLine( $"sb: { sb }" );
    }

    sb = checked((byte) sh);
    Console.WriteLine( $"sb: { sb }" );
}
```

运行结果与上面相同，只不过这里影响的是一段代码而不是一个表达式。

### 显式数字转换
***1、整数类型到整数类型***  
如果转换会丢失数据，checked ：OverflowException 异常；unchecked ：丢失的位不会发出警告。

***2、float 或 double 转到整数类型***  
当把浮点类型转换为整数类型时，值会舍掉小数点，截断为最接近的整数。如果截断后的值不在目标类型的范围内：checked ：OverflowException 异常；unchecked ：C# 将不定义它的值应该是什么。

***3、decimal 到整数类型***  
如果结果值不在目标类型的范围内，CLR 会抛出 OverflowException 异常。

***4、double 到 float***  
float 类型的值占32位，而 double 类型的值占64位。double 类型的值被舍入到最接近的 float 类型的值。①如果值太小而不能用 float 表示，那么值会被设置为正或负0；②如果值太大而不能用 float 表示，那么值会被设置为正无穷大或负无穷大。

***5、float 或 double 到 decimal***  
如果值太小而不能用 decimal 类型表示，那么值会被设置为0；如果值太大，那么 CLR 会抛出 OverflowException 异常。

***6、decimal 到 float 或 double***  
从 decimal 类型转换到浮点数类型总会成功，然而可能会损失精度，即截断值到最接近的 float 或 double 值。

## 引用转换
引用转换接受源引用并返回一个指向堆中同一位置的引用，只是把引用“标记”为其他类型。

``` C#
class A { public int Field1; }

class B: A { public int Field2; }

class Program
{
    static void Main( )
    {
        B myVar1 = new B();
        A myVar2 = (A) myVar1; //返回指向myVar1的引用作为A类的引用

        Console.WriteLine($"{ myVar2.Field1 }"); //正确
        Console.WriteLine($"{ myVar2.Field2 }"); //编译错误，Field2对myVar2不可见
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2023/02/08/doaBWsuXMOmgbS3.png" width = "70%" height = "70%" alt="图80 - 引用转换返回与对象关联的不同类型"/>
</div>

对于 myVar2 ，它实际上指向 B 类型的对象，但它看不到 B 扩展 A 部分，因此看不到 Field2 。

### 隐式引用转换
①所有引用类型可以被隐式转换为 object 类型；  
②任何接口可以隐式转换为它继承的接口；  
③类可以隐式转换为它继承链中任何的类以及它实现的任何接口。
④委托可以隐式转换成如下图所示的 .NET BCL 类和接口：
⑤ Array 数组，比如下图的 ArrayS 数组（S for source，其中元素为 Ts 类型），可以隐式转换为如下图所示的 .NET BCL 类和接口，或者另一个数组，比如下图的 ArrayT 数组（T for target，其中元素为 Tt 类型）， ArrayT 数组必须满足：两个数组维度一样；Ts 和 Tt 都是引用类型；Ts 和 Tt 之间存在隐式转换。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/08/CZ1hvJaREHfVLxq.png" width = "70%" height = "70%" alt="图81 - 委托和数组的隐式转换"/>
</div>

### 显式引用转换
上面所述隐式转换的相反转换，需要显式引用转换，比如从 object 到任何引用类型的转换或从基类到派生自它的类的转换。

但是如果转换的类型没有限制，可能会导致尝试去引用内存中实际不存在的类成员，虽然编译器允许这样的转换，但如果运行时遇到它们，会抛出异常，如下：

``` C#
class A { public int Field1; }

class B: A { public int Field2; }

class Program
{
    static void Main( )
    {
        A myVar1 = new A();
        B myVar2 = (B) myVar1; //在运行时抛出InvalidCastException异常
    }
}
```

①若 myVar2 尝试访问 Field2，它会尝试访问对象中“ B 部分”（不在内存中），这会导致内存错误；
②运行时会捕获这种错误的强制转换并抛出 InvalidCastException 异常，它不会导致编译错误。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/08/o2MAUtmqbWfQEVK.png" width = "40%" height = "40%" alt="图82 - 无效的转换抛出运行时异常"/>
</div>

### 有效显式引用转换
在运行时能够成功进行的显式转换有以下3种情况：

第一种情况：显式转换没有必要，即可以隐式转换的情况，如下：

``` C#
class A { public int Field1; }
class B: A { public int Field2; }
...
B myVar1 = new B();
A myVar2 = (A) myVar1; //不必转换，因为A是B的基类
```

第二种情况：源引用是 null 。即使转换基类的引用到派生类的引用通常是不安全的，但是由于源引用是 null ，这种转换是允许的，如下：

``` C#
class A { public int Field1; }
class B: A { public int Field2; }
...
A myVar1 = null;
B myVar2 = (B) myVar1; //允许转换，因为myVar1为空
```

第三种情况：源引用指向的实际数据安全地进行隐式转换后，可以转回原类型：

``` C#
class A { public int Field1; }
class B: A { public int Field2; }
...
B myVar1 = new B();
A myVar2 = myVar1; //将myVar1隐式转换为A类型
B myVar3 = (B) myVar2; //该转换是允许的，因为数据是B类型的
```

①第二行隐式转换，看似使 myVar2 指向 A 类型的数据，实际上指向的是 B 类型的数据；  
②第三行中的显式转换把基类引用强制转换为它的派生类的引用，这通常会产生异常，但这里由于指向的对象实际就是 B 类型的数据项，所以允许转换。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/08/PWS8RLs9tgQHX4K.png" width = "70%" height = "70%" alt="图83 - 强制转换到安全类型"/>
</div>

## 装箱变换 Boxing Conversions
所有 C# 类型都派生自 object 类型，包括值类型，虽然 object 本身是引用类型。值类型在默认情况下在堆上不包括它们的对象组件，可以使用**装箱 boxing**（一种隐式转换），接受值类型，根据这个值在堆上创建一个完整的引用类型对象并返回对象引用，如下：

``` C#
int i = 12;
object oi = null;
oi = i;
```

系统将 i 的值装箱如下：  
①在堆上创建了 int 类型的对象；  
②将 i 的值复制到 int 对象；  
③返回 int 对象的引用，让 oi 作为引用保存。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/10/tIpGFHRgKxdLfVZ.png" width = "30%" height = "30%" alt="图84 - 装箱从值类型创建了完整的引用类型"/>
</div>

### 装箱是创建副本
装箱后返回的是值的引用类型副本。原始值类型和引用类型副本都可以独立操作，如下：

``` C#
int i = 10;
object oi = i;
Console.WriteLine($"i: { i }, io: { oi }");

i = 12;
oi = 15;
Console.WriteLine($"i: { i}, io: {oi }");
```

运行结果如下：

``` console
i: 10, io: 10
i: 12, io: 15
```

### 装箱转换
任何值类型 ValueTypeS 都可以被隐式转换为 object、System.ValueType 或 InterfaceT 类型（如果 ValueTypeS 实现了 InterfaceT ）。

## 拆箱转换 Unboxing Conversions
**拆箱 unboxing** 是把装箱后的对象转换回值类型的过程：  
①拆箱是显式转换；  
②系统在把值拆箱成 ValueTypeT 时执行了如下的步骤：  
&ensp;&ensp;&ensp;&ensp;- 它检测到要拆箱的对象实际是 ValueTypeT 的装箱值；  
&ensp;&ensp;&ensp;&ensp;- 它把对象的值复制到变量。  

``` C#
static void Main()
{
    int i = 10;
    object oi = i; //对i装箱并把引用赋值给oi
    int j = (int) oi; //对oi拆箱并把值赋值给j
    Console.WriteLine($"i: { i }, oi: { oi }, j: { j }");
}
```

运行结果如下：

``` console
i: 10, oi: 10, j: 10
```

尝试将一个值拆箱为非原始类型时，会抛出 InvalidCastException 异常。

## 用户自定义转换
除了标准转换外，可以为类或结构定义隐式和显式转换。

用户自定义转换的语法如下：  
①除了 **implicit** 或 **explicit 关键字**外，隐式转换和显式转换的声明语法是一样的；  
②需要 **public** 和 **static 修饰符**。

``` C#
public static implicit operator TargetType ( SourceType Identifier )
{
    ...
    return ObjectOfTargetType;
}
```

### 用户自定义转换的约束
①只可以为类或结构定义用户自定义转换；  
②不能重定义标准隐式或显式转换；  
③对于源类型 S 和目标类型 T：S 和 T 必须是不同类型。S 和 T 不能通过继承关联，即 S 不能派生自 T，而 T 也不能派生自 S 。S 和 T 都不能是接口类型或者 object 类型。转换运算符必须是 S 或 T 的成员；  
④不能同时对同一源和目标类型声明两种转换，即不能同时声明隐式和显式转换。

### 用户自定义转换的示例

``` C#
class Person
{
    public string Name;
    public int Age;
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    public static implicit operator int(Person p) //将Person转换为int
    {
        return p.Age;
    }

    public static implicit operator Person(int i) //将int转换为Person
    {
        return new Person("Nemo", i);
    }
}

class Program
{
    static void Main()
    {
        Person bill = new Person( "bill", 25);

        int age = bill; //把Person对象转换为int
        Console.WriteLine($"Person Info: { bill.Name }, { age }");

        Person anon = 35; //把int转换为Person对象
        Console.WriteLine($"Person Info: { anon.Name }, { anon.Age }");
    }
}
```

运行结果如下：

``` console
Person Info: bill, 25
Person Info: Nemo, 35
```

如果使用 explicit 运算符来定义相同转换，需要使用强制转换表达式来进行转换：

``` C#
    ...
public static explicit operator int( Person p )
{
    return p.Age;
}
...

static void Main( )
{
    ...
    int age = (int) bill;
    ...
}
```

### 多步用户自定义转换
上面讨论的用户自定义转换都是单步内直接把源类型转换为目标类型对象。但是，用户自定义转换在完整转换中最多可以有3个步骤：①预备标准转换；②用户自定义转换；③后续标准转换。这个链不可能有一个以上的用户自定义转换。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/10/WF45ydOzgBiUC1s.png" width = "70%" height = "70%" alt="图85 - 多步用户自定义转换"/>
</div>

### 多步用户自定义转换的示例

``` C#
class Employee : Person { }

class Person
{
    public string Name;
    public int Age;

    //将Person对象转换为int
    public static implicit operator int(Person p)
    {
        return p.Age;
    }
}

class Program
{
    static void Main( )
    {
        Employee bill = new Employee();
        bill.Name = "William";
        bill.Age = 25;

        float fVar = bill; //把Employee转换为float

        Console.WriteLine($"Person Info: { bill.Name }, { fVar }");
    }
}
```

运行结果如下：

``` console
Person Info: William, 25
```

<div  align="center">  
<img src="https://s2.loli.net/2023/02/10/9CGMNEyoaBWYen7.png" width = "70%" height = "70%" alt="图86 - 从Employee转换为float"/>
</div>

①上述代码声明了一个从 Person 类到 int 的用户自定义转换。由于从 Employee 到 Person 以及从 int 到 float 有标准转换，所以可以直接从 Employee 转换到 float ：  
&ensp;&ensp;&ensp;&ensp;- 由于 Employee 继承自 Person，从Employee 到 Person 有标准转换；  
&ensp;&ensp;&ensp;&ensp;- 从 int 到 float 有隐式数字转换，也是标准转换。
②由于链中的3个部分都存在，所以可以从 Employee 转换到 float 。

## is 运算符
可以使用 **is 运算符**来检查转换是否会成功完成。is 运算符的语法如下，其中 Expr 是源表达式：`Expr is TargetType`，该表达式返回 bool 类型。

如果 Expr 可以通过以下方式成功转换为目标类型，则运算符返回 true ：①引用转换；②装箱转换；③拆箱转换。

``` C#
class Employee : Person { }
class Person
{
    public string Name = "Anonymous";
    public int Age = 25;
}

class Program
{
    static void Main()
    {
        Employee bill = new Employee();

        //检测变量bill是否能转换为Person类型
        if( bill is Person )
        {
            Person p = bill;
            Console.WriteLine($"Person Info: { p.Name }, { p.Age }");
        }
    }
}
```

is 运算符只可以用于引用转换以及装箱和拆箱转换，不能用于用户自定义转换。

## as 运算符
**as 运算符**和强制转换运算符类似，只是不抛出异常，如果转换失败，它返回 null 。as 运算符的语法如下，其中 Expr 是源表达式，TargetType 是目标类型，它必须是引用类型：`Expr as TargetType`。

由于 as 运算符返回引用表达式，它可以用作赋值操作中的源，如下：

``` C#
class Employee : Person { }

class Person
{
    public string Name = "Anonymous";
    public int Age = 25;
}

class Program
{
    Employee bill = new Employee();
    Person p;

    p = bill as Person;
    if( p != null )
    {
        Console.WriteLine($"Person Info: { p.Name }, { p.Age }");
    }
}
```

as 运算符只可以用于引用转换以及装箱转换，不能用于用户自定义转换或到值类型的转换。


# 第十八章 泛型
## 什么是泛型
到现在为止，所有在类声明中用到的类型都是特定的类型，要么是程序员定义的，要么是语言或 BCL 定义的。然而，很多时候，我们需要把类的行为提取或重构出来，使之不仅能用到它们编码的数据类型上，还能应用到其他类型上。**泛型 generics**可以做到这一点，我们可以重构代码并额外增加一个抽象层，数据类型就不用硬编码了。这是专门为多段代码在不同的数据类型上执行相同指令的情况专门设计的。

### 一个栈的示例
如下，声明了 MyIntStack 的类，实现了一个 int 类型的栈，允许我们把 int 压入栈中，或弹出：

``` C#
class MyIntStack //int类型的栈
{
    int StackPointer = 0;
    int[] StackArray; //int类型的数组

    public void Push( int x ) { ... } //输入类型：int
    public int Pop() { ... } //返回类型：int
}
```

但是如果希望相同的功能应用于 float 类型的值，其中一种方式是剪切并粘贴 MyIntStack 类的代码，把类名改为 MyFloatStack ，把整个类声明中相应的 int 声明改为 float 声明。

这个方法可行，但是有很多缺点：需要仔细检查类的每一个部分来看哪些类型的声明需要修改，哪些需要保留；每次需要新类型的栈类时，需要重复这个过程，这就意味着具有很多相同代码的副本，占据了额外空间；并且很难调试和维护，修复问题需要一个个修改，很麻烦。

## C# 中的泛型
**泛型 generics**可以让多个类型共享一组代码。泛型允许声明**类型参数化 type-parameterized** 的代码，用不同类型进行实例化。即可以使用**类型占位符 placeholders for types** 来写代码，然后在创建类的实例时指明真实的类型。

***类型不是对象，而是对象或者实例的模板；而泛型类型不是类型，而是类型的模板。***

C# 提供了5种泛型：类、结构、接口、委托和方法。

<div  align="center">  
<img src="https://s2.loli.net/2023/02/11/k1o2XvBEa9MnHPs.png" width = "50%" height = "50%" alt="图87 - 泛型和用户定义类型"/>
</div>

### 继续栈的示例
通过以下步骤可以从 MyIntStack 创建一个泛型类，T 为标识符：  
①使用类型占位符 T 而不是 int 或 float 等；  
②修改类名称为 Mystack ；  
③在类名后放置 `<T>`。

``` C#
class MyStack<T>
{
    int StackPointer = 0;
    T [] StackArray;

    public void Push(T x ) {...}
    public T Pop() {...}
}
```

## 泛型类
