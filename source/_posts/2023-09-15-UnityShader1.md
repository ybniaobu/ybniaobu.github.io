---
title: 《Unity Shader 入门精要》读书笔记（一）
date: 2023-09-15 12:03:32
categories: 
  - [unity, unity shader]
tags:
  - 游戏开发
  - unity
  - 图形学
top_img: /images/black.jpg
cover: https://s2.loli.net/2023/09/15/XwyEsNaAnIxhHW4.jpg
mathjax: true
---
  
> 本读书笔记主要内容为XXXXXXXXXXXXXX。
> 读书笔记是对知识的记录与总结，但是对比较熟悉的内容不会再行描述。

# 第一章 渲染管线 Rendering Pipeline
## 什么是渲染管线
**渲染管线**也称为**渲染流水线**，是将三维场景模型转换到屏幕像素空间输出的过程。渲染流程可分为三个阶段：**应用阶段**、**几何阶段**、**光栅化阶段**：  
**①应用阶段**：这是一个由开发者完全控制的阶段，在这一阶段将进行数据准备，并通过 CPU 向 GPU 输送数据，例如顶点数据、摄像机位置、视锥体数据、场景模型数据、光源等等；此外，为了提高渲染性能，还会对这些数据进行处理，比如**剔除 culling** 不可见物体；最后还要设置每个模型的渲染状态，这些渲染状态包括但不限于所使用的材质、纹理、shader等。这一阶段最重要的输出是渲染所需的几何信息，即**渲染图元 rendering primitives**，通俗来讲渲染图元可以是点、线、面等；  
**②几何阶段**：几何阶段运行在 GPU 中，几何阶段和每个渲染图元打交道。几何阶段最重要的任务是将顶点坐标变换到屏幕空间中，再交给光栅器进行处理。通过对输入的渲染图元进行处理后，将输出屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息，传递给下个阶段；  
**③光栅化阶段**：光栅化阶段运行在 GPU 中，其主要任务是决定每个渲染图元中哪些像素应该被绘制在屏幕上，它需要对上一阶段得到的逐顶点数据进行插值，然后进行逐像素处理。

## CPU 和 GPU 之间的通信（应用阶段）
渲染管线的起点是 CPU ，应用阶段可分为以下三个阶段：  
**①把数据加载到显存**：所有渲染所需的数据都需要从硬盘 Hard Disk Drive, HDD 中加载到系统内存 Random Access Memory, RAM 中。然后网格和纹理等数据又被加载到显卡上的存储空间，即显存 Video Random Access Memory, VRAM 中。大多数显卡没有直接访问 RAM 的能力，将数据加载到显存中使 GPU 能更快的访问这些数据。当把数据加载到显存后，内存中的数据便可以释放了，但对于一些还需要使用的数据则需要继续保留在内存中，如 CPU 需要网格数据进行碰撞检测；  
**②设置渲染状态**：渲染状态的一个通俗解释就是，定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器 Vertex Shader /片段着色器 Fragment Shader、光源属性、材质等。
**③调用 Draw Call**：当所有的数据准备好后，CPU 就需要调用一个渲染指令告诉 GPU，按照上述设置进行渲染，这个渲染命令就是 **Draw Call**。Draw Call 命令仅仅会指向一个需要被渲染的图元列表，而不包含任何材质信息，因为这些信息已经在上一个阶段中完成。给定 Draw Call 后 GPU 就会根据渲染状态和所有输入的顶点数据来进行计算，并输出到显示设备中，所执行的操作便是下述 GPU 渲染管线的内容。  

## GPU 渲染管线（几何阶段和光栅化阶段）

<div  align="center">  
<img src="https://s2.loli.net/2023/09/15/BkGnZ46bTAVrR1J.png" width = "60%" height = "60%" alt="图1- GPU 渲染管线。颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由 GPU 固定实现的，开发者没有任何控制权。实线表示该 shader 必须由开发者编程实现，虚线表示该 Shader 是可选的"/>
</div>

### 顶点着色器 Vertex Shader
顶点着色器的处理单位是顶点，即对于输入的每个顶点都会调用一次顶点着色器。顶点着色器本身无法得到顶点与顶点之间的关系，例如无法得到两个顶点是否属于同一个三角网格，因为这样的独立性，可以优化处理每一个顶点。  

顶点着色器的两个任务是**坐标变换**和**逐顶点光照**：  
**①坐标变换，即将顶点坐标从模型空间转换到齐次裁剪空间。**当顶点坐标被变换到齐次裁剪空间后，通常再由硬件做透视除法，最终得到**归一化的设备坐标 Normalized Device Coordinates, NDC**。OpenGL（Unity 使用的 NDC）的 z 分量范围在\[-1, 1\]之间，而在 DirectX 中，NDC 的 z 分量范围是\[0, 1\]。

> 内容扩展：**MVP 矩阵**是**模型 Model**、**观察 View**、**投影 Projection** 三个矩阵的合称。这三个矩阵代表了物体顶点坐标从局部空间转换到裁剪空间，最后以屏幕坐标的形式结束。模型矩阵表示顶点坐标从物体自身局部空间 Local Space 转换到世界空间 World Space；观察矩阵表示从世界空间到观察空间 View Space ；投影矩阵表示从观察空间到裁剪空间 Clip Space。需要注意的是：投影矩阵并不代表这一步矩阵乘法过程中包含了投影，而是在下一步通过透视除法将 xyz 分量除以 w 才会发生投影。

**②逐顶点光照 per-vertex lighting**，也被称为**高洛德着色 Gouraud Shading**。在逐顶点光照中，会在每个顶点上计算光照，然后会在渲染图元内部进行线性插值，最后输出成像素颜色。

但顶点光照效果通常不尽人意，因此通常在片元着色器中执行逐片元光照计算。顶点着色器可以有不同的输出方式。最常见的输出路径是经光栅化后交给片元着色器进行处理。而在现代的 Shader Model 中，还可以把数据发送给曲面细分着色器或几何着色器。

### 曲面细分着色器 Tessellation Shader
曲面细分着色器是一个可选的阶段。曲面细分是利用镶嵌化处理技术对三角形进行细分，以此来增加物体表面的三角面数量。如果为这些细分的顶点再准备一些位置信息，有助于展现一个细节更加丰富的模型，这也是**贴图置换 Displacement Mapping** 的基本思路。

### 几何着色器 Geometry Shader
几何着色器也是一个可选的阶段。顶点着色器以顶点数据作为输入，而几何着色器则以完整的图元 Primitive 作为输入数据。与顶点着色器不能销毁或创建顶点不同，几何着色器的主要亮点就是可以创建或销毁几何图元，此功能让 GPU 可以实现一些有趣的效果。例如，根据输入图元类型扩展为一个或更多其他类型的图元，或者不输出任何图元。需要注意的是，几何着色器的输出图元不一定和输入图元相同。几何着色器的一个拿手好戏就是将一个点扩展为一个四边形(即两个三角形)。

### 裁剪 Clipping
裁剪操作就是将相机看不到的物体、顶点剔除，使其不被下一阶段处理。只有当图元完全位于视锥体内时，才会将它送到下一阶段，对于部分位于视锥体内的图元，外部的顶点将被剔除掉。由于已经知道在 NDC 下的顶点位置，即顶点位置在一个立方体内，因此裁剪就变得简单：只需要将图元裁剪到单位立方体内，只有在单位立方体的图元才需要被继续处理。因此，完全在单位立方体外部的图元被舍弃，完全在单位立方体内部的图元将被保留。和单位立方体相交的图元会被裁剪，新的顶点会被生成，原来在外部的顶点会被舍弃。裁剪这一步骤是硬件的固定操作，因此是不可编程的，但是可以自定义一个裁剪操作来配置。

### 屏幕映射 Screen Mapping
主要是**视口变换 Viewport Transformation**。这一步输入的坐标仍是三维坐标（范围在单位立方体内），屏幕映射的任务就是将每个图元的 x、y 值变换到**屏幕坐标系 Screen Coordinates**，屏幕坐标系是一个二维坐标系。由于输入坐标范围在\[-1, 1\]，因此这是一个缩放到屏幕分辨率大小的过程。对于输入的坐标 z 值不做任何处理，实际上屏幕坐标系和 z 坐标一起构成**窗口坐标系 Window Coordinates**，这些值会被一起传递到光栅化阶段。

OpenGL 和 DirectX 的屏幕坐标系存在差异：OpenGL 把屏幕的左下角当成最小的窗口坐标值，而 DirectX 则定义了屏幕的左上角为最小的窗口坐标值。

### 三角形设置
