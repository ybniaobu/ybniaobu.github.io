---
title: Temporal Anti-Aliasing (TAA)
date: 2025-06-21 19:43:03
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2025/06/23/kEPO3zg8IRXwUFC.gif
mathjax: true
description: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
---

> 本来是想先实现 SSGI 或者 SSR 的，但是研究着研究着，就发现 SSGI 或 SSR 的思想都有些许依赖于 SSAO 相关技术算法（SSAO、SSDO、HBAO、GTAO 等等），然后就想着要不先实现 SSAO，但是研究着研究着，又发现 SSAO 等相关技术跟 PCSS 一样较为依赖于降噪技术，降噪技术又可以分为**空间滤波 Spatial Filter** 以及**时间滤波 Temporal Filter**。所以为了打好基础，最终决定先实现 **Temporal Anti-Aliasing (TAA)**，对**抖动 jitter** 有个更深入的理解后，再进入全局光照的实现，顺便也能优化一下 PCSS。
>   
> 本篇文章主要参考了以下几篇文章或演讲或 PPT（加粗的文章更综合地介绍了 TAA 技术，建议优先观看）：  
> ① High Quality Temporal Supersampling（SIGGRAPH 2014）：https://advances.realtimerendering.com/s2014/#_HIGH-QUALITY_TEMPORAL_SUPERSAMPLING or https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf ；  
> ② **A Survey of Temporal Antialiasing Techniques** ：https://research.nvidia.com/labs/rtr/publication/yang2020survey/ ；  
> ③ **Temporal AA and the Quest for the Holy Trail** ：https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/ ；  
> ④ Temporal Reprojection Anti-Aliasing in INSIDE（GDC 2016）：https://www.gdcvault.com/play/1022970/Temporal-Reprojection-Anti-Aliasing-in ；  
> ⑤ An Excursion in Temporal Supersampling（GDC 2016）：https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf ；  
> ⑥ Temporal Antialiasing in Uncharted 4（SIGGRAPH 2016）：https://advances.realtimerendering.com/s2016/ ；  
> ⑦ Temporal Antialiasing Starter Pack ：https://alextardif.com/TAA.html ；  
> ⑧ Temporal Anti Aliasing – Step by Step ：https://ziyadbarakat.wordpress.com/2020/07/28/temporal-anti-aliasing-step-by-step/ ；  
> ⑨ Adaptive Temporal Antialiasing ：https://research.nvidia.com/publication/2018-08_adaptive-temporal-antialiasing ；  


# TAA 原理及流程简单介绍
**时域抗锯齿 Temporal Anti-Aliasing (TAA)** 用一句话概括可以说是使用了历史帧中的**子/次/亚像素 subpixel** 进行累计从而更有效地实现**超采样抗锯齿 Supersampling Anti-Aliasing (SSAA)**。相对于 SSAA 或 MSAA 来说，TAA 有效地将一个像素多次采样分摊到了连续的几帧当中，即以一个像素一次采样的代价实现了超采样抗锯齿。与此同时，单帧单像素采样，实际上会“损失”一些亚像素信息的，而 TAA 通过抖动在历史帧中解析出单帧光栅化中丢失的亚像素信息，从而能够更好地实现抗锯齿的效果，也相对来说增加了基于时序的稳定性。特别是当物体或相机移动时，图元边缘相对于采样点的位置不断变化，导致边缘像素的覆盖率计算结果不断变化，使得边缘像素的颜色在帧与帧之间发生微妙的、高频的亮度变化，而历史帧的混合可以减少这种不稳定性。虽然由于每帧的抖动，会让我们误以为更加不稳定，但实际上可以通过些许 trick 来减少感知上的闪烁问题，从而达到其他后处理抗锯齿技术无法达到的基于时序的稳定性。这也引出了 TAA 的两大难题：**鬼影 ghost** 问题和**闪烁 flicker** 问题，我们在后面重点解决这两个问题。

TAA 大致流程如下所示：  
①首先对摄像机进行**抖动 jitter**，这样子每一帧采样的是一个基于中心位置的被抖动过后的随机位置采样点，将当前帧采样颜色和历史颜色进行混合得到 TAA Target 贴图，后处理后输出。与此同时，将 TAA Target 复制为 TAA History/Accumulation 贴图，将累计的历史颜色信息用于下一帧进行混合；  
②由于相机或物体会进行移动，所以采样历史帧（TAA History）时，不能使用当前的 uv 值，否则采样到的颜色会不是当前像素点或物体的历史颜色信息。这就需要使用上一帧的矩阵进行**重投影 Reprojection** 计算出**运动向量 Motion Vector**，从而还原出当前像素在上一帧的屏幕位置。Motion Vector 又分为 **Camera Motion Vector** 和 **Object Motion Vector**，后面会详细说明；  
③由于运动时遮挡的变化，或者超出屏幕范围，又或者是灯光的变化，会让我们采样到跟当前帧不匹配的历史颜色信息。因此我们需要**验证 Validate** 或**矫正 rectify** 历史信息，以防止鬼影以及闪烁现象的产生。

<div align="center">  
<img src="https://s2.loli.net/2025/07/06/HCp3vjaQ4tswEUq.png" width = "60%" height = "60%" alt="图1 - TAA 基本流程"/>
</div>

下面就开始介绍具体的实现方式，我们先处理静态场景的情形，即摄像机和物体都不运动：

# 累计历史样本
## 抖动 Jitter
由于我们要对一个像素内的多个**子像素 subpixel** 进行采样，故我们需要对采样点的位置进行偏移，即**抖动 Jitter**，通常情况下会使用低差异序列中的 Halton 序列，从而实现更好的抗锯齿效果。Playdead Studios 工作室（《INSIDE》、《地狱边境》的制作厂商）在 GDC 2016 的分享中有提到使用 Halton 序列的前 16 个样本可以产生更好的效果，我也采用了这个方式。

<div align="center">  
<img src="https://s2.loli.net/2025/07/06/Fr3pSCQuLM2fJWl.jpg" width = "50%" height = "50%" alt="图2 - Halton Squence"/>
</div>

对采样点进行偏移的方式通常是修改相机的投影矩阵，只需修改矩阵中的两个变量即可：  

    ProjectionMatrix[0][2] += ( OffsetX * 2.0f – 1.0f ) / FrameBufferSize.Width;
    ProjectionMatrix[1][2] += ( OffsetY * 2.0f – 1.0f ) / FrameBufferSize.Height;

至于为什么要对 offset 乘 2 减 1 的原因是，Halton 序列即 offset 的范围是在 (0, 1)，我们希望偏移的范围是在一个像素内，即在 (-0.5, 0.5) 之间，需要对 Halton 序列减去 0.5。又因为齐次除法后得到的 NDC 坐标的 x、y 分量都在 \[-1, 1\] 之间，而得到 uv 值在 (0, 1) 之间，故需要乘以 2 消除缩放影响。具体推导如下：  


