---
title: Unity Custom SRP 基础（五）
date: 2025-02-26 11:30:46
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2025/02/26/m2zJbPd8aeGD14A.gif
mathjax: true
description: 本笔记的主要内容包含 PCSS 的实现；XXXXXXXXXXXXXXXXXXXXXXXXXX
---

> 本笔记是关于 Unity 的**自定义可编程渲染管线**的入门基础，即 **SRP (Scriptable Rendering Pipeline)**，主要参考了著名的教程 https://catlikecoding.com/ 的 Custom SRP Tutorial，以及知乎上各位图形学大神们的文章。  
>    
> 笔者使用的 Unity 版本是 6000.0.27f1，Core RP Library 的版本是 17.0.3。

# PCSS
本章节讲解**百分比接近软阴影 Percentage-Closer Soft Shadows (PCSS)** 的实现，这部分内容是 catlikecoding 教程中没有的。PCSS 解决了 PCF 均匀相同的半影宽度问题，能够根据**遮挡物 Blocker** 和**接受物 Receiver** 之间的距离产生可变宽度的软阴影效果。该技术最早由 NVIDIA 的一篇论文提出：[Percentage-Closer Soft Shadows](https://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf) ，本章节也是基于这篇论文书写的。 

## 实现步骤
**第一步：Blocker Search**  
搜索阴影贴图的一定的区域，并记录下比采样点离光源更近的深度值做平均（注意这里只平均比采样点更近的遮挡物的深度值）。理论上来说，搜索区域的大小是由灯光大小和接受物离光源的距离共同决定的，如下图：  

<div  align="center">  
<img src="https://s2.loli.net/2025/02/27/mw86o9gnCTrKx1e.jpg" width = "50%" height = "50%" alt="图78 - Blocker Search Step"/>
</div>

阴影贴图的位置是在灯光的近裁切平面，所以真实的搜索区域的大小需要通过相似三角形计算得到。但是在实际操作中，因为近裁切平面离光源非常近，我们可以假定近裁切平面就在灯光的位置。这样搜索区域的大小在世界空间下就是灯光的大小。根据灯光的大小和世界空间下阴影贴图的大小，可以计算出灯光所占阴影贴图的比例，就可以得到灯光所占阴影贴图像素的范围。

为什么要对遮挡距离进行平均计算，而不直接使用**着色点 shading point** 的采样深度。是因为一旦该点未被遮挡，遮挡距离会直接变为 0，这样就会形成一条具体的边缘，阴影将无法散开。

**第二步：Penumbra Estimation**  
根据计算得到的平均遮挡距离、着色点距离（接受物距离）和灯光大小，使用相似三角形计算半影宽度，如下图：  

$$ \omega_{Penumbra} = \cfrac {(d_{Receiver} - d_{Blocker}) \cdot \omega_{Light}} {d_{Blocker}} $$

<div  align="center">  
<img src="https://s2.loli.net/2025/02/27/6TaGFh1Hz54vmdU.jpg" width = "25%" height = "25%" alt="图79 - Penumbra Estimation Step "/>
</div>

**第三步：Filtering**  
这一步跟 PCF 是一样的，只不过滤波核大小使用的上一步估算出来的大小，可以使用一个参数乘以计算出来的半影宽度，来控制滤波核大小。

## 具体实现
下面为方向光、点光源、聚光灯的 PCSS 的具体实现，因为这三种光源的实现细节会有所不同，故一个一个讲，首先是最简单的聚光灯。

### 聚光灯
首先是需要从 CPU 传递到 GPU 的可控制的参数，CPU 中具体步骤这里就不摘抄了：  

    CBUFFER_START(LightParamsPerFrame)
        ...
        float4 _SpotLightShadowBias[MAX_SHADOWING_SPOT_LIGHT_COUNT]; // x: depth bias, y: slope scaled depth bias, z: normal bias, w: slope scaled normal bias
        float4 _SpotLightShadowParams[MAX_SHADOWING_SPOT_LIGHT_COUNT]; // x: light size, y: penumbra scale, z: blocker search sample number, w: filter sample number
        float4 _SpotLightDepthParams[MAX_SHADOWING_SPOT_LIGHT_COUNT]; // x: (f + n) / (f - n), y: -2 * f * n / (f - n); [if UNITY_REVERSED_Z] x: (f + n) / (n - f), y: -2 * f * n / (n - f)
        ...
    CBUFFER_END

原本我 Shadow Bias 的四个参数是全光源共用的，后来从效果体验上觉得对于点光源、聚光灯和方向光还是分开比较好。当然也可以选择所有点光源、所有聚光灯、所有方向光都分别共用一个 Shadow Bias，即三个 Shadow Bias 作为全局设置。但我最终还是选择了把 Shadow Bias 作为 per-light 设置，即一个灯光一个 Shadow Bias。`_SpotLightDepthParams` 里面的参数是用于将非线性深度转变为线性深度的，后面会提到。

---

然后就是 PCSS 的第一步 Blocker Search 了，先确定搜索区域的范围，即灯光所占阴影贴图的比例，用灯光大小除以阴影贴图的大小，两者都是在世界空间下的大小。对于聚光灯来说，由于不是正交投影，阴影贴图的大小对于不同深度的着色点是不同的，这点在 PCF 中也提到过，就不再重复了：  

    float searchWidthWS = GetSpotLightSize(shadowingSpotLightIndex);
    float searchWidthPercent = searchWidthWS / (2.0 * ComputeTanHalfFOV(lightIndex) * linearDepth);
  
拿到了搜索区域的范围，就可以利用它偏移着色点并在阴影贴图上采样，获取遮挡物深度值最后平均。这里注意一下，我们要获取的是线性深度值，而直接在阴影贴图上采样得到的是非线性深度值，后面计算半影宽度需要的是线性深度。这里可以选择用非线性深度值做平均后再转换为线性深度值，但相对来说不太准确（其实影响也不大）。我这里选择的是，每次采样后都转换为线性深度，再做平均。

如何将非线性深度值转换为线性深度属于基础知识了，忘了回去看《Unity Shader入门精要》。我这里直接写结论了，首先传递投影矩阵的 m22 和 m23 分量，注意如果 Reversed Z 就传递 -m22 和 -m23，这样在 Shader 里就不用判断 Reversed Z 了，计算出来都是从近到远变大的线性深度值：  

``` C#
m_SpotLightDepthParams[i] = SystemInfo.usesReversedZBuffer
                            ? new Vector4(-projectionMatrix.m22, -projectionMatrix.m23)
                            : new Vector4(projectionMatrix.m22, projectionMatrix.m23);
```

在 Shader 中线性深度转换代码如下：  

    float NonLinearToLinearDepth(float4 depthParams, float nonLinearDepth)
    {
        return depthParams.y / (2.0 * nonLinearDepth - 1.0 + depthParams.x);
    }

注意，在计算平均遮挡深度时，仅在发生遮挡的时候才计入平均距离，故需要做判断。这里可以选择比较非线性深度值，也可以选择比较线性深度值，但是选择比较非线性深度值需要做 Reversed Z 判断并反转大于小于符号，代码如下：  

    float ComputeAverageBlockerDepth(float index, TEXTURE2D_ARRAY(shadowMap), float sampleNumber, float searchWidthPercent, float3 positionSS, float4 depthParams, uint hash1, uint hash2, float2x2 rotation)
    {
        float d_Shading = positionSS.z;
        float ld_Shading = NonLinearToLinearDepth(depthParams, d_Shading);
        float ald_Blocker = 0.0;
        float count = 1e-8; // avoid division by zero

        for (int i = 0; i < sampleNumber; i++)
        {
            float2 offset = mul(rotation, InverseSampleCircle(Sobol_Scrambled(i, hash1, hash2))) * 0.5;
            offset = offset * searchWidthPercent;
            float2 uv = positionSS.xy + offset;
            float d_Blocker = SampleShadowArray_Depth(uv, index, shadowMap, SHADOW_SAMPLER);
            float ld_Blocker = NonLinearToLinearDepth(depthParams, d_Blocker);
            
            if (ld_Blocker < ld_Shading)
            {
                ald_Blocker += ld_Blocker;
                count += 1.0;
            }
        }
        ald_Blocker = ald_Blocker / count;
        return ald_Blocker;
    }

上述代码中变量的前缀 d、ld、ald 的含义分别为 depth、linear depth、average linear depth。offset 需要乘以 0.5 是因为 Sobol 序列随机数生成的范围是 [0, 1]，圆盘化后范围变为了 [-1, 1]，这样范围就从 1 变为 2 了。这样子就可以得到平均遮挡深度了，但是仍然存在问题。我将着色点深度减去平均遮挡深度所占着色点深度的比例（d_Shading - ald_Blocker）/ d_Shading 输出如下：  

<div  align="center">  
<img src="https://s2.loli.net/2025/02/27/Ufsjnp1zAcWv5m7.jpg" width = "40%" height = "40%" alt="图80 - 自遮挡现象"/>
</div>

可以看到有非常多的 alias，
