---
title: 《C#图解教程》读书笔记（五）
date: 2023-07-07 14:09:57
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 本篇主要内容为：预处理指令，反射和特性，以及其他主题中的字符串、可空类型、Main方法、文档注释等等；  
> 读书笔记仅为知识的记录，方便后续查找。  
> 学习完成日期为XXXX年XX月XX日。 

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第二十四章 预处理指令
## 什么是预处理指令
源代码指定了程序的定义，**预处理指令 preprocessor directive** 指示编译器如何处理源代码。例如，在某些情况下，我们可能希望编译器忽略一部分代码，而在其他情况下，我们可能希望代码被编译。预处理指令给了我们这样的选项。

在 C 和 C++ 中有实际的预处理阶段，此时预处理程序遍历源代码并且为之后的编译阶段准备文本输出流。在 C# 中没有实际的预处理程序。“预处理”指令由编译器来处理，而这个术语保留了下来。

## 基本规则
下面是预处理指令最重要的一些语法规则：  
①预处理指令必须和 C# 代码在不同的行；  
②与 C# 语句不同，预处理指令不需要以分号结尾；  
③包含预处理指令的每一行必须以#字符开始：
&emsp;&emsp;- 在#字符前可以有空格；  
&emsp;&emsp;- 在#字符和指令之间可以有空格。
④允许行尾注释；  
⑤在预处理指令所在的行不允许分隔符注释。

``` C#
#define PremiumVersion     //没有分号，正确
  #define BudgetVersion    //前面有空格，正确
# define MediumVersion     //中间有空格，正确

#define PremiumVersion     /* all bells & whistles */ 不允许分隔符注释，错误

#define BudgetVersion      // Stripped-down version 允许行尾注释，正确
```

下表列出了预处理指令：

| 指令 | 含义概要 |
| :---- | :---- |
| #define identifier | 定义编译符号 |
| #undef identifier | 取消定义编译符号 |
| #if expression | 如果表达式是true，则编译器编译下面的片段 |
| #elif expression | 如果表达式是true，则编译器编译下面的片段 |
| #else | 如果之前的#if或#elif表达式是false，则编译器编译下面的片段 |
| #endif | 标记一个#if结构的结束 |
| #region name | 标记一段代码的开始，没有编译效果 |
| #endregion name | 标记一段代码的结束，没有编译效果 |
| #warning message | 显示编译时的警告消息 |
| #error message | 显示编译时的错误消息 |
| #line indicator | 修改在编译器消息中显示的行数 |
| #pragma warning | 提供修改编译器警告消息行为的选项 |

## `#define` 和 `#undef` 指令
**编译符号 compilation symbol** 是只有两种可能状态的标识符，要么被定义，要么未被定义。编译符号有如下特性：  
①它可以是除了 true 或 false 以外的任何标识符，包括 C# 关键字，以及在 C# 代码中声明的标识符，这两者都是可以的；  
②它没有值。与 C 和 C++ 不同，它不表示字符串。

`#define` 和 `#undef` 指令只能用在源文件的第一行，也就是任何 C# 代码之前。在 C# 代码开始后，`#define` 和 `#undef` 指令就不能再使用。编译符号的范围被限制于单个源文件。只要编译符号在任何 C# 代码之前，重复定义已存在的编译符号也是允许的。

定义一个标识符相当于将其值设置为 true。取消定义一个标识符相当于将其值设置为 false。尽管必须在 C# 代码之外定义标识符，但可以在 C# 代码中使用它，通常是在 `#if #else` 构造中使用，如下：

``` C#
#define debug
static void Main()
{
    #if debug
        //开启详细日志
    #else
        //性能优化
    #endif
        ...
}
```

## 条件编译
条件编译允许根据某个编译符号是否被定义标注一段代码被编译或跳过。

有4个指令可以用来指定条件编译：`#if`; `#else`; `#elif`; `#endif`。

在`#if`和`#elif`指令中使用的条件是一个返回 true 或 false 的简单表达式，如下表所总结的。条件可以由单个编译符号、符号表达式或操作符组成；子条件可以使用圆括号分组；文本 true 或 false 也可以在条件表达式中使用：

| 参数类型 | 意义 | 运算结果 |
| :---- | :---- | :---- |
| 编译符号 | 使用`#define`指令定义（或未被定义）的标识符 | true：如果符号已经使用`#define`指令定义 <br> false：其他 |
| 表达式 | 使用符号和操作符!、==、!=、&&、&#9474;&#9474;构建的 | true：如果表达式运算结果为true <br> false：其他 |

条件编译示例如下：  

``` C#
#if !DemoVersion //表达式
    …
#endif

#if(LeftHanded && OemVersion) //完整版
    …
#endif

#if true //下面的代码片段总是会被编译
    …
#endif
```

## 条件编译结构
`#if` 和 `#endif` 指令在条件编译结构中需要配对使用。

例如，如下的代码演示了简单的 `#if...#else` 结构。如果符号 RightHanded 被定义了，那么 `#if` 和 `#else` 之间的代码会被编译。否则，`#else` 和 `#endif` 之间的代码会被编译：

``` C#
...
#if RightHanded
    // Code implementing right-handed functionality
    ...
#else
    // Code implementing left-handed functionality
    ...
#endif
```

如下的代码演示了 `#if...#elif...#else` 结构。包含程序版本描述的字符串根据定义的编译符号被设置为不同的值：  

``` C#
#define DemoVersionWithoutTimeLimit

using System;

class demo
{
    static void Main()
    {
        const int intExpireLength = 30;
        string strVersionDesc = null;
        int intExpireCount = 0;

#if DemoVersionWithTimeLimit
    intExpireCount = intExpireLength;
    strVersionDesc = "This version of Supergame Plus will expire in 30 days";

#elif DemoVersionWithoutTimeLimit
    strVersionDesc = "Demo Version of Supergame Plus";

#elif OEMVersion
    strVersionDesc = "Supergame Plus, distributed under license";

#else
    strVersionDesc = "The original Supergame Plus!!";

#endif

        Console.WriteLine(strVersionDesc);
    }
}
```

运行结果如下：

``` console
Demo Version of Supergame Plus
```

## 诊断指令
**诊断指令 Diagnostic Directives** 产生用户自定义的编译时警告及错误消息。

下面是诊断指令的语法。 Message 是字符串，但是需要注意，与普通的 C# 字符串不同，它们不需要被引号包围。

``` C#
#warning Message

#error Message
```

当编译器遇到诊断指令时，它会输出相关的消息。诊断指令的消息会和任何编译器产生的警告和错误消息列在一起。

## 行号指令
**行号指令 Line number directives** 可以做很多事情，诸如：  
①改变由编译器警告和错误消息报告的出现行数；  
②改变被编译源文件的文件名；  
③对交互式调试器隐藏一些行。

`#line` 指令的语法如下：

``` C#
#line integer    //将下一行的行号设置为整数
#line "filename" //设置文件名
#line default    //重新保存实际的行号和文件名

#line hidden     //对断点调试器隐藏以下代码
#line            //停止在调试器中隐藏代碼
```

带一个整数参数的 `#line` 指令会使编译器将该值视为下一行代码的行号，之后的行号会在这个行号的基础上递增。  
①要改变文件名，可以在双引号内使用文件名作为参数。双引号是必需的；  
②要返回真实行号和真实文件名，可以使用 default 参数；  
③要对交互式调试器的断点调试功能隐藏代码段，可以使用 hidden 作为参数。要停止隐藏，可以使用不带任何参数的指令。到目前为止，这个功能大多用于在 ASP.NET 和 WPF 中隐藏编译器生成的代码。

``` C#
#line 226
    x = y + z; //现在编译器认为这是第226行
    ...

#line 330 "SourceFile.cs" //改变报告的行号和文件名
    var1 = var2 + var3;
    ...

#line default //重新保存行号和文件名
```

## 区域指令
**区域指令 region directive** 允许标注和有选择性地命名一段代码。区域由一个 region 指令和某下方某处的一个 `#endregion` 指令构成。通过仅显示当前要处理的代码区域，区域功能可以让你更轻松地浏览代码。它还允许你通过位置组织代码，例如所有的属性放在同一位置，所有方法放在另一个位置。`#region` 指令的特性如下：  
①`#region` 指令被放置在你想要标注的代码段上，而 `#endregion` 指令被放置在区域中最后一行代码之后；  
②`#region` 指令用其后的可选文本字符串作为区域的名称；  
③区域可以内嵌在其他的区域内：  
&emsp;&emsp;- 区域可以内嵌到任何级别，区域可以嵌套；  
&emsp;&emsp;- `#endregion` 指令始终与其上方的第一个没匹配过的 `#region` 指令匹配。

尽管区域指令被编译器忽略，但它们可以被源代码工具所使用。例如，Visual Studio允许我们很简单地隐藏或显式区域。作为示例，下面的代码中有一个叫做 Constructors 的区域，它封闭了 MyClass 类的两个构造函数。在 Visual Studio 中，如果不想看到其中的代码，可以把这个区域折叠成一行，如果又想对它进行操作或增加另外一个构造函数，还可以扩展它：

``` C#
#region Constructors
    MyClass()
    { ... }

    MyClass(string s)
    { ... }
#endregion
```

## `#pragma warning` 指令
利用 `#pragma warning` 指令可以关闭及重新开启警告消息：  
①要关闭警告消息，可以使用 disable 形式加上希望关闭的警告数的逗号分隔的形式列表；  
②要重新开启警告消息，可以使用 restore 形式加上希望关闭的警告数的逗号分隔的形式列表。

例如，下面的代码关闭了两个警告消息：618和414。在后面的代码中又开启了618警告消息，但还是保持414消息为关闭状态：

``` C#
#pragma warning disable 618, 414 //要关闭的警告信息
    ... //列出的警告信息在这段代码中处于关闭状态
#pragma warning restore 618
```

如果我们使用任意一种不带警告数字列表的形式，这个命令会应用于所有警告。例如，下面的代码关闭然后恢复所有警告消息：

``` C#
#pragma warning disable
    ... //所有警告信息在这段代码中处于关闭状态

#pragma warning restore
    ... //所有警告信息在这段代码中处于开启状态
```


# 第二十五章 反射和特性
## 元数据和反射
大多数程序都要处理数据，包括读、写、操作和显示数据。（图形也是数据的一种形式。）然而，对于某些程序来说，它们操作的数据不是数字、文本或图形，而是关于程序和程序类型的信息。  
①有关程序及其类型的数据被称为**元数据 metadata**，它们保存在程序的程序集中；  
②程序在运行时，可以查看其他程序集或其本身的元数据。运行中的程序査看本身的元数据或其他程序的元数据的行为叫做**反射 reflection**。

对象浏览器是显式元数据的程序的一个示例。它可以读取程序集，然后显示所包含的类型以及类型的所有特性和成员。

本章将介绍程序如何使用 **Type 类**来反射数据，以及程序员如何使用**特性 attributes** 来给类型添加元数据。

> 要使用反射，我们必须使用 System.Reflection 命名空间。

## Type 类
BCL 声明了一个叫做 Type 的抽象类，它被设计用来包含类型的特性。使用这个类的对象能获取程序使用的类型的信息。

由于 Type 是抽象类，因此它不能有实例。在运行时，CLR 创建从 Type(RuntimeType) 派生的类的实例，Type 包含了类型信息。当访问这些实例时，CLR 不会返回派生类的引用而是返回 Type 基类的引用。但是，为了简单起见，在本章剩余的篇幅中，会把引用所指向的对象称为 Type 类型的对象（虽然从技术角度来说它是一个 BCL 内部的派生类型的对象）。

需要了解的有关 Type 的重要事项如下：  
①对于程序中用到的每一个类型，CLR 都会创建一个包含这个类型信息的 Type 类型的对象；  
②不管创建的类型有多少个实例，只有一个 Type 对象会关联到所有这些实例。

下图显示了一个运行的程序，它有两个 MyClass 对象和一个 OtherClass 对象。注意，尽管有两个 MyClass 的实例，只会有一个 Type 对象来表示它：

<div  align="center">  
<img src="https://s2.loli.net/2023/07/08/GSnWuZd9UPpOIfE.png" width = "60%" height = "60%" alt="图120 - 对于程序中使用的每一个类型，CLR都会实例化Type类型的对象"/>
</div>

可以从 Type 对象中获取有关类型的几乎所有信息。下表列出了 System.Type 类的部分成员：

| 成员 | 成员类型 | 描述 |
| :---- | :---- | :---- |
| Name | 属性 | 返回类型的名字 |
| Namespace | 属性 | 返回包含类型声明的命名空间 |
| Assembly | 属性 | 返回声明类型的程序集。如果类型是泛型的，返回定义这个类型的程序集 |
| GetFields | 方法 | 返回类型的字段列表 |
| GetProperties | 方法 | 返回类型的属性列表 |
| GetMethods | 方法 | 返回类型的方法列表 |

## 获取 Type 对象
本节学习，使用实例对象的 GetType 方法或者 typeof 运算符和类名来获取 Type 对象。object 类型包含了一个叫做 GetType 的方法，它返回对实例的 Type 对象的引用。由于每一个类型最终都是从 object 派生的，所以我们可以在任何类型的对象上使用 **GetType 方法**来获取它的 Type 对象，如下所示：`Type t = myInstance.GetType();`

下面的代码演示了如何声明一个基类以及从它派生的子类。Main 方法创建了每一个类的实例并且把这些引用放在了一个叫做 bca 的数组中以方便使用。在外层的 foreach 循环中，代码得到了 Type 对象并且输出类的名字，然后获取类的字段并输出。代码后的图演示了内存中的对象：

``` C#
using System;
using System.Reflection; //必须使用该命名空间

class BaseClass
{
    public int BaseField = 0;
}

class DerivedClass : BaseClass
{
    public int DerivedField = 0;
}

class Program
{
    static void Main( )
    {
        var bc = new BaseClass();
        var dc = new DerivedClass();

        BaseClass[] bca = new BaseClass[] { bc, dc };

        foreach (var v in bca)
        {
            Type t = v.GetType(); //获取类型

            Console.WriteLine($"Object type : { t.Name }");

            FieldInfo[] fi = t.GetFields(); //获取字段信息
            foreach (var f in fi)
                Console.WriteLine($" Field : { f.Name }");
            Console.WriteLine();
        }
    }
}
```

运行结果如下：

``` console
Object type : BaseClass
 Field : BaseField

Object type : DerivedClass
 Field : DerivedField
 Field : BaseField
```

<div  align="center">  
<img src="https://s2.loli.net/2023/07/08/IayVTBjoL7MAkeO.png" width = "60%" height = "60%" alt="图121 - 基类和派生类对象以及它们的 Type 对象"/>
</div>

还可以使用 **typeof 运算符**来获取 Type 对象。只需要提供类型名作为操作数，它就会返回 Type 对象的引用，如下所示：`Type t = typeof( DerivedClass );`

示例如下：

```C#
using System;
using System.Reflection; //必须使用该命名空间

namespace SimpleReflection
{
    class BaseClass
    {
        public int BaseField;
    }

    class DerivedClass : BaseClass
    {
        public int DerivedField;
    }

    class Program
    {
        static void Main()
        {
            Type tbc = typeof(DerivedClass); //获取类型
            Console.WriteLine($"Object type : { tbc.Name }");
            FieldInfo[] fi = tbc.GetFields();
            foreach (var f in fi)
                Console.WriteLine($" Field : { f.Name }");
        }
    }
}
```

运行结果如下：

``` console
Object type : DerivedClass
 Field : DerivedField
 Field : BaseField
```

## 什么是特性
**特性 attribute** 是一种允许我们向程序的程序集增加元数据的语言结构。它是用于保存程序结构信息的某种特殊类型的类：  
①将应用了特性的程序结构 program construct 叫做目标 target ；  
②设计用来获取和使用元数据的程序（比如对象浏览器）叫做特性的消费者 consumer ；  
③ .NET 预定了很多特性，我们也可以声明自定义特性。

下图是使用特性中相关组件的概览，并且演示了如下有关特性的要点：  
①我们在源代码中将特性应用于程序结构；  
②编译器获取源代码并且从特性产生元数据，然后把元数据放到程序集中；  
③消费者程序可以获取特性的元数据以及程序中其他组件的元数据。注意，编译器同时生产和消费特性。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/08/CFOw2pD6xrQIb5G.png" width = "60%" height = "60%" alt="图122 - 创建和使用特性的相关组件"/>
</div>

根据惯例，特性名使用 Pascal 命名法并且以 Attribute 后缀结尾。当为目标应用特性时，可以不使用后缀。例如，对于 SerializableAttribute 和 MyAttributeAttribute 这两个特性，在把它们应用到结构时可以使用 Serializable 和 MyAttribute 短名称。

## 应用特性
特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集。我们可以通过把特性应用到结构来实现：  
①通过在结构前放置**特性片段 attribute section** 来应用特性；  
②**特性片段**由方括号包围特性名和参数列表（可以没有）构成。

例如，下面的代码演示了两个类的开始部分。最初的几行代码演示了把一个叫做 Serializable 的特性应用到 MyClass 。注意，Serializable 没有参数列表。第二个类的声明有一个叫做 MyAttribute 的特性，它有一个带有两个 string 参数的参数列表：

``` C#
[ Serializable ] //特性
public class MyClass
{ ...

[ MyAttribute("Simple class", "Version 3.57") ] //带有参数的特性
public class MyOtherClass
{ ...
```

有关特性需要了解的重要事项如下：  
①大多数特性只应用于直接跟随在一个或多个特性片段后的结构；  
②应用了特性的结构称为被特性装饰（ decorated 或 adorned ）。

## 预定义的特性
本节介绍几个 .NET 预定义特性
### Obsolete 特性
一个程序可能在其生命周期中经历多次发布，而且很可能延续多年。在程序生命周期的后半部分，程序员经常需要编写类似功能的新方法替换老方法。出于多种原因，你可能不想再使用那些调用过时的旧方法的老代码，而只想用新编写的代码调用新方法。

如果出现这种情况，你肯定希望稍后操作代码的团队成员或程序员也只使用新代码。要警告他们不要使用旧方法，可以使用 Obsolete 特性将程序结构标注为过期的，并且在代码编译时显示有用的警告消息。以下代码给出了一个示例：

``` C#
class Program
{
    [Obsolete("Use method SuperPrintOut")] //将特性应用到方法
    static void PrintOut(string str) {
        Console.WriteLine(str);
    }
    static void Main(string[] args) {
        PrintOut("Start of Main"); //调用 obsolete 方法
    }
}
```

注意，即使 PrintOut 被标注为过期，Main 方法还是调用了它。代码编译也运行得很好，并且产生了如下的输出：

``` console
Start of Main
```

不过，在编译的过程中，编译器产生了下面的 CS0618 警告消息来通知我们正在使用一个过期的结构:`[CS0618] “Program.PrintOut(string)”已过时:“Use method SuperPrintOut”`

Obsolete 特性的另外一个重载接受了 bool 类型的第二个参数。这个参数指定目标是否应该被标记为错误而不仅仅是瞥告。以下代码指定了它应被标记为错误：

``` C#
[ Obsolete("Use method SuperPrintOut", true) ] //标记为错误，将特性应用到方法
static void PrintOut(string str)
{ ...
```

### Conditional 特性
Conditional 特性允许我们包括或排斥特定方法的所有调用。要使用 Conditional 特性，将其应用于方法声明并把编译符作为参数：  
①如果定义了编译符号，那么编译器会包含所有调用这个方法的代码，这和普通方法没有什么区别；  
②如果没有定义编译符号，那么编译器会忽略代码中这个方法的所有调用；  
③定义方法的 CIL 代码本身总是会包含在程序集中。只是调用代码会被插入或忽略；  
④除了在方法上使用 Conditional 特性之外，还可以在类上使用它，只要该类派生自 Attribute 类。这里不会介绍 Conditional 特性的这种用法。

在方法上使用 Conditional 特性的规则如下：  
①该方法必须是类或结构体的方法；  
②该方法必须是 void 类型；  
③该方法不能被声明为 override，但可以标记为 virtual；  
④该方法不能是接口方法的实现。

例如，在如下的代码中，Conditional 特性被应用到一个叫作 TraceMessage 的方法的声明上。特性只有一个参数，在这里是字符串 DoTrace 。  
①当编译器编译这段代码时，它会检査是否定义了一个名为 DoTrace 的编译符号；  
②如果定义了 DoTrace ，编译器就会像往常一样在代码中包含所有对 TraceMessage 方法的调用；  
③如果没有定义 DoTrace 编译符号，编译器就不会输出任何对 TraceMessage 的任何调用代码。

``` C#
[Conditional( "DoTrace" )] //编译符号
static void TraceMessage(string str)
{
    Console.WriteLine(str);
}
```

***Conditional 特性的示例***  
以下代码演示了一个使用 Conditional 特性的完整示例：  
①Main 方法包含了两个对 TraceMessage 方法的调用；  
②TraceMessage 方法的声明被用 Conditional 特性装饰，它带有 DoTrace 编译符号作为参数。因此，如果 DoTrace 被定义，那么编译器就会包含对 TraceMessage 所有调用的代码；  
③由于代码的第一行定义了叫做 DoTrace 的编译符，编译器会包含两个 TraceMessage 的调用代码。

``` C#
#define DoTrace
using System;
using System.Diagnostics;

namespace AttributesConditional
{
    class Program
    {
        [Conditional( "DoTrace" )]
        static void TraceMessage(string str)
        { Console.WriteLine(str); }

        static void Main( )
        {
            TraceMessage("Start of Main");
            Console.WriteLine("Doing work in Main.");
            TraceMessage("End of Main");
        }
    }
}
```

运行结果如下：  

``` console
Start of Main
Doing work in Main.
End of Main
```

如果注释掉第一行来取消 DoTrace 的定义，编译器就不再会插人两次对 TraceMessage 的调用代码。这次，如果我们运行程序，就会产生如下输出：

``` console
Doing work in Main.
```

### 调用者信息特性
利用调用者信息特性可以访问文件路径、代码行数、调用成员的名称等源代码信息。  
①这三个特性名称为 CallerFilePath 、CallerLineNumber 和 CallerMemberName；  
②这些特性只能用于方法中的可选参数。

下面的代码声明了一个名为 MyTrace 的方法，它在三个可选参数上使用了这三个调用者信息特性。如果调用方法时显式指定了这些参数，则会使用真正的参数值。但在下面所示的 Main 方法中调用时，没有显式提供这些值，因此系统将会提供源代码的文件路径、调用该方法的代码行数和调用该方法的成员名称。

``` C#
using System;
using System.Runtime.CompilerServices;

public static class Program
{
    public static void MyTrace( string message,
                                [CallerFilePath] string fileName = "",
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerMemberName] string callingMember = "" )
    {
        Console.WriteLine($"File: { fileName }");
        Console.WriteLine($"Line: { lineNumber }");
        Console.WriteLine($"Called From: { callingMember }");
        Console.WriteLine($"Message: { message }");
    }

    public static void Main()
    {
        MyTrace( "Simple message" );
    }
}
```

运行结果如下：

``` console
File: C:\Users\XXXX\XXXX\XXXX\Program.cs
Line: 19
Called From: Main
Message: Simple message
```

### DebuggerStepThrough 特性
我们在单步调试代码时，常常希望调试器不要进入某些方法。我们只想执行该方法，然后继续调试下一行。DebuggerStepThrough 特性告诉调试器在执行目标代码时不要进入该方法调试。

在我自己的代码中，这是最有用的特性。有些方法很小并且毫无疑问是正确的，在调试时对其反复单步调试只能徒增烦恼。但使用该特性时要十分小心，因为你并不想排除那些可能含有 bug 的代码。

关于 DebuggerStepThrough 要注意以下两点：  
①该特性位于 System.Diagnostics 命名空间；  
②该特性可用于类、结构、构造函数、方法或访问器。

下面这段编造的代码在一个访问器和一个方法上使用了该特性。你会发现，调试器调试这段代码时不会进入 IncrementFields 方法或 X 属性的 set 访问器。

``` C#
using System;
using System.Diagnostics; //DebuggerStepThrough特性所需的

class Program
{
    int x = 1;
    int X
    {
        get { return x; }
        [DebuggerStepThrough] //不进入set访问器
        set
        {
            x = x * 2;
            x += value;
        }
    }

    public int Y { get; set; }

    public static void Main()
    {
        Program p = new Program();
        p.IncrementFields();
        p.X = 5;
        Console.WriteLine( $"X = { p.X }, Y = { p.Y }" );
    }

    [DebuggerStepThrough] //不进入这个方法
    void IncrementFields()
    {
        X++; Y++;
    }
}
```

### 其他预定义特性
.NET 框架预定义了很多编译器和 CLR 能理解和解释的特性，下表列出了一些。在表中使用了不带 Attribute 后缀的短名称。例如，CLSCompliant 的全名是 CLSCompliantAttribute 。

| 特性 | 意义 |
| :---- | :---- |
| CLSCompliant | 声明公开暴露的成员应该被编译器检测其是否符号CLS。兼容的程序集可以被任何兼容.NET的语言使用 |
| Serializable | 声明结构可以被序列化 |
| NonSerialized | 声明结构不能被序列化 |
| DLLImport | 声明是非托管代码实现的 |
| WebMethod | 声明方法应该被作为 XML Web 服务的一部分暴露 |
| AttributeUsage | 声明特性能应用于什么类型的程序结构。将这个特性应用到特性声明上 |

## 关于应用特性的更多内容
本节介绍特性的一些其他使用方式。

### 多个特性
可以为单个结构应用多个特性：  
①多个特性可以使用下面任何一种格式列出：  
&emsp;&emsp;- 独立的特性片段一个接一个。通常，它们彼此叠加，位于不同的行中；  
&emsp;&emsp;- 单个特性片段，特性之间使用逗号分隔。  
②可以以任何次序列出特性。

例如，下面的两个代码片段显示了应用多个特性的两种方式。两个片段的代码是等价的。

``` C#
[ Serializable ] //多层结构
[ MyAttribute("Simple class", "Version 3.57") ]

[ MyAttribute("Simple class", "Version 3.57"), Serializable ] //逗号分隔
```

### 其他类型的目标
除了类，还可以将特性应用到诸如字段和属性等其他程序结构。以下的声明显示了字段上的特性以及方法上的多个特性：

``` C#
[MyAttribute("Holds a value", "Version 3.2")] //字段上的特性
public int MyField;

[Obsolete] //方法上的特性
[MyAttribute("Prints out a message.", "Version 3.6")]
public void PrintOut()
{
...
```

还可以显式地标注特性，从而将它应用到特殊的目标结构。要使用**显式目标说明符**，在特性片段的开始处放置目标类型，后面跟冒号。例如，如下的代码用特性装饰方法，并且还把特性应用到返回值上：

``` C#
[method: MyAttribute("Prints out a message.", "Version 3.6")] //显式目标说明符
[return: MyAttribute("This value represents ...", "Version 2.3")]
public long ReturnSetting()
{
    ...
```

C# 语言定义了10个标准的特性目标：event； field； method； param； property； return； type； typevar； assembly； module。大多数目标名可以自解释的，而 type 覆盖了类、结构、委托、枚举和接口。 typevar 目标名称为使用泛型的结构指定类型参数。

### 全局特性
还可以通过使用 assembly 和 module 目标名称来使用显式目标说明符把特性设置在程序集或模块级別。有关程序集级别的特性的要点如下：  
①程序集级别的特性必须放置在任何命名空间之外，并且通常放置在 AssemblyInfo.cs 文件中；  
②AssemblyInfo.cs 文件通常包含有关公司、产品以及版权信息的元数据。

如下的代码行摘自 AssemblyInfo.cs 文件：

``` C#
[assembly: AssemblyTitle("SuperWidget")]
[assembly: AssemblyDescription("Implements the SuperWidget product.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("McArthur Widgets, Inc.")]
[assembly: AssemblyProduct("Super Widget Deluxe")]
[assembly: AssemblyCopyright("Copyright © McArthur Widgets 2012")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
```

## 自定义特性
特性是一种特殊的类：  
①用户自定义的特性类叫做自定义特性；  
②所有特性类都派生自 System.Attribute 。

### 声明自定义特性
总体来说，声明一个特性类和声明其他类一样。然而，有一些事项值得注意，如下所示：  
①要声明一个自定义特性，需要做如下工作：  
&emsp;&emsp;- 声明一个派生自 System.Attribute 的类；
&emsp;&emsp;- 给它起一个以后缀 Attribute 结尾的名字。
②安全起见，通常建议你声明一个 sealed 的特性类（密封类，不能被继承）。

例如，下面的代码显示了 MyAttributeAttribute 特性的声明的开始部分：

``` C#
public sealed class MyAttributeAttribute : System.Attribute //特性名MyAttributeAttribute带后缀Attribute
{
...
```

由于特性持有目标的信息，所有特性类的公共成员只能是：①字段；②属性；③构造函数

### 使用特性的构造函数
特性和其他类一样，有构造函数。每一个特性必须至少有一个公共构造函数：  
①和其他类一样，如果你不声明构造函数，编译器会为你产生一个隐式、公共且无参的构造函数；  
②特性的构造函数和其他构造函数一样，可以被重载；  
③声明构造函数时必须使用类全名，包括**后缀**。我们只可以在应用特性时使用短名称。

如下，如果下面的构造函数名字没有后缀，编译器会产生一个错误消息：  

``` C#
public MyAttributeAttribute(string desc, string ver) //包含后缀 Suffix
{
    Description = desc;
    VersionNumber = ver;
}
```

### 指定构造函数
当我们为目标应用特性时，其实是在指定应该使用哪个构造函数来创建特性的实例。列在特性应用中的参数其实就是构造函数的参数。

例如，在下面的代码中，MyAttribute 被应用到一个字段和一个方法上。对于字段，声明指定了使用单个字符串参数的构造函数。对于方法，声明指定了使用两个字符串参数的构造函数。

``` C#
[MyAttribute("Holds a value")] //使用一个字符串的构造函数
public int MyField;

[MyAttribute("Version 1.3", "Galen Daniel")] //使用两个字符串的构造函数
public void MyMethod()
{ ...
```

特性构造函数的其他要点如下：  
①在应用特性时，构造函数的实参必须是在编译时能确定值的常量表达式；  
②如果应用的特性构造函数没有参数，可以省略圆括号。例如，如下代码的两个类都使用 MyAttr 特性的无参构造函数。两种形式的意义是相同的。

``` C#
[MyAttr]
class SomeClass ...

[MyAttr()]
class OtherClass ...
```

### 使用构造函数
和其他类一样，我们不能显式调用构造函数。特性的实例创建后，只有特性的消费者访问特性时才能调用构造函数。这一点与其他类的实例很不相同，这些实例都创建在使用对象创建表达式的位置。应用一个特性是一条声明语句，它不会决定什么时候构造特性类的对象。

下图比较了普通类构造函数的使用和特性的构造函数的使用：  
①命令语句 imperative statement 的实际意义是："在这里创建新的类"
②声明语句 declarative statement 的意义是："这个特性和这个目标相关联，如果需要构造特性，使用这个构造函数"。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/09/AFYQLha2wR4PEgG.png" width = "70%" height = "70%" alt="图123 - 比较构造函数的使用"/>
</div>

### 构造函数中的位置参数和命名参数
和普通类的方法与构造方法相似，特性的构造函数同样可以使用位置参数和命名参数。如下代码显示了使用一个位置参数和两个命名参数来应用一个特性：

``` C#
//第一个为位置参数，第二、三个为命名参数
[MyAttribute("An excellent class",Reviewer="Amy McArthur"，Ver="0.7.15.33")]
```

下面的代码演示了特性类的声明以及为 MyClass 类应用特性。注意，构造函数的声明只列出了一个形参，但我们可通过命名参数给构造函数3个实参。两个命名参数设置了字段 Ver 和 Reviewer 的值：

``` C#
public sealed class MyAttributeAttribute : System.Attribute
{
    public string Description;
    public string Ver;
    public string Reviewer;

    public MyAttributeAttribute(string desc) //一个形参
    {
        Description = desc;
    }
}

[MyAttribute("An excellent class", Reviewer="Amy McArthur", Ver="7.15.33")]
class MyClass
{
...
}
```

> 和方法一样，构造函教需要的任何位置参数都必须放在命名参数之前。

### 限制特性的使用
我们已经看到了可以为类应用特性。而特性本身就是类，有一个很重要的预定义特性可以应用到自定义特性上，那就是 AttributeUsage 特性。我们可以使用它来限制将特性使用在某个目标类型上。

例如，如果我们希望自定义特性 MyAttribute 只能应用到方法上，那么可以以如下形式使用 AttributeUsage ：

``` C#
[ AttributeUsage( AttributeTargets.Method ) ] //只针对方法
public sealed class MyAttributeAttribute : System.Attribute
{ ...
```

AttributeUsage 有3个重要的公共属性，如下表所示。表中显示了属性名和属性的含义。对于后两个属性，还显示了它们的默认值：  

| 名字 | 意义 | 默认值 |
| :---- | :---- | :---- |
| ValidOn | 保存能应用特性的目标类型的列表。构造函数的第一个参数必须是 AttributeTargets 类型的枚举值 | N/A |
| Inherited | 一个布尔值，它指示特性是否可被装饰类型的派生类所继承 | true |
| AllowMultiple | 一个布尔值，指示目标上是否可应用特性的多个实例的 | false |

***AttributeUsage 的构造函数***
AttributeUsage 的构造函数接受单个位置参数，该参数指定了可使用特性的目标类型。它用这个参数来设置 ValidOn 属性，可接受的目标类型是 AttributeTargets 枚举的成员。AttributeTargets 枚举的完整成员：All； Assembly； Class； Constructor； Delegate； Enum； Event； Field； GenericParameter； Interface； Method； Module； Parameter； Property； ReturnValue； Struct。

可以通过使用按位或运算符来组合使用类型。例如，在下面的代码中，被装饰的特性只能应用到方法和构造函数上：

``` C#
[ AttributeUsage( AttributeTargets.Method | AttributeTargets.Constructor ) ]
public sealed class MyAttributeAttribute : System.Attribute
{ ...
```

当为特性声明应用 AttributeUsage 时，构造函数至少需要一个必需的参数，参数包含的目标类型会保存在 ValidOn 中。还可以通过使用命名参数有选择性地设置 Inherited 和 AllowMultiple 属性。如果不设置，它们会保持如之前所示的默认值。

作为示例，下面一段代码指定了 MyAttribute 的如下方面：  
①MyAttribute 能且只能应用到类上；  
②MyAttribute 不会被应用它的派生类所继承；  
③不能在同一个目标上应用 MyAttribute 的多个实例。

``` C#
[ AttributeUsage( AttributeTargets.Class, //必需的位置参数
                    Inherited = false, //可选的命名参数
                    AllowMultiple = false ) ] //可选的命名参数
public sealed class MyAttributeAttribute : System.Attribute
{ ...
```

### 自定义特性的最佳实践
强烈推荐编写自定义特性时参考如下实践：  
①特性类应该表示目标结构的某些状态；  
②如果特性需要某些字段，可以通过包含具有位置参数的构造函数来收集数据，可选字段可以采用命名参数按需初始化；  
③除了属性之外，不要实现公共方法或其他函数成员；  
④为了更安全，把特性类声明为 sealed ；  
⑤在特性声明中使用 AttributeUsage 来显式指定特性目标组。

如下代码演示了这些准则：

``` C#
[AttributeUsage( AttributeTargets.Class )]
public sealed class ReviewCommentAttribute : System.Attribute
{
    public string Description { get; set; }
    public string VersionNumber { get; set; }
    public string ReviewerID { get; set; }

    public ReviewCommentAttribute(string desc, string ver)
    {
        Description = desc;
        VersionNumber = ver;
    }
}
```

## 访问特性
可以使用 Type 对象来访问自定义特性。Type 的两个方法（IsDefined 和 GetCustomAttributes）在这里非常有用。

### 使用 IsDefined 方法
可以使用 Type 对象的 IsDefined 方法来检测某个特性是否应用到了某个类上。

例如，以下的代码声明了一个特性类 MyClass ，并且作为自己的特性消费者在程序中访问被声明和应用的特性。代码的开始处是 MyAttribute 特性和应用特性的 MyClass 类的声明。这段代码做了下面的事情：  
①首先，Main 创建了类的一个对象。然后通过使用从 object 基类继承的 GetType 方法获取了 Type 对象的一个引用；  
②有了 Type 对象的引用，就可以调用 IsDefined 方法来判断 ReviewComment 特性是否应用到了这个类：  
&emsp;&emsp;- 第一个参数接受需要检査的特性的 Type 对象；  
&emsp;&emsp;- 第二个参数是 bool 类型的，它指示是否搜索 MyClass 的继承树来查找这个特性。

``` C#
[AttributeUsage(AttributeTargets.Class)]
public sealed class ReviewCommentAttribute : System.Attribute
{... }

[ReviewComment("Check it out", "2.4")]
class MyClass { }

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass(); //创建类实例
        Type t = mc.GetType(); //从实例中获取类型对象
        bool isDefined = //创建特性的类型
            t.IsDefined(typeof(ReviewCommentAttribute), false);

        if( isDefined )
            Console.WriteLine($"ReviewComment is applied to type { t.Name }");
    }
}
```

运行结果如下：

``` console
ReviewComment is applied to type MyClass
```

### 使用 GetCustomAttributes 方法
Type 类的 GetCustomAttributes 方法返回应用到结构上的特性的数组：  
①实际返冋的对象是 object 的数组，因此我们必须将它强制转换为相应的特性类型；  
②布尔参数指定是否搜索继承树来査找特性：`object[] AttArr = t.GetCustomAttributes(false);`  
③调用 GetCustomAttributes 方法后，每一个与目标相关联的特性的实例就会被创建。

下面的代码使用了前面的示例中相同的特性和类声明。但是，本例中，它不检测特性是否应用到了类上，而是获取应用到类的特性的数组，然后遍历它们，输出它们的成员的值。

``` C#
using System;

[AttributeUsage( AttributeTargets.Class )]
public sealed class MyAttributeAttribute : System.Attribute
{
    public string Description { get; set; }
    public string VersionNumber { get; set; }
    public string ReviewerID { get; set; }

    public MyAttributeAttribute( string desc, string ver )
    {
        Description = desc;
        VersionNumber = ver;
    }
}

[MyAttribute( "Check it out", "2.4" )]
class MyClass
{
}

class Program
{
    static void Main()
    {
        Type t = typeof( MyClass );
        object[] AttArr = t.GetCustomAttributes( false );

        foreach ( Attribute a in AttArr )
        {
            MyAttributeAttribute attr = a as MyAttributeAttribute;
            if ( null != attr )
            {
                Console.WriteLine($"Description : { attr.Description }");
                Console.WriteLine($"Version Number : { attr.VersionNumber }");
                Console.WriteLine($"Reviewer ID : { attr.ReviewerID }");
            }
        }
    }
}
```

运行结果如下：

``` console
Description : Check it out
Version Number : 2.4
Reviewer ID :
```


# 第二十六章 C# 6.0 和 C# 7.0 新增的内容
## 字符串插值 C#6.0
字符串插值主要在第三章。

C#6.0使用了字符串插值简化了格式字符串。字符串插值不仅可以用在 Console.WriteLine 中，还可以使用在 String.Format，如下代码所示：

``` C#
string name = "Aiden";
string technology = "Cold Fusion";
string s;

s = String.Format("{0} is working on {1}.", name, technology); //格式字符串
Console.WriteLine(s);

s = String.Format($"{ name } is working on { technology }."); //字符串插值
Console.WriteLine(s);
```

## 自动属性初始化语句
详见第七章，自动属性是属性声明的一种简写形式，由编译器生成或管理一个不可见的、关联到这个属性的后备字段。之前，自动属性只能在构造函数或者方法中初始化，现在也可以像普通的属性一样在声明的时候初始化：

``` C#
public double Length { get; set; } = 42.5;

//可以对以 internal、protected、internal protected 或者 private 修饰的 setter 使用
private double Length { get; private set; } = 42.5;

//可以适用于只读自动属性
public double Length { get; } = 42.5;

//可以使用任何可以被解析为字面量的表达式
const double myConstant = 42;
public double Length { get; set; } = myConstant + .5;

//但是初始化语句不能引用非静态的属性、字段或者方法
private double myField = 42.5;
public double Length { get; set; } = myField; //编译错误
private double myProperty { get; set; } = 42.5;
public double Length { get; set; } = myProperty; //编译错误
```

集合 List 是自动属性初始化的最佳例子：

``` C#
public List<double> Areas { get; set; } = new List<double>();
```

结构体中的静态属性也可以使用自动属性初始化语句：

``` C#
struct MyStruct
{
    static double Length { get; set; } = 42.5;
    double Length2 { get; set; } = 42.5; //编译错误，非静态
}
```

## 只读自动属性 C#6.0
只读自动属性详见第七章。

之前，想要声明一个只读属性，需要私有化 setter。虽然阻止了类的使用者改变属性值，但是仍然可以在类内部的其他地方改变它：`public string CompanyName { get; private set; }`

现在可以去掉整个 setter。在这种情况下，属性必须在声明时或者在构造函数中初始化：`public string CompanyName { get; }`

在类和结构体中都可以使用只读自动属性。

## 表达式函数体成员 C#6.0和C#7.0
之前，所有方法和 get 属性的主体部分都是由包含在大括号内的代码组成的，并且必须有大括号。但是现在，如果函数体是由单个表达式构成的，我们可以使用称为表达式函数体的短格式语法。表达式函数体成员有如下重要特征：  
①代码必须是由一个表达式组成的，以分号结束；  
&emsp;&emsp;- 对于有返回值的成员类型，表达式的值就是返回值。对于没有返回值的成员，不返回任何东西。  
②不能有开始和结束大括号；  
③在参数列表和构成函数体的表达式之间使用 Lambda 运算符（=>）；  
④在 C#6.0 中，这个功能可以用在方法和属性的 get 访问器中。C#7.0 将这个功能扩展到了构造函数、终结函数 finalizer、属性 set 访问器和索引器。

例如，下面的方法声明使用了之前的方法体语法，而没有使用表达式函数体语法。它由包含在大括号内的一个语句组成：

``` C#
public string GetWineGrowingRegion(string countryName, string regionName)
{
    return countryName + ":" + regionName;
}
```

使用表达式函数体格式，可以使用 Lambda 运算符重写为`public string GetWineGrowingRegion(string countryName, string regionName) => countryName + ":" + regionName;`

下面演示一个只读属性的例子：`public string MyFavoriteWineGrowingRegion => "Sonoma County";`

你不能对自动实现了读写操作的属性成员使用表达式函数体。在这种情况下，不能同时使用访问器列表和表达式函数体：

``` C#
public int AreaCode { get; set; } = 408;
public int CentralOfficeCode { get; set; } = 428;
public int LineNumber { get; set; } = 4208;

public string PhoneNumber { get; } //访问器列表
                    => $"({AreaCode}) {CentralOfficeCode}-{LineNumber}"; //编译错误

public string PhoneNumber //没有访问器列表
                    => $"({AreaCode}) {CentralOfficeCode}-{LineNumber}"; // OK
```

## using static C#6.0
using static 主要在第7章和第22章。

在C#6.0之前，使用类或结构体的静态成员，必须包含类或结构体的名称。之后，可以使用 using static 语句，关键字后面包含静态成员的类或者结构体的全名，这样就可以在使用静态成员时不用在前面加上类型名称。

## 空条件运算符 C#6.0
主要在下一章，第27章，讨论。

空条件运算符主要是为了阻止试图访问一个空对象的成员时抛出的空引用异常。如下：

``` C#
Student[] students = null;
int studentCount = students.Length; //产生异常
Student firstStudent = students[0]; //产生异常

//可以使用空条件运算符来避免空引用异常
int? studentCount = students?.Length;
Student firstStudent = students?[0];
```

## 在 catch 和 finally 块中使用 await C#6.0
在 C#5.0 引入 async/await 时，不能把 await 子句放在 catch 或 finally 块中。现在这个限制被解除了。

## nameof 运算符 C#6.0
nameof 运算符主要在第9章讨论。

nameof 是一个新的运算符，它接受一个参数，可以是变量名、类型名或者成员名。运算符返回代表参数名称的字符串。

## 异常过滤器 C#6.0
异常过滤器主要在第23章讨论。

## 索引初始化语句
本节是唯一讨论索引初始化语句的地方。

C#6.0 引入了新的语法来初始化带索引器的数据结构，比如字典 Dictionary 对象。

``` C#
//传统语法，集合初始化
var favoriteCities = new Dictionary<int, string>
{
    {0, "Oxford"},
    {1, "Paris"},
    {2, "Barcelona"}
};

//上段代码和下面等效，使用Add方法：
var favoriteCities = new Dictionary<int, string>();
favoriteCities.Add(0, "Oxford");
favoriteCities.Add(1, "Paris");
favoriteCities.Add(2, "Barcelona");

//因为字典对象有索引器，可以使用新的索引初始化语法：
var favoriteCities = new Dictionary<int, string>
{
    [0] = "Oxford",
    [1] = "Paris",
    [2] = "Barcelona"
};

//这种形式与下面等价：
var favoriteCities = new Dictionary<int, string>();
favoriteCities[0] = "Oxford";
favoriteCities[1] = "Paris";
favoriteCities[2] = "Barcelona";
```

集合初始化隐式地调用集合的 Add 方法，但索引初始化没有调用 Add 方法，而是给索引指定的元素赋值。这两种不同的差别如下：首先，集合初始化需要一个实现了 IEnumerable 接口的集合，还需要一个公有的 Add 方法。索引初始化则两个都不需要，它仅仅需要类或者结构体包含索引器，不需要实现 IEnumerable 接口或者可以没有 Add 方法。

Dictionary 既能使用集合初始化又能使用索引初始化，不能在一个语句中同时使用这两种语法。

## 集合初始化语句的扩展方法 C#6.0
本节是唯一讨论集合初始化扩展方法的地方。扩展方法详见第8章。

使用集合初始化创建集合：

``` C#
var customer1 = new Customer(Name = "Willem", Age = 35);
var customer2 = new Customer(Name = "Sandra", Age = 32);
//集合初始化
var customers = new List<Customer>() { customer1, customer2 };
```

集合初始化能够工作，是因为编译器在调用构造函数之后，又加入了调用 Add 方法的代码。其他 .NET 集合也都有 Add 函数，可以使用集合初始化。

假设定义一个自己的集合，在集合内部使用名称不同于 Add 的调用 Add 方法的方法：

``` C#
public class Subscriptions : IEnumerable<Customer>
{
    private List<Customer> _subscribers = new List<Customer>();

    public void Subscribe(Customer c)
    {
        _subscribers.Add(c);
    }

    ...
}
```

上述代码因为 Subscription 类没有 Add 方法，所以下面的代码会失败：`var customers = new Subscription() { customer1, customer2 };`

但是从 C# 6.0 开始，可以通过实现一个名为 Add 的扩展方法来调用 Subscription 类中的 Subscribe 方法，来实现集合初始化语句。但是注意，集合仍然需要支持 IEnumerable 接口：

``` C#
public static class SubscriptionExtensions
{
    public static void Add( this Subscriptions s, Customer c ) // Extension method
    {
        s.Subscribe( c );
    }
}

public class Customer
{ public string Name{ get; set; } public Customer( string name ) { Name = name; }}

public class Subscriptions : IEnumerable<Customer>
{
    private List<Customer> mSubscribers = new List<Customer>();

    public IEnumerator<Customer> GetEnumerator()
    { return mSubscribers.GetEnumerator(); }

    IEnumerator IEnumerable.GetEnumerator()
    { throw new System.NotImplementedException(); }

    public void Subscribe( Customer c )
    {
        mSubscribers.Add( c );
    }
}

class Program
{
    public static void Main()
    {
        var customer1 = new Customer( "Willem" );
        var customer2 = new Customer( "Sandra" );

        //集合初始化
        var customers = new Subscriptions() { customer1, customer2 };

        foreach ( Customer c in customers )
            WriteLine( $"Name: {c.Name}" );
    }
}
```

## 值元组
**值元组 ValueTuple** 主要在下一章介绍。

**元组 tuple** 是一个有序的元素集合，其中元素可以是相同或不同的数据类型。元组仅仅是通过使用圆括号包裹和逗号分隔的方式提供了引用和操作一组元素的方便方法：

``` C#
(string, int) CreateSampleTuple()
{
    return ("Paul", 39);
}

var myTuple = CreateSampleTuple();
Console.WriteLine($"Name: { myTuple.Item1 } Age: {myTuple.Item2}");
```

元组易于创造但是调用相对麻烦，因为元组的元素只能靠没有描述性的名称 Item1、Item2 等调用。另外，因为元组是类、引用类型，需要在堆上创建，并不在引用时候被垃圾机制回收。

C# 7.0 引入了 ValueTuple 的结构体，可以获得比元组更好的性能。此外，可以给属于 ValueTuple 的元素命名。

## is 模式匹配 C#7.0
**is 运算符**用来检测一个对象是不是某些类型。C#支持继承和接口实现，虽然不支持多继承，但是类可以实现任意多个接口。在这种复杂性下，is 运算符不仅能检测当前类的类型，还能检测任意层次的基类，以及是否支持任意指定的接口。示例如下：

``` C#
public interface IOne
{
    int SampleIntProperty { get; set; }
}
public interface ITwo
{
    int SampleIntProperty2 { get; set; }
}
public class BaseClass
{
    public string SampleStringProperty { get; set; }
}
public class DerivedClass : BaseClass, IOne, ITwo
{
    public int SampleIntProperty { get; set; }
    public int SampleIntProperty2 { get; set; }
}

class Program
{
    static void Main(string[] args)
    {
        var dc = new DerivedClass();
        if (dc is DerivedClass)
        { Console.WriteLine("Derived Class found"); }
        if (dc is BaseClass)
        { Console.WriteLine("Base Class found"); }
        if (dc is IOne)
        { Console.WriteLine("Interface One found"); }
        if (dc is ITwo)
        { Console.WriteLine("Interface Two found"); }
    }
}
```

运行结果如下：

``` console
Derived Class found
Base Class found
Interface One found
Interface Two found
```

若检测了一个给定对象是不是某种类型后，如果想要引用这种类型，就必须先转换成这种类型：

``` C#
if(myEmployee is Supervisor)
{
    var mySupervisor = (Supervisor)myEmployee;
    //继续调用父类成员
}

//也可以使用 as 运算符来实现转换：
var mySupervisor = myEmployee as Supervisor;
if (mySupervisor != null)
{
    //继续调用父类成员
}
```

在 C# 7.0中，is 运算符的类型语法已经简化，可以直接给检测类后的变量赋值。增强的 is 运算符不仅检测变量类型，如果变量通过了测试，还可以同时将其赋值给指定的新变量。这个新变量叫作**匹配变量 match variable**。

``` C#
if (myEmployee is Supervisor mySupervisor)
{
    //如果检测通过了，mySupervisor变量立即可以使用
    Console.WriteLine($"My supervisor’s name is { mySupervisor.Name }");
}
```

## switch 模式匹配 C#7.0
C#7.0 对 switch 语句做了很多重要的改进。switch 语句之前受限于编译时常量，包括 char、string、bool、integer等。现在可以使用任何类型进行检测，包括用户自定义的类型：class、struct、array、enum、delegate和interface。示例如下：

``` C#
using static System.Console;

public abstract class Investment
{
    public string Name { get; set; }
    public double MinPurchaseAmt { get; set; }
}

public class Stock : Investment { }
public class Bond : Investment { }
public class BankAccount : Investment { }
public class RealEstate : Investment { }

class Program
{
    static void Main()
    {
        var myStock = new Stock() { Name = "Tesla", MinPurchaseAmt = 1000 };
        var myBond = new Bond() { Name = "California Municipal", MinPurchaseAmt = 500 };
        var myBankAccount = new BankAccount() { Name = "ABC Bank", MinPurchaseAmt = 10 };
        var myBankAccount2 = new BankAccount() { Name = "XYZ Bank", MinPurchaseAmt = 20 };
        var myRealEstate =
                new RealEstate() { Name = "My Vacation Home", MinPurchaseAmt = 100_000 };

        CheckInvestmentType(myStock);
        CheckInvestmentType(myBond);
        CheckInvestmentType(myBankAccount);
        CheckInvestmentType(myBankAccount2);
        myBankAccount2 = null;
        CheckInvestmentType(myBankAccount2);
        CheckInvestmentType(myRealEstate);
    }

    public static void CheckInvestmentType (Investment investment)
    {
        switch (investment)
        {
            case Stock stock:
            WriteLine($"This investment is a stock named {stock.Name}");
            break;
            case Bond bond:
            WriteLine($"This investment is a bond named {bond.Name}");
            break;
            case BankAccount bankAccount when bankAccount.Name.Contains("ABC") :
            WriteLine($"This investment is my ABC Bank account");
            break;
            case BankAccount bankAccount:
            WriteLine($"This investment is any bank account other than ABC Bank");
            break;
            case null:
            WriteLine("For whatever reason, this investment is null. ");
            break;
            default:
            WriteLine("The default case will always be evaluated last. ");
            WriteLine("Even if its position is not last.");
            break;
        }
    }
}
```

运行结果如下：

``` console
This investment is a stock named Tesla
This investment is a bond named California Municipal
This investment is my ABC Bank account
This investment is any bank account other than ABC Bank
For whatever reason, this investment is null.
The default case will always be evaluated last.
Even if its position is not last.
```

所有类型模式都有一个隐含的 when 子句条件，即当类型不为 null 时。这可以防止 switch 语句中的第一个类型匹配空值，从而触发其 switch 块中的语句，产生意外结果。可以添加特殊的 case 语句来处理 null 的情况，也可以在默认块中处理。

与之前不同，case 语句的顺序现在很重要。现在必须将列表中所有特殊的情况放在普通情况之前，之前因为是常量，值总是互斥的，所以不重要。

## 表达式函数体成员的扩展 C#7.0
表达式函数体成员是指一种使用 Lambda 符号（=>）引入单行语句，而不是将其放在一组大括号中的语法。C#7.0使其允许在构造函数、析构函数以及属性和索引器的 get 和 set 访问器使用表达式函数体成员。示例如下：

``` C#
//构造函数
public MyClass (string var1) => this.Var1 = var1;

//析构函数
~MyClass() => Console.WriteLine( "Unmanaged resources have been released ");

public string Area
{
    get => mArea;
    set => mArea = value;
}
```

## throw 表达式 C#7.0
在C#7.0之前，throw 关键字只能在语句中使用，现在可以在一些需要表达式的场景下使用，包括条件表达式、空接合表达式和一些 Lambda 表达式。

throw 表达式最常用的例子是空接合运算符，空接合运算符详见下一章节，它有两个操作数，第一个操作数是可空的，当它解析为空时，就使用第二个非空的表达式：

``` C#
bool? success = LoadResource(); //可空类型
var resourceLoadResult =
        success ?? throw new InvalidOperationException("Resource load failed");
```


# 第二十七章 其他主题
## 字符串
BCL 提供了很多能让字符串操作变得更简单的类。C# 预定义的 string 类型代表了 .NET 的 System.String 类。关于字符串的重要事项如下：  
①字符串是 Unicode 字符数组；  
②字符串是**不可变的 immutable**，它们不能被修改。

string 类型有很多有用的字符串操作成员，下表列出了其中一些最有用的成员：

| 成员 | 类型 | 意义 |
| :---- | :---- | :---- |
| Length | 属性 | 返回字符串长度 |
| Concat | 静态方法 | 返回连接参数字符串后的字符串 |
| Contains | 方法 | 返回指示参数是否是对象字符串的子字符串的bool值 |
| Format | 静态方法 | 返回格式化后的字符串 |
| Insert | 方法 | 接受一个字符串和一个位置作为参数，创建并返回一个在指定位置插入了参数字符串的新的字符串对象副本 |
| Remove | 方法 | 返回对象字符串的副本，其中移除了一个子字符串 |
| Replace | 方法 | 返回对象字符串的副本，其中替换了一个子字符串 |
| Spilt | 方法 | 返回一个包含原始字符串的子字符串的字符串数组。对于每个输入参数，为方法提供一组分隔符来分隔目标子字符串 |
| Substring | 方法 | 获取对象字符串的子字符串 |
| ToLower | 方法 | 返回对象字符串的副本，其中所有字母字符都为小写 |
| ToUpper| 方法 | 返回对象字符串的副本，其中所有字母字符都为大写 |

从上表中的大多数方法的名字来看，好像它们都会改变字符串对象。其实，它们不会改变字符串而是返回了新的副本。对于一个 string ，任何“改变”都会分配一个新的不可变字符串。

## StringBuilder 类
**StringBuilder 类**可以帮助你动态、有效地产生字符串，并且避免创建许多副本：  
①StringBuilder 类是 BCL 的成员，位于 System.Text 命名空间中；  
②StringBuilder 对象是 Unicode 字符的可变数组。

例如，下面的代码声明并初始化了一个 StringBuilder 类型的字符串，然后输出了它的值。第四行代码通过替换初始字符串的一部分改变了实际对象：

``` C#
using System;
using System.Text;

class Program
{
    static void Main()
    {
        StringBuilder sb = new StringBuilder( "Hi there." );
        Console.WriteLine($"{ sb.ToString() }");

        sb.Replace( "Hi", "Hello" ); 
        Console.WriteLine($"{ sb.ToString() }"); 
    }
}
```

运行结果如下：

``` console
Hi there.
Hello there.
```

当依据给定的字符串创建了 StringBuilder 对象之后，类分配了一个比当前字符串长度更长的缓冲区。只要缓冲区能容纳对字符串的改变就不会分配新的内存。如果对字符串的改变需要的空间比缓冲区中的可用空间多，就会分配更大的缓冲区，并把字符串复制到其中。和原来的缓冲区一样，新的缓冲区也有额外的空间。

要获取 StringBuilder 对应的字符串内容，只需要调用它的 ToString 方法即可。

## 把字符串解析为数据值
①**解析 Parse** 允许我们接受表示值的字符串，并且把它转换为实际的类型值；  
②所有预定义的简单类型都有一个叫做 Parse 的静态方法，它接受一个表示值的字符串，并且把它转换为类型的实际值；  
③如果字符串无法解析，系统会抛出异常。

以下语句给出了一个使用 Parse 方法语法的示例。注意，Parse 是静态的，所以需要通过目标类型名来调用它：`double d1 = double.Parse("25.873");`

Parse 方法的缺点是如果不能把 string 成功转换为目标类型就抛出一个异常。**TryParse 方法**可以避免这个问题。有关 TryParse 需要知道的亟要事项如下：  
①每一个具有 Parse 方法的内置类型同样都有一个 TryParse 方法；  
②TryParse 方法接受两个参数并且返回一个 bool 值：  
&emsp;&emsp;- 第一个参数是你希望转换的字符串；  
&emsp;&emsp;- 第二个是指向目标类型变量的引用的 out 参数；  
&emsp;&emsp;- 如果 TryParse 成功，解析值被赋给 out 参数，它返回 true，否则返回 false。

``` C#
class Program
{
    static void Main( )
    {
        string parseResultSummary;
        string stringFirst = "28";
        int intFirst;

        bool success = int.TryParse( stringFirst, out intFirst );

        parseResultSummary = success
                                ? "was successfully parsed"
                                : "was not successfully parsed";

        Console.WriteLine($"String { stringFirst } { parseResultSummary }");

        string stringSecond = "vt750";
        int intSecond;

        success = int.TryParse( stringSecond, out intSecond );

        parseResultSummary = success
                                ? "was successfully parsed"
                                : "was not successfully parsed";
        Console.WriteLine($"String { stringSecond } { parseResultSummary }" );
    }
}
```

运行结果如下：

``` console
String 28 was successfully parsed
String vt750 was not successfully parsed
```

## 关于可空类型的更多内容
**可空类型 nullable type** 允许我们创建一个值类型变量并且可以标记为有效或无效，这样我们就可以有效地把值类型设置为 null 。可空类型总是基于另外一个已经被声明的类型。  
①可以从任何值类型创建可空类型，包括预定义的简单类型；  
②不能从引用类型或其他可空类型创建可空类型；  
③不能在代码中显式声明可空类型，只能声明可空类型的变量。之后我们会看到，编译器会隐式地创建可空类型。

要创建可空类型的变量，只需要在变量声明中的基础类型的名字后面加一个问号：`int? myInt=28;`

可空类型包含以下重要的只读属性：  
①HasValue 属性是 bool 类型，并且指示值是否有效；  
②Value 属性是和基础类型相同的类型并且返回变量的值，如果变量有效的话。

使用可空类型基本与使用其他类型的变量一样。读取可空类型的变量会返回其值。但是必须确保变量不是 null ，尝试读取一个 null 的变量会产生异常。  
①跟任何变量一样，要获取可空类型变量的值，使用名字即可；  
②要检测可空类型是否具有值，可以将它和 null 比较或者检查它的 HasValue 属性。

``` C#
int? myInt1 = 15;

if( myInt1 != null )
    Console.WriteLine("{0}", myInt1);
```

可空类型和相应的非可空类型之间可轻松实现转换。有关可空类型转换的重要事项如下：  
①非可空类型和相应的可空版本之间的转换是隐式的，也就是说，不需要强制转换；  
②可空类型和相应的非可空版本之间的转换是显式的。

``` C#
int? myInt1 = 15; //隐式转换
int regInt = (int) myInt1; //显式转换
```

### 空接合运算符
标准算术运算符和比较运算符同样也能处理可空类型。还有一个特别的运算符叫做**空接合运算符 null coalescing operator** ，它允许我们在可空类型变量为 null 时返回一个值给表达式。

空接合运算符由两个连续的问号组成，它有两个操作数：  
①第一个操作数是可空类型的变量；  
②第二个是相同基础类型的不可空值；  
③在运行时，如果第一个操作数运算后为 null ，那么第二个操作数就会被返回作为运算结果。

``` C#
int? myI4 = null;
Console.WriteLine("myI4: {0}", myI4 ?? -1);
myI4 = 10;
Console.WriteLine("myI4: {0}", myI4 ?? -1);
```

运行结果如下：

``` console
myI4: -1
myI4: 10
```

### 空条件运算符
如果有一个引用变量，它的值为空，并且尝试通过该空引用访问它的成员，那么程序会抛出 NullReferenceException 。避免这个问题可以使用**空条件运算符 null conditional operator**，空条件运算符为`?.`组成，它检查引用变量为空还是包含一个对象引用。如果为空，那么运算符返回空；如果不为空，那么访问成员。

``` C#
Student[] students = null;
int? studentCount = 5;

if ( students != null )
    studentCount = students.Length;
Console.WriteLine( $"studentCount: { studentCount }" );

studentCount = students?.Length; //使用空条件运算符
Console.WriteLine( $"studentCount: { studentCount }" );
```

运行结果如下：

``` console
studentCount: 5
studentCount:
```

空条件运算符的第二种形式用于数组或索引。在这种情况下，需要省略句点字符，并在问号后面紧跟索引指示器的左括号。下面一行代码演示了这种形式：`Student student = students?[7];`。该代码，若数组 students 不为空，则返回数组的第八个元素。如果数组 students 不为空，但是没有元素，则抛出 ArgumentOutOfRangeException。

由于空条件运算符的目的是检查是否为空，因此它只能应用于可以有空引用的对象。下面的代码将不会被编译。相反，将收到警告消息：运算符?不能用于 int 类型的操作数。

``` C#
int length = 7;
int strLength = length?.ToString()
```

空条件运算符可以进行链式调用，意味着只要任何空条件运算检测到空值，该过程就会短路并且不会计算下游调用，同时表达式返回 null。例如：`var supervisorPhoneNumber = Employees?[0].Supervisors?[0].PhoneNumbers?[0].ToString();`

当空条件运算符作用于返回值类型的成员时，它总是返回该类型的可空版本：`var studentCount = students?.Count;`：这个例子 studentCount 是 int? 类型。`int studentCount = students?.Count;`：因为 int? 不能隐式转换为 int ，该代码不会被编译。

如第14章所述，空条件运算符最常用的用法之一就是用于委托调用，如下：

``` C#
if(handler != null)
{
    handler(this, args)
}

//上述三行代码可以修改为下面一行代码：
handler?.Invoke(this, args);
```

将空条件运算符与空接合运算符结合使用也很有用：`int studentCount = Students?.Count ?? 0;`

### 使用可空用户自定义类型
至此，我们已经看到了预定义的简单类型的可空形式。我们还可以创建用户自定义值类型的可空形式。这就引出了在使用简单类型时没有遇到的其他问题。

主要问题是访问封装的基础类型的成员。一个可空类型不直接暴露基础类型的任何成员。例如，来看看下面的代码和下图中它的表示形式。代码声明了一个叫做 MyStruct 的结构（值类型），它有两个公共字段。  
①由于结构的字段是公有的，所以它可以被结构的任何实例所访问到，如下图左部分所示；  
②然而，结构的可空形式只通过 **Value 属性**暴露基础类型，它不直接暴露它的任何成员。尽管这些成员对结构来说是公有的，但是它们对可空类型来说不是公有的，如下图右部分所示。

``` C#
struct MyStruct //声明结构
{
    public int X; //字段
    public int Y; //字段
    public MyStruct(int xVal, int yVal) //构造函数
    { X = xVal; Y = yVal; }
}

class Program {
    static void Main()
    {
        MyStruct? mSNull = new MyStruct(5, 10);
        ...
```

<div  align="center">  
<img src="https://s2.loli.net/2023/07/29/8cO7ExBpiYJVFQ9.png" width = "70%" height = "70%" alt="图124 - 结构成员的可访问性不同于可空类型"/>
</div>

例如，以下代码使用之前声明的结构并创建了结构和它对应的可空类型的变量。在代码的第三行和第四行中，我们直接读取结构变量的值。在第五行和第六行中，就必须从可空类型的 Value 属性返回的值中进行读取：

``` C#
MyStruct mSStruct = new MyStruct(6, 11); //结构变量
MyStruct? mSNull = new MyStruct(5, 10); //可空类型的变量

Console.WriteLine("mSStruct.X: {0}", mSStruct.X); //结构访问
Console.WriteLine("mSStruct.Y: {0}", mSStruct.Y);

Console.WriteLine("mSNull.X: {0}", mSNull.Value.X); //可空类型访问
Console.WriteLine("mSNull.Y: {0}", mSNull.Value.Y);
```

可空类型通过一个叫作 `System.Nullable<T>` 的 .NET 类型来实现，它使用了 C# 的泛型特性。C# 可空类型的问号语法是创建 Nullable&lt;T&gt; 类型变量的快捷语法，其中 T 是基础类型。 Nullable&lt;T&gt; 接受了基础类型并把它嵌入结构中，同时给结构提供可空类型的属性、方法和构造函数。

可以使用 Nullable&lt;T&gt; 这种泛型语法，也可以使用 C# 的快捷语法。以下代码使用Nullable&lt;T&gt; 语法为之前示例中声明的 MyStruct 结构创建一个叫做 mSNull 的Nullable&lt;MyStruct&gt; 类型的变量：`Nullable<MyStruct> mSNull = new Nullable<MyStruct>();`，下面的代码使用了问号语法，语义上完全等同于 Nullable&lt;T&gt; 语法：`MyStruc? mSNull = new MyStruct();`

## Main 方法
每一个 C# 程序都必须有一个入口点，一个必须叫做 Main 的方法。

在贯穿本书的示例代码中，都使用了一个不接受参数并且也不返回值的 Main 方法。然而，一共有4种形式的 Main 可以作为程序的入口点。这些形式如下：  
①`static void Main {…}`  
②`static void Main(string[] args) {…}`  
③`static int Main() {…}`  
④`static int Main(string[] args) {…}`

前面两种形式在程序终止后都不返回值给执行环境。后面两种形式则返回 int 值。如果使用返回值，通常用于报告程序的成功或失败，0通常用于表示成功。

第二种和第四种形式允许我们在程序启动时从命令行向程序传入实参。命令行参数的一些重要特性如下：  
①可以有0个或多个命令行参数。即使没有参数，args参数也不会是 null ，而是一个没有元素的数组；  
②参数由空格或制表符隔开；  
③每一个参数都被程序解释为字符串，但是你无须在命令行中为参数加上引号。

例如，下面叫做 CommandLineArgs 的程序接受了命令行参数并打印了每一个提供的参数：

``` C#
class Program
{
    static void Main(string[] args)
    {
        foreach (string s in args)
            Console.WriteLine(s);
    }
}
```

可以从 Windows 命令提示符中运行这个程序。如下命令行使用5个参数执行 CommandLineArgs 程序：`CommandLineArgs Jon Peter Beth Julia Tammi`

运行结果如下：

``` console
Jon
Peter
Beth
Julia
Tammi
```

其他需要了解的有关 Main 的重要事项如下：  
①Main 必须总是声明为 static ；
②Main 可以在类或结构中声明。

一个程序只可以包含 Main 的4种可用入口点形式中的一种声明。当然，如果你声明其他方法的名称为Main，只要它们不是4种入口点形式中的一种就是合法，但是，这样做是非常容易混淆的。

### Main 的可访问性
Main 可以被声明为 public 或 private。  
①如果 Main 被声明为 private ，其他程序集就不能访问它，只有执行环境才能启动程序；  
②如果 Main 被声明为 public ，其他程序集就可以调用它。

然而，无论 Main 声明的访问级或所属类或结构的访问级別是什么，操作系统总是能访问 Main 。

默认情况下，当 Visual Studio 创建了一个项目时，它就创建了一个程序框，其中的 Main 是隐式 private 。如果需要，你随时可以添加 public 修饰符。

## 文档注释
文档注释特性允许我们以 XML 元素的形式在程序中包含文档（第20章介绍过 XML ）。Visual Studio会帮助我们插入元素，以及从源文件中读取它们并复制到独立的 XML 文件中。

XML 注释的使用，包括如下步骤：  
①可以使用 Visual Studio 来产生嵌入了 XML 的源文件。Visual Studio 会自动插入大多数重要的 XML 元素；  
②Visual Studio 从源文件中读取 XML 并且复制 XML 代码到新的文件；  
③另外一个叫做文档编译器的程序可以获取 XML 文件并且从它产生各种类型的文档文件。

之前的 Visual Studio 版本包含了基本的文档编译器，但是它在 Visual Studio 2005 发布之前被删除了。微软公司开发了一个叫做 Sandcastle 的新文档编译器，它已经被用来生成 .NET 框架的文档。

### 插入文档注释
文档注释以3个连续的正斜杠开头。

例如，以下代码中前4行就是有关类声明的文档注释。这里使用&lt;summary&gt; XML 标签。在字段声明之上有3行来说明这个字段，还是使用&lt;summary&gt;标签。

``` C#
/// <summary> 类的开始 XML 标签
/// This is class MyClass, which does the following wonderful things, using
/// the following algorithm. ... Besides those, it does these additional
/// amazing things.
/// </summary> 关闭 XML 标签

class MyClass
{
    /// <summary> 字段的开始 XML 标签
    /// Field1 is used to hold the value of ...
    /// </summary> 关闭 XML 标签
    public int Field1 = 10; 
    ...
```

每一个 XML 元素都是当我们在语言特性（比如类或类成员）的声明上输入3条斜杠时，Visual Studio 自动增加的。

### 使用其他 XML 标签
在之前的示例中，我们看到了summay XML 标签的使用。C# 可识别的标签还有很多，如下表列出了最重要的一些：

| 标签 | 意义 |
| :---- | :---- |
| &lt;code&gt; | 用看上去像代码的字体格式化内部的行 |
| &lt;example&gt; | 将内部的行标注为一个示例 |
| &lt;param&gt; | 为方法或构造函数标注参数，并允许描述 |
| &lt;remarks&gt; | 描述类型的声明 |
| &lt;returns&gt; | 描述返回值 |
| &lt;seealso&gt; | 在输出文档中创建 See Also 一项 |
| &lt;summary&gt; | 描述类型或类型成员 |
| &lt;value&gt; | 描述属性 |

## 嵌套类型
通常直接在命名空间中声明类型。然而，还可以在类或结构中声明类型。  
①在另一个类型声明中声明的类型叫做嵌套类型。和所有类型声明一样，嵌套类型是类型实例的模板；  
②嵌套类型像**封闭类型 enclosing type** 的成员一样声明：  
&emsp;&emsp;- 嵌套类型可以是任意类型；  
&emsp;&emsp;- 嵌套类型可以是类或结构。

### 嵌套类的示例

``` C#
class MyClass {
    class MyCounter //嵌套类
    {
        public int Count { get; private set; }

        public static MyCounter operator ++( MyCounter current )
        {
            current.Count++;
            return current;
        }
    }

    private MyCounter counter;

    public MyClass() { counter = new MyCounter(); }

    public int Incr() { return ( counter++ ).Count; }
    public int GetValue() { return counter.Count; } 
}

class Program {
    static void Main() {
        MyClass mc = new MyClass();
        mc.Incr(); mc.Incr(); mc.Incr();
        mc.Incr(); mc.Incr(); mc.Incr();

        Console.WriteLine($"Total: { mc.GetValue() }");
    }
}
```

运行结果如下：

``` console
Total: 6
```

### 可见性和嵌套类型
在第9章中，我们已经了解到类和类型通常有 public 或 internal 的访问级别。然而，嵌套类型的不同之处在于，它们有*成员访问级别*而不是*类型访问级别*。因此，下面的命题是成立的：  
①在类内部声明的嵌套类型可以有5种类成员访问级别中的任何一种：public、protected、private、internal 或 protected internal；  
②在结构内部声明的嵌套类型可以有3种结构成员访问级別中的任何一种：public、internal或 private。

在这两种情况下，嵌套类型的默认访问级别都是 private ，也就是说不能被封闭类型以外的对象所见。不管封闭类型的成员声明了怎样的访问级別，包括 private 和 protected ，嵌套类型都能访问这些成员。然而，它们之间的关系不是对称的。尽管封闭类型的成员总是能看见嵌套类型的声明并且能创建它的变量及实例，但是它们不能完全访问嵌套类型的成员。相反，这种访问权限受限于嵌套类成员声明的访问级别，就好像嵌套类型是一个独立的类型一样。也就是说，它们可以访问 public 或 internal 的成员，但是不能访问嵌套类型的 private 或 protected 成员。

嵌套类型中的 this 引用指的是嵌套类型的对象，而不是封闭类型的对象。如果嵌套类型的对象需要访问封闭类型，它必须持有封闭类型的引用。

## 析构函数和 dispose 模式
第7章介绍了创建类对象的构造函数。类还可以拥有**析构函数 destructor** ，它可以在一个类的实例不再被引用的时候执行一些操作，以清除或释放非托管资源。非托管资源是指用 Win32 API 或非托管内存块获取的文件句柄这样的资源。使用 .NET 资源是无法获取它们的，因此如果我们只用 .NET 类，是不需要编写太多析构函数的。

关于析构函数要注意以下几点：  
①每个类只能有一个析构函数；  
②析构函数不能有参数；  
③析构函数不能有访问修饰符；  
④析构函数名称与类名相同，但要在前面加一个波浪符；  
⑤析构函数只能作用于类的实例。因此没有静态析构函数；  
⑥*不能在代码中显式调用析构函教*。相反，当垃圾同收器分析代码并认为代码中不存在指向该对象的可能路径时，系统会在垃圾回收过程中调用析构函数。

例如，下面的代码通过类 Class1 演示了析构函数的语法：

``` C#
Class1
{
    ~Class1() //析构函数
    {
        CleanupCode
    }
    ...
}
```

使用析构函数时一些重要的原则如下：  
①不要在不需要时实现析构函数，这会严重影响性能；  
②析构函数应该只释放对象拥有的外部资源；  
③析构函数不应该访问其他对象，因为无法假定这些对象是否已经被销毁。

### 标准 dispose 模式
与 C++ 析构函数不同，C# 析构函数不会在实例超出作用域时立即调用。事实上，你无法知道何时会调用析构函数。此外，如前所述，你也不能显式调用析构函数。你知道的只是系统会在对象从托管堆上移除之前的某个时刻调用析构函数。

如果你的代码中包含的非托管资源越早释放越好，就不能将这个任务留给析构函数，因为无法保证它会何时执行。相反，你应该采用**标准 dispose 模式**。

标准 dispose 模式包含以下特点：  
①包含非托管资源的类应该实现 IDisposable 接口，后者包含单一方法 Dispose 。Dispose 包含释放资源的清除代码；  
②如果代码使用完了这些资源并且希望将它们释放，应该在程序代码中调用 Dispose 方法；  
③你的类还应该实现一个析构函数来调用 Dispose 方法，以防止之前没有调用该方法。

总结一下：你需要将所有清除代码放到 Dispose 方法中，并在使用完资源时调用它。万一 Dispose 没被调用，类的析构函数应该调用 Dispose 。如果调用了 Dispose ，你需要告诉垃圾回收器不要再调用析构函数，因为 Dispose 已经执行了清除操作。

析构函数和 Dispose 代码应该遵循以下原则：  
①析构函数和 Dispose 方法的逻辑应该是，如果由于某种原因代码没有调用 Dispose ，那么析构函数应该调用它，并释放资源；  
②在 Dispose 方法的最后应该调用 GC.SuppressFinalize 方法，通知 CLR 不要调用该对象的析构函数，因为清除工作已经完成；  
③最好在 Dispose 中实现多次调用该方法也是安全的代码。也就是说代码要这样写：如果该方法已经被调用，那么任何后续调用都不会执行额外的工作，也不会抛出任何异常。

下面的代码展示了标准的 dispose 模式，代码后面的图对其进行了阐释。这段代码的要点如下：  
①Dispose 方法有两个重载：一个是 public 的，一个是 protected 的。protected 的重载包含实际的清除代码；  
②public 版本可以在代码中显式调用以执行清除工作。它会调用 protected 版本；  
③析构函数调用 protected 版本；  
④protected 版本的 bool 参数通知方法是它被析构函数或是其他代码调用的。这一点很重要，因为两种情况下执行的操作略有不同。细节如下面的代码所示：  

``` C#
class MyClass : IDisposable
{
    bool disposed = false; //释放状态

    public void Dispose() //公有 Dispose 方法
    {
        Dispose( true );
        GC.SuppressFinalize(this);
    }

    ~MyClass() //析构函数
    {
        Dispose(false);
    }

    protected virtual void Dispose(bool disposing) //分解释放
    {
        if (disposed == false)
        {
            if (disposing == true)
            {
                //释放托管资源
                ...
            }
                //释放非托管资源
                ...
        }
        disposed = true;
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2023/07/29/G6qIsWLxXHS4fjn.png" width = "80%" height = "80%" alt="图125 - 标准 dispose 模式"/>
</div>

## Tuple 和 ValueTuple
**元组 tuple** 数据类型是一种保存有序列表的数据结构，列表中最多有7个元素，元素的数据类型可以不同。元组常用于从方法返回多个值，或者临时存放数据。

元组是在C#4.0引入的在基类库中预定义的类，C#7.0引入**值元组 ValueTuple** 类型，它们的重要特征如下：  
①元组数据类型是类。值元组是结构体，可以提升性能；  
②元组是不可变的。值元组的成员是可变的；  
③元组的成员是属性，值元组的成员是字段；  
④可以使用默认的构造函数或者元组类提供的 Create 辅助函数来创建元组实例；  
⑤元组拥有7个元素，但是只要第8个元素也是元组，就可以创建和访问第8个元素的元组；  
⑥为了访问元组的元素，可以使用8个属性名称之一：Item1，...，Item8。注意没有 Item0，只能这样访问，不能 foreach 遍历，也不能方括号索引访问。

``` C#
class GlobalTemp
{
    public Tuple<double, double, double, double, double, double>
    TempDifferenceConst()
    {
        //使用构造函数
        return new Tuple<double, double, double, double, double, double>
                        ( 0.03, 0.00, 0.20, 0.34, 0.52, 0.63 );
    }

    public Tuple<double, double, double, double, double, double>
    TempDifferenceCreate()
    {
        //使用Create方法更简洁
        return Tuple.Create( 0.03, 0.00, 0.20, 0.34, 0.52, 0.63 );
    }
}

class Program
{
    static void Main()
    {
        GlobalTemp gt = new GlobalTemp();

        var tdTuple = gt.TempDifferenceCreate();
        Console.WriteLine( "Temp increase 1950's to 2000: {0}C.", tdTuple.Item5);

        tdTuple = gt.TempDifferenceConst();
        Console.WriteLine( "Temp increase 1950's to 2010: {0}C.", tdTuple.Item6 );
    }
}
```

运行结果如下：

``` console
Temp increase 1950's to 2000: 0.52C.
Temp increase 1950's to 2010: 0.63C.
```

从C#7.0和.NET Framework 4.7开始，新的 ValueTuple 类解决了元素命名问题。

下面的代码使用 ValueTuple 代替 Tuple 重新了上面的示例，注意以下几点：  
①ValueTuple 的创建是隐式的，只需要传递正确数量和正确数据类型的元素即可；  
②ValueTuple 的返回数据类型是由圆括号括起的、以逗号分隔的元素列表；  
③方法的返回类型中包括了 ValueTuple 元素的名称。在调用域中可以使用这些名称来引用各个元素。如果未在返回类型列表中指定元素的名称，则 Item1 等旧的默认名称仍然适用。

``` C#
class GlobalTemp
{
    public (double d1960, double d1970, double d1980,
            double d1990, double d2000, double d2010)
    TempDifferenceUsingValueTupleCtor()
    {
        //使用构造函数
        return new ValueTuple<double, double, double,
                double, double, double>(0.03, 0.00, 0.20, 0.34, 0.52, 0.63);
    }

    public (double d1960, double d1970, double d1980,
            double d1990, double d2000, double d2010)
    TempDifferenceUsingValueTuple()
    {   
        //隐式创建
        return (0.03, 0.00, 0.20, 0.34, 0.52, 0.63);
    }
}

class Program
{
    static void Main()
    {
        GlobalTemp gt = new GlobalTemp();

        var tdVTuple = gt.TempDifferenceUsingValueTupleCtor();
        Console.WriteLine( "Temp increase 1950's to 2000: {0}C.", tdVTuple.d2000 ); //参数名可见

        tdVTuple = gt.TempDifferenceUsingValueTuple();
        Console.WriteLine( "Temp increase 1950's to 2010: {0}C.", tdVTuple.d2010); //参数名可见
    }
}
```

运行结果同上。