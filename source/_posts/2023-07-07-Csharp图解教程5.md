---
title: 《C#图解教程》读书笔记（五）
date: 2023-07-07 14:09:57
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 本篇主要内容为：预处理指令，反射和特性，以及其他主题中的字符串、可空类型、Main方法、文档注释等等；  
> 读书笔记仅为知识的记录，方便后续查找。  
> 学习完成日期为XXXX年XX月XX日。 

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第二十四章 预处理指令
## 什么是预处理指令
源代码指定了程序的定义，**预处理指令 preprocessor directive** 指示编译器如何处理源代码。例如，在某些情况下，我们可能希望编译器忽略一部分代码，而在其他情况下，我们可能希望代码被编译。预处理指令给了我们这样的选项。

在 C 和 C++ 中有实际的预处理阶段，此时预处理程序遍历源代码并且为之后的编译阶段准备文本输出流。在 C# 中没有实际的预处理程序。“预处理”指令由编译器来处理，而这个术语保留了下来。

## 基本规则
下面是预处理指令最重要的一些语法规则：  
①预处理指令必须和 C# 代码在不同的行；  
②与 C# 语句不同，预处理指令不需要以分号结尾；  
③包含预处理指令的每一行必须以#字符开始：
&emsp;&emsp;- 在#字符前可以有空格；  
&emsp;&emsp;- 在#字符和指令之间可以有空格。
④允许行尾注释；  
⑤在预处理指令所在的行不允许分隔符注释。

``` C#
#define PremiumVersion     //没有分号，正确
  #define BudgetVersion    //前面有空格，正确
# define MediumVersion     //中间有空格，正确

#define PremiumVersion     /* all bells & whistles */ 不允许分隔符注释，错误

#define BudgetVersion      // Stripped-down version 允许行尾注释，正确
```

下表列出了预处理指令：

| 指令 | 含义概要 |
| :---- | :---- |
| #define identifier | 定义编译符号 |
| #undef identifier | 取消定义编译符号 |
| #if expression | 如果表达式是true，则编译器编译下面的片段 |
| #elif expression | 如果表达式是true，则编译器编译下面的片段 |
| #else | 如果之前的#if或#elif表达式是false，则编译器编译下面的片段 |
| #endif | 标记一个#if结构的结束 |
| #region name | 标记一段代码的开始，没有编译效果 |
| #endregion name | 标记一段代码的结束，没有编译效果 |
| #warning message | 显示编译时的警告消息 |
| #error message | 显示编译时的错误消息 |
| #line indicator | 修改在编译器消息中显示的行数 |
| #pragma warning | 提供修改编译器警告消息行为的选项 |

## `#define` 和 `#undef` 指令
**编译符号 compilation symbol** 是只有两种可能状态的标识符，要么被定义，要么未被定义。编译符号有如下特性：  
①它可以是除了 true 或 false 以外的任何标识符，包括 C# 关键字，以及在 C# 代码中声明的标识符，这两者都是可以的；  
②它没有值。与 C 和 C++ 不同，它不表示字符串。

`#define` 和 `#undef` 指令只能用在源文件的第一行，也就是任何 C# 代码之前。在 C# 代码开始后，`#define` 和 `#undef` 指令就不能再使用。编译符号的范围被限制于单个源文件。只要编译符号在任何 C# 代码之前，重复定义已存在的编译符号也是允许的。

定义一个标识符相当于将其值设置为 true。取消定义一个标识符相当于将其值设置为 false。尽管必须在 C# 代码之外定义标识符，但可以在 C# 代码中使用它，通常是在 `#if #else` 构造中使用，如下：

``` C#
#define debug
static void Main()
{
    #if debug
        //开启详细日志
    #else
        //性能优化
    #endif
        ...
}
```

## 条件编译
条件编译允许根据某个编译符号是否被定义标注一段代码被编译或跳过。

有4个指令可以用来指定条件编译：`#if`; `#else`; `#elif`; `#endif`。

在`#if`和`#elif`指令中使用的条件是一个返回 true 或 false 的简单表达式，如下表所总结的。条件可以由单个编译符号、符号表达式或操作符组成；子条件可以使用圆括号分组；文本 true 或 false 也可以在条件表达式中使用：

| 参数类型 | 意义 | 运算结果 |
| :---- | :---- | :---- |
| 编译符号 | 使用`#define`指令定义（或未被定义）的标识符 | true：如果符号已经使用`#define`指令定义 <br> false：其他 |
| 表达式 | 使用符号和操作符!、==、!=、&&、&#9474;&#9474;构建的 | true：如果表达式运算结果为true <br> false：其他 |

条件编译示例如下：  

``` C#
#if !DemoVersion //表达式
    …
#endif

#if(LeftHanded && OemVersion) //完整版
    …
#endif

#if true //下面的代码片段总是会被编译
    …
#endif
```

## 条件编译结构
`#if` 和 `#endif` 指令在条件编译结构中需要配对使用。

例如，如下的代码演示了简单的 `#if...#else` 结构。如果符号 RightHanded 被定义了，那么 `#if` 和 `#else` 之间的代码会被编译。否则，`#else` 和 `#endif` 之间的代码会被编译：

``` C#
...
#if RightHanded
    // Code implementing right-handed functionality
    ...
#else
    // Code implementing left-handed functionality
    ...
#endif
```

如下的代码演示了 `#if...#elif...#else` 结构。包含程序版本描述的字符串根据定义的编译符号被设置为不同的值：  

``` C#
#define DemoVersionWithoutTimeLimit

using System;

class demo
{
    static void Main()
    {
        const int intExpireLength = 30;
        string strVersionDesc = null;
        int intExpireCount = 0;

#if DemoVersionWithTimeLimit
    intExpireCount = intExpireLength;
    strVersionDesc = "This version of Supergame Plus will expire in 30 days";

#elif DemoVersionWithoutTimeLimit
    strVersionDesc = "Demo Version of Supergame Plus";

#elif OEMVersion
    strVersionDesc = "Supergame Plus, distributed under license";

#else
    strVersionDesc = "The original Supergame Plus!!";

#endif

        Console.WriteLine(strVersionDesc);
    }
}
```

运行结果如下：

``` console
Demo Version of Supergame Plus
```

## 诊断指令
**诊断指令 Diagnostic Directives** 产生用户自定义的编译时警告及错误消息。

下面是诊断指令的语法。 Message 是字符串，但是需要注意，与普通的 C# 字符串不同，它们不需要被引号包围。

``` C#
#warning Message

#error Message
```

当编译器遇到诊断指令时，它会输出相关的消息。诊断指令的消息会和任何编译器产生的警告和错误消息列在一起。

## 行号指令
**行号指令 Line number directives** 可以做很多事情，诸如：  
①改变由编译器警告和错误消息报告的出现行数；  
②改变被编译源文件的文件名；  
③对交互式调试器隐藏一些行。

`#line` 指令的语法如下：

``` C#
#line integer    //将下一行的行号设置为整数
#line "filename" //设置文件名
#line default    //重新保存实际的行号和文件名

#line hidden     //对断点调试器隐藏以下代码
#line            //停止在调试器中隐藏代碼
```

带一个整数参数的 `#line` 指令会使编译器将该值视为下一行代码的行号，之后的行号会在这个行号的基础上递增。  
①要改变文件名，可以在双引号内使用文件名作为参数。双引号是必需的；  
②要返回真实行号和真实文件名，可以使用 default 参数；  
③要对交互式调试器的断点调试功能隐藏代码段，可以使用 hidden 作为参数。要停止隐藏，可以使用不带任何参数的指令。到目前为止，这个功能大多用于在 ASP.NET 和 WPF 中隐藏编译器生成的代码。

``` C#
#line 226
    x = y + z; //现在编译器认为这是第226行
    ...

#line 330 "SourceFile.cs" //改变报告的行号和文件名
    var1 = var2 + var3;
    ...

#line default //重新保存行号和文件名
```

## 区域指令
**区域指令 region directive** 允许标注和有选择性地命名一段代码。区域由一个 region 指令和某下方某处的一个 `#endregion` 指令构成。通过仅显示当前要处理的代码区域，区域功能可以让你更轻松地浏览代码。它还允许你通过位置组织代码，例如所有的属性放在同一位置，所有方法放在另一个位置。`#region` 指令的特性如下：  
①`#region` 指令被放置在你想要标注的代码段上，而 `#endregion` 指令被放置在区域中最后一行代码之后；  
②`#region` 指令用其后的可选文本字符串作为区域的名称；  
③区域可以内嵌在其他的区域内：  
&emsp;&emsp;- 区域可以内嵌到任何级别，区域可以嵌套；  
&emsp;&emsp;- `#endregion` 指令始终与其上方的第一个没匹配过的 `#region` 指令匹配。

尽管区域指令被编译器忽略，但它们可以被源代码工具所使用。例如，Visual Studio允许我们很简单地隐藏或显式区域。作为示例，下面的代码中有一个叫做 Constructors 的区域，它封闭了 MyClass 类的两个构造函数。在 Visual Studio 中，如果不想看到其中的代码，可以把这个区域折叠成一行，如果又想对它进行操作或增加另外一个构造函数，还可以扩展它：

``` C#
#region Constructors
    MyClass()
    { ... }

    MyClass(string s)
    { ... }
#endregion
```

## `#pragma warning` 指令
利用 `#pragma warning` 指令可以关闭及重新开启警告消息：  
①要关闭警告消息，可以使用 disable 形式加上希望关闭的警告数的逗号分隔的形式列表；  
②要重新开启警告消息，可以使用 restore 形式加上希望关闭的警告数的逗号分隔的形式列表。

例如，下面的代码关闭了两个警告消息：618和414。在后面的代码中又开启了618警告消息，但还是保持414消息为关闭状态：

``` C#
#pragma warning disable 618, 414 //要关闭的警告信息
    ... //列出的警告信息在这段代码中处于关闭状态
#pragma warning restore 618
```

如果我们使用任意一种不带警告数字列表的形式，这个命令会应用于所有警告。例如，下面的代码关闭然后恢复所有警告消息：

``` C#
#pragma warning disable
    ... //所有警告信息在这段代码中处于关闭状态

#pragma warning restore
    ... //所有警告信息在这段代码中处于开启状态
```


# 第二十五章 反射和特性
## 元数据和反射
大多数程序都要处理数据，包括读、写、操作和显示数据。（图形也是数据的一种形式。）然而，对于某些程序来说，它们操作的数据不是数字、文本或图形，而是关于程序和程序类型的信息。  
①有关程序及其类型的数据被称为**元数据 metadata**，它们保存在程序的程序集中；  
②程序在运行时，可以查看其他程序集或其本身的元数据。运行中的程序査看本身的元数据或其他程序的元数据的行为叫做**反射 reflection**。

对象浏览器是显式元数据的程序的一个示例。它可以读取程序集，然后显示所包含的类型以及类型的所有特性和成员。

本章将介绍程序如何使用 **Type 类**来反射数据，以及程序员如何使用**特性 attributes** 来给类型添加元数据。

> 要使用反射，我们必须使用 System.Reflection 命名空间。

## Type 类
BCL 声明了一个叫做 Type 的抽象类，它被设计用来包含类型的特性。使用这个类的对象能获取程序使用的类型的信息。

由于 Type 是抽象类，因此它不能有实例。在运行时，CLR 创建从 Type(RuntimeType) 派生的类的实例，Type 包含了类型信息。当访问这些实例时，CLR 不会返回派生类的引用而是返回 Type 基类的引用。但是，为了简单起见，在本章剩余的篇幅中，会把引用所指向的对象称为 Type 类型的对象（虽然从技术角度来说它是一个 BCL 内部的派生类型的对象）。

需要了解的有关 Type 的重要事项如下：  
①对于程序中用到的每一个类型，CLR 都会创建一个包含这个类型信息的 Type 类型的对象；  
②不管创建的类型有多少个实例，只有一个 Type 对象会关联到所有这些实例。

下图显示了一个运行的程序，它有两个 MyClass 对象和一个 OtherClass 对象。注意，尽管有两个 MyClass 的实例，只会有一个 Type 对象来表示它：

<div  align="center">  
<img src="https://s2.loli.net/2023/07/08/GSnWuZd9UPpOIfE.png" width = "60%" height = "60%" alt="图120 - 对于程序中使用的每一个类型，CLR都会实例化Type类型的对象"/>
</div>

可以从 Type 对象中获取有关类型的几乎所有信息。下表列出了 System.Type 类的部分成员：

| 成员 | 成员类型 | 描述 |
| :---- | :---- | :---- |
| Name | 属性 | 返回类型的名字 |
| Namespace | 属性 | 返回包含类型声明的命名空间 |
| Assembly | 属性 | 返回声明类型的程序集。如果类型是泛型的，返回定义这个类型的程序集 |
| GetFields | 方法 | 返回类型的字段列表 |
| GetProperties | 方法 | 返回类型的属性列表 |
| GetMethods | 方法 | 返回类型的方法列表 |

## 获取 Type 对象
本节学习，使用实例对象的 GetType 方法或者 typeof 运算符和类名来获取 Type 对象。object 类型包含了一个叫做 GetType 的方法，它返回对实例的 Type 对象的引用。由于每一个类型最终都是从 object 派生的，所以我们可以在任何类型的对象上使用 **GetType 方法**来获取它的 Type 对象，如下所示：`Type t = myInstance.GetType();`

下面的代码演示了如何声明一个基类以及从它派生的子类。Main 方法创建了每一个类的实例并且把这些引用放在了一个叫做 bca 的数组中以方便使用。在外层的 foreach 循环中，代码得到了 Type 对象并且输出类的名字，然后获取类的字段并输出。代码后的图演示了内存中的对象：

``` C#
using System;
using System.Reflection; //必须使用该命名空间

class BaseClass
{
    public int BaseField = 0;
}

class DerivedClass : BaseClass
{
    public int DerivedField = 0;
}

class Program
{
    static void Main( )
    {
        var bc = new BaseClass();
        var dc = new DerivedClass();

        BaseClass[] bca = new BaseClass[] { bc, dc };

        foreach (var v in bca)
        {
            Type t = v.GetType(); //获取类型

            Console.WriteLine($"Object type : { t.Name }");

            FieldInfo[] fi = t.GetFields(); //获取字段信息
            foreach (var f in fi)
                Console.WriteLine($" Field : { f.Name }");
            Console.WriteLine();
        }
    }
}
```

运行结果如下：

``` console
Object type : BaseClass
 Field : BaseField

Object type : DerivedClass
 Field : DerivedField
 Field : BaseField
```

<div  align="center">  
<img src="https://s2.loli.net/2023/07/08/IayVTBjoL7MAkeO.png" width = "60%" height = "60%" alt="图121 - 基类和派生类对象以及它们的 Type 对象"/>
</div>

还可以使用 **typeof 运算符**来获取 Type 对象。只需要提供类型名作为操作数，它就会返回 Type 对象的引用，如下所示：`Type t = typeof( DerivedClass );`

示例如下：

```C#
using System;
using System.Reflection; //必须使用该命名空间

namespace SimpleReflection
{
    class BaseClass
    {
        public int BaseField;
    }

    class DerivedClass : BaseClass
    {
        public int DerivedField;
    }

    class Program
    {
        static void Main()
        {
            Type tbc = typeof(DerivedClass); //获取类型
            Console.WriteLine($"Object type : { tbc.Name }");
            FieldInfo[] fi = tbc.GetFields();
            foreach (var f in fi)
                Console.WriteLine($" Field : { f.Name }");
        }
    }
}
```

运行结果如下：

``` console
Object type : DerivedClass
 Field : DerivedField
 Field : BaseField
```

## 什么是特性
**特性 attribute** 是一种允许我们向程序的程序集增加元数据的语言结构。它是用于保存程序结构信息的某种特殊类型的类：  
①将应用了特性的程序结构 program construct 叫做目标 target ；  
②设计用来获取和使用元数据的程序（比如对象浏览器）叫做特性的消费者 consumer ；  
③ .NET 预定了很多特性，我们也可以声明自定义特性。

下图是使用特性中相关组件的概览，并且演示了如下有关特性的要点：  
①我们在源代码中将特性应用于程序结构；  
②编译器获取源代码并且从特性产生元数据，然后把元数据放到程序集中；  
③消费者程序可以获取特性的元数据以及程序中其他组件的元数据。注意，编译器同时生产和消费特性。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/08/CFOw2pD6xrQIb5G.png" width = "60%" height = "60%" alt="图122 - 创建和使用特性的相关组件"/>
</div>

根据惯例，特性名使用 Pascal 命名法并且以 Attribute 后缀结尾。当为目标应用特性时，可以不使用后缀。例如，对于 SerializableAttribute 和 MyAttributeAttribute 这两个特性，在把它们应用到结构时可以使用 Serializable 和 MyAttribute 短名称。

## 应用特性
特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集。我们可以通过把特性应用到结构来实现：  
①通过在结构前放置**特性片段 attribute section** 来应用特性；  
②**特性片段**由方括号包围特性名和参数列表（可以没有）构成。

例如，下面的代码演示了两个类的开始部分。最初的几行代码演示了把一个叫做 Serializable 的特性应用到 MyClass 。注意，Serializable 没有参数列表。第二个类的声明有一个叫做 MyAttribute 的特性，它有一个带有两个 string 参数的参数列表：

``` C#
[ Serializable ] //特性
public class MyClass
{ ...

[ MyAttribute("Simple class", "Version 3.57") ] //带有参数的特性
public class MyOtherClass
{ ...
```

有关特性需要了解的重要事项如下：  
①大多数特性只应用于直接跟随在一个或多个特性片段后的结构；  
②应用了特性的结构称为被特性装饰（ decorated 或 adorned ）。

## 预定义的特性
本节介绍几个 .NET 预定义特性
### Obsolete 特性
一个程序可能在其生命周期中经历多次发布，而且很可能延续多年。在程序生命周期的后半部分，程序员经常需要编写类似功能的新方法替换老方法。出于多种原因，你可能不想再使用那些调用过时的旧方法的老代码，而只想用新编写的代码调用新方法。

如果出现这种情况，你肯定希望稍后操作代码的团队成员或程序员也只使用新代码。要警告他们不要使用旧方法，可以使用 Obsolete 特性将程序结构标注为过期的，并且在代码编译时显示有用的警告消息。以下代码给出了一个示例：

``` C#
class Program
{
    [Obsolete("Use method SuperPrintOut")] //将特性应用到方法
    static void PrintOut(string str) {
        Console.WriteLine(str);
    }
    static void Main(string[] args) {
        PrintOut("Start of Main"); //调用 obsolete 方法
    }
}
```

注意，即使 PrintOut 被标注为过期，Main 方法还是调用了它。代码编译也运行得很好，并且产生了如下的输出：

``` console
Start of Main
```

不过，在编译的过程中，编译器产生了下面的 CS0618 警告消息来通知我们正在使用一个过期的结构:`[CS0618] “Program.PrintOut(string)”已过时:“Use method SuperPrintOut”`

Obsolete 特性的另外一个重载接受了 bool 类型的第二个参数。这个参数指定目标是否应该被标记为错误而不仅仅是瞥告。以下代码指定了它应被标记为错误：

``` C#
[ Obsolete("Use method SuperPrintOut", true) ] //标记为错误，将特性应用到方法
static void PrintOut(string str)
{ ...
```

### Conditional 特性
Conditional 特性允许我们包括或排斥特定方法的所有调用。要使用 Conditional 特性，将其应用于方法声明并把编译符作为参数：  
①如果定义了编译符号，那么编译器会包含所有调用这个方法的代码，这和普通方法没有什么区别；  
②如果没有定义编译符号，那么编译器会忽略代码中这个方法的所有调用；  
③定义方法的 CIL 代码本身总是会包含在程序集中。只是调用代码会被插入或忽略；  
④除了在方法上使用 Conditional 特性之外，还可以在类上使用它，只要该类派生自 Attribute 类。这里不会介绍 Conditional 特性的这种用法。

在方法上使用 Conditional 特性的规则如下：  
①该方法必须是类或结构体的方法；  
②该方法必须是 void 类型；  
③该方法不能被声明为 override，但可以标记为 virtual；  
④该方法不能是接口方法的实现。

例如，在如下的代码中，Conditional 特性被应用到一个叫作 TraceMessage 的方法的声明上。特性只有一个参数，在这里是字符串 DoTrace 。  
①当编译器编译这段代码时，它会检査是否定义了一个名为 DoTrace 的编译符号；  
②如果定义了 DoTrace ，编译器就会像往常一样在代码中包含所有对 TraceMessage 方法的调用；  
③如果没有定义 DoTrace 编译符号，编译器就不会输出任何对 TraceMessage 的任何调用代码。

``` C#
[Conditional( "DoTrace" )] //编译符号
static void TraceMessage(string str)
{
    Console.WriteLine(str);
}
```

***Conditional 特性的示例***  
以下代码演示了一个使用 Conditional 特性的完整示例：  
①Main 方法包含了两个对 TraceMessage 方法的调用；  
②TraceMessage 方法的声明被用 Conditional 特性装饰，它带有 DoTrace 编译符号作为参数。因此，如果 DoTrace 被定义，那么编译器就会包含对 TraceMessage 所有调用的代码；  
③由于代码的第一行定义了叫做 DoTrace 的编译符，编译器会包含两个 TraceMessage 的调用代码。

``` C#
#define DoTrace
using System;
using System.Diagnostics;

namespace AttributesConditional
{
    class Program
    {
        [Conditional( "DoTrace" )]
        static void TraceMessage(string str)
        { Console.WriteLine(str); }

        static void Main( )
        {
            TraceMessage("Start of Main");
            Console.WriteLine("Doing work in Main.");
            TraceMessage("End of Main");
        }
    }
}
```

运行结果如下：  

``` console
Start of Main
Doing work in Main.
End of Main
```

如果注释掉第一行来取消 DoTrace 的定义，编译器就不再会插人两次对 TraceMessage 的调用代码。这次，如果我们运行程序，就会产生如下输出：

``` console
Doing work in Main.
```

### 调用者信息特性
利用调用者信息特性可以访问文件路径、代码行数、调用成员的名称等源代码信息。  
①这三个特性名称为 CallerFilePath 、CallerLineNumber 和 CallerMemberName；  
②这些特性只能用于方法中的可选参数。

下面的代码声明了一个名为 MyTrace 的方法，它在三个可选参数上使用了这三个调用者信息特性。如果调用方法时显式指定了这些参数，则会使用真正的参数值。但在下面所示的 Main 方法中调用时，没有显式提供这些值，因此系统将会提供源代码的文件路径、调用该方法的代码行数和调用该方法的成员名称。

``` C#
using System;
using System.Runtime.CompilerServices;

public static class Program
{
    public static void MyTrace( string message,
                                [CallerFilePath] string fileName = "",
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerMemberName] string callingMember = "" )
    {
        Console.WriteLine($"File: { fileName }");
        Console.WriteLine($"Line: { lineNumber }");
        Console.WriteLine($"Called From: { callingMember }");
        Console.WriteLine($"Message: { message }");
    }

    public static void Main()
    {
        MyTrace( "Simple message" );
    }
}
```

运行结果如下：

``` console
File: C:\Users\XXXX\XXXX\XXXX\Program.cs
Line: 19
Called From: Main
Message: Simple message
```

### DebuggerStepThrough 特性
我们在单步调试代码时，常常希望调试器不要进入某些方法。我们只想执行该方法，然后继续调试下一行。DebuggerStepThrough 特性告诉调试器在执行目标代码时不要进入该方法调试。

在我自己的代码中，这是最有用的特性。有些方法很小并且毫无疑问是正确的，在调试时对其反复单步调试只能徒增烦恼。但使用该特性时要十分小心，因为你并不想排除那些可能含有 bug 的代码。

关于 DebuggerStepThrough 要注意以下两点：  
①该特性位于 System.Diagnostics 命名空间；  
②该特性可用于类、结构、构造函数、方法或访问器。

下面这段编造的代码在一个访问器和一个方法上使用了该特性。你会发现，调试器调试这段代码时不会进入 IncrementFields 方法或 X 属性的 set 访问器。

``` C#
using System;
using System.Diagnostics; //DebuggerStepThrough特性所需的

class Program
{
    int x = 1;
    int X
    {
        get { return x; }
        [DebuggerStepThrough] //不进入set访问器
        set
        {
            x = x * 2;
            x += value;
        }
    }

    public int Y { get; set; }

    public static void Main()
    {
        Program p = new Program();
        p.IncrementFields();
        p.X = 5;
        Console.WriteLine( $"X = { p.X }, Y = { p.Y }" );
    }

    [DebuggerStepThrough] //不进入这个方法
    void IncrementFields()
    {
        X++; Y++;
    }
}
```

### 其他预定义特性
.NET 框架预定义了很多编译器和 CLR 能理解和解释的特性，下表列出了一些。在表中使用了不带 Attribute 后缀的短名称。例如，CLSCompliant 的全名是 CLSCompliantAttribute 。

| 特性 | 意义 |
| :---- | :---- |
| CLSCompliant | 声明公开暴露的成员应该被编译器检测其是否符号CLS。兼容的程序集可以被任何兼容.NET的语言使用 |
| Serializable | 声明结构可以被序列化 |
| NonSerialized | 声明结构不能被序列化 |
| DLLImport | 声明是非托管代码实现的 |
| WebMethod | 声明方法应该被作为 XML Web 服务的一部分暴露 |
| AttributeUsage | 声明特性能应用于什么类型的程序结构。将这个特性应用到特性声明上 |

## 关于应用特性的更多内容
本节介绍特性的一些其他使用方式。

### 多个特性
可以为单个结构应用多个特性：  
①多个特性可以使用下面任何一种格式列出：  
&emsp;&emsp;- 独立的特性片段一个接一个。通常，它们彼此叠加，位于不同的行中；  
&emsp;&emsp;- 单个特性片段，特性之间使用逗号分隔。  
②可以以任何次序列出特性。

例如，下面的两个代码片段显示了应用多个特性的两种方式。两个片段的代码是等价的。

``` C#
[ Serializable ] //多层结构
[ MyAttribute("Simple class", "Version 3.57") ]

[ MyAttribute("Simple class", "Version 3.57"), Serializable ] //逗号分隔
```

### 其他类型的目标
除了类，还可以将特性应用到诸如字段和属性等其他程序结构。以下的声明显示了字段上的特性以及方法上的多个特性：

``` C#
[MyAttribute("Holds a value", "Version 3.2")] //字段上的特性
public int MyField;

[Obsolete] //方法上的特性
[MyAttribute("Prints out a message.", "Version 3.6")]
public void PrintOut()
{
...
```

还可以显式地标注特性，从而将它应用到特殊的目标结构。要使用**显式目标说明符**，在特性片段的开始处放置目标类型，后面跟冒号。例如，如下的代码用特性装饰方法，并且还把特性应用到返回值上：

``` C#
[method: MyAttribute("Prints out a message.", "Version 3.6")] //显式目标说明符
[return: MyAttribute("This value represents ...", "Version 2.3")]
public long ReturnSetting()
{
    ...
```

C# 语言定义了10个标准的特性目标：event； field； method； param； property； return； type； typevar； assembly； module。大多数目标名可以自解释的，而 type 覆盖了类、结构、委托、枚举和接口。 typevar 目标名称为使用泛型的结构指定类型参数。

### 全局特性
还可以通过使用 assembly 和 module 目标名称来使用显式目标说明符把特性设置在程序集或模块级別。有关程序集级别的特性的要点如下：  
①程序集级别的特性必须放置在任何命名空间之外，并且通常放置在 AssemblyInfo.cs 文件中；  
②AssemblyInfo.cs 文件通常包含有关公司、产品以及版权信息的元数据。

如下的代码行摘自 AssemblyInfo.cs 文件：

``` C#
[assembly: AssemblyTitle("SuperWidget")]
[assembly: AssemblyDescription("Implements the SuperWidget product.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("McArthur Widgets, Inc.")]
[assembly: AssemblyProduct("Super Widget Deluxe")]
[assembly: AssemblyCopyright("Copyright © McArthur Widgets 2012")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
```

## 自定义特性
特性是一种特殊的类：  
①用户自定义的特性类叫做自定义特性；  
②所有特性类都派生自 System.Attribute 。

### 声明自定义特性
总体来说，声明一个特性类和声明其他类一样。然而，有一些事项值得注意，如下所示：  
①要声明一个自定义特性，需要做如下工作：  
&emsp;&emsp;- 声明一个派生自 System.Attribute 的类；
&emsp;&emsp;- 给它起一个以后缀 Attribute 结尾的名字。
②安全起见，通常建议你声明一个 sealed 的特性类（密封类，不能被继承）。

例如，下面的代码显示了 MyAttributeAttribute 特性的声明的开始部分：

``` C#
public sealed class MyAttributeAttribute : System.Attribute //特性名MyAttributeAttribute带后缀Attribute
{
...
```

由于特性持有目标的信息，所有特性类的公共成员只能是：①字段；②属性；③构造函数

### 使用特性的构造函数
特性和其他类一样，有构造函数。每一个特性必须至少有一个公共构造函数：  
①和其他类一样，如果你不声明构造函数，编译器会为你产生一个隐式、公共且无参的构造函数；  
②特性的构造函数和其他构造函数一样，可以被重载；  
③声明构造函数时必须使用类全名，包括**后缀**。我们只可以在应用特性时使用短名称。

如下，如果下面的构造函数名字没有后缀，编译器会产生一个错误消息：  

``` C#
public MyAttributeAttribute(string desc, string ver) //包含后缀 Suffix
{
    Description = desc;
    VersionNumber = ver;
}
```

### 指定构造函数
当我们为目标应用特性时，其实是在指定应该使用哪个构造函数来创建特性的实例。列在特性应用中的参数其实就是构造函数的参数。

例如，在下面的代码中，MyAttribute 被应用到一个字段和一个方法上。对于字段，声明指定了使用单个字符串参数的构造函数。对于方法，声明指定了使用两个字符串参数的构造函数。

``` C#
[MyAttribute("Holds a value")] //使用一个字符串的构造函数
public int MyField;

[MyAttribute("Version 1.3", "Galen Daniel")] //使用两个字符串的构造函数
public void MyMethod()
{ ...
```

特性构造函数的其他要点如下：  
①在应用特性时，构造函数的实参必须是在编译时能确定值的常量表达式；  
②如果应用的特性构造函数没有参数，可以省略圆括号。例如，如下代码的两个类都使用 MyAttr 特性的无参构造函数。两种形式的意义是相同的。

``` C#
[MyAttr]
class SomeClass ...

[MyAttr()]
class OtherClass ...
```

### 使用构造函数
和其他类一样，我们不能显式调用构造函数。特性的实例创建后，只有特性的消费者访问特性时才能调用构造函数。这一点与其他类的实例很不相同，这些实例都创建在使用对象创建表达式的位置。应用一个特性是一条声明语句，它不会决定什么时候构造特性类的对象。

下图比较了普通类构造函数的使用和特性的构造函数的使用：  
①命令语句 imperative statement 的实际意义是："在这里创建新的类"
②声明语句 declarative statement 的意义是："这个特性和这个目标相关联，如果需要构造特性，使用这个构造函数"。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/09/AFYQLha2wR4PEgG.png" width = "70%" height = "70%" alt="图123 - 比较构造函数的使用"/>
</div>

### 构造函数中的位置参数和命名参数
和普通类的方法与构造方法相似，特性的构造函数同样可以使用位置参数和命名参数。如下代码显示了使用一个位置参数和两个命名参数来应用一个特性：

``` C#
//第一个为位置参数，第二、三个为命名参数
[MyAttribute("An excellent class",Reviewer="Amy McArthur"，Ver="0.7.15.33")]
```

下面的代码演示了特性类的声明以及为 MyClass 类应用特性。注意，构造函数的声明只列出了一个形参，但我们可通过命名参数给构造函数3个实参。两个命名参数设置了字段 Ver 和 Reviewer 的值：

``` C#
public sealed class MyAttributeAttribute : System.Attribute
{
    public string Description;
    public string Ver;
    public string Reviewer;

    public MyAttributeAttribute(string desc) //一个形参
    {
        Description = desc;
    }
}

[MyAttribute("An excellent class", Reviewer="Amy McArthur", Ver="7.15.33")]
class MyClass
{
...
}
```

> 和方法一样，构造函教需要的任何位置参数都必须放在命名参数之前。

### 限制特性的使用
我们已经看到了可以为类应用特性。而特性本身就是类，有一个很重要的预定义特性可以应用到自定义特性上，那就是 AttributeUsage 特性。我们可以使用它来限制将特性使用在某个目标类型上。

例如，如果我们希望自定义特性 MyAttribute 只能应用到方法上，那么可以以如下形式使用 AttributeUsage ：

``` C#
[ AttributeUsage( AttributeTargets.Method ) ] //只针对方法
public sealed class MyAttributeAttribute : System.Attribute
{ ...
```

AttributeUsage 有3个重要的公共属性，如下表所示。表中显示了属性名和属性的含义。对于后两个属性，还显示了它们的默认值：  

| 名字 | 意义 | 默认值 |
| :---- | :---- | :---- |
| ValidOn | 保存能应用特性的目标类型的列表。构造函数的第一个参数必须是 AttributeTargets 类型的枚举值 | N/A |
| Inherited | 一个布尔值，它指示特性是否可被装饰类型的派生类所继承 | true |
| AllowMultiple | 一个布尔值，指示目标上是否可应用特性的多个实例的 | false |

***AttributeUsage 的构造函数***
AttributeUsage 的构造函数接受单个位置参数，该参数指定了可使用特性的目标类型。它用这个参数来设置 ValidOn 属性，可接受的目标类型是 AttributeTargets 枚举的成员。AttributeTargets 枚举的完整成员：All； Assembly； Class； Constructor； Delegate； Enum； Event； Field； GenericParameter； Interface； Method； Module； Parameter； Property； ReturnValue； Struct。

可以通过使用按位或运算符来组合使用类型。例如，在下面的代码中，被装饰的特性只能应用到方法和构造函数上：

``` C#
[ AttributeUsage( AttributeTargets.Method | AttributeTargets.Constructor ) ]
public sealed class MyAttributeAttribute : System.Attribute
{ ...
```

当为特性声明应用 AttributeUsage 时，构造函数至少需要一个必需的参数，参数包含的目标类型会保存在 ValidOn 中。还可以通过使用命名参数有选择性地设置 Inherited 和 AllowMultiple 属性。如果不设置，它们会保持如之前所示的默认值。

作为示例，下面一段代码指定了 MyAttribute 的如下方面：  
①MyAttribute 能且只能应用到类上；  
②MyAttribute 不会被应用它的派生类所继承；  
③不能在同一个目标上应用 MyAttribute 的多个实例。

``` C#
[ AttributeUsage( AttributeTargets.Class, //必需的位置参数
                    Inherited = false, //可选的命名参数
                    AllowMultiple = false ) ] //可选的命名参数
public sealed class MyAttributeAttribute : System.Attribute
{ ...
```

### 自定义特性的最佳实践
强烈推荐编写自定义特性时参考如下实践：  
①特性类应该表示目标结构的某些状态；  
②如果特性需要某些字段，可以通过包含具有位置参数的构造函数来收集数据，可选字段可以采用命名参数按需初始化；  
③除了属性之外，不要实现公共方法或其他函数成员；  
④为了更安全，把特性类声明为 sealed ；  
⑤在特性声明中使用 AttributeUsage 来显式指定特性目标组。

如下代码演示了这些准则：

``` C#
[AttributeUsage( AttributeTargets.Class )]
public sealed class ReviewCommentAttribute : System.Attribute
{
    public string Description { get; set; }
    public string VersionNumber { get; set; }
    public string ReviewerID { get; set; }

    public ReviewCommentAttribute(string desc, string ver)
    {
        Description = desc;
        VersionNumber = ver;
    }
}
```

## 访问特性
可以使用 Type 对象来访问自定义特性。Type 的两个方法（IsDefined 和 GetCustomAttributes）在这里非常有用。

### 使用 IsDefined 方法
可以使用 Type 对象的 IsDefined 方法来检测某个特性是否应用到了某个类上。

例如，以下的代码声明了一个特性类 MyClass ，并且作为自己的特性消费者在程序中访问被声明和应用的特性。代码的开始处是 MyAttribute 特性和应用特性的 MyClass 类的声明。这段代码做了下面的事情：  
①首先，Main 创建了类的一个对象。然后通过使用从 object 基类继承的 GetType 方法获取了 Type 对象的一个引用；  
②有了 Type 对象的引用，就可以调用 IsDefined 方法来判断 ReviewComment 特性是否应用到了这个类：  
&emsp;&emsp;- 第一个参数接受需要检査的特性的 Type 对象；  
&emsp;&emsp;- 第二个参数是 bool 类型的，它指示是否搜索 MyClass 的继承树来查找这个特性。

``` C#
[AttributeUsage(AttributeTargets.Class)]
public sealed class ReviewCommentAttribute : System.Attribute
{... }

[ReviewComment("Check it out", "2.4")]
class MyClass { }

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass(); //创建类实例
        Type t = mc.GetType(); //从实例中获取类型对象
        bool isDefined = //创建特性的类型
            t.IsDefined(typeof(ReviewCommentAttribute), false);

        if( isDefined )
            Console.WriteLine($"ReviewComment is applied to type { t.Name }");
    }
}
```

运行结果如下：

``` console
ReviewComment is applied to type MyClass
```

### 使用 GetCustomAttributes 方法
Type 类的 GetCustomAttributes 方法返回应用到结构上的特性的数组：  
①实际返冋的对象是 object 的数组，因此我们必须将它强制转换为相应的特性类型；  
②布尔参数指定是否搜索继承树来査找特性：`object[] AttArr = t.GetCustomAttributes(false);`  
③调用 GetCustomAttributes 方法后，每一个与目标相关联的特性的实例就会被创建。

下面的代码使用了前面的示例中相同的特性和类声明。但是，本例中，它不检测特性是否应用到了类上，而是获取应用到类的特性的数组，然后遍历它们，输出它们的成员的值。

``` C#
using System;

[AttributeUsage( AttributeTargets.Class )]
public sealed class MyAttributeAttribute : System.Attribute
{
    public string Description { get; set; }
    public string VersionNumber { get; set; }
    public string ReviewerID { get; set; }

    public MyAttributeAttribute( string desc, string ver )
    {
        Description = desc;
        VersionNumber = ver;
    }
}

[MyAttribute( "Check it out", "2.4" )]
class MyClass
{
}

class Program
{
    static void Main()
    {
        Type t = typeof( MyClass );
        object[] AttArr = t.GetCustomAttributes( false );

        foreach ( Attribute a in AttArr )
        {
            MyAttributeAttribute attr = a as MyAttributeAttribute;
            if ( null != attr )
            {
                Console.WriteLine($"Description : { attr.Description }");
                Console.WriteLine($"Version Number : { attr.VersionNumber }");
                Console.WriteLine($"Reviewer ID : { attr.ReviewerID }");
            }
        }
    }
}
```

运行结果如下：

``` console
Description : Check it out
Version Number : 2.4
Reviewer ID :
```


# 第二十六章 C# 6.0 和 C# 7.0 新增的内容
## 字符串插值 C#6.0
字符串插值主要在第三章。

C#6.0使用了字符串插值简化了格式字符串。字符串插值不仅可以用在 Console.WriteLine 中，还可以使用在 String.Format，如下代码所示：

``` C#
string name = "Aiden";
string technology = "Cold Fusion";
string s;

s = String.Format("{0} is working on {1}.", name, technology); //格式字符串
Console.WriteLine(s);

s = String.Format($"{ name } is working on { technology }."); //字符串插值
Console.WriteLine(s);
```

## 自动属性初始化语句
详见第七章，自动属性是属性声明的一种简写形式，由编译器生成或管理一个不可见的、关联到这个属性的后备字段。之前，自动属性只能在构造函数或者方法中初始化，现在也可以像普通的属性一样在声明的时候初始化：

``` C#
public double Length { get; set; } = 42.5;

//可以对以 internal、protected、internal protected 或者 private 修饰的 setter 使用
private double Length { get; private set; } = 42.5;

//可以适用于只读自动属性
public double Length { get; } = 42.5;

//可以使用任何可以被解析为字面量的表达式
const double myConstant = 42;
public double Length { get; set; } = myConstant + .5;

//但是初始化语句不能引用非静态的属性、字段或者方法
private double myField = 42.5;
public double Length { get; set; } = myField; //编译错误
private double myProperty { get; set; } = 42.5;
public double Length { get; set; } = myProperty; //编译错误
```

集合 List 是自动属性初始化的最佳例子：

``` C#
public List<double> Areas { get; set; } = new List<double>();
```

结构体中的静态属性也可以使用自动属性初始化语句：

``` C#
struct MyStruct
{
    static double Length { get; set; } = 42.5;
    double Length2 { get; set; } = 42.5; //编译错误，非静态
}
```

## 只读自动属性 C#6.0
只读自动属性详见第七章。

之前，想要声明一个只读属性，需要私有化 setter。虽然阻止了类的使用者改变属性值，但是仍然可以在类内部的其他地方改变它：`public string CompanyName { get; private set; }`

现在可以去掉整个 setter。在这种情况下，属性必须在声明时或者在构造函数中初始化：`public string CompanyName { get; }`

在类和结构体中都可以使用只读自动属性。

## 表达式函数体成员 C#6.0和C#7.0
之前，所有方法和 get 属性的主体部分都是由包含在大括号内的代码组成的，并且必须有大括号。但是现在，如果函数体是由单个表达式构成的，我们可以使用称为表达式函数体的短格式语法。表达式函数体成员有如下重要特征：  
①代码必须是由一个表达式组成的，以分号结束；  
&emsp;&emsp;- 对于有返回值的成员类型，表达式的值就是返回值。对于没有返回值的成员，不返回任何东西。  
②不能有开始和结束大括号；  
③在参数列表和构成函数体的表达式之间使用 Lambda 运算符（=>）；  
④在 C#6.0 中，这个功能可以用在方法和属性的 get 访问器中。C#7.0 将这个功能扩展到了构造函数、终结函数 finalizer、属性 set 访问器和索引器。

例如，下面的方法声明使用了之前的方法体语法，而没有使用表达式函数体语法。它由包含在大括号内的一个语句组成：

``` C#
public string GetWineGrowingRegion(string countryName, string regionName)
{
    return countryName + ":" + regionName;
}
```

使用表达式函数体格式，可以使用 Lambda 运算符重写为`public string GetWineGrowingRegion(string countryName, string regionName) => countryName + ":" + regionName;`

下面演示一个只读属性的例子：`public string MyFavoriteWineGrowingRegion => "Sonoma County";`

你不能对自动实现了读写操作的属性成员使用表达式函数体。在这种情况下，不能同时使用访问器列表和表达式函数体：

``` C#
public int AreaCode { get; set; } = 408;
public int CentralOfficeCode { get; set; } = 428;
public int LineNumber { get; set; } = 4208;

public string PhoneNumber { get; } //访问器列表
                    => $"({AreaCode}) {CentralOfficeCode}-{LineNumber}"; //编译错误

public string PhoneNumber //没有访问器列表
                    => $"({AreaCode}) {CentralOfficeCode}-{LineNumber}"; // OK
```

## using static C#6.0
using static 主要在第7章和第22章。

在C#6.0之前，使用类或结构体的静态成员，必须包含类或结构体的名称。之后，可以使用 using static 语句，关键字后面包含静态成员的类或者结构体的全名，这样就可以在使用静态成员时不用在前面加上类型名称。

## 空条件运算符 C#6.0
主要在下一章，第27章，讨论。

空条件运算符主要是为了阻止试图访问一个空对象的成员时抛出的空引用异常。如下：

``` C#
Student[] students = null;
int studentCount = students.Length; //产生异常
Student firstStudent = students[0]; //产生异常

//可以使用空条件运算符来避免空引用异常
int? studentCount = students?.Length;
Student firstStudent = students?[0];
```

## 在 catch 和 finally 块中使用 await C#6.0
在 C#5.0 引入 async/await 时，不能把 await 子句放在 catch 或 finally 块中。现在这个限制被解除了。

## nameof 运算符 C#6.0
nameof 运算符主要在第9章讨论。

nameof 是一个新的运算符，它接受一个参数，可以是变量名、类型名或者成员名。运算符返回代表参数名称的字符串。

## 异常过滤器 C#6.0
异常过滤器主要在第23章讨论。

## 索引初始化语句
本节是唯一讨论索引初始化语句的地方。

C#6.0 引入了新的语法来初始化带索引器的数据结构，比如字典 Dictionary 对象。

``` C#
//传统语法，集合初始化
var favoriteCities = new Dictionary<int, string>
{
    {0, "Oxford"},
    {1, "Paris"},
    {2, "Barcelona"}
};

//上段代码和下面等效，使用Add方法：
var favoriteCities = new Dictionary<int, string>();
favoriteCities.Add(0, "Oxford");
favoriteCities.Add(1, "Paris");
favoriteCities.Add(2, "Barcelona");

//因为字典对象有索引器，可以使用新的索引初始化语法：
var favoriteCities = new Dictionary<int, string>
{
    [0] = "Oxford",
    [1] = "Paris",
    [2] = "Barcelona"
};

//这种形式与下面等价：
var favoriteCities = new Dictionary<int, string>();
favoriteCities[0] = "Oxford";
favoriteCities[1] = "Paris";
favoriteCities[2] = "Barcelona";
```

集合初始化隐式地调用集合的 Add 方法，但索引初始化没有调用 Add 方法，而是给索引指定的元素赋值。这两种不同的差别如下：首先，集合初始化需要一个实现了 IEnumerable 接口的集合，还需要一个公有的 Add 方法。索引初始化则两个都不需要，它仅仅需要类或者结构体包含索引器，不需要实现 IEnumerable 接口或者可以没有 Add 方法。

Dictionary 既能使用集合初始化又能使用索引初始化，不能在一个语句中同时使用这两种语法。

## 集合初始化语句的扩展方法 C#6.0
本节是唯一讨论集合初始化扩展方法的地方。扩展方法详见第8章。

使用集合初始化创建集合：

``` C#
var customer1 = new Customer(Name = "Willem", Age = 35);
var customer2 = new Customer(Name = "Sandra", Age = 32);
//集合初始化
var customers = new List<Customer>() { customer1, customer2 };
```

集合初始化能够工作，是因为编译器在调用构造函数之后，又加入了调用 Add 方法的代码。其他 .NET 集合也都有 Add 函数，可以使用集合初始化。

假设定义一个自己的集合，在集合内部使用名称不同于 Add 的调用 Add 方法的方法：

``` C#
public class Subscriptions : IEnumerable<Customer>
{
    private List<Customer> _subscribers = new List<Customer>();

    public void Subscribe(Customer c)
    {
        _subscribers.Add(c);
    }

    ...
}
```

上述代码因为 Subscription 类没有 Add 方法，所以下面的代码会失败：`var customers = new Subscription() { customer1, customer2 };`

但是从 C# 6.0 开始，可以通过实现一个名为 Add 的扩展方法来调用 Subscription 类中的 Subscribe 方法，来实现集合初始化语句。但是注意，集合仍然需要支持 IEnumerable 接口：

``` C#
public static class SubscriptionExtensions
{
    public static void Add( this Subscriptions s, Customer c ) // Extension method
    {
        s.Subscribe( c );
    }
}

public class Customer
{ public string Name{ get; set; } public Customer( string name ) { Name = name; }}

public class Subscriptions : IEnumerable<Customer>
{
    private List<Customer> mSubscribers = new List<Customer>();

    public IEnumerator<Customer> GetEnumerator()
    { return mSubscribers.GetEnumerator(); }

    IEnumerator IEnumerable.GetEnumerator()
    { throw new System.NotImplementedException(); }

    public void Subscribe( Customer c )
    {
        mSubscribers.Add( c );
    }
}

class Program
{
    public static void Main()
    {
        var customer1 = new Customer( "Willem" );
        var customer2 = new Customer( "Sandra" );

        //集合初始化
        var customers = new Subscriptions() { customer1, customer2 };

        foreach ( Customer c in customers )
            WriteLine( $"Name: {c.Name}" );
    }
}
```

## 值元组
**值元组 ValueTuple** 主要在下一章介绍。

**元组 tuple** 是一个有序的元素集合，其中元素可以是相同或不同的数据类型。元组仅仅是通过使用圆括号包裹和逗号分隔的方式提供了引用和操作一组元素的方便方法：

``` C#
(string, int) CreateSampleTuple()
{
    return ("Paul", 39);
}

var myTuple = CreateSampleTuple();
Console.WriteLine($"Name: { myTuple.Item1 } Age: {myTuple.Item2}");
```

元组易于创造但是调用相对麻烦，因为元组的元素只能靠没有描述性的名称 Item1、Item2 等调用。另外，因为元组是类、引用类型，需要在堆上创建，并不在引用时候被垃圾机制回收。

C# 7.0 引入了 ValueTuple 的结构体，可以获得比元组更好的性能。此外，可以给属于 ValueTuple 的元素命名。

## is 模式匹配 C#7.0
**is 运算符**用来检测一个对象是不是某些类型。C#支持继承和接口实现，虽然不支持多继承，但是类可以实现任意多个接口。在这种复杂性下，is 运算符不仅能检测当前类的类型，还能检测任意层次的基类，以及是否支持任意指定的接口。示例如下：

``` C#
public interface IOne
{
    int SampleIntProperty { get; set; }
}
public interface ITwo
{
    int SampleIntProperty2 { get; set; }
}
public class BaseClass
{
    public string SampleStringProperty { get; set; }
}
public class DerivedClass : BaseClass, IOne, ITwo
{
    public int SampleIntProperty { get; set; }
    public int SampleIntProperty2 { get; set; }
}

class Program
{
    static void Main(string[] args)
    {
        var dc = new DerivedClass();
        if (dc is DerivedClass)
        { Console.WriteLine("Derived Class found"); }
        if (dc is BaseClass)
        { Console.WriteLine("Base Class found"); }
        if (dc is IOne)
        { Console.WriteLine("Interface One found"); }
        if (dc is ITwo)
        { Console.WriteLine("Interface Two found"); }
    }
}
```

运行结果如下：

``` console
Derived Class found
Base Class found
Interface One found
Interface Two found
```

若检测了一个给定对象是不是某种类型后，如果想要引用这种类型，就必须先转换成这种类型：

``` C#
if(myEmployee is Supervisor)
{
    var mySupervisor = (Supervisor)myEmployee;
    //继续调用父类成员
}

//也可以使用 as 运算符来实现转换：
var mySupervisor = myEmployee as Supervisor;
if (mySupervisor != null)
{
    //继续调用父类成员
}
```

在 C# 7.0中，is 运算符的类型语法已经简化，可以直接给检测类后的变量赋值。增强的 is 运算符不仅检测变量类型，如果变量通过了测试，还可以同时将其赋值给指定的新变量。这个新变量叫作**匹配变量 match variable**。

``` C#
if (myEmployee is Supervisor mySupervisor)
{
    //如果检测通过了，mySupervisor变量立即可以使用
    Console.WriteLine($"My supervisor’s name is { mySupervisor.Name }");
}
```

## switch 模式匹配 C#7.0
C#7.0 对 switch 语句做了很多重要的改进。switch 语句之前受限于编译时常量，包括 char、string、bool、integer等。现在可以使用任何类型进行检测，包括用户自定义的类型：class、struct、array、enum、delegate和interface。示例如下：

``` C#
using static System.Console;

public abstract class Investment
{
    public string Name { get; set; }
    public double MinPurchaseAmt { get; set; }
}

public class Stock : Investment { }
public class Bond : Investment { }
public class BankAccount : Investment { }
public class RealEstate : Investment { }

class Program
{
    static void Main()
    {
        var myStock = new Stock() { Name = "Tesla", MinPurchaseAmt = 1000 };
        var myBond = new Bond() { Name = "California Municipal", MinPurchaseAmt = 500 };
        var myBankAccount = new BankAccount() { Name = "ABC Bank", MinPurchaseAmt = 10 };
        var myBankAccount2 = new BankAccount() { Name = "XYZ Bank", MinPurchaseAmt = 20 };
        var myRealEstate =
                new RealEstate() { Name = "My Vacation Home", MinPurchaseAmt = 100_000 };

        CheckInvestmentType(myStock);
        CheckInvestmentType(myBond);
        CheckInvestmentType(myBankAccount);
        CheckInvestmentType(myBankAccount2);
        myBankAccount2 = null;
        CheckInvestmentType(myBankAccount2);
        CheckInvestmentType(myRealEstate);
    }

    public static void CheckInvestmentType (Investment investment)
    {
        switch (investment)
        {
            case Stock stock:
            WriteLine($"This investment is a stock named {stock.Name}");
            break;
            case Bond bond:
            WriteLine($"This investment is a bond named {bond.Name}");
            break;
            case BankAccount bankAccount when bankAccount.Name.Contains("ABC") :
            WriteLine($"This investment is my ABC Bank account");
            break;
            case BankAccount bankAccount:
            WriteLine($"This investment is any bank account other than ABC Bank");
            break;
            case null:
            WriteLine("For whatever reason, this investment is null. ");
            break;
            default:
            WriteLine("The default case will always be evaluated last. ");
            WriteLine("Even if its position is not last.");
            break;
        }
    }
}
```

运行结果如下：

``` console
This investment is a stock named Tesla
This investment is a bond named California Municipal
This investment is my ABC Bank account
This investment is any bank account other than ABC Bank
For whatever reason, this investment is null.
The default case will always be evaluated last.
Even if its position is not last.
```

所有类型模式都有一个隐含的 when 子句条件，即当类型不为 null 时。这可以防止 switch 语句中的第一个类型匹配空值，从而触发其 switch 块中的语句，产生意外结果。可以添加特殊的 case 语句来处理 null 的情况，也可以在默认块中处理。

与之前不同，case 语句的顺序现在很重要。现在必须将列表中所有特殊的情况放在普通情况之前，之前因为是常量，值总是互斥的，所以不重要。

## 表达式函数体成员的扩展 C#7.0
表达式函数体成员是指一种使用 Lambda 符号（=>）引入单行语句，而不是将其放在一组大括号中的语法。C#7.0使其允许在构造函数、析构函数以及属性和索引器的 get 和 set 访问器使用表达式函数体成员。示例如下：

``` C#
//构造函数
public MyClass (string var1) => this.Var1 = var1;

//析构函数
~MyClass() => Console.WriteLine( "Unmanaged resources have been released ");

public string Area
{
    get => mArea;
    set => mArea = value;
}
```

## throw 表达式 C#7.0
在C#7.0之前，throw 关键字只能在语句中使用，现在可以在一些需要表达式的场景下使用，包括条件表达式、空接合表达式和一些 Lambda 表达式。

throw 表达式最常用的例子是空接合运算符，空接合运算符详见下一章节，它有两个操作数，第一个操作数是可空的，当它解析为空时，就使用第二个非空的表达式：

``` C#
bool? success = LoadResource(); //可空类型
var resourceLoadResult =
        success ?? throw new InvalidOperationException("Resource load failed");
```


# 第二十七章 其他主题
## 字符串
BCL 提供了很多能让字符串操作变得更简单的类。C# 预定义的 string 类型代表了 .NET 的 System.String 类。关于字符串的重要事项如下：  
①字符串是 Unicode 字符数组；  
②字符串是**不可变的 immutable**，它们不能被修改。

string 类型有很多有用的字符串操作成员，下表列出了其中一些最有用的成员：

| 成员 | 类型 | 意义 |
| :---- | :---- | :---- |
| Length | 属性 | 返回字符串长度 |
| Concat | 静态方法 | 返回连接参数字符串后的字符串 |
| Contains | 方法 | 返回指示参数是否是对象字符串的子字符串的bool值 |
| Format | 静态方法 | 返回格式化后的字符串 |
| Insert | 方法 | 接受一个字符串和一个位置作为参数，创建并返回一个在指定位置插入了参数字符串的新的字符串对象副本 |
| Remove | 方法 | 返回对象字符串的副本，其中移除了一个子字符串 |
| Replace | 方法 | 返回对象字符串的副本，其中替换了一个子字符串 |
| Spilt | 方法 | 返回一个包含原始字符串的子字符串的字符串数组。对于每个输入参数，为方法提供一组分隔符来分隔目标子字符串 |
| Substring | 方法 | 获取对象字符串的子字符串 |
| ToLower | 方法 | 返回对象字符串的副本，其中所有字母字符都为小写 |
| ToUpper| 方法 | 返回对象字符串的副本，其中所有字母字符都为大写 |

从上表中的大多数方法的名字来看，好像它们都会改变字符串对象。其实，它们不会改变字符串而是返回了新的副本。对于一个 string ，任何“改变”都会分配一个新的不可变字符串。

## StringBuilder 类
**StringBuilder 类**可以帮助你动态、有效地产生字符串，并且避免创建许多副本：  
①StringBuilder 类是 BCL 的成员，位于 System.Text 命名空间中；  
②StringBuilder 对象是 Unicode 字符的可变数组。

例如，下面的代码声明并初始化了一个 StringBuilder 类型的字符串，然后输出了它的值。第四行代码通过替换初始字符串的一部分改变了实际对象：

``` C#
using System;
using System.Text;

class Program
{
    static void Main()
    {
        StringBuilder sb = new StringBuilder( "Hi there." );
        Console.WriteLine($"{ sb.ToString() }");

        sb.Replace( "Hi", "Hello" ); 
        Console.WriteLine($"{ sb.ToString() }"); 
    }
}
```

运行结果如下：

``` console
Hi there.
Hello there.
```

当依据给定的字符串创建了 StringBuilder 对象之后，类分配了一个比当前字符串长度更长的缓冲区。只要缓冲区能容纳对字符串的改变就不会分配新的内存。如果对字符串的改变需要的空间比缓冲区中的可用空间多，就会分配更大的缓冲区，并把字符串复制到其中。和原来的缓冲区一样，新的缓冲区也有额外的空间。

要获取 StringBuilder 对应的字符串内容，只需要调用它的 ToString 方法即可。

## 把字符串解析为数据值
①**解析 Parse** 允许我们接受表示值的字符串，并且把它转换为实际的类型值；  
②所有预定义的简单类型都有一个叫做 Parse 的静态方法，它接受一个表示值的字符串，并且把它转换为类型的实际值；  
③如果字符串无法解析，系统会抛出异常。

