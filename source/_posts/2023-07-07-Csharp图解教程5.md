---
title: 《C#图解教程》读书笔记（五）
date: 2023-07-07 14:09:57
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：XXXXXXXXXXXXXXXX 。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第二十四章 预处理指令
## 什么是预处理指令
源代码指定了程序的定义，**预处理指令 preprocessor directive** 指示编译器如何处理源代码。例如，在某些情况下，我们可能希望编译器忽略一部分代码，而在其他情况下，我们可能希望代码被编译。预处理指令给了我们这样的选项。

在 C 和 C++ 中有实际的预处理阶段，此时预处理程序遍历源代码并且为之后的编译阶段准备文本输出流。在 C# 中没有实际的预处理程序。“预处理”指令由编译器来处理，而这个术语保留了下来。

## 基本规则
下面是预处理指令最重要的一些语法规则：  
①预处理指令必须和 C# 代码在不同的行；  
②与 C# 语句不同，预处理指令不需要以分号结尾；  
③包含预处理指令的每一行必须以#字符开始：
&emsp;&emsp;- 在#字符前可以有空格；  
&emsp;&emsp;- 在#字符和指令之间可以有空格。
④允许行尾注释；  
⑤在预处理指令所在的行不允许分隔符注释。

``` C#
#define PremiumVersion     //没有分号，正确
  #define BudgetVersion    //前面有空格，正确
# define MediumVersion     //中间有空格，正确

#define PremiumVersion     /* all bells & whistles */ 不允许分隔符注释，错误

#define BudgetVersion      // Stripped-down version 允许行尾注释，正确
```

下表列出了预处理指令：

| 指令 | 含义概要 |
| :---- | :---- |
| #define identifier | 定义编译符号 |
| #undef identifier | 取消定义编译符号 |
| #if expression | 如果表达式是true，则编译器编译下面的片段 |
| #elif expression | 如果表达式是true，则编译器编译下面的片段 |
| #else | 如果之前的#if或#elif表达式是false，则编译器编译下面的片段 |
| #endif | 标记一个#if结构的结束 |
| #region name | 标记一段代码的开始，没有编译效果 |
| #endregion name | 标记一段代码的结束，没有编译效果 |
| #warning message | 显示编译时的警告消息 |
| #error message | 显示编译时的错误消息 |
| #line indicator | 修改在编译器消息中显示的行数 |
| #pragma warning | 提供修改编译器警告消息行为的选项 |

## `#define` 和 `#undef` 指令
**编译符号 compilation symbol** 是只有两种可能状态的标识符，要么被定义，要么未被定义。编译符号有如下特性：  
①它可以是除了 true 或 false 以外的任何标识符，包括 C# 关键字，以及在 C# 代码中声明的标识符，这两者都是可以的；  
②它没有值。与 C 和 C++ 不同，它不表示字符串。

`#define` 和 `#undef` 指令只能用在源文件的第一行，也就是任何 C# 代码之前。在 C# 代码开始后，`#define` 和 `#undef` 指令就不能再使用。编译符号的范围被限制于单个源文件。只要编译符号在任何 C# 代码之前，重复定义已存在的编译符号也是允许的。

定义一个标识符相当于将其值设置为 true。取消定义一个标识符相当于将其值设置为 false。尽管必须在 C# 代码之外定义标识符，但可以在 C# 代码中使用它，通常是在 `#if #else` 构造中使用，如下：

``` C#
#define debug
static void Main()
{
    #if debug
        //开启详细日志
    #else
        //性能优化
    #endif
        ...
}
```

## 条件编译
条件编译允许根据某个编译符号是否被定义标注一段代码被编译或跳过。

有4个指令可以用来指定条件编译：`#if`; `#else`; `#elif`; `#endif`。

在`#if`和`#elif`指令中使用的条件是一个返回 true 或 false 的简单表达式，如下表所总结的。条件可以由单个编译符号、符号表达式或操作符组成；子条件可以使用圆括号分组；文本 true 或 false 也可以在条件表达式中使用：

| 参数类型 | 意义 | 运算结果 |
| :---- | :---- | :---- |
| 编译符号 | 使用`#define`指令定义（或未被定义）的标识符 | true：如果符号已经使用`#define`指令定义 <br> false：其他 |
| 表达式 | 使用符号和操作符!、==、!=、&&、&#9474;&#9474;构建的 | true：如果表达式运算结果为true <br> false：其他 |

条件编译示例如下：  

``` C#
#if !DemoVersion //表达式
    …
#endif

#if(LeftHanded && OemVersion) //完整版
    …
#endif

#if true //下面的代码片段总是会被编译
    …
#endif
```

## 条件编译结构
`#if` 和 `#endif` 指令在条件编译结构中需要配对使用。

例如，如下的代码演示了简单的 `#if...#else` 结构。如果符号 RightHanded 被定义了，那么 `#if` 和 `#else` 之间的代码会被编译。否则，`#else` 和 `#endif` 之间的代码会被编译：

``` C#
...
#if RightHanded
    // Code implementing right-handed functionality
    ...
#else
    // Code implementing left-handed functionality
    ...
#endif
```

如下的代码演示了 `#if...#elif...#else` 结构。包含程序版本描述的字符串根据定义的编译符号被设置为不同的值：  

``` C#
#define DemoVersionWithoutTimeLimit

using System;

class demo
{
    static void Main()
    {
        const int intExpireLength = 30;
        string strVersionDesc = null;
        int intExpireCount = 0;

#if DemoVersionWithTimeLimit
    intExpireCount = intExpireLength;
    strVersionDesc = "This version of Supergame Plus will expire in 30 days";

#elif DemoVersionWithoutTimeLimit
    strVersionDesc = "Demo Version of Supergame Plus";

#elif OEMVersion
    strVersionDesc = "Supergame Plus, distributed under license";

#else
    strVersionDesc = "The original Supergame Plus!!";

#endif

        Console.WriteLine(strVersionDesc);
    }
}
```

运行结果如下：

``` console
Demo Version of Supergame Plus
```

## 诊断指令
**诊断指令 Diagnostic Directives** 产生用户自定义的编译时警告及错误消息。

下面是诊断指令的语法。 Message 是字符串，但是需要注意，与普通的 C# 字符串不同，它们不需要被引号包围。

``` C#
#warning Message

#error Message
```

当编译器遇到诊断指令时，它会输出相关的消息。诊断指令的消息会和任何编译器产生的警告和错误消息列在一起。

## 行号指令
**行号指令 Line number directives** 可以做很多事情，诸如：  
①改变由编译器警告和错误消息报告的出现行数；  
②改变被编译源文件的文件名；  
③对交互式调试器隐藏一些行。

`#line` 指令的语法如下：

``` C#
#line integer    //将下一行的行号设置为整数
#line "filename" //设置文件名
#line default    //重新保存实际的行号和文件名

#line hidden     //对断点调试器隐藏以下代码
#line            //停止在调试器中隐藏代碼
```

带一个整数参数的 `#line` 指令会使编译器将该值视为下一行代码的行号，之后的行号会在这个行号的基础上递增。  
①要改变文件名，可以在双引号内使用文件名作为参数。双引号是必需的；  
②要返回真实行号和真实文件名，可以使用 default 参数；  
③要对交互式调试器的断点调试功能隐藏代码段，可以使用 hidden 作为参数。要停止隐藏，可以使用不带任何参数的指令。到目前为止，这个功能大多用于在 ASP.NET 和 WPF 中隐藏编译器生成的代码。

``` C#
#line 226
    x = y + z; //现在编译器认为这是第226行
    ...

#line 330 "SourceFile.cs" //改变报告的行号和文件名
    var1 = var2 + var3;
    ...

#line default //重新保存行号和文件名
```

## 区域指令
**区域指令 region directive** 允许标注和有选择性地命名一段代码。区域由一个 region 指令和某下方某处的一个 `#endregion` 指令构成。通过仅显示当前要处理的代码区域，区域功能可以让你更轻松地浏览代码。它还允许你通过位置组织代码，例如所有的属性放在同一位置，所有方法放在另一个位置。`#region` 指令的特性如下：  
①`#region` 指令被放置在你想要标注的代码段上，而 `#endregion` 指令被放置在区域中最后一行代码之后；  
②`#region` 指令用其后的可选文本字符串作为区域的名称；  
③区域可以内嵌在其他的区域内：  
&emsp;&emsp;- 区域可以内嵌到任何级别，区域可以嵌套；  
&emsp;&emsp;- `#endregion` 指令始终与其上方的第一个没匹配过的 `#region` 指令匹配。

尽管区域指令被编译器忽略，但它们可以被源代码工具所使用。例如，Visual Studio允许我们很简单地隐藏或显式区域。作为示例，下面的代码中有一个叫做 Constructors 的区域，它封闭了 MyClass 类的两个构造函数。在 Visual Studio 中，如果不想看到其中的代码，可以把这个区域折叠成一行，如果又想对它进行操作或增加另外一个构造函数，还可以扩展它：

``` C#
#region Constructors
    MyClass()
    { ... }

    MyClass(string s)
    { ... }
#endregion
```

## `#pragma warning` 指令
利用 `#pragma warning` 指令可以关闭及重新开启警告消息：  
①要关闭警告消息，可以使用 disable 形式加上希望关闭的警告数的逗号分隔的形式列表；  
②要重新开启警告消息，可以使用 restore 形式加上希望关闭的警告数的逗号分隔的形式列表。

例如，下面的代码关闭了两个警告消息：618和414。在后面的代码中又开启了618警告消息，但还是保持414消息为关闭状态：

``` C#
#pragma warning disable 618, 414 //要关闭的警告信息
    ... //列出的警告信息在这段代码中处于关闭状态
#pragma warning restore 618
```

如果我们使用任意一种不带警告数字列表的形式，这个命令会应用于所有警告。例如，下面的代码关闭然后恢复所有警告消息：

``` C#
#pragma warning disable
    ... //所有警告信息在这段代码中处于关闭状态

#pragma warning restore
    ... //所有警告信息在这段代码中处于开启状态
```


# 第二十五章 反射和特性
## 元数据和反射
大多数程序都要处理数据，包括读、写、操作和显示数据。（图形也是数据的一种形式。）然而，对于某些程序来说，它们操作的数据不是数字、文本或图形，而是关于程序和程序类型的信息。  
①有关程序及其类型的数据被称为**元数据 metadata**，它们保存在程序的程序集中；  
②程序在运行时，可以查看其他程序集或其本身的元数据。运行中的程序査看本身的元数据或其他程序的元数据的行为叫做**反射 reflection**。

对象浏览器是显式元数据的程序的一个示例。它可以读取程序集，然后显示所包含的类型以及类型的所有特性和成员。

本章将介绍程序如何使用 **Type 类**来反射数据，以及程序员如何使用**特性 attributes** 来给类型添加元数据。

> 要使用反射，我们必须使用 System.Reflection 命名空间。

## Type 类
BCL 声明了一个叫做 Type 的抽象类，它被设计用来包含类型的特性。使用这个类的对象能获取程序使用的类型的信息。

由于 Type 是抽象类，因此它不能有实例。在运行时，CLR 创建从 Type(RuntimeType) 派生的类的实例，Type 包含了类型信息。当访问这些实例时，CLR 不会返回派生类的引用而是返回 Type 基类的引用。但是，为了简单起见，在本章剩余的篇幅中，会把引用所指向的对象称为 Type 类型的对象（虽然从技术角度来说它是一个 BCL 内部的派生类型的对象）。

需要了解的有关 Type 的重要事项如下：  
①对于程序中用到的每一个类型，CLR 都会创建一个包含这个类型信息的 Type 类型的对象；  
②不管创建的类型有多少个实例，只有一个 Type 对象会关联到所有这些实例。

下图显示了一个运行的程序，它有两个 MyClass 对象和一个 OtherClass 对象。注意，尽管有两个 MyClass 的实例，只会有一个 Type 对象来表示它：

<div  align="center">  
<img src="https://s2.loli.net/2023/07/08/GSnWuZd9UPpOIfE.png" width = "60%" height = "60%" alt="图120 - 对于程序中使用的每一个类型，CLR都会实例化Type类型的对象"/>
</div>

可以从 Type 对象中获取有关类型的几乎所有信息。下表列出了 System.Type 类的部分成员：

| 成员 | 成员类型 | 描述 |
| :---- | :---- | :---- |
| Name | 属性 | 返回类型的名字 |
| Namespace | 属性 | 返回包含类型声明的命名空间 |
| Assembly | 属性 | 返回声明类型的程序集。如果类型是泛型的，返回定义这个类型的程序集 |
| GetFields | 方法 | 返回类型的字段列表 |
| GetProperties | 方法 | 返回类型的属性列表 |
| GetMethods | 方法 | 返回类型的方法列表 |

## 获取 Type 对象
本节学习，使用实例对象的 GetType 方法或者 typeof 运算符和类名来获取 Type 对象。object 类型包含了一个叫做 GetType 的方法，它返回对实例的 Type 对象的引用。由于每一个类型最终都是从 object 派生的，所以我们可以在任何类型的对象上使用 **GetType 方法**来获取它的 Type 对象，如下所示：`Type t = myInstance.GetType();`

下面的代码演示了如何声明一个基类以及从它派生的子类。Main 方法创建了每一个类的实例并且把这些引用放在了一个叫做 bca 的数组中以方便使用。在外层的 foreach 循环中，代码得到了 Type 对象并且输出类的名字，然后获取类的字段并输出。代码后的图演示了内存中的对象：

``` C#
using System;
using System.Reflection; //必须使用该命名空间

class BaseClass
{
    public int BaseField = 0;
}

class DerivedClass : BaseClass
{
    public int DerivedField = 0;
}

class Program
{
    static void Main( )
    {
        var bc = new BaseClass();
        var dc = new DerivedClass();

        BaseClass[] bca = new BaseClass[] { bc, dc };

        foreach (var v in bca)
        {
            Type t = v.GetType(); //获取类型

            Console.WriteLine($"Object type : { t.Name }");

            FieldInfo[] fi = t.GetFields(); //获取字段信息
            foreach (var f in fi)
                Console.WriteLine($" Field : { f.Name }");
            Console.WriteLine();
        }
    }
}
```

运行结果如下：

``` console
Object type : BaseClass
 Field : BaseField

Object type : DerivedClass
 Field : DerivedField
 Field : BaseField
```

<div  align="center">  
<img src="https://s2.loli.net/2023/07/08/IayVTBjoL7MAkeO.png" width = "60%" height = "60%" alt="图121 - 基类和派生类对象以及它们的 Type 对象"/>
</div>

还可以使用 **typeof 运算符**来获取 Type 对象。只需要提供类型名作为操作数，它就会返回 Type 对象的引用，如下所示：`Type t = typeof( DerivedClass );`

示例如下：

```C#
using System;
using System.Reflection; //必须使用该命名空间

namespace SimpleReflection
{
    class BaseClass
    {
        public int BaseField;
    }

    class DerivedClass : BaseClass
    {
        public int DerivedField;
    }

    class Program
    {
        static void Main()
        {
            Type tbc = typeof(DerivedClass); //获取类型
            Console.WriteLine($"Object type : { tbc.Name }");
            FieldInfo[] fi = tbc.GetFields();
            foreach (var f in fi)
                Console.WriteLine($" Field : { f.Name }");
        }
    }
}
```

运行结果如下：

``` console
Object type : DerivedClass
 Field : DerivedField
 Field : BaseField
```

## 什么是特性
**特性 attribute** 是一种允许我们向程序的程序集增加元数据的语言结构。它是用于保存程序结构信息的某种特殊类型的类：  
①将应用了特性的程序结构 program construct 叫做目标 target ；  
②设计用来获取和使用元数据的程序（比如对象浏览器）叫做特性的消费者 consumer ；  
③ .NET 预定了很多特性，我们也可以声明自定义特性。

下图是使用特性中相关组件的概览，并且演示了如下有关特性的要点：  
①我们在源代码中将特性应用于程序结构；  
②编译器获取源代码并且从特性产生元数据，然后把元数据放到程序集中；  
③消费者程序可以获取特性的元数据以及程序中其他组件的元数据。注意，编译器同时生产和消费特性。

<div  align="center">  
<img src="https://s2.loli.net/2023/07/08/CFOw2pD6xrQIb5G.png" width = "60%" height = "60%" alt="图122 - 创建和使用特性的相关组件"/>
</div>

根据惯例，特性名使用 Pascal 命名法并且以 Attribute 后缀结尾。当为目标应用特性时，可以不使用后缀。例如，对于 SerializableAttribute 和 MyAttributeAttribute 这两个特性，在把它们应用到结构时可以使用 Serializable 和 MyAttribute 短名称。

## 应用特性
特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集。我们可以通过把特性应用到结构来实现：  
①通过在结构前放置**特性片段 attribute section** 来应用特性；  
②**特性片段**由方括号包围特性名和参数列表（可以没有）构成。

例如，下面的代码演示了两个类的开始部分。最初的几行代码演示了把一个叫做 Serializable 的特性应用到 MyClass 。注意，Serializable 没有参数列表。第二个类的声明有一个叫做 MyAttribute 的特性，它有一个带有两个 string 参数的参数列表：

``` C#
[ Serializable ] //特性
public class MyClass
{ ...

[ MyAttribute("Simple class", "Version 3.57") ] //带有参数的特性
public class MyOtherClass
{ ...
```

有关特性需要了解的重要事项如下：  
①大多数特性只应用于直接跟随在一个或多个特性片段后的结构；  
②应用了特性的结构称为被特性装饰（ decorated 或 adorned ）。

## 预定义的特性
本节介绍几个 .NET 预定义特性
### Obsolete 特性
一个程序可能在其生命周期中经历多次发布，而且很可能延续多年。在程序生命周期的后半部分，程序员经常需要编写类似功能的新方法替换老方法。出于多种原因，你可能不想再使用那些调用过时的旧方法的老代码，而只想用新编写的代码调用新方法。

如果出现这种情况，你肯定希望稍后操作代码的团队成员或程序员也只使用新代码。要警告他们不要使用旧方法，可以使用 Obsolete 特性将程序结构标注为过期的，并且在代码编译时显示有用的警告消息。以下代码给出了一个示例：

``` C#
class Program
{
    [Obsolete("Use method SuperPrintOut")] //将特性应用到方法
    static void PrintOut(string str) {
        Console.WriteLine(str);
    }
    static void Main(string[] args) {
        PrintOut("Start of Main"); //调用 obsolete 方法
    }
}
```

注意，即使 PrintOut 被标注为过期，Main 方法还是调用了它。代码编译也运行得很好，并且产生了如下的输出：

``` console
Start of Main
```

不过，在编译的过程中，编译器产生了下面的 CS0618 警告消息来通知我们正在使用一个过期的结构:`[CS0618] “Program.PrintOut(string)”已过时:“Use method SuperPrintOut”`

Obsolete 特性的另外一个重载接受了 bool 类型的第二个参数。这个参数指定目标是否应该被标记为错误而不仅仅是瞥告。以下代码指定了它应被标记为错误：

``` C#
[ Obsolete("Use method SuperPrintOut", true) ] //标记为错误，将特性应用到方法
static void PrintOut(string str)
{ ...
```

### Conditional 特性
Conditional 特性允许我们包括或排斥特定方法的所有调用。要使用 Conditional 特性，将其应用于方法声明并把编译符作为参数：  
①如果定义了编译符号，那么编译器会包含所有调用这个方法的代码，这和普通方法没有什么区别；  
②如果没有定义编译符号，那么编译器会忽略代码中这个方法的所有调用；  
③定义方法的 CIL 代码本身总是会包含在程序集中。只是调用代码会被插入或忽略；  
④除了在方法上使用 Conditional 特性之外，还可以在类上使用它，只要该类派生自 Attribute 类。这里不会介绍 Conditional 特性的这种用法。

在方法上使用 Conditional 特性的规则如下：  
①该方法必须是类或结构体的方法；  
②该方法必须是 void 类型；  
③该方法不能被声明为 override，但可以标记为 virtual；  
④该方法不能是接口方法的实现。

例如，在如下的代码中，Conditional 特性被应用到一个叫作 TraceMessage 的方法的声明上。特性只有一个参数，在这里是字符串 DoTrace 。  
①当编译器编译这段代码时，它会检査是否定义了一个名为 DoTrace 的编译符号；  
②如果定义了 DoTrace ，编译器就会像往常一样在代码中包含所有对 TraceMessage 方法的调用；  
③如果没有定义 DoTrace 编译符号，编译器就不会输出任何对 TraceMessage 的任何调用代码。

``` C#
[Conditional( "DoTrace" )] //编译符号
static void TraceMessage(string str)
{
    Console.WriteLine(str);
}
```

***Conditional 特性的示例***  
以下代码演示了一个使用 Conditional 特性的完整示例：  
①Main 方法包含了两个对 TraceMessage 方法的调用；  
②TraceMessage 方法的声明被用 Conditional 特性装饰，它带有 DoTrace 编译符号作为参数。因此，如果 DoTrace 被定义，那么编译器就会包含对 TraceMessage 所有调用的代码；  
③由于代码的第一行定义了叫做 DoTrace 的编译符，编译器会包含两个 TraceMessage 的调用代码。

``` C#
#define DoTrace
using System;
using System.Diagnostics;

namespace AttributesConditional
{
    class Program
    {
        [Conditional( "DoTrace" )]
        static void TraceMessage(string str)
        { Console.WriteLine(str); }

        static void Main( )
        {
            TraceMessage("Start of Main");
            Console.WriteLine("Doing work in Main.");
            TraceMessage("End of Main");
        }
    }
}
```

运行结果如下：  

``` console
Start of Main
Doing work in Main.
End of Main
```

如果注释掉第一行来取消 DoTrace 的定义，编译器就不再会插人两次对 TraceMessage 的调用代码。这次，如果我们运行程序，就会产生如下输出：

``` console
Doing work in Main.
```

### 调用者信息特性
利用调用者信息特性可以访问文件路径、代码行数、调用成员的名称等源代码信息。  
①这三个特性名称为 CallerFilePath 、CallerLineNumber 和 CallerMemberName；  
②这些特性只能用于方法中的可选参数。

下面的代码声明了一个名为 MyTrace 的方法，它在三个可选参数上使用了这三个调用者信息特性。如果调用方法时显式指定了这些参数，则会使用真正的参数值。但在下面所示的 Main 方法中调用时，没有显式提供这些值，因此系统将会提供源代码的文件路径、调用该方法的代码行数和调用该方法的成员名称。

``` C#
using System;
using System.Runtime.CompilerServices;

public static class Program
{
    public static void MyTrace( string message,
                                [CallerFilePath] string fileName = "",
                                [CallerLineNumber] int lineNumber = 0,
                                [CallerMemberName] string callingMember = "" )
    {
        Console.WriteLine($"File: { fileName }");
        Console.WriteLine($"Line: { lineNumber }");
        Console.WriteLine($"Called From: { callingMember }");
        Console.WriteLine($"Message: { message }");
    }

    public static void Main()
    {
        MyTrace( "Simple message" );
    }
}
```

运行结果如下：

``` console
File: C:\Users\XXXX\XXXX\XXXX\Program.cs
Line: 19
Called From: Main
Message: Simple message
```

### DebuggerStepThrough 特性
我们在单步调试代码时，常常希望调试器不要进入某些方法。我们只想执行该方法，然后继续调试下一行。DebuggerStepThrough 特性告诉调试器在执行目标代码时不要进入该方法调试。

在我自己的代码中，这是最有用的特性。有些方法很小并且毫无疑问是正确的，在调试时对其反复单步调试只能徒增烦恼。但使用该特性时要十分小心，因为你并不想排除那些可能含有 bug 的代码。

关于 DebuggerStepThrough 要注意以下两点：  
①该特性位于 System.Diagnostics 命名空间；  
②该特性可用于类、结构、构造函数、方法或访问器。

下面这段编造的代码在一个访问器和一个方法上使用了该特性。你会发现，调试器调试这段代码时不会进入 IncrementFields 方法或 X 属性的 set 访问器。

``` C#
using System;
using System.Diagnostics; //DebuggerStepThrough特性所需的

class Program
{
    int x = 1;
    int X
    {
        get { return x; }
        [DebuggerStepThrough] //不进入set访问器
        set
        {
            x = x * 2;
            x += value;
        }
    }

    public int Y { get; set; }

    public static void Main()
    {
        Program p = new Program();
        p.IncrementFields();
        p.X = 5;
        Console.WriteLine( $"X = { p.X }, Y = { p.Y }" );
    }

    [DebuggerStepThrough] //不进入这个方法
    void IncrementFields()
    {
        X++; Y++;
    }
}
```

### 其他预定义特性
.NET 框架预定义了很多编译器和 CLR 能理解和解释的特性，下表列出了一些。在表中使用了不带 Attribute 后缀的短名称。例如，CLSCompliant 的全名是 CLSCompliantAttribute 。

| 特性 | 意义 |
| :---- | :---- |
| CLSCompliant | 声明公开暴露的成员应该被编译器检测其是否符号CLS。兼容的程序集可以被任何兼容.NET的语言使用 |
| Serializable | 声明结构可以被序列化 |
| NonSerialized | 声明结构不能被序列化 |
| DLLImport | 声明是非托管代码实现的 |
| WebMethod | 声明方法应该被作为 XML Web 服务的一部分暴露 |
| AttributeUsage | 声明特性能应用于什么类型的程序结构。将这个特性应用到特性声明上 |

## 关于应用特性的更多内容
本节介绍特性的一些其他使用方式。

### 多个特性
可以为单个结构应用多个特性：  
①多个特性可以使用下面任何一种格式列出：  
&emsp;&emsp;- 独立的特性片段一个接一个。通常，它们彼此叠加，位于不同的行中；  
&emsp;&emsp;- 单个特性片段，特性之间使用逗号分隔。  
②可以以任何次序列出特性。

例如，下面的两个代码片段显示了应用多个特性的两种方式。两个片段的代码是等价的。

``` C#
[ Serializable ] //多层结构
[ MyAttribute("Simple class", "Version 3.57") ]

[ MyAttribute("Simple class", "Version 3.57"), Serializable ] //逗号分隔
```

### 其他类型的目标
除了类，还可以将特性应用到诸如字段和属性等其他程序结构。