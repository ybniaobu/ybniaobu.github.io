---
title: 屏幕空间环境光遮蔽（二）HBAO 与 GTAO
date: 2025-09-09 20:10:09
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2025/09/09/Uq93S46lgTAHs7Q.gif
mathjax: true
description: 本文章主要内容有XXXXXXXXXXXXXX。
---

# HBAO

> HBAO 参考文献如下：  
> ① Image-Space Horizon-Based Ambient Occlusion (Siggraph 2008)：https://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf 、https://www.researchgate.net/publication/215506032_Image-space_horizon-based_ambient_occlusion ；  
> ② NVIDIA DirectX 11 SDK Sample：https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/SSAO11.pdf 、 https://github.com/LiveMirror/NVIDIA-Direct3D-SDK-11/tree/master/SSAO11 ；  
> ③ An alternative implementation for HBAO：https://www.derschmale.com/2013/12/20/an-alternative-implementation-for-hbao-2/ ；  
> ④ NVIDIA's HBAO+ ：https://github.com/NVIDIAGameWorks/HBAOPlus ；

## HBAO 原理及流程
### 基本流程
书接上文，话说秦琼卖马……不好意思放错碟了。正如上篇文章所说，**Horizon-Based Ambient Occlusion (HBAO)** 由 NVIDIA 的 Louis Bavoil 于 SIGGRAPH 2008 中提出，资料详见上面参考文献中的 **①** Image-Space Horizon-Based Ambient Occlusion，有演讲的 PPT 和对应的论文。HBAO 的主要思路就是将 Z-Buffer 视做高度场，然后在屏幕空间中朝着一定数量的等角的方向进行步进，如下图：

<div align="center">  
<img src="https://s2.loli.net/2025/09/16/cDQAqnUwX6k4MFg.png" width = "20%" height = "20%" alt="图14 - Raymarching Depth Buffer"/>
</div>

同时在每个方向上的一定范围内寻找一个最高高度，这个最高高度所形成的仰角称为 **Horizon Angle**，它是计算 Ambient Occlusion 的依据之一。

<div align="center">  
<img src="https://s2.loli.net/2025/09/16/vaNzfwH2FbgTcxr.png" width = "45%" height = "45%" alt="图15 - Marching on the heightfield"/>
</div>

但是这样得到的角度，是基于视角方向的高度角，而 AO 是基于法线的，我们需要额外考虑法线和视角方向的夹角，即 **Tangent Angle**：  

<div align="center">  
<img src="https://s2.loli.net/2025/09/16/vHUQhs9BaCS57y4.png" width = "40%" height = "40%" alt="图16 - Tangent Angle"/>
</div>

最近计算 AO 值：  

<div align="center">  
<img src="https://s2.loli.net/2025/09/16/g91xjpuCdOF5laW.png" width = "45%" height = "45%" alt="图17 - Horizon-Based AO"/>
</div>

这里要注意一下，Horizon Angle 和 Tangent Angle 都是带正负符号的角度值，所以 AO 的计算公式看似是两个角度的正弦值相减，但在上图中其实可以说是相加。

### 数学原理
HBAO 的 AO 计算公式如下：  

$$ A = 1 - \cfrac {1} {2\pi} \int_{\Omega} V(\vec{\omega})W(\vec{\omega})d{\omega} $$

其中 $\,V(\vec{\omega})\,$ 是可见性函数，在 $\,\omega\,$ 方向上与遮挡物相交则返回 1，没相交则返回 0，和上篇文章中的可见性函数是反过来的，所以这里 AO 要用 1 减。$\,W(\vec{\omega})\,$ 是线性距离衰减函数。可以发现上述公式和上一篇文章的 AO 公式是不同的，这个公式实际上是 AO 的另外一种形式，上一篇文章的 AO 公式是带余弦权重的，如果不带余弦权重，就可以退化为上述公式，GTAO 的 [PPT](https://blog.selfshadow.com/publications/s2016-shading-course/activision/s2016_pbs_activision_occlusion.pdf) 中也提到了这一点，但是这个公式相对于带余弦权重的公式是没有那么 ground truth 的，这应该也是 GTAO 相比 HBAO 更真实的原因之一吧。

接下来就是对上述公式进行拆分，拆分为球坐标下的积分：  

$$ A = 1 - \cfrac {1} {2\pi} \int_{\theta = \pi}^{-\pi} \int_{\alpha = t(\theta)}^{h(\theta)} W(\vec{\omega}) cos\alpha d{\alpha}d{\theta} $$

<div align="center">  
<img src="https://s2.loli.net/2025/09/16/84956z3m2luIMCt.png" width = "40%" height = "40%" alt="图18 - Horizon-Based AO"/>
</div>

首先要注意一下，球坐标的**天顶角 Polar angle** 是 $\,\theta\,$，**方位角 Azimuthal angle** 是 $\,\phi\,$。但上述公式的方位角是 $\,\theta\,$，而 $\,\alpha\,$ 并非是常规的天顶角，而称为**仰角 Elevation angle**。常规球坐标的天顶角是相对于 Z 轴的角度，而这里的 Elevation angle 是基于 xy 平面的角度，这也是为什么上述公式拆分时多出来的是 $\,cos\alpha\,$ 而非 $\,sin\alpha\,$ 的原因。

上述公式的理解也比较简单，就是对于半球中心点 P 的每一个方向，累计从 $\,t(\theta)\,$ 到 $\,h(\theta)\,$ 范围（即被遮挡的范围）的距离衰减函数，作为该方向的 AO 值，再将方向旋转 $\,2\pi\,$ 角度，累计形成半球，即最终 P 点的 AO 值。

又因为 $\,cos\alpha\,$ 的积分就是 $\,sin\alpha\,$，且 $\,W(\vec{\omega})\,$ 是与 $\,\alpha\,$ 无关的函数，上述公式可以进一步简化为：  

$$ A = 1 - \cfrac {1} {2\pi} \int_{\theta = \pi}^{-\pi} (sin(h(\theta)) - sin(t(\theta)))W(\theta) d{\theta} $$

其中 $\,W(\theta) = max(0, 1 - r(\theta) / R)\,$，$\,r(\theta)\,$ 是点 P 和 Horizon Point 的距离，R 是 AO 的影响范围。这就是 HBAO 最终的公式，这也是图 17 中 $\,AO = sinh - sint\,$ 的数学来源。在屏幕空间中朝着一定数量的等角的方向进行步进，就相当于使用黎曼和求解上述积分公式，故上述公式最终可以写为如下：  

$$ A \approx 1 - \cfrac {1} {2\pi} \cdot \cfrac {\pi - (-\pi)} {N} \sum_{i = 1}^N (sin(h(\theta)) - sin(t(\theta))) W(\theta) = 1 - \cfrac {1} {N} \sum_{i = 1}^N (sin(h(\theta)) - sin(t(\theta))) W(\theta) $$

## 具体实现
以下内容主要参考了 [NVIDIA DirectX 11 SDK Sample](https://github.com/LiveMirror/NVIDIA-Direct3D-SDK-11/tree/master/SSAO11) 的代码，略微做出了点改动，最主要的改动是原代码使用了邻近像素点重建切线，而我直接使用了 Normal Buffer。

### 计算步长
首先要先采样 Depth Buffer 重构当前像素点的观察空间坐标，以及采样 Normal Buffer 获取世界空间的 Normal 并且转换至观察空间，具体如何重构观察空间坐标我就不再赘述了，属于基础知识：  

    float rawDepth = LoadDepth(id.xy);
    float3 P = FetchViewPosition(screenUV, rawDepth);

    float3 normalWS = LoadAndDecodeNormal(id.xy);
    float3 normalVS = TransformWorldToViewNormal(normalWS, true);

这里要注意一下 Unity 观察空间 z 轴的方向问题，+z 是指向摄像机的方向，为了方便理解建议反转一下，不反转也可以，就是后面计算时有些符号需要修改：  

    P.z = -P.z;
    normalVS.z = -normalVS.z;

因为我们往往会在观察空间（或世界空间下）定义 AO 的影响范围或半径 **Radius**，所以需要计算 AO 的影响范围在屏幕上的大小，以便我们计算在屏幕空间中每次步进的距离，同时若半径在屏幕上的大小比一个像素还小，就直接设置 AO 值为 1（即无 AO 效果），计算代码如下：  

    float radiusInUV = 0.5 * GetHBAORadius() * _CameraSettings.y / P.z;
    float radiusInPixel = radiusInUV * _TextureSize.w;
    
    if (radiusInPixel < 1)
    {
        _OutputTexture[id.xy] = float2(1.0, P.z);
        return;
    }

其中 `_CameraSettings.y` 是 $\,cot(FOV/2)\,$，为什么这么算，看看透视投影矩阵的 m00 和 m11 就明白了，除以 z 是透视除法，乘以 0.5 是因为 \[-1, 1\] 的范围要映射至 \[0, 1\]。得到了屏幕空间上的半径，就可以根据步进的步数计算步长了，一般步数 `NUM_STEPS` 为 4 ~ 8：  

    // Avoid oversampling if NUM_STEPS is greater than the kernel radius in pixels
    float numSteps = min(NUM_STEPS, radiusInPixel);
    float stepSizeInPixel = radiusInPixel / numSteps;
  
NVIDIA 还规定了一个最大采样像素半径，我没有使用，想添加可以看 NVIDIA 的代码。

### 步进
可以开始循环步进了，首先要根据设定的方向数量 `NUM_DIRECTIONS` 计算步进的方向，同时给每个方向添加一个随机旋转：  

    float ao = 0;
    float dirAngle = TWO_PI / NUM_DIRECTIONS;
    float noise = LOAD_TEXTURE2D_LOD(_BlueNoise64, id.xy % _BlueNoise64_TexelSize.zw, 0).r;
    float randomRadian = (noise + _Jitter.w * IsTemporalBlurEnabled()) * TWO_PI;

    UNITY_UNROLL
    for (int d = 0; d < NUM_DIRECTIONS; ++d)
    {
        float angle = dirAngle * d + randomRadian;
        float2 dir = float2(cos(angle), sin(angle));
        float2 pixelDelta = dir * stepSizeInPixel;
        ...
    }

我还是使用了蓝噪声，感觉还是蓝噪声最适配 Temporal Filter。

## 其他说明
### Angle Bias

### HBAO+ 的方法

### Compute Shader 优化


# GTAO