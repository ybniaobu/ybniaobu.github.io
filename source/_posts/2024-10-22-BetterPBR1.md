---
title: Custom Better PBR in Unity（一）
date: 2024-10-22 11:13:12
categories: 
  - [图形学]
  - [unity, pipeline]
tags:
  - 图形学
  - 游戏开发
  - unity
top_img: /images/black.jpg
cover: https://s2.loli.net/2024/10/22/x6Xp3JjS4k5PO2W.gif
mathjax: true
description: 
---

> 本文章所阐述的 PBR Shader 仍然是在 URP 下的自定义 Shader，使用的仍然是最简单的前向渲染，为未来实现自己的自定义渲染管线 SRP 打下一定的基础。本篇文章创建时期，该 Shader 只包含最基础的 BRDF 标准模型，以后会增加 Anisotropic、Clearcoat、Cloth、Subsurface 等模型，我放在我的 Github 库里：https://github.com/ybniaobu/Unity_YPipeline ，最终在这个库中会实现自己的自定义渲染管线 YPipeline。
>  
> 该 PBR Shader 主要参考了著名的 LearnOpenGL 教程：https://learnopengl-cn.github.io/ 或 https://learnopengl.com/ ，以及谷歌的 Filament PBR 白皮书：https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf 。

# Standard Shader 整体框架
顶点着色器不多说了，片元着色器整体框架如下：  
**1\. 初始部分**
$$\text{①声明 RenderingEquationContent 结构体}  \rightarrow \text{②声明并初始化材质及着色模型相关参数 InitializeStandardPBRParams} $$

**2\. IBL 部分**
$$ \text{③计算 RenderingEquationContent 里的 indirectLight (IBL) 项} $$

**3\. 主光源部分**
$$ \text{④声明并初始化主光源相关参数 InitializeMainLightParams} \rightarrow \text{⑤声明并初始化主光源 BRDF 计算所需参数 InitializeBRDFParams} $$ 

$$ \rightarrow \text{⑥计算 RenderingEquationContent 里的 directMainLight 项} $$

**3\. 其他光源部分**
$$ \text{⑦声明并初始化其他光源相关参数 InitializeAdditionalLightParams} \rightarrow \text{⑧声明并初始化其他光源 BRDF 计算所需参数 InitializeBRDFParams} $$ 

$$ \rightarrow \text{⑨计算 RenderingEquationContent 里的 directAdditionalLight 项} $$

每个步骤说明：  
**①**首先整个 Shader 的目的就是计算**渲染方程 The Rendering Equation**，即：L = Emission + Direct light diffuse term + Direct light specular term + Indirect light diffuse term + Indirect light specular term。由于游戏内需求的灯光不止一盏，故将 Direct light 分为 Main light 和 Additional light（暂时按 Unity 的 Main light 和 Additional light 的分法来，日后再修改）。故渲染方程可写为：L = Emission + Main Light + Additional Light + Indirect light (IBL)。

我把这些内容放置在了 `RenderingEquationLibrary.hlsl` 里的结构体 `RenderingEquationContent`：

    struct RenderingEquationContent
    {
        float3 directMainLight;
        float3 directAdditionalLight;
        float3 indirectLight;
    };

故第一步就是声明该结构体变量。暂时没在该结构体里增加 Emission 项，因为自发光的物体的处理比较特殊，日后自定义渲染管线时专门处理，暂时不在 Standard Shader 里增加自发光功能。

**②**接下来就是获取渲染方程计算所需的参数，首先是材质及着色模型相关的参数，这些参数不包括跟光源有关的参数，比如光源方向 $\,l\,$、半角向量 $\,h\,$ 等等。由于不同的着色模型所需参数可能不同，故针对不同着色模型有不同的结构体，我都放在了 `BRDFModelLibrary.hlsl` 里了，比如标准模型所需的参数结构体 `StandardPBRParams`：  

    struct StandardPBRParams
    {
        float3 albedo;
        float roughness;
        float metallic;
        float3 F0;
        float3 N; // L、H is related to the light，see XXXLightsLibrary.
        float3 V;
        float NoV;
    };

接下来就是根据材质属性、贴图等获取这些参数了，我都放在了函数 `InitializeStandardPBRParams(Varyings IN, out StandardPBRParams standardPBRParams)` 里了，因为我觉得这个函数会根据不同 Shader 的不同材质属性要求而有所不同，所以我没有将其封装在 ShaderLibrary 文件里，而是写在了 Shader 的 Pass 代码的 HLSL 文件中。

**③**然后就是计算 IBL 项，至于为什么先计算 IBL 项，是因为 IBL 的计算跟其他光源无关，我们只需要用法线 $\,n\,$ 或视角反射方向 $\,r\,$ 对预过滤的环境贴图或者球谐函数采样，以及用 roughness 和 NoV 对 Environment Lut 采样即可，这些参数都是 `StandardPBRParams` 里都计算好的。还有个原因就是若在标准模型里考虑 multiscattering 的话，我们需要用 Environment Lut 计算一个 energy compensation 项，以便后面直接光的计算使用，这个之后会在 IBL 里详细说明。  

**④、⑦**主光源流程和其他光源很像，就放在一起说了。首先就是初始化不同光源各自的参数，参数结构体 `LightParams` 放在了 `PunctualLightsLibrary.hlsl` 里（目前只实现了 punctual lights，日后还需添加 photometric lights、area lights 等），如下：  

    struct LightParams
    {
        float3 color;
        float4 positionWS;
        float3 L;
        float3 H;
        float distanceAttenuation;
        float angleAttenuation;
        float shadowAttenuation;
        uint layerMask;
    };

初始化这些参数的函数即 `InitializeMainLightParams()` 以及 `InitializeAdditionalLightParams()`。

**⑤、⑧**我们得到了 4 个主要方向 $\,n\,$、$\,v\,$、$\,l\,$、$\,h\,$ 后，就可以计算 BRDF 各项所需的参数了，即 `BRDFParams` 结构体：

    struct BRDFParams
    {
        // NoV is in BRDFModelParams
        float NoL;
        float NoH;
        float LoH;
        float VoH;
    };

计算这些参数的函数即 `InitializeBRDFParams()`，都写在 `BRDFTermsLibrary.hlsl` 文件中。

**⑥、⑨**最后即计算 BRDF 中的 diffuse term 和 specular term，根据不同的着色模型会有不同的计算函数，比如标准模型的 `StandardPBR()` 函数，我都放在了 `BRDFModelLibrary.hlsl` 文件中。注意：我将 NoL 乘在了 BRDF 里，有些人会将它乘在 Lighting 的 Attenuation 项里。

# 参数说明
## Roughness
### remapping
关于 roughness，我们在各种文章资料里总是能看到 Roughness, Linear Roughness, Perceptual Roughness, Alpha, Alpha2 等等，经常会傻傻分不清，其实我在我之前的博客文章里也分得不是很清楚。故在这里详细说明一下：  

首先大部分资料里的做法基本上就是：开发者控制的材质参数为 Linear Roughness/Perceptual Roughness，即我们调节的 0 到 1 的值。那么

$$ \alpha(Alpha) = Roughness = (\text{Linear Roughness or Perceptual Roughness})^2 $$
$$ \alpha2(Alpha2) = \alpha^2(Alpha^2) = Roughness^2 = (\text{Linear Roughness or Perceptual Roughness})^4 $$
 
之所以要搞这个 roughness remapping，是因为不 remapping 的话，在粗糙度低时，粗糙度变化会随参数响应过快，而粗糙度高时，粗糙度变化会随参数响应过慢，如下图（来源于寒霜的《Moving Frostbite to Physically Based Rendering》）：

<div  align="center">  
<img src="https://s2.loli.net/2024/10/23/Z3ctsd7BYPuivLb.png" width = "70%" height = "70%" alt="图1 - roughness remapping"/>
</div>

而我的方案里，就不区分 Linear Roughness 和 Roughness 了，开发者控制的材质参数统一为 roughness，传递给 BRDF 各项的函数的参数都统一为 roughness，只不过我的：  

$$ a = \alpha = roughness^2 $$
$$ a2 = a^2 = roughness^4 $$

### clamping
一般在手机平台上会使用 half 精度，即 16-bit floating-point (float16)。在 PC 或主机端一般使用 float, Single-precision floating-point format (float32)。至于 double，目前主流的游戏显卡对其的支持都相对较差，双精度计算单元只有单精度计算单元的 1/32，有兴趣可以去查阅显卡相关资料。

为了防止四次方超出精度范围，从而导致除以 0 的问题，我们需要给 roughness 设置一个最小值，这样做还有一个好处就是可以保证存在一个较小的高光波瓣，即使 roughness 设置为 0（默认情况下，roughness 为 0 时，高光波瓣会小到消失）。

对于 half，即 $\,2^{-14}\,$（$\,6.10352 \times 10 ^ {-5}\,$），为了防止 $\,\cfrac {1}{roughness^4}\,$ 小于该数，那么 roughness 的最小值应该设置为 0.089，这样计算出来为 $\,6.27422 \times 10 ^ {-5}\,$。对于 float，即 $\,2^{-126}\,$（$\,1.17549 \times 10 ^ {-38}\,$），那么 roughness 的最小值可以被设置为一个很小的数字。

我的方案是将 roughness 的最小值设置为了 0.02。但要注意：最好在计算 direct light 的 BRDF 时，以及在预过滤环境贴图以及预积分 BRDF 时做 clamping。最好不要直接在获取材质属性的时候做 clamping，因为这样 roughness 为 0 时，我们根据 roughness 采样贴图时可能会得到不是我们想要的结果。

## Reflectance
接下来是电介质的反射率的问题，我参考了寒霜和 Filament 的 remapping 方法。我在 Shader 的材质属性里添加了名为 Dielectrics Specular Intensity 的参数（寒霜和 Filament 写为 Reflectance），它是用于控制电解质的 F0 的，并且电解质的 F0 都是非彩色的，公式如下：  

$$ F_0 = 0.16 \cdot Reflectance^2 $$

这样 F0 的范围就可以覆盖几乎所有常见的电解质表面了，一般电解质 F0 在 0.02 ~ 0.08 之间，一些钻石会在 0.16 左右。而 Reflectance 参数的默认值设为 0.5，这样 F0 就默认为最常见的 0.04。

金属的 F0 则由我们设置的颜色控制，即 Albedo。那么可以用金属度进行插值来控制 F0 的颜色：  

    float3 F0 = lerp(_Specular * _Specular * float3(0.16, 0.16, 0.16), albedo, metallic);

# BRDF 各项说明
## Direct Diffuse
选用的是寒霜的 Renormalized Disney diffuse，代码和效果如下：

    float3 Fd_RenormalizedBurley_Disney(float NoV, float NoL, float LoH, float roughness, float3 diffuseColor)
    {
        float energyBias = lerp(0, 0.5, roughness);
        float energyFactor = lerp(1.0, 1.0 / 1.51, roughness);
        float fd90 = energyBias + 2.0 * LoH * LoH * roughness;
        float FdL = F_Schlick(fd90, 1.0, NoL);
        float FdV = F_Schlick(fd90, 1.0, NoV);
        return FdV * FdL * energyFactor * INV_PI * diffuseColor;
    }

<div  align="center">  
<img src="https://s2.loli.net/2024/10/25/srlfJyPN3WiUoFB.jpg" width = "50%" height = "50%" alt="图2 - Renormalized Disney diffuse（从左到右 roughness 分别为 0，0.5，1）"/>
</div>

和 Disney diffuse 一样，在粗糙度为 0 时有黑边，在粗糙度为 1 时有白边。只不过寒霜做了能量守恒，Disney 的黑边更淡一点，白边更亮一点，如下图：

<div  align="center">  
<img src="https://s2.loli.net/2024/10/25/VQeMXPtGs9a7Hup.jpg" width = "50%" height = "50%" alt="图3 - Disney(Burley) diffuse"/>
</div>

## Direct Specular
菲涅尔 Fresnel 项，选用的就是 Schlick 的 Fresnel 近似式；法线分布函数 NDF 项，选用的是 GGX (Trowbridge-Reitz) 分布；可见性 Visibility 项，选用的是 GGX-Smith Correlated Joint。

    float3 F_Schlick(float f90, float3 f0, float VoH)
    {
        return f0 + saturate(float3(f90, f90, f90) - f0) * pow(1.0 - VoH, 5.0);
    }

    float D_GGX(float NoH, float roughness)
    {
        float a2 = pow(roughness, 4.0);
        float d = (NoH * a2 - NoH) * NoH + 1.0;
        return a2 / (PI * d * d);
    }

    float V_SmithGGXCorrelated(float NoV, float NoL, float roughness)
    {
        float a2 = pow(roughness, 4.0);
        float V_SmithL = NoV * sqrt((-NoL * a2 + NoL) * NoL + a2);
        float V_SmithV = NoL * sqrt((-NoV * a2 + NoV) * NoV + a2);
        return 0.5 / (V_SmithL + V_SmithV);
    }

我采用了 $\,(1 - F)(1 - Metallic)\,$ 的方式来对漫反射和镜面反射的贡献进行平衡，代码如下：

    float3 StandardPBR(BRDFParams BRDFParams, StandardPBRParams standardPBRParams)
    {
        float roughness = clamp(standardPBRParams.roughness, 0.02, 1.0); //make sure there is a tiny specular lobe when roughness is zero
        float3 diffuse = Fd_RenormalizedBurley_Disney(standardPBRParams.NoV, BRDFParams.NoL, BRDFParams.LoH, roughness, standardPBRParams.albedo);
        
        float D = D_GGX(BRDFParams.NoH, roughness);
        float V = V_SmithGGXCorrelated(standardPBRParams.NoV, BRDFParams.NoL, roughness);
        float3 F = F_Schlick(1, standardPBRParams.F0, BRDFParams.VoH);
        float3 specular = D * V * F;
        
        return (diffuse * (float3(1.0, 1.0, 1.0) - F) * (1 - standardPBRParams.metallic) + specular) * BRDFParams.NoL;
    }

Direct Diffuse 和 Direct Specular 合并的 Direct Light 效果如下：  

<div  align="center">  
<img src="https://s2.loli.net/2024/10/25/6tpxUL9BwgySFMA.jpg" width = "70%" height = "70%" alt="图4 - Direct Light（正交投影）"/>
</div>

但是按照上面这样处理，高光颜色会有点小瑕疵，特别是在 albedo 颜色是彩色，且 RGB 三通道值都不一样的时候。我们只看高光部分，金属度为 1 时，如下图所示：  

<div  align="center">  
<img src="https://s2.loli.net/2024/10/25/zADWCMBqyEnjX4k.png" width = "40%" height = "40%" alt="图5 - 高光分层（粗糙度为 0.25）"/>
</div>

我将 RGB 分别设置为了 1，0.6，0.3。可以看到高光分为了三层，最里面为白色（红绿蓝组合），中间层为黄色（红绿组合），最外层就是设置的 RGB 颜色。之所以会有这个现象是因为计算 F 项时，代码是对 RGB 三个值分别计算的，值的不同大小会影响到波瓣大小，于是就出现了分层现象。

> 我观察了 Blender 的 Eevee 实时渲染器，发现没有这个现象。但是！！！！我后来发现是 Blender 自动开了 Tone Mapping 导致没有这个现象，关掉也有这个现象，我吐了，浪费了我不少时间找解决方案。然后我就开了 ACES Tone Mapping 看了下，发现这个现象确实得到了很好的修复。



TODO: energyCompensation