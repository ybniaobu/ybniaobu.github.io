---
title: 《C#图解教程》读书笔记（一）
date: 2022-11-24 14:08:00
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/10/28/YztgSrJ6BTOWRLU.jpg
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：XXXXXXXXXXXXXXXXXXXXXXX

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第一章 C#和.NET框架
## .NET框架的组成
.NET框架（.NET Framework）由三个部分组成：

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/sjP4eQIFqxNv65C.png" width = "30%" height = "30%" alt=".NET框架的组成"/>
</div>

执行环境称为**CLR**（Common Language Runtime 公共语言运行库）；CLR管理程序的执行，包括内存管理和垃圾收集（GC garbage collector 垃圾收集器）；代码安全验证；代码执行、线程管理及异常处理。

严格来说，.NET框架由**CLR**和**FCL**（Framework Class Library 框架类库）组成，FCL是BCL的超集。

**BCL**（Base Class Library 基类库）是.NET框架使用的一个大的类库。包括通用基础类：比如文件操作、字符串操作、安全和加密；集合类：实现了列表、字典、散列表（hash tables）以及位数组（bit arrays）；线程和同步类：用于创建多线程程序；XML类：用于创建、读取及操作XML文档。

> 以下内容摘《C#播放器指南》一书。  
> 
> BCL包含所有的内置类型、数组、异常、数学库、基本文件I/O、安全性、集合、反射、联网、字符串操作、线程等等。一般规则是任何以System开头的名称空间都是BCL的一部分。
> 
> 除了BCL之外，微软还随.NET框架提供了更多的类。通常，这些附加内容涵盖了广泛的功能领域，例如数据库访问或图形用户界面(Windows窗体或WPF)。包括BCL在内的整个集合被称为框架类库FCL。

## 编译为CIL
.NET语言的解释器接受源代码文件，并生成名为**程序集Assembly**的输出文件：

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/Q9dpN3izqSuKmGD.png" width = "45%" height = "45%" alt="编译过程"/>
</div>

**程序集**中的代码不是本机代码，而是**CIL**（Common Intermediate Language 公共中间语言）

程序集的信息中包括：程序的CIL；程序中使用的类型的元数据（Metadata）；对其他程序集引用的元数据。

## 编译成本机代码（Native Code）并执行
程序的CIL直到被调用运行时才会被编译成本机代码。在运行时，CLR执行以下步骤：  
（1）检查程序集的安全特性；  
（2）在内存中分配空间；  
（3）把程序集中的可执行代码发给即时编译器（just-in-time JIT compiler），把其中一部分编译成本机代码。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/AtdGz26FTm4voMn.png" width = "40%" height = "40%" alt="运行时被编译成本机代码"/>
</div>

程序集中的可执行代码只有在被需要时由JIT编译器编译，然后就被缓存cache起来以备在后来的程序中执行。这意味着不被调用的代码不会被编译成本机代码，而且被调用到的代码只被编译一次。

一旦CIL被编译成本机代码，CLR就在运行时管理它，执行如释放无主内存、检查参数类型、管理异常等任务。在CLR控制之下的代码称为托管代码（managed code）；而不在CLR控制之下运行的代码为非托管代码。

## CLR
.NET框架的核心组件是**CLR**，它在操作系统顶层，负责管理程序的执行：

<div  align="center">  
<img src="https://s2.loli.net/2022/11/01/iltGr4vmNuyMsA1.png" width = "50%" height = "50%" alt="CLR概览"/>
</div>

CLR还通过访问BCL得到广泛的编程功能，包括如Web服务和数据服务之类的功能。

## CLI
每种编程语言都有一组内置的类型，包括整数、浮点数和字符等对象。但是这些类型因为编程语言和平台的不同而不同，这种缺乏统一性需要一组标准促进有序协作。

**CLI**（Common Language Infrastructure 公共语言基础结构）就是一组标准，它把.NET框架的所有组件连结成了一个系统。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/01/Qq9xHIoUvszDgZh.png" width = "55%" height = "55%" alt="CLI组成"/>
</div>

1. 公共类型系统  
**CTS**（Common Type System 公共类型系统），它定义了一组内置类型；.NET兼容编程语言提供的类型通常映射到CTS已定义的内置类型集的某个特殊子集；***CTS让所有类型都继承自公共的基类——object***；CTS确保用户定义的类型和系统类型能够被任何.NET兼容的语言使用。

2. 公共语言规范  
**CLS**（Common Language Specification 公共语言规范）详细说明了.NET兼容编程语言的规则、属性和行为，包括数据类型、类结构和参数传递）。


# 第二章 C#和.NET Core
## .NET Core的由来
为了更好地解决Web开发以及Linux或macOS的开发，微软用.NET框架搭建了一个基于云的、跨平台的、开源衍生产品，这个新框架即 **.NET Core**。微软也收购了Xamarin以解决Android和IOS等移动平台的开发问题。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/01/UBiFr2XZNK4nJuE.png" width = "70%" height = "70%" alt=".NET生态系统"/>
</div>

.NET Core主要目标为多平台支持；快速开发和升级；更小的应用程序占用空间；更简单的部署；更少的版本问题；开源社区的支持；改进的应用程序性能。


# 第三章 C#编程概述
## 一个简单的C#程序
``` C#
using System;

namespace Simple
{
    class Program   // declare a class
    {
        static void Main()
        {
            Console.WriteLine("Hi there!");
        }
    }
}
```

行1 ：告诉编译器这个程序使用**System命名空间**的类型；  
行3 ：声明新的名为**Simple的命名空间**，在这部分声明的任何类型都是该命名空间的成员（第4行到第12行）；  
行5 ：声明新的名为**Program的类类型**，在这部分声明的任何成员都是组成这个类的成员（第6行到第11行）；  
行7 ：声明一个名称为**Main的方法**作为**类Program**的成员，**Main是一个特殊函数**，编译器用它作为程序的起始点；  
行9 ：包含了一条简单的语句，组成了**Main的方法**：简单语句以一个分号结束，这条语句使用**命名空间System**中的一个名为**Console的类**将消息输出到屏幕窗口，若没有第一条的**using语句**，编译器就不知道在哪里寻找**类Console**。

*C#程序由一个或多个类型声明组成，命名空间是与某个名称相关联的一组类型声明*。上述代码创建了一个名称为Simple的新命名空间，并在其中声明了其类型（类Program），还使用了System命名空间中定义的Console类。


> ***补充 ：使用 Visual Studio Code 创建 .NET 控制台应用程序（摘自官方.NET文档）***
> 
> **先决条件**：.NET 6 SDK以及已安装 C# 扩展 的 Visual Studio Code
> 
> **创建应用**：  
> 1、在合适位置创建文件夹，并打开vscode打开该文件夹。默认情况下，文件夹名称将是项目名称和命名空间名称；  
> 2、在vscode中选择Terminal - New Terminal；  
> 3、在“终端”中输入以下命令：`dotnet new console --framework net6.0`；  
> 4、此时创建了一个在控制台窗口中显示“Hello World”的简单应用程序：
> ``` C#
> Console.WriteLine("Hello, World!");
> ```
> 
> 首次创建程序时，Visual Studio Code 会提示添加缺少的资产，以生成和调试应用。 选择“是”，Visual Studio Code 会创建一个包含“launch.json”和“tasks.json”文件的“.vscode”文件夹。
> 
> <div  align="center">  
> <img src="https://s2.loli.net/2022/11/04/qmQSHOwfJIvMb8Y.png" width = "55%" height = "55%"/>
> </div>
> 
> 如果未收到提示，或者意外将其关闭而未选择“是”，可以按如下操作步骤：
> 
> <div  align="center">  
> <img src="https://s2.loli.net/2022/11/04/PtDE7zaYQeFGokC.png" width = "35%" height = "35%"/>
> </div>
> 
> 也可以从菜单中选择Run - Add Configurations，在“选择环境”提示符下，选择“.NET 5+ 和 .NET Core”。
> 总之最后要见到 .vscode 中的 launch.json 和 tasks.json 文件。
> 
> **运行应用**：  
> 在“终端”中运行以下命令：`dotnet run`  
> 程序显示“Hello World!”并终止。


## 标识符 Identifiers
**标识符**是用于命名的字符串。  

某些字符能否在标识符的特定位置出现是有规定的：
  - 字母和下划线可以出现在任何位置；
  - 数字不能放在首字母，但可以出现在其他任何位置；
  - @字符只能放在标识符的首位，不推荐将@作为常用字符。

标识符区分大小写，比如变量名myVar和MyVar是不同的标识符。第8章将介绍推荐的C#命名约定。

## 关键字 Keywords
**关键字**不能作为标识符，除非以@字符开始。  
所有C#关键字全部都以小写字母组成。

*表：C#关键字*

| |||||||
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| abstract | const | extern | int | out | short | typeof |
| as | continue | false | interface | override | sizeof | uint |
| base | decimal | finally | internal | params | stackalloc | ulong |
| bool | default | fixed | is | private | static | unchecked |
| break | delegate | float | lock | protected | string | unsafe |
| byte | do | for | long | public | struct | ushort |
| case | double | foreach | namespace | readonly | switch | using |
| catch | else | goto | new | ref | this | virtual |
| char | enum | if | null | return | throw | void |
| checked | event | implicit | object | sbyte | true | volatile |
| class | explicit | in | operator | sealed | try | when while |

**上下文关键字 Contextual Keywords**是仅在特定的语言结构中充当关键字的标识符，上下文关键字可以在代码的其他部分被用作标识符。

*表：C#的上下文关键字*

| |||||||
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| add | ascending | async | await | by | descending | dynamic |
| equals | from | get | global | group | in | into |
| join | let | on | orderby | partial | remove | select | 
| set | value | var | where | yield | | | 

## Main：程序的起始点  
每个C#程序必须有一个类带有**Main方法(函数)**。
  - 每个C#程序的可执行起始点在Main中的第一条指令；
  - Main必须首字母大写。

``` C#
static void Main( )
{
    Statements
}
```

## 空白 Whitespace
程序中的空白指没有可视化输出的字符。在源代码中使用的空白会被编译器忽略。

空白字符包括：空格(Space)；制表符(Tab)；换行符(New line)；回车符(Carriage return)

比如，下面的代码会被编译器同等对待：

``` C#
Main()
{
    Console.WriteLine("Hi, there!");
}
// 连在一起
Main(){Console.WriteLine("Hi, there!");}
```

## 语句 Statements
此处为简单介绍，详细见第10章。

**简单语句**以一个**分号**结束，下面的代码即2条简单语句组成的序列：
``` C#
int var1 = 5;
System.Console.WriteLine("The value of var1 is {0}", var1);
```

## 块 Blocks
**块**是一个由成对大括号包围的0条或多条语句序列，它在语法上相当于一条语句。
``` C#
{
    int var1 = 5;
    System.Console.WriteLine("The value of var1 is {0}", var1);
}
```

语法上只需要一条语句，若需要执行的动作无法用一条简单语句表达时，考虑用块；  
有些特定的程序结构只能使用块；  
简单语句以分号结束，块后面不跟分号。

## 从程序中输出文本
**控制台窗口console window**是一种简单的命令提示窗口。BCL提供了一个名为Console的类（在System命名空间中），该类包含了讲数据输入和输出到控制台窗口的方法。

### Write
Write是Console类的成员，示例：
``` C#
System.Console.Write ("This is text1. ");
System.Console.Write ("This is text2. ");
System.Console.Write ("This is text3. ");
```

在控制台窗口输出如下：
``` Console
This is text1. This is text2. This is text3.
```

注意：Write没有在字符串后面添加换行符，所以三个语句都输出在同一行。

### WriteLine
WriteLine也是Console类的成员，但会在每个输出字符串的结尾添加一个换行符。

上面的代码用WriteLine替换掉Write，输出会变为多行：  
``` Console
This is text1.
This is text2.
This is text3.
```

### 格式字符串 The Format String
Write或WriteLine语句可以有一个以上的参数，格式如下：  
`Console.WriteLine( FormatString, SubVal0, SubVal1, SubVal2, ... );`

第一个参数必须总是字符串，称为**格式字符串**；格式字符串可以包括**代替标记Substitution markers**。代替标记包含大括号和一个整数，整数就是替换值的数字位置。

例如：下面的语句有2个替代标记，{0}和{1}；以及2个替换值，即3和6。
``` C#
Console.WriteLine("Two sample integers are {0} and {1}.", 3, 6);
```

C# 6.0 还引入了**字符串插值string interpolation**，前提是前面加上$符号：
``` C#
int var1 = 3;
int var2 = 6;
Console.WriteLine($"Two sample integers are {var1} and {var2}.");
```

### 多重标记和值
可以使用任意数量的替代标记和任意数量的值，比如：
``` C#
Console.WriteLine("Three integers are {1}, {0} and {1}.", 3, 6);
```

但标记不能引用超出替换值列表长度的值，如果引用，不会产生编译错误compile error，但会产生运行错误runtime error（称为**异常exception**）。比如：`Console.WriteLine("Two integers are {0} and {2}.", 3, 6);`中位置2不存在，3是位置0，6是位置1。

### 格式化数字字符串
指定数字格式，例如：
``` C#
Console.WriteLine("The value: {0}." , 500);
Console.WriteLine("The value: {0:C}.", 500); // 格式化为货币

int myInt = 500;
Console.WriteLine($"The value: {myInt}.");
Console.WriteLine($"The value: {myInt:C}.");
```

上述2种代码，都在控制台窗口产生同样输出：
``` Console
The value: 500.
The value: ￥500.00.
```

大括号内的**格式说明符format specifier**的语法由三个字段fields组成：**索引号index或者字符串插值变量string interpolation variable**、**对齐说明符alignment specifier**和**格式字段format field**。

语法为：`{ index,alignment:format }`

*index或string interpolation*：必需项，指定列表中的某一项；  
*alignment*：可选，指定字段宽度，以及是否是左对齐或是右对齐；  
*format*：可选，指定项的格式。  
*注意*：对齐前面是逗号，格式前面是冒号。

***（1）对齐说明符***  
由一个正整数或者负整数组成：*整数表示字段使用字符的最少数量*；符号表示右对齐或左对齐，*正数表示右对齐，负数表示左对齐*。
``` C#
int myInt = 500;
Console.WriteLine("|{0, 10}|", myInt); // 右对齐Aligned right
Console.WriteLine("|{0,-10}|", myInt); // 左对齐Aligned left
```

输出如下，在两个竖杠的中间有10个字符：
``` Console
|       500|
|500       |
```

*如果要表示的字符数比对齐说明符指定的字符数少，那么其余字符会使用空格填充*；  
*如果要表示的字符数多于指定的字符数，对齐说明符会被忽略，并且使用所需的字符进行表示*。

***（2）格式字段***  
格式字段有三部分，①**冒号**后面必须紧跟格式说明符，中间不能有空格；②**格式说明符format specifier**是一个字母字符，是9个内置字符格式之一，可以是大写或者小写；③**精度说明符precision specifier**是可选的，由1~2位数字组成，实际意义取决于格式说明符。

语法为：`:Axx`，A为格式说明符，xx为精度说明符。
``` C#
double myDouble = 12.345678;
Console.WriteLine("{0,-10:G} -- General", myDouble);
Console.WriteLine("{0,-10} -- Default, same as General", myDouble);
Console.WriteLine("{0,-10:F4} -- Fixed Point, 4 dec places", myDouble);
Console.WriteLine("{0,-10:C} -- Currency", myDouble);
Console.WriteLine("{0,-10:E3} -- Sci. Notation, 3 dec places", myDouble);
Console.WriteLine("{0,-10:x} -- Hexadecimal integer", 1194719 );
```

输出如下：
``` Console
12.345678  -- General
12.345678  -- Default, same as General
12.3457    -- Fixed Point, 4 dec places
￥12.35     -- Currency
1.235E+001 -- Sci. Notation, 3 dec places
123adf     -- Hexadecimal integer
```

***（3）标准数字格式说明符***  
9种标准数字格式说明符，若说明符会根据大小写会有不同输出，会标注为区分大小写。

| 名字和字符 | 意义 |
| :---- | :---- |
| 货币Currency<br>C、c | 使用货币符号，货币符号取决于程序所在PC的区域设置<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :C}", 12.5);`<br>输出：￥12.50 |
| 十进制数Decimal<br>D、d | 十进制数字字符串，可以有负数符号。只能和整数类型配合使用<br>精度说明符：输出字符串的最小位数，若实际数字位数少，则左边以0填充<br>示例：`Console.WriteLine("{0 :D4}", 12);`<br>输出：0012 |
| 定点Fixed-point<br>F、f | 带有小数点的十进制数字字符串，可以有负数符号。<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :F4}", 12.3456789);`<br>输出：12.3457 |
| 常规General<br>G、g | 在没有指定说明符的情况下，会根据值转换为定点或科学计数法表示的形式<br>精度说明符：根据值的情况<br>示例：`Console.WriteLine("{0 :G4}", 12.3456789);`<br>输出：12.35 |
| 十六进制数Hexadecimal<br>X、x<br>区分大小写 | 十六进制数字字符串。A~F会匹配说明符的大小写<br>精度说明符：输出字符串的最小位数，若实际数字位数少，则左边以0填充<br>示例：`Console.WriteLine("{0 :x}", 180026);`<br>输出：2bf3a |
| 数字Number<br>N、n | 和定点表示法相似，但是每3个数字的一组中间有逗号或空格分隔符，使用哪个看程序所在PC的区域设置<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :N2}", 12345678.54321);`<br>输出：12,345,678.54 |
| 百分比Percent<br>P、p | 表示百分比的字符串，数字会乘以100<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :P2}", 0.1221897);`<br>输出：12.22% |
| 往返过程Round-trip<br>R、r | 保证输出字符串后如果使用Parse方法将字符串转化为数字，Parse方法在第27章<br>精度说明符：忽略<br>示例：`Console.WriteLine("{0 :R}", 1234.21897);`<br>输出：1234.21897 |
| 科学计数法Scientific<br>E、e<br>区分大小写 | 具有尾数和指数的科学计数法，e的大小写和说明符一致<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :e4}", 12.3456789);`<br>输出：1.2346e+001 |

## 注释：为代码添加注解 Comments: Annotating the Code
**单行注释 Single-line comments** ：`//`，注释范围一直到行结束都有效。

**带分隔符的注释 Delimited comments** ：开始标记`/*`和结束标记`*/`，带分隔符的注释可以跨越多行，或者只包括行的一部分。注释范围一直到第一个结束分隔符都有效。

**文档注释 Documentation Comments** ：`///`，在第27章阐述。文档注释包括XML文档，可以用于产生程序文档。


# 第四章 类型、存储和变量
## C#程序是一组类型声明
C程序是一组函数和数据类型，C++程序是一组函数和类，C#程序或DLL是一组类型声明。

(1) 类型声明中必须有一个包含**Main方法**的类；  
(2) **命名空间**将相关的类型声明分组并命名，所以在命名空间内声明程序类型。

``` C#
namespace MyProgram // Declare a namespace，名为MyProgram.
{
    DeclarationOfTypeA // Declare a type.
    DeclarationOfTypeB // Declare a type.

    class C // Declare a type.
    {
        static void Main()
        {
            ...
        }
    }
}
```

命名空间在第22章详细阐述。

## 类型是一种模板
类型可以理解为一个创建数据结构的模板。类型具有以下元素：名称、用于保存的数据结构、一些行为和约束条件。

比如：short类型，名称是short，结构是2字节，行为是16位整数。int类型，名称是int，结构是4字节，行为是32位整数。

## 实例化类型 Instantiating a Type
从类型模板创建对象，即**实例化**该类型。

通过实例化类型而创建的对象被称为类型的**对象**或类型的**实例**。这2术语可以互换。

## 数据成员和函数成员
**简单类型**如short、int和long，只能存储一个数据项；
数组类型（array）可以存储多个同类型的数据项，这些数据项即**数组元素**。

然而有些类型可以包含不同类型的数据项，这些数据项被称为**成员 members**，包括**数据成员**和**函数成员**：**数据成员**保存了与这个类的对象或整个类相关数据；**函数成员**执行代码，定义类型的行为。

## 预定义类型
C#有16种预定义类型，包括13种**简单类型**和3种**非简单类型**。所有预定义类型的名称都是小写。

简单类型可以分为3类：    
(1) 11种数值类型：  
&ensp;&ensp;&ensp;- 不同长度的有符号和无符号*整数类型*；  
&ensp;&ensp;&ensp;- *浮点数类型*float和double；  
&ensp;&ensp;&ensp;- *高精度小数类型*decimal，与float和double不同，decimal类型可以表示分数，常用于货币计算。  
(2) *Unicode字符类型*char；  
(3) *布尔类型*bool，即true和false。  

3种非简单类型为：  
(1) string，一个Unicode字符数组；  
(2) object，所有类型的基类；  
(3) dynamic，使用动态语言编写的程序集使用。  

<div  align="center">  
<img src="https://s2.loli.net/2022/11/16/pKUunxX9i5ayjqt.png" width = "60%" height = "60%" alt="预定义类型"/>
</div>

所有预定义类型都映射到底层的.NET类型。*预定义简单类型*都表示一个单一的数据项，如下表：

| 名称 | 含义 | 范围 | .NET框架类型 | 默认值 |
| :---- | :---- | :---- | :---- | :---- |
| sbyte | 8-bit signed integer | -128 to 127 | System.SByte | 0 |
| byte | 8-bit unsigned integer | 0 to 255 | System.Byte | 0 |
| short | 16-bit signed integer | -32,768 to 32,767 | System.Int16 | 0 |
| ushort | 16-bit unsigned integer | 0 to 65,535 | System.UInt16 | 0 |
| int | 32-bit signed integer | -2,147,483,648 to 2,147,483,647 | System.Int32 | 0 |
| uint | 32-bit unsigned integer | 0 to 4,294,967,295 | System.UInt32 | 0 |
| long | 64-bit signed integer | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | System.Int64 | 0 |
| ulong | 64-bit unsigned integer | 0 to 18,446,744,073,709,551,615 | System.UInt64 | 0 |
| float | Single-precision float | 1.5×10^-45 to 3.4×10^38 | System.Single | 0.0f |
| double | Double-precision float | 5×10^-324 to 1.7×10^308 | System.Double | 0.0d |
| bool | Boolean | true, false | System.Boolean | false |
| char | Unicode character | U+0000 to U+ffff | System.Char | \x0000 |
| decimal | Decimal value with 28-significant-digit precision | ±1.0×10^28 to ±7.9×10^28 | System.Decimal | 0m |

*预定义非简单类型*，如下表：

| 名称 | 含义 | .NET框架类型 |
| :---- | :---- | :---- |
| object | 所有其他类型的基类，包括简单类型 | System.Object |
| string | 0个或多个Unicode字符组成的序列 | System.String |
| dynamic |  在使用动态语言编写的程序集assemblies时使用 | 无相应的 .NET type |

## 用户定义类型
C#有16种预定义类型，另外还有6种类型可以由用户自己创建：  
*类类型 class*；*结构类型 struct*；*数组类型 array*；*枚举类型 enum*；*委托类型 delegate*；*接口类型 interface*。

类型通过**类型声明type declaration**创建。

预定义类型直接实例化对象即可；用户定义类型要先声明类型，然后实例化该类型对象。

## 栈和堆 The Stack and the Heap
运行中的程序使用两个内存区域来存储数据：栈和堆。
### 栈 The Stack
**栈**是一个内存数组，是一个**LIFO**（后进先出）的数据结构。

数据只能从栈的顶端插入和删除；把数据放到栈顶称为**入栈push**；从栈顶删除数据称为**出栈pop**。

### 堆 The Heap
**堆**是一块内存区域，堆里的内存能够以任意顺序存入和移除。

虽然程序可以在堆里保存数据，但是不能显示地删除它们。CLR的自动垃圾收集器在判断出程序代码不会再访问某数据项时，会自动清理无主对象。

## 值类型和引用类型
数据项的类型定义了存储需要的内存大小及组成该类型的数据成员，也决定了对象在内存的存储位置——栈或堆。

类型分为**值类型value types**和**引用类型reference types**：  
*值类型*只需要一段单独的内存，数据存放在栈中；  
*引用类型*需要两端内存：第一段存储实际的数据，位于堆中。第二段是一个*引用*，指向数据在堆存放的位置，而引用存放在栈中。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/17/yelvL6bXRMFCacG.png" width = "70%" height = "70%" alt="非成员数据的存储"/>
</div>

### 存储引用类型对象的成员
上图是当数据不是另一个对象的成员的存储方式。若数据是另一对象的成员，会有些不同。

假设一个引用类型的实例，名为MyType，包括2个成员：一个值类型成员A和一个引用类型成员B。 

对于一个引用类型，其实例的数据部分始终存放在堆中，二个成员都是对象数据的一部分，即都会存放在堆中，无论是值类型还是引用类型。即，引用类型B的数据和引用部分都存放在堆里；值类型A也在堆里。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/17/tdWgnr78DFyScLx.png" width = "50%" height = "50%" alt="引用类型对象数据的存储"/>
</div>

### C#类型的分类
如下表：

| | 值类型 | 引用类型 |
| :---- | :---- | :---- |
| 预定义类型 | sbyte byte<br>short ushort<br>int uint<br>long ulong<br>bool char<br>float double<br>decimal | object<br>string<br>dynamic |
| 用户定义类型 | struct<br>enum | class<br>interface<br>delegate<br>array |

## 变量 Variables
**变量**是一个名称，表示程序执行时存储在内存中的数据。

C#提供了4种变量，如下表：

| 名称 | 描述 |
| :---- | :---- |
| 局部变量Local variable | 在方法的作用域保存临时数据，不是类型的成员 |
| 字段Field | 保存和类型或类型实例相关的数据，是类型的成员 |
| 参数Parameter | 用于从一个方法到另一个方法传递数据的临时变量，不是类型的成员 |
| 数组元素Array element | 同类数据项构成的有序集合的一个成员，可以是局部变量，也可以是类型的成员 |

### 变量声明
变量声明定义了变量，并且完成了：① 给变量命名，并关联一种类型；② 让编译器分配一块内存。一个简单的变量声明至少需要一个类型和一个名称。

比如：`int var2;` 定义了一个名为 var2 的 int 类型的变量。

*（1）变量初始化语句*  

**变量初始化语句 variable initializer**由一个等号和初始值组成：`int var2 = 17;`

无初始化语句的局部变量有一个未定义的值，在赋值前不能使用。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/18/YPb8zBrDXshlfwj.png" width = "70%" height = "70%" alt="变量初始化语句"/>
</div>

*（2）自动初始化*

有一些类型的变量如果没初始化，会被自动设为默认值。没有自动化为默认值的变量在程序为它赋值之前包含未定义值。

| 变量类型| 存储位置 | 自动初始化 | 用途 |
| :---- | :---- | :---- | :---- |
| 局部变量 Local variables | 栈或栈和堆 | 否 | 用于函数成员内部的局部计算 |
| 类字段 Class fields | 堆 | 是 | 类的成员 |
| 结构字段 Struct fields | 栈或堆 | 是 | 结构的成员 |
| 参数 Parameters | 栈 | 否 | 用于把值传入或传出方法 |
| 数组元素 Array elements | 堆 | 是 | 数组的成员 |

### 多变量声明
可以在单个声明语句中声明多个变量：①多变量声明中的变量必须类型相同；②变量名必须逗号隔开，可以包含初始化语句。

``` C#
//声明一些变量，有的被初始化，有的没被初始化
int var3 = 7, var4, var5 = 3;
double var6, var7 = 6.52;

int var8, float var9; //错误：多变量声明的变量类型必须相同
```

## 静态 static 类型和 dynamic 关键字
C#是静态类型的语言，但 IronPython 和 IronRuby 之类的脚本语言是动态类型的，因为它们也是.NET
语言，C#需要能够使用这些语言编写的程序集，因此增加了dynamic关键字。

## 可空类型 Nullable Types
在某些情况下，希望变量目前不保存有效的值。对于引用类型，可以把变量设为null；但对于值类型，不管内容是否有效，其内存都会分配。可以使用布尔指示器来和变量关联，值有效则设置为true，无效即false。

**可空类型**允许创建可以标记为有效和无效的值类型变量。普通的值类型为**非可空类型**。详见第27章。


# 第五章 类的基本概念
## 类的概述
数据项和函数的封装集合，被称为**类**。

类包括数据成员和函数成员：①数据成员，存储与类或类实例相关的数据；②函数成员，执行代码。

| 数据成员存储数据 | 函数成员执行代码 |
| :---- | :---- |
| 字段 Fields<br>常量 Constants | 方法 Methods ；运算符 Operators ；属性 Properties ；索引器 Indexers<br>构造函数 Constructors ；事件 Events ；析构函数 Destructors |

## 声明类
**类的声明**定义类的名称、成员和特征，不创建类的实例，创建用于创建实例的模板。

``` C#
class MyExcellentClass //class为关键字Keyword，MyExcellentClass是类名
{
    MemberDeclarations
}
```

## 类成员
### 字段
**字段**是在类中的变量。可以是任意类型，包括预定义类型或用户定义的类型。

``` C#
class MyClass
{
    int MyField; //MyField即字段名称
}
```

与 C 和 C++ 不同，*C#在类型外面不能申明全局变量*。所有字段都属于类型。

因为字段是一种变量，**字段初始化语句**和变量初始化语言相同；如果没有初始化语句，字段的值会被编译器设为默认值，总结的来说，每种值类型的默认值都是0，bool 型的默认值是 false，引用类型的默认值为 null 。

``` C#
class MyClass
{
    int F1; // 初始化为0 - 值类型
    string F2; // 初始化为null - 引用类型

    int F3 = 25; // 初始化为25
    string F4 = "abcd"; // 初始化为"abcd"
}
```

在同一语句中声明多个字段，下面语句与上面效果相同：

``` C#
int F1, F3 = 25;
string F2, F4 = "abcd";
```

### 方法
**方法**是具有名称的可执行代码块，相当于C++的**成员函数**。

声明方法包括以下4个组成部分：  
①返回类型：声明方法返回值的类型，若不返回值，则被指定为 void ；  
②名称：方法的名称；  
③参数列表：由一对圆括号组成，参数列在其中；  
④方法体：由一对大括号组成，包含执行代码。

``` C#
class SimpleClass
{
    void PrintNums()
    {
        Console.WriteLine("1");
        Console.WriteLine("2");
    }
}
```

上述代码不返回值（void），有空的参数列表，方法体有2行。

与 C 和 C++ 不同，C#**没有全局函数**，也没有默认的返回类型，所有方法必须包含返回类型或者 void 。

## 创建变量和类的实例
类是引用类型，数据的引用保存在一个类类型的变量中，要创建类的实例，需要声明一个类类型的变量开始，如果变量没有被初始化，它的值是未定义的。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/19/DZy8t9hd3uxGcOa.png" width = "60%" height = "60%" alt="为类变量的引用分配内存"/>
</div>

左边顶端的代码是类 Dealer 的声明，下面是类 Program 的声明，它包含 Main 方法；Main 声明了 Dealer 类型的变量 theDealer 。因为该变量没有被初始化，所有它的值是未定义的。

## 为数据分配内存
声明类类型的变量所分配的内存是用来保存引用的，不是用来保存类对象实际数据的。要为实际数据分配内存，需要使用 **new 运算符 operator**。  
①new 运算符能为任意指定类型的实例分配并**初始化**内存；  
②使用 new 运算符组成一个**对象创建表达式**，包括：关键字 new ；要分配内存的实例的类型名称；成对的圆括号，包含或不包含参数。  
③如果将内存分配给一个引用类型，则对象创建表达式返回一个引用，指向在堆中被分配或初始化的对象实例。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/19/s9Vg3YBLvb7eXTP.png" width = "70%" height = "70%" alt="为类变量的数据分配内存"/>
</div>

`Dealer theDealer;`声明引用变量；`theDealer = new Dealer();`为类对象分配内存并赋值给变量

合并以上两个步骤，用对象创建表达式来**初始化**变量：

``` C#
Dealer theDealer = new Dealer(); // 声明并初始化
```

## 实例成员
**实例成员 Instance members**：类的每个实例都有自己的一组数据，不同于同一类的其他实例。因为数据成员和类的实例相关，所以被称为实例成员。

**静态成员 Static members**：实例成员是默认类型，但是可以声明与类有关，与实例无关的成员，称为静态成员。见第7章。

## 访问修饰符 Access Modifiers
**访问修饰符**是成员声明的可选部分，指明程序的其他部分如何访问成员，语法如下：
①字段：`访问修饰符 类型 标识符;` ②方法：`访问修饰符 返回类型 方法名()`

5种成员访问控制如下，本章只介绍前2种，其余在第8章：
①私有的 private ；②公有的 public ；③受保护的 protected ；④内部的 internal ；⑤受保护内部的 protected internal

### 私有访问和公有访问
私有成员只能从声明它的类的内部访问，其他的类看不到或无法访问它们。  
私有访问是默认的，若声明时不带访问修饰符，即私有成员。

``` C#
int MyInt1; //隐式声明为私有
private int MyInt2; //显示声明为私有
```

公有成员可以被程序中的其他对象访问。必须使用 public 访问修饰符指定。`public int MyInt;`

成员访问示例：

``` C#
class C1
{
    int F1; //隐式私有字段
    private int F2; //显式私有字段
    public int F3; //公有字段

    void DoCalc() //隐式私有方法
    {
    ...
    }

    public int GetVal() //公有方法
    {
    ...
    }
}
```

## 从类的内部访问成员
下面的类展示了类的方法对字段和其他方法的访问，私有成员可以被类的任何方法访问：

``` C#
class DaysTemp
{
    //字段
    private int High = 75;
    private int Low = 45;

    //方法
    private int GetHigh()
    {
        return High; //访问私有字段
    }

    private int GetLow()
    {
        return Low; //访问私有字段
    }

    public float Average ()
    {
        return (GetHigh() + GetLow()) / 2; //访问私有方法
    }
}
```

## 从类的外部访问成员
要从类的外部访问实例成员，需要**点运算符 dot-syntax notation**，如下：

``` C#
DaysTemp myDt = new DaysTemp(); //创建类的对象
float fValue = myDt.Average(); //从外部访问
```

示例如下，DaysTemp 内的两个字段被声明为 public ，可以从类外部访问：

``` C#
class DaysTemp //声明类 DaysTemp
{
    public int High = 75;
    public int Low = 45;
}

class Program //声明类 Program
{
    static void main()
    {
        DaysTemp temp = new DaysTemp(); //创建对象

        temp.High = 85; //字段赋值
        temp.Low = 60;

        Console.WriteLine("High:   {0}", temp.High ); //读取字段值
        Console.WriteLine($"Low:    {temp.Low}");
    }
}
```

运行结果如下：

``` console
High:   85
Low:    60
```

## 综合应用
创建两个实例并把它们的引用保存在名称为 t1 和 t2 的变量中：

``` C#
class DaysTemp //声明类
{
    public int High, Low; //声明实例字段

    public int Average() //声明实例方法
    {
        return (High + Low) / 2;
    }
}

class Program
{
    static void Main()
    {
        //创建两个DaysTemp实例
        DaysTemp t1 = new DaysTemp();
        DaysTemp t2 = new DaysTemp();

        //给字段赋值
        t1.High = 76; t1.Low = 57;
        t2.High = 75; t2.Low = 53;

        //读取字段值和调用实例的方法
        Console.WriteLine("t1: {0}, {1}, {2}",
                                  t1.High, t1.Low, t1.Average() );
        Console.WriteLine("t2: {0}, {1}, {2}",
                                  t2.High, t2.Low, t2.Average() );
    }
}
```

运行结果如下：

``` console
t1: 76, 57, 66
t2: 75, 53, 64
```

<div  align="center">  
<img src="https://s2.loli.net/2022/11/20/djQIPz6cxEgRlY7.png" width = "50%" height = "50%" alt="实例t1和t2的内存布局"/>
</div>


# 第六章 方法
## 方法的结构
*方法是类的函数成员*，包括方法头 method header 和方法体 method body。

方法头指定方法的特征：`int MyMethod ( int par1, string par2 )`，即返回类型、方法名称及参数列表。

方法体包含可执行代码的语句序列。

## 方法体内部的代码执行
方法体是个**块**，是大括号括起的语句序列。可以包括：局部变量；控制流结构 Flow-of-control constructs ；方法调用 Method invocations ；内嵌的块；其他方法（局部函数）

``` C#
static void Main()
{
    int myInt = 3; //局部变量初始化为3

    while (myInt > 0) //控制流结构
    {
        --myInt;
        PrintMyMessage(); //方法调用
    }
}
```

## 局部变量
和字段一样，局部变量也保存数据。字段通常保存和对象状态有关的数据，而局部变量是用于保存临时的计算数据。

局部变量声明的语法：`Type Identifier = Value;`

下面的代码包含了2个局部变量的声明，第一个是int类型变量，第二个是SomeClass类型变量：

``` C#
static void Main( )
{
    int myInt = 15;
    SomeClass sc = new SomeClass();
    ...
}
```

对比实例字段和局部变量：

| | 实例字段 | 局部变量 |
| :---- | :---- | :---- |
| 生存期 | 从实例被创建时开始，直到实例不再被访问时结束 | 从它的块中被声明的那一刻开始，在块完成执行时结束 |
| 隐式初始化 | 初始化成该类型的默认值 | 没有隐式初始化。如果变量在使用之前没有被赋值，编译器就会产生一条错误消息 |
| 存储区域 | 由于实例字段是类的成员，所以所有字段都存储在堆里，无论是值类型还是引用类型 | 值类型：存储在栈里；引用类型：引用存储在栈里，数据存储在堆里 |

### 类型推导和 var 关键字

``` C#
static void Main( )
{
    int total = 15;
    MyExcellentClass mec = new MyExcellentClass();
    ...
}
```

上述代码中，第一个变量声明中，编译器可以推断出15是 int 型；第二个变量声明中，右边的对象创建表达式返回了 MyExcellentClass 类型的对象。为避免冗余，可以使用**关键字 var** ：

``` C#
static void Main( )
{
    var total = 15;
    var mec = new MyExcellentClass();
    ...
}
```

var 关键字并不表示特殊变量，只是句法的速记 shorthand ，表示任何可以从初始化语句的右边推断出的类型。var 只能用于局部变量，不能用于字段。一旦推断出类型，即不能改变。

> var 关键字不改变 C# 的强类型性质。

### 嵌套块中的局部变量
局部变量在嵌套块的内部声明，它的生存期限于声明它的内嵌块。

在 C# 中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量。和 C 和 C++ 不同。

## 局部常量 Local Constants
**常量**在声明时必须初始化，声明后不能改变。

声明语句如下：`const Type Identifier = Value;`

初始化值必须在编译期决定，通常是一个预定义简单类型或其组成的表达式。还可以是null引用，但不能是某对象的引用，因为对象的引用是在运行时决定的。

**关键字 const** 不是修饰符，是核心声明的一部分，必须直接放在类型前面。

局部常量也在方法体或代码块中声明，并在声明它的块结束的地方失效。

``` C#
void DisplayRadii() {
    const double PI = 3.1416; //声明局部常量

    for (int radius = 1; radius <= 5; radius++) {
        double area = radius * radius * PI; //读取局部常量
        Console.WriteLine
            ($"Radius: { radius }, Area: { area }");
    }
}
```

## 控制流 Flow of Control

