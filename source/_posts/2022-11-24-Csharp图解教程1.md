---
title: 《C#图解教程》读书笔记（一）
date: 2022-11-24 14:08:00
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：.NET 框架的简单介绍；C# 程序的基本构成；类型和变量基础；类和方法的基础。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第一章 C#和.NET框架
## .NET框架的组成
.NET框架（.NET Framework）由三个部分组成：

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/sjP4eQIFqxNv65C.png" width = "30%" height = "30%" alt="图1 - .NET框架的组成"/>
</div>

执行环境称为**CLR**（Common Language Runtime 公共语言运行库）；CLR管理程序的执行，包括内存管理和垃圾收集（GC garbage collector 垃圾收集器）；代码安全验证；代码执行、线程管理及异常处理。

严格来说，.NET框架由**CLR**和**FCL**（Framework Class Library 框架类库）组成，FCL是BCL的超集。

**BCL**（Base Class Library 基类库）是.NET框架使用的一个大的类库。包括通用基础类：比如文件操作、字符串操作、安全和加密；集合类：实现了列表、字典、散列表（hash tables）以及位数组（bit arrays）；线程和同步类：用于创建多线程程序；XML类：用于创建、读取及操作XML文档。

> 以下内容摘《C#播放器指南》一书。  
> 
> BCL包含所有的内置类型、数组、异常、数学库、基本文件I/O、安全性、集合、反射、联网、字符串操作、线程等等。一般规则是任何以System开头的名称空间都是BCL的一部分。
> 
> 除了BCL之外，微软还随.NET框架提供了更多的类。通常，这些附加内容涵盖了广泛的功能领域，例如数据库访问或图形用户界面(Windows窗体或WPF)。包括BCL在内的整个集合被称为框架类库FCL。

## 编译为CIL
.NET语言的解释器接受源代码文件，并生成名为**程序集Assembly**的输出文件：

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/Q9dpN3izqSuKmGD.png" width = "45%" height = "45%" alt="图2 - 编译过程"/>
</div>

**程序集**中的代码不是本机代码，而是**CIL**（Common Intermediate Language 公共中间语言）

程序集的信息中包括：程序的CIL；程序中使用的类型的元数据（Metadata）；对其他程序集引用的元数据。

## 编译成本机代码（Native Code）并执行
程序的CIL直到被调用运行时才会被编译成本机代码。在运行时，CLR执行以下步骤：  
（1）检查程序集的安全特性；  
（2）在内存中分配空间；  
（3）把程序集中的可执行代码发给即时编译器（just-in-time JIT compiler），把其中一部分编译成本机代码。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/AtdGz26FTm4voMn.png" width = "40%" height = "40%" alt="图3 - 运行时被编译成本机代码"/>
</div>

程序集中的可执行代码只有在被需要时由JIT编译器编译，然后就被缓存cache起来以备在后来的程序中执行。这意味着不被调用的代码不会被编译成本机代码，而且被调用到的代码只被编译一次。

一旦CIL被编译成本机代码，CLR就在运行时管理它，执行如释放无主内存、检查参数类型、管理异常等任务。在CLR控制之下的代码称为托管代码（managed code）；而不在CLR控制之下运行的代码为非托管代码。

## CLR
.NET框架的核心组件是**CLR**，它在操作系统顶层，负责管理程序的执行：

<div  align="center">  
<img src="https://s2.loli.net/2022/11/01/iltGr4vmNuyMsA1.png" width = "50%" height = "50%" alt="图4 - CLR概览"/>
</div>

CLR还通过访问BCL得到广泛的编程功能，包括如Web服务和数据服务之类的功能。

## CLI
每种编程语言都有一组内置的类型，包括整数、浮点数和字符等对象。但是这些类型因为编程语言和平台的不同而不同，这种缺乏统一性需要一组标准促进有序协作。

**CLI**（Common Language Infrastructure 公共语言基础结构）就是一组标准，它把.NET框架的所有组件连结成了一个系统。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/01/Qq9xHIoUvszDgZh.png" width = "55%" height = "55%" alt="图5 - CLI组成"/>
</div>

1. 公共类型系统  
**CTS**（Common Type System 公共类型系统），它定义了一组内置类型；.NET兼容编程语言提供的类型通常映射到CTS已定义的内置类型集的某个特殊子集；***CTS让所有类型都继承自公共的基类——object***；CTS确保用户定义的类型和系统类型能够被任何.NET兼容的语言使用。

2. 公共语言规范  
**CLS**（Common Language Specification 公共语言规范）详细说明了.NET兼容编程语言的规则、属性和行为，包括数据类型、类结构和参数传递）。


# 第二章 C#和.NET Core
## .NET Core的由来
为了更好地解决Web开发以及Linux或macOS的开发，微软用.NET框架搭建了一个基于云的、跨平台的、开源衍生产品，这个新框架即 **.NET Core**。微软也收购了Xamarin以解决Android和IOS等移动平台的开发问题。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/01/UBiFr2XZNK4nJuE.png" width = "70%" height = "70%" alt="图6 - .NET生态系统"/>
</div>

.NET Core主要目标为多平台支持；快速开发和升级；更小的应用程序占用空间；更简单的部署；更少的版本问题；开源社区的支持；改进的应用程序性能。


# 第三章 C#编程概述
## 一个简单的C#程序
``` C#
using System;

namespace Simple
{
    class Program   // declare a class
    {
        static void Main()
        {
            Console.WriteLine("Hi there!");
        }
    }
}
```

行1 ：告诉编译器这个程序使用**System命名空间**的类型；  
行3 ：声明新的名为**Simple的命名空间**，在这部分声明的任何类型都是该命名空间的成员（第4行到第12行）；  
行5 ：声明新的名为**Program的类类型**，在这部分声明的任何成员都是组成这个类的成员（第6行到第11行）；  
行7 ：声明一个名称为**Main的方法**作为**类Program**的成员，**Main是一个特殊函数**，编译器用它作为程序的起始点；  
行9 ：包含了一条简单的语句，组成了**Main的方法**：简单语句以一个分号结束，这条语句使用**命名空间System**中的一个名为**Console的类**将消息输出到屏幕窗口，若没有第一条的**using语句**，编译器就不知道在哪里寻找**类Console**。

*C#程序由一个或多个类型声明组成，命名空间是与某个名称相关联的一组类型声明*。上述代码创建了一个名称为Simple的新命名空间，并在其中声明了其类型（类Program），还使用了System命名空间中定义的Console类。


> ***补充 ：使用 Visual Studio Code 创建 .NET 控制台应用程序（摘自官方.NET文档）***
> 
> **先决条件**：.NET 6 SDK以及已安装 C# 扩展 的 Visual Studio Code
> 
> **创建应用**：  
> 1、在合适位置创建文件夹，并打开vscode打开该文件夹。默认情况下，文件夹名称将是项目名称和命名空间名称；  
> 2、在vscode中选择Terminal - New Terminal；  
> 3、在“终端”中输入以下命令：`dotnet new console --framework net6.0`；  
> 4、此时创建了一个在控制台窗口中显示“Hello World”的简单应用程序：
> ``` C#
> Console.WriteLine("Hello, World!");
> ```
> 
> 首次创建程序时，Visual Studio Code 会提示添加缺少的资产，以生成和调试应用。 选择“是”，Visual Studio Code 会创建一个包含“launch.json”和“tasks.json”文件的“.vscode”文件夹。
> 
> <div  align="center">  
> <img src="https://s2.loli.net/2022/11/04/qmQSHOwfJIvMb8Y.png" width = "55%" height = "55%"/>
> </div>
> 
> 如果未收到提示，或者意外将其关闭而未选择“是”，可以按如下操作步骤：
> 
> <div  align="center">  
> <img src="https://s2.loli.net/2022/11/04/PtDE7zaYQeFGokC.png" width = "35%" height = "35%"/>
> </div>
> 
> 也可以从菜单中选择Run - Add Configurations，在“选择环境”提示符下，选择“.NET 5+ 和 .NET Core”。
> 总之最后要见到 .vscode 中的 launch.json 和 tasks.json 文件。
> 
> **运行应用**：  
> 在“终端”中运行以下命令：`dotnet run`  
> 程序显示“Hello World!”并终止。


## 标识符 Identifiers
**标识符**是用于命名的字符串。  

某些字符能否在标识符的特定位置出现是有规定的：
  - 字母和下划线可以出现在任何位置；
  - 数字不能放在首字母，但可以出现在其他任何位置；
  - @字符只能放在标识符的首位，不推荐将@作为常用字符。

标识符区分大小写，比如变量名myVar和MyVar是不同的标识符。第8章将介绍推荐的C#命名约定。

## 关键字 Keywords
**关键字**不能作为标识符，除非以@字符开始。  
所有C#关键字全部都以小写字母组成。

*表：C#关键字*

| |||||||
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| abstract | const | extern | int | out | short | typeof |
| as | continue | false | interface | override | sizeof | uint |
| base | decimal | finally | internal | params | stackalloc | ulong |
| bool | default | fixed | is | private | static | unchecked |
| break | delegate | float | lock | protected | string | unsafe |
| byte | do | for | long | public | struct | ushort |
| case | double | foreach | namespace | readonly | switch | using |
| catch | else | goto | new | ref | this | virtual |
| char | enum | if | null | return | throw | void |
| checked | event | implicit | object | sbyte | true | volatile |
| class | explicit | in | operator | sealed | try | when while |

**上下文关键字 Contextual Keywords**是仅在特定的语言结构中充当关键字的标识符，上下文关键字可以在代码的其他部分被用作标识符。

*表：C#的上下文关键字*

| |||||||
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| add | ascending | async | await | by | descending | dynamic |
| equals | from | get | global | group | in | into |
| join | let | on | orderby | partial | remove | select | 
| set | value | var | where | yield | | | 

## Main：程序的起始点  
每个C#程序必须有一个类带有**Main方法(函数)**。
  - 每个C#程序的可执行起始点在Main中的第一条指令；
  - Main必须首字母大写。

``` C#
static void Main( )
{
    Statements
}
```

## 空白 Whitespace
程序中的空白指没有可视化输出的字符。在源代码中使用的空白会被编译器忽略。

空白字符包括：空格(Space)；制表符(Tab)；换行符(New line)；回车符(Carriage return)

比如，下面的代码会被编译器同等对待：

``` C#
Main()
{
    Console.WriteLine("Hi, there!");
}
// 连在一起
Main(){Console.WriteLine("Hi, there!");}
```

## 语句 Statements
此处为简单介绍，详细见第10章。

**简单语句**以一个**分号**结束，下面的代码即2条简单语句组成的序列：
``` C#
int var1 = 5;
System.Console.WriteLine("The value of var1 is {0}", var1);
```

## 块 Blocks
**块**是一个由成对大括号包围的0条或多条语句序列，它在语法上相当于一条语句。
``` C#
{
    int var1 = 5;
    System.Console.WriteLine("The value of var1 is {0}", var1);
}
```

语法上只需要一条语句，若需要执行的动作无法用一条简单语句表达时，考虑用块；  
有些特定的程序结构只能使用块；  
简单语句以分号结束，块后面不跟分号。

## 从程序中输出文本
**控制台窗口console window**是一种简单的命令提示窗口。BCL提供了一个名为Console的类（在System命名空间中），该类包含了讲数据输入和输出到控制台窗口的方法。

### Write
Write是Console类的成员，示例：
``` C#
System.Console.Write ("This is text1. ");
System.Console.Write ("This is text2. ");
System.Console.Write ("This is text3. ");
```

在控制台窗口输出如下：
``` Console
This is text1. This is text2. This is text3.
```

注意：Write没有在字符串后面添加换行符，所以三个语句都输出在同一行。

### WriteLine
WriteLine也是Console类的成员，但会在每个输出字符串的结尾添加一个换行符。

上面的代码用WriteLine替换掉Write，输出会变为多行：  
``` Console
This is text1.
This is text2.
This is text3.
```

### 格式字符串 The Format String
Write或WriteLine语句可以有一个以上的参数，格式如下：  
`Console.WriteLine( FormatString, SubVal0, SubVal1, SubVal2, ... );`

第一个参数必须总是字符串，称为**格式字符串**；格式字符串可以包括**代替标记Substitution markers**。代替标记包含大括号和一个整数，整数就是替换值的数字位置。

例如：下面的语句有2个替代标记，{0}和{1}；以及2个替换值，即3和6。
``` C#
Console.WriteLine("Two sample integers are {0} and {1}.", 3, 6);
```

C# 6.0 还引入了**字符串插值string interpolation**，前提是前面加上$符号：
``` C#
int var1 = 3;
int var2 = 6;
Console.WriteLine($"Two sample integers are {var1} and {var2}.");
```

### 多重标记和值
可以使用任意数量的替代标记和任意数量的值，比如：
``` C#
Console.WriteLine("Three integers are {1}, {0} and {1}.", 3, 6);
```

但标记不能引用超出替换值列表长度的值，如果引用，不会产生编译错误compile error，但会产生运行错误runtime error（称为**异常exception**）。比如：`Console.WriteLine("Two integers are {0} and {2}.", 3, 6);`中位置2不存在，3是位置0，6是位置1。

### 格式化数字字符串
指定数字格式，例如：
``` C#
Console.WriteLine("The value: {0}." , 500);
Console.WriteLine("The value: {0:C}.", 500); // 格式化为货币

int myInt = 500;
Console.WriteLine($"The value: {myInt}.");
Console.WriteLine($"The value: {myInt:C}.");
```

上述2种代码，都在控制台窗口产生同样输出：
``` Console
The value: 500.
The value: ￥500.00.
```

大括号内的**格式说明符format specifier**的语法由三个字段fields组成：**索引号index或者字符串插值变量string interpolation variable**、**对齐说明符alignment specifier**和**格式字段format field**。

语法为：`{ index,alignment:format }`

*index或string interpolation*：必需项，指定列表中的某一项；  
*alignment*：可选，指定字段宽度，以及是否是左对齐或是右对齐；  
*format*：可选，指定项的格式。  
*注意*：对齐前面是逗号，格式前面是冒号。

***（1）对齐说明符***  
由一个正整数或者负整数组成：*整数表示字段使用字符的最少数量*；符号表示右对齐或左对齐，*正数表示右对齐，负数表示左对齐*。
``` C#
int myInt = 500;
Console.WriteLine("|{0, 10}|", myInt); // 右对齐Aligned right
Console.WriteLine("|{0,-10}|", myInt); // 左对齐Aligned left
```

输出如下，在两个竖杠的中间有10个字符：
``` Console
|       500|
|500       |
```

*如果要表示的字符数比对齐说明符指定的字符数少，那么其余字符会使用空格填充*；  
*如果要表示的字符数多于指定的字符数，对齐说明符会被忽略，并且使用所需的字符进行表示*。

***（2）格式字段***  
格式字段有三部分，①**冒号**后面必须紧跟格式说明符，中间不能有空格；②**格式说明符format specifier**是一个字母字符，是9个内置字符格式之一，可以是大写或者小写；③**精度说明符precision specifier**是可选的，由1~2位数字组成，实际意义取决于格式说明符。

语法为：`:Axx`，A为格式说明符，xx为精度说明符。
``` C#
double myDouble = 12.345678;
Console.WriteLine("{0,-10:G} -- General", myDouble);
Console.WriteLine("{0,-10} -- Default, same as General", myDouble);
Console.WriteLine("{0,-10:F4} -- Fixed Point, 4 dec places", myDouble);
Console.WriteLine("{0,-10:C} -- Currency", myDouble);
Console.WriteLine("{0,-10:E3} -- Sci. Notation, 3 dec places", myDouble);
Console.WriteLine("{0,-10:x} -- Hexadecimal integer", 1194719 );
```

输出如下：
``` Console
12.345678  -- General
12.345678  -- Default, same as General
12.3457    -- Fixed Point, 4 dec places
￥12.35     -- Currency
1.235E+001 -- Sci. Notation, 3 dec places
123adf     -- Hexadecimal integer
```

***（3）标准数字格式说明符***  
9种标准数字格式说明符，若说明符会根据大小写会有不同输出，会标注为区分大小写。

| 名字和字符 | 意义 |
| :---- | :---- |
| 货币Currency<br>C、c | 使用货币符号，货币符号取决于程序所在PC的区域设置<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :C}", 12.5);`<br>输出：￥12.50 |
| 十进制数Decimal<br>D、d | 十进制数字字符串，可以有负数符号。只能和整数类型配合使用<br>精度说明符：输出字符串的最小位数，若实际数字位数少，则左边以0填充<br>示例：`Console.WriteLine("{0 :D4}", 12);`<br>输出：0012 |
| 定点Fixed-point<br>F、f | 带有小数点的十进制数字字符串，可以有负数符号。<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :F4}", 12.3456789);`<br>输出：12.3457 |
| 常规General<br>G、g | 在没有指定说明符的情况下，会根据值转换为定点或科学计数法表示的形式<br>精度说明符：根据值的情况<br>示例：`Console.WriteLine("{0 :G4}", 12.3456789);`<br>输出：12.35 |
| 十六进制数Hexadecimal<br>X、x<br>区分大小写 | 十六进制数字字符串。A~F会匹配说明符的大小写<br>精度说明符：输出字符串的最小位数，若实际数字位数少，则左边以0填充<br>示例：`Console.WriteLine("{0 :x}", 180026);`<br>输出：2bf3a |
| 数字Number<br>N、n | 和定点表示法相似，但是每3个数字的一组中间有逗号或空格分隔符，使用哪个看程序所在PC的区域设置<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :N2}", 12345678.54321);`<br>输出：12,345,678.54 |
| 百分比Percent<br>P、p | 表示百分比的字符串，数字会乘以100<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :P2}", 0.1221897);`<br>输出：12.22% |
| 往返过程Round-trip<br>R、r | 保证输出字符串后如果使用Parse方法将字符串转化为数字，Parse方法在第27章<br>精度说明符：忽略<br>示例：`Console.WriteLine("{0 :R}", 1234.21897);`<br>输出：1234.21897 |
| 科学计数法Scientific<br>E、e<br>区分大小写 | 具有尾数和指数的科学计数法，e的大小写和说明符一致<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :e4}", 12.3456789);`<br>输出：1.2346e+001 |

## 注释：为代码添加注解 Comments: Annotating the Code
**单行注释 Single-line comments** ：`//`，注释范围一直到行结束都有效。

**带分隔符的注释 Delimited comments** ：开始标记`/*`和结束标记`*/`，带分隔符的注释可以跨越多行，或者只包括行的一部分。注释范围一直到第一个结束分隔符都有效。

**文档注释 Documentation Comments** ：`///`，在第27章阐述。文档注释包括XML文档，可以用于产生程序文档。


# 第四章 类型、存储和变量
## C#程序是一组类型声明
C程序是一组函数和数据类型，C++程序是一组函数和类，C#程序或DLL是一组类型声明。

(1) 类型声明中必须有一个包含**Main方法**的类；  
(2) **命名空间**将相关的类型声明分组并命名，所以在命名空间内声明程序类型。

``` C#
namespace MyProgram // Declare a namespace，名为MyProgram.
{
    DeclarationOfTypeA // Declare a type.
    DeclarationOfTypeB // Declare a type.

    class C // Declare a type.
    {
        static void Main()
        {
            ...
        }
    }
}
```

命名空间在第22章详细阐述。

## 类型是一种模板
类型可以理解为一个创建数据结构的模板。类型具有以下元素：名称、用于保存的数据结构、一些行为和约束条件。

比如：short类型，名称是short，结构是2字节，行为是16位整数。int类型，名称是int，结构是4字节，行为是32位整数。

## 实例化类型 Instantiating a Type
从类型模板创建对象，即**实例化**该类型。

通过实例化类型而创建的对象被称为类型的**对象**或类型的**实例**。这2术语可以互换。

## 数据成员和函数成员
**简单类型**如short、int和long，只能存储一个数据项；
数组类型（array）可以存储多个同类型的数据项，这些数据项即**数组元素**。

然而有些类型可以包含不同类型的数据项，这些数据项被称为**成员 members**，包括**数据成员**和**函数成员**：**数据成员**保存了与这个类的对象或整个类相关数据；**函数成员**执行代码，定义类型的行为。

## 预定义类型
C#有16种预定义类型，包括13种**简单类型**和3种**非简单类型**。所有预定义类型的名称都是小写。

简单类型可以分为3类：    
(1) 11种数值类型：  
&ensp;&ensp;&ensp;- 不同长度的有符号和无符号*整数类型*；  
&ensp;&ensp;&ensp;- *浮点数类型*float和double；  
&ensp;&ensp;&ensp;- *高精度小数类型*decimal，与float和double不同，decimal类型可以表示分数，常用于货币计算。  
(2) *Unicode字符类型*char；  
(3) *布尔类型*bool，即true和false。  

3种非简单类型为：  
(1) string，一个Unicode字符数组；  
(2) object，所有类型的基类；  
(3) dynamic，使用动态语言编写的程序集使用。  

<div  align="center">  
<img src="https://s2.loli.net/2022/11/16/pKUunxX9i5ayjqt.png" width = "60%" height = "60%" alt="图9 - 预定义类型"/>
</div>

所有预定义类型都映射到底层的.NET类型。*预定义简单类型*都表示一个单一的数据项，如下表：

| 名称 | 含义 | 范围 | .NET框架类型 | 默认值 |
| :---- | :---- | :---- | :---- | :---- |
| sbyte | 8-bit signed integer | -128 to 127 | System.SByte | 0 |
| byte | 8-bit unsigned integer | 0 to 255 | System.Byte | 0 |
| short | 16-bit signed integer | -32,768 to 32,767 | System.Int16 | 0 |
| ushort | 16-bit unsigned integer | 0 to 65,535 | System.UInt16 | 0 |
| int | 32-bit signed integer | -2,147,483,648 to 2,147,483,647 | System.Int32 | 0 |
| uint | 32-bit unsigned integer | 0 to 4,294,967,295 | System.UInt32 | 0 |
| long | 64-bit signed integer | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | System.Int64 | 0 |
| ulong | 64-bit unsigned integer | 0 to 18,446,744,073,709,551,615 | System.UInt64 | 0 |
| float | Single-precision float | 1.5×10^-45 to 3.4×10^38 | System.Single | 0.0f |
| double | Double-precision float | 5×10^-324 to 1.7×10^308 | System.Double | 0.0d |
| bool | Boolean | true, false | System.Boolean | false |
| char | Unicode character | U+0000 to U+ffff | System.Char | \x0000 |
| decimal | Decimal value with 28-significant-digit precision | ±1.0×10^28 to ±7.9×10^28 | System.Decimal | 0m |

*预定义非简单类型*，如下表：

| 名称 | 含义 | .NET框架类型 |
| :---- | :---- | :---- |
| object | 所有其他类型的基类，包括简单类型 | System.Object |
| string | 0个或多个Unicode字符组成的序列 | System.String |
| dynamic |  在使用动态语言编写的程序集assemblies时使用 | 无相应的 .NET type |

## 用户定义类型
C#有16种预定义类型，另外还有6种类型可以由用户自己创建：  
*类类型 class*；*结构类型 struct*；*数组类型 array*；*枚举类型 enum*；*委托类型 delegate*；*接口类型 interface*。

类型通过**类型声明type declaration**创建。

预定义类型直接实例化对象即可；用户定义类型要先声明类型，然后实例化该类型对象。

## 栈和堆 The Stack and the Heap
运行中的程序使用两个内存区域来存储数据：栈和堆。
### 栈 The Stack
**栈**是一个内存数组，是一个**LIFO**（后进先出）的数据结构。

数据只能从栈的顶端插入和删除；把数据放到栈顶称为**入栈push**；从栈顶删除数据称为**出栈pop**。

### 堆 The Heap
**堆**是一块内存区域，堆里的内存能够以任意顺序存入和移除。

虽然程序可以在堆里保存数据，但是不能显示地删除它们。CLR的自动垃圾收集器在判断出程序代码不会再访问某数据项时，会自动清理无主对象。

## 值类型和引用类型
数据项的类型定义了存储需要的内存大小及组成该类型的数据成员，也决定了对象在内存的存储位置——栈或堆。

类型分为**值类型value types**和**引用类型reference types**：  
*值类型*只需要一段单独的内存，数据存放在栈中；  
*引用类型*需要两端内存：第一段存储实际的数据，位于堆中。第二段是一个*引用*，指向数据在堆存放的位置，而引用存放在栈中。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/17/yelvL6bXRMFCacG.png" width = "70%" height = "70%" alt="图10 - 非成员数据的存储"/>
</div>

### 存储引用类型对象的成员
上图是当数据不是另一个对象的成员的存储方式。若数据是另一对象的成员，会有些不同。

假设一个引用类型的实例，名为MyType，包括2个成员：一个值类型成员A和一个引用类型成员B。 

对于一个引用类型，其实例的数据部分始终存放在堆中，二个成员都是对象数据的一部分，即都会存放在堆中，无论是值类型还是引用类型。即，引用类型B的数据和引用部分都存放在堆里；值类型A也在堆里。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/17/tdWgnr78DFyScLx.png" width = "50%" height = "50%" alt="图11 - 引用类型对象数据的存储"/>
</div>

### C#类型的分类
如下表：

| | 值类型 | 引用类型 |
| :---- | :---- | :---- |
| 预定义类型 | sbyte byte<br>short ushort<br>int uint<br>long ulong<br>bool char<br>float double<br>decimal | object<br>string<br>dynamic |
| 用户定义类型 | struct<br>enum | class<br>interface<br>delegate<br>array |

## 变量 Variables
**变量**是一个名称，表示程序执行时存储在内存中的数据。

C#提供了4种变量，如下表：

| 名称 | 描述 |
| :---- | :---- |
| 局部变量Local variable | 在方法的作用域保存临时数据，不是类型的成员 |
| 字段Field | 保存和类型或类型实例相关的数据，是类型的成员 |
| 参数Parameter | 用于从一个方法到另一个方法传递数据的临时变量，不是类型的成员 |
| 数组元素Array element | 同类数据项构成的有序集合的一个成员，可以是局部变量，也可以是类型的成员 |

### 变量声明
变量声明定义了变量，并且完成了：① 给变量命名，并关联一种类型；② 让编译器分配一块内存。一个简单的变量声明至少需要一个类型和一个名称。

比如：`int var2;` 定义了一个名为 var2 的 int 类型的变量。

*（1）变量初始化语句*  

**变量初始化语句 variable initializer**由一个等号和初始值组成：`int var2 = 17;`

无初始化语句的局部变量有一个未定义的值，在赋值前不能使用。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/18/YPb8zBrDXshlfwj.png" width = "70%" height = "70%" alt="图12 - 变量初始化语句"/>
</div>

*（2）自动初始化*

有一些类型的变量如果没初始化，会被自动设为默认值。没有自动化为默认值的变量在程序为它赋值之前包含未定义值。

| 变量类型| 存储位置 | 自动初始化 | 用途 |
| :---- | :---- | :---- | :---- |
| 局部变量 Local variables | 栈或栈和堆 | 否 | 用于函数成员内部的局部计算 |
| 类字段 Class fields | 堆 | 是 | 类的成员 |
| 结构字段 Struct fields | 栈或堆 | 是 | 结构的成员 |
| 参数 Parameters | 栈 | 否 | 用于把值传入或传出方法 |
| 数组元素 Array elements | 堆 | 是 | 数组的成员 |

### 多变量声明
可以在单个声明语句中声明多个变量：①多变量声明中的变量必须类型相同；②变量名必须逗号隔开，可以包含初始化语句。

``` C#
//声明一些变量，有的被初始化，有的没被初始化
int var3 = 7, var4, var5 = 3;
double var6, var7 = 6.52;

int var8, float var9; //错误：多变量声明的变量类型必须相同
```

## 静态 static 类型和 dynamic 关键字
C#是静态类型的语言，但 IronPython 和 IronRuby 之类的脚本语言是动态类型的，因为它们也是.NET
语言，C#需要能够使用这些语言编写的程序集，因此增加了dynamic关键字。

## 可空类型 Nullable Types
在某些情况下，希望变量目前不保存有效的值。对于引用类型，可以把变量设为null；但对于值类型，不管内容是否有效，其内存都会分配。可以使用布尔指示器来和变量关联，值有效则设置为true，无效即false。

**可空类型**允许创建可以标记为有效和无效的值类型变量。普通的值类型为**非可空类型**。详见第27章。


# 第五章 类的基本概念
## 类的概述
数据项和函数的封装集合，被称为**类**。

类包括数据成员和函数成员：①数据成员，存储与类或类实例相关的数据；②函数成员，执行代码。

| 数据成员存储数据 | 函数成员执行代码 |
| :---- | :---- |
| 字段 Fields<br>常量 Constants | 方法 Methods ；运算符 Operators ；属性 Properties ；索引器 Indexers<br>构造函数 Constructors ；事件 Events ；析构函数 Destructors |

## 声明类
**类的声明**定义类的名称、成员和特征，不创建类的实例，创建用于创建实例的模板。

``` C#
class MyExcellentClass //class为关键字Keyword，MyExcellentClass是类名
{
    MemberDeclarations
}
```

## 类成员
### 字段
**字段**是在类中的变量。可以是任意类型，包括预定义类型或用户定义的类型。

``` C#
class MyClass
{
    int MyField; //MyField即字段名称
}
```

与 C 和 C++ 不同，*C#在类型外面不能申明全局变量*。所有字段都属于类型。

因为字段是一种变量，**字段初始化语句**和变量初始化语言相同；如果没有初始化语句，字段的值会被编译器设为默认值，总结的来说，每种值类型的默认值都是0，bool 型的默认值是 false，引用类型的默认值为 null 。

``` C#
class MyClass
{
    int F1; // 初始化为0 - 值类型
    string F2; // 初始化为null - 引用类型

    int F3 = 25; // 初始化为25
    string F4 = "abcd"; // 初始化为"abcd"
}
```

在同一语句中声明多个字段，下面语句与上面效果相同：

``` C#
int F1, F3 = 25;
string F2, F4 = "abcd";
```

### 方法
**方法**是具有名称的可执行代码块，相当于C++的**成员函数**。

声明方法包括以下4个组成部分：  
①返回类型：声明方法返回值的类型，若不返回值，则被指定为 void ；  
②名称：方法的名称；  
③参数列表：由一对圆括号组成，参数列在其中；  
④方法体：由一对大括号组成，包含执行代码。

``` C#
class SimpleClass
{
    void PrintNums()
    {
        Console.WriteLine("1");
        Console.WriteLine("2");
    }
}
```

上述代码不返回值（void），有空的参数列表，方法体有2行。

与 C 和 C++ 不同，C#**没有全局函数**，也没有默认的返回类型，所有方法必须包含返回类型或者 void 。

## 创建变量和类的实例
类是引用类型，数据的引用保存在一个类类型的变量中，要创建类的实例，需要声明一个类类型的变量开始，如果变量没有被初始化，它的值是未定义的。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/19/DZy8t9hd3uxGcOa.png" width = "60%" height = "60%" alt="图13 - 为类变量的引用分配内存"/>
</div>

左边顶端的代码是类 Dealer 的声明，下面是类 Program 的声明，它包含 Main 方法；Main 声明了 Dealer 类型的变量 theDealer 。因为该变量没有被初始化，所有它的值是未定义的。

## 为数据分配内存
声明类类型的变量所分配的内存是用来保存引用的，不是用来保存类对象实际数据的。要为实际数据分配内存，需要使用 **new 运算符 operator**。  
①new 运算符能为任意指定类型的实例分配并**初始化**内存；  
②使用 new 运算符组成一个**对象创建表达式**，包括：关键字 new ；要分配内存的实例的类型名称；成对的圆括号，包含或不包含参数。  
③如果将内存分配给一个引用类型，则对象创建表达式返回一个引用，指向在堆中被分配或初始化的对象实例。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/19/s9Vg3YBLvb7eXTP.png" width = "70%" height = "70%" alt="图14 - 为类变量的数据分配内存"/>
</div>

`Dealer theDealer;`声明引用变量；`theDealer = new Dealer();`为类对象分配内存并赋值给变量

合并以上两个步骤，用对象创建表达式来**初始化**变量：

``` C#
Dealer theDealer = new Dealer(); // 声明并初始化
```

## 实例成员
**实例成员 Instance members**：类的每个实例都有自己的一组数据，不同于同一类的其他实例。因为数据成员和类的实例相关，所以被称为实例成员。

**静态成员 Static members**：实例成员是默认类型，但是可以声明与类有关，与实例无关的成员，称为静态成员。见第7章。

## 访问修饰符 Access Modifiers
**访问修饰符**是成员声明的可选部分，指明程序的其他部分如何访问成员，语法如下：
①字段：`访问修饰符 类型 标识符;` ②方法：`访问修饰符 返回类型 方法名()`

5种成员访问控制如下，本章只介绍前2种，其余在第8章：
①私有的 private ；②公有的 public ；③受保护的 protected ；④内部的 internal ；⑤受保护内部的 protected internal

范围比较：private < internal/protected < protected internal < public

### 私有访问和公有访问
私有成员只能从声明它的类的内部访问，其他的类看不到或无法访问它们。  
私有访问是默认的，若声明时不带访问修饰符，即私有成员。

``` C#
int MyInt1; //隐式声明为私有
private int MyInt2; //显示声明为私有
```

公有成员可以被程序中的其他对象访问。必须使用 public 访问修饰符指定。`public int MyInt;`

成员访问示例：

``` C#
class C1
{
    int F1; //隐式私有字段
    private int F2; //显式私有字段
    public int F3; //公有字段

    void DoCalc() //隐式私有方法
    {
    ...
    }

    public int GetVal() //公有方法
    {
    ...
    }
}
```

## 从类的内部访问成员
下面的类展示了类的方法对字段和其他方法的访问，私有成员可以被类的任何方法访问：

``` C#
class DaysTemp
{
    //字段
    private int High = 75;
    private int Low = 45;

    //方法
    private int GetHigh()
    {
        return High; //访问私有字段
    }

    private int GetLow()
    {
        return Low; //访问私有字段
    }

    public float Average ()
    {
        return (GetHigh() + GetLow()) / 2; //访问私有方法
    }
}
```

## 从类的外部访问成员
要从类的外部访问实例成员，需要**点运算符 dot-syntax notation**，如下：

``` C#
DaysTemp myDt = new DaysTemp(); //创建类的对象
float fValue = myDt.Average(); //从外部访问
```

示例如下，DaysTemp 内的两个字段被声明为 public ，可以从类外部访问：

``` C#
class DaysTemp //声明类 DaysTemp
{
    public int High = 75;
    public int Low = 45;
}

class Program //声明类 Program
{
    static void main()
    {
        DaysTemp temp = new DaysTemp(); //创建对象

        temp.High = 85; //字段赋值
        temp.Low = 60;

        Console.WriteLine("High:   {0}", temp.High ); //读取字段值
        Console.WriteLine($"Low:    {temp.Low}");
    }
}
```

运行结果如下：

``` console
High:   85
Low:    60
```

## 综合应用
创建两个实例并把它们的引用保存在名称为 t1 和 t2 的变量中：

``` C#
class DaysTemp //声明类
{
    public int High, Low; //声明实例字段

    public int Average() //声明实例方法
    {
        return (High + Low) / 2;
    }
}

class Program
{
    static void Main()
    {
        //创建两个DaysTemp实例
        DaysTemp t1 = new DaysTemp();
        DaysTemp t2 = new DaysTemp();

        //给字段赋值
        t1.High = 76; t1.Low = 57;
        t2.High = 75; t2.Low = 53;

        //读取字段值和调用实例的方法
        Console.WriteLine("t1: {0}, {1}, {2}",
                                  t1.High, t1.Low, t1.Average() );
        Console.WriteLine("t2: {0}, {1}, {2}",
                                  t2.High, t2.Low, t2.Average() );
    }
}
```

运行结果如下：

``` console
t1: 76, 57, 66
t2: 75, 53, 64
```

<div  align="center">  
<img src="https://s2.loli.net/2022/11/20/djQIPz6cxEgRlY7.png" width = "50%" height = "50%" alt="图15 - 实例t1和t2的内存布局"/>
</div>


# 第六章 方法
## 方法的结构
*方法是类的函数成员*，包括方法头 method header 和方法体 method body。

方法头指定方法的特征：`int MyMethod ( int par1, string par2 )`，即返回类型、方法名称及参数列表。

方法体包含可执行代码的语句序列。

## 方法体内部的代码执行
方法体是个**块**，是大括号括起的语句序列。可以包括：*局部变量；控制流结构 Flow-of-control constructs ；方法调用 Method invocations ；内嵌的块；其他方法（局部函数）*

``` C#
static void Main()
{
    int myInt = 3; //局部变量初始化为3

    while (myInt > 0) //控制流结构
    {
        --myInt;
        PrintMyMessage(); //方法调用
    }
}
```

## 局部变量
和字段一样，局部变量也保存数据。字段通常保存和对象状态有关的数据，而局部变量是用于保存临时的计算数据。

局部变量声明的语法：`Type Identifier = Value;`

下面的代码包含了2个局部变量的声明，第一个是int类型变量，第二个是SomeClass类型变量：

``` C#
static void Main( )
{
    int myInt = 15;
    SomeClass sc = new SomeClass();
    ...
}
```

对比实例字段和局部变量：

| | 实例字段 | 局部变量 |
| :---- | :---- | :---- |
| 生存期 | 从实例被创建时开始，直到实例不再被访问时结束 | 从它的块中被声明的那一刻开始，在块完成执行时结束 |
| 隐式初始化 | 初始化成该类型的默认值 | 没有隐式初始化。如果变量在使用之前没有被赋值，编译器就会产生一条错误消息 |
| 存储区域 | 由于实例字段是类的成员，所以所有字段都存储在堆里，无论是值类型还是引用类型 | 值类型：存储在栈里；引用类型：引用存储在栈里，数据存储在堆里 |

### 类型推导和 var 关键字

``` C#
static void Main( )
{
    int total = 15;
    MyExcellentClass mec = new MyExcellentClass();
    ...
}
```

上述代码中，第一个变量声明中，编译器可以推断出15是 int 型；第二个变量声明中，右边的对象创建表达式返回了 MyExcellentClass 类型的对象。为避免冗余，可以使用**关键字 var** ：

``` C#
static void Main( )
{
    var total = 15;
    var mec = new MyExcellentClass();
    ...
}
```

var 关键字并不表示特殊变量，只是句法的速记 shorthand ，表示任何可以从初始化语句的右边推断出的类型。var 只能用于局部变量，不能用于字段。一旦推断出类型，即不能改变。

> var 关键字不改变 C# 的强类型性质。

### 嵌套块中的局部变量
局部变量在嵌套块的内部声明，它的生存期限于声明它的内嵌块。

在 C# 中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量。和 C 和 C++ 不同。

## 局部常量 Local Constants
**常量**在声明时必须初始化，声明后不能改变。

声明语句如下：`const Type Identifier = Value;`

初始化值必须在编译期决定，通常是一个预定义简单类型或其组成的表达式。还可以是null引用，但不能是某对象的引用，因为对象的引用是在运行时决定的。

**关键字 const** 不是修饰符，是核心声明的一部分，必须直接放在类型前面。

局部常量也在方法体或代码块中声明，并在声明它的块结束的地方失效。

``` C#
void DisplayRadii() {
    const double PI = 3.1416; //声明局部常量

    for (int radius = 1; radius <= 5; radius++) {
        double area = radius * radius * PI; //读取局部常量
        Console.WriteLine
            ($"Radius: { radius }, Area: { area }");
    }
}
```

## 控制流 Flow of Control
默认情况下，程序按顺序执行语句，**控制流语句**允许改变执行的顺序。详见第10章。

①**选择语句 Selection statements**：`if` 、`if...else` 、`switch` ;  
②**迭代语句 Iteration statements**：`for 循环`、`while 循环`、`do 循环`、`foreach` ；  
③**跳转语句 Jump statements**：`break` 、`continue` 、`goto` 、`return` 。

## 方法调用 Method Invocations
可以从方法体的内部调用其他方法：

``` C#
class MyClass
{
    void PrintDateAndTime() //声明方法
    {
        DateTime dt = DateTime.Now; //获取当前日期和时间
        Console.WriteLine($"{ dt }"); //输出
    }

    static void Main() //声明方法
    {
        MyClass mc = new MyClass();
        mc.PrintDateAndTime( ); //调用方法，别忘了空的参数列表
    }
}
```

调用方法时的控制顺序：当前方法的执行在调用其他方法的点被挂起 → 控制转移到被调用方法的开始 → 被调用方法执行语句直到该方法结束 → 控制回到发起调用的方法。

如果另一个方法在同一个类中，可以直接使用它的名称并传入所需参数进行调用；如果另一个方法在不同的类中，必须通过这个类的一个对象实例调用它，且另一个类中的方法必须使用 public 访问修饰符声明。

## 返回值
方法要向调用代码返回一个值，除了要**声明返回类型**外，还要使用**返回语句**。若方法不返回值，即声明 void 返回类型，不需要返回语句。

返回语句包括关键字 return 及其后面的表达式：`return Expression;`

``` C#
int GetHour( ) //声明返回类型int
{
    DateTime dt = DateTime.Now;
    int hour = dt.Hour;

    return hour; //返回一个int
}
```

也可以返回用户定义类型的对象：

``` C#
MyClass method3( ) //声明返回类型MyClass
{
    MyClass mc = new MyClass();
    ...
    return mc; //返回一个MyClass对象
}
```

## void 方法
void 方法不需要返回语句。可以使用下面的返回语句提前退出方法，不带参数：`return;`。该语句只适用于 void 声明的方法。

``` C#
void SomeMethod()
{
    ...
    if ( SomeCondition )
        return; //返回到调用代码
    ...

    if ( OtherCondition )
        return; //返回到调用代码
    ...
} //默认返回到调用代码
```

## 局部函数 Local Functions
可以在一个方法内声明另一个方法，它只能在包含它的方法内调用，这些嵌入的方法被称为**局部函数**。

``` C#
class Program
{
    public void MethodWithLocalFunction()
    {
        int MyLocalFunction(int z1) //声明局部函数
        {
            return z1 * 5;
        }
    
        int results = MyLocalFunction(5); //调用局部函数
        Console.WriteLine($"Results of local function call: {results}");
    }

    static void Main(string[] args)
    {
        Program myProgram = new Program();
        myProgram.MethodWithLocalFunction(); //调用方法
    }
}
```

运行结果如下：

``` console
Results of local function call: 25
```

## 参数 Parameters
### 形参 Formal Parameters
**形参**是**局部变量**，它声明在方法的参数列表中，而不是在方法体中：`public void PrintSum( int x, float y )`。

参数在方法体的外面定义并在方法开始之前初始化（**输出参数**除外，见后面）；参数列表中可以有任意数目的形参声明，而且声明必须以逗号隔开。

``` C#
public void PrintSum( int x, int y )
{
    int sum = x + y;
    Console.WriteLine($"Newsflash: { x } + { y } is { sum }");
}
```

### 实参 Actual Parameters
调用方法时，形参的值必须在执行前初始化，用于初始化形参的表达式或变量称作**实参**（ actual parameters ，或称为 argument ）。

每一个实参必须与对应形参的类型相匹配，或者编译器能把实参隐式地转换为匹配的类型。

方法PrintSum的调用：`PrintSum( 5, someInt );`

实参的数量必须和形参的数量一致，并且每个实参的类型也必须和所对应的形参类型一致，这种形式的参数叫做**位置参数 Positional Parameters** 。

位置参数示例如下，对于第二次调用，编译器把 int 值 5 和 someInt 隐式地转换成了 float 类型：

``` C#
class MyClass
{
    public int Sum(int x, int y) //形参、声明方法
    {
        return x + y; //返回和
    }

    public float Avg(float input1, float input2) //形参、声明方法
    {
        return (input1 + input2) / 2.0F; //返回平均值
    }
}

class Program
{
    static void Main()
    {
        MyClass myT = new MyClass();
        int someInt = 6;

        Console.WriteLine
            ("Newsflash: Sum: {0} and {1} is {2}",
                5, someInt, myT.Sum( 5, someInt )); //实参、调用方法

        Console.WriteLine
            ("Newsflash: Avg: {0} and {1} is {2}",
                5, someInt, myT.Avg( 5, someInt )); //实参、调用方法
    }
}
```

运行结果如下：

``` console
Newsflash: Sum: 5 and 6 is 11
Newsflash: Avg: 5 and 6 is 5.5
```

## 值参数 Value Parameters
参数种类有好几种，目前为止看到的都是默认的类型，称为**值参数**。

使用值参数时，通过将实参的值复制到形参的方式把数据传递给方法。方法被调用时，系统执行如下操作：①在栈中为形参分配空间；②将实参的值复制给形参。

值参数的实参不一定是变量，可以是任何能计算成相应数据类型的表达式，如下：

``` C#
float func1( float val )
{
    float j = 2.6F;
    float k = 5.1F;
    ...
}


    float fValue1 = func1( k ); //方法调用
    float fValue2 = func1( (k + j) / 3 ); //方法调用，计算成 float 的表达式
```

用作实参之前，变量必须被复制（除非是输出函数）。对于引用类型，变量可以被设置为一个实际的引用或 null 。如下：

``` C#
class MyClass
{
    public int Val = 20; //初始化字段为20
}

class Program
{
    static void MyMethod( MyClass f1, int f2 ) //形参
    {
        f1.Val = f1.Val + 5; //参数的字段加5
        f2 = f2 + 5; //另一个参数加5
        Console.WriteLine($"f1.Val: { f1.Val }, f2: { f2 }");
    }

    static void Main()
    {
        MyClass a1 = new MyClass();
        int a2 = 10;

        MyMethod( a1, a2 ); //调用方法
        Console.WriteLine($"a1.Val: { a1.Val }, a2: { a2 }");
    }
}
```

输出结果如下:

``` console
f1.Val: 25, f2: 15
a1.Val: 25, a2: 10
```

<div  align="center">  
<img src="https://s2.loli.net/2022/11/29/phFWZkfumMcdVLw.png" width = "70%" height = "70%" alt="图16 - 值参数"/>
</div>

①在方法被调用前，用作实参的变量 a2 已经在栈里了；  
②在方法开始时，系统在栈中为形参分配空间，并从实参复制值。  
&emsp;&emsp;- 因为 a1 是引用类型，所以**引用被复制**，结果实参和形参都引用堆中的同一个对象；  
&emsp;&emsp;- 因为 a2 是值类型，所以**值被复制**，产生了一个独立的数据项。  
③在方法的结尾，f2 和对象 f1 的字段都被加上了5。  
&emsp;&emsp;- 方法执行后，形参从栈中弹出；  
&emsp;&emsp;- a2，值类型，它的值不受方法行为影响；  
&emsp;&emsp;- a1，引用类型，但它的值被方法的行为改变了。

> 区分参数和变量，值参数可以是引用类型的变量，注意与引用参数区分。

## 引用参数 Reference Parameters
第二种参数类型称为**引用参数**。

①使用引用参数时，必须在方法的声明和调用中都使用 **ref 修饰符**；  
②引用参数的**实参必须是变量**，在用作实参前必须被赋值。如果是引用类型变量，可以赋值为一个引用或 null 。

``` C#
void MyMethod( ref int val ) //方法声明，包含ref修饰符
{ ... }

int y = 1; //实参变量
MyMethod ( ref y ); //方法调用，包含ref修饰符

MyMethod ( ref 3+5 ); // Error!，必须使用变量
```

①引用参数不会在栈上为形参分配内存。  
②形参的参数名将作为实参变量的别名，指向相同的内存位置。  
由于形参名和实参名指向相同的内存位置，所以方法的执行过程中对形参做的任何改变在方法完成后依然可见。

``` C#
class MyClass
{
    public int Val = 20;
}

class Program
{
    static void MyMethod(ref MyClass f1, ref int f2) //ref修饰符
    {
        f1.Val = f1.Val + 5;
        f2 = f2 + 5;
        Console.WriteLine($"f1.Val: { f1.Val }, f2: { f2 }");
    }

    static void Main()
    {
        MyClass a1 = new MyClass();
        int a2 = 10;
        
        MyMethod(ref a1, ref a2); //调用方法，ref修饰符
        Console.WriteLine($"a1.Val: { a1.Val }, a2: { a2 }");
    }
}
```

输出结果如下：

``` console
f1.Val: 25, f2: 15
a1.Val: 25, a2: 15
```

<div  align="center">  
<img src="https://s2.loli.net/2022/11/29/OJWcAat1gi8SPhv.png" width = "70%" height = "70%" alt="图17 - 对于引用参数，形参就像实参的别名"/>
</div>

①在方法调用之前，将要被用作实参的变量 a1 和 a2 已经在栈里了；  
②在方法的开始，形参名被设置为实参的别名。变量 a1 和 f1 引用相同的内存位置，a2 和 f2 引用相同的内存位置；  
③在方法的结束位置，f2 和 f1 的对象的字段都被加上了5；  
④方法执行后，形参的名称已经失效，但值类型 a2 的值和引用类型 a1 所指向的对象的值被方法内的行为改变了。

## 引用类型作为值参数和引用参数
本节主要描述在方法内用引用类型给形参赋值会发生什么：  
①将引用类型对象作为**值参数**传递：如果在方法内创建一个新的对象并赋值给形参，将切断形参和实参之间的联系，并且在方法调用结束后，新对象将不存在。  
②将引用类型对象作为**引用参数**传递：如果在方法内创建一个新的对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。

*第一种情况 - 将引用类型对象作为值参数传递的示例：*

``` C#
class MyClass { public int Val = 20; }

class Program
{
    static void RefAsParameter( MyClass f1 )
    {
        f1.Val = 50;
        Console.WriteLine($"After member assignment: { f1.Val }");
        f1 = new MyClass();
        Console.WriteLine($"After new object creation: { f1.Val }");
    }

    static void Main( )
    {
        MyClass a1 = new MyClass();
        Console.WriteLine($"Before method call: { a1.Val }");
        RefAsParameter( a1 );
        Console.WriteLine($"After method call: { a1.Val }");
    }
}
```

输出结果如下：

``` console
Before method call: 20
After member assignment: 50
After new object creation: 20
After method call: 50
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/04/ocsiSMEuyIdvUpn.png" width = "70%" height = "70%" alt="图18 - 对用作值参数的引用类型对象赋值"/>
</div>

①在方法开始时，实参和形参都指向堆中相同的对象；  
②在为对象的成员赋值之后，它们仍指向堆中相同的对象；  
③当方法分配新的对象并赋值给形参时，方法外部的实参仍指向原始对象，而形参指向新对象；  
④在方法调用之后，实参指向原始对象，形参和新对象会消失。

*第二种情况 - 将引用类型对象作为引用参数传递的示例：*

``` C#
class MyClass
{
    public int Val = 20;
}

class Program
{
    static void RefAsParameter( ref MyClass f1 )
    {
        f1.Val = 50;
        Console.WriteLine($"After member assignment: { f1.Val }");
        
        f1 = new MyClass();
        Console.WriteLine($"After new object creation: { f1.Val }");
    }

    static void Main( string[] args )
    {
        MyClass a1 = new MyClass();

        Console.WriteLine($"Before method call: { a1.Val }");
        RefAsParameter( ref a1 );
        Console.WriteLine($"After method call: { a1.Val }");
    }
}
```

输出结果如下：

``` console
Before method call: 20
After member assignment: 50
After new object creation: 20
After method call: 20
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/04/yGU3lsVcNuoPdYM.png" width = "70%" height = "70%" alt="图19 - 对用作引用参数的引用类型对象赋值"/>
</div>

①在方法调用时，形参和实参指向堆中相同的对象；  
②对成员值的修改会同时影响到形参和实参；  
③当方法创建新的对象并赋值给形参时，形参和实参的引用都指向新对象。  
④在方法结束后，实参指向在方法内创建的新对象。

## 输出参数 Output Parameters
**输出参数**用于从方法体内把数据传出到调用代码，行为和引用参数类似。  
①必须**在声明和调用中**都使用修饰符，修饰符为 **out** 。  
②和引用参数一样，实参必须是变量，而不能是其他类型的表达式，因为方法需要位置来保存返回值。  
③和引用参数类似，输出参数的形参充当实参的别名，形参和实参都是同一块内存位置的名称。

与引用参数不同，输出参数有以下要求：  
①在方法内部，给输出参数赋值之后才能读取它；即参数的初始值是无关的，而且没必要在方法调用之前为实参赋值。  
②在方法内部，在方法返回之前，代码中每条可能的路径都必须给所有输出参数赋值。

因为方法内的代码在读取输出参数之前必须对其写入，所以不可能使用输出参数把数据传入方法；若方法中试图在方法给输出参数赋值之前读取它的值，编译器会产生一条错误消息。


``` C#
public void Add2( out int outValue )
{
    int var1 = outValue + 2; //出错，在赋值之前读取输出参数
}
```

使用输出参数的示例：

``` C#
class MyClass
{
    public int Val = 20;
}

class Program
{
    static void MyMethod(out MyClass f1, out int f2) //out修饰符
    {
        f1 = new MyClass(); //创建类变量
        f1.Val = 25; //赋值类字段
        f2 = 15; //赋值int参数
    }

    static void Main()
    {
        MyClass a1 = null;
        int a2;

        MyMethod(out a1, out a2); //调用方法，别忘了out修饰符
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/05/24xmMSKPvpBATVu.png" width = "65%" height = "65%" alt="图20 - 输出参数必须在方法内进行赋值"/>
</div>

①在方法调用之前，将要被用作实参的变量 a1 和 a2 已经在栈里了；  
②在方法的开始，形参的名称被设置为实参的别名。a1 和 a2 不再作用域之内，所以不能在 MyMethod 中访问；  
③在方法的内部，代码创建了一个 MyClass 类型的对象并赋值给 f1 ；然后给 f1 的字段和 f2 赋值。对 f1 和 f2 的赋值是必须的，因为是输出参数；  
④方法执行后，形参的名称失效，但引用类型的 a1 和值类型的 a2 都被方法内的行为改变了。

> 从 C# 7.0 之后，可以直接在方法调用时的参数列表中声明变量：  
> 原示例：
> 
> ``` C#
> static void Main()
> {
>     MyClass a1 = null; //声明将被用作输出参数的变量
>     int a2; //声明将被用作输出参数的变量
> 
>     MyMethod(out a1, out a2); //调用方法
> }
> ```
> 
> 新语法：
> 
> ``` C#
> static void Main()
> {
>     MyMethod( out MyClass a1, out int a2 ); //调用方法
> }
> ```

## 参数数组 Parameter Arrays
**参数数组**允许特定类型的零个或多个实参对应特定的形参：  
①在一个参数列表里只能有一个参数数组，且必须是列表中的最后一个；  
②由参数数组表示的所有参数必须是同一类型。

声明参数数组要在数据类型前使用 **params 修饰符**，在数据类型后放置一组**空的方括号**，空方括号指明了参数是一个整数数组。数组的细节在第13章。

下面是 int 型参数数组的声明语法：

``` C#
void ListInts( params int[] inVals ) //params为修饰符，int[]为int型参数数组，inVals为参数名称
```

### 方法调用
可以用2种方式为参数数组提供实参：  
①一个用逗号分隔的该数据类型元素的列表，所有元素必须是方法声明中指定的类型：  
`ListInts( 10, 20, 30 );`  
②一个该数据类型元素的一维数组：  
`int[] intArray = {1, 2, 3};`  
`ListInts( intArray );`

> 注意：调用不需要使用 params 修饰符，与上面的其他参数类型的模式不同。  
> 值参数的声明和调用都不带修饰符；  
> 引用参数和输出参数在两个地方都需要修饰符；  
> params 修饰符在声明中需要修饰符，在调用中不允许有修饰符。

*延伸式 Expanded Form*  
方法调用的第一种形式被称为延伸式，这种形式在调用中使用独立的实参；  

``` C#
void ListInts( params int[] inVals ) { ... } //方法声明
...

ListInts( ); //0个实参
ListInts( 1, 2, 3 ); //3个实参
ListInts( 4, 5, 6, 7 ); //4个实参
ListInts( 8, 9, 10, 11, 12 ); //5个实参
```

在使用一个为参数数组使用独立参数的调用时，编译器会  
①接受实参列表，用它们在堆中创建并初始化一个数组；  
②把数组的引用保存在栈的形参里；  
③如果在对应形参数组的位置没有实参，编译器会创建一个有零个元素的数组来使用。

示例如下：

``` C#
class MyClass
{
    public void ListInts( params int[] inVals ) //参数数组
    {
        if ( (inVals != null) && (inVals.Length != 0))
            for (int i = 0; i < inVals.Length; i++) //处理数组
            {
                inVals[i] = inVals[i] * 10;
                Console.WriteLine($"{ inVals[i] }");
            }
    }
}

class Program
{
    static void Main()
    {
        int first = 5, second = 6, third = 7; //声明3个int
        MyClass mc = new MyClass();
        mc.ListInts( first, second, third ); //调用方法

        Console.WriteLine($"{ first }, { second }, { third }");
    }
}
```

输出结果如下：

``` console
50
60
70
5, 6, 7
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/05/9n5PU8ZbdIkQzMy.png" width = "65%" height = "65%" alt="图21 - 参数数组示例"/>
</div>

①在方法调用之前，3个实参已经在栈中；  
②在方法的开始，3个实参被用于初始化堆中的数组，并且数组的引用被赋值给了形参 inVals ；  
③在方法内部，代码首先检查以确认数组引用不是 null ，然后处理数组，把每个元素乘以10并保存回去；  
④方法执行之后，形参 inVals 失效。

### 将数组作为实参
也可以在方法调用之前创建并组装一个数组，把单一的数组变量作为实参传递。

``` C#
static void Main() {
    int[] myArr = new int[] { 5, 6, 7 }; //创建并初始化数组
    MyClass mc = new MyClass();
    mc.ListInts(myArr); //调用方法

    foreach (int x in myArr)
        Console.WriteLine($"{ x }");
}
```

输出结果如下：

``` console
50
60
70
50
60
70
```

## 参数类型总结

| 参数类型 | 修饰符 | 是否在声明时使用 | 是否在调用时使用 | 执行 |
| :---- | :---- | :---- | :---- | :---- |
| 值 | 无 | | | 系统把实参的值复制到形参 |
| 引用 | ref | 是 | 是 | 形参是实参的别名 |
| 输出 | out | 是 | 是 | 仅包含一个返回的值。形参是实参的别名 |
| 数组 | params | 是 | 否 | 允许传递可变数目的实参到方法 |

## ref 局部变量和 ref 返回
ref 关键字允许传递一个对象引用给方法调用，在调用上下文中，对对象的改动在方法返回后依然可见；  
**ref 返回**允许将一个引用发送到方法外，然后在调用上下文内使用这个引用；  
与 ref 返回相关的功能是**ref 局部变量**，允许一个变量是另一个变量的别名。

### ref 局部变量
可以使用该功能创建一个变量的别名，对任意一个变量的赋值都会反映到另一个变量上，因为引用的是相同的对象，即使是值类型。

创建别名的语法需要使用关键字 ref 两次：`ref int y = ref x;`

当 x 改变时，y 也会变，示例如下：

``` C#
class Program {
    static void Main() {
        int x = 2;
        ref int y = ref x;
        Console.WriteLine( $"x = {x}, y = {y}" );
        x = 5;
        Console.WriteLine( $"x = {x}, y = {y}" );
        y = 6;
        Console.WriteLine( $"x = {x}, y = {y}" );
    }
}
```

输出结果如下：

``` console
x = 2, y = 2
x = 5, y = 5
x = 6, y = 6
```

### ref 返回
ref 局部变量通常和 ref 返回功能一起使用。ref 返回功能提供了一种使方法返回变量引用而不是变量值的方法。也需要使用 ref 关键字2次：一次在方法的返回类型声明之前；另一次在 return 关键字之后。

示例如下，因为调用了修改 ref 局部变量的代码，所以类的字段值改变了：

``` C#
class Simple
{
    private int Score = 5;

    public ref int RefToValue() //ref 返回的方法
    {
        return ref Score; //ref 返回
    }

    public void Display()
    {
        Console.WriteLine( $"Value inside class object: {Score}" );
    }
}

class Program
{
    static void Main()
    {
        Simple s = new Simple();
        s.Display();
        ref int v1Outside = ref s.RefToValue(); //ref 局部变量

        v1Outside = 10; //在调用域外修改值
        s.Display(); //检查值是否已经改变
    }
}
```

输出结果如下：

``` console
Value inside class object: 5
Value inside class object: 10
```

另一个示例，Math.Max 能够返回两个值中较大的那个，若想返回较大值的变量的引用：

``` C#
using static System.Console;

class Program
{
    static ref int Max(ref int p1, ref int p2)
    {
        if ( p1 > p2 )
            return ref p1; //返回引用而不是值
        else
            return ref p2; //返回引用而不是值
    }

    static void Main()
    {
        int v1 = 10;
        int v2 = 20;
        WriteLine("Start");
        WriteLine($"v1: {v1}, v2: {v2}\n");

        ref int max = ref Max(ref v1, ref v2);
        WriteLine("After assignment");
        WriteLine($"max: {max}\n");

        max++;
        WriteLine("After increment");
        WriteLine($"max: {max}, v1: {v1}, v2: {v2}");
    }
}
```

输出结果如下：

``` console
Start
v1: 10, v2: 20

After assignment
max: 20

After increment
max: 21, v1: 10, v2: 21
```

这个功能有如下限制：  
①不能将返回类型是 void 的方法声明为 ref 返回方法；  
②ref return 表达式不能返回：空值、常量、枚举成员、类或结构体的属性、指向只读位置的指针；  
③ref 局部变量只能被赋值一次；  
④即使一个方法声明为 ref 返回方法，如果在调用中省略了 ref 关键字，则返回的是指，而不是指向值的内存位置的指针；  
⑤如果将 ref 局部变量作为常规的实际参数传递给其他方法，则该方法仅获取该变量的一个副本，尽管 ref 局部变量包含指向存储位置的指针，但是当以这种方法使用时，传递的是值而不是引用。

## 方法重载 Method Overloading
一个类中可以有多个同名方法，叫做**方法重载 method overloading**。使用相同名称的每个方法必须有一个和其他方法不同的**签名 signature** 。

> 和 python 的方法重载区分，继承中的叫方法覆写 method overriding 。

*返回类型不是签名的一部分，形参的名称也不是签名的一部分*：`long AddValues( int a, out int b) { ... }`的 AddValues( int a, out int b) 部分为签名，包括方法的名称、参数的数目、参数的数据类型和顺序、参数修饰符。

示例如下，下面4个方法都是方法名 AddValues 的重载：

``` C#
class A
{
    long AddValues( int a, int b) { return a + b; }
    long AddValues( int c, int d, int e) { return c + d + e; }
    long AddValues( float f, float g) { return (long)(f + g); }
    long AddValues( long h, long m) { return h + m; }
}
```

非法的方法重载的示例如下，它们具有相同的签名，因为方法名相同，参数的数目、类型和顺序也相同。编译器会生成一条错误讯息：

``` C#
class B
{
    long AddValues( long a, long b) { return a+b; }
    int AddValues( long c, long d) { return c+d; } //错误，相同的签名
}
```

## 命名参数 Named Parameters
上面用到的都是位置参数，可以使用**命名参数**在方法调用中显示指定参数名字，以任意顺序列出实参：`c.Calc ( c: 2, a: 4, b: 3);` 

在调用时，可以同时使用位置参数和命名参数，但所有**位置参数必须先列出**，示例如下：

``` C#
class MyClass {
    public int Calc( int a, int b, int c )
    { return ( a + b ) * c; }

    static void Main() {
        MyClass mc = new MyClass( );

        int r0 = mc.Calc( 4, 3, 2 ); //位置参数
        int r1 = mc.Calc( 4, b: 3, c: 2 ); //位置参数和命名参数
        int r2 = mc.Calc( 4, c: 2, b: 3 ); //顺序变换
        int r3 = mc.Calc( c: 2, b: 3, a: 4 ); //命名参数
        int r4 = mc.Calc( c: 2, b: 1 + 2, a: 3 + 1 ); //命名参数表达式

        Console.WriteLine($"{ r0 }, { r1 }, { r2 }, { r3 }, { r4 }");
    }
}
```

## 可选参数 Optional Parameters
**可选参数**需要在方法声明中提供**默认值**，示例如下：

``` C#
class MyClass
{
    public int Calc( int a, int b = 3 ) //可选参数和默认值
    {
        return a + b;
    }

    static void Main()
    {
        MyClass mc = new MyClass();
        int r0 = mc.Calc( 5, 6 ); //使用显示值
        int r1 = mc.Calc( 5 ); //b使用默认值
        Console.WriteLine($"{ r0 }, { r1 }");
    }
}
```

注意事项：  
①可选参数只能是值参数，不能是 ref 、 out 、 params 参数，且只要值类型的默认值在编译时可以确定，就可以使用值类型作为可选参数。只有在默认值是 null 的时候，引用类型才可以作为可选参数；  
②所有必填参数 required parameters 必须在可选参数声明之前声明；如果有 params 参数，必须在所有可选参数之后声明。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/06/HrlmvtKgde7EWZc.png" width = "60%" height = "60%" alt="图22 - 参数语法顺序"/>
</div>

## 栈帧 Stack Frames
局部变量和参数是位于栈上的，在调用方法时，内存从栈的顶部开始分配，保存和方法关联的数据项。这块内存叫做方法的**栈帧 stack frame** 。

栈帧包含的内存保存如下内容：  
①返回地址，即方法退出时继续执行的位置；  
②分配内存的参数，方法的值参数，或参数数组；  
③和方法调用有关的其他管理数据项。

在方法调用时，整个栈帧都会压入栈；在方法退出时，整个栈帧会从栈上弹出。弹出栈帧有时候叫做**栈展开 unwind the stack** 。

示例如下，Main 调用了 MethodA ，MethodA 又调用了 MethodB ，创建了3个栈帧。在方法退出时，栈展开：

``` C#
class Program
{
    static void MethodA( int par1, int par2)
    {
        Console.WriteLine($"Enter MethodA: { par1 }, { par2 }");
        MethodB(11, 18); //调用MethodB
        Console.WriteLine("Exit MethodA");
    }

    static void MethodB(int par1, int par2)
    {
        Console.WriteLine($"Enter MethodB: { par1 }, { par2 }");
        Console.WriteLine("Exit MethodB");
    }

    static void Main( )
    {
        Console.WriteLine("Enter Main");
        MethodA( 15, 30); //调用MethodA
        Console.WriteLine("Exit Main");
    }
}
```

输出结果如下：

``` console
Enter Main
Enter MethodA: 15, 30
Enter MethodB: 11, 18
Exit MethodB
Exit MethodA
Exit Main
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/06/dPNMrXqxDuSelB7.png" width = "60%" height = "60%" alt="图23 - 一个简单程序中的栈帧"/>
</div>

## 递归 Recursion
**递归**：方法调用自身。递归每次方法调用都把新的栈帧压入栈顶，随着递归越来越深，栈也越来越大：

``` C#
class Program
{
    public void Count(int inVal)
    {
        if (inVal == 0)
            return;
        Count(inVal - 1); //调用自身

        Console.WriteLine($"{ inVal }");
    }

    static void Main()
    {
        Program pr = new Program();
        pr.Count(3);
    }
}
```

输出结果如下：

``` console
1
2
3
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/06/bhVKIcY2DPuT4qF.png" width = "65%" height = "65%" alt="图24 - 用递归的方法构建和展开栈的示例"/>
</div>


# 第七章 深入理解类
## 类成员

| 数据成员（保存数据） | 函数成员（执行代码） |
| :---- | :---- |
| 字段 Fields <br> 常量 Constants | 方法 Methods&emsp; &emsp;运算符 Operators <br> 属性 Properties &emsp; &emsp;索引 Indexers <br> 构造函数 Constructors &emsp; &emsp;事件 Events <br> 析构函数 Destructors |

## 成员修饰符的顺序
类成员声明语句由下列部分组成：**核心声明**、一组可选的**修饰符 modifiers** 和一组可选的**特性 attributes** 。语法如下，方括号内的成分是可选的：  
`[特性] [修饰符] 核心声明`

①修饰符：若有多个修饰符，可以任意顺序排列。
②特性：若有多个特性，可以任意顺序排列。在第25章介绍特性。

比如以下代码在语义上是等价的（public 和 static 都是修饰符，返回类型是核心声明的一部分）：  
`public static int MaxVal;`  
`static public int MaxVal;`

## 实例类成员 Instance Class Members
类成员可以关联到类的一个实例，也可以关联到整个类。类的每个实例都拥有自己的各自类成员的副本，称为**实例成员**。改变一个实例字段的值，不会影响其他实例成员的值。

``` C#
class D
{
    public int Mem1;
}

class Program
{
    static void Main()
    {
        D d1 = new D();
        D d2 = new D();
        d1.Mem1 = 10; d2.Mem1 = 28;

        Console.WriteLine($"d1 = { d1.Mem1 }, d2 = { d2.Mem1 }");
    }
}
```

运行结果如下：

``` console
d1 = 10, d2 = 28
```

## 静态字段 Static Fields
以上都是实例字段，类还可以拥有**静态字段**。静态字段被类的所有实例**共享**，所有实例都访问同一内存位置。使用 **static 修饰符**将字段声明为静态： 

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/vjSrekiyVHofd6z.png" width = "80%" height = "80%" alt="图25 - 静态和非静态数据成员"/>
</div>

## 从类的外部访问静态成员
**点运算符**由实例名、点和成员名组成。就像实例成员，静态成员也可以使用点运算符从外部访问，因为没有实例，所以使用*类名*来访问静态成员：`D.Mem2 = 5;`

访问静态成员的另一种方法不需要前缀，而是使用 using static 声明：

``` C#
using static System.Console; // includes, amongst other members, Writeline()
using static System.Math; // includes, amongst other members, Sqrt()
...
WriteLine($"The square root of 16 is { Sqrt(16) }" );
```

等价于：

``` C#
using System;
...
Console.WriteLine($"The square root of 16 is { Math.Sqrt(16) }");
```

第22章详细介绍 using static 声明结构体。

### 静态字段示例：

``` C#
class D
{
    int Mem1;
    static int Mem2;

    public void SetVars(int v1, int v2) //设置值
    {   Mem1 = v1; Mem2 = v2;   }

    public void Display( string str )
    {   Console.WriteLine("{0}: Mem1= {1}, Mem2= {2}", str, Mem1, Mem2);   }
}

class Program {
    static void Main()
    {
        D d1 = new D(), d2 = new D(); //创建2个实例

        d1.SetVars(2, 4); //设置d1的值
        d1.Display("d1");

        d2.SetVars(15, 17); //设置d2的值
        d2.Display("d2");
    
        d1.Display("d1"); //注意，这时Mem2静态成员的值已改变
    }
}
```

运行结果如下：

``` console
d1: Mem1= 2, Mem2= 4
d2: Mem1= 15, Mem2= 17
d1: Mem1= 2, Mem2= 17
```

### 静态成员的生存期
即使类没有实例，也存在静态成员，并且可以访问。

## 静态函数成员 Static Function Members
如同静态字段，静态函数成员独立于任何类实例，没有实例也可以调用静态方法；*静态函数成员不能访问实例成员，但能访问其他静态成员*。

``` C#
class X
{
    static public int A; //静态字段
    static public void PrintValA() //静态方法
    {
        Console.WriteLine("Value of A: {0}", A); //访问静态字段
    }
}
```

## 其他静态类成员类型
可声明为 static 的类成员前面有勾号：

| 数据成员（保存数据） | 函数成员（执行代码） |
| :---- | :---- |
| √ 字段 Fields <br> √ 类型 Types <br> 常量 Constants | √ 方法 Methods <br> √ 运算符 Operators <br> √ 属性 Properties <br> 索引 Indexers <br> √ 构造函数 Constructors <br> √ 事件 Events |

## 成员常量 Member Constants
区分局部常量和成员常量，成员常量声明在类声明中而不是方法内：

``` C#
class MyClass
{
    const int IntVal1 = 100;
    const int IntVal2 = 2 * IntVal1; //用于初始化成员常量的值在编译时必须是可计算的
}
```

> C# 没有全局常量，常量必须声明在类型中，与 C 和 C++ 不同。

## 常量和静态量 Constants Are Like Statics
常量非常像静态值，没有类的实例也可以使用，但常量没有自己的存储位置，而是在编译时被编译器替换。这种方式类似于 C 和 C++ 的 #define 值。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/7YgDBGnX5zWKS9I.png" width = "75%" height = "75%" alt="图26 - 常量字段变现得像静态字段，但是在内存中没有存储位置"/>
</div>

不能将常量声明为 static ：`static const double PI = 3.14; //错误`

## 属性 Properties
**属性**是代表类实例或类中数据项的成员。使用属性如同写入和读取字段，语法相同。  

与字段不同，属性是一个函数成员：  
①它不一定为数据存储分配内存；  
②它执行代码

**属性 Properties** 是一个包含2个相关方法的被命名为**访问器 accessors** 的组合：  
① **set** 访问器为属性赋值；  
② **get** 访问器从属性获取值。

如下图，注意 - 访问器从后面伸出，因为它们不能直接被调用：

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/4AuSJHGaxwBvhP6.png" width = "60%" height = "60%" alt="图27 - int 类型的、名称为 MyValue 的属性示例"/>
</div>

### 属性声明和访问器
**set** 访问器总是：  
①拥有一个单独的、隐式的值参，名称为 value，与属性的类型相同；  
②拥有一个返回类型 void 。

**get** 访问器总是：  
①没有参数；  
②拥有一个与属性类型相同的返回类型。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/jwPlrzJe3Zs1tfk.png" width = "65%" height = "65%" alt="图28 - 属性声明的语法与结构"/>
</div>

set 访问器中的隐式参数 value 和其他值参一样，可以用它发送数据到方法体或访问器块。  

访问器其他要点如下：  
1、get 访问器和所有执行路径*必须包含一个 return 语句*，返回一个属性类型的值。  
2、访问器 set 和 get 可以以任何顺序声明，并且，除了这两个访问器外，属性不允许有其他方法。

### 属性示例
属性本身没有任何存储，在下面的情况下，使用名为 TheRealValue 的字段作为存储：

``` C#
class C1
{
    private int theRealValue; //字段：分配内存

    public int MyValue //属性：未分配内存
    {
        set { theRealValue = value; }
        get { return theRealValue; }
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/8VH1CPpoYmv5RUd.png" width = "35%" height = "35%" alt="图29 - 属性访问器常常使用字段作为存储"/>
</div>

### 使用属性
写入和读取属性时，访问器会被隐式得调用：  
`MyValue = 5; //赋值：隐式地调用 set 方法`  
`z = MyValue; //表达式：隐式地调用 get 方法`

注意：不能显示地调用访问器，会产生编译错误。

### 属性和关联字段 Properties and Associated Fields
一种常见的方式是在类中将字段声明为 private 以封装该字段，并声明一个 public 属性来控制从类外部对该字段的访问。和属性关联的字段被称为**后备字段 backing field **或**后备存储 backing store**。

以下示例使用公有属性 MyValue 来控制对私有字段 theRealValue 的访问：

``` C#
class C1
{
    private int theRealValue = 10; //后备字段：分配内存

    public int MyValue //属性：不分配内存
    {
        set{ theRealValue = value; } //设置字段值
        get{ return theRealValue; } //获取字段值
    }
}

class Program
{
    static void Main()
    {
        C1 c = new C1();
        Console.WriteLine("MyValue: {0}", c.MyValue); //把属性看作字段，从中读取它的值

        c.MyValue = 20; //使用赋值语句设置属性的值
        Console.WriteLine("MyValue: {0}", c.MyValue);
    }
}
```

### 执行其他计算
访问器 get 和 set 能执行任何计算，下面若输入值大于100，就将 theRealValue 设置为100：

``` C#
int theRealValue = 10; //字段
int MyValue //属性
{
    set { theRealValue = value > 100 ? 100 : value; } //条件运算符，见第9章
    get { return theRealValue; }
}
```

C# 7.0 为属性的 getter/setter 引入了使用**表达函数体**的语法，见第14章。这种语法只有在访问函数体由一个表达式组成的时候才能使用：

``` C#
int MyValue
{
    set => value > 100 ? 100 : value;
    get => theRealValue;
}
```

### 只读和只写属性 Read-Only and Write-Only Properties
只有 get 访问器的属性称为**只读属性**；只有 set 访问器的属性称为**只写属性**。

两个访问器中至少有一个必须被定义，否则编译器会产生一条错误信息。

### 属性与公有字段
根据实践，属性比公有字段更好：  
①属性是函数成员不是数据成员，允许处理输入和输出；  
②属性可以只读和只写，而字段不行；  
③编译后的变量和编译后的属性语义不同。

### 计算只读属性示例
在大多示例中，属性都和一个后备字段关联，并且 get 和 set 访问器引用该字段。但是属性不是必须和字段关联：

``` C#
class RightTriangle
{
    public double A = 3;
    public double B = 4;
    public double Hypotenuse //只读属性
    {
        get{ return Math.Sqrt((A*A)+(B*B)); } 
    }
}

class Program
{
    static void Main()
    {
        RightTriangle c = new RightTriangle();
        Console.WriteLine($"Hypotenuse: { c.Hypotenuse }");
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/15/JfszWaUQgRqPrt5.png" width = "35%" height = "35%" alt="图30 - 只读属性 Hypotenuse"/>
</div>

### 自动实现属性
因为属性经常被关联到后备字段，所以 C# 提供了**自动实现属性**（automatically implemented property 或 auto-implemented property，简称为**自动属性 auto-property**），允许只声明属性而不声明后备字段。编译器会自动创建隐藏的后备字段，并且自动挂接到 get 和 set 访问器上。

自动实现属性要点：  
①不声明后备字段：编译器根据属性的类型分配存储；  
②不能提供访问器的方法体：声明为分号。

``` C#
class C1
{
    public int MyValue //分配内存，没有声明后备字段
    {
        set; get; //访问器的方法体被声明为分号
    }
}

class Program
{
    static void Main()
    {
        C1 c = new C1();
        Console.WriteLine("MyValue: {0}", c.MyValue);

        c.MyValue = 20;
        Console.WriteLine("MyValue: {0}", c.MyValue);
    }
}
```

运行结果如下：

``` console
MyValue: 0
MyValue: 20
```

### 静态属性
属性也可以被声明为 static ，示例如下：

``` C#
using System;
using static ConsoleTestApp.Trivial;
namespace ConsoleTestApp
{
    class Trivial {
        public static int MyValue { get; set; }
        public void PrintValue()
        { Console.WriteLine("Value from inside: {0}", MyValue); } //从类内部访问MyValue
    }

    class Program {
        static void Main() {
            Console.WriteLine("Init Value: {0}", Trivial.MyValue); //从类外部访问MyValue
            Trivial.MyValue = 10;
            Console.WriteLine("New Value : {0}", Trivial.MyValue); //从类外部访问MyValue

            MyValue = 20; //从类外部访问，但因为using static，所以可以省略类名
            Console.WriteLine($"New Value : { MyValue }");
            Trivial tr = new Trivial();
            tr.PrintValue();
        }
    }
}
```

运行结果如下：

``` console
Init Value: 0
New Value : 10
New Value : 20
Value from inside: 20
```

## 实例构造函数 Instance Constructors
**实例构造函数**是一个特殊的方法，它在创建类的每个新实例时执行。构造函数用于初始化类实例的状态；如果要从类的外部创建类的实例，需要将构造函数声明为 public 。

构造函数的名称和类名相同；构造函数不能有返回值。

``` C#
class MyClass
{
    public MyClass() //声明为public，没有返回类型，和类名相同
    {
        ···
    }
    ...
}
```

### 带参数的构造函数
构造函数可以带参数，也可以被重载，和方法类似。

在使用创建对象表达式创建类的新实例时，要使用 new 运算符，后面跟着类的构造函数，new 运算符使用该构造函数创建类的实例：

``` C#
class Class1
{
    int Id;
    string Name;

    public Class1()            { Id=28; Name="Nemo";  } //构造函数0
    public Class1(int val)     { Id=val; Name="Nemo"; } //构造函数1
    public Class1(String name) { Name=name;           } //构造函数2

    public void SoundOff()
    { Console.WriteLine($"Name { Name }, Id { Id }"); }
}

class Program
{
    static void Main()
    {
        Class1 a = new Class1(), //调用构造函数0
               b = new Class1(7), //调用构造函数1
               c = new Class1("Bill"); //调用构造函数2

        a.SoundOff();
        b.SoundOff();
        c.SoundOff();
    }
}
```

运行结果如下：

``` console
Name Nemo, Id 28
Name Nemo, Id 7
Name Bill, Id 0
```

### 默认构造函数
如果在类中没有显示地提供实例构造函数，那么编译器会提供一个隐式的默认构造函数，它没有参数，方法体为空。若为类声明了构造函数，那么编译器将不会为该类定义默认构造函数。

如果声明了带参数的构造函数，那么试图使用不带参数的构造函数创建新的实例时，编译器会产生一条错误消息，因为没有无参数的构造函数。

## 静态构造函数
实例构造函数初始化类的每个新实例，而**静态构造函数**初始化类级别的项，通常，静态构造函数初始化类的静态字段。

静态构造函数的特点：  
①类只能有一个静态构造函数，而且不能带参数；  
②静态构造函数不能有访问修饰符（static 关键字不是访问修饰符）；  
③类即可以有静态构造函数也可以有实例构造函数；  
④如同静态方法，静态构造函数不能访问所在类的实例成员，因此不能使用 this 访问器；  
⑤不能从程序中显示地调用静态构造函数，系统会自动调用它们：在类的任意实例被创建之前，在类的任意静态成员被引用之前。

示例如下，Random 是 BCL 提供的用于产生随机数的类，位于 System 命名空间中：

``` C#
class RandomNumberClass
{
    private static Random RandomKey; //私有静态字段

    static RandomNumberClass() //静态构造函数
    {
        RandomKey = new Random(); //初始化RandomKey
    }

    public int GetRandomNumber()
    {
        return RandomKey.Next();
    }
}

class Program
{
    static void Main()
    {
        RandomNumberClass a = new RandomNumberClass();
        RandomNumberClass b = new RandomNumberClass();
        Console.WriteLine("Next Random #: {0}", a.GetRandomNumber());
        Console.WriteLine($"Next Random #: { b.GetRandomNumber() }");
    }
}
```

## 对象初始化语句 Object Initializers
**对象创建表达式**由关键字 new 和类构造函数加参数列表组成。  
**对象初始化语句**扩展了创建语法，在表达式尾部加上一组成员初始化语句，利用对象初始化语句，可以在创建新的对象实例时，设置字段和属性的值。

该语法有两种形式：  
①包括构造函数的参数列表：`new TypeName(ArgList) { FieldOrProp = InitExpr, FieldOrProp = InitExpr, ...}`；  
②不包括构造函数的参数列表：`new TypeName { FieldOrProp = InitExpr, FieldOrProp = InitExpr, ...}`；

``` C#
public class Point
{
    public int X = 1;
    public int Y = 2;
}

class Program
{
    static void Main( )
    {
        Point pt1 = new Point();
        Point pt2 = new Point { X = 5, Y = 6 };
        Console.WriteLine("pt1: {0}, {1}", pt1.X, pt1.Y);
        Console.WriteLine($"pt2: { pt2.X }, { pt2.Y }");
    }
}
```

运行结果如下：

``` console
pt1: 1, 2
pt2: 5, 6
```

## 析构函数 Destructors
**析构函数**执行在类的实例被销毁之前需要的清理或释放非托管资源的行为。非托管资源 Unmanaged resources 是指通过 Win32 API 获得的文件句柄 file handles ，或非托管内存块。详见第27章。

## readonly 修饰符
**readonly 修饰符**类似于将字段声明为 const，一旦值设置了就不能改变：  
① const 字段只能在字段的声明语句中初始化，而 readonly 字段可以在下列任意位置设置它的值：  
&ensp;&ensp;- 字段声明语句，类似于 const ；  
&ensp;&ensp;- 类的任何构造函数。如果是 static 字段，初始化必须在静态构造函数中完成。  
② const 字段的值必须可在编译时决定，而 readonly 字段的值可以在运行时决定。
③ const 的行为总是静态的，而对于 readonly 字段可以是实例字段，也可以是静态字段，并且在内存中有存储位置。

``` C#
class Shape
{
    readonly double PI = 3.1416; //初始化
    readonly int NumberOfSides; //未初始化

    public Shape(double side1, double side2) //构造函数
    {
        NumberOfSides = 4; //在构造函数中设定
        ···
    }

    public Shape(double side1, double side2, double side3) { 
        NumberOfSides = 3; //在构造函数中设定
        ···
    }
}
```

## this 关键字
**this 关键字**在类中是对当前实例的引用，只能被用在实例构造函数、实例方法、属性和索引器的实例访问器。

因为静态成员不是实例的一部分，所以不能在任何静态函数成员的代码中使用 this 关键字。this 主要用于区分类成员和局部变量或参数，以及作为调用方法的实参。

``` C#
class MyClass
{
    int Var1 = 10;

    public int ReturnMaxSum(int Var1) //参数
    { Parameter Field
        return Var1 > this.Var1
                    ? Var1 //参数
                    : this.Var1; //字段
    }
}

class Program
{
    static void Main()
    {
        MyClass mc = new MyClass();

        Console.WriteLine($"Max: { mc.ReturnMaxSum(30) }");
        Console.WriteLine($"Max: { mc.ReturnMaxSum(5) }");
    }
}
```

虽然理解 this 关键字很重要，但是很少在代码中使用。

## 索引器 Indexers
**索引器**允许用索引访问类字段。

### 什么是索引器
**索引器**是一组 get 和 set 访问器，与属性类似：

<div  align="center">  
<img src="https://s2.loli.net/2022/12/16/aEWC8UMjmXOGA6i.png" width = "60%" height = "60%" alt="图31 - 索引器的表现形式"/>
</div>

### 索引器和属性
①和属性一样，索引器不用分配内存来存储；  
②索引器和属性都主要用来访问其他数据成员，与这些成员关联，并为它们提供获取和设置访问：
&ensp;&ensp;- 属性表示单个数据成员；  
&ensp;&ensp;- 索引器表示多个数据成员。

> 可以认为**索引器**是为类的多个数据成员提供 get 和 set 访问的**属性**。

但索引器总是实例成员，因此不能被声明为 static 。

### 声明索引器
声明索引器语法如下：  
①索引器没有名称，在名称的位置是关键字 this ；  
②参数列表在**方括号**内；  
③参数列表必须至少声明一个参数。

``` C#
ReturnType this [ Type param1, ... ]
{
    get
    {
        ...
    }

    set
    {
        ...
    }
}
```

### 索引器的 set 访问器
当索引器被用于赋值，set 访问器被调用，并接受2种数据：  
①一个名为 value 的隐式参数，其中持有要保存的数据；  
②索引参数，表示数据应该保存在哪里。  
`emp[0] = "Doe";`

set 访问器的语法和含义如下图：

<div  align="center">  
<img src="https://s2.loli.net/2022/12/16/lUVajeY5kGuXJ8W.png" width = "70%" height = "70%" alt="图32 - set 访问器的语法和含义"/>
</div>

左边是访问器声明的实际语法，右边展示了 set 访问器有如下语义：  
①它的返回类型为 void ；  
②它使用的参数列表和索引器声明中的相同；  
③它有一个名为 value 的隐式参数，值参类型与索引器类型相同。

### 索引器的 get 访问器
当使用索引器获取值时，可以通过索引参数调用 get 访问器：`string s = emp[0];`

get 访问器方法体内的代码必须检查索引参数，来确定它表示的是哪个字段，并返回该字段的值，语法和含义如下：

<div  align="center">  
<img src="https://s2.loli.net/2022/12/16/T4EuXyLAjODoW3h.png" width = "70%" height = "70%" alt="图33 - get 访问器的语法和含义"/>
</div>

①get 访问器的参数列表和索引器声明中的相同；  
②get 访问器返回与索引器类型相同的值。  

### 关于索引器的更多内容
和属性一样，不能显示地调用 get 和 set 访问器：  
`emp[0] = "Doe"; \\自动调用 set 访问器`  
`string NewName = emp[0]; \\自动调用 get 访问器`

### 为类声明索引器示例
①下面的索引器需要读取 string 类型的值，所以索引器的类型要和字段一致，且索引器要声明为 public ，以便从类外部访问；  
②若索引为整数，方括号内的 index 的形参需为 int 型。

``` C#
class Employee {
    public string LastName; //调用字段0
    public string FirstName; //调用字段1
    public string CityOfBirth; //调用字段2

    public string this[int index] //索引器声明
    {
        set //set访问器声明
        {
            switch (index) {
                case 0: LastName = value;
                    break;
                case 1: FirstName = value;
                    break;
                case 2: CityOfBirth = value;
                    break;

                default: //异常，见第23章
                    throw new ArgumentOutOfRangeException("index");
            }
        }

        get //get访问器声明
        {
            switch (index) {
                case 0: return LastName;
                case 1: return FirstName;
                case 2: return CityOfBirth;

                default: //异常，见第23章
                    throw new ArgumentOutOfRangeException("index");
            }
        }
    }
}
```

### 另一个索引器示例

``` C#
class Class1
{
    int Temp0; //私有字段
    int Temp1; //私有字段

    public int this [ int index ] //索引器
    {
        get
        {
            return ( 0 == index ) //返回Temp0或Temo1的值
                        ? Temp0
                        : Temp1;
        }

        set
        {
            if( 0 == index )
                Temp0 = value; //隐式变量value
            else
                Temp1 = value; //隐式变量value
        }
    }
}

class Example
{
    static void Main()
    {
        Class1 a = new Class1();

        Console.WriteLine("Values -- T0: {0}, T1: {1}", a[0], a[1]);
        a[0] = 15;
        a[1] = 20;
        Console.WriteLine($"Values -- T0: { a[0] }, T1: { a[1] }");
    }
}
```

运行结果如下：

``` console
Values -- T0: 0, T1: 0
Values -- T0: 15, T1: 20
```

### 索引器重载
只要索引器的参数列表不同，类就可以有任意多个索引器，类型不同不行。

## 访问器的访问修饰符
默认情况下，属性或索引器这两种函数成员的两个访问器（ get 和 set ）的访问级别与成员相同。即属性的访问级别是 public ，两个访问器的访问级别也是 public 。但是可以为两个访问器分配不同的访问级别。

如下代码展示了非常常见重要的示例，将 set 访问器声明为 private ，将 get 访问器声明为 public 。get 之所以是 public ，是因为属性的访问级别是 public 。这样尽管可以从类的外部读取属性，但只能从类内部设置它（该示例在构造函数内设置），是一个非常重要的封装工具：

``` C#
class Person
{
    public string Name { get; private set; } //不同访问级别的访问器
    public Person( string name ) { Name = name; }
}

class Program
{
    static public void Main( )
    {
        Person p = new Person( "Capt. Ernest Evans" );
        Console.WriteLine( $"Person's name is { p.Name }");
    }
}
```

运行结果如下：

``` console
Person's name is Capt. Ernest Evans
```

访问器的访问修饰符有几个限制：  
①仅当成员既有 get 访问器也有 set 访问器时，其访问器才能有访问修饰符；  
②虽然两个访问器都必须出现，但是只有一个能有访问修饰符；  
③访问器的访问修饰符的限制必须比成员的访问级别更严格：比如若属性的访问级别是 protected ，则唯一能对访问器使用的是 private 。

## 分部类和分部类型 Partial Classes and Partial Types
类的声明可以分割为几个分部类的声明，类的分部类声明可以在不同文件里。每个分部类声明要标注为 partial class，比普通类增加了**类型修饰符 partial** 。

> 类型修饰符 partial 不是关键字，所以在其他上下文中，可以被用作标识符。但是在关键字 class、struct 或 interface 之前时，表示分部类型。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/16/NzhGewJvAR1kYb2.png" width = "70%" height = "70%" alt="图34 - 使用分部类型来分割类"/>
</div>

组成类的所有分部类声明必须在一起编译；除了分部类还有2种分部类型，分部结构（第11章）和分部接口（第16章）

## 分部方法 Partial Methods
分部方法是声明在分部类中不同部分的方法，分部方法的不同部分可以声明在分部类的不同部分中。

分部方法的两个部分如下：  
①定义分部方法声明：给出签名和返回类型，声明的实现部分只是一个分号；  
②实现分部方法声明：给出签名和返回类型，以普通语句块形式实现。

定义声明和实现声明的签名和返回类型必须匹配：  
&ensp;&ensp;- 返回类型必须是 void ；  
&ensp;&ensp;- 签名不能包括访问修饰符，这使分部方法是隐式的 private ；  
&ensp;&ensp;- 参数列表不能包括 out 参数；  
&ensp;&ensp;- 定义和实现声明中都必须包含上下文关键字 partial ，并且直接在关键字 void 之前。

可以有定义部分而没有实现部分，此时编译器会把方法的声明和方法内部对方法的调用移除。

``` C#
partial class MyClass
{
    partial void PrintSum(int x, int y); //定义分部方法，注意分号，没有实现部分

    public void Add(int x, int y) //因为分部方法是隐式私有，PrintSum不能从类外部调用，所以用公有方法Add调用PrintSum
    {
        PrintSum(x, y);
    }
}

partial class MyClass
{
    partial void PrintSum(int x, int y) //实现分部方法
    {
        Console.WriteLine("Sum is {0}", x + y); //实现部分
    }
}

class Program
{
    static void Main( )
    {
    var mc = new MyClass();
    mc.Add(5, 6);
    }
}
```

运行结果如下：

``` console
Sum is 11
```


# 第八章 类和继承
## 类继承 Class Inheritance
通过**继承**定义一个新类，使用一个已存在的类作为新类的基础。已存在的类称为**基类 base class**，新类称为**派生类 derived class**。

要声明一个派生类，需要在类名后加上**基类规格说明 class-base specification**。  
①基类规格说明由冒号和用作基类的类名称组成：`class OtherClass : SomeClass`  
②派生类成员包括本身声明中的成员以及基类的成员；  
③派生类 *不能删除* 它所继承的任何成员。

## 访问继承的成员
继承的成员可以被访问，就像它们是派生类自己声明的一样（构造函数特殊，见本章后面）

``` C#
class SomeClass //基类
{
    public string Field1 = "base class field ";
    public void Method1( string value ) {
        Console.WriteLine($"Base class -- Method1: { value }");
    }
}

class OtherClass: SomeClass { //派生类
    public string Field2 = "derived class field";
    public void Method2( string value ) {
        Console.WriteLine($"Derived class -- Method2: { value }");
    }
}

class Program {
    static void Main() {
        OtherClass oc = new OtherClass();

        oc.Method1( oc.Field1 ); //以基类字段为参数的基类方法
        oc.Method1( oc.Field2 ); //以派生类字段为参数的基类方法
        oc.Method2( oc.Field1 ); //以基类字段为参数的派生类方法
        oc.Method2( oc.Field2 ); //以派生类字段为参数的派生类方法
    }
}
```

运行结果如下：

``` console
Base class -- Method1: base class field 
Base class -- Method1: derived class field
Derived class -- Method2: base class field
Derived class -- Method2: derived class field
```

## 所有类都派生自 object 类
所有类都是派生类，**类 object** 是唯一的非派生类，它是所有继承层次的基础。没有基类规格说明的类隐式地直接派生自类 object。类声明显式地派生自 object 类和隐式地派生自 object 类在语义上是等价的。

一个类声明的基类规格说明中只能有一个单独的类，称为**单继承 single inheritance**。

## 屏蔽基类的成员
虽然派生类不能删除它继承的任何成员，但可以用与基类成员名称相同的成员来屏蔽 mask 基类成员。  
①要屏蔽一个继承的数据成员，需要声明一个新的相同类型的成员，并使用相同的名称；  
②要屏蔽一个继承的函数成员，需要声明一个新的带有相同签名的函数成员，签名包括名称和参数列表，不包括返回类型；  
③最好使用 new 修饰符，虽然没有该修饰符，程序可以成功编译，但编译器会警告你隐藏了一个继承的成员；  
④可以屏蔽静态成员。

``` C#
class SomeClass //基类
{
    public string Field1 = "SomeClass Field1";
    public void Method1(string value)
        { Console.WriteLine($"SomeClass.Method1: { value }"); }
}

class OtherClass : SomeClass //派生类
{
    new public string Field1 = "OtherClass Field1"; //屏蔽基类成员
    new public void Method1(string value) //屏蔽基类成员
        { Console.WriteLine($"OtherClass.Method1: { value }"); }
}

class Program
{
    static void Main()
    {
        OtherClass oc = new OtherClass(); //使用屏蔽成员
        oc.Method1(oc.Field1); //使用屏蔽成员
    }
}
```

运行结果如下：

``` console
OtherClass.Method1: OtherClass Field1
```

## 基类访问 Base Access
如果派生类必须访问被隐藏的继承成员，可以使用**基类访问 base access** 表达式，由**关键字 base** 和点加上成员的名称组成：`Console.WriteLine("{0}", base.Field1);`

``` C#
class SomeClass { //基类
    public string Field1 = "Field1 -- In the base class";
}

class OtherClass : SomeClass { //派生类
    new public string Field1= "Field1 -- In the derived class";

    public void PrintField1()
    {
        Console.WriteLine(Field1); //访问派生类
        Console.WriteLine(base.Field1); //访问基类
    }
}

class Program {
    static void Main()
    {
        OtherClass oc = new OtherClass();
        oc.PrintField1();
    }
}
```

运行结果如下：

``` console
Field1 -- In the derived class
Field1 -- In the base class
```

## 使用基类的引用
派生类的实例由基类的实例和派生类新增的成员组成，派生类的引用指向整个类对象，包括基类部分。

如果有一个派生类对象的引用，就可以获取该对象基类部分的引用（使用**类型转换运算符 cast operator** 把引用转换 cast 为基类类型，详见第17章）。类型转换运算符放置在对象引用的前面，由圆括号括起的要被转换成的类名组成。将派生类对象强制转换为基类对象的作用是产生的变量只能访问基类的成员（在被覆写方法中除外，见本章后面）。

``` C#
MyDerivedClass derived = new MyDerivedClass(); //创建一个对象
MyBaseClass mybc = (MyBaseClass) derived; //转换引用
```

①第一行声明并初始化了变量 derived，它包含一个 MyDerivedClass 类型对象的引用；  
②第二行声明了一个基类类型 MyBaseClass 的变量，并把 derived 中的引用转换为该类型，给出对象的基类部分的引用。  

<div  align="center">  
<img src="https://s2.loli.net/2022/12/20/qvf8azxGJnpZkAi.png" width = "70%" height = "70%" alt="图35 - 派生类的引用可以看到完整的 MyDerivedClass 对象，而 mybc 只能看到对象的 MyBaseClass 部分"/>
</div>

``` C#
class MyBaseClass
{
    public void Print()
    {
        Console.WriteLine("This is the base class.");
    }
}

class MyDerivedClass : MyBaseClass
{
    public int var1;

    new public void Print()
    {
        Console.WriteLine("This is the derived class.");
    }
}

class Program
{
    static void Main()
    {
        MyDerivedClass derived = new MyDerivedClass();
        MyBaseClass mybc = (MyBaseClass)derived; //转换为基类

        derived.Print(); //从派生类部分调用Print
        mybc.Print(); //从基类部分调用Print
        // mybc.var1 = 5; //错误：基类引用无法访问派生类成员
    }
}
```

运行结果如下：

``` console
This is the derived class.
This is the base class.
```

### 虚方法和覆写方法 Virtual and Override Methods
上面可以看到：当基类引用访问派生类对象时，得到的是基类成员。而**虚方法 virtual methods** 可以将基类引用升至派生方法内，需满足以下条件：  
①派生类的方法和基类的方法有相同的签名和返回类型；  
②基类方法使用 **virtual** 标注；  
③派生类方法使用 **override** 标注；  

``` C#
class MyBaseClass
{
    virtual public void Print() //virtual方法
    {
        Console.WriteLine("This is the base class.");
    }
}

class MyDerivedClass : MyBaseClass
{
    override public void Print() //override方法
    {
        Console.WriteLine("This is the derived class.");
    }
}

class Program
{
    static void Main()
    {
        MyDerivedClass derived = new MyDerivedClass();
        MyBaseClass mybc = (MyBaseClass)derived; //转换至基类

        derived.Print();
        mybc.Print();
    }
}
```

运行结果如下：

``` console
This is the derived class.
This is the derived class.
```

当使用基类引用 mybc 调用 Print 方法时，方法调用被传递到派生类并执行，因为基类的方法被标记为 virtual ，在派生类中有匹配的 override 方法。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/21/fwOFbVB5CY1axjo.png" width = "60%" height = "60%" alt="图36 - 虚方法和覆写方法"/>
</div>

其他说明：  
①覆写和被覆写的方法要具有相同的可访问性，即不能一个 private 另一个 public ；  
②不能覆写 static 方法或非虚方法；  
③方法、属性和索引器，以及事件都可以被声明为 virtual 和 override 。

### 覆写标记为 override 的方法
覆写方法允许在继承的任何层次出现：  
①当使用对象基类部分的引用调用一个被覆写的方法时，方法的调用被沿派生层次上溯执行，一直到标记为 override 的方法的**最高派生 most-derived** 版本；  
②没标记为 override 不会被调用。

下面示例分2种情况，以下为2种情况的共同部分：

``` C#
class MyBaseClass //基类
{
    virtual public void Print()
    { Console.WriteLine("This is the base class."); }
}

class MyDerivedClass : MyBaseClass //派生类
{
    override public void Print()
    { Console.WriteLine("This is the derived class."); }
}

class SecondDerived : MyDerivedClass //最高派生类
{
    ... //见后面
}
```

***情况1***：SecondDerived 的 Print 方法声明为 override ：

``` C#
class SecondDerived : MyDerivedClass
{
    override public void Print() {
        Console.WriteLine("This is the second derived class.");
    }
}

class Program
{
    static void Main()
    {
        SecondDerived derived = new SecondDerived(); //使用SecondDerived
        MyBaseClass mybc = (MyBaseClass)derived; //使用MyBaseClass

        derived.Print();
        mybc.Print();
    }
}
```

运行结果如下：

``` console
This is the second derived class.
This is the second derived class.
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/21/BZcQVES3n2DleoR.png" width = "60%" height = "60%" alt="图37 - 执行被传递到多层覆写链的顶端"/>
</div>

***情况2***：SecondDerived 的 Print 方法声明为 new ：

``` C#
class SecondDerived : MyDerivedClass
{
    new public void Print()
    {
        Console.WriteLine("This is the second derived class.");
    }
}

class Program
{
    static void Main()
    {
        SecondDerived derived = new SecondDerived(); //使用SecondDerived
        MyBaseClass mybc = (MyBaseClass)derived; //使用MyBaseClass

        derived.Print();
        mybc.Print();
    }
}
```

运行结果如下：

``` console
This is the second derived class.
This is the derived class.
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/21/WIRHS71cFj9UQra.png" width = "60%" height = "60%" alt="图38 - 隐藏覆写的方法"/>
</div>

### 覆盖其他成员类型
在属性上使用 virtual / override 的示例：

``` C#
class MyBaseClass
{
    private int _myInt = 5;
    virtual public int MyProperty
    {
        get { return _myInt; }
    }
}

class MyDerivedClass : MyBaseClass
{
    private int _myInt = 10;
    override public int MyProperty
    {
        get { return _myInt; }
    }
}

class Program
{
    static void Main()
    {
    MyDerivedClass derived = new MyDerivedClass();
    MyBaseClass mybc = (MyBaseClass)derived;

    Console.WriteLine( derived.MyProperty );
    Console.WriteLine( mybc.MyProperty );
    }
}
```

运行结果如下：

``` console
10
10
```

## 构造函数的执行
派生类对象有一部分就是基类对象：要创建对象的基类部分，需要隐式调用基类的某个构造函数。继承层次链中的每个类在执行它自己的构造函数体之前执行它的基类构造函数。

创建一个实例的过程：*先初始化对象的所有实例成员，然后调用基类的构造函数，然后执行该类自己的构造函数体* 。

``` C#
class MyDerivedClass : MyBaseClass
{
    int MyField1 = 5; //1.成员初始化
    int MyField2; //成员初始化

    public MyDerivedClass() //3.执行构造函数体
    {
        ...
    }
}

class MyBaseClass
{
    public MyBaseClass() //2.调用基类构造函数
    {
        ...
    }
}
```

> 不建议在构造函数中调用虚方法，在执行基类的构造函数时，基类的虚方法会调用派生类的覆写方法，但是是在执行派生类的构造函数方法之前，因此调用会在派生类完全初始化之前传递到派生类。

### 构造函数初始化语句 Constructor Initializers
默认情况下，在构造对象时，将调用基类的无参数构造函数。但因为构造函数可以重载，所以基类可能有一个以上的构造函数，若需要指定基类构造函数，需要在**构造函数初始化语句**中指定它。

构造函数初始化语句有两种形式：  
①使用**关键字 base** 并指明使用哪一个基类构造函数：**构造函数初始化语句**由关键字 base 和要调用的基类构造函数的参数列表组成 - `public MyDerivedClass( int x, string s ) : base( s, x )`，基类参数列表中的参数必须在类型和顺序上与已定的基类构造方法的参数列表相匹配。当声明一个不带构造函数初始化语句的构造函数时，实际上是隐式调用 base( ) 构造函数初始化语句； 

②使用**关键字 this** 并指明使用当前类的哪一个构造函数：这种形式让构造过程（实际上是编译器）使用当前类中的其他构造函数。这种语法很有用的一个情形是：一个类有好几个构造函数，它们都需要在对象构造中执行一些公共代码，此时可以将公共代码提取出来作为一个构造函数，然后被其他所有的构造函数用作**构造函数初始化语句**。

``` C#
class MyClass
{
    readonly int firstVar;
    readonly double secondVar;
    public string UserName;
    public int UserIdNumber;

    private MyClass( ) //私有构造函数执行其他构造函数共用的初始化
    {
        firstVar = 20;
        secondVar = 30.5;
    }

    public MyClass( string firstName ) : this() //使用构造函数初始化语句
    {
        UserName = firstName;
        UserIdNumber = -1;
    }

    public MyClass( int idNumber ) : this( ) //使用构造函数初始化语句
    {
        UserName = "Anonymous";
        UserIdNumber = idNumber;
    }
}
```

### 类访问修饰符 Class Access Modifiers
类的**可访问性 accessibility**（可访问 accessible 也被称为 可见 visible）只有两个级别：**public** 和 **internal** 。

> 区分类的可访问性和成员的可访问性。

①标记为 public 的类可以被系统内任何程序集中的代码访问；  
②标记为 internal 的类只能被它自己所在的程序集内的类看到。这是默认的可访问级别，除非类声明中显式地指定修饰符 public，否则程序集外部的代码不能访问该类。

## 程序集间的继承
C# 允许从一个在不同的程序集内定义的基类来派生类，条件如下：  
①基类必须被声明为 public ；
②必须在 Visual Studio 工程中的 References 节点中添加对包含该基类的程序集的引用，若要不使用它们的完全限定名称 fully qualified names，可以在源文件放置一个 using 指令，加上要访问的类或类型所在的命名空间。

> 增加对其他程序集的引用和增加 using 指令是两回事。增加对其他程序集的引用是告诉编译器所需的类型在哪里定义；增加 using 指令允许你引用其他的类而不必使用它们的完全限定名称。详见第22章。

示例，以下代码来自两个不同的程序集：

``` C#
//源文件名称为Assembly1.cs
using System;

namespace BaseClassNS //包含基类声明的命名空间
{
    public class MyBaseClass { //声明为公有的，使它对程序集的外部可见
        public void PrintMe() {
            Console.WriteLine("I am MyBaseClass");
        }
    }
}


//源文件名称为Assembly2.cs
using System;
using BaseClassNS; //包含基类声明的命名空间

namespace UsesBaseClass
{
    class DerivedClass: MyBaseClass //在其他程序集中的基类
    {
        //空类体
    }

    class Program{
        static void Main( )
        {
            DerivedClass mdc = new DerivedClass();
            mdc.PrintMe();
        }
    }

}
```

## 成员访问修饰符
对类的可访问性，只有两种修饰符：internal 和 public。而**成员的可访问性**包括5个级别：**public** 、**private** 、**protected** 、**internal** 、**protected internal**。

①所有显式声明在类声明中的成员都是互相可见的，无论它们的访问性如何；  
②继承的成员不在类的声明中显式声明，所有继承的成员对派生类的成员可以是可见的，也可以是不可见的；  
③隐式访问级别为 private；  
④成员的可访问性受限于它的类，若类的可访问性是 internal，无论类成员的访问修饰符是什么，类成员在程序集的外部也不可见。

### 访问成员的区域
下面的类声明了5种访问级别的成员：

``` C#
public class MyClass
{
    public int Member1;
    private int Member2;
    protected int Member3;
    internal int Member4;
    protected internal int Member5;
    ...
```

另一个类能否访问这些成员取决于：另一个类是否派生自 MyClass 类；另一个类是否和 MyClass 类在同一个程序集。

以上2个特征可以划分出4个集合，如下图：

<div  align="center">  
<img src="https://s2.loli.net/2023/01/02/vWAestKFfy5VZPH.png" width = "65%" height = "65%" alt="图39 - 访问性的区域划分"/>
</div>

### 公有成员的可访问性
public 访问级别是限制最少的，所有类，包括程序集内部的类和外部的类都可以自由地访问成员。

<div  align="center">  
<img src="https://s2.loli.net/2023/01/02/6X835OUSyNsAVQr.png" width = "65%" height = "65%" alt="图40 - 公有类的公有成员对同一程序集或其他程序集的所有类可见"/>
</div>

### 私有成员的可访问性
private 访问级别最严格：  
① private 类成员只能被它自己的类成员访问，不能被其他类访问，包括继承它的类；  
② private 成员可以被嵌套在它的类中的类成员访问，嵌套类在第27章。

<div  align="center">  
<img src="https://s2.loli.net/2023/01/02/EIxvhMCU3RrKnpd.png" width = "65%" height = "65%" alt="图41 - 任何类的私有成员只对它自己的类（或嵌套类）的成员可见"/>
</div>

### 受保护成员的可访问性
protected 访问级别比 private 访问级别多了允许派生自该类的类访问该成员，即使程序集外部继承该类的类也能访问该成员。

<div  align="center">  
<img src="https://s2.loli.net/2023/01/02/CA5WMfa9dEhjDHG.png" width = "65%" height = "65%" alt="图42 - 公有类的受保护成员对它自己的类成员或派生类的成员可见，派生类可以在其他程序集中"/>
</div>

### 内部成员的可访问性
标记为 internal 的成员对程序集内部的所有类可见，但对程序集外部的类不可见。

<div  align="center">  
<img src="https://s2.loli.net/2023/01/02/H3bdXBgxQmt7e9Z.png" width = "65%" height = "65%" alt="图43 - 内部成员对同一程序集内部的任何类成员可见，但对程序集外部的类不可见"/>
</div>

### 受保护内部成员的可访问性
标记为 protected internal 的成员对所有继承该类的类以及程序集内部的所有类可见，是 protected 和 internal 的并集而不是交集。

<div  align="center">  
<img src="https://s2.loli.net/2023/01/02/pj4qbnR9hOcG8vr.png" width = "65%" height = "65%" alt="图44 - 公有类的受保护内部成员对相同程序集的类成员或继承该类的类成员可见，它对其他程序集中不继承该类的类不可见"/>
</div>

### 成员访问修饰符小结

| 修饰符 | 含义 |
| :---- | :---- |
| private | 只在类内部可访问 |
| internal | 对该程序集内所有类可访问 |
| protected | 对所有继承该类的类可访问 |
| protected internal | 对所有继承该类或在该程序集内声明的类可访问 |
| public | 对任何类可访问 |

<div  align="center">  
<img src="https://s2.loli.net/2023/01/02/NSo5x8qFrzABnTp.png" width = "40%" height = "40%" alt="图45 - 各种成员访问修饰符的相对可访问性"/>
</div>
<p></p>

<table>
    <thead>
    <tr>
        <th></th>
        <th colspan="2">同一程序集内的类</th> 
        <th colspan="2">不同程序集内的类</th> 
   </tr>
    </thead>
    <tbody>
    <tr>
        <td></td>
        <td>非派生</td>
        <td>派生</td>
        <td>非派生</td>
        <td>派生</td>
    </tr>
    <tr>
        <td>private</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>   
    </tr>
    <tr>
        <td>internal</td>
        <td>√</td>
        <td>√</td>
        <td></td>
        <td></td>   
    </tr>
    <tr>
        <td>protected</td>
        <td></td>
        <td>√</td>
        <td></td>
        <td>√</td>   
    </tr>
    <tr>
        <td>protected internal</td>
        <td>√</td>
        <td>√</td>
        <td></td>
        <td>√</td>   
    </tr>
    <tr>
        <td>public</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>
        <td>√</td>   
    </tr>
</table>

## 抽象成员 Abstract Members
**抽象成员**是指被设计为被覆写的函数成员，具有以下特征：  
①必须是一个函数成员，字段和常量不能为抽象成员；  
②必须用 **abstract** 修饰符标记；  
③不能有实现代码块，抽象成员的代码用分号表示。

``` C#
abstract public void PrintStuff(string s); //分号代替实现

abstract public int MyProperty
{
    get; //分号代替实现
    set; //分号代替实现
}
```

抽象成员只可以在抽象类中声明，一共有4种类型的成员可以被声明为抽象：方法；属性；事件；索引器。

其他事项：  
①尽管抽象成员必须在派生类中用相应的成员覆写，但是不能把 virtual 修饰符附加到 abstract 修饰符；
②类似于虚成员，派生类中抽象成员的实现必须指定 override 修饰符。

|  | 虚成员 | 抽象成员 |
| :---- | :---- | :---- |
| 关键字 | virtual | abstract |
| 实现体 | 有实现体 | 没有实现体，被分号取代 |
| 在派生类中被覆写 | 能被覆写，使用 override | 必须被覆写，使用 override |
| 成员的类型 | 方法 属性 事件 索引器 | 方法 属性 事件 索引器 |

## 抽象类 Abstract Classes
抽象类是指被设计为被继承的类，**抽象类**只能被用作其他类的基类。  
①不能创建抽象类的实例；  
②抽象类使用 abstract 修饰符声明；  
③抽象类可以包含抽象成员或非抽象成员；  
④抽象类自己可以派生自另一个抽象类；
⑤任何派生自抽象类的类必须使用 override 关键字实现该类所有的抽象成员，除非派生类自己也是抽象类。

### 抽象类和抽象方法的示例

``` C#
abstract class AbClass //抽象类
{
    public void IdentifyBase() //普通方法
    { Console.WriteLine("I am AbClass"); }

    abstract public void IdentifyDerived(); //抽象方法
}

class DerivedClass : AbClass //派生类
{
    override public void IdentifyDerived() //抽象方法的实现
    { Console.WriteLine("I am DerivedClass");}
}

class Program
{
    static void Main()
    {
        // AbClass a = new AbClass(); //错误，抽象类不能实例化
        // a.IndentifyDrived();

        DerivedClass b = new DerivedClass(); //实例化派生类
        b.IdentifyBase(); //调用继承的方法
        b.IdentifyDerived(); //调用抽象方法
    }
}
```

运行结果如下：

``` console
I am AbClass
I am DerivedClass
```

### 抽象类的另一个例子
注意，数据成员不能被声明为 abstract 。

``` C#
abstract class MyBase //抽象和非抽象成员的组合
{
    public int SideLength = 10; //数据成员
    const int TriangleSideCount = 3; //数据成员

    abstract public void PrintStuff( string s ); //抽象方法
    abstract public int MyInt { get; set;} //抽象属性

    public int PerimeterLength() //普通的非抽象方法
    { return TriangleSideCount * SideLength; }
}

class MyClass : MyBase
{
    public override void PrintStuff( string s ) //覆写抽象方法
    { Console.WriteLine( s ); }

    private int _myInt;

    public override int MyInt //覆写抽象属性
    {
        get { return _myInt; }
        set { _myInt = value; }
    }
}

class Program
{
    static void Main( string[] args )
    {
        MyClass mc = new MyClass();
        mc.PrintStuff( "This is a string" );
        mc.MyInt = 28;
        Console.WriteLine( mc.MyInt );
        Console.WriteLine($"Perimeter Length: { mc.PerimeterLength( ) }");
    }
}
```

运行结果如下：

``` console
This is a string
28
Perimeter Length: 30
```

## 密封类 Sealed Classes
抽象类必须用作基类，不能被实例化。**密封类**相反，只能用作独立的类，不能被用作基类，使用 **sealed** 修饰符标注。

``` C#
sealed class MyClass
{
    ...
}
```

## 静态类 Static Classes
**静态类**的所有成员都是静态的，静态类用于存放不受实例影响的数据和函数。静态类的常见用途是创建一个包含一组数学方法和值的数学库。

静态类的特性如下：  
①类本身必须标记为 static ；  
②类的所有成员必须是静态的；  
③类可以有一个静态构造函数，但不能有实例构造函数，因为不能创建该类的实例；  
④静态类是隐式密封的，即不能继承静态类。

可以使用类名和成员名访问静态类成员，也可以通过使用 using static 指令来访问静态类的成员，而不必使用类名，详见第22章。

``` C#
static public class MyMath {
    public static float PI = 3.14f; //成员必须是静态的
    public static bool IsOdd(int x)
        { return x % 2 == 1; }

    public static int Times2(int x)
        { return 2 * x; }
}

class Program {
    static void Main( )
    {
        int val = 3;
        Console.WriteLine("{0} is odd is {1}.", val, MyMath.IsOdd(val));
        Console.WriteLine($"{ val } * 2 = { MyMath.Times2(val) }.");
    }
}
```

运行结果如下：

``` console
3 is odd is True.
3 * 2 = 6.
```

## 扩展方法 Extension Methods
**扩展方法**允许编写的方法和声明它的类之外的类关联。在现实世界中，扩展方法是一个特别有用的工具，几乎整个 LINQ 库都是通过扩展方法来实现的，见第20章。

通常，若想要向一个类型中添加方法，可以通过以下几种方式：修改源代码；在派生类中定义新的方法；以及，若无法修改或继承，在一个新类中编写一个方法使用该类的实例作为参数，示例如下：

要添加方法的类如下：

``` C#
class MyData
{
    private double D1; //字段
    private double D2;
    private double D3;

    public MyData(double d1, double d2, double d3) //构造函数
    {
        D1 = d1; D2 = d2; D3 = d3;
    }

    public double Sum() //方法
    {
        return D1 + D2 + D3;
    }
}
```

可以编写以下的类，接受 MyData 的实例作为参数，来为上述类实现额外功能：

``` C#
static class ExtendMyData
{
    public static double Average( MyData md )
    {
        return md.Sum() / 3;
    }
}

class Program
{
    static void Main()
    {
        MyData md = new MyData(3, 4, 5);
        Console.WriteLine("Average: {0}", ExtendMyData.Average(md));
    }
}
```

但是上述方案只能用要改变的类的实例调用静态方法 `ExtendMyData.Average( md )`，不能直接在实例对象上调用方法 `md.Average();`。而**扩展方法**允许我们使用第二个形式，只需要将参数声明的类型名前增加关键字 **this** ，如下：

``` C#
static class ExtendMyData //必须是一个静态类
{
    public static double Average( this MyData md ) //必须是公有的和静态的，必须包含关键字this和它所扩展的类的名称，作为第一个参数的类型
    {
        ···
    }
}
```

扩展方法的重点要求如下：  
①声明扩展方法的类必须声明为 static ；  
②扩展方法本身必须声明为 public 和 static ；  
③扩展方法的第一个参数必须包含关键字 this ，并且在后面指定扩展的类的名称。

完整的示例如下：

``` C#
namespace ExtensionMethods
{
    sealed class MyData
    {
        private double D1, D2, D3;
        public MyData(double d1, double d2, double d3)
        { D1 = d1; D2 = d2; D3 = d3; }

        public double Sum() { return D1 + D2 + D3; }
    }

    static class ExtendMyData
    {
        public static double Average(this MyData md)
        {
            return md.Sum() / 3;
        }
    }

    class Program
    {
        static void Main()
        {
            MyData md = new MyData(3, 4, 5);
            Console.WriteLine($"Sum: { md.Sum() }");
            Console.WriteLine("Average: {0}", md.Average());
        }
    }
}
```

运行结果如下：

``` console
Sum: 12
Average: 4
```

## 命名约定
3种主要的命名风格如下：

| 风格名称 | 描述 | 推荐使用 | 示例 |
| :---- | :---- | :---- | :---- |
| Pascal 大小写 | 标识符中每个单词的首字母大写 | 用于类型名称和类中对外可见成员的名称。涉及的名称包括：类、方法、命名空间、属性和公有字段 | CardDeck、DealersHand |
| Camel 大小写 | 标识符中每个单词的首字母大写，第一个单词除外 | 用于局部变量的名称和方法声明的形参名称 | totalCycleCount、randomSeedParam |
| 下划线加 Camel 大小写 | 以下划线开头的 Camel 大小写标识符 | 用于私有或受保护的字段 | _cycleCount、_selectedIndex |
