---
title: 《C#图解教程》读书笔记（一）
date: 2022-11-24 14:08:00
categories: 
  - [C#, C#读书笔记]
tags:
  - .net
  - C#
  - 读书笔记
top_img: /images/black.jpg
cover: https://s2.loli.net/2022/12/15/TYXrac2oJnPlM1E.png
---

> 该笔记为 **《C#图解教程》** 的读书笔记，读书笔记仅为知识的记录，方便后续查找；  
> 学习完成日期为XXXX年XX月XX日。  
> 本篇主要内容为：.NET 框架的简单介绍；C# 程序的基本构成；类型和变量基础；类和方法的基础。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/>
</div>

# 第一章 C#和.NET框架
## .NET框架的组成
.NET框架（.NET Framework）由三个部分组成：

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/sjP4eQIFqxNv65C.png" width = "30%" height = "30%" alt="图1 - .NET框架的组成"/>
</div>

执行环境称为**CLR**（Common Language Runtime 公共语言运行库）；CLR管理程序的执行，包括内存管理和垃圾收集（GC garbage collector 垃圾收集器）；代码安全验证；代码执行、线程管理及异常处理。

严格来说，.NET框架由**CLR**和**FCL**（Framework Class Library 框架类库）组成，FCL是BCL的超集。

**BCL**（Base Class Library 基类库）是.NET框架使用的一个大的类库。包括通用基础类：比如文件操作、字符串操作、安全和加密；集合类：实现了列表、字典、散列表（hash tables）以及位数组（bit arrays）；线程和同步类：用于创建多线程程序；XML类：用于创建、读取及操作XML文档。

> 以下内容摘《C#播放器指南》一书。  
> 
> BCL包含所有的内置类型、数组、异常、数学库、基本文件I/O、安全性、集合、反射、联网、字符串操作、线程等等。一般规则是任何以System开头的名称空间都是BCL的一部分。
> 
> 除了BCL之外，微软还随.NET框架提供了更多的类。通常，这些附加内容涵盖了广泛的功能领域，例如数据库访问或图形用户界面(Windows窗体或WPF)。包括BCL在内的整个集合被称为框架类库FCL。

## 编译为CIL
.NET语言的解释器接受源代码文件，并生成名为**程序集Assembly**的输出文件：

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/Q9dpN3izqSuKmGD.png" width = "45%" height = "45%" alt="图2 - 编译过程"/>
</div>

**程序集**中的代码不是本机代码，而是**CIL**（Common Intermediate Language 公共中间语言）

程序集的信息中包括：程序的CIL；程序中使用的类型的元数据（Metadata）；对其他程序集引用的元数据。

## 编译成本机代码（Native Code）并执行
程序的CIL直到被调用运行时才会被编译成本机代码。在运行时，CLR执行以下步骤：  
（1）检查程序集的安全特性；  
（2）在内存中分配空间；  
（3）把程序集中的可执行代码发给即时编译器（just-in-time JIT compiler），把其中一部分编译成本机代码。

<div  align="center">  
<img src="https://s2.loli.net/2022/10/31/AtdGz26FTm4voMn.png" width = "40%" height = "40%" alt="图3 - 运行时被编译成本机代码"/>
</div>

程序集中的可执行代码只有在被需要时由JIT编译器编译，然后就被缓存cache起来以备在后来的程序中执行。这意味着不被调用的代码不会被编译成本机代码，而且被调用到的代码只被编译一次。

一旦CIL被编译成本机代码，CLR就在运行时管理它，执行如释放无主内存、检查参数类型、管理异常等任务。在CLR控制之下的代码称为托管代码（managed code）；而不在CLR控制之下运行的代码为非托管代码。

## CLR
.NET框架的核心组件是**CLR**，它在操作系统顶层，负责管理程序的执行：

<div  align="center">  
<img src="https://s2.loli.net/2022/11/01/iltGr4vmNuyMsA1.png" width = "50%" height = "50%" alt="图4 - CLR概览"/>
</div>

CLR还通过访问BCL得到广泛的编程功能，包括如Web服务和数据服务之类的功能。

## CLI
每种编程语言都有一组内置的类型，包括整数、浮点数和字符等对象。但是这些类型因为编程语言和平台的不同而不同，这种缺乏统一性需要一组标准促进有序协作。

**CLI**（Common Language Infrastructure 公共语言基础结构）就是一组标准，它把.NET框架的所有组件连结成了一个系统。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/01/Qq9xHIoUvszDgZh.png" width = "55%" height = "55%" alt="图5 - CLI组成"/>
</div>

1. 公共类型系统  
**CTS**（Common Type System 公共类型系统），它定义了一组内置类型；.NET兼容编程语言提供的类型通常映射到CTS已定义的内置类型集的某个特殊子集；***CTS让所有类型都继承自公共的基类——object***；CTS确保用户定义的类型和系统类型能够被任何.NET兼容的语言使用。

2. 公共语言规范  
**CLS**（Common Language Specification 公共语言规范）详细说明了.NET兼容编程语言的规则、属性和行为，包括数据类型、类结构和参数传递）。


# 第二章 C#和.NET Core
## .NET Core的由来
为了更好地解决Web开发以及Linux或macOS的开发，微软用.NET框架搭建了一个基于云的、跨平台的、开源衍生产品，这个新框架即 **.NET Core**。微软也收购了Xamarin以解决Android和IOS等移动平台的开发问题。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/01/UBiFr2XZNK4nJuE.png" width = "70%" height = "70%" alt="图6 - .NET生态系统"/>
</div>

.NET Core主要目标为多平台支持；快速开发和升级；更小的应用程序占用空间；更简单的部署；更少的版本问题；开源社区的支持；改进的应用程序性能。


# 第三章 C#编程概述
## 一个简单的C#程序
``` C#
using System;

namespace Simple
{
    class Program   // declare a class
    {
        static void Main()
        {
            Console.WriteLine("Hi there!");
        }
    }
}
```

行1 ：告诉编译器这个程序使用**System命名空间**的类型；  
行3 ：声明新的名为**Simple的命名空间**，在这部分声明的任何类型都是该命名空间的成员（第4行到第12行）；  
行5 ：声明新的名为**Program的类类型**，在这部分声明的任何成员都是组成这个类的成员（第6行到第11行）；  
行7 ：声明一个名称为**Main的方法**作为**类Program**的成员，**Main是一个特殊函数**，编译器用它作为程序的起始点；  
行9 ：包含了一条简单的语句，组成了**Main的方法**：简单语句以一个分号结束，这条语句使用**命名空间System**中的一个名为**Console的类**将消息输出到屏幕窗口，若没有第一条的**using语句**，编译器就不知道在哪里寻找**类Console**。

*C#程序由一个或多个类型声明组成，命名空间是与某个名称相关联的一组类型声明*。上述代码创建了一个名称为Simple的新命名空间，并在其中声明了其类型（类Program），还使用了System命名空间中定义的Console类。


> ***补充 ：使用 Visual Studio Code 创建 .NET 控制台应用程序（摘自官方.NET文档）***
> 
> **先决条件**：.NET 6 SDK以及已安装 C# 扩展 的 Visual Studio Code
> 
> **创建应用**：  
> 1、在合适位置创建文件夹，并打开vscode打开该文件夹。默认情况下，文件夹名称将是项目名称和命名空间名称；  
> 2、在vscode中选择Terminal - New Terminal；  
> 3、在“终端”中输入以下命令：`dotnet new console --framework net6.0`；  
> 4、此时创建了一个在控制台窗口中显示“Hello World”的简单应用程序：
> ``` C#
> Console.WriteLine("Hello, World!");
> ```
> 
> 首次创建程序时，Visual Studio Code 会提示添加缺少的资产，以生成和调试应用。 选择“是”，Visual Studio Code 会创建一个包含“launch.json”和“tasks.json”文件的“.vscode”文件夹。
> 
> <div  align="center">  
> <img src="https://s2.loli.net/2022/11/04/qmQSHOwfJIvMb8Y.png" width = "55%" height = "55%"/>
> </div>
> 
> 如果未收到提示，或者意外将其关闭而未选择“是”，可以按如下操作步骤：
> 
> <div  align="center">  
> <img src="https://s2.loli.net/2022/11/04/PtDE7zaYQeFGokC.png" width = "35%" height = "35%"/>
> </div>
> 
> 也可以从菜单中选择Run - Add Configurations，在“选择环境”提示符下，选择“.NET 5+ 和 .NET Core”。
> 总之最后要见到 .vscode 中的 launch.json 和 tasks.json 文件。
> 
> **运行应用**：  
> 在“终端”中运行以下命令：`dotnet run`  
> 程序显示“Hello World!”并终止。


## 标识符 Identifiers
**标识符**是用于命名的字符串。  

某些字符能否在标识符的特定位置出现是有规定的：
  - 字母和下划线可以出现在任何位置；
  - 数字不能放在首字母，但可以出现在其他任何位置；
  - @字符只能放在标识符的首位，不推荐将@作为常用字符。

标识符区分大小写，比如变量名myVar和MyVar是不同的标识符。第8章将介绍推荐的C#命名约定。

## 关键字 Keywords
**关键字**不能作为标识符，除非以@字符开始。  
所有C#关键字全部都以小写字母组成。

*表：C#关键字*

| |||||||
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| abstract | const | extern | int | out | short | typeof |
| as | continue | false | interface | override | sizeof | uint |
| base | decimal | finally | internal | params | stackalloc | ulong |
| bool | default | fixed | is | private | static | unchecked |
| break | delegate | float | lock | protected | string | unsafe |
| byte | do | for | long | public | struct | ushort |
| case | double | foreach | namespace | readonly | switch | using |
| catch | else | goto | new | ref | this | virtual |
| char | enum | if | null | return | throw | void |
| checked | event | implicit | object | sbyte | true | volatile |
| class | explicit | in | operator | sealed | try | when while |

**上下文关键字 Contextual Keywords**是仅在特定的语言结构中充当关键字的标识符，上下文关键字可以在代码的其他部分被用作标识符。

*表：C#的上下文关键字*

| |||||||
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| add | ascending | async | await | by | descending | dynamic |
| equals | from | get | global | group | in | into |
| join | let | on | orderby | partial | remove | select | 
| set | value | var | where | yield | | | 

## Main：程序的起始点  
每个C#程序必须有一个类带有**Main方法(函数)**。
  - 每个C#程序的可执行起始点在Main中的第一条指令；
  - Main必须首字母大写。

``` C#
static void Main( )
{
    Statements
}
```

## 空白 Whitespace
程序中的空白指没有可视化输出的字符。在源代码中使用的空白会被编译器忽略。

空白字符包括：空格(Space)；制表符(Tab)；换行符(New line)；回车符(Carriage return)

比如，下面的代码会被编译器同等对待：

``` C#
Main()
{
    Console.WriteLine("Hi, there!");
}
// 连在一起
Main(){Console.WriteLine("Hi, there!");}
```

## 语句 Statements
此处为简单介绍，详细见第10章。

**简单语句**以一个**分号**结束，下面的代码即2条简单语句组成的序列：
``` C#
int var1 = 5;
System.Console.WriteLine("The value of var1 is {0}", var1);
```

## 块 Blocks
**块**是一个由成对大括号包围的0条或多条语句序列，它在语法上相当于一条语句。
``` C#
{
    int var1 = 5;
    System.Console.WriteLine("The value of var1 is {0}", var1);
}
```

语法上只需要一条语句，若需要执行的动作无法用一条简单语句表达时，考虑用块；  
有些特定的程序结构只能使用块；  
简单语句以分号结束，块后面不跟分号。

## 从程序中输出文本
**控制台窗口console window**是一种简单的命令提示窗口。BCL提供了一个名为Console的类（在System命名空间中），该类包含了讲数据输入和输出到控制台窗口的方法。

### Write
Write是Console类的成员，示例：
``` C#
System.Console.Write ("This is text1. ");
System.Console.Write ("This is text2. ");
System.Console.Write ("This is text3. ");
```

在控制台窗口输出如下：
``` Console
This is text1. This is text2. This is text3.
```

注意：Write没有在字符串后面添加换行符，所以三个语句都输出在同一行。

### WriteLine
WriteLine也是Console类的成员，但会在每个输出字符串的结尾添加一个换行符。

上面的代码用WriteLine替换掉Write，输出会变为多行：  
``` Console
This is text1.
This is text2.
This is text3.
```

### 格式字符串 The Format String
Write或WriteLine语句可以有一个以上的参数，格式如下：  
`Console.WriteLine( FormatString, SubVal0, SubVal1, SubVal2, ... );`

第一个参数必须总是字符串，称为**格式字符串**；格式字符串可以包括**代替标记Substitution markers**。代替标记包含大括号和一个整数，整数就是替换值的数字位置。

例如：下面的语句有2个替代标记，{0}和{1}；以及2个替换值，即3和6。
``` C#
Console.WriteLine("Two sample integers are {0} and {1}.", 3, 6);
```

C# 6.0 还引入了**字符串插值string interpolation**，前提是前面加上$符号：
``` C#
int var1 = 3;
int var2 = 6;
Console.WriteLine($"Two sample integers are {var1} and {var2}.");
```

### 多重标记和值
可以使用任意数量的替代标记和任意数量的值，比如：
``` C#
Console.WriteLine("Three integers are {1}, {0} and {1}.", 3, 6);
```

但标记不能引用超出替换值列表长度的值，如果引用，不会产生编译错误compile error，但会产生运行错误runtime error（称为**异常exception**）。比如：`Console.WriteLine("Two integers are {0} and {2}.", 3, 6);`中位置2不存在，3是位置0，6是位置1。

### 格式化数字字符串
指定数字格式，例如：
``` C#
Console.WriteLine("The value: {0}." , 500);
Console.WriteLine("The value: {0:C}.", 500); // 格式化为货币

int myInt = 500;
Console.WriteLine($"The value: {myInt}.");
Console.WriteLine($"The value: {myInt:C}.");
```

上述2种代码，都在控制台窗口产生同样输出：
``` Console
The value: 500.
The value: ￥500.00.
```

大括号内的**格式说明符format specifier**的语法由三个字段fields组成：**索引号index或者字符串插值变量string interpolation variable**、**对齐说明符alignment specifier**和**格式字段format field**。

语法为：`{ index,alignment:format }`

*index或string interpolation*：必需项，指定列表中的某一项；  
*alignment*：可选，指定字段宽度，以及是否是左对齐或是右对齐；  
*format*：可选，指定项的格式。  
*注意*：对齐前面是逗号，格式前面是冒号。

***（1）对齐说明符***  
由一个正整数或者负整数组成：*整数表示字段使用字符的最少数量*；符号表示右对齐或左对齐，*正数表示右对齐，负数表示左对齐*。
``` C#
int myInt = 500;
Console.WriteLine("|{0, 10}|", myInt); // 右对齐Aligned right
Console.WriteLine("|{0,-10}|", myInt); // 左对齐Aligned left
```

输出如下，在两个竖杠的中间有10个字符：
``` Console
|       500|
|500       |
```

*如果要表示的字符数比对齐说明符指定的字符数少，那么其余字符会使用空格填充*；  
*如果要表示的字符数多于指定的字符数，对齐说明符会被忽略，并且使用所需的字符进行表示*。

***（2）格式字段***  
格式字段有三部分，①**冒号**后面必须紧跟格式说明符，中间不能有空格；②**格式说明符format specifier**是一个字母字符，是9个内置字符格式之一，可以是大写或者小写；③**精度说明符precision specifier**是可选的，由1~2位数字组成，实际意义取决于格式说明符。

语法为：`:Axx`，A为格式说明符，xx为精度说明符。
``` C#
double myDouble = 12.345678;
Console.WriteLine("{0,-10:G} -- General", myDouble);
Console.WriteLine("{0,-10} -- Default, same as General", myDouble);
Console.WriteLine("{0,-10:F4} -- Fixed Point, 4 dec places", myDouble);
Console.WriteLine("{0,-10:C} -- Currency", myDouble);
Console.WriteLine("{0,-10:E3} -- Sci. Notation, 3 dec places", myDouble);
Console.WriteLine("{0,-10:x} -- Hexadecimal integer", 1194719 );
```

输出如下：
``` Console
12.345678  -- General
12.345678  -- Default, same as General
12.3457    -- Fixed Point, 4 dec places
￥12.35     -- Currency
1.235E+001 -- Sci. Notation, 3 dec places
123adf     -- Hexadecimal integer
```

***（3）标准数字格式说明符***  
9种标准数字格式说明符，若说明符会根据大小写会有不同输出，会标注为区分大小写。

| 名字和字符 | 意义 |
| :---- | :---- |
| 货币Currency<br>C、c | 使用货币符号，货币符号取决于程序所在PC的区域设置<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :C}", 12.5);`<br>输出：￥12.50 |
| 十进制数Decimal<br>D、d | 十进制数字字符串，可以有负数符号。只能和整数类型配合使用<br>精度说明符：输出字符串的最小位数，若实际数字位数少，则左边以0填充<br>示例：`Console.WriteLine("{0 :D4}", 12);`<br>输出：0012 |
| 定点Fixed-point<br>F、f | 带有小数点的十进制数字字符串，可以有负数符号。<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :F4}", 12.3456789);`<br>输出：12.3457 |
| 常规General<br>G、g | 在没有指定说明符的情况下，会根据值转换为定点或科学计数法表示的形式<br>精度说明符：根据值的情况<br>示例：`Console.WriteLine("{0 :G4}", 12.3456789);`<br>输出：12.35 |
| 十六进制数Hexadecimal<br>X、x<br>区分大小写 | 十六进制数字字符串。A~F会匹配说明符的大小写<br>精度说明符：输出字符串的最小位数，若实际数字位数少，则左边以0填充<br>示例：`Console.WriteLine("{0 :x}", 180026);`<br>输出：2bf3a |
| 数字Number<br>N、n | 和定点表示法相似，但是每3个数字的一组中间有逗号或空格分隔符，使用哪个看程序所在PC的区域设置<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :N2}", 12345678.54321);`<br>输出：12,345,678.54 |
| 百分比Percent<br>P、p | 表示百分比的字符串，数字会乘以100<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :P2}", 0.1221897);`<br>输出：12.22% |
| 往返过程Round-trip<br>R、r | 保证输出字符串后如果使用Parse方法将字符串转化为数字，Parse方法在第27章<br>精度说明符：忽略<br>示例：`Console.WriteLine("{0 :R}", 1234.21897);`<br>输出：1234.21897 |
| 科学计数法Scientific<br>E、e<br>区分大小写 | 具有尾数和指数的科学计数法，e的大小写和说明符一致<br>精度说明符：小数位数<br>示例：`Console.WriteLine("{0 :e4}", 12.3456789);`<br>输出：1.2346e+001 |

## 注释：为代码添加注解 Comments: Annotating the Code
**单行注释 Single-line comments** ：`//`，注释范围一直到行结束都有效。

**带分隔符的注释 Delimited comments** ：开始标记`/*`和结束标记`*/`，带分隔符的注释可以跨越多行，或者只包括行的一部分。注释范围一直到第一个结束分隔符都有效。

**文档注释 Documentation Comments** ：`///`，在第27章阐述。文档注释包括XML文档，可以用于产生程序文档。


# 第四章 类型、存储和变量
## C#程序是一组类型声明
C程序是一组函数和数据类型，C++程序是一组函数和类，C#程序或DLL是一组类型声明。

(1) 类型声明中必须有一个包含**Main方法**的类；  
(2) **命名空间**将相关的类型声明分组并命名，所以在命名空间内声明程序类型。

``` C#
namespace MyProgram // Declare a namespace，名为MyProgram.
{
    DeclarationOfTypeA // Declare a type.
    DeclarationOfTypeB // Declare a type.

    class C // Declare a type.
    {
        static void Main()
        {
            ...
        }
    }
}
```

命名空间在第22章详细阐述。

## 类型是一种模板
类型可以理解为一个创建数据结构的模板。类型具有以下元素：名称、用于保存的数据结构、一些行为和约束条件。

比如：short类型，名称是short，结构是2字节，行为是16位整数。int类型，名称是int，结构是4字节，行为是32位整数。

## 实例化类型 Instantiating a Type
从类型模板创建对象，即**实例化**该类型。

通过实例化类型而创建的对象被称为类型的**对象**或类型的**实例**。这2术语可以互换。

## 数据成员和函数成员
**简单类型**如short、int和long，只能存储一个数据项；
数组类型（array）可以存储多个同类型的数据项，这些数据项即**数组元素**。

然而有些类型可以包含不同类型的数据项，这些数据项被称为**成员 members**，包括**数据成员**和**函数成员**：**数据成员**保存了与这个类的对象或整个类相关数据；**函数成员**执行代码，定义类型的行为。

## 预定义类型
C#有16种预定义类型，包括13种**简单类型**和3种**非简单类型**。所有预定义类型的名称都是小写。

简单类型可以分为3类：    
(1) 11种数值类型：  
&ensp;&ensp;&ensp;- 不同长度的有符号和无符号*整数类型*；  
&ensp;&ensp;&ensp;- *浮点数类型*float和double；  
&ensp;&ensp;&ensp;- *高精度小数类型*decimal，与float和double不同，decimal类型可以表示分数，常用于货币计算。  
(2) *Unicode字符类型*char；  
(3) *布尔类型*bool，即true和false。  

3种非简单类型为：  
(1) string，一个Unicode字符数组；  
(2) object，所有类型的基类；  
(3) dynamic，使用动态语言编写的程序集使用。  

<div  align="center">  
<img src="https://s2.loli.net/2022/11/16/pKUunxX9i5ayjqt.png" width = "60%" height = "60%" alt="图9 - 预定义类型"/>
</div>

所有预定义类型都映射到底层的.NET类型。*预定义简单类型*都表示一个单一的数据项，如下表：

| 名称 | 含义 | 范围 | .NET框架类型 | 默认值 |
| :---- | :---- | :---- | :---- | :---- |
| sbyte | 8-bit signed integer | -128 to 127 | System.SByte | 0 |
| byte | 8-bit unsigned integer | 0 to 255 | System.Byte | 0 |
| short | 16-bit signed integer | -32,768 to 32,767 | System.Int16 | 0 |
| ushort | 16-bit unsigned integer | 0 to 65,535 | System.UInt16 | 0 |
| int | 32-bit signed integer | -2,147,483,648 to 2,147,483,647 | System.Int32 | 0 |
| uint | 32-bit unsigned integer | 0 to 4,294,967,295 | System.UInt32 | 0 |
| long | 64-bit signed integer | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | System.Int64 | 0 |
| ulong | 64-bit unsigned integer | 0 to 18,446,744,073,709,551,615 | System.UInt64 | 0 |
| float | Single-precision float | 1.5×10^-45 to 3.4×10^38 | System.Single | 0.0f |
| double | Double-precision float | 5×10^-324 to 1.7×10^308 | System.Double | 0.0d |
| bool | Boolean | true, false | System.Boolean | false |
| char | Unicode character | U+0000 to U+ffff | System.Char | \x0000 |
| decimal | Decimal value with 28-significant-digit precision | ±1.0×10^28 to ±7.9×10^28 | System.Decimal | 0m |

*预定义非简单类型*，如下表：

| 名称 | 含义 | .NET框架类型 |
| :---- | :---- | :---- |
| object | 所有其他类型的基类，包括简单类型 | System.Object |
| string | 0个或多个Unicode字符组成的序列 | System.String |
| dynamic |  在使用动态语言编写的程序集assemblies时使用 | 无相应的 .NET type |

## 用户定义类型
C#有16种预定义类型，另外还有6种类型可以由用户自己创建：  
*类类型 class*；*结构类型 struct*；*数组类型 array*；*枚举类型 enum*；*委托类型 delegate*；*接口类型 interface*。

类型通过**类型声明type declaration**创建。

预定义类型直接实例化对象即可；用户定义类型要先声明类型，然后实例化该类型对象。

## 栈和堆 The Stack and the Heap
运行中的程序使用两个内存区域来存储数据：栈和堆。
### 栈 The Stack
**栈**是一个内存数组，是一个**LIFO**（后进先出）的数据结构。

数据只能从栈的顶端插入和删除；把数据放到栈顶称为**入栈push**；从栈顶删除数据称为**出栈pop**。

### 堆 The Heap
**堆**是一块内存区域，堆里的内存能够以任意顺序存入和移除。

虽然程序可以在堆里保存数据，但是不能显示地删除它们。CLR的自动垃圾收集器在判断出程序代码不会再访问某数据项时，会自动清理无主对象。

## 值类型和引用类型
数据项的类型定义了存储需要的内存大小及组成该类型的数据成员，也决定了对象在内存的存储位置——栈或堆。

类型分为**值类型value types**和**引用类型reference types**：  
*值类型*只需要一段单独的内存，数据存放在栈中；  
*引用类型*需要两端内存：第一段存储实际的数据，位于堆中。第二段是一个*引用*，指向数据在堆存放的位置，而引用存放在栈中。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/17/yelvL6bXRMFCacG.png" width = "70%" height = "70%" alt="图10 - 非成员数据的存储"/>
</div>

### 存储引用类型对象的成员
上图是当数据不是另一个对象的成员的存储方式。若数据是另一对象的成员，会有些不同。

假设一个引用类型的实例，名为MyType，包括2个成员：一个值类型成员A和一个引用类型成员B。 

对于一个引用类型，其实例的数据部分始终存放在堆中，二个成员都是对象数据的一部分，即都会存放在堆中，无论是值类型还是引用类型。即，引用类型B的数据和引用部分都存放在堆里；值类型A也在堆里。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/17/tdWgnr78DFyScLx.png" width = "50%" height = "50%" alt="图11 - 引用类型对象数据的存储"/>
</div>

### C#类型的分类
如下表：

| | 值类型 | 引用类型 |
| :---- | :---- | :---- |
| 预定义类型 | sbyte byte<br>short ushort<br>int uint<br>long ulong<br>bool char<br>float double<br>decimal | object<br>string<br>dynamic |
| 用户定义类型 | struct<br>enum | class<br>interface<br>delegate<br>array |

## 变量 Variables
**变量**是一个名称，表示程序执行时存储在内存中的数据。

C#提供了4种变量，如下表：

| 名称 | 描述 |
| :---- | :---- |
| 局部变量Local variable | 在方法的作用域保存临时数据，不是类型的成员 |
| 字段Field | 保存和类型或类型实例相关的数据，是类型的成员 |
| 参数Parameter | 用于从一个方法到另一个方法传递数据的临时变量，不是类型的成员 |
| 数组元素Array element | 同类数据项构成的有序集合的一个成员，可以是局部变量，也可以是类型的成员 |

### 变量声明
变量声明定义了变量，并且完成了：① 给变量命名，并关联一种类型；② 让编译器分配一块内存。一个简单的变量声明至少需要一个类型和一个名称。

比如：`int var2;` 定义了一个名为 var2 的 int 类型的变量。

*（1）变量初始化语句*  

**变量初始化语句 variable initializer**由一个等号和初始值组成：`int var2 = 17;`

无初始化语句的局部变量有一个未定义的值，在赋值前不能使用。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/18/YPb8zBrDXshlfwj.png" width = "70%" height = "70%" alt="图12 - 变量初始化语句"/>
</div>

*（2）自动初始化*

有一些类型的变量如果没初始化，会被自动设为默认值。没有自动化为默认值的变量在程序为它赋值之前包含未定义值。

| 变量类型| 存储位置 | 自动初始化 | 用途 |
| :---- | :---- | :---- | :---- |
| 局部变量 Local variables | 栈或栈和堆 | 否 | 用于函数成员内部的局部计算 |
| 类字段 Class fields | 堆 | 是 | 类的成员 |
| 结构字段 Struct fields | 栈或堆 | 是 | 结构的成员 |
| 参数 Parameters | 栈 | 否 | 用于把值传入或传出方法 |
| 数组元素 Array elements | 堆 | 是 | 数组的成员 |

### 多变量声明
可以在单个声明语句中声明多个变量：①多变量声明中的变量必须类型相同；②变量名必须逗号隔开，可以包含初始化语句。

``` C#
//声明一些变量，有的被初始化，有的没被初始化
int var3 = 7, var4, var5 = 3;
double var6, var7 = 6.52;

int var8, float var9; //错误：多变量声明的变量类型必须相同
```

## 静态 static 类型和 dynamic 关键字
C#是静态类型的语言，但 IronPython 和 IronRuby 之类的脚本语言是动态类型的，因为它们也是.NET
语言，C#需要能够使用这些语言编写的程序集，因此增加了dynamic关键字。

## 可空类型 Nullable Types
在某些情况下，希望变量目前不保存有效的值。对于引用类型，可以把变量设为null；但对于值类型，不管内容是否有效，其内存都会分配。可以使用布尔指示器来和变量关联，值有效则设置为true，无效即false。

**可空类型**允许创建可以标记为有效和无效的值类型变量。普通的值类型为**非可空类型**。详见第27章。


# 第五章 类的基本概念
## 类的概述
数据项和函数的封装集合，被称为**类**。

类包括数据成员和函数成员：①数据成员，存储与类或类实例相关的数据；②函数成员，执行代码。

| 数据成员存储数据 | 函数成员执行代码 |
| :---- | :---- |
| 字段 Fields<br>常量 Constants | 方法 Methods ；运算符 Operators ；属性 Properties ；索引器 Indexers<br>构造函数 Constructors ；事件 Events ；析构函数 Destructors |

## 声明类
**类的声明**定义类的名称、成员和特征，不创建类的实例，创建用于创建实例的模板。

``` C#
class MyExcellentClass //class为关键字Keyword，MyExcellentClass是类名
{
    MemberDeclarations
}
```

## 类成员
### 字段
**字段**是在类中的变量。可以是任意类型，包括预定义类型或用户定义的类型。

``` C#
class MyClass
{
    int MyField; //MyField即字段名称
}
```

与 C 和 C++ 不同，*C#在类型外面不能申明全局变量*。所有字段都属于类型。

因为字段是一种变量，**字段初始化语句**和变量初始化语言相同；如果没有初始化语句，字段的值会被编译器设为默认值，总结的来说，每种值类型的默认值都是0，bool 型的默认值是 false，引用类型的默认值为 null 。

``` C#
class MyClass
{
    int F1; // 初始化为0 - 值类型
    string F2; // 初始化为null - 引用类型

    int F3 = 25; // 初始化为25
    string F4 = "abcd"; // 初始化为"abcd"
}
```

在同一语句中声明多个字段，下面语句与上面效果相同：

``` C#
int F1, F3 = 25;
string F2, F4 = "abcd";
```

### 方法
**方法**是具有名称的可执行代码块，相当于C++的**成员函数**。

声明方法包括以下4个组成部分：  
①返回类型：声明方法返回值的类型，若不返回值，则被指定为 void ；  
②名称：方法的名称；  
③参数列表：由一对圆括号组成，参数列在其中；  
④方法体：由一对大括号组成，包含执行代码。

``` C#
class SimpleClass
{
    void PrintNums()
    {
        Console.WriteLine("1");
        Console.WriteLine("2");
    }
}
```

上述代码不返回值（void），有空的参数列表，方法体有2行。

与 C 和 C++ 不同，C#**没有全局函数**，也没有默认的返回类型，所有方法必须包含返回类型或者 void 。

## 创建变量和类的实例
类是引用类型，数据的引用保存在一个类类型的变量中，要创建类的实例，需要声明一个类类型的变量开始，如果变量没有被初始化，它的值是未定义的。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/19/DZy8t9hd3uxGcOa.png" width = "60%" height = "60%" alt="图13 - 为类变量的引用分配内存"/>
</div>

左边顶端的代码是类 Dealer 的声明，下面是类 Program 的声明，它包含 Main 方法；Main 声明了 Dealer 类型的变量 theDealer 。因为该变量没有被初始化，所有它的值是未定义的。

## 为数据分配内存
声明类类型的变量所分配的内存是用来保存引用的，不是用来保存类对象实际数据的。要为实际数据分配内存，需要使用 **new 运算符 operator**。  
①new 运算符能为任意指定类型的实例分配并**初始化**内存；  
②使用 new 运算符组成一个**对象创建表达式**，包括：关键字 new ；要分配内存的实例的类型名称；成对的圆括号，包含或不包含参数。  
③如果将内存分配给一个引用类型，则对象创建表达式返回一个引用，指向在堆中被分配或初始化的对象实例。

<div  align="center">  
<img src="https://s2.loli.net/2022/11/19/s9Vg3YBLvb7eXTP.png" width = "70%" height = "70%" alt="图14 - 为类变量的数据分配内存"/>
</div>

`Dealer theDealer;`声明引用变量；`theDealer = new Dealer();`为类对象分配内存并赋值给变量

合并以上两个步骤，用对象创建表达式来**初始化**变量：

``` C#
Dealer theDealer = new Dealer(); // 声明并初始化
```

## 实例成员
**实例成员 Instance members**：类的每个实例都有自己的一组数据，不同于同一类的其他实例。因为数据成员和类的实例相关，所以被称为实例成员。

**静态成员 Static members**：实例成员是默认类型，但是可以声明与类有关，与实例无关的成员，称为静态成员。见第7章。

## 访问修饰符 Access Modifiers
**访问修饰符**是成员声明的可选部分，指明程序的其他部分如何访问成员，语法如下：
①字段：`访问修饰符 类型 标识符;` ②方法：`访问修饰符 返回类型 方法名()`

5种成员访问控制如下，本章只介绍前2种，其余在第8章：
①私有的 private ；②公有的 public ；③受保护的 protected ；④内部的 internal ；⑤受保护内部的 protected internal

### 私有访问和公有访问
私有成员只能从声明它的类的内部访问，其他的类看不到或无法访问它们。  
私有访问是默认的，若声明时不带访问修饰符，即私有成员。

``` C#
int MyInt1; //隐式声明为私有
private int MyInt2; //显示声明为私有
```

公有成员可以被程序中的其他对象访问。必须使用 public 访问修饰符指定。`public int MyInt;`

成员访问示例：

``` C#
class C1
{
    int F1; //隐式私有字段
    private int F2; //显式私有字段
    public int F3; //公有字段

    void DoCalc() //隐式私有方法
    {
    ...
    }

    public int GetVal() //公有方法
    {
    ...
    }
}
```

## 从类的内部访问成员
下面的类展示了类的方法对字段和其他方法的访问，私有成员可以被类的任何方法访问：

``` C#
class DaysTemp
{
    //字段
    private int High = 75;
    private int Low = 45;

    //方法
    private int GetHigh()
    {
        return High; //访问私有字段
    }

    private int GetLow()
    {
        return Low; //访问私有字段
    }

    public float Average ()
    {
        return (GetHigh() + GetLow()) / 2; //访问私有方法
    }
}
```

## 从类的外部访问成员
要从类的外部访问实例成员，需要**点运算符 dot-syntax notation**，如下：

``` C#
DaysTemp myDt = new DaysTemp(); //创建类的对象
float fValue = myDt.Average(); //从外部访问
```

示例如下，DaysTemp 内的两个字段被声明为 public ，可以从类外部访问：

``` C#
class DaysTemp //声明类 DaysTemp
{
    public int High = 75;
    public int Low = 45;
}

class Program //声明类 Program
{
    static void main()
    {
        DaysTemp temp = new DaysTemp(); //创建对象

        temp.High = 85; //字段赋值
        temp.Low = 60;

        Console.WriteLine("High:   {0}", temp.High ); //读取字段值
        Console.WriteLine($"Low:    {temp.Low}");
    }
}
```

运行结果如下：

``` console
High:   85
Low:    60
```

## 综合应用
创建两个实例并把它们的引用保存在名称为 t1 和 t2 的变量中：

``` C#
class DaysTemp //声明类
{
    public int High, Low; //声明实例字段

    public int Average() //声明实例方法
    {
        return (High + Low) / 2;
    }
}

class Program
{
    static void Main()
    {
        //创建两个DaysTemp实例
        DaysTemp t1 = new DaysTemp();
        DaysTemp t2 = new DaysTemp();

        //给字段赋值
        t1.High = 76; t1.Low = 57;
        t2.High = 75; t2.Low = 53;

        //读取字段值和调用实例的方法
        Console.WriteLine("t1: {0}, {1}, {2}",
                                  t1.High, t1.Low, t1.Average() );
        Console.WriteLine("t2: {0}, {1}, {2}",
                                  t2.High, t2.Low, t2.Average() );
    }
}
```

运行结果如下：

``` console
t1: 76, 57, 66
t2: 75, 53, 64
```

<div  align="center">  
<img src="https://s2.loli.net/2022/11/20/djQIPz6cxEgRlY7.png" width = "50%" height = "50%" alt="图15 - 实例t1和t2的内存布局"/>
</div>


# 第六章 方法
## 方法的结构
*方法是类的函数成员*，包括方法头 method header 和方法体 method body。

方法头指定方法的特征：`int MyMethod ( int par1, string par2 )`，即返回类型、方法名称及参数列表。

方法体包含可执行代码的语句序列。

## 方法体内部的代码执行
方法体是个**块**，是大括号括起的语句序列。可以包括：*局部变量；控制流结构 Flow-of-control constructs ；方法调用 Method invocations ；内嵌的块；其他方法（局部函数）*

``` C#
static void Main()
{
    int myInt = 3; //局部变量初始化为3

    while (myInt > 0) //控制流结构
    {
        --myInt;
        PrintMyMessage(); //方法调用
    }
}
```

## 局部变量
和字段一样，局部变量也保存数据。字段通常保存和对象状态有关的数据，而局部变量是用于保存临时的计算数据。

局部变量声明的语法：`Type Identifier = Value;`

下面的代码包含了2个局部变量的声明，第一个是int类型变量，第二个是SomeClass类型变量：

``` C#
static void Main( )
{
    int myInt = 15;
    SomeClass sc = new SomeClass();
    ...
}
```

对比实例字段和局部变量：

| | 实例字段 | 局部变量 |
| :---- | :---- | :---- |
| 生存期 | 从实例被创建时开始，直到实例不再被访问时结束 | 从它的块中被声明的那一刻开始，在块完成执行时结束 |
| 隐式初始化 | 初始化成该类型的默认值 | 没有隐式初始化。如果变量在使用之前没有被赋值，编译器就会产生一条错误消息 |
| 存储区域 | 由于实例字段是类的成员，所以所有字段都存储在堆里，无论是值类型还是引用类型 | 值类型：存储在栈里；引用类型：引用存储在栈里，数据存储在堆里 |

### 类型推导和 var 关键字

``` C#
static void Main( )
{
    int total = 15;
    MyExcellentClass mec = new MyExcellentClass();
    ...
}
```

上述代码中，第一个变量声明中，编译器可以推断出15是 int 型；第二个变量声明中，右边的对象创建表达式返回了 MyExcellentClass 类型的对象。为避免冗余，可以使用**关键字 var** ：

``` C#
static void Main( )
{
    var total = 15;
    var mec = new MyExcellentClass();
    ...
}
```

var 关键字并不表示特殊变量，只是句法的速记 shorthand ，表示任何可以从初始化语句的右边推断出的类型。var 只能用于局部变量，不能用于字段。一旦推断出类型，即不能改变。

> var 关键字不改变 C# 的强类型性质。

### 嵌套块中的局部变量
局部变量在嵌套块的内部声明，它的生存期限于声明它的内嵌块。

在 C# 中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量。和 C 和 C++ 不同。

## 局部常量 Local Constants
**常量**在声明时必须初始化，声明后不能改变。

声明语句如下：`const Type Identifier = Value;`

初始化值必须在编译期决定，通常是一个预定义简单类型或其组成的表达式。还可以是null引用，但不能是某对象的引用，因为对象的引用是在运行时决定的。

**关键字 const** 不是修饰符，是核心声明的一部分，必须直接放在类型前面。

局部常量也在方法体或代码块中声明，并在声明它的块结束的地方失效。

``` C#
void DisplayRadii() {
    const double PI = 3.1416; //声明局部常量

    for (int radius = 1; radius <= 5; radius++) {
        double area = radius * radius * PI; //读取局部常量
        Console.WriteLine
            ($"Radius: { radius }, Area: { area }");
    }
}
```

## 控制流 Flow of Control
默认情况下，程序按顺序执行语句，**控制流语句**允许改变执行的顺序。详见第10章。

①**选择语句 Selection statements**：`if` 、`if...else` 、`switch` ;  
②**迭代语句 Iteration statements**：`for 循环`、`while 循环`、`do 循环`、`foreach` ；  
③**跳转语句 Jump statements**：`break` 、`continue` 、`goto` 、`return` 。

## 方法调用 Method Invocations
可以从方法体的内部调用其他方法：

``` C#
class MyClass
{
    void PrintDateAndTime() //声明方法
    {
        DateTime dt = DateTime.Now; //获取当前日期和时间
        Console.WriteLine($"{ dt }"); //输出
    }

    static void Main() //声明方法
    {
        MyClass mc = new MyClass();
        mc.PrintDateAndTime( ); //调用方法，别忘了空的参数列表
    }
}
```

调用方法时的控制顺序：当前方法的执行在调用其他方法的点被挂起 → 控制转移到被调用方法的开始 → 被调用方法执行语句直到该方法结束 → 控制回到发起调用的方法。

如果另一个方法在同一个类中，可以直接使用它的名称并传入所需参数进行调用；如果另一个方法在不同的类中，必须通过这个类的一个对象实例调用它，且另一个类中的方法必须使用 public 访问修饰符声明。

## 返回值
方法要向调用代码返回一个值，除了要**声明返回类型**外，还要使用**返回语句**。若方法不返回值，即声明 void 返回类型，不需要返回语句。

返回语句包括关键字 return 及其后面的表达式：`return Expression;`

``` C#
int GetHour( ) //声明返回类型int
{
    DateTime dt = DateTime.Now;
    int hour = dt.Hour;

    return hour; //返回一个int
}
```

也可以返回用户定义类型的对象：

``` C#
MyClass method3( ) //声明返回类型MyClass
{
    MyClass mc = new MyClass();
    ...
    return mc; //返回一个MyClass对象
}
```

## void 方法
void 方法不需要返回语句。可以使用下面的返回语句提前退出方法，不带参数：`return;`。该语句只适用于 void 声明的方法。

``` C#
void SomeMethod()
{
    ...
    if ( SomeCondition )
        return; //返回到调用代码
    ...

    if ( OtherCondition )
        return; //返回到调用代码
    ...
} //默认返回到调用代码
```

## 局部函数 Local Functions
可以在一个方法内声明另一个方法，它只能在包含它的方法内调用，这些嵌入的方法被称为**局部函数**。

``` C#
class Program
{
    public void MethodWithLocalFunction()
    {
        int MyLocalFunction(int z1) //声明局部函数
        {
            return z1 * 5;
        }
    
        int results = MyLocalFunction(5); //调用局部函数
        Console.WriteLine($"Results of local function call: {results}");
    }

    static void Main(string[] args)
    {
        Program myProgram = new Program();
        myProgram.MethodWithLocalFunction(); //调用方法
    }
}
```

运行结果如下：

``` console
Results of local function call: 25
```

## 参数 Parameters
### 形参 Formal Parameters
**形参**是**局部变量**，它声明在方法的参数列表中，而不是在方法体中：`public void PrintSum( int x, float y )`。

参数在方法体的外面定义并在方法开始之前初始化（**输出参数**除外，见后面）；参数列表中可以有任意数目的形参声明，而且声明必须以逗号隔开。

``` C#
public void PrintSum( int x, int y )
{
    int sum = x + y;
    Console.WriteLine($"Newsflash: { x } + { y } is { sum }");
}
```

### 实参 Actual Parameters
调用方法时，形参的值必须在执行前初始化，用于初始化形参的表达式或变量称作**实参**（ actual parameters ，或称为 argument ）。

每一个实参必须与对应形参的类型相匹配，或者编译器能把实参隐式地转换为匹配的类型。

方法PrintSum的调用：`PrintSum( 5, someInt );`

实参的数量必须和形参的数量一致，并且每个实参的类型也必须和所对应的形参类型一致，这种形式的参数叫做**位置参数 Positional Parameters** 。

位置参数示例如下，对于第二次调用，编译器把 int 值 5 和 someInt 隐式地转换成了 float 类型：

``` C#
class MyClass
{
    public int Sum(int x, int y) //形参、声明方法
    {
        return x + y; //返回和
    }

    public float Avg(float input1, float input2) //形参、声明方法
    {
        return (input1 + input2) / 2.0F; //返回平均值
    }
}

class Program
{
    static void Main()
    {
        MyClass myT = new MyClass();
        int someInt = 6;

        Console.WriteLine
            ("Newsflash: Sum: {0} and {1} is {2}",
                5, someInt, myT.Sum( 5, someInt )); //实参、调用方法

        Console.WriteLine
            ("Newsflash: Avg: {0} and {1} is {2}",
                5, someInt, myT.Avg( 5, someInt )); //实参、调用方法
    }
}
```

运行结果如下：

``` console
Newsflash: Sum: 5 and 6 is 11
Newsflash: Avg: 5 and 6 is 5.5
```

## 值参数 Value Parameters
参数种类有好几种，目前为止看到的都是默认的类型，称为**值参数**。

使用值参数时，通过将实参的值复制到形参的方式把数据传递给方法。方法被调用时，系统执行如下操作：①在栈中为形参分配空间；②将实参的值复制给形参。

值参数的实参不一定是变量，可以是任何能计算成相应数据类型的表达式，如下：

``` C#
float func1( float val )
{
    float j = 2.6F;
    float k = 5.1F;
    ...
}


    float fValue1 = func1( k ); //方法调用
    float fValue2 = func1( (k + j) / 3 ); //方法调用，计算成 float 的表达式
```

用作实参之前，变量必须被复制（除非是输出函数）。对于引用类型，变量可以被设置为一个实际的引用或 null 。如下：

``` C#
class MyClass
{
    public int Val = 20; //初始化字段为20
}

class Program
{
    static void MyMethod( MyClass f1, int f2 ) //形参
    {
        f1.Val = f1.Val + 5; //参数的字段加5
        f2 = f2 + 5; //另一个参数加5
        Console.WriteLine($"f1.Val: { f1.Val }, f2: { f2 }");
    }

    static void Main()
    {
        MyClass a1 = new MyClass();
        int a2 = 10;

        MyMethod( a1, a2 ); //调用方法
        Console.WriteLine($"a1.Val: { a1.Val }, a2: { a2 }");
    }
}
```

输出结果如下:

``` console
f1.Val: 25, f2: 15
a1.Val: 25, a2: 10
```

<div  align="center">  
<img src="https://s2.loli.net/2022/11/29/phFWZkfumMcdVLw.png" width = "70%" height = "70%" alt="图16 - 值参数"/>
</div>

①在方法被调用前，用作实参的变量 a2 已经在栈里了；  
②在方法开始时，系统在栈中为形参分配空间，并从实参复制值。  
&emsp;&emsp;- 因为 a1 是引用类型，所以**引用被复制**，结果实参和形参都引用堆中的同一个对象；  
&emsp;&emsp;- 因为 a2 是值类型，所以**值被复制**，产生了一个独立的数据项。  
③在方法的结尾，f2 和对象 f1 的字段都被加上了5。  
&emsp;&emsp;- 方法执行后，形参从栈中弹出；  
&emsp;&emsp;- a2，值类型，它的值不受方法行为影响；  
&emsp;&emsp;- a1，引用类型，但它的值被方法的行为改变了。

> 区分参数和变量，值参数可以是引用类型的变量，注意与引用参数区分。

## 引用参数 Reference Parameters
第二种参数类型称为**引用参数**。

①使用引用参数时，必须在方法的声明和调用中都使用 **ref 修饰符**；  
②引用参数的**实参必须是变量**，在用作实参前必须被赋值。如果是引用类型变量，可以赋值为一个引用或 null 。

``` C#
void MyMethod( ref int val ) //方法声明，包含ref修饰符
{ ... }

int y = 1; //实参变量
MyMethod ( ref y ); //方法调用，包含ref修饰符

MyMethod ( ref 3+5 ); // Error!，必须使用变量
```

①引用参数不会在栈上为形参分配内存。  
②形参的参数名将作为实参变量的别名，指向相同的内存位置。  
由于形参名和实参名指向相同的内存位置，所以方法的执行过程中对形参做的任何改变在方法完成后依然可见。

``` C#
class MyClass
{
    public int Val = 20;
}

class Program
{
    static void MyMethod(ref MyClass f1, ref int f2) //ref修饰符
    {
        f1.Val = f1.Val + 5;
        f2 = f2 + 5;
        Console.WriteLine($"f1.Val: { f1.Val }, f2: { f2 }");
    }

    static void Main()
    {
        MyClass a1 = new MyClass();
        int a2 = 10;
        
        MyMethod(ref a1, ref a2); //调用方法，ref修饰符
        Console.WriteLine($"a1.Val: { a1.Val }, a2: { a2 }");
    }
}
```

输出结果如下：

``` console
f1.Val: 25, f2: 15
a1.Val: 25, a2: 15
```

<div  align="center">  
<img src="https://s2.loli.net/2022/11/29/OJWcAat1gi8SPhv.png" width = "70%" height = "70%" alt="图17 - 对于引用参数，形参就像实参的别名"/>
</div>

①在方法调用之前，将要被用作实参的变量 a1 和 a2 已经在栈里了；  
②在方法的开始，形参名被设置为实参的别名。变量 a1 和 f1 引用相同的内存位置，a2 和 f2 引用相同的内存位置；  
③在方法的结束位置，f2 和 f1 的对象的字段都被加上了5；  
④方法执行后，形参的名称已经失效，但值类型 a2 的值和引用类型 a1 所指向的对象的值被方法内的行为改变了。

## 引用类型作为值参数和引用参数
本节主要描述在方法内用引用类型给形参赋值会发生什么：  
①将引用类型对象作为**值参数**传递：如果在方法内创建一个新的对象并赋值给形参，将切断形参和实参之间的联系，并且在方法调用结束后，新对象将不存在。  
②将引用类型对象作为**引用参数**传递：如果在方法内创建一个新的对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。

*第一种情况 - 将引用类型对象作为值参数传递的示例：*

``` C#
class MyClass { public int Val = 20; }

class Program
{
    static void RefAsParameter( MyClass f1 )
    {
        f1.Val = 50;
        Console.WriteLine($"After member assignment: { f1.Val }");
        f1 = new MyClass();
        Console.WriteLine($"After new object creation: { f1.Val }");
    }

    static void Main( )
    {
        MyClass a1 = new MyClass();
        Console.WriteLine($"Before method call: { a1.Val }");
        RefAsParameter( a1 );
        Console.WriteLine($"After method call: { a1.Val }");
    }
}
```

输出结果如下：

``` console
Before method call: 20
After member assignment: 50
After new object creation: 20
After method call: 50
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/04/ocsiSMEuyIdvUpn.png" width = "70%" height = "70%" alt="图18 - 对用作值参数的引用类型对象赋值"/>
</div>

①在方法开始时，实参和形参都指向堆中相同的对象；  
②在为对象的成员赋值之后，它们仍指向堆中相同的对象；  
③当方法分配新的对象并赋值给形参时，方法外部的实参仍指向原始对象，而形参指向新对象；  
④在方法调用之后，实参指向原始对象，形参和新对象会消失。

*第二种情况 - 将引用类型对象作为引用参数传递的示例：*

``` C#
class MyClass
{
    public int Val = 20;
}

class Program
{
    static void RefAsParameter( ref MyClass f1 )
    {
        f1.Val = 50;
        Console.WriteLine($"After member assignment: { f1.Val }");
        
        f1 = new MyClass();
        Console.WriteLine($"After new object creation: { f1.Val }");
    }

    static void Main( string[] args )
    {
        MyClass a1 = new MyClass();

        Console.WriteLine($"Before method call: { a1.Val }");
        RefAsParameter( ref a1 );
        Console.WriteLine($"After method call: { a1.Val }");
    }
}
```

输出结果如下：

``` console
Before method call: 20
After member assignment: 50
After new object creation: 20
After method call: 20
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/04/yGU3lsVcNuoPdYM.png" width = "70%" height = "70%" alt="图19 - 对用作引用参数的引用类型对象赋值"/>
</div>

①在方法调用时，形参和实参指向堆中相同的对象；  
②对成员值的修改会同时影响到形参和实参；  
③当方法创建新的对象并赋值给形参时，形参和实参的引用都指向新对象。  
④在方法结束后，实参指向在方法内创建的新对象。

## 输出参数 Output Parameters
**输出参数**用于从方法体内把数据传出到调用代码，行为和引用参数类似。  
①必须**在声明和调用中**都使用修饰符，修饰符为 **out** 。  
②和引用参数一样，实参必须是变量，而不能是其他类型的表达式，因为方法需要位置来保存返回值。  
③和引用参数类似，输出参数的形参充当实参的别名，形参和实参都是同一块内存位置的名称。

与引用参数不同，输出参数有以下要求：  
①在方法内部，给输出参数赋值之后才能读取它；即参数的初始值是无关的，而且没必要在方法调用之前为实参赋值。  
②在方法内部，在方法返回之前，代码中每条可能的路径都必须给所有输出参数赋值。

因为方法内的代码在读取输出参数之前必须对其写入，所以不可能使用输出参数把数据传入方法；若方法中试图在方法给输出参数赋值之前读取它的值，编译器会产生一条错误消息。


``` C#
public void Add2( out int outValue )
{
    int var1 = outValue + 2; //出错，在赋值之前读取输出参数
}
```

使用输出参数的示例：

``` C#
class MyClass
{
    public int Val = 20;
}

class Program
{
    static void MyMethod(out MyClass f1, out int f2) //out修饰符
    {
        f1 = new MyClass(); //创建类变量
        f1.Val = 25; //赋值类字段
        f2 = 15; //赋值int参数
    }

    static void Main()
    {
        MyClass a1 = null;
        int a2;

        MyMethod(out a1, out a2); //调用方法，别忘了out修饰符
    }
}
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/05/24xmMSKPvpBATVu.png" width = "65%" height = "65%" alt="图20 - 输出参数必须在方法内进行赋值"/>
</div>

①在方法调用之前，将要被用作实参的变量 a1 和 a2 已经在栈里了；  
②在方法的开始，形参的名称被设置为实参的别名。a1 和 a2 不再作用域之内，所以不能在 MyMethod 中访问；  
③在方法的内部，代码创建了一个 MyClass 类型的对象并赋值给 f1 ；然后给 f1 的字段和 f2 赋值。对 f1 和 f2 的赋值是必须的，因为是输出参数；  
④方法执行后，形参的名称失效，但引用类型的 a1 和值类型的 a2 都被方法内的行为改变了。

> 从 C# 7.0 之后，可以直接在方法调用时的参数列表中声明变量：  
> 原示例：
> 
> ``` C#
> static void Main()
> {
>     MyClass a1 = null; //声明将被用作输出参数的变量
>     int a2; //声明将被用作输出参数的变量
> 
>     MyMethod(out a1, out a2); //调用方法
> }
> ```
> 
> 新语法：
> 
> ``` C#
> static void Main()
> {
>     MyMethod( out MyClass a1, out int a2 ); //调用方法
> }
> ```

## 参数数组 Parameter Arrays
**参数数组**允许特定类型的零个或多个实参对应特定的形参：  
①在一个参数列表里只能有一个参数数组，且必须是列表中的最后一个；  
②由参数数组表示的所有参数必须是同一类型。

声明参数数组要在数据类型前使用 **params 修饰符**，在数据类型后放置一组**空的方括号**，空方括号指明了参数是一个整数数组。数组的细节在第13章。

下面是 int 型参数数组的声明语法：

``` C#
void ListInts( params int[] inVals ) //params为修饰符，int[]为int型参数数组，inVals为参数名称
```

### 方法调用
可以用2种方式为参数数组提供实参：  
①一个用逗号分隔的该数据类型元素的列表，所有元素必须是方法声明中指定的类型：  
`ListInts( 10, 20, 30 );`  
②一个该数据类型元素的一维数组：  
`int[] intArray = {1, 2, 3};`  
`ListInts( intArray );`

> 注意：调用不需要使用 params 修饰符，与上面的其他参数类型的模式不同。  
> 值参数的声明和调用都不带修饰符；  
> 引用参数和输出参数在两个地方都需要修饰符；  
> params 修饰符在声明中需要修饰符，在调用中不允许有修饰符。

*延伸式 Expanded Form*  
方法调用的第一种形式被称为延伸式，这种形式在调用中使用独立的实参；  

``` C#
void ListInts( params int[] inVals ) { ... } //方法声明
...

ListInts( ); //0个实参
ListInts( 1, 2, 3 ); //3个实参
ListInts( 4, 5, 6, 7 ); //4个实参
ListInts( 8, 9, 10, 11, 12 ); //5个实参
```

在使用一个为参数数组使用独立参数的调用时，编译器会  
①接受实参列表，用它们在堆中创建并初始化一个数组；  
②把数组的引用保存在栈的形参里；  
③如果在对应形参数组的位置没有实参，编译器会创建一个有零个元素的数组来使用。

示例如下：

``` C#
class MyClass
{
    public void ListInts( params int[] inVals ) //参数数组
    {
        if ( (inVals != null) && (inVals.Length != 0))
            for (int i = 0; i < inVals.Length; i++) //处理数组
            {
                inVals[i] = inVals[i] * 10;
                Console.WriteLine($"{ inVals[i] }");
            }
    }
}

class Program
{
    static void Main()
    {
        int first = 5, second = 6, third = 7; //声明3个int
        MyClass mc = new MyClass();
        mc.ListInts( first, second, third ); //调用方法

        Console.WriteLine($"{ first }, { second }, { third }");
    }
}
```

输出结果如下：

``` console
50
60
70
5, 6, 7
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/05/9n5PU8ZbdIkQzMy.png" width = "65%" height = "65%" alt="图21 - 参数数组示例"/>
</div>

①在方法调用之前，3个实参已经在栈中；  
②在方法的开始，3个实参被用于初始化堆中的数组，并且数组的引用被赋值给了形参 inVals ；  
③在方法内部，代码首先检查以确认数组引用不是 null ，然后处理数组，把每个元素乘以10并保存回去；  
④方法执行之后，形参 inVals 失效。

### 将数组作为实参
也可以在方法调用之前创建并组装一个数组，把单一的数组变量作为实参传递。

``` C#
static void Main() {
    int[] myArr = new int[] { 5, 6, 7 }; //创建并初始化数组
    MyClass mc = new MyClass();
    mc.ListInts(myArr); //调用方法

    foreach (int x in myArr)
        Console.WriteLine($"{ x }");
}
```

输出结果如下：

``` console
50
60
70
50
60
70
```

## 参数类型总结

| 参数类型 | 修饰符 | 是否在声明时使用 | 是否在调用时使用 | 执行 |
| :---- | :---- | :---- | :---- | :---- |
| 值 | 无 | | | 系统把实参的值复制到形参 |
| 引用 | ref | 是 | 是 | 形参是实参的别名 |
| 输出 | out | 是 | 是 | 仅包含一个返回的值。形参是实参的别名 |
| 数组 | params | 是 | 否 | 允许传递可变数目的实参到方法 |

## ref 局部变量和 ref 返回
ref 关键字允许传递一个对象引用给方法调用，在调用上下文中，对对象的改动在方法返回后依然可见；  
**ref 返回**允许将一个引用发送到方法外，然后在调用上下文内使用这个引用；  
与 ref 返回相关的功能是**ref 局部变量**，允许一个变量是另一个变量的别名。

### ref 局部变量
可以使用该功能创建一个变量的别名，对任意一个变量的赋值都会反映到另一个变量上，因为引用的是相同的对象，即使是值类型。

创建别名的语法需要使用关键字 ref 两次：`ref int y = ref x;`

当 x 改变时，y 也会变，示例如下：

``` C#
class Program {
    static void Main() {
        int x = 2;
        ref int y = ref x;
        Console.WriteLine( $"x = {x}, y = {y}" );
        x = 5;
        Console.WriteLine( $"x = {x}, y = {y}" );
        y = 6;
        Console.WriteLine( $"x = {x}, y = {y}" );
    }
}
```

输出结果如下：

``` console
x = 2, y = 2
x = 5, y = 5
x = 6, y = 6
```

### ref 返回
ref 局部变量通常和 ref 返回功能一起使用。ref 返回功能提供了一种使方法返回变量引用而不是变量值的方法。也需要使用 ref 关键字2次：一次在方法的返回类型声明之前；另一次在 return 关键字之后。

示例如下，因为调用了修改 ref 局部变量的代码，所以类的字段值改变了：

``` C#
class Simple
{
    private int Score = 5;

    public ref int RefToValue() //ref 返回的方法
    {
        return ref Score; //ref 返回
    }

    public void Display()
    {
        Console.WriteLine( $"Value inside class object: {Score}" );
    }
}

class Program
{
    static void Main()
    {
        Simple s = new Simple();
        s.Display();
        ref int v1Outside = ref s.RefToValue(); //ref 局部变量

        v1Outside = 10; //在调用域外修改值
        s.Display(); //检查值是否已经改变
    }
}
```

输出结果如下：

``` console
Value inside class object: 5
Value inside class object: 10
```

另一个示例，Math.Max 能够返回两个值中较大的那个，若想返回较大值的变量的引用：

``` C#
using static System.Console;

class Program
{
    static ref int Max(ref int p1, ref int p2)
    {
        if ( p1 > p2 )
            return ref p1; //返回引用而不是值
        else
            return ref p2; //返回引用而不是值
    }

    static void Main()
    {
        int v1 = 10;
        int v2 = 20;
        WriteLine("Start");
        WriteLine($"v1: {v1}, v2: {v2}\n");

        ref int max = ref Max(ref v1, ref v2);
        WriteLine("After assignment");
        WriteLine($"max: {max}\n");

        max++;
        WriteLine("After increment");
        WriteLine($"max: {max}, v1: {v1}, v2: {v2}");
    }
}
```

输出结果如下：

``` console
Start
v1: 10, v2: 20

After assignment
max: 20

After increment
max: 21, v1: 10, v2: 21
```

这个功能有如下限制：  
①不能将返回类型是 void 的方法声明为 ref 返回方法；  
②ref return 表达式不能返回：空值、常量、枚举成员、类或结构体的属性、指向只读位置的指针；  
③ref 局部变量只能被赋值一次；  
④即使一个方法声明为 ref 返回方法，如果在调用中省略了 ref 关键字，则返回的是指，而不是指向值的内存位置的指针；  
⑤如果将 ref 局部变量作为常规的实际参数传递给其他方法，则该方法仅获取该变量的一个副本，尽管 ref 局部变量包含指向存储位置的指针，但是当以这种方法使用时，传递的是值而不是引用。

## 方法重载 Method Overloading
一个类中可以有多个同名方法，叫做**方法重载 method overloading**。使用相同名称的每个方法必须有一个和其他方法不同的**签名 signature** 。

> 和 python 的方法重载区分，继承中的叫方法覆写 method overriding 。

*返回类型不是签名的一部分，形参的名称也不是签名的一部分*：`long AddValues( int a, out int b) { ... }`的 AddValues( int a, out int b) 部分为签名，包括方法的名称、参数的数目、参数的数据类型和顺序、参数修饰符。

示例如下，下面4个方法都是方法名 AddValues 的重载：

``` C#
class A
{
    long AddValues( int a, int b) { return a + b; }
    long AddValues( int c, int d, int e) { return c + d + e; }
    long AddValues( float f, float g) { return (long)(f + g); }
    long AddValues( long h, long m) { return h + m; }
}
```

非法的方法重载的示例如下，它们具有相同的签名，因为方法名相同，参数的数目、类型和顺序也相同。编译器会生成一条错误讯息：

``` C#
class B
{
    long AddValues( long a, long b) { return a+b; }
    int AddValues( long c, long d) { return c+d; } //错误，相同的签名
}
```

## 命名参数 Named Parameters
上面用到的都是位置参数，可以使用**命名参数**在方法调用中显示指定参数名字，以任意顺序列出实参：`c.Calc ( c: 2, a: 4, b: 3);` 

在调用时，可以同时使用位置参数和命名参数，但所有**位置参数必须先列出**，示例如下：

``` C#
class MyClass {
    public int Calc( int a, int b, int c )
    { return ( a + b ) * c; }

    static void Main() {
        MyClass mc = new MyClass( );

        int r0 = mc.Calc( 4, 3, 2 ); //位置参数
        int r1 = mc.Calc( 4, b: 3, c: 2 ); //位置参数和命名参数
        int r2 = mc.Calc( 4, c: 2, b: 3 ); //顺序变换
        int r3 = mc.Calc( c: 2, b: 3, a: 4 ); //命名参数
        int r4 = mc.Calc( c: 2, b: 1 + 2, a: 3 + 1 ); //命名参数表达式

        Console.WriteLine($"{ r0 }, { r1 }, { r2 }, { r3 }, { r4 }");
    }
}
```

## 可选参数 Optional Parameters
**可选参数**需要在方法声明中提供**默认值**，示例如下：

``` C#
class MyClass
{
    public int Calc( int a, int b = 3 ) //可选参数和默认值
    {
        return a + b;
    }

    static void Main()
    {
        MyClass mc = new MyClass();
        int r0 = mc.Calc( 5, 6 ); //使用显示值
        int r1 = mc.Calc( 5 ); //b使用默认值
        Console.WriteLine($"{ r0 }, { r1 }");
    }
}
```

注意事项：  
①可选参数只能是值参数，不能是 ref 、 out 、 params 参数，且只要值类型的默认值在编译时可以确定，就可以使用值类型作为可选参数。只有在默认值是 null 的时候，引用类型才可以作为可选参数；  
②所有必填参数 required parameters 必须在可选参数声明之前声明；如果有 params 参数，必须在所有可选参数之后声明。

<div  align="center">  
<img src="https://s2.loli.net/2022/12/06/HrlmvtKgde7EWZc.png" width = "60%" height = "60%" alt="图22 - 参数语法顺序"/>
</div>

## 栈帧 Stack Frames
局部变量和参数是位于栈上的，在调用方法时，内存从栈的顶部开始分配，保存和方法关联的数据项。这块内存叫做方法的**栈帧 stack frame** 。

栈帧包含的内存保存如下内容：  
①返回地址，即方法退出时继续执行的位置；  
②分配内存的参数，方法的值参数，或参数数组；  
③和方法调用有关的其他管理数据项。

在方法调用时，整个栈帧都会压入栈；在方法退出时，整个栈帧会从栈上弹出。弹出栈帧有时候叫做**栈展开 unwind the stack** 。

示例如下，Main 调用了 MethodA ，MethodA 又调用了 MethodB ，创建了3个栈帧。在方法退出时，栈展开：

``` C#
class Program
{
    static void MethodA( int par1, int par2)
    {
        Console.WriteLine($"Enter MethodA: { par1 }, { par2 }");
        MethodB(11, 18); //调用MethodB
        Console.WriteLine("Exit MethodA");
    }

    static void MethodB(int par1, int par2)
    {
        Console.WriteLine($"Enter MethodB: { par1 }, { par2 }");
        Console.WriteLine("Exit MethodB");
    }

    static void Main( )
    {
        Console.WriteLine("Enter Main");
        MethodA( 15, 30); //调用MethodA
        Console.WriteLine("Exit Main");
    }
}
```

输出结果如下：

``` console
Enter Main
Enter MethodA: 15, 30
Enter MethodB: 11, 18
Exit MethodB
Exit MethodA
Exit Main
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/06/dPNMrXqxDuSelB7.png" width = "60%" height = "60%" alt="图23 - 一个简单程序中的栈帧"/>
</div>

## 递归 Recursion
**递归**：方法调用自身。递归每次方法调用都把新的栈帧压入栈顶，随着递归越来越深，栈也越来越大：

``` C#
class Program
{
    public void Count(int inVal)
    {
        if (inVal == 0)
            return;
        Count(inVal - 1); //调用自身

        Console.WriteLine($"{ inVal }");
    }

    static void Main()
    {
        Program pr = new Program();
        pr.Count(3);
    }
}
```

输出结果如下：

``` console
1
2
3
```

<div  align="center">  
<img src="https://s2.loli.net/2022/12/06/bhVKIcY2DPuT4qF.png" width = "65%" height = "65%" alt="图24 - 用递归的方法构建和展开栈的示例"/>
</div>