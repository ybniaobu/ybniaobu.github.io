<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity URP 和 HLSL（一）</title>
      <link href="/2024/02/22/2024-02-22-URP1/"/>
      <url>/2024/02/22/2024-02-22-URP1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前的《Unity Shader入门精要》是以 Unity 内置渲染管线为基础的，以 Cg 语言为主，但当使用 URP 和 HDRP 时，使用的是 HLSL 语言；<br>本文主要介绍 URP 相关概念以及 HLSL 主要语法，并将部分重要的 Unity Shader 入门精要的 Cg 语言的 Shader 转换为 HLSL，以实现 NPR 渲染为结尾。<br>本文参考了 <a href="https://catlikecoding.com/">https://catlikecoding.com/</a> 的 tutorials for Unity。</p></blockquote><h1 id="Unity-SRP"><a href="#Unity-SRP" class="headerlink" title="Unity SRP"></a>Unity SRP</h1><p><strong>SRP</strong>，<strong>Scriptable Render Pipeline</strong>，即<strong>可编程渲染管线</strong>。Unity 当前提供两个预先构建的 SRP： ①<strong>URP</strong>，<strong>Universal Render Pipeline</strong>，即<strong>通用渲染管线</strong>；②<strong>HDRP</strong>，<strong>High Definition Render Pipeline</strong>，即<strong>高清渲染管线</strong>。SRP 可以理解为是一个 API 层，允许使用 C# 脚本来调度和配置渲染命令。Unity 将这些命令传递给它的低级图形架构，后者随后将指令发送给图形 API。</p><p>URP 和 HDRP 都可以使用 <strong>Shader Graph</strong> 来编写 Shader，但是手写 Shader 在性能方面有很大的优势，因此在项目中前期建议直接使用 Shader Graph 来编写 Shader，因为 Shader Graph 可视化更加便捷，在得到想要的效果后，在项目后期改成手写 Shader 来提高性能。</p><h2 id="SRP-和内置管线的不同"><a href="#SRP-和内置管线的不同" class="headerlink" title="SRP 和内置管线的不同"></a>SRP 和内置管线的不同</h2><p>在 SRP 中手写 Shader 仍然使用的是 Shader Lab，和内置渲染管线相比，结构并没有太大的变化，主要的几点不同如下：<br><strong>①</strong>使用 <strong>HLSL</strong> 而不是 Cg 语言，尽管这不是强制的，但是 HLSL 是官方推荐的。Cg 语言已经不再更新。官方的 URP 的自带的 Shader 都是 HLSL 编写的，URP Shader 代码中会调用 URP Shader Library 中的 Shader 代码（在名为 Universal RP 的 Packages 中）；<br><strong>②</strong>SubShader 的 Tags 中需要指定 <strong>RenderPipeline</strong>，例如：<code>&quot;RenderPipeline&quot; = &quot;UniversalPipeline&quot;</code>表示这是一个 URP 的 Shader；<br><strong>③</strong>Pass 的 Tags 中的 <strong>LightMode</strong> 和内置渲染管线不同，在内置管线中，LightMode 表示了这个 Pass 处于管线中处理光照的哪个步骤，例如 <code>ForwardBase</code>，<code>ForwardAdd</code>分别是前向流水线中的主光照 pass 和附加逐像素光照 pass。而 URP 中，我们经常使用的有 <code>UniversalForward</code>，<code>ShadowCaster</code>，<code>DepthNormalsOnly</code>，<code>DepthOnly</code>，<code>SRPDefaultUnlit</code> 等 pass；<br><strong>④</strong>为了兼容 <strong>SRP Batcher</strong>，Shader 需要采用一些特殊的写法。简单来说，就是对于 Properties 中的属性，需要放到特定的 <strong>CBuffer</strong> 中，这个 CBuffer 的名字为 <strong>UnityPerMaterial</strong>。另外对于 Unity 的内置属性，比如一些内置矩阵，要放到 <strong>UnityPerDraw</strong> 的 CBuffer 中；<br><strong>⑤</strong>如果要支持 <strong>GPU Instancing</strong>，Shader 代码还要使用另外的一组宏来修改，使得可以支持 GPU Instancing。</p><h2 id="URP"><a href="#URP" class="headerlink" title="URP"></a>URP</h2><p><strong>【待补充】</strong><br>Render Pipeline Asset  </p><p>URP ShaderLab Pass tags：<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/urp-shaders/urp-shaderlab-pass-tags.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@17.0/manual/urp-shaders/urp-shaderlab-pass-tags.html</a>  </p><h1 id="URP-shader-基础框架"><a href="#URP-shader-基础框架" class="headerlink" title="URP shader 基础框架"></a>URP shader 基础框架</h1><p>下面通过一个非常基础的 URP shader 代码介绍 URP shader 的基础框架：</p><blockquote><p>不要管代码块标注的 c，只是为了让代码高亮</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Example/URPUnlitShaderBasic&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        [MainColor] _BaseColor(<span class="string">&quot;Base Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        [MainTexture] _BaseMap(<span class="string">&quot;Base Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">//SubShader Tags 定义何时以及在何种条件下执行某个 SubShader 代码块或某个 Pass。</span></span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalPipeline&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">//声明 Pass 名称，方便调用与识别</span></span><br><span class="line">            Name <span class="string">&quot;ForwardUnlit&quot;</span> </span><br><span class="line"></span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Core.hlsl 文件包含常用的 HLSL 宏和函数的定义，还包含对其他 HLSL 文件（例如Common.hlsl、SpaceTransforms.hlsl 等）的 #include 引用。</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">struct</span> Attributes &#123;</span><br><span class="line">                <span class="comment">//positionOS 即 position in object space</span></span><br><span class="line">                float4 positionOS   : POSITION;</span><br><span class="line">                float2 uv           : TEXCOORD0;</span><br><span class="line">                half3 normal        : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span> &#123;</span></span><br><span class="line">                <span class="comment">//positionHCS 即 position in homogeneous clip space 齐次裁剪空间</span></span><br><span class="line">                float4 positionHCS  : SV_POSITION;</span><br><span class="line">                float2 uv           : TEXCOORD0;</span><br><span class="line">                half3 normal        : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//材质单独声明，使用 DX 风格的新采样方法，下面两个宏都在 Core.hlsl 里面</span></span><br><span class="line">            <span class="comment">//此宏将 _BaseMap 声明为 Texture2D 对象。</span></span><br><span class="line">            TEXTURE2D(_BaseMap);</span><br><span class="line">            <span class="comment">//此宏声明采样器</span></span><br><span class="line">            SAMPLER(sampler_BaseMap);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//要使 Unity 着色器 SRP Batcher 兼容，请在名为 UnityPerMaterial 的单个 CBUFFER 代码块中声明与材质相关的所有属性。</span></span><br><span class="line">            CBUFFER_START(UnityPerMaterial)</span><br><span class="line">                half4 _BaseColor;</span><br><span class="line">                float4 _BaseMap_ST;</span><br><span class="line">            CBUFFER_END</span><br><span class="line"></span><br><span class="line">            Varyings <span class="title function_">vert</span><span class="params">(Attributes IN)</span> &#123;</span><br><span class="line">                Varyings OUT;</span><br><span class="line">                OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);</span><br><span class="line">                <span class="comment">//TRANSFORM_TEX 宏在 Macros.hlsl 定义，用于应用纹理偏移缩放</span></span><br><span class="line">                OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);</span><br><span class="line">                OUT.normal = TransformObjectToWorldNormal(IN.normal);</span><br><span class="line">                <span class="keyword">return</span> OUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            half4 <span class="title function_">frag</span><span class="params">(Varyings IN)</span> : SV_Target &#123;</span><br><span class="line">                <span class="comment">//SAMPLE_TEXTURE2D 宏用于纹理采样</span></span><br><span class="line">                half4 color = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);</span><br><span class="line">                color *= _BaseColor;</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="URP-Shader-目录结构"><a href="#URP-Shader-目录结构" class="headerlink" title="URP Shader 目录结构"></a>URP Shader 目录结构</h2><p>我们观察一下 URP 源码的目录结构（在 项目/Liabrary/PackageCache/<strong>com.unity.render-pipelines.universal</strong> 目录下面），可以看到 Shader 代码位于 Shader 目录以及 ShaderLibrary 目录中，其中 Shader 代码主要放在 Shader 目录，HLSL 文件主要放在 ShaderLibrary 目录中。在 Pass 中可以直接插入 HLSL 文件中的代码，下面会详细介绍。</p><p>另外，URP 的 Shader 还会引用 SRP Core 这个包中的 ShaderLibrary（在 项目/Liabrary/PackageCache/<strong>com.unity.render-pipelines.core</strong> 目录下面）。这个 SRP Core 提供了 URP/HDRP 共享的一些功能的实现，如果需要自定义一个 SRP，使用这个库也可以大大简化工作。其 ShaderLibrary 中包含了很多基础和核心 Shader 函数以及宏定义。</p><p>我们也可以采用官方的目录结构，将主要的 HLSL 的 Pass 代码放置在 ShaderLibrary 文件夹中，然后在 shader 代码中添加 <code>#include</code> 指令以及 HLSL 文件的相对地址来插入 HLSL 代码，如下：</p><pre><code>    HLSLPROGRAM    #pragma vertex UnlitPassVertex    #pragma fragment UnlitPassFragment    #include &quot;UnlitPass.hlsl&quot;    ENDHLSL</code></pre><h2 id="include-指令保护"><a href="#include-指令保护" class="headerlink" title="include 指令保护"></a>include 指令保护</h2><p><code>#include</code> HLSL 文件和 using 命名空间不同，它直接在指令的位置插入整个文件的内容。有可能会 <code>#include</code> 同样的文件两次，从而导致编译错误，为了防止上述情况发生，可以在 HLSL 文件开头添加 include 指令保护：  </p><pre><code>    #ifndef CUSTOM_UNLIT_PASS_INCLUDED    #define CUSTOM_UNLIT_PASS_INCLUDED    #endif</code></pre><p><code>#define</code> 指令理论上可以定义任意标识符 identifier。使用 <code>#ifndef</code> 指令来判断代码是否被定义，因为我们只想在没被定义的情况下插入代码。所有在 <code>#ifndef</code> 和 <code>#endif</code> 之间的代码块会被跳过并且不会被编译，如果该宏已经被定义的话。</p><p>我们可以将函数代码放在上述代码块之间，HLSL 文件的简易代码框架如下：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line">CBUFFER_START(UnityPerMaterial) <span class="comment">//见下面 Optimizing draw calls</span></span><br><span class="line">float4 _BaseColor;</span><br><span class="line">CBUFFER_END</span><br><span class="line"></span><br><span class="line">float4 <span class="title function_">UnlitPassVertex</span><span class="params">(float3 positionOS : POSITION)</span> : SV_POSITION &#123;</span><br><span class="line">    float3 positionWS = TransformObjectToWorld(positionOS.xyz);</span><br><span class="line">    <span class="keyword">return</span> TransformWorldToHClip(positionWS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 <span class="title function_">UnlitPassFragment</span> <span class="params">()</span> : SV_TARGET &#123;</span><br><span class="line">    <span class="keyword">return</span> _BaseColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="Optimizing-draw-calls"><a href="#Optimizing-draw-calls" class="headerlink" title="Optimizing draw calls"></a>Optimizing draw calls</h2><blockquote><p>这里只是简单介绍一下，详见官方文档：<a href="https://docs.unity3d.com/2022.3/Documentation/Manual/optimizing-draw-calls.html">https://docs.unity3d.com/2022.3/Documentation/Manual/optimizing-draw-calls.html</a> ，本文重点关注 URP 代码，故下面主要关注对 shader 代码的影响。</p></blockquote><p>优化 draw call 主要有四个方法：<br>①<strong>Draw call batching</strong>：对于使用相同材质的物体，合并 mesh 从而减少 draw call 的一种方式，包括下面两种内置的 draw call batching 方式：<br>&emsp;&emsp; - <strong>Static batching</strong>：将静态物体合并为一个大网格；<br>&emsp;&emsp; - <strong>Dynamic batching</strong>：在运行时 Unity 自动把符合条件的多个模型网格合并为一个；<br>②<strong>SRP Batcher</strong>：对于使用相同 shader 的材质球，减少 CPU 在不同的 draw call 之间的准备工作；<br>③<strong>GPU instancing</strong>：对于使用同个材质的多个物体进行一次 draw call 的一种方式。</p><p>上述 4 个优化方法的<strong>优先级</strong>是：<strong>SRP Batcher and static batching &gt; GPU instancing &gt; Dynamic batching</strong>。Unity 只会使用优先级最高的方法，除了 SRP Batcher 和 static batching 可以同时使用。</p><h3 id="Dynamic-batching"><a href="#Dynamic-batching" class="headerlink" title="Dynamic batching"></a>Dynamic batching</h3><p>动态批处理是为老的低端设备而设计的。只有当动态批处理产生的 CPU 开销小于 Draw Call 的开销，动态批处理才具有优化性能的效果。而在如今的电子设备上，动态批处理产生的 CPU 开销反而有可能大于 DrawCall 的开销，影响性能。比如，对于 Apple Metal 来说，Draw Call 的开销非常低，所以动态批处理并不能提供性能。</p><p>动态批处理对 HDRP 不兼容，其他都兼容。</p><p>动态批处理是满足一定条件自动开启的，在运行时 Unity 自动把每一帧画面里符合条件的多个模型网格合并为一个，在 CPU 中将所有顶点转换到世界空间。</p><p>其他可能需了解的内容的关键词如下，详见官方文档：<br>①MaterialPropertyBlock：一种使用相同材质但是不同材质属性的方法，不影响批处理，但是不与 SRP Batcher 兼容；<br>②如果物体使用相同材质但是不同的纹理贴图，可以使用纹理图集 Texture atlases 技术将不同纹理合并为一个更大的纹理，从而使用一个材质；<br>③通过 C# 脚本修改材质，请使用 Renderer.sharedMaterial 以保持批处理，Renderer.material 创建材质的复制；<br>④可以使用 Mesh.CombineMeshes 手动合并网格；<br>⑤对于不同材质的相同的 shadows caster pass，Unity 可以使用动态批处理。</p><h3 id="Static-batching"><a href="#Static-batching" class="headerlink" title="Static batching"></a>Static batching</h3><p>静态批处理将静态物体合并为一个大网格，只使用一个 draw call 画出所有合并的网格。静态批处理比动态批处理效率更高，因为它不需要在 CPU 上转换顶点，但是需要占据更多的 CPU 内存。这段话虽然是官方文档说法，但是不太准确，下面更加准确：</p><p>静态批处理不一定减少 DrawCall，但是会让 CPU 在“设置渲染状态-提交 Draw Call”上更高效；Unity 将静态物体合并为一个(或多个)大网格，这个(或这些)大网格以 vertex buffers 和 index buffers 的形式存储在 GPU 上；Unity 按顺序绘制场景中的物体时，如果两个物体的数据属于同一块 buffer，且在 vertex buffer 和 index buffer 上连续，那么这两个物体仅产生 1 次 DrawCall；如果它们不连续，那么将产生 2 次 DrawCall(specify different regions of this buffer)；但是由于它们属于同一块 buffer，因此这 2 次 DrawCall 之间的 GPU 状态不发生改变，它们构成 1 次 StaticBatch；虽然没有降低 DrawCall 次数，但是避免了重复的 “buffer binding”。</p><p>静态批处理对内置管线、URP、HDRP 和自定义 SRP 都兼容。</p><h3 id="SRP-Batcher"><a href="#SRP-Batcher" class="headerlink" title="SRP Batcher"></a>SRP Batcher</h3><p>SRP Batcher 适用于使用不同材质的物体，但这些材质使用相同的 Shader（确切地说是 Shader Variant）。</p><p>顾名思义 SRP 才支持。在 URP 项目中，这一项是默认开启的，可以找到 URP Asset，可以看到 SRP Batcher 的选项是默认开启的，默认情况下该选项是被隐藏的，可以在 Edit -&gt; Preferences -&gt; Core Render Pipeline 中把 Visibility 改为 All Visible。</p><p>被渲染的物体需要满足兼容性：<br>①被渲染的物体必须是 mesh 或 skinned mesh，不可以是 particle；<br>②被渲染的物体不能使用 MaterialPropertyBlock 修改属性，MaterialPropertyBlock 不支持 SRP Batcher；<br>③Shader 需要支持 SRP Batcher，见下面。</p><p>要想 Shader 使用 SRP Batcher 必须满足 SRP Batcher compatibility 条件：<br>①在一个名为 <strong>UnityPerDraw</strong> 的 <strong>CBuffer</strong> (constant buffer) 中声明所有内置属性，比如 unity_ObjectToWorld；<br>②在一个名为 <strong>UnityPerMaterial</strong> 的 <strong>CBuffer</strong> (constant buffer) 中声明所有材质属性。<br>可以在 Shader 的 Inspector 面板中，看到 SRP Batcher 的兼容性状态。</p><blockquote><p>UnityPerDraw 这部分内容 URP 的 Core.hlsl 都帮我们做好了，若引入了 Core.hlsl 理论上不用关心这部分内容，只需要在自己的 Shader 里关心 UnityPerMaterial 这部分就行。若要编写自己的 Custom SRP，则需要自己加入 UnityPerDraw，即对一些内置的 Unity 自动更新的矩阵进行定义（比如 unity_ObjectToWorld，这些矩阵每次 draw call 都会被 GPU 设置），可以参考 URP 的 Core.hlsl -&gt; Input.hlsl -&gt; UnityInput.hlsl。</p></blockquote><pre><code>CBUFFER_START(UnityPerDraw)float4x4 unity_ObjectToWorld;float4x4 unity_WorldToObject;float4 unity_LODFade;real4 unity_WorldTransformParams;CBUFFER_ENDCBUFFER_START(UnityPerMaterial)float4 _BaseColor;CBUFFER_END</code></pre><p>SRP Batcher 主要减少不同 draw call 之间的渲染状态转换。原本，CPU 每次提交 Draw Call 前都要 Set up Cbuffer - Upload Cbuffer，但是在 SRP Batcher 里，所有材质球在显存里占有固定的 CBuffer，如果材质球的内容不发生改变，CPU 就不需要 Set Up - Upload，从而降低了 CPU 渲染时间。</p><h3 id="GPU-instancing"><a href="#GPU-instancing" class="headerlink" title="GPU instancing"></a>GPU instancing</h3><p>GPU instancing 适用于处理大量相同物体（同一 Mesh 和同一 Material），比如建筑物/树/草等重复出现的物体。注意 GPU instancing 和 SRP Batcher 不兼容。若要使用 GPU instancing 需要移除 SRP Batcher 兼容性，否则根据优先级，Unity 会自动选择 SRP Batcher。</p><p>要想使用 GPU instancing 需要满足以下条件：<br>①材质的 Shader 需要支持 GPU instancing，见后面；<br>②网格必须有一个 MeshRenderer 组件，或是由 Graphics.DrawMesh 产生，或是由 Graphics.DrawMeshInstanced、Graphics.DrawMeshIndirect 产生。不支持 SkinnedMeshRenderer；  </p><p>GPU instancing 允许实例物体具有不同的 Transform，但如果想要创建更多的变体，比如不同颜色的变体，你需要修改 shader 添加 pre-instance 属性。自定义的 shader 没有 pre-instance 的数据，需要使用 <code>UNITY_SETUP_INSTANCE_ID</code> 添加一个实例 ID，表面着色器会自动创建实例 ID，然后在脚本中通过 MaterialPropertyBlock 修改实例的颜色。</p><p>创建支持 GPU instancing 的 Shader 的步骤如下：<br><strong>①</strong>第一步在 shader 的顶点和片元着色器的指令前添加 <code>#pragma multi_compile_instancing</code></p><pre><code>    #pragma multi_compile_instancing    #pragma vertex UnlitPassVertex    #pragma fragment UnlitPassFragment</code></pre><p>这会让 Unity 生成两个 shader 变体，一个支持 GPU instancing 一个不支持，我们可以在材质的 inspector 面板中选择是否 <strong>Enable GPU instancing</strong> 让材质使用相应的 shader。</p><p><strong>②</strong>支持 GPU instancing 需要引入 core shader library 的 UnityInstancing.hlsl 文件，但是若引入 URP 的 Core.hlsl，则不需要再重复引入了，因为 Core.hlsl 都帮我们处理好了，可以在 Core.hlsl 引入的 Input.hlsl 最下面看到以下代码：  </p><pre><code>    #define UNITY_MATRIX_M unity_ObjectToWorld    ...    #include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/UnityInput.hlsl&quot;    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl&quot;    ...    #include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl&quot;</code></pre><p><strong>③</strong>UnityInstancing.hlsl 的工作包括对矩阵相关宏进行重定义使其可以被替换为 instanced data arrays。但是为了让其工作，还需知道当前渲染物体的索引，因为不同实例的变换矩阵不同，这些索引需要在顶点着色器的输入结构中被提供，我们只需将 <code>UNITY_VERTEX_INPUT_INSTANCE_ID</code> 放在 Attributes 结构中，如下：  </p><pre><code>    struct Attributes &#123;        float3 positionOS : POSITION;        UNITY_VERTEX_INPUT_INSTANCE_ID    &#125;;</code></pre><p><strong>④</strong>然后在定制着色器函数的开头添加 <code>UNITY_SETUP_INSTANCE_ID(input);</code>，这会提取 input 中的索引并把它存储为一个全局静态变量，让其他 instancing 的宏使用它，如下：  </p><pre><code>    float4 UnlitPassVertex (Attributes input) : SV_POSITION &#123;        UNITY_SETUP_INSTANCE_ID(input);        float3 positionWS = TransformObjectToWorld(input.positionOS);        return TransformWorldToHClip(positionWS);    &#125;</code></pre><p><strong>⑤</strong>为了取消 SRP batcher 兼容性，我们还需要修改 CBUFFER，替换为 <code>UNITY_INSTANCING_BUFFER_START</code> 和 <code>UNITY_INSTANCING_BUFFER_END</code>，从而支持  per-instance material data。还要替换属性声明，比如 _BaseColor 替换为 <code>UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)</code> ：   </p><pre><code>    UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)        UNITY_DEFINE_INSTANCED_PROP(float4, _BaseColor)    UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)</code></pre><p><strong>⑥</strong>接下来是为了让片元着色器也能获取到实例索引，我们需要在顶点着色器的输出结构添加 <code>UNITY_VERTEX_INPUT_INSTANCE_ID</code>，并且在顶点着色器中使用 <code>UNITY_TRANSFER_INSTANCE_ID(input, output);</code> 来复制索引：  </p><pre><code>    struct Varyings &#123;        float4 positionCS : SV_POSITION;        UNITY_VERTEX_INPUT_INSTANCE_ID    &#125;;    Varyings UnlitPassVertex (Attributes input) &#123;        Varyings output;        UNITY_SETUP_INSTANCE_ID(input);        UNITY_TRANSFER_INSTANCE_ID(input, output);        float3 positionWS = TransformObjectToWorld(input.positionOS);        output.positionCS = TransformWorldToHClip(positionWS);        return output;    &#125;</code></pre><p><strong>⑦</strong>最后，在片元着色器中使用 <code>UNITY_SETUP_INSTANCE_ID(input);</code> 让索引可用。材质的属性现在需要通过 <code>UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor);</code> 获取：  </p><pre><code>    float4 UnlitPassFragment (Varyings input) : SV_TARGET &#123;        UNITY_SETUP_INSTANCE_ID(input);        return UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor);    &#125;</code></pre><h1 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h1><h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>首先在 SubShader 的 Tags 里把渲染队列设为 Transparent：<code>&quot;Queue&quot; = &quot;Transparent&quot;</code>。可以在材质添加 _SrcBlend 和 _DstBlend 属性，以及深度写入 Zwrite 的开关属性，如下：  </p><pre><code>    Properties &#123;        _BaseColor(&quot;Color&quot;, Color) = (1.0, 1.0, 1.0, 1.0)        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (&quot;Src Blend&quot;, Float) = 1        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (&quot;Dst Blend&quot;, Float) = 0        [Enum(Off, 0, On, 1)] _ZWrite (&quot;Z Write&quot;, Float) = 1    &#125;</code></pre><p><code>[Enum(UnityEngine.Rendering.BlendMode)]</code> 特性可以让我们在材质面板中选择混合模式，不透明的 _SrcBlend 为 1，_DstBlend 为 0；一般透明度混合，_SrcBlend 为 ScrAlpha，_DstBlend 为 OneMinusSrcAlpha。详见 Unity Shader 入门精要。</p><p>然后在 Pass 中添加混合命令，以及深度写入开关命令：  </p><pre><code>    Blend [_SrcBlend] [_DstBlend]    ZWrite [_ZWrite]</code></pre><h2 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h2><p>添加 _Cutoff 阈值属性：  </p><pre><code>    _Cutoff (&quot;Alpha Cutoff&quot;, Range(0.0, 1.0)) = 0.5</code></pre><p>别忘了在 CBuffer 里声明属性。接下来在片元着色器用 Clip 函数进行裁切：  </p><pre><code>    clip(_BaseColor.a - _Cutoff)</code></pre><p>我们可以在材质属性中添加 <code>Toggle</code> 特性来控制一个 _CLIPPING 关键字，该特性让我们可以选择是否开启透明度测试：  </p><pre><code>    [Toggle(_CLIPPING)] _Clipping (&quot;Alpha Clipping&quot;, Float) = 0</code></pre><p>如果在材质面板中开启了透明度测试，就会自动添加 _CLIPPING 关键字到材质的激活的关键字表里，关闭就去除。我们可以根据关键字是否被定义，来告诉 Unity 编写不同的 shader。首先我们需要在 Pass 中添加 <code>#pragma shader_feature _CLIPPING</code> 指令：  </p><pre><code>    #pragma shader_feature _CLIPPING</code></pre><p>这样 Unity 就可以根据 _CLIPPING 是否被定义来编译 shader 代码，然后修改 Clip 函数：  </p><pre><code>    #if defined(_CLIPPING)        clip(_BaseColor.a -  _Cutoff);    #endif</code></pre><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>①新建一个名为 Transparency.shader 的 shader 文件，代码如下：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/Transparency&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [Header(Base)] <span class="comment">//在材质面板中插入标题</span></span><br><span class="line">        [Space(<span class="number">12</span>)] <span class="comment">//在材质面板中插入多行空行</span></span><br><span class="line">        _BaseColor(<span class="string">&quot;Base Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _BaseMap(<span class="string">&quot;Base Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        [Header(Transparency)] <span class="comment">//在材质面板中插入标题</span></span><br><span class="line">        [Space(<span class="number">12</span>)] <span class="comment">//在材质面板中插入多行空行</span></span><br><span class="line">        [Toggle(_CLIPPING)] _Clipping (<span class="string">&quot;Alpha Clipping&quot;</span>, Float) = <span class="number">0</span> <span class="comment">//开关透明度测试</span></span><br><span class="line">        _Cutoff(<span class="string">&quot;Alpha CutOff&quot;</span>, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.5</span> <span class="comment">//裁切阈值</span></span><br><span class="line">        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (<span class="string">&quot;Src Blend&quot;</span>, Float) = <span class="number">1</span> <span class="comment">//混合因子</span></span><br><span class="line">        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (<span class="string">&quot;Dst Blend&quot;</span>, Float) = <span class="number">0</span> <span class="comment">//混合因子</span></span><br><span class="line">        [Enum(Off, <span class="number">0</span>, On, <span class="number">1</span>)] _ZWrite (<span class="string">&quot;Z Write&quot;</span>, Float) = <span class="number">1</span> <span class="comment">//开关深度写入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalPipeline&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span> &#125; <span class="comment">//渲染队列为 Transparent</span></span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;TransparencyForwardUnlit&quot;</span> <span class="comment">//Pass 命名</span></span><br><span class="line">            </span><br><span class="line">            Blend [_SrcBlend] [_DstBlend] <span class="comment">//混合命令</span></span><br><span class="line">            ZWrite [_ZWrite] <span class="comment">//深度写入开关</span></span><br><span class="line">            </span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> shader_feature _CLIPPING <span class="comment">//控制 shader 变体</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Assets/ShaderLibrary/TransparencyPass.hlsl&quot;</span> <span class="comment">//引入 HLSL 文件，见下面</span></span></span><br><span class="line">            </span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②在 ShaderLibrary 创建名为 TransparencyPass.hlsl 的 HLSL 文件，代码如下：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionOS   : POSITION;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionHCS  : SV_POSITION;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEXTURE2D(_BaseMap);</span><br><span class="line">SAMPLER(sampler_BaseMap);</span><br><span class="line"></span><br><span class="line">CBUFFER_START(UnityPerMaterial)</span><br><span class="line">half4 _BaseColor;</span><br><span class="line">float4 _BaseMap_ST;  <span class="comment">//别忘了这个</span></span><br><span class="line"><span class="type">float</span> _Cutoff;</span><br><span class="line">CBUFFER_END</span><br><span class="line"></span><br><span class="line">Varyings <span class="title function_">vert</span><span class="params">(Attributes IN)</span> &#123;</span><br><span class="line">    Varyings OUT;</span><br><span class="line">    OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);</span><br><span class="line">    OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);</span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 <span class="title function_">frag</span><span class="params">(Varyings IN)</span> : SV_Target &#123;</span><br><span class="line">    half4 color = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv); <span class="comment">//纹理采样</span></span><br><span class="line">    color *= _BaseColor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(_CLIPPING)</span></span><br><span class="line">        clip(color.r -  _Cutoff); <span class="comment">//这里选择 r 是因为希望根据纹理的颜色来裁切</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样就得到了一个包含了透明度混合和透明度测试的 Shader，材质面板如下图：  </p><div  align="center">  <img src="https://s2.loli.net/2024/02/24/fFWhj2K1R7vkYCL.jpg" width = "60%" height = "60%" alt="图1 - 包含透明度混合和透明度测试的材质"/></div><p>我选择的是一张<strong>高斯噪声纹理 Gaussian Noise</strong>，我让纹理颜色与基础颜色相乘后若小于 0.85 则被裁切掉，透明度混合是基础的 ScrAlpha 和 OneMinusScrAlpha 即根据 Alpha 值混合，关闭深度写入防止渲染错误，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2024/02/24/GFzAeuNrxDbgOyo.png" width = "70%" height = "70%" alt="图2 - 透明度混合和透明度测试的效果"/></div><h1 id="GPU-instancing-实践"><a href="#GPU-instancing-实践" class="headerlink" title="GPU instancing 实践"></a>GPU instancing 实践</h1><p>接下来根据上面的实践的 shader，改造为使用 GPU instancing 的 shader。TransparencyGPUInstancing.shader 的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/TransparencyGPUInstaning&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        [Header(Base)]</span><br><span class="line">        [Space(<span class="number">12</span>)]</span><br><span class="line">        _BaseColor(<span class="string">&quot;Base Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _BaseMap(<span class="string">&quot;Base Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        [Header(Transparency)]</span><br><span class="line">        [Space(<span class="number">12</span>)]</span><br><span class="line">        [Toggle(_CLIPPING)] _Clipping (<span class="string">&quot;Alpha Clipping&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">        _Cutoff(<span class="string">&quot;Alpha CutOff&quot;</span>, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.5</span></span><br><span class="line">        [Enum(UnityEngine.Rendering.BlendMode)] _SrcBlend (<span class="string">&quot;Src Blend&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">        [Enum(UnityEngine.Rendering.BlendMode)] _DstBlend (<span class="string">&quot;Dst Blend&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">        [Enum(Off, <span class="number">0</span>, On, <span class="number">1</span>)] _ZWrite (<span class="string">&quot;Z Write&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;RenderPipeline&quot;</span> = <span class="string">&quot;UniversalPipeline&quot;</span> <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Name <span class="string">&quot;TransparencyGPUInstaningForwardUnlit&quot;</span></span><br><span class="line">            </span><br><span class="line">            Blend [_SrcBlend] [_DstBlend]</span><br><span class="line">            ZWrite [_ZWrite]</span><br><span class="line">            </span><br><span class="line">            HLSLPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> shader_feature _CLIPPING</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_instancing <span class="comment">//生成支持或不支持 GPU instancing 的 shader 变体</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../ShaderLibrary/TransparencyGPUInstaningPass.hlsl&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 Shader 中引入的 TransparencyGPUInstaningPass.hlsl 代码如下：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入 Core.hlsl 了就不需要重复引入 UnityInstancing.hlsl 了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Attributes</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionOS   : POSITION;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID <span class="comment">//为顶点着色器的输入输出结构定义 instance ID</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Varyings</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 positionHCS  : SV_POSITION;</span><br><span class="line">    float2 uv           : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID <span class="comment">//使用这个是为了在片元着色器获取 instanced 属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEXTURE2D(_BaseMap);</span><br><span class="line">SAMPLER(sampler_BaseMap);</span><br><span class="line"></span><br><span class="line">UNITY_INSTANCING_BUFFER_START(UnityPerMaterial) <span class="comment">//声明 per-instance 的 CBuffer</span></span><br><span class="line">    UNITY_DEFINE_INSTANCED_PROP(half4, _BaseColor) <span class="comment">//定义 per-instance 的属性</span></span><br><span class="line">    UNITY_DEFINE_INSTANCED_PROP(float4, _BaseMap_ST)</span><br><span class="line">    UNITY_DEFINE_INSTANCED_PROP(<span class="type">float</span>, _Cutoff)</span><br><span class="line">UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)</span><br><span class="line"></span><br><span class="line">Varyings <span class="title function_">vert</span><span class="params">(Attributes IN)</span> &#123;</span><br><span class="line">    Varyings OUT;</span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(IN); <span class="comment">//允许着色器函数获取 instance ID</span></span><br><span class="line">    UNITY_TRANSFER_INSTANCE_ID(IN, OUT); <span class="comment">//从输入结构复制 instance ID 到输出结构</span></span><br><span class="line">    OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);</span><br><span class="line">    float4 baseST = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseMap_ST); <span class="comment">//获取 per-instance 属性</span></span><br><span class="line">    OUT.uv = IN.uv * baseST.xy + baseST.zw;</span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 <span class="title function_">frag</span><span class="params">(Varyings IN)</span> : SV_Target &#123;</span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(IN); <span class="comment">//允许着色器函数获取 instance ID</span></span><br><span class="line">    half4 mapColor = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, IN.uv);</span><br><span class="line">    half4 baseColor = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _BaseColor); <span class="comment">//获取 per-instance 属性</span></span><br><span class="line">    half4 color = half4(mapColor.rgb * baseColor.rgb, baseColor.a);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(_CLIPPING)</span></span><br><span class="line">    clip(mapColor.r -  UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, _Cutoff)); <span class="comment">//获取 per-instance 属性</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样子材质部分就准备好了，接下来为了方便生成大量的物体，并生成不同的颜色，使用了下面的脚本代码（MeshBall.cs）：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MeshBall</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> baseColorId = Shader.PropertyToID(<span class="string">&quot;_BaseColor&quot;</span>); <span class="comment">//找到 _BaseColor 材质属性的 ID，每个 shader 属性都有个独特的数字 ID，并在游戏中保持不变。</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Mesh mesh; <span class="comment">//要生成的 mesh</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Material material; <span class="comment">//要生成的 mesh 的材质</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了生成 1023 个实例，我们需要告诉 Unity 它们的变换矩阵和颜色</span></span><br><span class="line">    <span class="keyword">private</span> Matrix4x4[] matrices = <span class="keyword">new</span> Matrix4x4[<span class="number">1023</span>];</span><br><span class="line">    <span class="keyword">private</span> Vector4[] baseColors = <span class="keyword">new</span> Vector4[<span class="number">1023</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//MaterialPropertyBlock 适用于需要画出使用相同材质但不同材质属性的多个物体，传递给 Graphics.RenderMesh 或 Renderer.SetPropertyBlock 时会被复制，所以创建一个 block 一直复用最佳。我们使用它来传递颜色数组。</span></span><br><span class="line">    <span class="keyword">private</span> MaterialPropertyBlock block;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; matrices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用 Matrix4x4.TRS 创建了一个在半径十米的球内的随机位置的，无旋转和缩放的变换矩阵</span></span><br><span class="line">            matrices[i] = Matrix4x4.TRS(Random.insideUnitSphere * <span class="number">10f</span>, Quaternion.identity, Vector3.one ); </span><br><span class="line">            <span class="comment">//随机颜色</span></span><br><span class="line">            baseColors[i] = <span class="keyword">new</span> Vector4(Random.<span class="keyword">value</span>, Random.<span class="keyword">value</span>, Random.<span class="keyword">value</span>, Random.<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (block == <span class="literal">null</span>) &#123;</span><br><span class="line">            block = <span class="keyword">new</span> MaterialPropertyBlock();</span><br><span class="line">            block.SetVectorArray(baseColorId, baseColors); <span class="comment">//设置颜色到 block</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//画出使用 GPU Instancing 的大量相同 mesh，并赋予材质、变换矩阵、数量以及材质属性块</span></span><br><span class="line">        Graphics.DrawMeshInstanced(mesh, <span class="number">0</span>, material, matrices, <span class="number">1023</span>, block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把该代码赋给任意空物体上，如下：  </p><div  align="center">  <img src="https://s2.loli.net/2024/02/25/FXb9O6YrP34jem7.jpg" width = "70%" height = "70%" alt="图3 - 附上 mesh 和材质后的 MeshBall.cs"/></div><p>在材质上别忘了开启 GPU Instancing：  </p><div  align="center">  <img src="https://s2.loli.net/2024/02/25/btBDClwi64aYVq7.jpg" width = "70%" height = "70%" alt="图4 - 勾选 Enable GPU Instancing"/></div><p>运行游戏效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2024/02/25/4PqBzvnHjCu2pNO.png" width = "90%" height = "90%" alt="图5 - 1023 个透明球体"/></div><div  align="center">  <img src="https://s2.loli.net/2024/02/25/evZMxzK3yJQbm24.jpg" width = "50%" height = "50%" alt="图6 - 画这些透明物体只使用了 3 个 draw call"/></div><h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1>]]></content>
      
      
      <categories>
          
          <category> unity </category>
          
          <category> unity shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> unity </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 线性代数公开课笔记（三）</title>
      <link href="/2024/02/22/2024-02-22-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%803/"/>
      <url>/2024/02/22/2024-02-22-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%803/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该笔记主要内容为XXXXXXXXXXXXX；<br>该笔记主要参考了 MLNLP 的关于该公开课的 GitHub 公开项目的笔记：<a href="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes">https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes</a><br>公开课 B 站 bv 号：BV16Z4y1U7oU</p></blockquote><h1 id="第十四课"><a href="#第十四课" class="headerlink" title="第十四课"></a>第十四课</h1>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 3d数学基础 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 线性代数公开课笔记（二）</title>
      <link href="/2024/02/18/2024-02-18-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%802/"/>
      <url>/2024/02/18/2024-02-18-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%802/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该笔记主要内容为XXXXXXXXXXXXX；<br>该笔记主要参考了 MLNLP 的关于该公开课的 GitHub 公开项目的笔记：<a href="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes">https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes</a><br>公开课 B 站 bv 号：BV16Z4y1U7oU</p></blockquote><h1 id="第十四课-正交向量与正交子空间"><a href="#第十四课-正交向量与正交子空间" class="headerlink" title="第十四课 正交向量与正交子空间"></a>第十四课 正交向量与正交子空间</h1><div  align="center">  <img src="https://s2.loli.net/2024/02/18/iwvTI9XHNrf4QjB.png" width = "60%" height = "60%" alt="图4 - 四个子空间的关系"/></div><h2 id="向量正交"><a href="#向量正交" class="headerlink" title="向量正交"></a>向量正交</h2><p><strong>正交 Orthogonal </strong>就是<strong>垂直 perpendicular</strong> 的另一种说法。两向量正交的判据之一是其点积 $\,x^Ty = y^Tx = 0\,$。</p><p>可以根据勾股定理（毕达哥拉斯定理 Pythagorean theorem）推出上述判断，当两个向量的夹角为 90 度时，x，y 满足：  </p><script type="math/tex; mode=display">|x|^2 + |y|^2 = |x + y|^2</script><p>其中 $\,|x|^2 = x^Tx\,$（x 为 列向量），可得：</p><script type="math/tex; mode=display">x^Tx + y^Ty = (x + y)^T(x + y) = x^Tx + y^Ty + x^Ty + y^Tx</script><p>可得 $\,x^Ty + y^Tx = 0\,$，因 $\,x^Ty\,$ 与 $\,y^Tx\,$ 其实是一样的，都表示两个一维向量的点乘，故若两个向量正交，则 $\,x^Ty = y^Tx = 0\,$。</p><blockquote><p>零向量与所有向量都正交。</p></blockquote><h2 id="子空间正交"><a href="#子空间正交" class="headerlink" title="子空间正交"></a>子空间正交</h2><p><strong>两个子空间正交</strong>就是：<strong>一个子空间中的任意一个向量，都与另一个子空间中的任意一个向量正交。</strong></p><p>在三维空间中，假设世界原点为黑板和地板交接处的一点，黑板所在的平面（子空间）和地板所在平面（子空间）不是正交关系，沿两者的交线方向的向量同时属于两个平面，但并不与自己正交。即两个平面在某一非零向量处相交，那这两个平面一定不正交，因为相交处的这个非零向量无法满足空间正交定义。</p><p>再从子空间角度看一看正交空间，以 $\,R^2\,$ 的子空间为例，一个平面上的子空间有三种：<br>①整个平面 D；<br>②过原点的直线 L；<br>③原点 O。</p><p>看一看这些子空间之间的正交，以 L 为例：<br>①L 与 D 什么时候正交？<br>一个平面上的直线不可能与这个平面垂直；<br>②L 什么时候与 O 正交？<br>L 与 O 永远是正交的；<br>③L 什么时候与另一个 L 正交？<br>由正交的定义，两条直线在原点处互相垂直，这两个 L 空间才正交。</p><h2 id="零空间与行空间的正交关系"><a href="#零空间与行空间的正交关系" class="headerlink" title="零空间与行空间的正交关系"></a>零空间与行空间的正交关系</h2><p>零空间与行空间之间是正交的，得到这个结论并不难，我们把 A 写成行向量形式，再看 Ax = 0 这个方程：  </p><script type="math/tex; mode=display">\begin{bmatrix} R_1 \\ R_2 \\ ... \\ ... \\ R_m \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \\ ... \\ ... \end{bmatrix} = \begin{bmatrix} R_1(x_1, x_2, ...) \\ R_2(x_1, x_2, ...) \\ ... \\ ... \\ R_m(x_1, x_2, ...) \end{bmatrix} = \begin{bmatrix} 0 \\ 0 \\ ... \\ ... \\ 0 \end{bmatrix}</script><p>x 与矩阵 A 的行向量点积都等于 0，则它和矩阵 A 行向量的线性组合进行点积也为 0，所以 x 与 A 的行空间正交。x 为零空间内的任意向量，所以零空间与行空间正交。同理可以证明列空间与左零空间正交。</p><hr><p>行空间和零空间类似于把 $\,R^n\,$ 空间分割成了两个正交的子空间。例如对于矩阵：$\,A = \begin{bmatrix} 1 &amp; 2 &amp; 5 \\ 2 &amp; 4 &amp; 10 \end{bmatrix}\,$，其行空间是 1 维的，向量 (1, 2, 5) 是它的基向量，而其零空间是垂直于 (1, 2, 5) 并穿过原点的二维平面。行空间和零空间不仅仅是正交，并且其维数之和等于 n，我们称行空间和零空间为 $\,R^n\,$ 空间内的<strong>正交补 orthogonal complements</strong>。这表示零空间包含所有和行空间正交的向量，反之亦然。</p><blockquote><p>想想我们之前提到的黑板和地板平面不是正交子空间的例子，二者都在三维空间中，分别为二维空间，因此不可能正交。一个空间中正交子空间的维数之和不可能超过原空间的维数。</p></blockquote><h2 id="无解方程的最优解"><a href="#无解方程的最优解" class="headerlink" title="无解方程的最优解"></a>无解方程的最优解</h2><p>下面讨论如何求解一个无解方程组 Ax = b 的解（引出下一节的内容）。矩阵的数据来源于实际测量，那么就势必会有测量不准确的时候，如果 A 是长方形矩阵，m 大于 n。当左侧方程数特别多的时候，容易混入“坏”数据，方程变得无解。但是对于数据的可信度我们无从判断，线性代数要做的就是在这种条件下求一个方程的“最优解”。矩阵 $\,A^TA\,$ 会发挥重要作用，它是一个 n x n 方阵，并且是对称矩阵。</p><p>将方程改写成：$\,A^TA \hat {x} = A^Tb\,$，即求解 $\,\hat {x}\,$ 这个最优解。我们利用了 $\,A^TA\,$ 矩阵的特殊性质如下：<br>①设 A 为 m × n 矩阵，则 $\,A^TA\,$ 为 n × n 矩阵；<br>②$\,A^TA\,$，总为对称矩阵。$\,(A^TA)^T = A^TA\,$，故 $\,A^TA\,$ 总是对称的。</p><p>有一点需要注意，$\,A^TA\,$ 矩阵不一定总是可逆的，所以在求解时要注意 A 的特点。很明显，当 A 矩阵列向量线性相关时候，$\,A^TA\,$ 就不可逆了。因此若要 $\,A^TA\,$ 矩阵可逆，则要求 A 的零空间只有零向量，即 A 的列向量线性无关。</p><h1 id="第十五课-子空间投影"><a href="#第十五课-子空间投影" class="headerlink" title="第十五课 子空间投影"></a>第十五课 子空间投影</h1><p>这节主要讲<strong>投影 projection</strong>，从向量的投影入手，延伸到高维投影，并将投影用矩阵形式给出。做投影即是向另一个向量上做垂线，跟上节课的正交有联系。</p><h2 id="向量投影"><a href="#向量投影" class="headerlink" title="向量投影"></a>向量投影</h2><div  align="center">  <img src="https://s2.loli.net/2024/02/19/xU4EQOj73XNgM2F.jpg" width = "50%" height = "50%" alt="图5 - 向量投影"/></div><p>投影问题的几何解释就是：如何在向量 a 的方向上寻找与向量 b 距离最近的一点。从图中可以看出，这个距离最近的点 p 就位于穿过 b 点并与向量 a 正交的直线与向量 a 所在直线的交点，即 b 在 a 上的投影。</p><blockquote><p>如果我们将向量 p 视为 b 的一种近似，则长度 e = b - p 就是这一近似的误差。</p></blockquote><p>因为 p 在向量 a 的方向上，因此可以令 p = xa，而因为它和 e 正交，我们可以得到方程：  </p><script type="math/tex; mode=display">a^Te = a^T(b - p) = a^T(b - xa) = 0</script><p>可得：  </p><script type="math/tex; mode=display">x = \frac {a^Tb} {a^Ta}, p = xa = a \frac {a^Tb} {a^Ta}</script><p>如果 b 变为原来的 2 倍，则 p 也变为原来的 2 倍。而如果 a 变为原来的 2 倍，p 不发生变化。从几何上和计算中都会得到验证。</p><h2 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h2><p>接下来我们将投影问题用投影矩阵的方式进行描述，即 $\,p = Pb\,$，其中 $\,P\,$ 为投影矩阵。</p><p>根据 $\,p = xa = a \frac {a^Tb} {a^Ta}\,$，可知 $\,P = \frac {aa^T} {a^Ta}\,$，注意当 a 是列向量时，分母 $\,a^Ta\,$ 是一个数，分子 $\,aa^T\,$ 是一个矩阵。</p><p>观察这个矩阵可知，因为 a 是列向量，$\,aa^T\,$ 得到的必然是秩一矩阵，矩阵 P 的列空间就是向量 a 所在的直线，矩阵 P 的秩为 1。同样，投影矩阵 P 是一个对称矩阵，即 $\,P^T = P\,$；另一方面，如果投影两次，第二次投影还在原来的位置，即 $\,P^2 = P\,$。</p><h2 id="Why-Project"><a href="#Why-Project" class="headerlink" title="Why Project"></a>Why Project</h2><p>如上一节结尾所述，方程 Ax = b 有可能无解，我们需要得到方程的“最优解”。这里的问题在于向量 Ax 一定在矩阵 A 的列空间之内，但是 b 不一定，因此我们希望将 b 投影到 A 的列空间得到 p，将问题转化为 $\,A\hat {x} = p\,$。</p><h2 id="平面投影"><a href="#平面投影" class="headerlink" title="平面投影"></a>平面投影</h2><div  align="center">  <img src="https://s2.loli.net/2024/02/19/7uG81TXxNLzUKnQ.jpg" width = "50%" height = "50%" alt="图6 - 平面投影"/></div><p>$\,a_1\,$，$\,a_2\,$ 构成平面的一组基，平面是矩阵 $\,A = \begin{bmatrix} a_1 &amp; a_2\end{bmatrix}\,$ 的列空间。</p><p>p 在平面上，即 $\,p = \hat {x_1} a_1 + \hat {x_2} a_2\,$，即 $\,p = A\hat {x}\,$。</p><p>而 $\,e = b - p = b - A \hat {x}\,$ 与投影平面正交，也就是 $\,e\,$ 与 $\,a_1\,$ 和 $\,a_2\,$ 均正交，可得 $\,a_1^T(b - A \hat {x}) = 0\,$ 和 $\,a_2^T(b - A \hat {x}) = 0\,$。</p><p>因为 $\,a_1\,$ 和 $\,a_2\,$ 分别为矩阵 A 的列向量，即 $\,a_1^T\,$ 和 $\,a_2^T\,$ 为矩阵 $\,A^T\,$ 的行向量，所以将两个方程式写成矩阵形式即为 $\,A^T(b - A \hat {x}) = 0\,$，这与一维投影的方程形式相同，一维投影只是 A 只有一列的情况下。</p><p>$\,A^T(b - A \hat {x}) = 0\,$ 这个公式说明了，向量 $\,e = b - A \hat {x}\,$ 存在于矩阵 $\,A^T\,$ 的零空间 $\,N(A^T)\,$ ，即 e 向量与 $\,A^T\,$ 的行向量正交，也就与 A 的列向量正交。</p><hr><p>将方程 $\,A^T(b - A \hat {x}) = 0\,$ 改写，可得 $\,A^TA \hat {x} = A^Tb\,$，也就是上一节结尾的公式。</p><p>我们要注意一点：不能直接在两边左乘 $\,(A^T)^{-1}\,$。因为 $\,A^T\,$ 不一定是方阵，不一定有逆矩阵。但是这里 A 为两个基向量构成的矩阵，两个基向量线性无关，根据上节的知识，$\,A^TA\,$是可逆的。在两侧同时左乘 $\,(A^TA)^{-1}\,$：</p><script type="math/tex; mode=display">\hat x = (A^TA)^{-1} A^T b</script><p>代入 $p = A \hat {x}$：  </p><script type="math/tex; mode=display">p = A \hat x = A(A^TA)^{-1} A^T b</script><p>即投影矩阵为：  </p><script type="math/tex; mode=display">P =  A(A^TA)^{-1} A^T</script><p>可以看出，之前一维的 $\,P = \frac {aa^T} {a^Ta}\,$ 是上式的特殊情况。</p><p>因为矩阵 A 不是方阵，无法简单地用 $\,(A^TA)^{-1} = A^{-1}(A^T)^{-1}\,$ 对投影矩阵进行化简。若 A 是可逆方阵，则化简得到 P = I。此时 A 的列空间就是整个 $\,R^n\,$ 空间，b 到这个空间的投影就是其本身，投影矩阵等于单位阵。</p><p>对 $\,P =  A(A^TA)^{-1} A^T\,$ 用矩阵乘法的结合律和矩阵乘积的转置公式，可以证明投影矩阵的性质：$\,P^T = P\,$，$\,P^2 = P\,$。</p><h2 id="最小二乘法-Least-Squares-初涉"><a href="#最小二乘法-Least-Squares-初涉" class="headerlink" title="最小二乘法 Least Squares 初涉"></a>最小二乘法 Least Squares 初涉</h2><p>应用投影矩阵求方程组最优解的方法，最常用于“最小二乘法”拟合曲线。</p><p>例如：求解三个点（1，1），（2,2），（3，2）拟合的直线方程</p><p>我们假设最优直线方程：b = C + Dt，代入三个点列出方程。</p><script type="math/tex; mode=display">C + D = 1</script><script type="math/tex; mode=display">C + 2D = 2</script><script type="math/tex; mode=display">C + 3D = 2</script><p>矩阵形式为：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 1 \\ 1 & 2 \\ 1 & 3 \end{bmatrix} \begin{bmatrix} C \\ D \end{bmatrix} = \begin{bmatrix} 1 \\ 2 \\ 2 \end{bmatrix}</script><p>这个的方程 Ax = b 是无解的，解决办法就是求其最优解，即方程 $\,A^TA \hat {x} = A^Tb\,$ 的解。</p><p>最小二乘法下节还会详述。</p><h1 id="第十六课-投影矩阵和最小二乘法"><a href="#第十六课-投影矩阵和最小二乘法" class="headerlink" title="第十六课 投影矩阵和最小二乘法"></a>第十六课 投影矩阵和最小二乘法</h1><h2 id="投影矩阵回顾"><a href="#投影矩阵回顾" class="headerlink" title="投影矩阵回顾"></a>投影矩阵回顾</h2><p>上一节中介绍过投影矩阵 P，即：  </p><script type="math/tex; mode=display">P = A(A^TA)^{-1}A^T</script><p>投影矩阵 P 与一向量 b 的乘积可以理解为：将 b 向量投影到它在列空间中的最近一点上，类似于上节课中，将 p 投影到平面上的过程。</p><p>两个问题：  </p><p>①如果 b 在矩阵 A 的列空间里，则 Pb = ？  </p><p>此时 Pb = b，因为 b 本身就在 A 列空间中。b 在 A 的列空间里，就一定可以写成：$\,Ax = b\,$。代入投影矩阵：$\,A(A^TA)^{-1}A^TAx = A(A^TA)^{-1}(A^TA)x = Ax = b\,$</p><p>②如果 b 垂直于 A 的列空间，则 Pb = ？<br>此时 Pb = 0，此时没有投影。b 垂直于 A 的列空间，也就垂直于 A 的所有列向量，故 b 在左零空间中，即 $\,A^Tb = 0\,$。代入投影矩阵：$\,A(A^TA)^{-1}A^Tb = A(A^TA)^{-1}0 = 0\,$</p><p>通过上面两个问题，我们可以看出来，一个向量 b 总有两个分量，一个分量在 A 的列空间中，另一个分量垂直于 A 的列空间。而投影矩阵的作用就是保留列空间中的那个分量，拿掉垂直于列空间的分量。</p><div  align="center">  <img src="https://s2.loli.net/2024/02/21/iTJeK6R5ts7OSVL.jpg" width = "30%" height = "30%" alt="图7 - 投影矩阵的理解"/></div><p>$\,b = p + e\,$，p 就是投影矩阵作用于 b 上得到的向量，而 e 这个左零空间中的分量，如果也用类似投影矩阵来表示的话，就是：$\,p = Pb\,$，$\,e = b - p = b - Pb = (I - P)b \,$。$\,I-P\,$可以看作是左零空间的投影矩阵，并且 $\,(I - P)^T = I - P\,$，$\,(I - P)^2 = I - P\,$。</p><h2 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h2><p>接着上节课的例子：  </p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 1 \\ 1 & 2 \\ 1 & 3 \end{bmatrix} \begin{bmatrix} C \\ D \end{bmatrix} = \begin{bmatrix} 1 \\ 2 \\ 2 \end{bmatrix}</script><p>这个的方程 Ax = b 是无解的，解决办法就是求其最优解，最优解的含义即为直线与各点之间的误差（偏移量）最小，为了便于计算，研究它们的平方和：$\,|e|^2 = |Ax - b|^2\,$，因此就是寻找具有最小误差平方和的解 x，这就是所谓的“最小二乘”问题。</p><div  align="center">  <img src="https://s2.loli.net/2024/02/21/bdhuCi1Zo9qctK2.jpg" width = "30%" height = "30%" alt="图8 - 误差"/></div><p>从几何上讨论求解过程，就是试图寻找数据点到直线距离的平方和 $\,e_1^2 + e_2^2 + e_3^2\,$ 最小的情况。另一种看法是，对于 $\,R^3\,$ 空间上的向量 b，它投影到矩阵 A 的列空间中会得到向量 p = [p1 p2 p3]，投影到矩阵 A 的左零空间中则为 e。</p><p>计算如下，使用上节课中我们介绍的方程：  </p><script type="math/tex; mode=display">A^TA \hat {x} = A^Tb</script><p>对应方程：$\,\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 2 \\ 1 &amp; 3 \end{bmatrix} \begin{bmatrix} C \\ D \end{bmatrix} = \begin{bmatrix} 1 \\ 2 \\ 2 \end{bmatrix}\,$，其中 $\,A = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 2 \\ 1 &amp; 3 \end{bmatrix}\,$，$\,\hat x = \begin{bmatrix} \hat c \\ \hat d \end{bmatrix}\,$，$\,b = \begin{bmatrix} 1 \\ 2 \\ 2 \end{bmatrix}\,$。</p><p>其中 $\,A \hat {x} = b\,$ 可以写成增广矩阵模式，故 $\,A^TA \hat {x} = A^Tb\,$ 可以写成：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 1 & 1 \\ 1 & 2 & 3 \end{bmatrix} \left[ \begin{array}{cc|c} 1 & 1 & 1 \\ 1 & 2 & 2 \\ 1 & 3 & 2 \end{array} \right] = \left[ \begin{array}{cc|c} 3 & 6 & 5 \\ 6 & 14 & 11 \end{array} \right]</script><p>即有：  </p><script type="math/tex; mode=display">\begin{bmatrix} 3 & 6 \\ 6 & 14 \end{bmatrix} \begin{bmatrix} \hat {C} \\ \hat {D} \end{bmatrix} = \begin{bmatrix} 5 \\ 11 \end{bmatrix}</script><p>解得：</p><script type="math/tex; mode=display">\hat {C} = 2/3，\hat {D} = 1/2</script><p>得到直线表达式 y = 2/3 + t/2。</p><p>还可以从误差最小的角度出发求解：  </p><script type="math/tex; mode=display">e_1^2 + e_2^2 + e_3^2 = (C + D - 1)^2 + (C + 2D - 2)^2 + (C + 3D - 2)^2</script><p>对等号右边的表达式求偏导数，极值出现在偏导数为 0 的位置。求偏导最终会得到相同的线性方程组和相同的解。</p><p>得到直线表达式 y = 2/3 + t/2。将 t = 1, 2, 3 分别代入，以及 b = p + e 可得：  </p><script type="math/tex; mode=display">b = \begin{bmatrix} 1 \\ 2 \\ 2 \end{bmatrix}, p = \begin{bmatrix} 7/6 \\ 10/6 \\ 13/6 \end{bmatrix}, e = \begin{bmatrix} -1/6 \\ 2/6 \\ -1/6 \end{bmatrix}</script><p>得到如下性质：<br>①误差向量与投影向量 p 垂直（二者点乘为 0）<br>②误差向量不仅仅垂直于 p，它还垂直于列空间中的每一个向量。</p><h2 id="矩阵-A-TA"><a href="#矩阵-A-TA" class="headerlink" title="矩阵 $\,A^TA\,$"></a>矩阵 $\,A^TA\,$</h2><p>之前有一个结论没有验证过：如果矩阵 A 各列线性无关，则矩阵 $\,A^TA\,$ 可逆。</p><p>引入之前几节的结论：如果矩阵可逆，则其对应的零空间仅为零向量。$\,x^Tx\,$ 对应是在求 x 的长度（x 是列向量）。如果 $\,x^Tx = 0\,$，则 x = 0（x 是列向量）。</p><p>假设存在 x 使得 $\,A^TAx = 0\,$。则有 $\,x^TA^TAx = 0 = (Ax)^T(Ax)\,$，可推得 Ax = 0，因为 A 各列线性无关，所以也就推得了 x 必为零向量。即 $\,A^TA\,$ 为可逆矩阵。</p><h2 id="标准正交基"><a href="#标准正交基" class="headerlink" title="标准正交基"></a>标准正交基</h2><p>这部分是引出下节的部分，内容较少：</p><p>如果矩阵的列向量是互相垂直的单位向量，则它们一定是线性无关的。我们将这种向量称之为<strong>标准正交 orthonormal</strong>。</p><p>例如：$\,\begin{bmatrix} 1 \\ 0 \\ 0 \end{bmatrix}\,$，$\,\begin{bmatrix} 0 \\ 1 \\ 0 \end{bmatrix}\,$，$\,\begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}\,$，以及 $\,\begin{bmatrix} \cos \theta \\ \sin \theta \end{bmatrix}\,$ 和 $\,\begin{bmatrix} -\sin \theta \\ \cos \theta \end{bmatrix}\,$。</p><h1 id="第十七课-正交矩阵和施密特正交化"><a href="#第十七课-正交矩阵和施密特正交化" class="headerlink" title="第十七课 正交矩阵和施密特正交化"></a>第十七课 正交矩阵和施密特正交化</h1><h2 id="标准正交向量-Orthonormal-vectors"><a href="#标准正交向量-Orthonormal-vectors" class="headerlink" title="标准正交向量 Orthonormal vectors"></a>标准正交向量 Orthonormal vectors</h2><p>满足如下条件的向量 $\,q_1, q_2, q_3\,$ 为标准正交：  </p><script type="math/tex; mode=display">q_i^Tq_j = \begin{cases} 0 & i \ne j \\[2ex] 1 & i = j \end{cases}</script><p>即，这些向量都具有单位长度 1，并且彼此正交。标准正交向量是线性无关的。</p><h2 id="标准正交矩阵-Orthonormal-matrix"><a href="#标准正交矩阵-Orthonormal-matrix" class="headerlink" title="标准正交矩阵 Orthonormal matrix"></a>标准正交矩阵 Orthonormal matrix</h2><p>所谓标准正交矩阵 Q，就是将标准正交向量组中的 $\,q_1, q_2 ··· q_n\,$ 列在同一个<br>矩阵中：  </p><script type="math/tex; mode=display">Q = \begin{bmatrix} q_1 & ... & q_n \end{bmatrix}</script><p>这样的标准正交矩阵有一个很好的性质：  </p><script type="math/tex; mode=display">Q^TQ = \begin{bmatrix} q_1 \\ q_2 \\ ... \\ q_n \end{bmatrix} \begin{bmatrix} q_1 & q_2 & ... & q_n \end{bmatrix} = \begin{bmatrix} 1 & 0 & \cdots & 0 & 0 \\ 0 & 1 & \cdots & 0 & 0 \\ \vdots & \vdots & \ddots & \vdots & \vdots \\ 0 & 0 & \cdots & 1 & 0 \\ 0 & 0 & \cdots & 0 & 1 \end{bmatrix} = I</script><p>注意这里的标准正交矩阵 Q 可以不是方阵；一个标准正交的方阵我们称之为<strong>正交矩阵 orthogonal matrix</strong>。如果 Q 为方阵，因为 $\,Q^TQ = I\,$，所以 $\,Q^T = Q^{-1}\,$。</p><p>正交矩阵不要忘了单位化。例如，$\,\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1 \end{bmatrix}\,$，这个矩阵各列是正交的，但并不是正交矩阵，因为没有单位化，正确的正交矩阵是 $\,\frac {1} {\sqrt 2}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1 \end{bmatrix}\,$。由这个矩阵可以延伸出<strong>阿达马矩阵 Adamar Matrix</strong>，这里不做详细介绍。</p><h2 id="标准正交矩阵的作用"><a href="#标准正交矩阵的作用" class="headerlink" title="标准正交矩阵的作用"></a>标准正交矩阵的作用</h2><p>记得上面介绍的投影矩阵 $\,P = A(A^TA)^{-1}A^T\,$，若 A 矩阵是标准正交矩阵 Q 时：  </p><script type="math/tex; mode=display">Q(Q^TQ)^{-1}Q^T = QQ^T</script><p>特别的，当 Q 时方阵（正交阵）时，由于此时 $\,Q^T = Q^{-1}\,$。所以投影矩阵即为 I。</p><p>很多复杂问题使用标准正交向量之后都变得简单。如果基为标准正交，则方程 $\,A^TA \hat {x} = A^Tb\,$ 的解变为 $\,\hat {x} = Q^Tb\,$，$\,\hat {x}\,$ 的分量 $\,\hat {x_i} = q_i^Tb\,$。</p><h2 id="施密特正交化-Gram-Schmidt"><a href="#施密特正交化-Gram-Schmidt" class="headerlink" title="施密特正交化 Gram-Schmidt"></a>施密特正交化 Gram-Schmidt</h2><p><strong>施密特正交化 Gram-Schmidt Orthogonalization</strong> 即从线性无关向量组入手，将其矩阵标准正交化。</p><p>有两个线性无关的向量 a，b。我们想从中得到标准正交向量 $\,q_1\,$，$\,q_2\,$。</p><p>Schmidt 给出的结论是如果我们有一组正交基 A 和 B（注意这个小节 A，B，C 均为向量），那么我们令它们除以自己的长度就得到标准正交基：  </p><script type="math/tex; mode=display">q_1 = \frac {A} {|A|}, q_2 = \frac {B} {|B|}</script><p>Gram 做了重要的工作，在 a 和 b 张成的空间中，将 a 向量定为 A 向量，然后将 b 向量投影到 a 向量上。然后取 B = b - p：  </p><div  align="center">  <img src="https://s2.loli.net/2024/02/22/abOJoXkDYQEpyv2.jpg" width = "40%" height = "40%" alt="图9 - 二维施密特正交化"/></div><p>即：  </p><script type="math/tex; mode=display">B = b - \cfrac {A^Tb} {A^TA} A</script><p>验证 A 与 B 是否正交：$\,A^TB = A^T(b - \cfrac {A^Tb} {A^TA} A) = 0\,$，说明 A 与 B 是正交的。接下来通过 $\,q_1 = \cfrac {A} {|A|}, q_2 = \cfrac {B} {|B|}\,$ 单位化各个向量，就得到了 a, b 空间的标准正交基。</p><hr><p>同样的道理，推广到三维：</p><div  align="center">  <img src="https://s2.loli.net/2024/02/22/AyuORYN4vqm5oCj.jpg" width = "40%" height = "40%" alt="图10 - 三维施密特正交化"/></div><p>寻找三个正交的向量 A, B, C 的话，其中 A，B 方法不变：</p><script type="math/tex; mode=display">A = a</script><script type="math/tex; mode=display">B = b - \cfrac {A^Tb} {A^TA} A</script><p>而 C 通过将 c 减去在 A, B 上的投影就可以得到：  </p><script type="math/tex; mode=display">C = c - \cfrac {A^Tb} {A^TA} A - \cfrac {B^Tc} {B^TB} B</script><p>得到三个正交的向量 A, B, C，再进行单位化即可。</p><hr><p>示例：$\,a = \begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix}\,$，$\,b = \begin{bmatrix} 1 \\ 0 \\ 2 \end{bmatrix}\,$，求标准正交矩阵 Q。</p><script type="math/tex; mode=display">A = a = \begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix}</script><script type="math/tex; mode=display">B = b - \cfrac {A^Tb} {A^TA} A = \begin{bmatrix} 1 \\ 0 \\ 2 \end{bmatrix} - \frac {3} {3} \begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix} = \begin{bmatrix} 0 \\ -1 \\ 1 \end{bmatrix}</script><p>再进行单位化，得到标准正交矩阵 Q：</p><script type="math/tex; mode=display">Q = \begin{bmatrix} q_1 & q_2 \end{bmatrix} = \begin{bmatrix} 1/\sqrt {3} & 0 \\ 1/\sqrt {3} & -1/\sqrt {2} \\ 1/\sqrt {3} & 1/\sqrt {2} \end{bmatrix}</script><p>观察矩阵 $\,A = \begin{bmatrix} 1 &amp; 1\\ 1 &amp; 0 \\ 1 &amp; 2 \end{bmatrix}\,$ 和矩阵 Q 的列空间，它们是相同的，也就是说我们的正交化过程都是在同一个空间中进行的，只是最后得到了一个更好的标准正交基而已。</p><p>从矩阵的角度来看，类似于 A 的 LU 分解，在 Gram-Schmidt 正交化中，A 可分解为 Q 与 R。其中 R 是上三角矩阵：$\,A = QR\,$</p><script type="math/tex; mode=display">A = \begin{bmatrix} a_1 & a_2 \end{bmatrix}</script><script type="math/tex; mode=display">Q = \begin{bmatrix} q_1 & q_2 \end{bmatrix}</script><script type="math/tex; mode=display">R = \begin{bmatrix} a_1^Tq_1 & a_2^Tq_1 \\ a_1^Tq_2 & a_2^Tq_2 \end{bmatrix}</script><p>其中 R 中的 $\,a_1^Tq_2\,$ 为 0，这是因为 $\,a_1\,$ 就是 $\,q_1\,$ 的方向，而 $\,q_1\,$ 和 $\,q_2\,$ 为标准正交向量，因此 $\,q_2\,$ 的方向与 $\,a_1\,$ 垂直，因此内积为 0。</p><p>R 在 Q 右侧相当于对 Q 做列操作，即 A 的列向量是 Q 列向量的线性组合。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 3d数学基础 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT 线性代数公开课笔记（一）</title>
      <link href="/2024/02/05/2024-02-05-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%801/"/>
      <url>/2024/02/05/2024-02-05-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%801/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该笔记主要内容为矩阵基础，以及 Ax = b 的相关的四个基本子空间；<br>该笔记主要参考了 MLNLP 的关于该公开课的 GitHub 公开项目的笔记：<a href="https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes">https://github.com/MLNLP-World/MIT-Linear-Algebra-Notes</a><br>公开课 B 站 bv 号：BV16Z4y1U7oU</p></blockquote><h1 id="第一课-方程组的几何解释"><a href="#第一课-方程组的几何解释" class="headerlink" title="第一课 方程组的几何解释"></a>第一课 方程组的几何解释</h1><p>通过一个例子来阐述对<strong>方程组的不同几何理解</strong>：</p><p>方程组形式：  </p><script type="math/tex; mode=display">\left\{ \begin{array}{c} 2x - y = 0 \\ −x + 2y = 3  \end{array} \right.\\</script><p>列向量形式：</p><script type="math/tex; mode=display">x\begin{bmatrix} 2 \\ -1 \end{bmatrix} + y \begin{bmatrix} -1 \\ 2 \end{bmatrix} = \begin{bmatrix} 0 \\ 3 \end{bmatrix}</script><p>矩阵形式：</p><script type="math/tex; mode=display">\begin{bmatrix} 2 & -1 \\ -1 & 2 \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix} = \begin{bmatrix} 0 \\ 3 \end{bmatrix}</script><p>①方程组形式（行图像）的理解：在坐标系的两条直线，相交点即为解；<br>②列向量形式（列图像）的理解：将公式左侧的向量以未知方式进行组合，组合的结果为右侧向量，该未知组合为解；<br>③矩阵形式的理解：即坐标系变换，将未知向量进行矩阵坐标系变换得到的结果为右侧向量，该未知向量为解。</p><p><strong>矩阵乘法</strong>：<br>方法 1，将矩阵看做列向量的组合（建议使用这个理解，更好一点）：</p><script type="math/tex; mode=display">\begin{bmatrix} 2 & 5 \\ 1 & 3 \end{bmatrix} \begin{bmatrix} 1 \\ 2 \end{bmatrix} = 1\begin{bmatrix} 2 \\ 1 \end{bmatrix} + 2\begin{bmatrix} 5 \\ 3 \end{bmatrix} = \begin{bmatrix} 12 \\ 7 \end{bmatrix}</script><p>方法 2，将矩阵 A 看做行向量的组合（点乘）：</p><script type="math/tex; mode=display">\begin{bmatrix} 2 & 5 \\ 1 & 3 \end{bmatrix} \begin{bmatrix} 1 \\ 2 \end{bmatrix} = \begin{bmatrix} (2, 5)\cdot(1, 2) \\ (1, 3)\cdot(1, 2) \end{bmatrix}  = \begin{bmatrix} 12 \\ 7 \end{bmatrix}</script><h1 id="第二课-消元法"><a href="#第二课-消元法" class="headerlink" title="第二课 消元法"></a>第二课 消元法</h1><h2 id="消元法介绍"><a href="#消元法介绍" class="headerlink" title="消元法介绍"></a>消元法介绍</h2><p>$ 求解方程组: \left\{ \begin{aligned} x + 2y + z &amp;= 2 \\ 3x + 8y + z &amp;= 12 \\ 4y + z &amp;= 2  \end{aligned} \right.\\ $</p><p>使用矩阵运算，将方程写为矩阵形式 Ax = b（系数矩阵为 A）：  </p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 2 & 1 \\ 3 & 8 & 1 \\ 0 & 4 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ z\end{bmatrix} = \begin{bmatrix} 2 \\ 12 \\2 \end{bmatrix}</script><p><strong>增广矩阵 Augmented matrix</strong> 就是在系数矩阵的右边添上一列，即线性方程组的等号右边的值：</p><script type="math/tex; mode=display">\left[ \begin{array}{ccc|c} 1 & 2 & 1 & 2 \\ 3 & 8 & 1 & 12 \\ 0 & 4 & 1 & 2 \end{array} \right] \to \left[ \begin{array}{ccc|c} 1 & 2 & 1 & 2 \\ 0 & 2 & -2 & 6 \\ 0 & 4 & 1 & 2 \end{array} \right] \to \left[ \begin{array}{ccc|c} 1 & 2 & 1 & 2 \\ 0 & 2 & -2 & 6 \\ 0 & 0 & 5 & -10 \end{array} \right]</script><p>消元后的矩阵就是：</p><script type="math/tex; mode=display">\left\{ \begin{aligned} x + 2y + z &= 2 \\ 2y - 2z &= 6 \\ 5z &= -10  \end{aligned} \right.\\</script><p>然后就可以求解了，和解二元一次方程组的消元法一模一样。</p><h2 id="消元矩阵"><a href="#消元矩阵" class="headerlink" title="消元矩阵"></a>消元矩阵</h2><p>①行向量与矩阵的乘法（这里先知道一下，之后会讲）</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 2 & 7 \end{bmatrix} \begin{bmatrix} ? & ? & ? \\ ? & ? & ? \\ ? & ? & ? \end{bmatrix}</script><p>上述公式可理解为 1 乘以第一行，2 乘以第二行，7 乘以第三行，解为行向量。而第一课的列向量是 x 乘以第一列，y 乘以第二列，z 乘以第三列，解为列向量。至于为什么一个在左侧和一个右侧，见后面，即<strong>矩阵运算不符合交换律 commutative law</strong>。</p><p>②消元矩阵介绍（重点）</p><p>首先先看<strong>单位矩阵 identity matrix</strong>：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} 1 & 2 & 1 \\ 3 & 8 & 1 \\ 0 & 4 & 1 \end{bmatrix} = \begin{bmatrix} 1 & 2 & 1 \\ 3 & 8 & 1 \\ 0 & 4 & 1 \end{bmatrix}</script><p>把单位矩阵看成三行，即[1 0 0]，[0 1 0]，[0 0 1]。可以看作三个行向量与矩阵乘法，首先 [1 0 0]，1个第一行，0个第二行和第三行，结果为值为第一行的行向量。依此类推，得到原矩阵。</p><p>所以上面消元法的矩阵可以写成：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 0 & 0 \\ -3 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} 1 & 2 & 1 \\ 3 & 8 & 1 \\ 0 & 4 & 1 \end{bmatrix} = \begin{bmatrix} 1 & 2 & 1 \\ 0 & 2 & -2 \\ 0 & 4 & 1 \end{bmatrix}</script><p>可以算一下，结果矩阵的第二行，即 -3 个参数矩阵的第一行，1 个第二行和 0 个第三行组合而成。另外：若想得到结果矩阵的第二行第三列的数字，就需要第一个矩阵的第二行，第二个矩阵的第三列的数字。</p><h2 id="置换矩阵-Permutation"><a href="#置换矩阵-Permutation" class="headerlink" title="置换矩阵 Permutation"></a>置换矩阵 Permutation</h2><p>左乘置换矩阵可以完成原矩阵的行变换：</p><script type="math/tex; mode=display">\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix} \begin{bmatrix} a & b \\ c & d \end{bmatrix} = \begin{bmatrix} c & d \\ a & b \end{bmatrix}</script><p>右乘置换矩阵则为列变换：</p><script type="math/tex; mode=display">\begin{bmatrix} a & b \\ c & d \end{bmatrix} \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix} = \begin{bmatrix} b & a \\ d & c \end{bmatrix}</script><p>对于三阶矩阵，一共有 6 个置换矩阵：  </p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} 0 & 1 & 0 \\ 1 & 0 & 0 \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & 1 \\ 0 & 1 & 0 \end{bmatrix} \begin{bmatrix} 0 & 1 & 0 \\ 0 & 0 & 1 \\ 1 & 0 & 0 \end{bmatrix} \begin{bmatrix} 0 & 0 & 1 \\ 0 & 1 & 0 \\ 1 & 0 & 0 \end{bmatrix} \begin{bmatrix} 0 & 0 & 1 \\ 1 & 0 & 0 \\ 0 & 1 & 0 \end{bmatrix}</script><p>我们任取两个矩阵相乘，结果仍在这个 6 个矩阵中。</p><h2 id="逆矩阵初探-Inverse"><a href="#逆矩阵初探-Inverse" class="headerlink" title="逆矩阵初探 Inverse"></a>逆矩阵初探 Inverse</h2><p>消元矩阵的逆矩阵的实施效果就是抵消原矩阵的消元操作。消元矩阵实现了对原矩阵 A 的操作，使第二行行向量 [3, 8, 1] 减掉了第一行 [1, 2, 1] 的3倍变为 [0, 2, -2]，则逆向操作就应该是把现在的第二行行向量 [0, 2, -2] 加上第一行 [1, 2, 1] 的3倍，从而变回原来的第二行 [3, 8, 1]。</p><p>所以对于$ E = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ -3 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} $，有 $ E^{-1} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 3 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} $</p><p>满足$ E^{-1}E = I $，即 $ \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 3 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ -3 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} $</p><h1 id="第三课-矩阵乘法和逆矩阵"><a href="#第三课-矩阵乘法和逆矩阵" class="headerlink" title="第三课 矩阵乘法和逆矩阵"></a>第三课 矩阵乘法和逆矩阵</h1><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>①基础求解方法<br>假设 A、B、C 为矩阵，且 A * B = C。若要求解元素 $C_{ij}$，将 A 中 i 行的行向量与 B 中 j 列的列向量进行数量积，即为该元素的值：</p><script type="math/tex; mode=display">C_{ij} = (A 中第 i 行向量)(B 中第 j 列向量) = \sum_{k=1}^n a_{ik} b_{kj}</script><p>根据上述，若要矩阵相乘，A 的列数必须与 B 的行数相同，结果 C 矩阵的规格为 A 的行数，B 的列数。即若 A 是 m 行 n 列，B 是 n 行 p 列，结果为：</p><script type="math/tex; mode=display">\begin{array}{} A & \times & B & = & C \\ m * n & & n * p & & m * p \end{array}</script><p>②列组合方法：跟前一节课说得一样，把 B 矩阵当作很多个列向量的组合，将问题转化为矩阵与向量的乘法问题。也表明了矩阵 C 就是矩阵 A 中各列向量的线性组合，而 B 其实是在告诉我们，要以什么样的方式组合 A 中的列向量。</p><p>③行组合方法：同理，将 A 矩阵当作很多个行向量的组合，将问题转化为矩阵与向量的乘法问题。所以是矩阵 B 各行的线性组合组成了 C 的各行。</p><p>④列乘以行<br><em>若是行向量乘以列向量，得到的是某个位置的单一元素。</em>即 1 * n 矩阵和 n * 1 矩阵得到 1 * 1 矩阵。<br><em>若是列向量乘以行向量，得到的是一个矩阵。</em>即 m * 1 矩阵和 1 * p 矩阵得到 m * p 矩阵。<br>所以矩阵相乘使用列乘以行，得到数个矩阵，再将矩阵相加，就可以得到 C。</p><script type="math/tex; mode=display">\begin{bmatrix} 2 & 7 \\ 3 & 8 \\ 4 & 9 \end{bmatrix} \begin{bmatrix} 1 & 6 \\ 0 & 0 \end{bmatrix} = \begin{bmatrix} 2 \\ 3 \\ 4 \end{bmatrix} \begin{bmatrix} 1 & 6 \end{bmatrix} + \begin{bmatrix} 7 \\ 8 \\ 9 \end{bmatrix} \begin{bmatrix} 0 & 0 \end{bmatrix} = \begin{bmatrix} 2 & 12 \\ 3 & 18 \\ 4 & 24 \end{bmatrix}</script><p>⑤分块乘法<br>比如现在有一个 50*50 的矩阵与 50*50 矩阵相乘，一个一个进行运算很麻烦，尤其是如果矩阵在某一区域上有一定的性质，那么我们可以将其分块，如：  </p><script type="math/tex; mode=display">\begin{bmatrix} A_1 & A_2 \\ A_3 & A_4 \end{bmatrix} \begin{bmatrix} B_1 & B_2 \\ B_3 & B_4 \end{bmatrix} = \begin{bmatrix} C_1 & C_2 \\ C_3 & C_4 \end{bmatrix}</script><p> 其中 $A_{1,2,3,4} $ 和 $B_{1,2,3,4} $ 都是划分之后的一块块矩阵，那么 $C_1 = A_1B_1 + A_2B_3 $ 。</p><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><p>①对于一个方阵（正方形矩阵）$A$，如果 $A$ 可逆，就有这样一个 $A^{−1}$，使：  </p><script type="math/tex; mode=display">AA^{−1} = I = A^{−1}A</script><p>但是对于非方阵（长方形矩阵），左侧的$A^{−1}$与右侧的$A^{−1}$不可能相同。</p><p>②不可逆矩阵<br>&emsp;&emsp; - 应行列式为 0，矩阵不可逆（见后面行列式）；<br>&emsp;&emsp; - 若存在非零向量 x，使得 Ax = 0，那么 A 就不可能有逆矩阵。因为如果 $A$ 有逆，在 $Ax = 0$ 这个等式两端同时乘上$A^{−1}$，就有：$A^{−1}Ax$ = $Ix$ = 零向量。自相矛盾。所以此时 A 没有逆矩阵。</p><p>比如这个没有逆的矩阵 $\begin{bmatrix} 1 &amp; 3 \\ 2 &amp; 6 \end{bmatrix}$，它的行列式为零；矩阵中的两个列向量在同一直线上；非零向量[3, -1]可以使 Ax = 0。</p><p>③逆矩阵求解<br>方法一：列向量</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 3 \\ 2 & 7 \end{bmatrix} \begin{bmatrix} a & b \\ c & d \end{bmatrix} = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}</script><p>即，得到两个方程：</p><script type="math/tex; mode=display">\begin{array}{} \begin{bmatrix} 1 & 3 \\ 2 & 7 \end{bmatrix} \begin{bmatrix} a \\ c \end{bmatrix} = \begin{bmatrix} 1 \\ 0 \end{bmatrix} & \begin{bmatrix} 1 & 3 \\ 2 & 7 \end{bmatrix} \begin{bmatrix} b \\ d \end{bmatrix} = \begin{bmatrix} 0 \\ 1 \end{bmatrix} \end{array}</script><p>方法二：高斯－若尔当消元法 Gauss-Jordan Elimination<br>即使用增广矩阵联系两个方程增广矩阵，并进行消元行变换，将虚线左侧消为单位矩阵 I，此时右侧矩阵即为逆矩阵：</p><script type="math/tex; mode=display">\left[ \begin{array}{cc|cc} 1 & 3 & 1 & 0 \\ 2 & 7 & 0 & 1 \end{array} \right] \to \left[ \begin{array}{cc|cc} 1 & 3 & 1 & 0 \\ 0 & 1 & -2 & 1 \end{array} \right] \to \left[ \begin{array}{cc|cc} 1 & 0 & 7 & -3 \\ 0 & 1 & -2 & 1 \end{array} \right]</script><p>上述公式，可以理解为对 [A I] 进行左乘消元处理（见上面消元矩阵），即 E [A I] = [I ?]，已知消元矩阵 E 乘以 A 等于 I，所以 E 本身就是逆矩阵，所以逆矩阵乘以 I 还是逆矩阵。</p><p>④逆矩阵补充<br>AB 的逆矩阵：因为 $ABB^{−1}A^{−1} = I$，所以 $(AB)^{−1}= B^{−1}A^{−1}$。</p><h1 id="第四课-矩阵-A-的-LU-分解"><a href="#第四课-矩阵-A-的-LU-分解" class="headerlink" title="第四课 矩阵 A 的 LU 分解"></a>第四课 矩阵 A 的 LU 分解</h1><p>将矩阵 A 分解为<strong>下三角矩阵 L（lower triangular matrix）</strong> 与<strong>上三角矩阵 U (upper triangular matrix)</strong>，$A=LU$。</p><p>我们熟悉的的消元法都是直接使用行变换得来的。而由于消元矩阵的存在，说明用矩阵乘法也可以达与之到一样的消元效果，即对于 2 阶矩阵，消元矩阵 $E$ 左乘 $A$ 变为上三角矩阵 $U$， $E_{21}  A = U$，可以改写为 $A = (E_{21})^{−1} U$，这一形式即 $A = LU$ 形式。并且，每个消元矩阵都是下三角矩阵，它的逆依然是下三角矩阵。<strong>这个等式有更重大的意义，它是将矩阵分解为一个下三角矩阵乘一个上三角矩阵，一个方形系统等于两个三角系统。</strong></p><p>关于矩阵的 LU 分解，下面的关键点值得注意：<br>①每个 $E_{ij}$ 都可逆，若其（i，j）元素是负的“乘数”，而 $E_{ij}^{-1}$ 的（i，j）元素就是正的乘数。比如：$ E_{21} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ -a &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} $，那么 $E_{21}^{-1} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ a &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} $。因为消元矩阵是减去某行的“乘数”倍，它的逆就是加上那行的“乘数”倍。<br>②不仅每个 $E_{ij}$ 都可逆，每个 $E_{ij}$ 的逆依然是下三角矩阵，并且对角线上的元素依然是1。<br>③$L$ 是一系列 $E_{ij}^{-1}$ 相乘的结果，但是 $E_{ij}^{-1}$ 相乘顺序和 $E_{ij}$ 相反。比如，$E_{32} E_{31} E_{21} A = U$，那么 $L = E_{21}^{-1} E_{31}^{-1} E_{32}^{-1}$。<br>④每个 $E_{ij}^{-1}$ 都是对角线为 1 的下三角矩阵，它们的乘积依然是对角线为 1 的下三角矩阵。<br>⑤关于 L 最重要的一个结论：L 中下三角部分（i，j）位置的元素 $L_{ij}$ 就等于“乘数”。<br>例如，$ E_{21} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ -a &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} $ $ E_{31} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ -b &amp; 0 &amp; 1 \end{bmatrix} $ $ E_{32} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; -c &amp; 1 \end{bmatrix} $<br>则 $ E = E_{32}E_{31}E_{21} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; -c &amp; 1 \end{bmatrix}\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ -b &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ -a &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ -a &amp; 1 &amp; 0 \\ ac-b &amp; -c &amp; 1 \end{bmatrix} $<br>那么 $ L = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ a &amp; 1 &amp; 0 \\ b &amp; c &amp; 1 \end{bmatrix} $</p><h1 id="第五课-转置、转换、向量空间"><a href="#第五课-转置、转换、向量空间" class="headerlink" title="第五课 转置、转换、向量空间"></a>第五课 转置、转换、向量空间</h1><h2 id="置换矩阵-Permutation-Matrix"><a href="#置换矩阵-Permutation-Matrix" class="headerlink" title="置换矩阵 Permutation Matrix"></a>置换矩阵 Permutation Matrix</h2><p>置换矩阵回顾：<br>①所谓的置换矩阵 P，就是用来完成行交换的矩阵。<br>②那么对于 n 阶矩阵来说，有 n! 个置换矩阵。<br>③置换矩阵另一个优点就是可逆的，并且对于置换矩阵 P 来说，有 $PP^T = I$，即 $P^{-1} = P^T$。<br>④置换矩阵是一种特殊的正交矩阵，正交矩阵未必是置换矩阵。</p><h2 id="转置矩阵-Transposed-Matrix"><a href="#转置矩阵-Transposed-Matrix" class="headerlink" title="转置矩阵 Transposed Matrix"></a>转置矩阵 Transposed Matrix</h2><p>①转置矩阵回顾：转置矩阵将行元素与列元素交换，即 $A_{ij}^T = A_{ji}$。<br>②转置矩阵的运算规律：${(AB)}^T = B^TA^T$。<br>③<strong>对称矩阵 Symmetric matrix</strong>，即主对角线两侧元素对应相等的矩阵，即对于该矩阵来说 $A^T = A$。任意矩阵和它的转置矩阵相乘得到的方阵一定是对称矩阵，即 ${(A^TA)}^T = A^TA^{TT} = A^TA$，所以对于任何 $A^TA$，其转置仍然是本身，所以是对称矩阵。</p><h2 id="向量空间-Vector-Space-与子空间"><a href="#向量空间-Vector-Space-与子空间" class="headerlink" title="向量空间 Vector Space 与子空间"></a>向量空间 Vector Space 与子空间</h2><h3 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h3><p>向量空间，又称线性空间，定义为带有加法和标量乘法的集合。在一个向量空间中，如果我们将任意向量相加或者乘以一个标量，也就是任意向量的线性组合，它们的结果仍然在这个向量空间中（向量空间必然包括原点，因为任意向量乘以一个标量也在向量空间，而这个标量可以为零）。向量空间 $R^n$ 由所有的 n 维向量 v 组成，向量中的每个元素都是实数 R。</p><p>比如，$R^2$ 就是一个向量空间，即一个平面，其中的向量均为二维实向量。$R^3$ 这个三维空间也是向量空间。在三维空间中过原点的一个平面也是一个向量空间，这个向量空间和 $R^2$ 很像，但其中的每个向量都有三个元素。</p><h3 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h3><p>一个向量空间的子空间是由一系列包含零向量的向量组成的，并且满足：如果是 v 和 w 是子空间的两个向量并且 c 是任意标量，那么有 (1) v + w 在子空间中， (2) cv 在子空间中。也就是说，所有向量的线性组合都仍然在这个子空间中，即子空间本身也是向量空间。</p><p>对于 $R^3$ 三维空间来说，有 4 类子空间：<br>①$L$：所有过 (0, 0, 0) 的直线；<br>②$P$：所有过 (0, 0, 0) 的平面；<br>③$Z$：零向量 (0, 0, 0)；<br>④$R^3$：整个三维空间</p><h3 id="列空间初探"><a href="#列空间初探" class="headerlink" title="列空间初探"></a>列空间初探</h3><p>矩阵 A 的列空间 $C(A)$ 是其列向量的所有线性组合所构成的空间（某个子空间）。比如：</p><script type="math/tex; mode=display">A = \begin{bmatrix} 1 & 3 \\ 2 & 3 \\ 4 & 1 \end{bmatrix}</script><p>其 2 个列向量都属于 $R^3$ ，这两个向量组成一个平面，构成了 $R^3$ 的一个子空间。</p><h1 id="第六课-列空间和零空间"><a href="#第六课-列空间和零空间" class="headerlink" title="第六课 列空间和零空间"></a>第六课 列空间和零空间</h1><h3 id="列空间回顾"><a href="#列空间回顾" class="headerlink" title="列空间回顾"></a>列空间回顾</h3><p>列空间的 Ax = b 解释(从 A 的角度)：<br>①子空间是和矩阵紧密联系的。当我们求解 Ax = b 时，Ax 的本质是对 A 的列向量进行线性组合。为了得到 b，我们用任何可能的 x 来求取 A 的列向量的所有可能的线性组合，这产生了一个 A 的列空间 $C(A)$ 。$C(A)$ 不仅仅包含的所有列向量，还包括他们的所有线性组合。<br>②只要 b 在 A 的列空间这个子空间中，那么就可以找到一种 A 列向量的线性组合来构成 b。也就是使得 Ax = b 有解。</p><h3 id="零空间"><a href="#零空间" class="headerlink" title="零空间"></a>零空间</h3><p>①零向量介绍<br>即 Ax = 0 的所有解 x 所构成的一个空间。以下面 A 为例，其零空间就是下面这个方程的解构成的空间：</p><script type="math/tex; mode=display">Ax = \begin{bmatrix} 1 & 1 & 2 \\ 2 & 1 & 3 \\ 3 & 1 & 4 \\ 4 & 1 & 5 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \\ x_3 \end{bmatrix} = 0</script><p>可以看到 x 有三个分量，所以其零空间是 $R^3$ 的子空间。假设向量 v 和 w 位于此零空间中，也就是 Av = 0 、Aw = 0，那就有 A(v + w) = 0、A(cv) = 0，即它们相加或者乘以一个标量后仍然在零空间中，因此零空间是一个向量空间。</p><p>所以，对于 m*n 的矩阵来说，列空间是 $R^m$ 的子空间，零空间是 $R^n$ 的子空间。列空间关键在于列向量的维数，零空间的关键在于列向量的个数。</p><p>对于上面的例子，可以看出 $ \begin{bmatrix} 1 \\ 1 \\ -1 \end{bmatrix} $ 是一个解，而其零空间即为：$ C \begin{bmatrix} 1 \\ 1 \\ -1 \end{bmatrix} $ (C 表示任意常数)。表现在图像上就是 $R^3$ 中的一条穿过原点的直线。</p><p>②从 x 的角度看 Ax = b<br>如果上面构造零空间的方程右侧变为任意向量的话，其解集 x 还能构成向量空间吗？如下：</p><script type="math/tex; mode=display">Ax = \begin{bmatrix} 1 & 1 & 2 \\ 2 & 1 & 3 \\ 3 & 1 & 4 \\ 4 & 1 & 5 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \\ x_3 \end{bmatrix} = \begin{bmatrix} 1 \\ 2 \\ 3 \\ 4 \end{bmatrix}</script><p>答案是不能，因为 x 的解集不包括零向量。本例中 x 的解集是一个不穿过原点的直线。</p><h1 id="第七课-求解-Ax-0：主变量，特解"><a href="#第七课-求解-Ax-0：主变量，特解" class="headerlink" title="第七课  求解 Ax=0：主变量，特解"></a>第七课  求解 Ax=0：主变量，特解</h1><p>本课主要讲解出 Ax = 0 中的 x 构成的零空间的算法。</p><h2 id="消元法求解零空间"><a href="#消元法求解零空间" class="headerlink" title="消元法求解零空间"></a>消元法求解零空间</h2><p>第一步：消元法确定主变量与自由变量（消元）</p><p>假设 $ A = \begin{bmatrix} 1 &amp; 2 &amp; 2 &amp; 2 \\ 2 &amp; 4 &amp; 6 &amp; 8 \\ 3 &amp; 6 &amp; 8 &amp; 10 \end{bmatrix} $ ，求解由 Ax = 0 中的 x 构成的零空间。</p><p>消元法并不会改变 x 的解，因为本质就是求方程式，只是会改变 A 的列空间。</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 2 & 2 & 2 \\ 2 & 4 & 6 & 8 \\ 3 & 6 & 8 & 10 \end{bmatrix} \to \begin{bmatrix} 1 & 2 & 2 & 2 \\ 0 & 0 & 2 & 4 \\ 0 & 0 & 2 & 4 \end{bmatrix}\to \begin{bmatrix} 1 & 2 & 2 & 2 \\ 0 & 0 & 2 & 4 \\ 0 & 0 & 0 & 0 \end{bmatrix}</script><p>A 矩阵消元之后只有两个主元：1 和 2，主元的个数被称为<strong>秩 Rank</strong>。矩阵中包含主元的列为<strong>主元列 pivot column</strong>，不包含主元的列称为<strong>自由列 free column</strong>。</p><p>所谓自由列，就表示其对应的未知变量 $x_n$ (n 表示自由列是第 n 列)可以被任意分配值。所以这个 U 的主变量(主元)为 $x_1$ ，$x_3$，自由变量为 $x_2$，$x_4$。</p><p>第二步：回代<br>首先给自由变量 $x_2$，$x_4$ 赋值为 1 和 0，带入到回代的方程式：</p><script type="math/tex; mode=display">\left\{ \begin{aligned} x_1 + 2x_2 + 2x_3 + 2x_4 &= 0 \\ 2x_3 + 4x_4 &= 0 \end{aligned} \right.\\</script><p>得到解向量为：$ A = \begin{bmatrix} -2 \\ 1 \\ 0 \\ 0 \end{bmatrix} $</p><p>再给自由变量 $x_2$，$x_4$ 赋值为 0 和 1，得到解向量为：$ A = \begin{bmatrix} 2 \\ 0 \\ -2 \\ 1 \end{bmatrix} $</p><p>这两个解为<strong>特解 Special solutions</strong>，矩阵 A 的零空间就是这些特解向量的线性组合所构成的向量空间，即：  </p><script type="math/tex; mode=display">x = c\begin{bmatrix} -2 \\ 1 \\ 0 \\ 0 \end{bmatrix} + d\begin{bmatrix} 2 \\ 0 \\ -2 \\ 1 \end{bmatrix}</script><p>若矩阵为 m*n 的矩阵，矩阵的秩 r 等于其主元列的数目，因此自由列的数目就等于 n-r，即列的数目减去主元列的数目。这个数值等于特解的数目和零空间的维数。主元列和自由列的一个重要区别就是，自由列可以表示为其左侧所有主元列的线性组合，而主元列则不可以。</p><h2 id="行最简阶梯矩阵-Reduced-row-echelon-form-rref"><a href="#行最简阶梯矩阵-Reduced-row-echelon-form-rref" class="headerlink" title="行最简阶梯矩阵 Reduced row echelon form (rref)"></a>行最简阶梯矩阵 Reduced row echelon form (rref)</h2><p>通过继续消元我们可以将矩阵 U 转变为行最简阶梯矩阵形式 R，其中主元为 1，而主元列除主元外皆为 0：</p><script type="math/tex; mode=display">U = \begin{bmatrix} 1 & 2 & 2 & 2 \\ 0 & 0 & 2 & 4 \\ 0 & 0 & 0 & 0 \end{bmatrix} \to \begin{bmatrix} 1 & 2 & 0 & -2 \\ 0 & 0 & 2 & 4 \\ 0 & 0 & 0 & 0 \end{bmatrix} \to \begin{bmatrix} 1 & 2 & 0 & -2 \\ 0 & 0 & 1 & 2 \\ 0 & 0 & 0 & 0 \end{bmatrix} = R</script><p>在矩阵中主元行和主元列的交汇处存在一个单位阵。通过列交换，可以将矩阵 R 中的主元列集中在左侧，从而在左上角形成这个单位阵，而将自由列集中在矩阵的右侧。如果矩阵 A 中的某些行是线性相关的，则在矩阵 R 的下半部分就会出现一些完全为 0 的行向量。即：</p><script type="math/tex; mode=display">R = \begin{bmatrix} 1 & 0 & 2 & -2 \\ 0 & 1 & 0 & 2 \\ 0 & 0 & 0 & 0 \end{bmatrix} = \begin{bmatrix} I & F \\ 0 & 0 \end{bmatrix}</script><p>这里的 I 是 rxr 的方阵，F 代表着自由列经过化简剩余的形式。</p><p>将 Ax=0 的特解作为列向量写成一个矩阵 N ，即零空间矩阵。即：</p><script type="math/tex; mode=display">Ax = Rx = \begin{bmatrix} I & F \\ 0 & 0 \end{bmatrix} \begin{bmatrix} x_{pivot} \\ x_{free} \end{bmatrix} = 0</script><p>根据矩阵分块乘法运算可得：</p><script type="math/tex; mode=display">N = \begin{bmatrix} -F \\ I \end{bmatrix}</script><p>这里的 I 为一个 (n-r)x(n-r) 的矩阵。零空间矩阵满足 RN = 0，故零空间矩阵是一个 nx(n-r) 的矩阵。</p><p>对于矩阵 R 而言，求零空间特解就变得非常简单，只需要将消元的到的 F 部分拼接上单位阵就可以得到所有的通解。注意如果在变换出 R 左上角的单位阵的过程中采用了列交换，则最后的解要行变换回去。即：</p><script type="math/tex; mode=display">N = \begin{bmatrix} -2 & 2 \\ 0 & -2 \\ 1 & 0 \\ 0 & 1 \end{bmatrix} \to \begin{bmatrix} -2 & 2 \\ 1 & 0 \\ 0 & -2 \\ 0 & 1 \end{bmatrix}</script><h1 id="第八课-求解-Ax-b：可解性与结构"><a href="#第八课-求解-Ax-b：可解性与结构" class="headerlink" title="第八课 求解 Ax=b：可解性与结构"></a>第八课 求解 Ax=b：可解性与结构</h1><h2 id="Ax-b-的解"><a href="#Ax-b-的解" class="headerlink" title="Ax=b 的解"></a>Ax=b 的解</h2><h3 id="可解性"><a href="#可解性" class="headerlink" title="可解性"></a>可解性</h3><p>Ax = b，这个方程并不一定有解。我们通过一个例子来说明下这个问题：  </p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 2 & 2 & 2 \\ 2 & 4 & 6 & 8 \\ 3 & 6 & 8 & 10 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \\ x_3 \\ x_4 \end{bmatrix} = \begin{bmatrix} b_1 \\ b_2 \\ b_3 \end{bmatrix}</script><p>同上一课例子中的矩阵，第三行为第一行和第二行的和。因此 Ax=b 中 b 的第 3 个分量也要等于其第 1 和第 2 个分量的和。若 b 不满足 $b_3=b_1+b_2$ 则方程组无解。</p><p>检验 Ax=b 是否可解的方法也可以使用增广矩阵进行消元。如果矩阵 A 的行被完全消去的话，则对应的 b 的分量也要得 0：</p><script type="math/tex; mode=display">\left[ \begin{array}{cccc|c} 1 & 2 & 2 & 2 & b_1 \\ 2 & 4 & 6 & 8 & b_2 \\ 3 & 6 & 8 & 10 & b_3 \end{array} \right] \to \left[ \begin{array}{cccc|c} 1 & 2 & 2 & 2 & b_1 \\ 0 & 0 & 2 & 4 & b_2 - 2b_1 \\ 0 & 0 & 0 & 0 & b_3-b_2-b_1 \end{array} \right]</script><p>因此本方程的可解条件为 $b_3-b_2-b_1=0$ 。</p><p>前几讲讨论过，只有当 b 处于矩阵的列空间 C(A) 之中时，方程才有解。本讲推导出矩阵 A 的行向量若经过线性组合成为了零向量，则对应的 b 经同样的线性组合后也要等于 0。因此看起来我们有了两条关于b的限制条件，但实际上这两点是等价的。</p><h3 id="通解"><a href="#通解" class="headerlink" title="通解"></a>通解</h3><p>为求得 Ax=b 的所有解，我们首先检验方程是否可解，然后找到一个<strong>特解 particular solution</strong>。将特解和矩阵零空间的向量相加即为方程的<strong>通解 Complete solution</strong>。因为 $Ax_p = b$, $Ax_n = 0$，所以 $A(x_p+x_n) = b$。</p><p>求 Ax=b 特解的方法是将自由变量均赋值为 0，求解其主变量。本例中，假设 b = [1, 5, 6]，令 $x_2=x_4=0$ 得到方程组：</p><script type="math/tex; mode=display">\left\{ \begin{aligned} x_1 + 2x_3 &= 1 \\ 2x_3 &= 3 \end{aligned} \right.\\</script><p>得到特解：</p><script type="math/tex; mode=display">x_p = \begin{bmatrix} -2 \\ 0 \\ 3/2 \\ 0 \end{bmatrix}</script><blockquote><p>主元列和自由列的一个重要区别就是，自由列可以表示为其左侧所有主元列的线性组合，而主元列则不可以，主元列之间是线性无关的。我们将自由变量赋值为 0 就可以去掉自由列列向量的干扰，求得方程的特解。</p></blockquote><p>通过上一节的知识我们很容易求出 Ax = 0 的 x 零空间的解：</p><script type="math/tex; mode=display">c_1\begin{bmatrix} -2 \\ 1 \\ 0 \\ 0 \end{bmatrix} + c_2\begin{bmatrix} 2 \\ 0 \\ -2 \\ 1 \end{bmatrix}</script><p>因此上述方程的通解为(式中 c1 和 c2 为任意实数)：  </p><script type="math/tex; mode=display">x_{complete} = \begin{bmatrix} -2 \\ 0 \\ 3/2 \\ 0 \end{bmatrix} + c_1\begin{bmatrix} -2 \\ 1 \\ 0 \\ 0 \end{bmatrix} + c_2\begin{bmatrix} 2 \\ 0 \\ -2 \\ 1 \end{bmatrix}</script><p>矩阵的零空间 N(A) 是 $R^4$ 空间中的二维子空间，方程的解 Ax=b 构成了穿过 $x_p$ 点并且和矩阵零空间平行的二维平面。但该平面并不是 $R^4$ 空间的子空间，因为不包括零向量，不是向量空间。</p><h2 id="m-n-的矩阵-A-的秩与解的关系"><a href="#m-n-的矩阵-A-的秩与解的关系" class="headerlink" title="m*n 的矩阵 A 的秩与解的关系"></a>m*n 的矩阵 A 的秩与解的关系</h2><p>矩阵的秩等于矩阵的主元数。如果 m x n 矩阵的秩为 r ，则必有 r &lt;= m 且 r &lt;= n。</p><p>①列满秩：r = n &lt; m。每列都有主元，x 的每一个分量都是主变量，没有自由变量。零空间 N(A) 之内只有零向量。方程无解或者有唯一解 $x_p$ 。例如：</p><script type="math/tex; mode=display">A = \begin{bmatrix} 1 & 3 \\ 2 & 1 \\ 6 & 1 \\ 5 & 1 \end{bmatrix} \to \begin{bmatrix} 1 & 0 \\ 0 & 1 \\ 0 & 0 \\ 0 & 0 \end{bmatrix} = \begin{bmatrix} I \\ 0 \end{bmatrix}</script><p>②行满秩：r = m &lt; n。每行都有主元，无论 b 取何值，方程 Ax=b 都有无穷多个解。主变量 r 个，自由变量 n-r 个。例如：  </p><script type="math/tex; mode=display">A = \begin{bmatrix} 1 & 2 & 6 & 5 \\ 3 & 1 & 1 & 1 \end{bmatrix} \to \begin{bmatrix} 1 & 0 & * & * \\ 0 & 1 & * & * \end{bmatrix} = \begin{bmatrix} I & F \end{bmatrix}</script><p>③满秩：r = m = n，矩阵可逆。零空间只有零向量，无论 b 取何值，方程 Ax=b 都有唯一解，因为自由变量个数为 0。只能得到一个全是主元的方程组。例如： </p><script type="math/tex; mode=display">A = \begin{bmatrix} 1 & 2 \\ 3 & 1 \end{bmatrix} \to \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix} = I</script><p>④不满秩：r &lt; n, r &lt; m，此时 A 可化简为 $ \begin{bmatrix} I &amp; F \\ 0 &amp; 0 \end{bmatrix} $ 形式，最后化简结果中有 0 行。如本节课开头中的矩阵，b 的分量与零行牵扯出了可解条件的存在。所以这样的矩阵 A 所构成的 Ax = b 方程解有两种情况：不满足可解条件或无穷多个解。</p><p>总结：</p><div class="table-container"><table><thead><tr><th style="text-align:left">r = m = n</th><th style="text-align:left">r = n &lt; m</th><th style="text-align:left">r = m &lt; n</th><th style="text-align:left">r &lt; n, r &lt; m</th></tr></thead><tbody><tr><td style="text-align:left">$R=I$</td><td style="text-align:left">$R=\begin{bmatrix} I \\ 0 \end{bmatrix}$</td><td style="text-align:left">$R=\begin{bmatrix} I &amp; F \end{bmatrix}$</td><td style="text-align:left">$ \begin{bmatrix} I &amp; F \\ 0 &amp; 0 \end{bmatrix} $</td></tr><tr><td style="text-align:left">唯一解</td><td style="text-align:left">无解或唯一解</td><td style="text-align:left">无穷多解</td><td style="text-align:left">无解或无穷多解</td></tr></tbody></table></div><p>秩决定了方程组解的数量。mxn 给出了矩阵的尺寸，但是秩 r 给出的是矩阵的实际“大小”。关于这个随后会有讨论。</p><p>如上表，①可解条件的产生是由于 A 消元之后的 0 行导致的：消元后有零行产生时，需要考虑方程是否满足可解条件；消元后没有零行时，方程不用考虑可解条件的影响。②自由变量总为（n-r）个，根据自由变量个数可以初步判断 Ax = b 的解的结构：n − r = 0 时，方程即为唯一解，否则为无穷解。</p><h1 id="第九课-线性相关性，基和维数"><a href="#第九课-线性相关性，基和维数" class="headerlink" title="第九课 线性相关性，基和维数"></a>第九课 线性相关性，基和维数</h1><h2 id="线性无关-Independence-与线性相关-Dependence"><a href="#线性无关-Independence-与线性相关-Dependence" class="headerlink" title="线性无关 Independence 与线性相关 Dependence"></a>线性无关 Independence 与线性相关 Dependence</h2><p>一般来说，线性无关，线性相关是向量组内的关系。</p><p>矩阵 A 为 m x n 矩阵，其中 m &lt; n。因此 Ax = b 中未知数个数多于方程数，未知数一共 n 个，方程一共 m 个，则 A 中具有至少一个自由变量，那么 Ax = 0 一定具有非零解。此时，由于 A 的列向量可以线性组合得到零向量，所以 A 的列向量必定是线性相关的。</p><p>线性无关的定义：若 $c_1x_1 + c_2x_2 + \cdots + c_nx_n = 0$ 仅在 $c_1 = c_2 = \cdots = c_n = 0$ 时才成立，则称向量 $x_1, x_2 \cdots x_n$ 是线性无关的。即若这些向量作为列向量构成矩阵 A，则方程 Ax = 0 只有零解 x = 0，或称矩阵 A 的零空间只有零向量。换而言之，若存在非零向量 c，使得 Ac = 0，则这个矩阵 A 的列向量线性相关。</p><blockquote><p>注：如果一个向量组中有零向量存在，那么这个向量组一定是线性相关的。</p></blockquote><p>在 R2 空间中，两个向量只要不在一条直线上就是线性无关的。在 R3 中，三个向量线性无关的条件是它们不在一个平面上。若选定空间 R2 中的三个向量，则他们必然是线性相关的。例如，如下的三个向量 v1，v2 和 v3 是线性相关的。</p><script type="math/tex; mode=display">A = \begin{bmatrix} v_1 & v_2 & v_3 \end{bmatrix} = \begin{bmatrix} 2 & 1 & 2.5 \\ 1 & 2 & -1 \end{bmatrix}</script><p>显然，A 矩阵是 n &gt; m 型的矩阵。Ac = 0 这个方程对应的零空间中，除了零向量肯定还有其他向量，也就是存在一种 c 不全为 0 的情况，使 A 各列线性组合后得到 0。也就是 A 各列的 v1，v2 和 v3 线性相关。</p><h2 id="零空间和线性相关-无关"><a href="#零空间和线性相关-无关" class="headerlink" title="零空间和线性相关/无关"></a>零空间和线性相关/无关</h2><p>假设现有一 m x n 矩阵 A：<br>①如果 A 各列向量构成的向量组是线性无关的，那么矩阵 A 的零空间中只有零向量；线性无关对应向量组构成的矩阵，秩为 n，此时没有自由变量，零空间中只有零向量存在。<br>②如果 A 各列向量构成的向量组是线性相关的，那么矩阵 A 零空间中除零向量之外还一定有其他向量。线性相关对应向量组构成的矩阵，秩小于 n，有 n-r 个自由变量，零空间中有很多向量。</p><h2 id="生成-张成-空间-Spanning-a-space"><a href="#生成-张成-空间-Spanning-a-space" class="headerlink" title="生成(张成)空间 Spanning a space"></a>生成(张成)空间 Spanning a space</h2><p>所谓生成空间，即为此空间由向量 $v_1,v_2,v_3 \cdots v_n$ 的线性组合构成，就称 $v_1,v_2,v_3 \cdots v_n$ 生成了一个空间。</p><p>但是 $v_1,v_2,v_3 \cdots v_n$ 不一定是线性无关的，只是我们更关心线性无关的 $v_1,v_2,v_3 \cdots v_n$，因为它们可以表示出空间的特征，这就引出了“基”的概念。</p><h2 id="基-Basis"><a href="#基-Basis" class="headerlink" title="基 Basis"></a>基 Basis</h2><p>基的定义：一组向量 $v_1,v_2,v_3 \cdots v_n$ ，具有两个性质：<br>①$v_1,v_2,v_3 \cdots v_n$ 线性无关；<br>②$v_1,v_2,v_3 \cdots v_n$ 生成整个空间。</p><p>例如三维空间中的一组基：$\begin{bmatrix} 1 \\ 0 \\ 0 \end{bmatrix}$，$\begin{bmatrix} 0 \\ 1 \\ 0 \end{bmatrix}$，$\begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}$。因为它们满足 $c_1, c_2, c_3$ 只有零解。</p><p>而 $\begin{bmatrix} 1 \\ 1 \\ 2 \end{bmatrix}$，$\begin{bmatrix} 2 \\ 2 \\ 5 \end{bmatrix}$，$\begin{bmatrix} 3 \\ 3 \\ 8 \end{bmatrix}$ 则不能构成一组基，因为以它们为列向量组成的矩阵，有两个相同的行，消元肯定有自由列存在，因此这三个向量并非线性无关。</p><p>从矩阵是否为可逆矩阵也可以判断是否为一组基：若以 R(n) 空间中的 n 个向量为列向量构成的矩阵为可逆矩阵，则这些向量可以构成 R(n) 空间中的一组基。</p><p>但是可以发现：一个空间的不同基，其中向量的个数是一定的。如果 A 是 R(n) 空间的基，那么 A 中向量的个数就是 n 个。比如三维空间 R3，基一定是三个向量构成的向量组。这里给出一个性质：R(n) 中的 n 个向量构成基，则以这 n 个向量构成的 n × n 矩阵必须可逆。矩阵可逆就意味着任意两行，两列都线性无关，所以可以构成一组生成空间的基。 </p><h2 id="维数-Dimension"><a href="#维数-Dimension" class="headerlink" title="维数 Dimension"></a>维数 Dimension</h2><p>R(n) 空间的基中向量的个数就是 n 个，这个 n 称之为维数。</p><h2 id="总结举例"><a href="#总结举例" class="headerlink" title="总结举例"></a>总结举例</h2><p>假设列空间由矩阵 A 确定：</p><script type="math/tex; mode=display">A = \begin{bmatrix} 1 & 2 & 3 & 1 \\ 1 & 1 & 2 & 1 \\ 1 & 2 & 3 & 1 \end{bmatrix}</script><p>讨论<strong>列空间</strong>：矩阵 A 的四个列向量生成了矩阵 A 的列空间，其中第 3 列和第 4 列与前两列线性相关，而前两个列向量线性无关。可以取前两列为主元列，他们组成了列空间C(A)的一组基。矩阵的秩为2。A 的列空间的维数也为 2。</p><p>所以有：<strong>矩阵 A 的秩 = 矩阵 A 主列的个数 = A 列空间的维数</strong></p><blockquote><p>注意：矩阵具有秩 rank 而不是维数 dimension，而空间有维数而不是秩。</p></blockquote><p>当知道了列空间的维数，可以从矩阵列向量中随意选取足够数量的线性无关的向量，它们每一组都可以构成列空间的一组基。</p><p>讨论<strong>零空间</strong>：所谓零空间维数，即是零空间基的个数，也是 Ax = 0 的特解的个数，还可以理解为：Ax = 0 的解中自由变量的个数。本例中矩阵的列向量不是线性无关的，因此其零空间 N(A) 不止包含零向量。</p><p>经过消元，自由变量赋值，回代，可以得到两个特解：</p><script type="math/tex; mode=display">\begin{bmatrix} -1 \\ -1 \\ 1 \\ 0 \end{bmatrix},\begin{bmatrix} -1 \\ 0 \\ 0 \\ 1\end{bmatrix}</script><p>所以此零空间的维数为 2，这两个特解就构成了零空间的一组基。所以有：<strong>m × n 矩阵中，主列个数为 r，秩为 r，则有：零空间维数 = n - r。</strong></p><h1 id="第十课-四个基本子空间"><a href="#第十课-四个基本子空间" class="headerlink" title="第十课 四个基本子空间"></a>第十课 四个基本子空间</h1><h2 id="四个基本空间介绍"><a href="#四个基本空间介绍" class="headerlink" title="四个基本空间介绍"></a>四个基本空间介绍</h2><p>对于一个 m × n 矩阵 A 来说：<br>①<strong>列空间 $C(A)$</strong><br>列空间即是矩阵 A 的列向量线性组合构成的空间。对于 m × n  的矩阵 A 来说，每个列向量有 m 个分量，即列向量属于 $R^m$ 空间。所以列空间是 $R^m$ 的子空间。<br>②<strong>零空间 $N(A)$</strong><br>即由 Ax = 0 的解构成的空间。由于 x 本质是对 A 列向量的线性组合，A 一共有 n 个列向量，所以零空间是 $R^n$ 的子空间。<br>③<strong>行空间 $C(A^T)$</strong><br>行空间就是矩阵 A 各行线性组合构成的子空间。也可以理解为 A 转置的列空间，即 $C(A^T)$。A 的每个行向量都有 n 个分量，所以每个行向量都在 $R^n$ 中。也就是 A 的行空间是 $R^n$ 的子空间。<br>④<strong>左零空间 $N(A^T)$</strong><br>左零空间我们接下来会再介绍，先理解为 $A^T$ 的零空间就好。很明显，$A^T$ 是一个 n × m 的矩阵。联系零空间的介绍，$A^T$ 一共有 m 个列向量，所以左零空间是 $R^m$ 的子空间。</p><h2 id="四个基本空间的维数与基"><a href="#四个基本空间的维数与基" class="headerlink" title="四个基本空间的维数与基"></a>四个基本空间的维数与基</h2><p>还是对于一个 m × n 矩阵 A 来说：<br>①<strong>列空间</strong><br>设矩阵 A 的秩为 r，则 A 有 r 个主列，这 r 个主列就是列空间 C(A) 的一组基，一组基里有 r 个向量，所以列空间维数为：r 。<br>②<strong>零空间</strong><br>矩阵 A 秩为 r 时，自由列为 n - r 列。这 n - r 列决定了 x 中的 n - r 个自由变元，赋值后就构成了零空间的 n - r 个基向量，故零空间维数为：n - r 。<br>③<strong>行空间</strong><br>A 的行空间可以化为 $A^T$ 的列空间。但我们这里使用的方法是直接对 A 的行向量进行变换（其实一样），最后行空间的维数也是秩数 r。  </p><p>以下述矩阵为例：</p><script type="math/tex; mode=display">A = \begin{bmatrix} 1 & 2 & 3 & 1 \\ 1 & 1 & 2 & 1 \\ 1 & 2 & 3 & 1 \end{bmatrix} \to \begin{bmatrix} 1 & 0 & 1 & 1 \\ 0 & 1 & 1 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} = \begin{bmatrix} I & F \\ 0 & 0 \end{bmatrix} = R</script><p>显然，A 只有两行线性无关，所以 A 秩为 2，所以 A 行向量的基就是 R 的前两行。维数为 2。</p><blockquote><p>注：经过行变换，矩阵 A 的列空间显然改变了：C(A) ≠ C(R)。但是行变换并没有改变 A 的行空间，因为所谓行空间就是 A 行向量的线性组合，而我们进行的行变换就是取原来行向量的一些线性组合，并没有改变行空间。</p></blockquote><p>从上面这个例子中，可以得知，行空间会在行最简型 R 中以最佳形式表现出来。也就是说，将 A 化简为行最简型 R 后取前 r 行向量，即为 A 行空间的基。</p><p>④<strong>左零空间</strong><br>左零空间，写成方程形式，即 $A^Ty = 0$，将方程两边同时转置，得到：$y^TA = 0$。我们看到，对于 A 矩阵本身来说，$y^T$ 左乘矩阵 A 得到零向量，所以我们称之为左零空间。然而，理解为 $A^T$ 的零空间更直接一点。因为 $A^T$ 是一个 n × m 的矩阵，所以以 $A^T$ 零空间维数为 m - r。</p><p>为找到左零空间的基，我们应用高斯-若尔当消元法使用增广矩阵：$[A_{m \times n} \quad I_{m \times n}] \to [R_{m \times n} \quad E_{m \times n}]$，因为我们将 A 通过消元得到矩阵 R ，其消元矩阵记为 E ，即 EA = R。那么 A 变为 R 相当于左乘 E 矩阵，同样处理单位阵 I，得到的即是矩阵 E。</p><p>还是上面的例子中的矩阵：</p><script type="math/tex; mode=display">EA = \begin{bmatrix} -1 & 2 & 0 \\ 1 & -1 & 0 \\ -1 & 0 & 1 \end{bmatrix} \begin{bmatrix} 1 & 2 & 3 & 1 \\ 1 & 1 & 2 & 1 \\ 1 & 2 & 3 & 1 \end{bmatrix} = \begin{bmatrix} 1 & 0 & 1 & 1 \\ 0 & 1 & 1 & 0 \\ 0 & 0 & 0 & 0 \end{bmatrix} = R</script><p>以“行操作”的观点来看矩阵 E 和 A 的乘法，则矩阵 E 最下面的 m - r 个行向量使得矩阵 A 的行向量线性组合成为 0，也就是矩阵 R 最下面的 m - r 个零向量。本例中，m - r = 1。</p><p>矩阵 E 的这 m - r 个行向量满足 $y^TA = 0$ ，它组成了矩阵 A 左零空间的一组基。</p><h1 id="第十一课-矩阵空间、秩1矩阵和小世界图"><a href="#第十一课-矩阵空间、秩1矩阵和小世界图" class="headerlink" title="第十一课 矩阵空间、秩1矩阵和小世界图"></a>第十一课 矩阵空间、秩1矩阵和小世界图</h1><blockquote><p>这节课和下节课和前面的课程有所区别，前面的课程偏向于介绍矩阵的基础知识，将矩阵运算和线性方程组结合了起来。这两节课程则偏向于线性方程组的扩展应用，它可以是线性关系抽象出来的方程，也可以是从微分方程或者从图论的角度建立起来的关系式。可以说前面的课程偏向于解方程，而这两节偏向于建模来解决实际问题。</p></blockquote><h2 id="矩阵空间"><a href="#矩阵空间" class="headerlink" title="矩阵空间"></a>矩阵空间</h2><p><strong>向量空间</strong>是指由一组向量构成的集合，满足一定的线性运算规则，如加法和数量乘法。<strong>矩阵空间</strong>则是指所有特定大小的矩阵组成的集合，同样满足线性运算规则。主要区别在于向量空间中的元素是向量，而矩阵空间中的元素是矩阵。</p><p><strong>矩阵空间</strong>可以理解为一种新的对空间的定义，线性空间里的元素并不一定是实数组成的向量，可以将所有 3 * 3 的矩阵当成一个所谓“向量空间”中的向量，只要满足线性空间的八条规律，对线性运算封闭，就可以将其当做线性空间中的元素。</p><blockquote><p>拓展 - 线性空间八条运算法则：①加法交换律：对于任意两个向量 u 和 v，u + v = v + u；②加法结合律：对于任意三个向量 u、v 和 w，(u + v) + w = u + (v + w)；③零向量存在性：存在一个零向量 0，使得对于任意向量 u，u + 0 = u；④加法逆元存在性：对于任意向量 u，存在一个加法逆元 -u，使得 u + (-u) = 0；⑤数乘单位元存在性：对于任意向量 u，存在一个单位元 1，使得 1u = u；⑥数乘结合律：对于任意标量 k 和向量 u，k(au) = (ka)u；⑦数乘分配律 1：对于任意标量 k 和向量 u、v 的和，k(u + v) = ku + kv；⑧数乘分配律 2：对于任意两个标量 k 和 l 以及向量 u，(k + l)u = ku + lu。</p></blockquote><p>因为矩阵本身也满足线性空间的八条运算律，我们就可以将所有的 3 * 3 矩阵构成的集合看做一个线性空间，称之为 $\,M\,$。</p><p>$\,M\,$ 的子空间包括：①所有的上三角矩阵，记为 $\,U\,$；②所有的对称矩阵，记为 $\,S\,$；③所有的对角矩阵，记为 $\,D\,$，它是前两个子空间的交集。</p><h3 id="M-的基与维数"><a href="#M-的基与维数" class="headerlink" title="M 的基与维数"></a>M 的基与维数</h3><p>空间 $\,M\,$ 的维数为 9，与 $\,R^9\,$ 的向量空间类似，只不过这里的基是矩阵，不是向量：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \end{bmatrix}, \begin{bmatrix} 0 & 1 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \end{bmatrix}, \begin{bmatrix} 0 & 0 & 1 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \end{bmatrix} \cdots \begin{bmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 1 \end{bmatrix}</script><p>对称矩阵构成的子空间 $\,S\,$ 维数为 6，它的一组基为：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \end{bmatrix}, \begin{bmatrix} 0 & 1 & 0 \\ 1 & 0 & 0 \\ 0 & 0 & 0 \end{bmatrix}, \begin{bmatrix} 0 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 0 \end{bmatrix}, \begin{bmatrix} 0 & 0 & 1 \\ 0 & 0 & 0 \\ 1 & 0 & 0 \end{bmatrix}, \begin{bmatrix} 0 & 0 & 0 \\ 0 & 0 & 1 \\ 0 & 1 & 0 \end{bmatrix}, \begin{bmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 1 \end{bmatrix}</script><p>上三角矩阵构成的子空间 $\,U\,$ 维数也为 6，它的一组基为：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \end{bmatrix}, \begin{bmatrix} 0 & 1 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \end{bmatrix}, \begin{bmatrix} 0 & 0 & 1 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \end{bmatrix}, \begin{bmatrix} 0 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 0 \end{bmatrix}, \begin{bmatrix} 0 & 0 & 0 \\ 0 & 0 & 1 \\ 0 & 0 & 0 \end{bmatrix}, \begin{bmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 1 \end{bmatrix}</script><p>对角矩阵构成的子空间 $\,D\,$ 维数为 3，可以选定 $\,S\,$ 和 $\,U\,$ 的基的交集为 $\,D\,$ 的基。</p><p>$\,S\,$ 和 $\,U\,$ 的并集，即 3x3 矩阵中或为上三角阵或为对称阵的矩阵，却不构成 $\,M\,$ 的子空间。因为这就如同在 $\,R^2\,$ 空间中找出两条直线，询问它们的并集是否构成一个子空间。如果我们将 $\,S\,$ 和 $\,U\,$ 中所有元素可能构成的加和作为一个集合，即包含了它们两个的线性组合，可以称为和集 $\,S+U\,$，它是 $\,M\,$ 的一个子空间。实际上 $\,S+U\,$ 就是 $\,M\,$ 本身，其维数为 9。</p><p>联系上面的所有维数，有这样一个等式：</p><script type="math/tex; mode=display">\begin{align*} dim(S) + dim(U) &= dim( S \cap U ) + dim( S + U ) \\ \,\,\,\,\,\,\,\,6\,\,\,\,\,\,\,\, + \,\,\,\,\,\,\,\,6\,\,\,\,\,\,\,\,\, &= \,\,\,\,\,\,\,\,3\,\,\,\,\,\,\,\, + \,\,\,\,\,\,\,\,9\,\,\,\,\,\,\,\, \end{align*}</script><h2 id="微分方程-Differential-Equations"><a href="#微分方程-Differential-Equations" class="headerlink" title="微分方程 Differential Equations"></a>微分方程 Differential Equations</h2><p>同样的“空间”概念还适用于很多地方，这样的线性空间内元素不一定是向量，矩阵，还可以是方程的解。</p><p>例如，解微分方程：  </p><script type="math/tex; mode=display">\frac {d^2y} {dx^2} + y = 0</script><blockquote><p>该公式就是 y 的二阶导加上其本身等于 0，即 $y’’ + y = 0$</p></blockquote><p>很明显这个微分方程有两个特解：$y = \sin x$ 和 $y = \cos x$。</p><p>而所有的解就是这两个特解的线性组合：$y = c_1 \cos x + c_2 \sin x$。这类似于零空间，也就是说我们将这些解看做线性空间中的元素也可以。所以我们可以称其为解空间。其中的元素是解，满足线性运算封闭条件。那么从空间的角度出发，这个解空间两个基就是 cosx 与 sinx，其线性组合构成了解空间，所以解空间维数为 2。</p><h2 id="轶一矩阵"><a href="#轶一矩阵" class="headerlink" title="轶一矩阵"></a>轶一矩阵</h2><p>矩阵 $A = \begin{bmatrix} 1 &amp; 4 &amp; 5 \\ 2 &amp; 8 &amp; 10 \end{bmatrix} = \begin{bmatrix} 1 \\ 2 \end{bmatrix} \begin{bmatrix} 1 &amp; 4 &amp; 5 \end{bmatrix}$，矩阵的轶为 1。</p><p>所有的秩一矩阵都可分解为 $A = UV^T$，其中 U 和 V 都是列向量。秩一矩阵的行列式和特征值都很简单，它可以被当作是构建其他矩阵的“积木”。其实我们在矩阵乘法的第四种形式里面见过它的作用。例如若存在一个 5x17 的矩阵 M，而其秩为 4，那么它可以由 4 个秩一矩阵组合而成。</p><p>若矩阵空间 M 为所有的 5x17 矩阵，那么 M 中所有的秩为 4 的矩阵所构成的集合是一个子空间么？答案是否定的，即使加入零矩阵也无法构成子空间，对于两个矩阵的加和，秩为 4 的矩阵集合并不封闭：  </p><script type="math/tex; mode=display">R(A + B) \le R(A) + R(B)</script><p>M 这个集合对加法不封闭。两个秩为 4 的矩阵相加，结果的秩可能大于 4。所以所有秩为 4 的矩阵集合并不能构成空间。同理，秩为 1 的矩阵集合也不能构成空间。</p><h2 id="子空间的转换"><a href="#子空间的转换" class="headerlink" title="子空间的转换"></a>子空间的转换</h2><p>在 $\,R^4\,$ 空间中的向量都有 4 个分量，即 $ v = \begin{bmatrix} v_1 \\ v_2 \\ v_3 \\ v_4 \end{bmatrix}$，设 S 为一个集合，其中的向量都满足： $v_1 + v_2 + v_3 + v_4 = 0$ ，那么 S 是一个子空间吗？S 显然是一个子空间，$v_1 + v_2 + v_3 + v_4 = 0$ 这个特点，对加法和数乘都封闭。而且 S 中肯定有零向量，故 S 是一个子空间。</p><p>假设有一矩阵 A，$A = \begin{bmatrix}1 &amp; 1 &amp; 1 &amp; 1\end{bmatrix}$，可以得到：  </p><script type="math/tex; mode=display">AV = \begin{bmatrix}1 & 1 & 1 & 1\end{bmatrix} \begin{bmatrix} v_1 \\ v_2 \\ v_3 \\ v_4 \end{bmatrix} = v_1 + v_2 + v_3 + v_4 = 0</script><p>这样一来就构建了 Ax = 0 的方程，将 S 空间转化为了 A 的零空间。矩阵 A 的秩 r 为 1，列数 n = 4，主元只有一个，自由变元有三个。因此维度为 n - r = 3，S 的零空间是三维空间。其基为 Av = 0 的三个特解：</p><script type="math/tex; mode=display">\begin{bmatrix} -1 \\ 1 \\ 0 \\ 0 \end{bmatrix}, \begin{bmatrix} -1 \\ 0 \\ 1 \\ 0 \end{bmatrix} \begin{bmatrix} -1 \\ 0 \\ 0 \\ 1 \end{bmatrix}</script><blockquote><p>本例的一个意义就是寻找子空间维数的逆向思路，可以考虑它是不是某个方程的解空间，在这里它是矩阵 A 的零空间，我们可以从矩阵推出这个空间的维数。</p></blockquote><p>矩阵 A 的列空间为 $\,R^1\,$。左零空间仅包含零向量，维数为 0。</p><h2 id="小世界图-Small-world-graphs"><a href="#小世界图-Small-world-graphs" class="headerlink" title="小世界图 Small world graphs"></a>小世界图 Small world graphs</h2><p>介绍小世界图主要是引出图论和线性代数的联系，对下一节“图与网络”的引出。</p><div  align="center">  <img src="https://s2.loli.net/2024/02/10/BCOFH3rnegoVJPU.jpg" width = "30%" height = "30%" alt="图1- 图：结点和边的集合"/></div><p>在这里，图是结点和边的集合。上图包含 5 个结点和 6 条边，我们可以利用一个 5 x 6 矩阵完全描述它。</p><p>另外，大家应该也听说过“六度分割理论”，任何两位素不相识的人之间，通过一定的联系方式，总能够产生必然联系或关系。这个概念即是将人抽象成点，将联系抽象为图。<strong>六度分割理论 six degrees of separation</strong> 猜想一个人和陌生人之间间隔的点不会超过六个。因此当陌生的两人聊起这种联系都会感叹：“世界真小啊！”这也是“小世界图”这个名字的由来。</p><h1 id="第十二课-图、网络、关联矩阵"><a href="#第十二课-图、网络、关联矩阵" class="headerlink" title="第十二课 图、网络、关联矩阵"></a>第十二课 图、网络、关联矩阵</h1><blockquote><p>该节我看完时颇为震撼。</p></blockquote><p>本节主要讲述矩阵在实际问题中的作用。</p><h2 id="图和关联矩阵"><a href="#图和关联矩阵" class="headerlink" title="图和关联矩阵"></a>图和关联矩阵</h2><p><strong>结点</strong>和<strong>边</strong>的一个集合，离散数学称为<strong>图</strong>。图论是离散数学的一个分支。</p><div  align="center">  <img src="https://s2.loli.net/2024/02/12/a4SIQb13MDPoVzc.jpg" width = "35%" height = "35%" alt="图2- 有向图"/></div><p>根据上图，可以写出一个矩阵来表示图的内在含义，该矩阵称为<strong>关联矩阵 Incidence Matrices</strong>：  </p><script type="math/tex; mode=display">\begin{bmatrix} -1 & 1 & 0 & 0 \\ 0 & -1 & 1 & 0 \\ -1 & 0 & 1 & 0 \\ -1 & 0 & 0 & 1 \\ 0 & 0 & -1 & 1 \end{bmatrix}</script><p>图中每个结点代表矩阵的一列，每边代表一行。第一行代表边①，从结点 1 流出记为 -1，从结点 2 流入记为 1。</p><p>接下来就要从实际问题来研究图所代表的实际意义，这里选择该图表示的是电路网络。我们假设 x 为每个结点上的电势，研究 Ax = b 形式下，可以得到些什么定律。<br>①首先考虑零空间，即求 Ax = 0 的解，矩阵乘法得到以下结果：  </p><script type="math/tex; mode=display">Ax = \begin{bmatrix} -1 & 1 & 0 & 0 \\ 0 & -1 & 1 & 0 \\ -1 & 0 & 1 & 0 \\ -1 & 0 & 0 & 1 \\ 0 & 0 & -1 & 1 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \\ x_3 \\ x_4 \end{bmatrix} = \begin{bmatrix} x_2 - x_1 \\ x_3 - x_2 \\ x_3 - x_1 \\ x_4 - x_1 \\ x_4 - x_3 \end{bmatrix} = \begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}</script><p>不难得到：</p><script type="math/tex; mode=display">x = C \begin{bmatrix} 1 \\ 1 \\ 1 \\ 1 \end{bmatrix}</script><p>上述公式表达了：x 为结点上的电势，则 Ax 给出了每个边上的电势差。x 的解集代表在相等电势条件下不会有电流产生。  </p><p>考虑矩阵的列空间，矩阵的列数为 4，而其零空间的维数为 1，则矩阵的秩为 3，矩阵第 1 列，第 2 列，第 4 列的列向量线性无关。</p><p>②若求 Ax = b 的解，则相当于在给定了电压 b 的情况下，求各点的电势，但实际上我们得不到电势的准确值，因为零空间有常数解 c，各点得到的电势需要加上常数 c，这很类似于求积分要加上常函数，常数值需要边界条件来确定。</p><p>③接下来考虑左零空间 $\,A^Ty = 0\,$，A 转置后行列互换，对应的 y 一共有五个分量，即 y 为流过每条边的电流。A 矩阵的转置为：  </p><script type="math/tex; mode=display">\begin{bmatrix} -1 & 0 & -1 & -1 & 0 \\ 1 & -1 & 0 & 0 & 0 \\ 0 & 1 & 1 & 0 & -1 \\ 0 & 0 & 0 & 1 & 1 \end{bmatrix}</script><p>矩阵 $\,A^T\,$ 有 5 列，且矩阵的秩为 3，因此矩阵的左零空间维数为 2。$\,A^Ty = 0\,$ 方程如下：  </p><script type="math/tex; mode=display">A^Ty = \begin{bmatrix} -1 & 0 & -1 & -1 & 0 \\ 1 & -1 & 0 & 0 & 0 \\ 0 & 1 & 1 & 0 & -1 \\ 0 & 0 & 0 & 1 & 1 \end{bmatrix} \begin{bmatrix} y_1 \\ y_2 \\ y_3 \\ y_4 \\ y_5 \end{bmatrix} = \begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}</script><p>即：  </p><script type="math/tex; mode=display">\left\{ \begin{align*} -y_1 - y_3 - y_4 &= 0 \\ y_1 - y_2 &= 0 \\ y_2 + y_3 - y_5 &= 0 \\ y_4 + y_5 &= 0 \end{align*} \right.</script><p>上述每条方程式都是关于一个结点，方程表示结点电流值为 0，即流入等于流出，也就是说上面的方程阐释了一个定律 - <strong>基尔霍夫定律</strong>：在任意闭合回路中，流入该回路的电流之和等于流出该回路的电流之和。建议结合“图”一起看。我们最后解得的 y 就是满足基尔霍夫定律的各条边的电流值。</p><div  align="center">  <img src="https://s2.loli.net/2024/02/12/rCscIGfpug8lFmt.jpg" width = "35%" height = "35%" alt="图3- 有向图"/></div><p>我们也可以直接从图上看出 $\,A^Ty = 0\,$ 的两个特解，比如让 y1，y2 和 y3 组成的回路的“环流“为 0，即 y1 = 1 ，y2 = 1，y3 = -1，这样形成了一个小的闭环，写成向量为 $ y = \begin{bmatrix} 1 \\ 1 \\ -1 \\ 0 \\ 0 \end{bmatrix}$。另一个特解即右边的小环，y3 = 1，y4 = -1，y5 = 1，即 $ y = \begin{bmatrix} 0 \\ 0 \\ 1 \\ -1 \\ 1 \end{bmatrix}$。而若要 y1，y2，y4 和 y5 组成的大回路环流为 0，则 y1 = 1，y2 = 1，y4 = -1，y5 = 1，这个向量是前两个向量的线性组合。</p><p>考察矩阵 A 的<strong>行空间</strong>，因为矩阵 r = 3，所以存在 3 个线性无关的向量。第 1 行，第 2 行和第 4 行为线性无关，在“图”中，边①,边②和边④构成了一张小图，这三个边没有形成回路。线性相关问题等价于形成回路。没有回路的小图包含 4 个结点和 3 条边，再添加一条边就会产生回路，在矩阵里表现为在第 1 行，第 2 行和第 4 行之上再添加一个行向量就会变为线性相关。没有回路的图称为<strong>树 tree</strong>。</p><h2 id="思考一下维数公式的在“图”中的意义"><a href="#思考一下维数公式的在“图”中的意义" class="headerlink" title="思考一下维数公式的在“图”中的意义"></a>思考一下维数公式的在“图”中的意义</h2><p>左零空间的维数 $dim\,N(A^T)=m-r$；而左零空间的维数即图中小环的数量，m 就是边的数量，r 为节点数量 - 1。综上，结点数 - 边数 + 环数 = 1，该公式为二维的拓扑学欧拉公式，对所有图都成立。</p><blockquote><p>拓扑学中的欧拉公式：对于一个单联通的多面体，V - E + F = 2，其中 V 表示顶点数，E 表示边数，F 表示面数。1 和 2 是因为二维图和三维多面体的不同。</p></blockquote><h2 id="结合"><a href="#结合" class="headerlink" title="结合"></a>结合</h2><script type="math/tex; mode=display">电势 \begin{bmatrix} x_1 \\ x_2 \\ x_3 \\ x_4 \end{bmatrix} \xrightarrow[Ax = e]{矩阵 A} 电势差 \begin{bmatrix} x_2 - x_1 \\ x_3 - x_2 \\ x_3 - x_1 \\ x_4 - x_1 \\ x_4 - x_3 \end{bmatrix} \xrightarrow[欧姆定律 y = Ce]{矩阵 C} 电流 \begin{bmatrix} y_1 \\ y_2 \\ y_3 \\ y_4 \\ y_5 \end{bmatrix} \xrightarrow{矩阵 A^T} 基尔霍夫定律 A^Ty = f</script><p>第一步，即给定电压，求解 Ax = e，得到电势差。第二步，电势差根据欧姆定律（在同一电路中，通过某一导体的电流跟这段导体两端的电压成正比）乘上矩阵 C，得到电流 y。第三步即基尔霍夫定律，之前的讨论都是针对于一个无源的电场，如果加入电源则情况又不同，例如加入电流源相当于将基尔霍夫定律的方程变为 $A^Ty = f$，$\,f\,$ 就是外部流入的电流。</p><p>将 $Ax = e$，$y = Ce$，$A^Ty = f$，三个等式结合得到应用数学中的基本方程 $A^TCAx = f$。</p><blockquote><p>关于上述方程，有兴趣可以查阅 G.Strang 的书《Computational science and engineering》的第二章。</p></blockquote><h1 id="第十三课-复习一"><a href="#第十三课-复习一" class="headerlink" title="第十三课 复习一"></a>第十三课 复习一</h1><p>本讲为考前复习课，考试范围就是 Ax = b 这个单元，重点是长方形矩阵（不可逆），与此相关的概念包括零空间、左零空间、秩、向量空间、子空间，特别是四个基本子空间。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>例 1</strong>：设 u，v，w 是 $R^7$ 空间内的非零向量，由他们生成了一个属于 $R^7$ 的向量子空间，则此空间的维数是多少？</p><p><strong>答案</strong>：三个向量张开的空间，很明显维数只能是 0, 1, 2, 3。本题中维数不可能是 0，因为题设为非零向量。所以最后答案为：1, 2, 3。</p><p><strong>例 2</strong>：有一个 5 x 3 的阶梯形矩阵 R，秩为 3。<br>①求矩阵 R 的零空间。<br>②给定 10 x 3 矩阵 B，B 中含有矩阵 R 和 2R：$\,B = \begin{bmatrix} R \\ 2R \end{bmatrix}\,$ （R 是行最简形矩阵）。该矩阵的秩是多少？其行最简阶梯矩阵又是怎样的？<br>③令 $\,C = \begin{bmatrix} U &amp; U \\ U &amp; 0 \end{bmatrix}\,$，求它的行最简阶梯矩阵？<br>④C 的秩？<br>⑤C 左零空间的维数 $\,dim\,N(C^T)\,$？</p><p><strong>答案</strong>：<br>①因为列数为 3 且秩为 3，其列向量线性无关，没有线性组合能得到零向量，则 Rx = 0 只有零解。<br>②利用分块矩阵思想，B 可化简为：$\,\begin{bmatrix} R \\ 0 \end{bmatrix}\,$。这就是 B 的行最简阶梯矩阵。<br>③B 的秩即为矩阵 R 的秩，即为 3。<br>④6，B 的秩为 3。<br>⑤m = 10 而 r = 6，所以 $\,dim\,N(C^T) = 4\,$。</p><p><strong>例 3</strong>：$\,Ax = \begin{bmatrix} 2 \\ 4 \\ 2 \end{bmatrix}\,$，且 $\,x = \begin{bmatrix} 2 \\ 0 \\ 0 \end{bmatrix} + c \begin{bmatrix} 1 \\ 1 \\ 0 \end{bmatrix} + d \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}\,$。<br>①矩阵 A 的形状？<br>②矩阵 A 的行空间的维数？<br>③求矩阵 A。<br>④什么样的向量 b 使得方程 Ax = b 有解 x？</p><p><strong>答案</strong>：<br>①矩阵 A 的形状是 3 x 3。<br>②从通解的形式可以看出 A 零空间的维数为 2，则其行空间的维数为 3 - 2 = 1。<br>③代入特解 $\,A\begin{bmatrix} 2 \\ 0 \\ 0 \end{bmatrix} = \begin{bmatrix} 2 \\ 4 \\ 2 \end{bmatrix}$，可知 A 的第一列为 $\,\begin{bmatrix} 1 \\ 2 \\ 1 \end{bmatrix}\,$。代入零空间的特解 $\,A\begin{bmatrix} 1 \\ 1 \\ 0 \end{bmatrix} = 0$，可知 A 的第二列为 $\,\begin{bmatrix} -1 \\ -2 \\ -1 \end{bmatrix}\,$。代入零空间的另一个特解 $\,A\begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix} = 0$，故 $\,A = \begin{bmatrix} 1 &amp; -1 &amp; 0 \\ 2 &amp; -2 &amp; 0 \\ 1 &amp; -1 &amp;0 \end{bmatrix}\,$。<br>④当 b 在矩阵 A 的列空间内的时候，方程有解。本题中 b 需为 $\,\begin{bmatrix} 1 \\ 2 \\ 1 \end{bmatrix}\,$ 的倍数。</p><p><strong>例 4</strong>：如果一个方阵 A 的零空间只包含零向量，那它转置矩阵的零空间呢？  </p><p><strong>答案</strong>：A 转置的零空间也只有零向量。</p><p><strong>例 5</strong>：所有的 5 x 5 可逆矩阵，是否构成 5 x 5 矩阵空间的子空间？</p><p><strong>答案</strong>：否。因为零矩阵不包含在内，肯定不是向量空间。而且两个可逆矩阵相加不一定是可逆矩阵，不对加法封闭。</p><p><strong>例 6</strong>：存在除零矩阵外的平方为零的矩阵吗？  </p><p><strong>答案</strong>：否。例如：$\,\begin{bmatrix} 0 &amp; 1 \\ 0 &amp; 0 \end{bmatrix}\,$</p><p><strong>例 7</strong>：方阵 A 的列线性无关，Ax = b 是否总是有解的？</p><p><strong>答案</strong>：是，方阵 A 为可逆矩阵，所以 $\,x = A^{-1}b$ 是唯一解。</p><p><strong>例 8</strong>：矩阵 $\,B = CD = \begin{bmatrix} 1 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; -1 &amp; 2 \\ 0 &amp; 1 &amp; 1 &amp; -1 \\ 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix} \,$。<br>①给出矩阵 B 零空间的一组基。<br>②求 $\,Bx = \begin{bmatrix} 1 \\ 0 \\ 1 \end{bmatrix}\,$ 的通解。</p><p><strong>答案</strong>：<br>①首先知道的是：由 B 是 3 x 4 矩阵，有四个列向量。因此 B 的零空间必是 $\,R^4\,$ 的子空间。除此之外，B 是由一个可逆矩阵左乘上矩阵得到的，那么我们在 Ax = 0 两侧同时左乘上 C 的逆矩阵，这样也不会影响到 B 零空间的求解。也就是说，B 的零空间求解只取决于 D 矩阵，即 $\,\begin{bmatrix} 1 &amp; 0 &amp; -1 &amp; 2 \\ 0 &amp; 1 &amp; 1 &amp; -1 \\ 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \\ x_3 \\ x_4 \end{bmatrix} = 0\,$。矩阵 D 已经是行最简阶梯矩阵了，可解得其零空间的一组基为 $\,\begin{bmatrix} 1 \\ -1 \\ 1 \\ 0 \end{bmatrix}\,$ 和 $\,\begin{bmatrix} -2 \\ 1 \\ 0 \\ 1 \end{bmatrix}\,$。</p><p>左乘可逆矩阵，相当于对行向量进行可逆的线性组合。既不改变行空间，也不改变零空间。</p><p>②观察 B 的第一列（计算可得），B 的第一列恰好就是等式右侧的 b：$\,\begin{bmatrix} 1 \\ 0 \\ 1 \end{bmatrix}\,$。  </p><script type="math/tex; mode=display">B = \begin{bmatrix} 1 & 1 & 0 \\ 0 & 1 & 0 \\ 1 & 0 & 1 \end{bmatrix} \begin{bmatrix} 1 & 0 & -1 & 2 \\ 0 & 1 & 1 & -1 \\ 0 & 0 & 0 & 0 \end{bmatrix} = \begin{bmatrix} 1 & * & * & * \\ 0 & * & * & * \\ 1 & * & * & * \end{bmatrix}</script><p>于是可以很快地写出一个特解：$\,\begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}\,$。其通解就是特解和零空间的解的合并：$\,x = \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix} + c \begin{bmatrix} 1 \\ -1 \\ 1 \\ 0 \end{bmatrix} + d \begin{bmatrix} -2 \\ 1 \\ 0 \\ 1 \end{bmatrix}\,$</p><p><strong>例 9</strong>：A 为方阵，则它的行空间和列空间相同？  </p><p><strong>答案</strong>：否，只是空间的维数相等，但空间不一定相同。</p><p><strong>例 10</strong>：矩阵 A 和 -A 的四个子空间相同？</p><p><strong>答案</strong>：是，相同。</p><p><strong>例 11</strong>：如果 A 与 B 的四个子空间相同，则 A 是 B 的倍数。</p><p><strong>答案</strong>：错误，例如：任意的可逆矩阵的四个子空间都相同。不一定非要成倍数。</p><p><strong>例 12</strong>：给定矩阵 A，交换其中的两行，哪些子空间没变？</p><p><strong>答案</strong>：行空间与零空间</p><p><strong>例 13</strong>：为什么向量（1，2，3）不能既是 A 的某一行，又在 A 零空间中？</p><p><strong>答案</strong>：直接代入方程 Ax = 0 看一下就知道了：  </p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 2 & 3 \\ * & * & * \\ * & * & * \end{bmatrix} \begin{bmatrix} 1 \\ 2 \\ 3 \end{bmatrix} = \begin{bmatrix} 0 \\ 0 \\ 0 \end{bmatrix}</script><p>这不可能成立。给定矩阵，其行空间与零空间共享的向量只能是零向量（以后会提到：矩阵的零空间与行空间正交）</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 3d数学基础 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Unity Shader入门精要》读书笔记（五）</title>
      <link href="/2023/12/30/2023-12-30-UnityShader5/"/>
      <url>/2023/12/30/2023-12-30-UnityShader5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本读书笔记为高级篇的最后一章和扩展篇，主要内容为高级篇最后一章渲染优化；扩展篇的表面着色器以及 PBS。<br>读书笔记是对知识的记录与总结，但是对比较熟悉的内容不会再行描述。</p></blockquote><h1 id="第十五章-Unity-中的渲染优化技术"><a href="#第十五章-Unity-中的渲染优化技术" class="headerlink" title="第十五章 Unity 中的渲染优化技术"></a>第十五章 Unity 中的渲染优化技术</h1><p>在本章中，将会阐述一些 Unity 常见的优化技术。这些优化技术都是和渲染有关的，例如：使用批处理、LOD 技术（Level of Detail）等。</p><h2 id="移动平台的特点"><a href="#移动平台的特点" class="headerlink" title="移动平台的特点"></a>移动平台的特点</h2><p>和 PC 平台相比，移动平台上的 GPU 架构有很大的不同。由于处理资源等条件的限制，移动设备上的 GPU 架构专注于尽可能使用更小的带宽和功能，也由此带来许多和 PC 不同的现象。</p><p>例如，为了尽可能移除一些隐藏的表面，减少 overdraw（同一像素绘制多次），PowerVR 芯片（用于 iOS 设备和一些 Android 设备）使用<strong>基于瓦片的延迟渲染 Tiled-based Deferred Rendering, TBDR</strong> 架构，把所有渲染图像装入一个个瓦片中，由硬件找到可见的片元，并只对它们执行片元着色器；另一些基于瓦片的 GPU 架构，如：Adreno（高通的芯片）和 Mali（ARM 的芯片），则会使用 Early-Z 或相似的技术进行低精度的深度检测，剔除不需要渲染的片元。还有一些 GPU，如 Tegra（英伟达的芯片），则使用了传统的架构设计，因此在这些设备上，overdraw 更可能造成性能的瓶颈。</p><p>由于这些芯片架构造成的不同，一些游戏往往需要针对不同的芯片发布不同的版本，以便对每个芯片进行更有针对性的优化。</p><h2 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h2><p>游戏主要使用两种计算资源：GPU 和 CPU。CPU 主要负责保证帧率，GPU 主要负责分辨率相关。把造成游戏性能瓶颈的主要原因分成以下几方面：<br>①CPU：<br>&emsp;&emsp; - 过多的 drawcall，每次调用 Draw Call，CPU 往往需要改变很多渲染状态的设置，这些操作非常耗时，若大部分时间花费在提交 Draw Call 的准备工作上，会导致性能下降；<br>&emsp;&emsp; - 复杂的脚本或者模拟（物理、布料、蒙皮、粒子等）。<br>②GPU<br>&emsp;&emsp; - 过多的顶点或过多的逐顶点计算；<br>&emsp;&emsp; - 过多的片元（可能是由于分辨率造成，也有可能是 overdraw）或过多的逐片元计算。<br>③带宽<br>&emsp;&emsp; - 使用了尺寸很大且未压缩的纹理；<br>&emsp;&emsp; - 分辨率过高的帧缓存。</p><hr><p>在了解上面的基本内容后，本章后续涉及的优化技术有：<br>①CPU 优化：<br>&emsp;&emsp; - 使用批处理技术减少 Draw Call 数目；<br>②GPU 优化：<br>减少需要处理的顶点数目：<br>&emsp;&emsp; - 优化几何体；<br>&emsp;&emsp; - 使用模型的 LOD（Level of Detail）技术；<br>&emsp;&emsp; - 使用遮挡剔除 Occlusion Culling 技术；<br>减少需要处理的片元数目：<br>&emsp;&emsp; - 控制绘制顺序；<br>&emsp;&emsp; - 警惕透明物体；<br>&emsp;&emsp; - 减少实时光照；<br>减少计算复杂度：<br>&emsp;&emsp; - 使用 Shader 的 LOD（Level of Detail）技术；<br>&emsp;&emsp; - 代码方面的优化；<br>③节省内存带宽：<br>&emsp;&emsp; - 减少纹理大小；<br>&emsp;&emsp; - 利用分辨率缩放。</p><h2 id="Unity-中的渲染分析工具"><a href="#Unity-中的渲染分析工具" class="headerlink" title="Unity 中的渲染分析工具"></a>Unity 中的渲染分析工具</h2><p>Unity 内置了一些工具，用来查看和渲染相关的统计数据，包括渲染统计窗口 Rendering Statistics Window、性能分析器 Profiler，以及帧调试器 Frame Debugger。</p><h3 id="渲染统计窗口"><a href="#渲染统计窗口" class="headerlink" title="渲染统计窗口"></a>渲染统计窗口</h3><p>就是 Game 窗口的 Stats 按钮。图片不放出了，主要包括 3 个方面的信息：音频 Audio、图像 Graphics 和网络 Network。而图像相关的渲染统计结果包含了很多重要的渲染数据，如下表：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">信息名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">每帧的时间和 FPS</td><td style="text-align:left">Frame per Second，后面的括号中显示的是当前帧的耗时</td></tr><tr><td style="text-align:left">CPU：main / render thread</td><td style="text-align:left">main 是主线程的耗时，render thread 是渲染线程的耗时</td></tr><tr><td style="text-align:left">Batches</td><td style="text-align:left">当前帧需要进行的批处理数目</td></tr><tr><td style="text-align:left">Saved by batching</td><td style="text-align:left">合并的批处理数目，这个数字表明了批处理为我们节省了多少 draw call</td></tr><tr><td style="text-align:left">Tris / Vertes</td><td style="text-align:left">当前帧绘制的三角面片和顶点的数目</td></tr><tr><td style="text-align:left">Screen</td><td style="text-align:left">屏幕的大小，及它占用的内存大小</td></tr><tr><td style="text-align:left">SetPass calls</td><td style="text-align:left">渲染使用的 Pass 的数目，每个 Pass 都需要 Unity 的 runtime 来绑定一个新的 Shader。数目越大，越容易产生 CPU 的性能瓶颈</td></tr><tr><td style="text-align:left">Shadow casters</td><td style="text-align:left">当前帧投射阴影的物体数目</td></tr><tr><td style="text-align:left">Visible skinned meshes</td><td style="text-align:left">渲染的蒙皮网格数目</td></tr><tr><td style="text-align:left">Animation / Animator components playing</td><td style="text-align:left">当前帧播放的 Animation / Animator 数目</td></tr></tbody></table></div><h3 id="性能分析器"><a href="#性能分析器" class="headerlink" title="性能分析器"></a>性能分析器</h3><p>Window -&gt; Analysis -&gt; Profiler 打开性能分析器 Profiler 。这里图片也不放了。性能分析器中的渲染模块 Rendering 提供了更多关于渲染的统计信息，比如，draw call 数目、动态批处理/静态批处理的数目、渲染纹理的数目和内存占用等。</p><p>使用 Unity 性能分析器可以通过三种主要方式记录数据：<br>①在目标平台上的播放器中对应用程序进行性能分析；<br>②在 Unity 编辑器中以运行模式对应用程序进行性能分析；<br>③对 Unity 编辑器进行性能分析。</p><p>获得有关应用程序性能的最佳方法是在打算发布它的终端平台上对它进行性能分析。详见官方文档：<a href="https://docs.unity3d.com/2022.3/Documentation/Manual/profiler-profiling-applications.html">https://docs.unity3d.com/2022.3/Documentation/Manual/profiler-profiling-applications.html</a></p><h3 id="帧调试器"><a href="#帧调试器" class="headerlink" title="帧调试器"></a>帧调试器</h3><p>Window -&gt; Analysis -&gt; Frame Debugger 打开帧调试器面板。在该窗口中可以看到每一个 draw call 的工作和结果。之前讲过，不再重复摘抄了。需要详细信息见官方文档：<a href="https://docs.unity3d.com/2022.3/Documentation/Manual/frame-debugger-window.html">https://docs.unity3d.com/2022.3/Documentation/Manual/frame-debugger-window.html</a></p><h3 id="其他性能分析工具"><a href="#其他性能分析工具" class="headerlink" title="其他性能分析工具"></a>其他性能分析工具</h3><p>①对 Android 平台来说：<br>&emsp;&emsp; - 高通的 Adreno 分析工具可以对不同的测试机进行详细的性能分析。<br>&emsp;&emsp; - 英伟达的 NVPerfHUD 工具可以帮助我们得到几乎所有需要的性能分析数据，如：每个 Draw Call 的 GPU 时间、每个 Shader 花费的 cycle 数目等。<br>②对 iOS 平台来说：<br>&emsp;&emsp; - PowerVRAM 的 PVRUniSCo Shader 分析器可以给出大致的性能评估。<br>&emsp;&emsp; - XCode 的 OpenGL ES Driver Instruments 可以给出一些宏观上的性能信息，如：设备利用率、渲染器利用率等。</p><p>相比 Android，对 iOS 的性能分析更加困难（工具较少）。且 PowerVR 芯片采用了基于瓦片的延迟渲染器，想得到每个 Draw Call 花费的 GPU 时间几乎不可能，所以一些宏观上的统计数据更有参考价值。</p><h2 id="减少-draw-call-数目"><a href="#减少-draw-call-数目" class="headerlink" title="减少 draw call 数目"></a>减少 draw call 数目</h2><p>最常见的优化技术大概就是<strong>批处理 batching</strong>了。批处理的实现原理就是为了减少每一帧需要的 draw call 的数量。为了把一个对象渲染到屏幕上，CPU 需要检查哪些光源影响了该物体，绑定 shader 并设置它的参数，再把渲染命令发送给 GPU。当场景中包含了大量对象时，这些操作会非常耗时。批处理就是在每次调用 draw call 时尽可能的处理多个物体。</p><p>什么样的物体可以进行一起批处理：即使用相同材质的物体。因为它们之间的不同仅仅在于顶点数据的差别，可以把这些顶点数据合并在一起发送给 GPU，就可以完成一次批处理。</p><p>Unity 支持两种批处理方式：<br>①<strong>动态批处理</strong>：有点在于一切都是Unity自动完成，无需自己做任何操作，物体可移动。缺点是限制太多，一不小心就破坏这种机制，导致无法动态批处理一些使用了相同材质的物体；<br>②<strong>静态批处理</strong>：自由度高，限制少。但是占用更多内存，而且经过静态批处理后的物体不能再移动（即使脚本中尝试改变物体的位置也是无效的）。</p><h3 id="动态批处理"><a href="#动态批处理" class="headerlink" title="动态批处理"></a>动态批处理</h3><p>如果场景中有一些模型共享了同一材质并满足了一些条件，Unity 就自动把它们进行批处理，从而只需要花费一个 draw call 就可以渲染所有模型。动态批处理的基本原理就是每一帧把可以进行批处理的模型网格进行合并，再把合并后模型数据传递给 GPU，然后使用同一个材质对其渲染。除了实现方便，动态批处理的另一个好处是，经过批处理的物体仍然可以移动，这是因为由于在处理每帧时 Unity 都会重新合并一次网格。</p><p>模型网格批处理合并的主要的条件限制（随着 Unity 版本变化，条件可能会改变）：<br>①网格的顶点属性规模要小于 900。例如，如果 Shader 中需要使用顶点位置、法线、纹理坐标这 3 个顶点属性，想要让模型被动态批处理，他们的顶点数目不能超过 300；<br>②一般来说，所有对象都需要使用同一个缩放尺度。一个例外情况是，如果所有物体都使用了不同的非统一缩放，那么也是可以被动态批处理的。但在 Unity 5 中，这种对模型缩放的限制不存在了；<br>③使用光照纹理 lightmap 的物体需要额外的渲染参数，例如，在光照纹理上的索引、偏移量和缩放信息等。为了让这些物体可以被动态批处理，需要保证它们指向光照纹理的同一个位置；<br>④多 Pass 的 shader 会中断批处理。前向渲染中，有时需要额外的 Pass 来为模型添加更多的光照效果，这样会导致模型无法被完全动态批处理。Unity 只会批处理第一个 Pass，不能为额外的逐像素光源进行批处理。</p><h3 id="静态批处理"><a href="#静态批处理" class="headerlink" title="静态批处理"></a>静态批处理</h3><p>相对于动态批处理来说，静态批处理适合于任何大小的几何模型。其实现原理是，只在运行开始阶段，把需要进行静态批处理的模型合并到一个新的网格结构中，这意味着这些模型不可以在运行时刻被移动。静态批处理的另一个缺点在于，它往往需要占用更多的内存来存储合并后的几何结构。因为，若在静态批处理前一些物体共享了相同的网格，那么在内存中每一个物体都会对应一个该网格的复制品，即一个网格会变成多个网格再发给 GPU。如果这一类使用同一网格的对象很多，那么将会成为一个性能瓶颈。</p><p>静态批处理的实现，只需要把物体面板右上角的 <strong>Static</strong> 勾选上即可，实际上只需要在其右边的下拉菜单里勾选 Batching Static 即可。</p><p>在内部实现上，Unity 首先把这些静态物体变换到世界空间下，为它们构建成一个更大的顶点和索引缓存。对于使用同一材质的物体，Unity 只需调用一个 Draw Call 就可以绘制全部物体；对于使用不同材质的物体，静态批处理同样可以提升渲染性能，尽管仍然需要调用多个 Draw Call，但静态批处理可以减少这些 Draw Call 之间的状态切换，而这些切换往往是费时的操作。我们可以从 Unity 的分析器中观察在应用静态批处理前后 <strong>VBO total</strong>（<strong>Vertex Buffer Object</strong>，顶点缓冲对象）的变化。VBO 的数目变大，即它需要更多的内存存储合并后的几何结构，即如果一些物体共享了相同的网格，那么在内存中每一个物体都会对应一个该网格的复制品。</p><p>若场景中包含了除了平行光以外的其他光源，并且在 shader 中定义了额外的 pass 来处理它们，这些 pass 将不会被批处理，而平行光的 base pass 仍然可以被静态批处理。</p><h3 id="共享材质"><a href="#共享材质" class="headerlink" title="共享材质"></a>共享材质</h3><p>无论是动态批处理还是静态批处理，都要求模型之间共享同一个材质。但不同模型之间总需要有不同的渲染属性，如：不同的纹理、颜色等，这时需要一些策略尽可能地合并材质。</p><p>如果两个材质之间只有使用的纹理不同，可以这些纹理合并到一张更大的纹理中，这张更大的纹理被称为一张<strong>图集 atlas</strong>。一旦使用了同一张纹理，就可以使用同一个材质，再使用不同的采样坐标对纹理采样即可。</p><p>但除了纹理不同外，不同的物体在材质上还有一些微小的参数变化。但是只要调整了参数，就会影响到所有使用了这个材质的对象。一个常用的解决方案就是使用网格的顶点数据（最常见的就是顶点颜色数据）来存储这些参数。前面说过，经过批处理后的物体会被处理成更大的 VBO 发送给 GPU，VBO 中的数据可以作为输入传递给顶点着色器，因此可以对 VBO 中的数据进行控制，从而达到不同的目的。</p><p>如果需要在脚本中访问共享材质，可以使用 <code>Renderer.sharedMaterial</code> 来修改共享材质。</p><h3 id="批处理的注意事项"><a href="#批处理的注意事项" class="headerlink" title="批处理的注意事项"></a>批处理的注意事项</h3><p>①尽可能选择静态批处理，要时刻小心对内存的消耗，记住经过静态批处理的物体不可以再被移动；<br>②如果无法进行静态批处理而需要动态批处理时，小心各种限制条件；<br>③游戏中的小道具，如可以拾取的金币，可以使用动态批处理；<br>④对于包含动画的物体，无法全部使用静态批处理，而如果不动的部分可以把这部分标示为 static；<br>⑤批处理需要把多个模型变换到 <em>世界空间</em> 下合并他们，因此，如果 shader 存在一些在模型空间下的坐标的运算，那么往往会得到错误的结果，可以在这部分的 shader 中使用 <strong>DisableBatching</strong> 标签来强制使用该 shader 的材质不会被批处理；<br>⑥对于使用 <em>半透明材质</em> 的物体通常需要使用严格的从后往前的绘制顺序来保证透明混合的正确性。对于这些物体，Unity 会首先保证它们的绘制顺序，再尝试对它们进行批处理。即当绘制顺序无法满足时，批处理无法被成功应用。</p><h2 id="减少需要处理的顶点数目"><a href="#减少需要处理的顶点数目" class="headerlink" title="减少需要处理的顶点数目"></a>减少需要处理的顶点数目</h2><p>顶点数目可能会造成 GPU 的性能瓶颈。有 3 个常用的顶点优化策略。</p><h3 id="优化几何体"><a href="#优化几何体" class="headerlink" title="优化几何体"></a>优化几何体</h3><p>优化网格来尽可能减少模型中三角面片的数目或顶点数目。Unity 的渲染统计窗口中可以查看渲染当前帧需要的三角面片数目和顶点数目。需要注意的是：Unity 中显示的顶点数目往往要多于建模软件里显示的顶点数。主要有几个原因：<br>①三维软件是以人类的角度理解顶点，而 Unity 是站在 GPU 的角度计算顶点数的；<br>②在 GPU 看来，有时候一个顶点需要拆分成多个顶点，其原因主要有两个：一是为了<strong>分离纹理坐标 uv splits</strong>，另一个是为了<strong>产生平滑的边界 smoothing splits</strong>。建模时一个顶点的纹理坐标有多个，例如：一个立方体，它的 6 个面之间虽然使用了一些相同的顶点，但在不同面上，同一个顶点的纹理坐标可能并不相同。而对 GPU 来说，顶点的每个属性和顶点之间必须是一对一的关系，所以必须将这个顶点拆分成多个具有不同纹理坐标的顶点。而平滑边界也是类似，顶点可能会对应多个法线信息或切线信息，这通常是因为我们要决定这个边是<strong>硬边 hard edge</strong> 还是<strong>平滑边 smooth edge</strong>。</p><p>使用可以移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离，来尽可能减少顶点数目。</p><h3 id="模型的-LOD-技术"><a href="#模型的-LOD-技术" class="headerlink" title="模型的 LOD 技术"></a>模型的 LOD 技术</h3><p><strong>LOD，Level of Detail</strong> 技术的原理是，当一个物体离摄像机很远时，模型上的很多细节是无法被察觉到的，因此 LOD 允许当对象逐渐远离摄像机时，减少模型上的面片数量，从而提高性能。  </p><p>在 Unity 中，可以使用 LOD Group 组件来为一个物体构建一个 LOD。当需要为一个对象准备多个包含不同细节程度的模型，然后把它们赋给 LOD Group 组件中的不同等级，Unity 会自动判断当前位置上使用哪个等级的模型。</p><h3 id="遮挡剔除技术"><a href="#遮挡剔除技术" class="headerlink" title="遮挡剔除技术"></a>遮挡剔除技术</h3><p><strong>遮挡剔除 Occlusion Culling</strong> 可以用来消除那些被其他物体遮挡住的物体，这意味着看不见的顶点不会被 GPU 渲染，从而提升性能。</p><p>注意，区分遮挡剔除和摄像机的视锥体剔除 Frustum Culling。视锥体剔除只会剔除掉那些不在相机的视野范围内的对象，但不会判断视野中是否有物体被其他物体遮挡。而遮挡剔除会使用一个虚拟的相机来遍历场景，从而构建一个潜在可见的对象集合的层级结构。运行时，每个相机将会使用这个数据来识别哪些物体可见，哪些物体被挡住。</p><p>遮挡剔除不仅可以减少处理的顶点数目，还可以减少 overdraw，提高游戏性能。</p><h2 id="减少需要处理的片元数目"><a href="#减少需要处理的片元数目" class="headerlink" title="减少需要处理的片元数目"></a>减少需要处理的片元数目</h2><p>过多的片元是造成 GPU 性能瓶颈的另一原因，其优化的重点在于减少 <strong>Overdraw</strong>，Overdraw 指的是同一个像素被绘制了多次。</p><p>Unity 提供了查看 overdraw 的视图，在 Scene 视图的 2D 按钮前一个 Shading Mode 的球体按钮下拉菜单里可以选择 Overdraw。实际上，这里的视图只是提供了查看物体互相遮挡的层数，并不是真正绘制屏幕的最终 overdraw。也就是说，它显示的是，没有使用任何深度测试和其他优化策略时的 overdraw。这种视图是通过把所有对象都渲染成一个透明的轮廓，通过查看透明颜色的累计程度来判断物体之间的遮挡。</p><h3 id="控制绘制顺序"><a href="#控制绘制顺序" class="headerlink" title="控制绘制顺序"></a>控制绘制顺序</h3><p>为了最大限度地避免 overdraw，一个重要的优化策略就是控制绘制顺序。由于深度测试的存在，从而如果保证了所有物体都是从前往后进行绘制，从很大程度上减少 overdraw。因为后面绘制的物体无法通过深度测试，从而无法被绘制出来。  </p><p>在 Unity 中，渲染队列数目小于 2500（如 “Background”、“Geometry”、“AlphaTest”）的对象都被认为是不透明 opaque 的物体，这些物体总体上是从前到后绘制的。而使用其他队列（如 “Transparent”、“Overlay” 等）的物体，则是从后到前，意味着开发者尽可能把物体的队列设置为不透明物体的渲染队列，而经可能避免使用半透明队列。</p><p>而且，我们还可以充分利用渲染队列，比如：<br>①在第一人称射击游戏，游戏的主角的 shader 往往比较复杂。但是通常会挡住屏幕的很大一部分区域，因此可以将主角的渲染队列调小，先渲染；<br>②对于一些敌方角色，由于它们通常在掩体的后面，所以可以将它们的渲染队列调大，这样先渲染不透明掩体，掩体后面的敌人就不用再被渲染；<br>③对于天空盒来说，它几乎覆盖所有的像素，而且它永远会出现在所有物体的后面。将它的队列设置为 “Geometry+1”，就可以保证其最后渲染，减少 Overdraw。</p><h3 id="时刻警惕透明物体"><a href="#时刻警惕透明物体" class="headerlink" title="时刻警惕透明物体"></a>时刻警惕透明物体</h3><p>半透明物体因为没有开启深度写入，需要从后往前进行渲染，这意味着一定会产生 overdraw 现象。</p><p>例如，对于 GUI 对象来说，如果大多被设置成了半透明，并且占据比例太多，那么会造成大量 overdraw。因此，场景中若包含了大面积的半透明物体，或者很多层相互覆盖的半透明对象，或者是透明的粒子效果，在移动设备上也会造成大量的 overdraw。</p><p>可以尽量减少窗口中的 GUI 所占的面积，如果没办法，可以把 GUI 的绘制和三维场景的绘制交给不同的摄像机，而其中负责三维场景的摄像机的视角范围经历不要与 GUI 的相互重叠。</p><p>在移动平台上，透明度测试也会影响游戏性能。透明度测试会使用 discard 或 clip 操作，导致一些硬件的优化策略失效。比如：PowerVR 使用的基于瓦片的延迟渲染技术，为了减少 Overdraw 它会调用片元着色器前就判定哪些瓦片被真正渲染。但由于透明度测试在片元着色器中使用了 discard 函数改变了片元是否会被渲染的结果，因此 GPU 无法使用上述的优化策略，只有执行了所有的片元着色器后，GPU 才知道哪些片元会被真正渲染到屏幕上，这样原先减少的 Overdraw 的优化就都失效了。</p><h3 id="减少实时光照和阴影"><a href="#减少实时光照和阴影" class="headerlink" title="减少实时光照和阴影"></a>减少实时光照和阴影</h3><p>如果场景中包含了过多的点光源，并且使用了多个 Pass 的 Shader，那么很可能会造成性能下降。对于逐像素的点光源，使用了逐像素的 Shader 不仅会提高 draw call，同时会增加 overdraw。这是因为，对于逐像素的光源来说，被这些光源照亮的物体需要被再渲染一次，而且也会中断批处理。</p><p>模拟光源的方法有：<br>①使用烘焙技术，把光照提前烘焙到一张<strong>光照纹理 lightmap</strong> 中，在运行时对纹理进行采样即可。<br>②使用 <strong>God Ray</strong>，即<strong>丁达尔效应</strong>，不是真的光源，而是通过透明纹理模拟得到的。  </p><p>开发者还可以把复杂的光照计算存储到一张<strong>查找纹理 lookup texture</strong>，即<strong>查找表 lookup table, LUT</strong>，中。然后只需要使用光源方向、视角方向、法线方向等参数，对 LUT 采样得到光照结果即可。对于主要角色使用更大分辨率的 LUT，一些 NPC 就使用较小的 LUT，这样可以优化性能。</p><p>实时阴影同样是非常消耗性能的效果，不仅是 CPU 需要提交更多的 Draw Call，GPU 也要做贡多的处理。所以尽量减少实时阴影，可以使用烘焙把静态物体的阴影信息存储到光照纹理当中，而只对动态物体使用适当的实时阴影。</p><h2 id="节省带宽"><a href="#节省带宽" class="headerlink" title="节省带宽"></a>节省带宽</h2><p>大量使用未经压缩的纹理以及过大的分辨率都会造成由于带宽而引发的性能瓶颈。  </p><h3 id="减少纹理大小"><a href="#减少纹理大小" class="headerlink" title="减少纹理大小"></a>减少纹理大小</h3><p>需要注意的是，所有纹理的长宽比最好是正方形，而且长宽值最好是 2 的整数幂。很多优化策略只有在这种时候才可以发挥最大效用。在 Unity 5 中，即使导入的纹理长宽值并不是 2 的整数幂，Unity 也会自动把长宽转换到离他最近的 2 的整数幂。</p><p> 除此之外，还应该尽可能使用<strong>多级渐变纹理技术 mipmapping</strong> 和<strong>纹理压缩</strong>。<br> ①纹理的属性面板里，勾选 <strong>Generate Mip Maps</strong>，Unity 就会为同一张纹理创建出很多大小不同的小纹理。而在游戏运行时可以根据物体的远近来动态选择使用哪一个纹理。<br> ②而纹理压缩，不同的 GPU 架构有它自己的纹理压缩格式，例如 PowerVRAM 的 PVRTC 格式、Tegra 的 DXT 格式、Adreno 的 ATC 格式。所幸的是，Unity 会根据不同的设备选择不同的压缩格式，只需设置为自动压缩即可。但是对一些有一定画质要求的纹理，比如 GUI，可以选择不压缩。</p><h3 id="利用分辨率缩放"><a href="#利用分辨率缩放" class="headerlink" title="利用分辨率缩放"></a>利用分辨率缩放</h3><p> 过高的分辨率也是造成性能下降的原因之一，尤其对于很多低端手机，除了分辨率高其他硬件条件不尽如人意，也就是游戏性能的两大瓶颈：过大的屏幕分辨率、糟糕的 GPU。</p><p>对于特定设备，将其屏幕分辨率设低，再放大到屏幕的尺寸，虽然降低游戏效果，但是可以带来性能上的提升。Unity 中设置分辨率可以调用<code>Screen.SetResolution</code>。</p><h2 id="减少计算复杂度"><a href="#减少计算复杂度" class="headerlink" title="减少计算复杂度"></a>减少计算复杂度</h2><p>计算复杂度同样会影响游戏的渲染性能，可通过两方面的技术来减少计算复杂度：Shader 的 LOD 技术、代码方面的优化。</p><h3 id="Shader-的-LOD-技术"><a href="#Shader-的-LOD-技术" class="headerlink" title="Shader 的 LOD 技术"></a>Shader 的 LOD 技术</h3><p> 跟之前提到的<strong>模型的 LOD 技术</strong>类似，<strong>Shader 的 LOD 技术</strong>可以控制使用的 Shader 等级。它的原理是，只有 Shader 的 LOD 值小于某个设定的值，这个 Shader 才会被使用，而使用了那些超过设定值的 Shader 的物体将不会被渲染。</p><p> 通常会在 SubShader 中使用类似下面的语句来指明该 Shader 的 LOD 值：  </p><pre><code> SubShader &#123;    Tags &#123; &quot;RenderTYpe&quot; = &quot;Opaque&quot;&#125;    LOD 200</code></pre><p>在 Unity Shader 的导入面板上看到该 Shader 使用的 LOD 值。默认情况下，LOD 等级是无限大的，即任何被当前显卡支持的 Shader 都可以被使用。有时需要去掉一些使用了复杂计算的 Shader 渲染，这时可以使用 <code>Shader.maximumLOD</code> 或 <code>Shader.globalMaximumLOD</code> 来设置允许的最大 LOD 值。</p><p>Unity 内置的 Shader 使用了不同的 LOD 值，例如：Diffuse 的 LOD 值为 200，Bumped Specular 的 LOD 值为 400。</p><h3 id="代码方面的优化"><a href="#代码方面的优化" class="headerlink" title="代码方面的优化"></a>代码方面的优化</h3><p>游戏需要计算的对象、顶点和像素排序是：对象数 &lt; 顶点数 &lt; 像素数。因此需要尽可能需要把计算放在对象或逐顶点上，例如在实现高斯模糊或边缘检测，把采样坐标的计算放在顶点着色器中，该做法好于原片着色器中。</p><p>尽可能使用低精度的浮点值进行运算：<br>①最高精度的 float/highp 适用于存储顶点坐标等变量，但它计算速度最慢，所以应尽量避免在片元着色器中使用这种精度的计算；<br>②half/mediump 适用于一些标量、纹理坐标等变量，其计算速度约为 float 的两倍；<br>③fixed/lowp 适用于大多数颜色变量和归一化后的方向矢量，对于一些精度要求不高的计算，尽量使用这种精度，其计算速度约为 float 的 4 倍。但要避免频繁的 swizzle 操作（如：color.xwxw），同时避免不同精度间的转换。</p><p>对于绝大多数 GPU 来说，在使用<strong>插值寄存器</strong>把数据从顶点着色器传递给下一个阶段时，我们应该使用尽量少的插值变量。例如，如果需要对两个纹理坐标进行插值，通常需要会把它们打包在同一个 float4 类型的变量中，两个纹理坐标分别对应了 xy 分量和 zw 分量。然而对于 PowerVR 平台来说，这种插值变量是非常廉价的，直接把不同的纹理坐标存储在不同的插值变量中，性能会更好。尤其是，如果在 PowerVR 上使用类似 <code>tex2D(_MainTex, uv.zw)</code> 语句进行采样，GPU 就无法进行一些纹理的预读取，因为它会认为这些纹理坐标是需要依赖其他数据的。</p><p>尽可能不使用全屏的屏幕后处理效果。如果必须使用，尽量使用 fixed/lowp 进行低精度运算（纹理坐标除外，可使用 half/mediump）；高精度运算可使用查找表（LUT）或转移到顶点着色器进行处理；尽量把多个特效合并到一个 Shader 中，例如：颜色校正和添加噪声等屏幕特效在 Bloom 特效的最后一个 Pass 中进行合成。  </p><p>其他代码优化规则：<br>①尽量不要使用分支语句和循环语句；<br>②避免使用 sin、tan、pow、log 等较为复杂的数学运算，用查找表代替；<br>③尽量不要使用 discard 操作，这会影响硬件的某些优化。</p><h3 id="根据硬件条件进行缩放"><a href="#根据硬件条件进行缩放" class="headerlink" title="根据硬件条件进行缩放"></a>根据硬件条件进行缩放</h3><p>保证游戏基本的配置可以在所有的平台上运行良好；对于一些具有更高表现能力的设备，可以开启一些更“养眼”的效果，如：使用更高分辨率、开启屏幕后处理特效、开启粒子效果等。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>Unity 官方手册给出了很多优化的建议，建议详细阅读。</p><h1 id="第十六章-Unity-的表面着色器"><a href="#第十六章-Unity-的表面着色器" class="headerlink" title="第十六章 Unity 的表面着色器"></a>第十六章 Unity 的表面着色器</h1><p>2009年（Unity 2.x），Unity 的渲染工程师 Aras 连续发表3篇名为《Shaders must die》的博客。博客中，Aras 认为：把渲染流程分为顶点和像素的抽象层面是不易理解的，这种在顶点/几何/片元着色器上的操作是对硬件友好的一种方式，他提出应该划分为：表面着色器、光照模型和光照着色器这样的层面。<br>①表面着色器定义模型表面的反射率、法线和高光等；<br>②光照模型选择使用兰伯特还是 Blinn-Phong 等模型；<br>③光照着色器负责计算光照衰减、阴影等。</p><p>这样绝大多数时候开发者只需要和表面着色器打交道，如：混合纹理、颜色等；而光照模型是可以提前定义好的，只需要选择几种预定义的光照模型即可；光照着色器一旦由系统实现后，更不会轻易改动。这样大大减轻 Shader 编写者的工作量。2010年的 Unity 3 中，Surface Shader 被加入到 Unity 中。</p><h2 id="表面着色器的一个例子"><a href="#表面着色器的一个例子" class="headerlink" title="表面着色器的一个例子"></a>表面着色器的一个例子</h2><p>准备工作如下：<br>①新建名为 Scene_17_1 的场景，并去掉天空盒，在场景中新建一个胶囊体；<br>②新建名为 BumpedSpecularMat 的材质，并赋给场景中的胶囊体；<br>③新建名为 Chapter17-BumpedDiffuse 的 Unity Shader，并赋给上一步创建的材质。</p><p>这里使用表面着色器来实现了一个使用了法线纹理的漫反射效果，下面代码参考的是 Unity 内置的 DefaultResourcesExtra/Bumped Diffuse 的代码：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 17/Bumped Diffuse&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Main Color&quot;</span>, Color) = (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _BumpMap (<span class="string">&quot;Normalmap&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">300</span></span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> surface surf Lambert</span></span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        sampler2D _BumpMap;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">            float2 uv_BumpMap;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">surf</span><span class="params">(Input IN, inout SurfaceOutput o)</span> &#123;</span><br><span class="line">            fixed4 tex = tex2D(_MainTex, IN.uv_MainTex);</span><br><span class="line">            o.Albedo = tex.rgb * _Color.rgb;</span><br><span class="line">            o.Alpha = tex.a * _Color.a;</span><br><span class="line">            o.Normal =  UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Legacy Shaders/Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在材质面板上拖拽一张漫反射纹理、一张法线纹理，分别在对应路径为：Assets/Textures/Chapter17/Mud_Diffuse.tif 和 Assets/Textures/Chapter17/Mud_Normal.tif。我们还可以向场景中添加一些点光源和聚光灯，我们不需要对代码做任何改动，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2024/01/03/wWrkYsa3RSv6XDl.jpg" width = "60%" height = "60%" alt="图83- 表面着色器的例子。左图：在一个平行光下的效果。右图：添加了一个点光源（蓝色）和一个聚光灯（紫色）后的效果。"/></div><p>从上面例子来看，相比顶点/片元着色器，表面着色器的代码很少。而且，可以轻松地实现常见的光照模型，不需要和任何光照变量打交道，Unity 帮我们处理好了每个光源的光照结果。</p><p>和顶点/片元着色器需要包含到一个特定的 Pass 块中不同，<strong>表面着色器的 Cg 代码是直接而且必需写在 SubShader 块中，Unity 会在背后生成多个 Pass</strong>。</p><h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><p>一个表面着色器中最重要的部分是<strong>两个结构体</strong>以及它的<strong>编译指令</strong>，两个结构体是表面着色器中不同函数之间信息传递的桥梁，而编译指令是开发者和 Unity 沟通的重要手段。</p><p>编译指令最重要的作用是指明该表面着色器使用的<strong>表面函数</strong>和<strong>光照函数</strong>，并设置一些可选参数。表面着色器的 Cg 块中第一句往往就是编译指令，编译指令的一般格式如下：  </p><pre><code>#pragma surface surfaceFunction lightModel [optionalparams]</code></pre><p>其中，<strong>#pragma surface</strong> 用于指明该编译指令是用于定义表面着色器的，在它后面需要指明使用的表面函数 surfaceFunction 和光照模型 lightModel，同时还可以使用一些可选参数来控制表面着色器的一些行为。</p><h3 id="表面函数"><a href="#表面函数" class="headerlink" title="表面函数"></a>表面函数</h3><p>一个对象的表面属性定义了它的反射率、光滑度、透明度等值，而表面函数用于定义这些表面属性。surfaceFunction 通常就是名为 surf 的函数（函数名可以是任意的），其函数格式是固定的：  </p><pre><code>void surf (Input IN, inout SurfaceOutput o)void surf (Input IN, inout SurfaceOutputStandard o)void surf (Input IN, inout SurfaceOutputStandardSpecular o)</code></pre><p>其中，后两个是基于物理的渲染。<strong>SurfaceOutput</strong>、<strong>SurfaceOutputStandard</strong> 和 <strong>SurfaceOutputStandardSpecular</strong> 都是 Unity 内置的结构体，需要配合不同的光照模型使用，后面会介绍。</p><p>在表面函数中，会使用输入结构体 <strong>Input IN</strong> 来设置各种表面属性，并把这些属性存储在结构体  SurfaceOutput、SurfaceOutputStandard 和 SurfaceOutputStandardSpecular 中，再传递给光照函数计算光照结果。</p><p>可以在 Unity 手册的表面着色器例子中找到更多示例：<a href="https://docs.unity3d.com/Manual/SL-SurfaceShaderExamples.html">https://docs.unity3d.com/Manual/SL-SurfaceShaderExamples.html</a></p><h3 id="光照函数"><a href="#光照函数" class="headerlink" title="光照函数"></a>光照函数</h3><p>光照函数会使用表面函数中设置的各种表面属性，来应用某些光照模型，进而模拟物体表面的光照效果。Unity 内置了基于物理的光照模型函数：<strong>Standard</strong>、<strong>StandardSpecular</strong>（在 UnityPBSLighting.cginc 文件中被定义），以及简单的非基于物理的光照模型函数：<strong>Lambert</strong>、<strong>BlinnPhong</strong>（在 Lighting.cginc 文件中被定义）。</p><p>当然，也可以定义自己的光照函数。例如，可以使用下面的函数来定义用于前向渲染中的光照函数：  </p><pre><code>// 用于不依赖视角的光照模型，例如：漫反射half4 Lighting&lt;Name&gt; (SurfaceOutput s, half3 lightDir, half atten);// 使用依赖视角的光照模型，例如：高光反射half4 Lighting&lt;Name&gt; (SurfaceOutput s, half3 lightDir, half3 viewDir, half atten);</code></pre><h3 id="其他可选参数"><a href="#其他可选参数" class="headerlink" title="其他可选参数"></a>其他可选参数</h3><p><strong>可选参数 optionalparams</strong> 包含了很多有用的指令类型，例如：开启/设置透明混合/透明度测试，指明自定义的顶点和颜色修改函数，控制生成的代码等。下面选取了一些比较重要和常用的参数进行更深入地说明，可以在 Unity 官方手册查看更多：<br>①自定义的修改函数：除了表面函数和光照模型外，表面着色器还可以支持其他两种自定义的函数：<strong>顶点修改函数 vertex:VertexFunction</strong>和<strong>最后的颜色修改函数 finalcolor:ColorFunction</strong>。顶点修改函数允许开发者自定义一些顶点属性，例如，把顶点颜色传递给表面函数，或是修改顶点位置，实现某些顶点动画等。最后的颜色修改函数则可以在颜色绘制到屏幕前，最后一次修改颜色值，例如实现自定义的雾效等。<br>②阴影：可以通过一些指令来控制和阴影相关的代码。例如，<strong>addshadow</strong> 参数会为表面着色器生成一个阴影投射的 pass。通常情况下，Unity 可以直接在 FallBack 中找到通用的光照模式为 ShadowCaster 的 pass，从而将物体正确地渲染到深度和阴影纹理中。但是对于一些进行了顶点动画、透明度测试地物体，就需要特殊处理，正如第 10 章最后说的一样；<strong>fullforwardshadows</strong> 参数则可以在前向渲染路径中支持所有光源类型的阴影。默认情况下，Unity 只支持最重要的平行光的阴影效果，如果需要让点光源或聚光灯在前向渲染中也有阴影，就可以添加这个参数；如果不想对这个 Shader 的物体进行任何阴影计算，就可以使用 <strong>noshadow</strong> 参数来禁用阴影。<br>③透明度混合和透明度测试：可以通过 <strong>alpha</strong> 和 <strong>alphatest</strong> 指令来控制透明度混合和透明度测试。例如，<strong>alphatest:VariableName</strong> 指令会使用名为 VariableName 的变量来剔除不满足条件的片元。此时，还需要使用前面提到的 <strong>addshadow</strong> 参数来生成正确的阴影投射的 Pass。<br>④光照：<strong>noambient</strong> 参数会告诉 Unity 不要应用任何环境光照或光照探针 light probe；<strong>novertexlights</strong> 参数告诉 Unity 不要应用任何逐顶点光照；<strong>noforwardadd</strong> 会去掉所有前向渲染中的额外的 Pass，也就是说，这个 Shader 只会支持一个逐像素的平行光，而其他的光源会按照逐顶点或 SH 的方法来计算光照影响；还有一些用于控制光照烘焙、雾效模拟的参数，如 <strong>nolightmap</strong>、<strong>nofog</strong> 等。<br>⑤控制代码的生成：默认情况下，Unity 会为一个表面着色器生成相应的前向渲染路径、延迟渲染路径使用的 Pass，这会导致生成的 Shader 文件比较大。如果确定该表面着色器只会在某些渲染路径中使用，可使用 <strong>exclude_path:deferred</strong>、<strong>exclude_path:forward</strong> 和 <strong>exclude_path:prepass</strong> 来告诉 Unity 不需要为某些渲染路径生成代码。</p><h2 id="两个结构体"><a href="#两个结构体" class="headerlink" title="两个结构体"></a>两个结构体</h2><p>表面着色器支持最多自定义 4 个关键的函数：表面函数（设置表面属性，如反射率、法线等）、光照函数（定义光照模型）、顶点修改函数（修改、传递顶点属性）、颜色修改函数（修改最后的颜色）。那么这些函数之间的信息是如何传递的？这就是两个结构体的工作。</p><p>一个表面着色器需要使用两个结构体：表面函数的输入结构体 <strong>Input</strong>，以及存储了表面属性的结构体 <strong>SurfaceOutput</strong>、<strong>SurfaceOutputStandard</strong> 或 <strong>SurfaceOutputStandardSpecular</strong> 。</p><h3 id="数据来源：Input-结构体"><a href="#数据来源：Input-结构体" class="headerlink" title="数据来源：Input 结构体"></a>数据来源：Input 结构体</h3><p><strong>Input</strong> 结构体包含了许多表面属性的数据来源，因此，它会作为表面函数的输入结构体（如果自定义了顶点修改函数，它还会是顶点修改函数的输出结构体）</p><p>Input 支持很多内置的变量名，比如本章开头的表面着色器代码中的 Input 结构体包含了主纹理和法线纹理的采样坐标 <strong>uv_MainTex</strong> 和 <strong>uv_BumpMap</strong>。这些采样坐标必须以 “uv” 为前缀（也可以用 “uv2” 为前缀，表明使用次纹理坐标集合），后面紧跟纹理名称。</p><p>Input 结构体中内置的其他变量：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">float3 viewDir</td><td style="text-align:left">包含了视角方向，可用于计算边缘光照等</td></tr><tr><td style="text-align:left">使用 COLOR 语义定义的 float4 变量</td><td style="text-align:left">包含了插值后的逐顶点颜色</td></tr><tr><td style="text-align:left">float4 screenPos</td><td style="text-align:left">包含了屏幕空间的坐标，可以用于反射或屏幕特效</td></tr><tr><td style="text-align:left">float3 worldPos</td><td style="text-align:left">包含了世界空间下的位置</td></tr><tr><td style="text-align:left">float3 worldRefl</td><td style="text-align:left">包含了世界空间下的反射方向，前提是没有修改表面法线 o.normal</td></tr><tr><td style="text-align:left">float3 worldRefl; <br> INTERNAL_DATA</td><td style="text-align:left">如果修改了表面法线 o.normal，需要使用该变量告诉 Unity 要基于修改后的法线计算世界空间下的反射方向。在表面函数中，我们需要使用 WorldReflectionVector(IN, o.normal) 来得到世界空间下的反射方向</td></tr><tr><td style="text-align:left">float3 worldNormal</td><td style="text-align:left">包含了世界空间的法线方向。前提是没有修改表面法线 o.normal</td></tr><tr><td style="text-align:left">float3 worldNormal; <br> INTERNAL_DATA</td><td style="text-align:left">如果修改了表面法线 o.normal，需要使用该变量告诉 Unity 要基于修改后的法线计算世界空间下的法线方向。在表面函数中，我们需要使用 WorldNormalVector(IN, o.normal) 来得到世界空间下的法线方向</td></tr></tbody></table></div><p>这些内置变量 Unity 会自动帮我们计算好，我们只需要在表面函数中直接使用它们即可。但有个例外：自定义了顶点修改函数，并需要向表面函数中传递一些自定义的数据，如：自定义雾效，需要在顶点修改函数中根据顶点在视角空间下的位置信息计算雾效混合系数，这样我们就可以在 Input 结构体中定义一个名为 half fog 的变量，把计算结果存储在该变量后进行输出。</p><h3 id="表面属性：SurfaceOutput-结构体"><a href="#表面属性：SurfaceOutput-结构体" class="headerlink" title="表面属性：SurfaceOutput 结构体"></a>表面属性：SurfaceOutput 结构体</h3><p>有了 Input 结构体来提供所需要的数据后，就可以据此计算各种表面属性。<strong>SurfaceOutput</strong>、<strong>SurfaceOutputStandard</strong>、<strong>SurfaceOutputStandardSpecular</strong> 就是存储这些表面属性的结构体，它会作为表面函数的输出，随后会作为光照函数的输入来进行各种光照计算。</p><p>相比于 Input 结构体的自由性，这个结构体里面的变量是提前就声明好的，不可以增加也不会减少（如果没有对某些变量赋值，就会使用默认值）。</p><p><strong>SurfaceOutput</strong> 的声明可以在 Lighting.cginc 文件中找到：  </p><pre><code>struct SurfaceOutput &#123;    fixed3 Albedo; //对光源的反射率，通常由纹理采样和颜色属性的乘积计算得到    fixed3 Normal; //表面法线方向    fixed3 Emission; //自发光，Unity 通常会在片元着色器最后输出前（并在最后的顶点函数被调用前，如果定义了的话），使用类似 c.rgb += o.Emission 语句进行简单的颜色叠加。    half Specular; //高光反射中的指数部分的系数，影响高光反射的计算，比如：BlinnPhong 光照函数。使用如下语句计算高光反射的强度：float spec = pow(nh, s.Specular * 128.0) * s.Gloss;    fixed Gloss; //高光反射中的强度系数，与 Specular 类似，计算公式见上面的代码，一般在包含高光反射的光照模型中使用。    fixed Alpha; //透明通道。如果开启了透明度，会使用该值进行颜色混合。&#125;;</code></pre><p><strong>SurfaceOutputStandard</strong> 和 <strong>SurfaceOutputStandardSpecular</strong> 的声明可以在 UnityPBSLighting.cginc 中找到：  </p><pre><code>struct SurfaceOutputStandard &#123;    fixed3 Albedo; // base (diffuse or specular) color    fixed3 Normal; // tangent space normal, if written    half3 Emission;    half Metallic; // 0：non-metal，1：metal    half Smoothness; // 0：rough，1：smooth    half Occlusion; // occlusion (default 1)    fixed Alpha; // alpha for transparencies&#125;;struct SurfaceOutputStandardSpecular &#123;    fixed3 Albedo; // diffuse color    fixed3 Specular; // specular color    fixed3 Normal; // tangent space normal, if written    half3 Emission;    half Smoothness; // 0：rough，1：smooth    half Occlusion; // occlusion (default 1)    fixed Alpha; // alpha for transparencies&#125;;</code></pre><p>在一个表面着色器内，要根据我们选择使用的光照模型选择上述之一：<br>①如果使用了非基于物理的光照模型，比如 <strong>Lambert</strong> 和 <strong>BlinnPhong</strong>，通常使用 SurfaceOutput 结构体；<br>②如果使用了基于物理的光照模型，比如 <strong>Standard</strong> 或 <strong>StandardSpecular</strong>，分别使用 <strong>SurfaceOutputStandard</strong> 或 <strong>SurfaceOutputStandardSpecular</strong> 结构体。其中，SurfaceOutputStandard 结构体用于默认的金属工作流程（Metallic Workflow），对应了 Standard 光照函数；而 SurfaceOutputStandardSpecular 结构体用于高光工作流程（Specular Workflow），对应了 StandardSpecular 光照函数。</p><h2 id="Unity-背后做了什么"><a href="#Unity-背后做了什么" class="headerlink" title="Unity 背后做了什么"></a>Unity 背后做了什么</h2><p>Unity 在背后会根据表面着色器生成一个包含了很多 Pass 的顶点/片元着色器。这些 Pass 有些是为了针对不同的渲染路径。例如：<br>①默认情况下，Unity 会为前向渲染路径生成 LightMode 为 <strong>ForwardBase</strong> 和 <strong>ForwardAdd</strong> 的 Pass；<br>②为 Unity 5 之前的延迟渲染路径生成 LightMode 为 <strong>PrePassBase</strong> 和 <strong>PrePassFinal</strong> 的 Pass；<br>③为 Unity 5 之后的延迟渲染路径生成 LightMode 为 <strong>Deferred</strong> 的 Pass；  </p><p>还有一些 Pass 是用于产生额外的信息。例如，为了给光照映射和动态全局光照提取表面信息，Unity 会生成一个 LightMode 为 <strong>Meta</strong> 的 Pass；有些表面着色器由于修改了顶点位置，因此，可以利用 addshadow 编译指令为它生成相应的 LightMode 为 ShadowCaster 的阴影投射 Pass。</p><p>这些 Pass 的生成都是基于表面着色器中的编译指令和自定义函数，可在每个编译完成的表面着色器的面板上，点击 “Show generated code” 按钮，查看 Unity 为这个表面着色器生成的所有顶点/片元着色器。</p><p>通过查看这些代码，以 Unity 生成的 LightMode 为 ForwardBase 的 Pass 为例，它的渲染计算流水线如下图所示：  </p><div  align="center">  <img src="https://s2.loli.net/2024/01/04/WXdUP4Obtuhpgzf.jpg" width = "100%" height = "100%" alt="图84- 表面着色器的渲染计算流水线。黄色：可以自定义的函数。灰色：Unity 自动生成的计算步骤"/></div><p>Unity 对该 Pass 的自动生成过程大致如下：<br>①复制代码<br>直接将表面着色器中的 CGPROGRAM 和 ENDCG 之间的代码复制过来，这些代码包括 Input 结构体、表面函数、光照函数（如果有自定义）等变量和函数的定义，它们会在之后的处理过程中被当做正常的结构体和函数进行调用。<br>②生成 v2f_surf 结构体<br>Unity 会分析上述代码，据此生成顶点着色器的输出 v2f_surf 结构体，用于顶点着色器和片元着色器之间的数据传递。Unity 会分析我们在自定义函数所使用的变量，例如，纹理坐标、视角方向、反射方向等。如果需要，它就会在 v2f_surf 中生成相应的变量。而且，即便有时我们在 Input 中定义了某些变量（如某些纹理坐标），但是 Unity 在分析后续代码时发现我们并没有使用这些变量，那么这些变量实际上是不会在 v2f_surf 中生成的。也就是说，Unity 做了一些优化。v2f_surf 还包含一些其他需要的变量，如：阴影纹理坐标、光照纹理坐标、逐顶点光照等。<br>③生成顶点着色器<br>&emsp;&emsp; - 如果自定义了<strong>顶点修改函数</strong>，Unity 会首先调用它修改修改顶点数据，或填充自定义的 Input 结构体中的变量；然后，Unity 会分析顶点修改函数中修改的数据，在需要时通过 Input 结构体将修改结果存储到 v2f_surf 相应的变量中。<br>&emsp;&emsp; - 计算 v2f_surf 中其他生成的变量值，包括：顶点位置、纹理坐标、法线方向、逐顶点光照、光照纹理采样坐标等，可通过编译指令来控制某些变量是否需要计算。<br>&emsp;&emsp; - 最后将 v2f_surf 传递给接下来的片元着色器。<br>④生成片元着色器<br>&emsp;&emsp; - 使用 v2f_surf 中对应变量填充 Input 结构体，如：纹理坐标、视角方向等。<br>&emsp;&emsp; - 调用自定义的<strong>表面函数</strong>填充 SurfaceOutput 结构体。<br>&emsp;&emsp; - 调用<strong>光照函数</strong>得到初始颜色值。如果使用内置的 Lambert 或 BlinnPhong 光照函数，还会计算动态全局光照，并添加到光照模型的计算中。<br>&emsp;&emsp; - 进行其他的颜色叠加。如：若没有使用光照烘焙，还会添加逐顶点光照的影响。<br>&emsp;&emsp; - 最后，如果自定义了<strong>最后的颜色修改函数</strong>，Unity 会调用它进行最后的颜色修改。  </p><h2 id="表面着色器实例分析"><a href="#表面着色器实例分析" class="headerlink" title="表面着色器实例分析"></a>表面着色器实例分析</h2><p>下面代码的效果是对模型进行膨胀，在顶点修改函数中沿着顶点法线方向扩张顶点位置。为了分析表面着色器中 4 个可自定义函数的原理，在下面都使用了自定义的实现：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 17/Normal Extrusion&quot;</span> &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">_ColorTint (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">_MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">_BumpMap (<span class="string">&quot;Normalmap&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">_Amount (<span class="string">&quot;Extrusion Amount&quot;</span>, Range(<span class="number">-0.5</span>, <span class="number">0.5</span>)) = <span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line">Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">LOD <span class="number">300</span></span><br><span class="line"></span><br><span class="line">CGPROGRAM</span><br><span class="line"></span><br><span class="line"><span class="comment">// surf - which surface function.</span></span><br><span class="line"><span class="comment">// CustomLambert - which lighting model to use.</span></span><br><span class="line"><span class="comment">// vertex:myvert - use custom vertex modification function.</span></span><br><span class="line"><span class="comment">// finalcolor:mycolor - use custom final color modification function.</span></span><br><span class="line"><span class="comment">// addshadow - generate a shadow caster pass. Because we modify the vertex position, the shder needs special shadows handling.</span></span><br><span class="line"><span class="comment">// exclude_path:deferred/exclude_path:prepas - do not generate passes for deferred/legacy deferred rendering path.</span></span><br><span class="line"><span class="comment">// nometa - do not generate a “meta” pass (that’s used by lightmapping &amp; dynamic global illumination to extract surface information).</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> surface surf CustomLambert vertex:myvert finalcolor:mycolor addshadow exclude_path:deferred exclude_path:prepass nometa</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">fixed4 _ColorTint;</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">sampler2D _BumpMap;</span><br><span class="line">half _Amount;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">float2 uv_MainTex;</span><br><span class="line">float2 uv_BumpMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myvert</span> <span class="params">(inout appdata_full v)</span> &#123;</span><br><span class="line">v.vertex.xyz += v.normal * _Amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">surf</span> <span class="params">(Input IN, inout SurfaceOutput o)</span> &#123;</span><br><span class="line">fixed4 tex = tex2D(_MainTex, IN.uv_MainTex);</span><br><span class="line">o.Albedo = tex.rgb;</span><br><span class="line">o.Alpha = tex.a;</span><br><span class="line">o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half4 <span class="title function_">LightingCustomLambert</span> <span class="params">(SurfaceOutput s, half3 lightDir, half atten)</span> &#123;</span><br><span class="line">half NdotL = dot(s.Normal, lightDir);</span><br><span class="line">half4 c;</span><br><span class="line">c.rgb = s.Albedo * _LightColor0.rgb * (NdotL * atten);</span><br><span class="line">c.a = s.Alpha;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mycolor</span> <span class="params">(Input IN, SurfaceOutput o, inout fixed4 color)</span> &#123;</span><br><span class="line">color *= _ColorTint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="string">&quot;Legacy Shaders/Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①在顶点修改函数中，使用顶点法线对顶点位置进行膨胀；<br>②表面函数使用主纹理设置了表面属性中的反射率，并使用法线纹理设置了表面法线方向；<br>③光照函数实现了简单的兰伯特漫反射光照模型；<br>④最后的颜色修改函数，简单地使用颜色参数对输出颜色进行调整。</p><p>注意，除了上面四个函数外，我们在 #pragma surface 的编译指令一行中还指定了一些额外的参数：<br>①由于修改了顶点位置，为了产生正确的阴影效果，不能直接依赖 FallBack 中找到的阴影投射 Pass，使用 addshadow 参数告诉 Unity 生成一个对应当前表面着色器的阴影投射 Pass。<br>②默认情况下，Unity 会为所有支持的渲染路径生成相应的 Pass，为了缩小自动生成的代码量，我们使用 <strong>exclude_path:deferred</strong> 和 <strong>exclude_path:prepass</strong> 来告诉 Unity 不要为延迟渲染路径生成相应的 Pass。<br>③最后，使用 <strong>nometa</strong> 参数取消对提取元数据的 Pass 的生成。</p><hr><p>点击 “Show generated code” 按钮，可看到 Unity 生成的顶点/片元着色器。在这个将近 600 行的代码里，Unity 一共为该表面着色器生成了 3 个 Pass，它们的 LightMode 分别是 ForwardBase、ForwardAdd 和 ShadowCaster，分别对应了前向渲染路径中的处理逐像素平行光的 Pass、处理其他逐像素光的 Pass、处理阴影投射的 Pass。还可以看到生成的代码中有大量的 #ifdef 和 #if 语句，这些语句可以帮我们判断一些渲染条件，如：是否使用动态光照纹理、是否使用逐顶点光照、是否使用屏幕空间的阴影等。</p><p>下面分析 Unity 生成的 ForwardBase Pass：<br>①Unity 首先指明了一些编译指令：  </p><pre><code>// ---- forward rendering base pass:Pass &#123;    Name &quot;FORWARD&quot;    Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;    CGPROGRAM    // compile directives    #pragma vertex vert_surf    #pragma fragment frag_surf    #pragma target 3.0    #pragma multi_compile_instancing    #pragma multi_compile_fwdbase    #include &quot;HLSLSupport.cginc&quot;    #define UNITY_INSTANCED_LOD_FADE    #define UNITY_INSTANCED_SH    #define UNITY_INSTANCED_LIGHTMAPSTS    #define UNITY_INSTANCED_RENDERER_BOUNDS    #include &quot;UnityShaderVariables.cginc&quot;    #include &quot;UnityShaderUtilities.cginc&quot;</code></pre><p>②之后出现的是一些自动生成的注释：  </p><pre><code>// Surface shader code generated based on:// vertex modifier: &#39;myvert&#39;// writes to per-pixel normal: YES// writes to emission: no// writes to occlusion: no// needs world space reflection vector: no// needs world space normal vector: no// needs screen space position: no// needs world space position: no// needs view direction: no// needs world space view direction: no// needs world space position for lighting: no// needs world space view direction for lighting: no// needs world space view direction for lightmaps: no// needs vertex color: no// needs VFACE: no// needs SV_IsFrontFace: no// passes tangent-to-world matrix to pixel shader: YES// reads from normal: no// 2 texcoords actually used//   float2 _MainTex//   float2 _BumpMap</code></pre><p>尽管这些对渲染结果没有影响，但我们可以从这些注释中理解到 Unity 的分析过程和它的分析结果。</p><p>③随后，Unity 定义了一些宏来辅助计算：  </p><pre><code>#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))</code></pre><p>在本例中这些宏没有被用到。这些宏是为了在修改了表面法线的情况下，辅助计算得到世界空间下的反射方向和法线方向，与之对应的是 Input 结构体中的一些变量。  </p><p>④接着，Unity 把我们在表面着色器中编写的 Cg 代码复制过来，作为 Pass 的一部分，以便后续调用。</p><p>⑤然后，Unity 定义了顶点着色器到片元着色器的插值结构体 v2f_surf。在定义前，Unity 使用 #ifdef 语句来判断是否使用了光照纹理，并为不同的情况生成不同的结构体。主要区别是，如果没有使用光照纹理，就需要定义一个存储逐顶点和 SH 光照的变量。</p><pre><code>// vertex-to-fragment interpolation data// no lightmaps:#ifndef LIGHTMAP_ON// half-precision fragment shader registers:#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERSstruct v2f_surf &#123;    UNITY_POSITION(pos);    float4 pack0 : TEXCOORD0; // _MainTex _BumpMap    float4 tSpace0 : TEXCOORD1;    float4 tSpace1 : TEXCOORD2;    float4 tSpace2 : TEXCOORD3;    fixed3 vlight : TEXCOORD4; // ambient/SH/vertexlights    UNITY_LIGHTING_COORDS(5,6)    #if SHADER_TARGET &gt;= 30    float4 lmap : TEXCOORD7;    #endif    UNITY_VERTEX_INPUT_INSTANCE_ID    UNITY_VERTEX_OUTPUT_STEREO&#125;;#endif// with lightmaps:#ifdef LIGHTMAP_ON// half-precision fragment shader registers:#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERSstruct v2f_surf &#123;    UNITY_POSITION(pos);    float4 pack0 : TEXCOORD0; // _MainTex _BumpMap    float4 tSpace0 : TEXCOORD1;    float4 tSpace1 : TEXCOORD2;    float4 tSpace2 : TEXCOORD3;    float4 lmap : TEXCOORD4;    UNITY_LIGHTING_COORDS(5,6)    UNITY_VERTEX_INPUT_INSTANCE_ID    UNITY_VERTEX_OUTPUT_STEREO&#125;;#endif</code></pre><p>上面很多变量，我们之前都碰到过，只是这里的名称不同。如：pack0 存储的是主纹理和法线纹理的采样坐标；tSpace0、tSpace1 和 tSpace2 存储了从切线空间到世界空间的变换矩阵。一个比较陌生的变量是 vlight，Unity 会把逐顶点和 SH 光照的结果存储到该变量里，并在片元着色器中和原光照结构进行叠加（如果需要的话）。  </p><p>⑥随后，Unity 定义了真正的顶点着色器。顶点着色器首先会调用自定义的顶点修改函数来修改一些顶点属性：  </p><pre><code>// vertex shaderv2f_surf vert_surf (appdata_full v) &#123;    v2f_surf o;    ...    UNITY_INITIALIZE_OUTPUT(v2f_surf,o);    ...    myvert (v);    ...</code></pre><p>在我们的实现中，只对顶点坐标进行了修改，而不需要向 Input 结构体中添加并存储新的变量。也可以使用另一个版本的函数声明来把顶点修改函数中的某些计算结果存储到 Input 结构体当中：  </p><pre><code>void vert(inout appdata_full v, out Input o);</code></pre><p>之后的代码是用于计算 v2f_surf 中的各个变量的值。例如，计算经过 MVP 矩阵变换后的顶点坐标；使用 TRANSFORM_TEX 内置宏计算两个纹理的采样坐标，并存储在 o.pack0 的 xy 和 zw 分量中：计算从切线空间到世界空间的变换矩阵，并把矩阵的每一行分别存储在 o.tSpace0、o.tSpace1 和 o.tSpace2 变量中；判断是否使用了光照映射和动态光照映射，并在需要时将两种光照纹理的采样计算结果存储在 o.lmap 的 xy 和 zw 分量中；判断是否使用了光照映射，如果没有则计算该顶点的 SH 光照（一种快速计算光照的方法），把结果存储到 o.vlight 中；判断是否开启了逐顶点光照，如果是则计算最重要的 4 个逐顶点光照的光照结果，把结果叠加到 o.vlight 中。这部分代码不摘抄了。最后，计算阴影坐标并传递给片元着色器。  </p><p>⑦在 Pass 的最后，Unity 定义了真正的片元着色器。Unity 首先利用插值后的结构体 v2f_surf 来初始化 Input 结构体中的变量。</p><pre><code>// fragment shaderfixed4 frag_surf (v2f_surf IN) : SV_Target &#123;    ...    // prepare and unpack data    Input surfIN;    ...    UNITY_INITIALIZE_OUTPUT(Input,surfIN);    surfIN.uv_MainTex = IN.pack0.xy;    surfIN.uv_BumpMap = IN.pack0.zw;</code></pre><p>随后，Unity 声明一个 SurfaceOutput 结构体的变量，并对其中的表面属性进行初始化，再调用表面函数：</p><pre><code>#ifdef UNITY_COMPILER_HLSLSurfaceOutput o = (SurfaceOutput)0;#elseSurfaceOutput o;#endifo.Albedo = 0.0;o.Emission = 0.0;o.Specular = 0.0;o.Alpha = 0.0;o.Gloss = 0.0;fixed3 normalWorldVertex = fixed3(0,0,1);o.Normal = fixed3(0,0,1);// call surface functionsurf (surfIN, o);</code></pre><p>上述代码中，Unity 还使用 #ifdef 语句判断当前编译语言是否是 HLSL，如果是则使用更严格的声明方式来声明 SurfaceOutput 结构体（DirectX 平台有更严格的语义要求）。当对各个表面属性进行初始化后，Unity 调用了表面函数 surf 来填充这些表面属性。  </p><p>之后，Unity 进行真正的光照计算，首先计算得到光照衰减和世界空间下的法线方向：  </p><pre><code>// compute lighting &amp; shadowing factorUNITY_LIGHT_ATTENUATION(atten, IN, worldPos)fixed4 c = 0;float3 worldN;worldN.x = dot(_unity_tbn_0, o.Normal);worldN.y = dot(_unity_tbn_1, o.Normal);worldN.z = dot(_unity_tbn_2, o.Normal);worldN = normalize(worldN);o.Normal = worldN;</code></pre><p>其中，变量 c 用于存储最终的输出颜色，初始化为 0。随后 Unity 判断是否关闭光照映射，如果关闭了，则把逐顶点的光照结果叠加到输出颜色中：  </p><pre><code>#ifndef LIGHTMAP_ONc.rgb += o.Albedo * IN.vlight;#endif // !LIGHTMAP_ON</code></pre><p>而如果需要使用光照映射，Unity 就会使用之前计算的光照纹理采样坐标，对光照纹理进行采样并解码，得到光照纹理中的光照结果。这部分代码不摘抄。</p><p>如果没有使用光照映射，则需要使用自定义的光照模型计算光照结果：  </p><pre><code>// realtime lighting: call lighting function#ifndef LIGHTMAP_ONc += LightingCustomLambert (o, lightDir, atten);#elsec.a = o.Alpha;#endif</code></pre><p>而如果使用了光照映射，Unity 会根据之前由光照纹理得到的结果得到颜色值，并叠加到输出颜色 c 中；如果还开启了动态光照映射，Unity 还会计算对动态光照纹理的采样结果，同样把结果叠加到输出颜色 c 中。这部分代码不摘抄。</p><p>最后，Unity 调用自定义的颜色修改函数，对输出颜色 c 进行最后的修改：  </p><pre><code>mycolor (surfIN, o, c);UNITY_OPAQUE_ALPHA(c.a);return c;</code></pre><p>在上面的代码中，Unity 还使用了内置宏 UNITY_OPAQUE_ALPHA（在 UnityCG.cginc 中被定义）来重置片元的透明通道。在默认情况下，所有不透明类型的表面着色器和透明通道都会被重置为 1.0，不管我们是否在光照函数中改变了它。如果要保留它的透明通道，可以在表面着色器的编译指令中添加 keepalpha 参数。</p><hr><p>至此，ForwadBase Pass 分析结束，而 ForwardAdd Pass 和前者类似，只是代码更加简单，Unity 去掉了对逐顶点光照和各种判断是否使用了光照映射的代码，因为这些额外的 Pass 不需要考虑这些。</p><p>最后一个重要的 Pass 是 ShadowCaster Pass，相比之前的两个 Pass 更加短小简单，它通过调用自定义的顶点修改函数来保证计算阴影时使用的是和之前一致的顶点坐标。自定义的阴影投射 Pass 同样使用了 V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET 和 SHADOW_CASTER_FRAGMENT 来计算阴影投射。</p><h2 id="Surface-Shader-的缺点"><a href="#Surface-Shader-的缺点" class="headerlink" title="Surface Shader 的缺点"></a>Surface Shader 的缺点</h2><p>表面着色器虽然带来了很大的便利，但是只是 Unity 在顶点/片元着色器上面提供的一种封装，任何在表面着色器中能完成的事情，都可以在顶点/片元着色器中重现，但是这句话反过来不成立。</p><p>表面着色器虽然可以快速实现各种光照效果，但是失去了对各种优化和各种特效实现的控制。因此，使用表面着色器往往会对性能产生一定的影响。而内置的 Shader，例如 Diffuse、Bumped Specular 等都是使用表面着色器编写的。尽管 Unity 提供了移动平台的相应版本，例如 Mobile/Diffuse 和 Mobile/Bumped Specular 等，但这些版本的 Shader 只是去掉了额外的逐像素 Pass、不计算全局光照和其他一些光照计算上的优化。但是想要进行更深层的优化，表面着色器就不能满足需求了。</p><p>除了性能问题外，表面着色器还无法完成一些自定义的渲染效果。</p><p>建议：<br>①如果需要和各种光源打交道，尤其是 Unity 中的全局光照，使用表面着色器会更便利，但需要注意性能；<br>②如果处理光源数目较少，例如只有一个平行光，使用顶点/片元着色器是更好的选择；<br>③如果有很多自定义的渲染效果，建议选择顶点/片元着色器。</p><h1 id="第十七章-基于物理的渲染"><a href="#第十七章-基于物理的渲染" class="headerlink" title="第十七章 基于物理的渲染"></a>第十七章 基于物理的渲染</h1><p>之前学习的 Lambert 光照模型、Phong 光照模式和 Blinn-Phong 光照模型都是经验模型。Unity 5 正式将<strong>基于物理的渲染技术 Physically Based Shading, PBS</strong> 引入到引擎渲染中。Unity 5 引入了一个名叫 <strong>Standard Shader</strong> 的可在不同材质之间通用的着色器，该着色器就是基于物理的光照模型。</p><h2 id="PBS-的理论和数学基础"><a href="#PBS-的理论和数学基础" class="headerlink" title="PBS 的理论和数学基础"></a>PBS 的理论和数学基础</h2><p>本节主要参考了 Naty Hoffman 在 SIGGRAPH 2013 上的名为 Background：Physics and Math of Shading 的演讲。</p><h3 id="光是什么"><a href="#光是什么" class="headerlink" title="光是什么"></a>光是什么</h3><p>在物理学中，光是一种电磁波。材质和光线相交会发生两种物理现象：<strong>吸收 absorption</strong> 和<strong>散射 scattering</strong>（其实还有自发光现象）。<br>①光线被吸收是由于光被转化成了其他能量，但吸收并不会改变光的传播方向；<br>②散射则不会改变光的能量，但会改变它的传播方向。</p><p>光传播过程中，影响光的一个重要特性：材质的<strong>折射率 refractive index</strong>。在均匀介质中，光是沿直线传播的。但光传播过程中，如果折射率突变，会发生光的散射现象。</p><hr><p>在现实中，光和物体的交互是非常复杂的，大多数情况下并不存在一种可分析的解决方法，为了在渲染中对光照建模，往往只考虑一种特殊情况：两个介质的边界是无限大且<strong>光学平滑 optically flat</strong> 的。尽管实际物体表面并不是无限延伸的，也不是绝对光滑的，但相比光的波长，它们的大小可以被近似认为是无限大以及光学平滑的。在这样的前提下，光在不同介质的边界会被分割成两个方向：反射方向和折射方向。而有多少百分比的光会被反射则是由<strong>菲涅耳等式 Fresnel equations</strong> 来描述的。</p><div  align="center">  <img src="https://s2.loli.net/2024/01/05/ibW7h28n4GSzvUH.jpg" width = "40%" height = "40%" alt="图85- 在理想的边界处，折射率的突变会把光线分成两个方向"/></div><p>虽然相比光的波长，物体表面可以被认为是光学平坦。但物体表面是有很多肉眼不可见的凹凸不平的平面，物体表面和光照发生的各种行为更像是一系列微小的光学平滑平面和光交互的结果，每个小平面会把光分割成不同的方向。</p><p>这种建立在<strong>微表面</strong>的模型更容易解释物体的粗糙平滑程度，如下图所示。一个光滑物体的表面，尽管它的表面仍然由很多凹凸不平的微表面构成，但这些微表面的法线方向变化角度小，因此由这些表面反射的光线方向变化也比较小，这使得物体的高光反射更加清晰。而粗糙表面则相反，由此得到的高光反射效果更模糊。</p><div  align="center">  <img src="https://s2.loli.net/2024/01/05/c68FQLRyZspxPzB.jpg" width = "70%" height = "70%" alt="图86- 左图：光滑表面的微平面的法线变化较小，反射光线的方向变化也更小。右图：粗糙表面的微平面的法线变化较大，反射光线的方向变化也更大"/></div><p>上面说的是微表面的反射，下面讨论被微表面折射的光。这些光被折射到物体的内部，一部分被介质吸收，另一部分又被散射到外部。金属材质具有很高的吸收系数，因此，所有被折射的光往往会被立刻吸收，被金属内部的自由电子转化为其他形式的能量（即金属几乎没有次表面散射）。而非金属材质则会同时表现出吸收和散射两种现象，而被散射到外部的光又被称为<strong>次表面散射光 subsurface-scattered light，SSS</strong>。如下图：  </p><div  align="center">  <img src="https://s2.loli.net/2024/01/05/A59bZB4tIVlgRmL.jpg" width = "35%" height = "35%" alt="图87- 微表面对光的折射。这些被折射的光中一部分被吸收，一部分又被散射到外部"/></div><p>从渲染的层级上考虑光与表面的交互行为。那么，由微表面反射的光可以被认为是该点上一些方向变化不大的反射光，如下图黄线部分所示。而折射光线（蓝线）需要更多考虑，那些次表面散射光会从不同的入射点位置从物体内部再次射出。如果像素要大于这些散射距离的话，意味着这次次表面散射产生的距离可以被忽略，如下面右图所示。如果像素要小于这些散射距离，我们就不可以忽略了，要实现更真实的次表面散射效果，需要使用特殊的渲染模型，即次表面散射渲染技术。</p><div  align="center">  <img src="https://s2.loli.net/2024/01/05/IT54o1vLn3gPZ7E.jpg" width = "70%" height = "70%" alt="图88- 次表面散射。左图：次表面散射的光线会从不同于入射点的位置射出。如果这些距离值小于需要被着色的像素大小，那么渲染就可以完全在局部完成（右图）。否则，就需要使用次表面散射渲染技术"/></div><h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3><p>下面的内容建立在不考虑次表面散射的距离，而完全使用局部着色渲染的前提下。那么如何使用数学表达式来表示上面的光照模型。</p><p>首先，用<strong>辐射率 radiance</strong> 来量化光。辐射率是单位面积、单位方向上光源的辐射通量，通常用 $\,L\,$ 表示，被认为是对单一光线的亮度和颜色评估。在渲染中，我们通常会基于表面的入射光线的入射辐射率 $\,L_i\,$ 来计算出出射辐射率 $\,L_o\,$，这个过程也往往被称为是<strong>着色 shading</strong> 过程。</p><p>James Kajiya 在他 1986 年那篇著名的 <strong>The Rendering Equation</strong> 论文中给出了<strong>渲染方程</strong>的表述形式，由此在理论上完美地给出了基于物理渲染的方向。这个公式第一次从数学建模的角度描述了渲染到底是在解决什么问题，这个在图形学中大名鼎鼎的渲染方程公式如下：  </p><script type="math/tex; mode=display">L_o(v) = L_e(v) + \int_{\Omega} f(w_i, v) L_i(w_i)(n \cdot w_i)dw_i</script><p>上述公式的理解：给定观察视角 $\,v\,$ ，该方向上的出射辐射率 $\,L_o(v)\,$ 等于该点向观察方向发出的自发光辐射率 $\,L_e(v)\,$ 加上所有有效的入射光 $\,L_i(w_i)\,$ 到达观察点的辐射率积分和。下图给出了渲染等式中各个部分的通俗解释：  </p><div  align="center">  <img src="https://s2.loli.net/2024/01/05/McVnlTzp3gq7OwJ.jpg" width = "90%" height = "90%" alt="图89- 渲染方程参数的通俗解释"/></div><p>渲染方程是计算机图形学的核心公式，当去掉其中的自发光项 $\,L_e(v)\,$ 后，剩余的部分就是著名的<strong>反射等式 Reflectance Equation</strong>。可以这样理解反射等式：我们要计算表面上某点的出射辐射率，已知到该点的观察方向，该点的出射辐射率是由很多不同方向的入射辐射率叠加后的结果。$\,f(w_i, v)\,$，即 <strong>BRDF</strong> 表达部分（详见后面），表示了不同方向的入射光在该观察方向上的权重分布，我们把这些不同方向的光辐射率（$\,L_i(w_i)\,$部分）乘以观察方向上所占的权重（$\,f(w_i, v)\,$ 部分），再乘以它们在该表面的投影结果（$\,(n \cdot w_i)\,$ 部分），最后把这些值加起来（即做积分）就是最后的出射辐射率。</p><p>在实时渲染中，自发光项通常就是直接加上某个自发光值。除此之外，积分累加部分在实时渲染中也基本无法实现，因此积分部分通常会被若干精确光源的叠加所代替，而不需要计算所有入射光线在半球面上的积分。</p><h3 id="精确光源"><a href="#精确光源" class="headerlink" title="精确光源"></a>精确光源</h3><p>在真实的物理世界中，所有的光源都是有面积概念的，即所谓的面光源。由于面光源的光照计算通常要耗费大量的时间，因此在实时渲染中，我们通常会使用<strong>精确光源 punctual light sources</strong> 来近似模拟这些面光源。图形学中常见的精确光源类型有点光源、平行光和聚光灯等，这些精确光源被认为是大小为无限小且方向确定的，尽管这并不符合真实的物理定义，但它们在大多数情况下都能得到令人满意的渲染效果。</p><p>我们使用 $\,l_c\,$ 来表示它的方向，使用 $\,c_{light}\,$ 表示它的颜色。使用精确光源，我们就可以简化上面的反射等式。即对于一个精确光源，我们可以使用下面的等式来计算它在某个观察方向 $\,v\,$ 上的出射辐射率：  </p><script type="math/tex; mode=display">L_o(v) = \pi f(l_c, v) c_{light}(n \cdot l_c)</script><p>上面的式子使用一个特定的方向的 $\,f(l_c,v)\,$ 值来代替积分操作，这大大简化了计算。如果场景中包含了多个精确光源，我们可以把它们分别代入上面的式子进行计算，然后把它们的结果相加即可。也就是说，反射等式可以简化成下面的形式：</p><script type="math/tex; mode=display">L_o(v) = \sum_{i=0}^n L_o^i(v) = \sum_{i=0}^n \pi f(l_c^i, v) c_{light}(n \cdot l_c^i)</script><p>$\,f(l_c,v)\,$ 项实际上描述了当给定某个入射方向的入射光后，有多少百分比的光照被反射到了观察方向上，即<strong>双向反射分布函数 BRDF</strong>。</p><h3 id="双向反射分布函数-BRDF"><a href="#双向反射分布函数-BRDF" class="headerlink" title="双向反射分布函数 BRDF"></a>双向反射分布函数 BRDF</h3><p>要想得到出射辐射率 $\,L_o\,$，可以使用 <strong>BRDF Bidirectional Reflectance Distribution Function，双向反射分布函数</strong>来定量分析。大多数情况下，BRDF 用 $\,f(l, v)\,$ 来表示，其中 $\,l\,$ 为入射方向，$\,v\,$ 为观察方向（即双向）。绕着表面法线旋转入射方向或观察方向不影响 BRDF 的结果的情况被称为是<strong>各项同性 isotropic</strong> 的 BRDF；与之对应的则是<strong>各项异性 anisotropic</strong> 的 BRDF。</p><p>BRDF 有两种理解方式：<br>①给定入射角度后，BRDF 可以给出所有出射方向上的反射和散射光线的相对分布情况；<br>②给定观察方向（即出射方向）后，BRDF 可以给出从所有入射方向到该出射方向的光线分布。  </p><p>一个更直观的理解是，当一束光线沿入射方向 $\,l\,$ 到达表面某点时，$\,f(l, v)\,$ 表示了有多少部分的能量被反射到观察方向 $\,v\,$ 上。</p><p>BRDF 是反射等式中的重要组成部分，BRDF 决定了着色过程是否是基于物理的。这可以由 BRDF 是否满足两个特性来判断：它是否满足<strong>交换律 reciprocity</strong> 和<strong>能量守恒 energy conservation</strong>。</p><p>①交换律要求当交换 $\,l\,$ 和 $\,v\,$ 的值后，BRDF 的值不变，即：  </p><script type="math/tex; mode=display">f(l, v) = f(v, l)</script><p>②能量守恒则要求表面反射的能量不能超过入射的光能，即：  </p><script type="math/tex; mode=display">\forall l, \int_\Omega f(l, v)(n \cdot l)dw_o \le 1</script><blockquote><p>$\,\forall\,$ 是全称量化符号，读作任意</p></blockquote><p>基于这些理论，BRDF 可以用于描述两种不同的物理现象：表面反射和次表面散射。针对每种现象，BRDF 通常会包含一个单独的部分来描述它们，用于描述表面反射的部分被称为<strong>高光反射项 specular term</strong>，以及用于描述次表面散射的<strong>漫反射项 diffuse term</strong>。</p><hr><p>至于如何得到不同材质的 BRDF，一种完全真实的方法是使用精确的光学仪器在真实的物理世界中对这些材质进行测量，通过不断改变光照入射方向和观察方向并对当前材质的反射光照进行采样，我们就可以得到它的 BRDF 图像切片。</p><p>一些机构和组织向公众公开了他们测量出来的 BRDF 数据库，以便供研究人员进行分析和研究，例如 MERL BRDF 数据库（ <a href="http://www.merl.com/brdf/">http://www.merl.com/brdf/</a> ）以及 MIT CSAIL 数据库（ <a href="http://people.csail.mit.edu/addy/research/brdf/">http://people.csail.mit.edu/addy/research/brdf/</a> ），这些真实材质的 BRDF 数据反映了它们在不同光照和观察角度下的反射情况。</p><p>在学术界，学者们也基于复杂的物理和光学理论分析归纳出了一些通用的 BRDF 数学模型，来对 BRDF 分析模型中的高光反射项和漫反射项进行数学建模。这些由研究人员得到的 BRDF 模型也可以被称为是分析型 BRDF 模型，这些 BRDF 模型通常包含了大量的物理和光学参数。  </p><p>通过对真实材质的 BRDF 图像和现有的分析型 BRDF 模型进行对比，研究人员发现，其实很多材质是无法被现有的任何一种分析型 BRDF 模型所良好的描述出来。因此，许多最新的研究都选择使用基于数据驱动的方法，来开发出一些新的分析型 BRDF 模型，从而使其可以和真实材质的 BRDF 图像尽可能地接近。但遗憾的是，由于真实世界的光照和材质都非常复杂，因此很难有一种可以满足所有真实材质特性的 BRDF 模型。Disney 向公众开源了一个名为 <strong>BRDF Explorer</strong>（ <a href="http://github.com/wdas/brdf">http://github.com/wdas/brdf</a> ）的软件，来让用户可以直观地对比各种分析型 BRDF 模型与真实测量得到的 BRDF 值之间的差异。</p><p>可以认为，这些测量得到的真实 BRDF 数据库是研究人员在开发新的基于物理的 BRDF 光照模型的重要依据，除了满足交换律和能量守恒两个条件外，一个分析型 BRDF 模型应当与测量得到的 BRDF 数据在尽可能多得材质范围内（或这些特定的材质）、具有尽可能得相似的表现才可能被广泛应用。Disney 通过对大量现有的分析型 BRDF 模型进行对比，并结合对真实材质的 BRDF 数据的观察，开发出了适用于 Disney 动画渲染流程的 BRDF 模型，也被称为 <strong>Disney BRDF</strong>。在下面的内容中，我们会介绍<strong>漫反射项</strong>和<strong>高光反射项</strong>的一些常见的 BRDF 数学模型，同时给出 Disney BRDF 模型中的相应表示。</p><h3 id="漫反射项"><a href="#漫反射项" class="headerlink" title="漫反射项"></a>漫反射项</h3><p>之前所学习的 Lambert 模型就是最简单、也是应用最广泛的漫反射 BRDF。准确的 <strong>Lambertian BRDF</strong> 的表示为：  </p><script type="math/tex; mode=display">f_{Lambert}(l,v) = \cfrac {c_{diff}} {\pi}</script><p>其中，$\,c_{diff}\,$ 表示漫反射光线所占的比例，它也通常被称为是漫反射颜色 diffuse color。和之前讲的 Lambert 光照模型不太一样的是，上面的式子实际上是一个定值，我们常见到的余弦因子部分，$\,(n \cdot l)\,$ 实际是反射等式的一部分，而不是 BRDF 的部分。上面的式子之所以要除以 $\, \pi \,$，是因为我们假设漫反射在所有方向上的强度都是相同的，而 BRDF 要求在半球内的积分值为 1。因此，给定入射方向 $\,l\,$ 的光源在表面某点的出射漫反射辐射率为：</p><script type="math/tex; mode=display">L_o(v) = \pi f_{Lambert}(l, v) c_{light}(n \cdot l) = c_{diff} \times c_{light}(n \cdot l)</script><p>可以看出这个结果和之前一直使用的漫反射项基本一样。尽管 Lambert 模型简单且易于实现，但它具有完美均匀的散射，但真实世界中很少有材质符合。不过，一些游戏引擎和实时渲染器出于性能的考虑会使用 Lambert 模型作为它们 PBS 模型中的漫反射项，例如虚幻引擎 4（Unreal Engine 4）。</p><hr><p>通过对真实材质的 BRDF 数据进行分析，研究人员发现许多材质在掠射角度表现出了明显的高光反射峰值，而且还与表面的粗糙度有着强烈的联系。粗糙表面在掠射角容易形成一条亮边，而相反地光滑表面则容易在掠射角形成一条阴影边。这些都是 Lambert 模型所无法描述的。下图显示了这样的例子，注意图中在掠射角的光照效果。</p><div  align="center">  <img src="https://s2.loli.net/2024/01/05/z5k1rVCIngwKNG4.jpg" width = "80%" height = "80%" alt="图90- 从左到右：粗糙材质和光滑材质的真实漫反射结果，以及 Lambert 漫反射结果"/></div><p>因此，许多基于物理的渲染选择使用更加复杂的漫反射项来模拟更加真实次表面散射的结果。例如，在 <strong>Disney BRDF</strong> 中，它的漫反射项为：  </p><script type="math/tex; mode=display">f_{diff} (l, v) = \cfrac {baseColor} {\pi} (1 + (F_{D90} - 1)(1 - n \cdot l)^5) (1 + (F_{D90} - 1)(1 - n \cdot v)^5)</script><script type="math/tex; mode=display">其中，F_{D90} = 0.5 + 2roughness(h \cdot l)^2</script><p>其中，baseColor 是表面颜色，通常由纹理采样得到，roughness 是表面的粗糙度。上面的漫反射项既考虑了在掠射角漫反射项的能量变化，还考虑了表面的粗糙度对漫反射的影响。Disney 使用了 Schlick 菲涅耳近似等式来模拟在掠射角的反射变化，同时使用表面粗糙度来进一步修改它，这使得光滑材质可以在掠射角具有更为明显的阴影边，而又使得粗糙材质在掠射角具有亮边。而上面的式子也正是 Unity 5 内部使用的漫反射项。</p><h3 id="高光反射项"><a href="#高光反射项" class="headerlink" title="高光反射项"></a>高光反射项</h3><p>在现实生活中，几乎所有的物体都或多或少有高光反射现象。John Hable 在他的文章中就强调了 <strong>Everything is Shiny</strong>。在基于物理的渲染中，BDRF 中的<strong>高光反射项</strong>大多数都是建立在<strong>微面元理论 microfacet theory</strong> 的假设上的。微面元理论认为，物体表面实际是由许多人眼看不到的微面元组成的，虽然物体表面并不是光学平滑的，但这些微面元可以被认为是光学平滑的，也就是说它们具有完美的高光反射。当光和这些微面元相交时，光线会被分割成两个方向，即反射方向和折射方向。这里我们只需要考虑被反射的光线，而折射光线已经在之前的漫反射项中考虑过了。当然，微面元理论也仅仅是真实世界的散射的一种近似理论，它也有自身的缺陷，仍然有一些材质是无法使用微面元理论来描述的。</p><p>假设表面法线为 $\,n\,$，这些微面元的法线 $\,m\,$ 并不都等于 $\,n\,$，因此，不同的微面元会把同一入射方向的光线反射到不同的方向上。而当我们计算 BRDF 时，入射方向 $\,l\,$ 和观察方向 $\,v\,$ 都会被给定，这意味着只有一部分微面元反射的光线才会进入到我们的眼睛中，这部分微面元会恰好把光线反射到方向 $\,v\,$ 上，即它们的法线 $\,m\,$ 等于 $\,l\,$ 和 $\,v\,$ 的一半，也就是我们一直看到的半角度矢量 $\,h\,$（<strong>halfangle vector</strong>，也被称为 <strong>half vector</strong>），如下图的 (a) 所示：  </p><div  align="center">  <img src="https://s2.loli.net/2024/01/06/PUrFwhC4LVujkMv.jpg" width = "90%" height = "90%" alt="图91- （a） 那些 m = h 的微面元会恰好把入射光从 l 反射到 v 上，只有这部分微面元才可以添加到 BRDF 的计算中。（b）一部分满足（a）的微面元会在 I 方向上被其他微面元遮挡住，它们不会接受到光照，因此会形成阴影。（c）还有一部分满足（a）的微面元会在反射方向 v 上被其他微面元挡住，因此，这部分反射光也不会被看到"/></div><p>然而，这些 $\,m = h\,$ 的微面元反射也并不会全部添加到 BRDF 的计算中。这是因为，它们其中一部分会在入射方向 $\,l\,$ 上被其他微面元挡住 <strong>shadowing</strong>，如上图（b）所示，或是在它们的反射方向 $\,v\,$ 上被其他微面元挡住了 <strong>masking</strong>，如上图（c）所示。微面元理论认为，所有这些被遮挡住的微面元不会添加到高光反射项的计算中（实际上它们中的一些由于多次反射仍然会被我们看到，但这不在微面元理论的考虑范围内）。</p><p>基于微面元理论的这些假设，BRDF 的高光反射项可以用下面的通用形式来表示：  </p><script type="math/tex; mode=display">f_{spec}(l,v) = \frac {F(l,h)G(l,v,h)D(h)} {4(n \cdot l)(n \cdot v)}</script><p>这就是著名的 Torrance-Sparrow 微面元模型。上述公式的理解：<br>①$\,D(h)\,$ 是微面元的<strong>法线分布函数 normal distribution function，NDF</strong>，它用于计算有多少比例的微面元的法线满足 $\,m=h\,$，只有这部分微面元才会把光线从 $\,l\,$ 方向反射到 $\,v\,$ 上。<br>②$\,G(l, v, h)\,$ 是<strong>阴影-遮掩函数 shadowing-masking function</strong>，它用于计算那些满足 $\,m=h\,$ 的微面元中有多少会由于遮挡而不会被人眼看到，因此它给出了活跃的微面元 active microfacets 所占的浓度，只有活跃的微面元才会成功地把光线反射到观察方向上。<br>③$\,F(l, h)\,$ 则是这些活跃微面元的<strong>菲涅尔反射 Fresnel reflectance 函数</strong>，它可以告诉我们每个活跃的微面元会把多少入射光线反射到观察方向上，即表示了反射光线占入射光线的比率。事实上，现实生活中几乎所有的物体都会表现出菲涅耳现象。<br>④最后，分母 $\,4(n ⋅ l)(n⋅ v)\,$ 是用于校正从微面元的局部空间到整体宏观表面数量差异的校正因子。</p><p>这些不同的部分又可以衍生出很多不同的 BRDF 模型。首先是菲涅耳反射函数部分 $\,F(l, h)\,$。</p><h4 id="菲涅耳反射函数"><a href="#菲涅耳反射函数" class="headerlink" title="菲涅耳反射函数"></a>菲涅耳反射函数</h4><p>菲涅耳反射函数计算了光学表面反射光线所占的部分，它表明了当光照方向和观察方向夹角逐渐增大时高光反射强度增大的现象。完整的菲涅耳等式非常复杂，包含了诸如复杂的折射率等与材质相关的参数。为了给美术人员提供更加直观且方便调节的参数，大多数 PBS 实现选择使用 <strong>Schlick 菲涅耳近似等式</strong>来得到近似的菲涅尔反射效果：  </p><script type="math/tex; mode=display">F_{Schlick} (l,h) = c_{spec} + (1 - c_{spec})(1 - (l \cdot h))^5</script><p>其中，$\,c_{spec}\,$ 是材质的高光反射颜色。通过对真实世界材质的观察，人们发现金属材质的高光反射颜色值往往比较大，而非金属材质的反射颜色值则往往较小。</p><h4 id="法线发布函数"><a href="#法线发布函数" class="headerlink" title="法线发布函数"></a>法线发布函数</h4><p>法线分布函数 $\,D(h)\,$ 表示了对于当前表面来说有多少比例的微面元的法线满足 $\,m=h\,$，这意味着只有这些微面元才会把光线从 $\,l\,$ 方向反射到 $\,v\,$ 上。对于大多数表面来说，微面元的法线朝向并不是均匀分布的，大部分的微面元会具有和表面法线 $\,n\,$ 相同的面法线。法线分布函数的值必须是非负的标量值，它决定了高光区域的大小、亮度和形状，因此是高光反射项中非常重要的一项。一个直观的感受是，当表面的粗糙度下降时，应该有更多的微面元的面法线满足 $\,m=n\,$，因此法线分布函数应该考虑到<strong>表面粗糙度</strong>的影响。  </p><p>我们之前学习的 Blinn-Phong 模型就是一种非常简单的模型。Blinn 在他的论文中改进了 Phong 模型并提出了 Blinn-Phong 模型，使它更贴合微面元 BRDF 模型的理论。<strong>Blinn-Phong 模型</strong>使用的法线分布函数 $\,D(h)\,$ 为：  </p><script type="math/tex; mode=display">D_{blinn} (h) = \cfrac {gloss + 2} {2 \pi} (n \cdot h)^{gloss}</script><p>其中，gloss 是与表面粗糙度相关的参数，它的值可以是任意非负数。上面的式子和我们之前所见的 Blinn-Phong 模型有所不同，这是因为我们在里面加入了归一化因子，这是因为法线分布函数必须满足一个条件，即所有微面元的投影面积必须等于该区域宏观表面的投影面积。因此，上述公式也被称为是<strong>归一化的 Phong 法线分布函数</strong>。</p><p>但实际上，Blinn-Phong 模型并不能真实地反映很多真实世界中物体的微面元法线方向分布，它其实完全是一种经验型模型，因此，很多更加复杂的分布函数被提了出来，例如 <strong>GGX</strong>、<strong>Beckmann</strong> 等。<strong>Beckmann 分布</strong>来源于高斯粗糙分布的一种假设，而且在表现上和 Phong 分布非常类似，但它的计算却要复杂很多。 <strong>GGX 分布</strong>（也被称为 <strong>Trowbridge-Reitz 法线分布函数</strong>）是一种更加新的法线分布函数，它的公式如下：  </p><script type="math/tex; mode=display">D_{GGX}(h) = \cfrac {\alpha ^ 2} {\pi ((\alpha ^ 2 - 1)(n \cdot h)^2 + 1)^2}</script><p>其中，参数 α 是与表面粗糙度相关的参数。与 Blinn-Phong 的法线分布相比，GGX 分布具有更明亮、更狭窄且拖尾更长的高光区域，它的结果更接近于一些测量得到的真实材质的 BRDF 分布。  </p><p>在 Disney BRDF 中，Disney 认为对于很多材质来说，GGX 表现出来的高光拖尾仍然不够长。他们选择使用一种更加广义的法线分布模型，即 <strong>Generalized-Trowbridge-Reitz, GTR 分布</strong>。GTR 分布于 GGX 分布很类似，但它的分母部分的指数不是 2，而是一个可调参数。Disney 使用两个不同指数的 GTR 分布作为两个高光反射片，其中第一个反射片用于表示基本材质层，第二个反射片用于表示基本材质表面的清漆层。除此之外，他们还发现令 $\,α = roughness^2\,$ 可以在材质粗糙度上得到更加线性的变化。否则，直接使用 roughness 作为参数的话会导致在光滑材质和粗糙材质之间插值出来的材质总是偏粗糙的。</p><h4 id="阴影-遮挡函数"><a href="#阴影-遮挡函数" class="headerlink" title="阴影-遮挡函数"></a>阴影-遮挡函数</h4><p>阴影-遮挡函数 $\,G(l, v, h)\,$ 也被称为<strong>几何函数 geometry function</strong>，它表明了具有给定面法线 $\,m\,$ 的微面元在沿着入射方向 $\,l\,$ 和观察方向 $\,v\,$ 上不会被其他微面元挡住的概率。</p><p>在微面元理论的 BRDF 中，$\,m\,$ 可以使用半向量 $\,h\,$ 来代替，因为只有这部分微面元才会把光线从 $\,l\,$ 方向反射到 $\,v\,$ 上。由于 $\,G(l, v, h)\,$ 表示的是一个概率值，因此它的值是一个范围在 0 到 1 之间的标量。学术界发表了许多对于 $\,G(l, v, h)\,$ 的分析模型，这些公式大多建立在一些简化的表面模型基础下。许多已发表的微面元 BRDF 模型习惯把 $\,G(l, v, h)\,$ 和高光反射项的分母 $\,(n ⋅ l)(n ⋅ v)\,$ 部分结合起来，即把 $\,G(l, v, h)\,$ 除以 $\,(n ⋅ l)(n ⋅ v)\,$ 的部分合在一起讨论，这是因为这两个部分都和微面元的可见性有关，因此 Naty Hoffman 在他的演讲中称这个合项为<strong>可见性项 visibility term</strong>。</p><p>一些 BRDF 模型选择完全省略可见性项，即把该项的值设为 1。这意味着，这些 BRDF 中的 $\,G(l, v, h)\,$ 表达式等同于：  </p><script type="math/tex; mode=display">G_{implicit} (l,v,h) = (n \cdot l_c) (n \cdot v)</script><p>上述的 $\,G_{implicit}\,$ 实现不需要任何计算量（因为可以直接和高光反射项的分母进行抵消），并且在一些程度上可以反映正确的变化趋势。例如，当从掠射角进行观察或光线从掠射角射入时，该项会趋近于 0，这是符合我们的认知的，因为在掠射角时微面元被其他微面元遮挡的概率会非常大。然而，这种 $\,G_{implicit}\,$ 的实现忽略了材质粗糙度的影响，缺乏一定的物理真实性，因为我们希望粗糙的表面具有更高阴影和遮挡概率。</p><blockquote><p>这里掠射角应该指入射角或出射角接近于90度时，这样余弦值为 0。</p></blockquote><hr><p>通常，阴影-遮挡函数 $\,G(l, v, h)\,$ 依赖于法线分布函数 $\,D(h)\,$，因为它需要结合 $\,D(h)\,$ 来保持 BRDF 能量守恒的规定。最早的阴影-遮挡函数之一是 <strong>Cook-Torrance 阴影遮挡函数</strong>：  </p><script type="math/tex; mode=display">G_{ct}(l,v,h) = min(1, \cfrac {2(n \cdot h)(n \cdot v)} {(v \cdot h)}, \cfrac {2(n \cdot h)(n \cdot l)} {(v \cdot h)})</script><p>Cook-Torrance 阴影遮挡函数在电影行业被应用了很长时间，但它实际上是基于一个非真实的微几何模型，而且同样不受材质粗糙度的影响。后来，Kelemen 等人提出了一个对于 CookTorrance 阴影遮挡函数非常快速且有效的近似实现：  </p><script type="math/tex; mode=display">\cfrac {G_{ct}(l,v,h)} {(n \cdot l)(n \cdot v)} \approx \cfrac {1} {(l \cdot h)^2}</script><hr><p>目前在图形学中广受推崇的是 <strong>Smith 阴影-遮掩函数</strong>。Smith 函数比 Cook-Torrance 函数更加精确，而且考虑进了表面粗糙度和法线分布的影响。原始的 Smith 函数是为 Beckmann 法线分布函数所涉及的，而 Walter 等人随后将其通用化，使其可以匹配任何法线分布函数，并给出了针对 Beckmann 和 GGX 法线分布函数的更加高效的<strong>近似 Smith 模型</strong>。在 Disney 的 BRDF 模型中，它的阴影-遮掩函数 $\,G(l, v, h)\,$ 就使用了 Walter 等人提出的为 GGX 设计的 Smith 模型：  </p><script type="math/tex; mode=display">G(l,v,h) = \cfrac {2} {1 + \sqrt{1 + \alpha_g^2 \tan \theta_v^2}}</script><script type="math/tex; mode=display">其中，\alpha_g = （0.5 + \frac {roughness} {2})^2</script><p>上述公式中的 $\,θ_v\,$ 表示观察方向 $\,v\,$ 和表面法线 $\,n\,$ 之间的夹角。根据艺术家的反馈以及对测量得到的 BRDF 图像的观察，Disney 在上述式子中重新映射了 $\,α_g\,$ 和 $\,roughness\,$ 之间的关系，由此得到了一个在视觉上让艺术家更加满意的效果。这种 Smith 阴影-遮掩函数被广泛应用在电影行业中，但可以看出，相比于 Kelemen 改进后的 Cook-Torrance 阴影遮挡函数，Smith 函数的计算量要明显高很多。</p><hr><p>至此，我们已经介绍完了基于物理的 BRDF 模型的基础理论，并给出了一些常见的 BRDF 模型，例如 Phong、Beckmann、GGX 模型以及 Disney BRDF 模型的实现等。尽管存在很多基于物理的 BRDF 模型，但在真实的电影或游戏制作中，我们希望在直观性和物理可信度之间找到一个平衡点，使得实现的 BRDF 既可以让美术人员直观地调节各个参数，而又有一定的物理可信度。Disney 的 BRDF 模型就是一个很好的例子，它使用尽可能少的若干直观参数来代替那些晦涩难懂的物理变量，而且这些参数的范围被精妙地设计为 0 到 1，为此 Disney 会在必要时重新映射 BRDF 中的变量范围，例如在阴影-遮掩函数中他们重新映射了粗糙度变量的范围。</p><h3 id="PBS-中的光照"><a href="#PBS-中的光照" class="headerlink" title="PBS 中的光照"></a>PBS 中的光照</h3><p>要想得到画面出色的渲染效果，仅仅应用以上这些公式是远远不够的，我们还需要为这些 PBS 材质搭配以出色的光照。</p><p>在上面的内容中我们已经介绍了精确光源。随着新的技术不断被提出，<strong>实时面光源</strong>也不再是一个奢侈的梦想。在 SIGGRAPH 2016 上，Eric Heitz 和 Stephen Hill 在他们名为 <strong>Real-Time Area Lighting: a Journey from Research to Production</strong> 的演讲中就分享了如何实现实时面光源的渲染，这也是 Unity 的 Adam Demo 中使用的技术，读者可以在 Unity Labs 的相关文章中找到相关内容和源码实现。除了上述两种光源外，<strong>基于图像的光照 image-based lighting, IBL</strong> 同样是非常重要的光照来源。</p><p>基于图像的光照通常指的是把场景中远处的光照存储在类似环境贴图的图像中。这些环境贴图可以表示光滑物体表面反射的环境光，从而允许我们可以快速得到拥有很高细节的真实光照效果。在 Unity 中，这种光照通常是由<strong>反射探针 Reflection Probes</strong> 机制来实现的，我们可以在 Shader 中获取当前物体所在的反射探针并在需要时对它们的采样结果进行混合。当然，我们也可以实现一套自己的 IBL 机制，Sébastien Lagarde 在他的博文里详细介绍了 IBL 的一些实现方法以及如何得到视差正确的局部环境贴图的方法，非常值得一看。  </p><h3 id="Unity-中的-PBS-实现"><a href="#Unity-中的-PBS-实现" class="headerlink" title="Unity 中的 PBS 实现"></a>Unity 中的 PBS 实现</h3><p>需要注意的是，随着 Unity 的不断更新，其选择使用的 BRDF 模型也可能会发生变化，例如在 Unity 5.3 之前，Unity 的 PBS 中的法线分布函数 $\,D(h)\,$ 采用的是我们之前提到的归一化的 Phong 法线分布函数，而在 Unity 5.3 及其之后的版本（截止到本书完成时为 Unity 5.6）中，法线分布函数改为采用 GGX 分布。因此，这里旨在让我们了解完整的 PBS 数学模型，如果希望了解当前所用 Unity 版本的 PBS 所使用的 BRDF 模型，强烈建议去翻看内置的 Shader 文件。  </p><p>在之前的内容中，我们提到了 Unity 5 的 PBS 实际上是受 Disney BRDF 的启发。这种 BRDF 最大的好处之一就是很直观，只需要提供一个万能的 Shader 就可以让美术人员通过调整少量参数来渲染绝大部分常见的材质。我们可以在 Unity 内置的 UnityStandardBRDF.cginc 文件中找到它的实现。</p><p>总体来说，Unity 5 一共实现了两种 PBS 模型。一种是基于 GGX 模型的，另一种则是基于归一化的 Blinn-Phong 模型的，这两种模型使用了不同的公式来计算高光反射项中的法线分布函数 $\,D(h)\,$ 和阴影-遮掩函数 $\,G(l, v, h)\,$。Unity 5.3 以前的版本默认会使用基于归一化后的 Blinn-Phong 模型来实现基于物理的渲染，但在 Unity 5.3 及后续版本中，默认将使用 GGX 模型，这和很多其他主流引擎的选择一致。</p><p>①<strong>漫反射项：</strong><br>在这两种实现中，Unity 使用的 BRDF 中的漫反射项都与 Disney BRDF 中的漫反射项相同，即：  </p><script type="math/tex; mode=display">f_{diff} (l, v) = \cfrac {baseColor} {\pi} (1 + (F_{D90} - 1)(1 - n \cdot l)^5) (1 + (F_{D90} - 1)(1 - n \cdot v)^5)</script><script type="math/tex; mode=display">其中，F_{D90} = 0.5 + 2roughness(h \cdot l)^2</script><p>baseColor 一般由纹理采样和颜色参数共同决定。  </p><p>②<strong>菲涅耳反射函数：</strong><br>高光反射项中的菲涅耳反射函数 $\,F(l, h)\,$ 也与 Disney BRDF 中的一致，即使用的 Schlick 菲涅耳近似等式：  </p><script type="math/tex; mode=display">F_{Schlick} (l,h) = c_{spec} + (1 - c_{spec})(1 - (l \cdot h))^5</script><p>其中，$\,c_{spec}\,$ 一般由纹理采样或高光颜色所决定。</p><p>③<strong>法线分布函数：</strong><br>Unity 5 两种 PBS 模型的主要区别在于它们所选择的法线分布函数及其对应的阴影-遮掩函数的不同。基于 GGX 模型的 PBS 的法线分布函数为 GGX 分布，基于归一化 Blinn-Phong 模型的 PBS 的法线分布函数则为归一化后的 Phong 分布。它们的公式分别如下：  </p><script type="math/tex; mode=display">D_{GGX}(h) = \cfrac {\alpha ^ 2} {\pi ((\alpha ^ 2 - 1)(n \cdot h)^2 + 1)^2}, \alpha = {roughness}^2</script><script type="math/tex; mode=display">D_{blinn} (h) = \cfrac {\alpha + 2} {2 \pi} (n \cdot h)^{\alpha}, \alpha = \cfrac {2} {roughness^4} - 2</script><p>需要注意的是，不同 Unity 版本在上述实现上可能会略有不同，比如 roughness 的指数部分会有所不同。</p><p>④<strong>Unity 5.3 之前的阴影-遮掩函数：</strong><br>阴影-遮掩函数的选择更加复杂一些。在 Unity 5.3 之前的版本中，基于 GGX 模型和归一化 Blinn-Phong 模型的 PBS 的阴影-遮掩函数分别是为 GGX 和 Beckmann 设计的 Smith-Schlick 模型。它们的公式分别如下：  </p><script type="math/tex; mode=display">\cfrac {G_{GGX}(l,v,h)} {(n \cdot l)(n \cdot v)} = \cfrac {1} {((n \cdot l)(1 - k) + k)((n \cdot v)(1 - k) + k)}, k = \frac {roughness^2} {2}</script><script type="math/tex; mode=display">\cfrac {G_{Beckmann}(l,v,h)} {(n \cdot l)(n \cdot v)} = \cfrac {1} {((n \cdot l)(1 - k) + k)((n \cdot v)(1 - k) + k)}, k = roughness^2 \sqrt {\cfrac {2} {\pi}}</script><p>⑤<strong>Unity 5.3 以后 GGX 的阴影-遮掩函数：</strong><br>尽管很多文献都曾推荐使用上述的 Smith-Schlick 阴影-遮掩函数，然而，Naty Hoffman 和 Eric Heitz 都指出，这种 Smith-Schlick 阴影-遮掩函数是作者 Schlick 对一个错误版本的 Smith 模型的近似公式，这意味着这些 Smith-Schlick 阴影-遮掩函数并不是基于物理的，因为它不能保证微面元投影区域面积的守恒定律。在 Unity 5.3 及其后续版本中，Unity 为基于 GGX 的 PBS 模型改用了 Smith-Joint 阴影-遮掩函数。Smith-Joint 阴影-遮掩函数的公式如下：  </p><script type="math/tex; mode=display">\begin{align*} \cfrac {G_{SmithJoint}(l,v,h)} {(n \cdot l)(n \cdot v)} & = \cfrac {1} {(n \cdot l)(n \cdot v)(1 + \Lambda(w_o) + \Lambda(w_i))} \\ &= \cfrac {1} {(n \cdot l)(n \cdot v)(1 + 0.5(-1 + \sqrt {1 + \alpha_g^2 \tan \theta_v^2 }) + 0.5(-1 + \sqrt {1 + \alpha_g^2 \tan \theta_l^2 }))} \\ &= \cfrac {2} {(n \cdot l) \sqrt {\alpha_g^2 + (n \cdot v)^2(1 - \alpha_g^2)} + (n \cdot v) \sqrt {\alpha_g^2 + (n \cdot l)^2(1 - \alpha_g^2)}} \\ & \approx \cfrac {2} {(n \cdot l)((n \cdot v)(1 - \alpha_g) + \alpha_g)  + (n \cdot v)((n \cdot l)(1 - \alpha_g) + \alpha_g)} \end{align*}</script><script type="math/tex; mode=display">其中，\alpha_g = roughness^2</script><p>在上述的式子中，$\,\Lambda(w_o)\,$ 和 $\,\Lambda(w_i)\,$ 分别评估出射方向和入射方向上的阴影和遮掩，基于这种分开计算的 $\,\Lambda(w_o)\,$ 和 $\,\Lambda(w_i)\,$ 的 Smith 模型，Eric Heitz 针对 $\,\Lambda(w_o)\,$ 和 $\,\Lambda(w_i)\,$ 的不同组合方式列举了四种形式的阴影-遮掩函数。上述的公式显示了其中一种被称为 <strong>Height-Correlated Masking and Shadowing</strong> 的组合方式，也是 Eric 建议在实践中使用的一种方式。由于原始的 Smith-Joint 阴影遮掩函数涉及两个开根号操作，处于性能方面的考虑，Unity 在实现上选择使用上述仅包含乘法的近似公式来简化计算。尽管在数学上这个近似公式并不正确，但从效果上来看是足够接受的。</p><hr><p>如果读者想要深入了解基于物理的渲染的数学原理和应用的话，可以参见本章的扩展阅读部分。需要再次强调的是，由于 Unity 版本的不同，内置 PBS 的实现也可能会发生变化。除此之外，在学术界和工业界仍然不断有新的或改良后的 BRDF 模型的出现，读者也可以根据项目需要选择与 Unity 实现不同的 BRDF 模型。尤其是如果需要在移动端应用基于物理的渲染，除了效果外性能是我们最应当关心的问题之一，此时我们可能需要针对移动平台对采用的 BRDF 模型进行一些修改，读者可以在本章的扩展阅读部分中找到更多的资料。</p><h2 id="PBS-实践"><a href="#PBS-实践" class="headerlink" title="PBS 实践"></a>PBS 实践</h2><p>本节中，将在 Unity Shader 中实现之前提到的 BRDF 模型。读者可以发现，把 PBS 应用到自己的材质中并不是一件非常困难的事情。我们回顾使用了精确光源简化后的渲染方程：  </p><script type="math/tex; mode=display">L_o(v) = L_e(v) + \sum_{i=0}^{n} L_o^i(v) = L_e(v) + \sum_{i=0}^{n} \pi f(l_c^i,v) c_{light} (n \cdot l_c^i)</script><p>其中，$\,L_e(v)\,$ 是自发光部分，$\,f(l_c^i, v)\,$ 是最为关键的 BRDF 模型部分。BRDF 的高光反射项则可以用下面的通用形式来表示：  </p><script type="math/tex; mode=display">f_{spec}(l,v) = \cfrac {F(l,h)G(l,v,h)D(h)} {4(n \cdot l)(n \cdot v)}</script><p>在本例中，我们会使用 Disney BRDF 中的漫反射项、Schlick 菲涅耳近似等式、基于 GGX 模型的法线分布函数和 Smith-Joint 阴影-遮掩函数作为 BRDF 光照模型的实现。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>准备工作如下：<br>①在 Unity 中新建一个场景，名为 Scene_18_2。我们使用本书资源中的天空盒材质 EveningSkyboxHDR，在 Window -&gt; Lighting -&gt; Skybox 中代替场景默认的天空盒。<br>②新建两个材质，分别名为 CustomPBSCubeMat 和 CustomPBSSphereMat。<br>③新建一个 Unity Shader，名为 Chapter18-CustomPBR。把它赋给第 2 步中创建的材质。<br>④在场景中放置一个球体和立方体，并把第 2 步中的两个材质分别赋给两个物体。</p><p>Chapter18-CustomPBR 的 Shader 代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book v2/Chapter 18/Custom PBR&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Albedo&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//漫反射材质纹理</span></span><br><span class="line">        _Glossiness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.5</span></span><br><span class="line">        _SpecularColor (<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>)</span><br><span class="line">        _SpecGlossMap (<span class="string">&quot;Specular (RGB) Smoothness (A)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//_SpecGlossMap 的 RGB 通道值用于控制材质的高光反射颜色；_SpecGlossMap 的 A 通道值和 _Glossiness 用于共同控制材质的粗糙度</span></span><br><span class="line">        _BumpScale (<span class="string">&quot;Bump Scale&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _BumpMap (<span class="string">&quot;Normal Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">        _EmissionColor (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        _EmissionMap (<span class="string">&quot;Emission&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        LOD <span class="number">300</span></span><br><span class="line"></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HLSLSupport.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过使用#pragma target 3.0 来指明使用 Shader Target 3.0，这是因为基于物理渲染涉及了较多的公式，因此需要较多的数学指令来进行计算，这可能会超过 Shader Target 2.0 对指令数目的规定，因此我们选择使用更高的 Shader Target 3.0。</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fog</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Glossiness;</span><br><span class="line">            fixed4 _SpecularColor;</span><br><span class="line">            sampler2D _SpecGlossMap;</span><br><span class="line">            float4 _SpecGlossMap_ST;</span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            fixed4 _EmissionColor;</span><br><span class="line">            sampler2D _EmissionMap;</span><br><span class="line">            float4 _EmissionMap_ST;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;</span><br><span class="line">                float4 TtoW1 : TEXCOORD2;</span><br><span class="line">                float4 TtoW2 : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>) <span class="comment">// Defined in AutoLight.cginc</span></span><br><span class="line">                UNITY_FOG_COORDS(<span class="number">5</span>) <span class="comment">// Defined in UnityCG.cginc</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//选择使用 Disney BRDF 中的漫反射项实现，CustomDisneyDiffuseTerm 函数的实现如下。UNITY_INV_PI 是在 UnityCG.cginc 文件中定义的宏变量，即圆周率 π 的倒数。在上面的实现中，我们还使用了 Cg 关键词 inline 来修饰函数声明，inline 的作用是用于告诉编译器应该尽可能使用内联调用的方式来调用该函数，减少函数调用的开销。  </span></span><br><span class="line">            <span class="keyword">inline</span> half3 <span class="title function_">CustomDisneyDiffuseTerm</span><span class="params">(half NdotV, half NdotL, half LdotH, half roughness, half3 baseColor)</span> &#123;</span><br><span class="line">                half fd90 = <span class="number">0.5</span> + <span class="number">2</span> * LdotH * LdotH * roughness;</span><br><span class="line">                <span class="comment">// Two schlick fresnel term</span></span><br><span class="line">                half lightScatter = (<span class="number">1</span> + (fd90 - <span class="number">1</span>) * <span class="built_in">pow</span>(<span class="number">1</span> - NdotL, <span class="number">5</span>));</span><br><span class="line">                half viewScatter = (<span class="number">1</span> + (fd90 - <span class="number">1</span>) * <span class="built_in">pow</span>(<span class="number">1</span> - NdotV, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> baseColor * UNITY_INV_PI * lightScatter * viewScatter;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//可见性项 V，它计算的是阴影-遮掩函数除以高光反射项的分母部分后的结果。CustomSmithJointGGXVisibilityTerm 函数的实现如下：  </span></span><br><span class="line">            <span class="keyword">inline</span> half <span class="title function_">CustomSmithJointGGXVisibilityTerm</span><span class="params">(half NdotL, half NdotV, half roughness)</span> &#123;</span><br><span class="line">                <span class="comment">// Original formulation:</span></span><br><span class="line">                <span class="comment">// lambda_v = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;</span></span><br><span class="line">                <span class="comment">// lambda_l = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;</span></span><br><span class="line">                <span class="comment">// G = 1 / (1 + lambda_v + lambda_l);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Approximation of the above formulation</span></span><br><span class="line">                half a = roughness * roughness;</span><br><span class="line">                half lambdaV = NdotL * (NdotV * (<span class="number">1</span> - a) + a);</span><br><span class="line">                half lambdaL = NdotV * (NdotL * (<span class="number">1</span> - a) + a);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.5f</span> / (lambdaV + lambdaL + <span class="number">1e-5</span>f);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//法线分布项 D，CustomGGXTerm 函数的实现如下：  </span></span><br><span class="line">            <span class="keyword">inline</span> half <span class="title function_">CustomGGXTerm</span><span class="params">(half NdotH, half roughness)</span> &#123;</span><br><span class="line">                half a = roughness * roughness;</span><br><span class="line">                half a2 = a * a;</span><br><span class="line">                half d = (a2 - <span class="number">1.0f</span>) * NdotH * NdotH + <span class="number">1.0f</span>;</span><br><span class="line">                <span class="keyword">return</span> UNITY_INV_PI * a2 / (d * d + <span class="number">1e-7</span>f);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//菲涅耳反射项 F，CustomFresnelTerm 函数的实现如下：  </span></span><br><span class="line">            <span class="keyword">inline</span> half3 <span class="title function_">CustomFresnelTerm</span><span class="params">(half3 c, half cosA)</span> &#123;</span><br><span class="line">                half t = <span class="built_in">pow</span>(<span class="number">1</span> - cosA, <span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> c + (<span class="number">1</span> - c) * t;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//菲涅耳插值 CustomFresnelLerp 的函数实现如下：  </span></span><br><span class="line">            <span class="keyword">inline</span> half3 <span class="title function_">CustomFresnelLerp</span><span class="params">(half3 c0, half3 c1, half cosA)</span> &#123;</span><br><span class="line">                half t = <span class="built_in">pow</span>(<span class="number">1</span> - cosA, <span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> lerp (c0, c1, t);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                UNITY_INITIALIZE_OUTPUT(v2f, o); <span class="comment">// Defined in HLSLSupport.cginc</span></span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex); <span class="comment">// Defined in UnityCG.cginc</span></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); <span class="comment">// Defined in UnityCG.cginc</span></span><br><span class="line"></span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;</span><br><span class="line"></span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//We need this for shadow receving</span></span><br><span class="line">                TRANSFER_SHADOW(o); <span class="comment">// Defined in AutoLight.cginc</span></span><br><span class="line">                <span class="comment">//We need this for fog rendering</span></span><br><span class="line">                UNITY_TRANSFER_FOG(o, o.pos); <span class="comment">// Defined in UnityCG.cginc</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            half4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                <span class="comment">/////首先需要为后续计算准备好所有的输入数据，这些输入大多来源于材质面板中的各个属性，例如漫反射颜色 diffColor 和高光反射颜色 specColor、粗糙度 roughness、世界空间下的法线方向、光源方向、观察方向、反射方向等。我们还使用内置宏 UNITY_LIGHT_ATTENUATION 计算了阴影和光照衰减值 atten。除此之外，我们还计算了一个变量 oneMinusReflectivity，这个变量并不是我们之前提到的 BRDF 中需要的变量，它主要是为了计算掠射角的反射颜色，从而得到效果更好的菲涅耳反射效果。</span></span><br><span class="line">                half4 specGloss = tex2D(_SpecGlossMap, i.uv);</span><br><span class="line">                specGloss.a *= _Glossiness;</span><br><span class="line">                half3 specColor = specGloss.rgb * _SpecularColor.rgb;</span><br><span class="line">                half roughness = <span class="number">1</span> - specGloss.a;</span><br><span class="line"></span><br><span class="line">                half oneMinusReflectivity = <span class="number">1</span> - max(max(specColor.r, specColor.g), specColor.b);</span><br><span class="line"></span><br><span class="line">                half3 diffColor = _Color.rgb * tex2D(_MainTex, i.uv).rgb * oneMinusReflectivity;</span><br><span class="line"></span><br><span class="line">                half3 normalTangent = UnpackNormal(tex2D(_BumpMap, i.uv));</span><br><span class="line">                normalTangent.xy *= _BumpScale;</span><br><span class="line">                normalTangent.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(dot(normalTangent.xy, normalTangent.xy)));</span><br><span class="line">                half3 normalWorld = normalize(half3(dot(i.TtoW0.xyz, normalTangent), dot(i.TtoW1.xyz, normalTangent), dot(i.TtoW2.xyz, normalTangent)));</span><br><span class="line">                </span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                half3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos)); <span class="comment">// Defined in UnityCG.cginc</span></span><br><span class="line">                half3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos)); <span class="comment">// Defined in UnityCG.cginc</span></span><br><span class="line"></span><br><span class="line">                half3 reflDir = reflect(-viewDir, normalWorld);</span><br><span class="line"></span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, worldPos); <span class="comment">// Defined in AutoLight.cginc</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/////接下来开始计算最重要的 BRDF 光照模型。在此之前，我们先准备好各个角度的余弦值，即之前公式中的各个点乘项。通过使用 Cg 的 saturate 函数，我们把这些点乘值的范围截取到了[0, 1]之间，来避免背光面的光照</span></span><br><span class="line">                half3 halfDir = normalize(lightDir + viewDir);</span><br><span class="line">                half nv = saturate(dot(normalWorld, viewDir));</span><br><span class="line">                half nl = saturate(dot(normalWorld, lightDir));</span><br><span class="line">                half nh = saturate(dot(normalWorld, halfDir));</span><br><span class="line">                half lv = saturate(dot(lightDir, viewDir));</span><br><span class="line">                half lh = saturate(dot(lightDir, halfDir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算 BRDF 中的漫反射项：  </span></span><br><span class="line">                half3 diffuseTerm = CustomDisneyDiffuseTerm(nv, nl, lh, roughness, diffColor);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算高光反射项：</span></span><br><span class="line">                half V = CustomSmithJointGGXVisibilityTerm(nl, nv, roughness);</span><br><span class="line">                half D = CustomGGXTerm(nh, roughness * roughness);</span><br><span class="line">                half3 F = CustomFresnelTerm(specColor, lh);</span><br><span class="line">                half3 specularTerm = F * V * D;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算自发光项：</span></span><br><span class="line">                half3 emisstionTerm = tex2D(_EmissionMap, i.uv).rgb * _EmissionColor.rgb;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//为了得到更加真实的光照，还需要计算基于图像的光照部分（IBL），详见补充：  </span></span><br><span class="line">                half perceptualRoughness = roughness * (<span class="number">1.7</span> - <span class="number">0.7</span> * roughness);</span><br><span class="line">                half mip = perceptualRoughness * <span class="number">6</span>;</span><br><span class="line">                half4 envMap = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflDir, mip); <span class="comment">// Defined in HLSLSupport.cginc</span></span><br><span class="line">                half3 decodeEnvMap = DecodeHDR(envMap, unity_SpecCube0_HDR);  <span class="comment">//Decode the 4 channels HDR data to RGB format. Otherwise the indirectLight will be too bright because the cube map contains high dynamic range colors, which allows the values greater than 1.</span></span><br><span class="line">                </span><br><span class="line">                half grazingTerm = saturate((<span class="number">1</span> - roughness) + (<span class="number">1</span> - oneMinusReflectivity));</span><br><span class="line">                half surfaceReduction = <span class="number">1.0</span> / (roughness * roughness + <span class="number">1.0</span>);</span><br><span class="line">                half3 indirectSpecular = surfaceReduction * decodeEnvMap.rgb * CustomFresnelLerp(specColor, grazingTerm, nv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//最后按照渲染方程把所有项加起来：</span></span><br><span class="line">                half3 col = emisstionTerm + UNITY_PI * (diffuseTerm + specularTerm) * _LightColor0.rgb * nl * atten + indirectSpecular;</span><br><span class="line"></span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, c.rgb); <span class="comment">// Defined in UnityCG.cginc</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> half4(col, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 IBL 部分的补充：IBL 部分的主要思想是使用材质粗糙度对环境贴图进行 LOD，Level Of Detail 采样，这是因为粗糙度越大的材质，反射的环境光照应该越模糊，而这可以通过对环境贴图不同级数的多级渐远纹理 mipmaps 进行采样来模拟得到。级数越高，在多级渐远纹理中对应的纹理就越小，图像也就越模糊。</p><p>为了计算需要采样的多级渐远纹理的级数，我们将材质粗糙度乘以某个常数（在上述实现中该常数为 6），这个常数表明了整个粗糙度范围内多级渐远纹理的总级数。需要注意的是，这种由粗糙度计算级数的方法并不是唯一的，读者可以在 UnityImageBasedLighting.cginc 文件的 perceptualRoughnessToMipmapLevel 函数中找到相关实现。然后，我们使用该级数和反射方向来对环境贴图进行采样。其中，unity_SpecCube0 包含了该物体周围当前活跃的反射探针 Reflection Probe 中所包含的环境贴图。尽管我们没有在场景中手动放置任何反射探针，但 Unity 会根据 Window -&gt; Lighting -&gt; Skybox 中的设置，在场景中生成一个默认的反射探针。由于在本节的准备工作中我们在 Window -&gt; Lighting -&gt; Skybox 中设置了自定义的天空盒，因此此时 unity_SpecCube0 中包含的就是这个自定义天空盒的环境贴图。如果我们在场景中放置了其他反射探针，Unity 则会根据相关设置和物体所在的位置自动把距离该物体最近的一个或几个反射探针数据传递给 Shader。尽管在之前的内容中，我们是使用 samplerCUBE 来声明一个立方体贴图并使用 texCUBE 来采样它，但是 Unity 内置反射探针的立方体贴图则是以一种特殊的方式声明的，这主要是为了在某些平台下可以节省 sampler slots。读者可以在 UnityShaderVariables.cginc 文件中找到 unity_SpecCube0 的声明，Unity 主要是通过 HLSLSupport.cginc 文件中定义的内置宏 UNITY_DECLARE_TEXCUBE 来实现的。 由于这样的特殊性， 在采样 unity_SpecCube0 时我们也应该使用内置宏如 UNITY_SAMPLE_TEXCUBE（在 HLSLSupport.cginc 文件中被定义）来采样。由于在这里我们还需要对指定级数的多级渐远纹理采样，因此我们使用内置宏 UNITY_SAMPLE_TEXCUBE_LOD（在 HLSLSupport.cginc 文件中被定义）来实现。至此，我们得到了采样后的环境光照颜色 envMap。</p><p>对环境光采样后变量 envMap 为 HDR 值 RGBM，直接使用会导致材质过曝，因此添加了 DecodeHDR 函数将 HDR 转换为 RGB。</p><p>然后，为了给 IBL 添加更加真实的菲涅耳反射，我们对高光反射颜色 specColor 和掠射颜色 grazingTerm 进行菲涅耳插值。掠射颜色 grazingTerm 是由材质粗糙度和之前计算得到的 oneMinusReflectivity 共同决定的。使用掠射角度进行菲涅耳插值的好处是，我们可以在掠射角得到更加真实的菲涅耳反射效果，同时还考虑了材质粗糙度的影响。除此之外，我们还使用了由粗糙度计算得到的 surfaceReduction 参数进一步对 IBL 的进行修正。</p><p>CustomFresnelLerp 的函数的实现和之前实现的 CustomFresnelTerm 函数很类似，不同的是这里使用参数 t 来混合两个颜色。尽管 grazingTerm 被声明为单一维数的 half 变量，在传递给 CustomFresnelLerp 时它会自动被转换成 half3 类型的变量，这在 Cg 中被称为是 <strong>“Smearing” Of Scalars To Vectors</strong>。</p><hr><p>若场景中存在多个光源，需要实现 Forward Add Pass。Forward Add Pass 的实现与 Forward Base Pass 基本一致，其中不同的是，Forward Add Pass 不需要计算雾效、自发光和 IBL 的部分，因为这些只需要在 Forward Base Pass 计算一遍即可。其他实现在此不再赘述。</p><p>保存后返回场景，再调整相关参数，Color 为黑色，Smoothness 为 0.75，Specular 为白色，不添加任何贴图的效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2024/01/07/duosjItMTSVGU9P.jpg" width = "80%" height = "80%" alt="图92- 使用自定义的基于物理渲染的材质"/></div><p>需要注意的是，我们还需要保证 Edit -&gt; Project Settings -&gt; Player -&gt; Color Space 中的选项是 Linear，即线性空间，只有这样才能保证我们的计算是在线性空间下进行的，且输出的为线性颜色。与线性空间相关的是<strong>伽马校正</strong>，详见后面。</p><p>在上面的内容中，我们依靠自定义的函数实现了一个基于 GGX BRDF 模型的 Shader。实际上，Unity 已经帮我们实现了很多 BRDF 模型中的函数，并为我们提供了现成的基于物理着色的 Shader，也就是 <strong>Standard Shader</strong>。</p><h2 id="Unity-5-的-Standard-Shader"><a href="#Unity-5-的-Standard-Shader" class="headerlink" title="Unity 5 的 Standard Shader"></a>Unity 5 的 Standard Shader</h2><p>在 Unity 5 中新创建一个模型或是新创建一个材质时，其默认使用的着色器都是一个名为 Standard 的着色器。Unity 支持两种流行的基于物理的工作流程：<strong>金属工作流 metallic workflow</strong> 和<strong>高光反射工作流 specular workflow</strong>。其中，金属工作流是默认的工作流程，对应的 Shader 为 Standard Shader。而如果想要使用高光反射工作流，就需要在材质的 Shader 下拉框中选择 Standard（Specular setup）。在内部实现上，这两种工作流实际上最终都会使用同一套 BRDF 模型，不同的是 BRDF 模型中各个输入参数的来源不同而已。</p><h3 id="它们是如何实现的"><a href="#它们是如何实现的" class="headerlink" title="它们是如何实现的"></a>它们是如何实现的</h3><p>Standard 和 Standard（Specular setup）的 Shader 源代码可以在 Unity 内置的 builtin_shaders-XXXXXX/DefaultResourcesExtra 文件夹中找到，这些 Shader 依赖于 builtin_shaders-XXXXXX/CGIncludes 文件夹中定义的一些头文件。这些相关的头文件的名称大多类似于 UnityStandardXXX.cginc，其中定义了和 PBS 相关的各个函数、结构体和宏等。下表列出了这些头文件的名称以及它们的主要用处：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">文件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">UnityStandardInput.cginc</td><td style="text-align:left">声明了 Standard 和 Standard (Specular setup) Shader 使用的所有材质参数（如 _Color、_MainTex、_EmissionMap），定义了顶点着色器的输入结构体 VertexInput，还定义了相关辅助函数用于从这些输入中计算得到相关的材质变量，例如 Albedo 函数可以从 _MainTex 和 _Color 参数中计算得到漫反射颜色，Occlusion 函数可以从 _OcclusionMap 中计算得到遮挡值</td></tr><tr><td style="text-align:left">UnityLightingCommon.cginc</td><td style="text-align:left">定义了和 PBS 光照相关的各个结构体，例如 UnityLight、UnityIndirect、UnityGI 和 UnityGIInput 等</td></tr><tr><td style="text-align:left">UnityStandardCore.cginc</td><td style="text-align:left">定义了 Standard 和 Standard (Specular setup) Shader 使用的顶点/片元着色器（ 如 vertForwardBase 和 fragForwardBase ）、相关的结构体 （ 如 VertexOutputForwardBase 和 FragmentCommonData ） 和辅助函数（如 MetallicSetup、SpecularSetup、MainLight、PerPixelWorldNormal、FragmentGI）等</td></tr><tr><td style="text-align:left">UnityStandardCoreForwardSimple.cginc</td><td style="text-align:left">定义了简化版的顶点/片元着色器（ 如 vertForwardBaseSimple 和 fragForwardBaseSimple）、相关的结构体（如 VertexOutputBaseSimple）和辅助函数（如 FragmentSetupSimple、MainLightSimple）等。在默认情况下，Unity 会将 UNITY_STANDARD_SIMPLE（在 UnityStandardConfig.cginc 文件中被定义）设为 0，即不使用这些简化后的实现</td></tr><tr><td style="text-align:left">UnityPBSLighting.cginc</td><td style="text-align:left">定义了表面着色器使用的标准光照函数和相关的结构体等，如 LightingStandardSpecular 函数和 SurfaceOutputStandardSpecular 结构体，这些定义主要是为 Unity 表面着色器（Surface Shader）服务的。除此之外，还定义 PBS 函数的调用宏 UNITY_BRDF_PBS，Unity 会根据当前平台设置等为 UNITY_BRDF_PBS 设置不同性能的函数入口，如 BRDF1_Unity_PBS、BRDF2_Unity_PBS 和 BRDF3_Unity_PBS 等函数，而这些函数是在 UnityStandardBRDF.cginc 文件中被定义的</td></tr><tr><td style="text-align:left">UnityStandardBRDF.cginc</td><td style="text-align:left">实现了 Unity 中基于物理的渲染技术，定义了 BRDF1_Unity_PBS、BRDF2_Unity_PBS 和 BRDF3_Unity_PBS 等函数，来实现不同平台下的 BRDF。这个文件包含了关键的 BRDF 模型的实现部分，包括漫反射项和高光反射项的函数实现（如 DisneyDiffuse、SmithJointGGXVisibilityTerm）和相关的辅助函数（如 常用的数学函数 Pow4 和 Pow5 、 PerceptualRoughnessToSpecPower）</td></tr><tr><td style="text-align:left">UnityGlobalIllumination.cginc</td><td style="text-align:left">定义了计算全局光照的 UnityGlobalIllumination 函数，该函数在 FragmentGI 函数（在 UnityStandardCore.cginc 中被定义）中被调用，它会从光照贴图、光照探针、反射探针等输入中读取数据，计算全局光照中的间接漫反射颜色和高光反射颜色，并存储 UnityGI 结构体中的 UnityIndirect 结构体变量中（两个结构体均在 UnityLightingCommon.cginc 中被定义）</td></tr><tr><td style="text-align:left">UnityImageBasedLighting.cginc</td><td style="text-align:left">定义了和基于图像的光照相关的结构体和函数，这些结构体和函数会在计算全局光照时被使用，例如 Unity_GlossyEnvironment 函数会采样反射探针中的数据，它可以用于计算间接的高光反射</td></tr><tr><td style="text-align:left">UnityStandardUtils.cginc</td><td style="text-align:left">Standard Shader 使用的一些辅助函数，将来可能会移到 UnityCG.cginc 文件中</td></tr><tr><td style="text-align:left">UnityStandardConfig.cginc</td><td style="text-align:left">Standard Shader 的相关配置，例如默认情况下使用 GGX 模型来实现 BRDF（将 UNITY_BRDF_GGX 设为 1）</td></tr><tr><td style="text-align:left">UnityStandardMeta.cginc</td><td style="text-align:left">定义了 Standard Shader 中 “LightMode” 为 “Meta” 的 Pass（用于提取光照纹理和全局光照的相关信息）使用的顶点/片元着色器，以及它们使用的输入/输出结构体</td></tr><tr><td style="text-align:left">UnityStandardShadow.cginc</td><td style="text-align:left">定义了 Standard Shader 中 “LightMode” 为 “ShadowCaster” 的 Pass（用于投射阴影）使用的顶点/片元着色器，以及它们使用的输入/输出结构体</td></tr></tbody></table></div><p>Standard.shader 和 StandardSpecular.shader 的代码分析如下：<br>①总体来讲，这两个 Shader 的代码基本相同—它们都定义了两个 SubShader，第一个 SubShader 使用的计算更加复杂，Unity 为其定义了前向渲染路径和延迟渲染路径使用的 Pass，以及用于投射阴影和提取元数据的 Pass；第二个 SubShader 也定义了 4 个 Pass，其中两个 Pass 用于前向渲染路径，一个 Pass 用于投射阴影，另一个 Pass 用于提取元数据，该 SubShader 和第一个 SubShader 的主要区别在于取消了一些计算，例如不计算视差贴图、不计算软阴影等。<br>②它们最大的不同之处在于，它们在设置 BRDF 的输入时使用了不同的函数来设置各个参数 — 基于金属工作流的 Standard Shader 使用 MetallicSetup 函数来设置各个参数，基于高光反射工作流的 Standard（Specular setup）Shader 使用 SpecularSetup 函数来设置。MetallicSetup 和 SpecularSetup 函数均在 UnityStandardCore.cginc 文件中被定义。</p><p>下图出了 Standard Shader 中用于前向渲染路径的典型实现，这是由对内置文件的分析所得：  </p><div  align="center">  <img src="https://s2.loli.net/2024/01/08/v3fX5dsCAmJiOHw.jpg" width = "100%" height = "100%" alt="图93- Standard Shader 中前向渲染路径使用的 Pass（简化版本的 PBS 使用了 VertexOutputBaseSimple 等结构体来代替相应的结构体）"/></div><h3 id="如何使用-Standard-Shader"><a href="#如何使用-Standard-Shader" class="headerlink" title="如何使用 Standard Shader"></a>如何使用 Standard Shader</h3><p>金属材质和非金属材质的漫反射和高光反射的一些特点：<br>①金属材质<br>&emsp;&emsp; - 几乎没有漫反射，因为所有被吸收的光都会被自由电子立刻转化为其他形式的能量；<br>&emsp;&emsp; - 有非常强烈的高光反射；<br>&emsp;&emsp; - 高光反射通常是有颜色的，例如金子的反光颜色为黄色。<br>②非金属材质<br>&emsp;&emsp; - 大多数角度高光反射的强度比较弱，但在掠射角时高光反射强度反而会增强，即菲涅耳现象；<br>&emsp;&emsp; - 高光反射的颜色比较单一；<br>&emsp;&emsp; - 漫反射的颜色多种多样。</p><p>在 Unity 官方提供的示例项目 <strong>Shader Calibration Scene</strong> 中，Unity 提供了两个非常有参考价值的校准表格，如下图所示，它们分别对应了金属工作流和高光反射工作流使用的参考属性值，来方便我们针对不同类型的材质来调整参数。</p><table><tr><td><img src='https://s2.loli.net/2024/01/08/IrVKbMOlyYTFfoh.png' width="400" alt="图94- 金属工作流使用的校准表格"></td><td><img src='https://s2.loli.net/2024/01/08/E14Qf7imDrz3xkw.png' width="400" alt="图95- 高光反射工作流使用的校准表格"></td></tr></table><p>需要注意的是，为了保证数学上准确，光照计算应该在线性空间执行。在使用标准纹理时，需要在 Edit -&gt; Project Settings -&gt; Player -&gt; Color Space 中选择 Linear 线性空间，这是因为基于物理的渲染需要使用线性空间来进行相关计算。</p><p>在金属工作流中，材质面板中的 <strong>Albedo</strong> 定义了物体的整体颜色，它通常就是我们视觉上认为的物体颜色。从亮度来看，非金属材质的亮度范围通常在 50～243，而金属材质的亮度一般在 186~255 之间。材质面板中的下一个属性是 <strong>Metallic</strong>，它定义了该物体表面看起来是否更像金属或非金属。同样，我们也可以使用一张纹理来采样得到表面的 Metallic 值，此时该纹理中的 R 通道值将对应了 Metallic 值。最后一个重要的材质属性是 <strong>Smoothness</strong>，它是上一个属性 Metallic 的附属值，定义了从视觉上来看该表面的光滑程度。如果我们在设置 Metallic 属性时使用的是一张纹理，那么这张纹理的 A 通道就对应了表面的 Smoothness 值（此时纹理的 GB 通道则被忽略）。</p><p>高光反射工作流，使用了不同含义的 <strong>Albedo</strong> 属性，并使用 <strong>Specular</strong> 代替了上述的 <strong>Metallic</strong> 属性。在高光反射工作流中，材质的 <strong>Albedo</strong> 属性定义了表面的漫反射强度。对于非金属材质，它的值通常仍然是视觉上认为的物体颜色，但对于金属材质，Albedo 的值通常非常接近黑色（还记得吗，金属材质几乎不存在次表面散射的现象）。高光反射工作流的 <strong>Specular</strong> 属性则定义了表面的高光反射强度。非金属材质通常使用一个灰度值范围在 0～55 的深灰色来作为 Specular 值，表明非金属材质的高光反射较弱。金属材质则通常会使用视觉上认为的该金属的颜色作为它的 Specular 值。<strong>Specular</strong> 属性同样也有一个子属性 <strong>Smoothness</strong>，它定义了从视觉上来看该表面的光滑程度。和上面的金属工作流类似，如果使用了一张纹理来为 Specular 属性赋值，那么纹理的 RGB 通道对应了 Specular 属性值，A 通道对应了 Smoothness 属性值。</p><p>上述材质属性都属于材质面板中的 <strong>Main Maps</strong> 部分，除了上述提到的属性外，Main Maps 还包含了其他材质属性，例如，切线空间下的法线纹理、遮挡纹理、自发光纹理等。Main Maps 部分的下面还有一个 <strong>Secondary Maps</strong> 的属性部分，这个部分的属性是用来定义额外的细节信息，这些细节通常会直接绘制在 Main Maps 的上面，来为材质提供更多的微表面或细节表现。</p><p>除了上述属性，我们还可以为 Standard Shader 选择它使用的渲染模式，即材质面板上的 <strong>Render Mode</strong> 选项。Standard Shader 支持 4 种渲染模式，分别是 Opaque、Cutout、Fade 和 Transparent。其中，<strong>Opaque</strong> 用于渲染最常见的不透明物体，这也是默认的渲染模式。对于像玻璃这样的材质，我们可以选择 <strong>Transparent</strong> 模式，在这个渲染模式下，Albedo 属性的 A 通道用于控制材质的透明度。而在 <strong>Cutout</strong> 渲染模式下，Albedo 属性中纹理的 A 通道会成为一个遮掩纹理，而它的子属性 Alpha Cutoff 将是透明度测试时使用的阈值。<strong>Fade</strong> 模式和 Transparent 模式是类似的，不同的是，在 Transparent 模式下，当材质的透明值不断降低时，它的反射仍然能被保留，而在 Fade 模式下，该材质的所有渲染效果都会逐渐从屏幕上淡出。</p><p>需要注意的是，尽管 Standard Shader 的材质面板有许多可供调节的属性，但我们不用担心由于没有使用一些属性而会对性能有所影响。Unity 在背后已经进行了高度优化，在我们生成可执行程序时，Unity 会检查哪些属性没有被使用到，同时也会针对目标平台进行相应的优化。这些逻辑是通过使用一个 C# 脚本文件来自定义材质面板的行为来实现的，读者可以在 builtin_shaders-XXXXX/ Editor/ StandardShaderGUI.cs 中找到这个文件。这个脚本的核心思想是通过判断用户是否设置了某一材质属性来决定是否开启相应的 shader feature，例如，如果用户没有设置法线纹理，那么该脚本就会关闭名为 _NORMALMAP 的 shader feature，从而在 Shader 逻辑中跳过相关代码。</p><p>想要让整个场景的渲染结果令人满意，尤其包含了复杂光照的场景，仅仅有这些使用了 PBS 的材质是不够的，我们需要使用 Unity 提供的其他一些重要的技术，例如 HDR 格式的 Skybox、全局光照、反射探针、光照探针、HDR 和屏幕后处理等。更多内容读者阅读本章的扩展阅读部分。</p><h2 id="一个更加复杂的例子"><a href="#一个更加复杂的例子" class="headerlink" title="一个更加复杂的例子"></a>一个更加复杂的例子</h2><p>场景对应了本书资源中的 Scene_18_3。本场景使用的元素大多来源于 Unity 官方的示例项目 <strong>Viking Village</strong>。别忘了先把色彩空间改为线性空间。下面不再放出图片，了解原理即可。</p><h3 id="设置光照环境"><a href="#设置光照环境" class="headerlink" title="设置光照环境"></a>设置光照环境</h3><p>首先需要为场景设置光照环境，在默认情况下，Unity 5 中一个新创建的场景会包含一个默认的 Skybox。在本例中，我们使用一个自定义的 Skybox 来代替默认值，使用的是 SunsetSkyboxHDR。</p><p>本例中的 Skybox 使用了一个 <strong>HDR</strong> 格式的 Cubemap，后面会详细讲解 HDR，这里，只需要知道，使用 HDR 格式的 Skybox 可以让场景中物体的反射更加真实，有利于我们得到更加可信的光照效果。</p><p>我们还可以设置场景使用的<strong>环境光照</strong>，这些环境光照可以对场景中所有的物体表面产生影响。在 Lighting -&gt; Environment 的设置面板中，我们可以选择环境光照的来源（Ambient Source 选项，目前版本叫 <strong>Environment Lighting Source</strong> 属性），是来自于场景使用的 Skybox，还是使用渐变值，亦或是某个固定的颜色。我们还可以设置环境光照的强度（Ambient Intensity 参数，目前版本叫 <strong>Environment Lighting Intensity Multiplier</strong> 属性），如果想要场景中的所有物体不接受任何环境光照，可以把该值设为 0。在使用了 Standard Shader 的前提下，如果我们关闭场景中所有的光源，并把环境光照的强度设为 0，场景中的物体仍然可以接受一些光照。图片这里不放出了，总之还有物体接受到的<strong>反射</strong>光。</p><p>默认的反射源（Reflection Source 选项，目前版本叫 <strong>Environment Reflections Source</strong>）是场景使用的 Skybox。可以把反射源设置为自定义，即 Custom。在渲染实现上，即便场景中没有任何光源，Unity 在内部仍然会调用 ForwardBase Pass（假设使用的是前向渲染路径的话），并使用反射的光照信息来填充光源信息，再进行基于物理的渲染计算。读者可以通过帧调试器 Frame Debugger 来查看渲染过程。需要注意的是，这里设置的反射源是默认的反射源，如果我们在场景中添加了其他反射探针 Reflection Probes，物体可能会使用其他反射源。当默认反射源是 Skybox 时，Unity 会由场景使用的 Skybox 生成一个 Cubemap，我们可以通过 <strong>Resolution</strong> 选项来控制它每个面的分辨率。</p><hr><p>除了 Standard Shader 外，Unity 还引入了一个重要的流水线 - <strong>实时全局光照 Global Illumination，GI</strong> 流水线。使用 GI，场景中的物体不仅可以受直接光照的影响，还可以接受间接光照的影响。直接光照指的是那些直接把光照射到物体表面的光源，在本书之前的章节中，我们使用的都是直接光照来渲染场景中的物体。但在现实生活中，物体还会受到间接光照的影响。例如，想象一个红色墙壁旁边放置了一个球体，尽管墙壁本身不发光，但球体靠近墙的一面仍会有少许的红色，这是由于红色墙壁把一些间接光照投射到了球体上。在 Unity 中，间接光照指的就是那些被场景中其他物体反弹的光，这些间接光照会受反弹光的表面的颜色影响（例如之前例子中的红色的墙壁），这些表面会在反弹光线时把自身表面的颜色添加到反射光的计算中。在 Unity 5 中，我们可以使用这些直接光照和间接光照来创建更加真实的视觉效果。</p><hr><p>首先设置场景使用的<strong>直接光照</strong> - 一个平行光。为了让渲染效果更加真实可信，我们需要保证平行光的方向和 Skybox 中的太阳或其他光源的位置一致，使得物体产生的光照信息可以与 Skybox 互相吻合。有时，我们可能会使用一张<strong>耀斑纹理 Flare Texture</strong> 来模拟太阳等光源，此时我们同样需要确保平行光的方向与耀斑纹理的位置一致。与之类似的还有平行光的颜色，我们应该尽量让平行光的颜色和场景环境相匹配。若场景的光照环境为日落时分，平行光的颜色可为浅黄色；若场景的光照环境更接近傍晚，此时平行光的颜色为淡蓝色。</p><p>在平行光面板的 <strong>Mode</strong> 选项中，选择 <strong>Realtime</strong> 模式，这意味着，场景中受平行光影响的所有物体都会进行实时的光照计算，当光源或场景中其他物体的位置、旋转角度等发生变化时，场景中的光照结果也会随之变化。然而，实时光照往往需要较大的性能消耗，对于移动平台这样资源比较短缺的平台，我们可以选择 <strong>Baked</strong> 模式，此时，Unity 会把该光源的光照效果烘焙到一张<strong>光照纹理 lightmap</strong> 中，这样我们就不用实时为物体计算复杂的光照，而只需要通过纹理采样来得到光照结果。选择烘焙模式的缺点在于，如果场景中的物体发生了移动，但是它的阴影等光照效果并不会发生变化。<strong>Mix</strong> 模式则允许我们混合使用实时模式和烘焙模式，它会把场景中的静态物体（即那些被标识为 <strong>Static</strong> 的物体）的光照烘焙到光照纹理中，但仍然会对动态物体产生实时光照。</p><p>Unity 5 引入了实时间接光照的功能，在这个系统下，场景中的直接光照会在场景中各个物体之间来回反射，产生<strong>间接光照</strong>。当一条光线从光源被发射出来后，它会与场景中的一些物体相交，第一个和光线相交的物体受到的光照即为直接光照。当得到直接光照在该物体上的光照结果后，该物体还会继续反射该光线，从而对其他物体产生间接光照。此后与该光线相交的物体，就会受到间接光照的影响，同时它们也会继续反射。当经过多次反射后，该光线最后完全消失。这些间接光照的强度是由 GI 系统计算得到的默认亮度值。调整 Lighting -&gt; Environment -&gt; Environment Reflections <strong>Bounces</strong> 参数可以调节这些间接光照的强度。当我们把它设为 1 时，意味着一条光线仅会和一个物体相交，不再被继续反射，也就是说，场景中的物体只会受到直接光照的影响。需要注意的是，间接光照还有可能来自一些自发光的物体。</p><h3 id="放置反射探针"><a href="#放置反射探针" class="headerlink" title="放置反射探针"></a>放置反射探针</h3><p>在实时渲染中，我们经常会使用 Cubemap 来模拟物体的反射效果。然而，如果我们永远使用同一个 Cubemap，当移动物体周围的场景发生较大变化时，就很容易出现“穿帮镜头”，因为物体的环境反射并没有随着环境变化而发生变化。</p><p>一种解决办法是可以在脚本中控制何时生成从当前位置观察到的 Cubemap，而 Unity 5 为我们提供了一种更加方便的途径，即使用<strong>反射探针 Reflection Probes</strong>。反射探针的工作原理和光照探针 Light Probes 类似，它允许我们在场景中的特定位置上对整个场景的环境反射进行采样，并把采样结果存储在每个探针上。当游戏中包含反射效果的物体从这些探针附近经过时，Unity 会把从这些邻近探针存储的反射结果传递给物体使用的反射纹理。如果物体周围存在多个反射探针，Unity 还会在这些反射结果之间进行插值，来得到平滑渐变的反射效果。实际上，Unity 会在场景中放置一个默认的反射探针，这个反射探针存储了对场景使用的 Skybox 的反射结果，来作为场景的环境光照。如果我们需要让场景中的物体包含额外的反射效果，就需要放置更多的反射探针。</p><p>反射探针同样有 3 种类型：<br>①<strong>Baked</strong>，这种类型的反射探针是通过提前烘焙来得到该位置使用的 Cubemap 的，在游戏运行时反射探针中存储的 Cubemap 并不会发生变化。需要注意的是，这种类型的反射探针在烘焙时同样只会处理那些静态物体（即那些被标识为 Reflection Probe Static 的物体）；<br>②<strong>Realtime</strong>，这种类型则会实时更新当前的 Cubemap，并且会受到动态物体的影响；当然，这种类型的反射探针需要花费更多的处理时间，因此，在使用时应当非常小心它们的性能。幸运的是，Unity 允许我们从脚本中通过触发来精确控制反射探针的更新；<br>③<strong>Custom</strong>，这种类型的探针既可以让我们从编辑器中烘焙它，也可以让我们使用一个自定义的 Cubemap 来作为反射映射，但自定义的 Cubemap 不会被实时更新。  </p><p>在放置反射探针时，选取的位置并不是任意的。通常来说，反射探针应该被放置在那些具有明显反射现象的物体的旁边，或是一些墙角等容易发生遮挡的物体周围。当我们放置好探针后，我们还需要为它们定义每个探针的影响区域，当反射物体进入到这个区域后，反射探针就会对物体的反射产生影响。通常情况下，反射探针的影响区域之间往往会有所重叠。此时，Unity 会计算反射物体的包围盒与这些重叠区域的交叉部分，并据此来选择使用的反射映射。如果当前的目标平台使用的是 SM 3.0 及以上的话，Unity 还可以允许我们在这些互相重叠的反射探针之间进行混合，来实现平缓的反射过渡效果。</p><hr><p>使用 Unity 内置的反射探针的另一个好处是，我们可以模拟<strong>互相反射 interreflections</strong>。例如，假设场景中有两面互相面对面的镜子，在理想情况下，它们不仅会反射自己对面的那面镜子，也会反射那面镜子里反射的图像。只要反射光线没有被完全吸收，反射就会一直进行下去。要实现这种效果，就需要追踪光线的反射轨迹，这是传统的反射方法所无法实现的。Unity 5 引入的 GI 系统让这种效果变成了可能，我们可以在每个相互反射的物体的位置处放置一个反射探针，并把每个物体的 Mesh Renderer 组件中的 Reflection Probes 设置为 Simple，这样保证它们只会使用离它们最近的一个反射探针。默认情况下，反射探针只会捕捉一次反射，也就是说，左边物体使用的反射探针只会捕捉到由右边物体第一次反射过来的光线。但在理想情况下，反射过来的光线会继续被左边的物体反射，并对右边的物体造成影响。Unity 允许我们控制物体之间这样来回反射的次数，这可以通过改变 Reflection Bounces 参数来实现。</p><p>使用反射探针往往会需要更多的计算时间。这些探针实际上也是通过在它的位置上放置一个摄像机，来渲染得到一个 Cubemap。如果我们把反弹次数设置的很大，或是使用实时渲染，那么这些探针很可能会造成性能瓶颈。</p><h3 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h3><p>在使用基于物理的渲染方法渲染整个场景时，我们应该使用<strong>线性空间 Linear Space</strong> 来得到最好的渲染效果。使用线性空间可以得到更加真实的效果。但它的缺点在于，需要一些硬件支持来实现线性计算，但一些移动平台对它的支持并不好。这种情况下，我们往往只能退而求其次，选择伽马空间进行渲染和计算。下面会解释<strong>伽马校正 Gamma Correction</strong> 的相关内容。实际上，当我们在默认的伽马空间下进行渲染计算时，由于使用了非线性的输入数据，导致很多计算都是在非线性空间下进行的，这意味着我们得到的结果并不符合真实的物理期望。除此之外，由于输出时没有考虑显示器的显示伽马的影响，会导致渲染出来的画面整体偏暗，总是和真实世界不像。</p><h2 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h2><h3 id="什么是全局光照"><a href="#什么是全局光照" class="headerlink" title="什么是全局光照"></a>什么是全局光照</h3><p><strong>全局光照</strong>，指的就是模拟光线是如何在场景中传播的，它不仅会考虑那些直接光照的结果，还会计算光线被不同的物体表面反射而产生的间接光照。</p><p>通常来讲，这些间接光照的计算是非常耗时间的，通常不会用在实时渲染中。一个传统的方法是使用光线追踪，来追踪场景中每一条重要的光线的传播路径。使用光线追踪能得到非常出色的画面效果，因此，被大量应用在电影制作中。但是，这种方法往往需要大量时间才能得到一帧，并不能满足实时的要求。</p><p>Unity 采用了 <strong>Enlighten 解决方案</strong>来让全局光照能够在各种平台上有不错的性能表现。事实上，Enlighten 也已经被集成在虚幻引擎 Unreal Engine 中，它已经在很多 3A 大作中展现了自身强大的渲染能力。总体来讲，Unity 使用了实时+预计算的方法来模拟场景中的光照。其中，实时光照用于计算那些直接光源对场景的影响，当物体移动时，光照也会随之发生变化。但正如我们之前所说，实时光照无法模拟光线被多次反射的效果。为了得到更加真实的渲染效果，Unity 又引入了<strong>预计算光照</strong>的方法，使得全局光照甚至在一些高端的移动设备上也可以达到实时的要求。</p><p>预计算光照包含了我们常见的光照烘焙，也就是指我们把光源对场景中静态物体的光照效果提前烘焙到一张光照纹理中，然后把这张光照纹理直接贴在这些物体的表面，来得到光照效果。这些光照纹理不仅存储了直接光照的结果，还包含了那些由物体反射得到的间接光照。但是，这些光照纹理无法在游戏运行时不断更新，也就是说，它们是静态的。不过这种方法的确为移动平台的复杂光照模拟提供了一个有效途径。</p><p>由于静态的光照烘焙无法在光照条件改变时更新物体的光照效果，因此，Unity 使用了<strong>预计算实时全局光照 Precomputed Realtime GI</strong> 为我们提供了一个解决途径，来动态地为场景实时更新复杂的光照结果。使用这种技术我们可以让场景中的物体包含丰富的全局光照效果，例如多次反射等，并且这些计算都是实时的，可以随着光源和物体的移动而发生变化。这是使用之前的实时光照或烘焙光照所无法实现的。</p><p>实现的原理：一旦物体和光源的位置被固定了，这些物体对光线的反弹路径以及漫反射光照（我们假设漫反射光照在各个方向的分布是相同的）也是固定的，也就是说是和摄像机无关的。因此，我们可以使用预计算方法来把这些物体之间的关系提前计算出来，而在实时运行时，只要光源的位置（光源的颜色是可以实时变化的）不变，即便改变了光源颜色和强度、物体材质属性（指的是漫反射和自发光相关的属性），这些信息就一直有效，不需要实时更新。</p><p>在预计算阶段，Enlighten 会在由所有静态物体组成的场景上，进行简化的“光线追踪”过程。在这个过程中 Enlighten 会自动把场景分割成很多个子系统，它并不是为了得到精确的光照效果，而是为了得到场景中物体之间的关系。需要注意的是，这些预计算都是在静态物体上进行的，因此，为了利用上述的预计算方法，我们至少需要把场景中的一个物体标识为 Static（至少需要把 Lightmap Static 勾选上）。一个例外是物体的高光反射，这是和摄像机的位置相关的，Unity 的解决方案是使用反射探针，正如我们之前看到的那样。对于动态移动的物体来说，我们可以使用光照探针来模拟它的光照环境。因此，在实时运行时，Unity 会利用预计算得到的信息来计算光照信息，并把它们存储在额外的光照纹理、光照探针或 Cubemap 中，再和物体材质进行必要的光照计算，得到最后的渲染效果。</p><p>Unity 全新的全局光照解决方案可以大大提高一些基于 PC /游戏机等平台的大型游戏的画面质量，但如果要在移动平台上使用仍需要非常小心它的性能。</p><h3 id="什么是伽马校正"><a href="#什么是伽马校正" class="headerlink" title="什么是伽马校正"></a>什么是伽马校正</h3><p>Unity 默认的空间是伽马空间，要把伽马空间转换到线性空间，就需要进行<strong>伽马校正 Gamma Correction</strong>。</p><p>伽马校正中的伽马一词来源伽马曲线。通常，伽马曲线的表达式如下：  </p><script type="math/tex; mode=display">L_{out} = L_{in}^{\gamma}</script><p>最开始的时候，人们使用伽马曲线来对拍摄的图像进行<strong>伽马编码 gamma encoding</strong>。事情的起因可以从在真实环境中拍摄一张图片说起。摄像机的原理可以简化为，把进入到镜头内的光线亮度编码成图像（例如一张 JEPG）中的像素。如果我们只用 8 位空间来存储像素的每个通道的话，这意味着 0～1 区间可以对应 256 种不同的亮度值。但是，后来人们发现，人眼有一个有趣的特性，就是对光的灵敏度在不同亮度上是不一样的。在正常的光照条件下，人眼对较暗区域的变化更加敏感。即亮度上的线性变化对人眼感知来说是非均匀的。</p><p>如果使用 8 位空间来存储每个通道的话，我们仍然把 0.5 亮度编码成值为 0.5 的像素，那么暗部和亮部区域我们都使用了 128 种颜色来表示，但实际上，对亮部区域使用这么多颜色是种存储浪费。一种更好的方法是，我们应该把把更多的空间来存储更多的暗部区域，这样存储空间就可以被充分利用起来了。摄影设备如果使用了 8 位空间来存储照片的话，会使用大约为 0.45 的编码伽马来对输入的亮度进行编码，得到一张编码后的图像。因此，图像中 0.5 像素值对应的亮度其实并不是 0.5，而大约为 0.22。这是因为：  </p><script type="math/tex; mode=display">0.5 \approx 0.22^{0.45}</script><p>对拍摄图像使用的伽马编码使得我们可以充分利用图像的存储空间。但当把图片放到显示器里显示时，我们应该对图像再进行一次解码操作，使得屏幕输出的亮度和捕捉到的亮度是符合线性的。</p><p>这时，人们发现了一个奇妙的巧合，CRT 显示器本身几乎已经自动做了这个解码操作！在早期，<strong>CRT Cathode Ray Tube，阴极射线管</strong>几乎是唯一的显示设备。这类设备的显示机制是，使用一个电压轰击它屏幕上的一种图层，这个图层就可以发亮，我们就可以看到图像了。但 CRT 显示器有一个特性，它的输入电压和显示出来的亮度关系不是线性的，也就是说，如果我们把输入电压调高两倍，屏幕亮度并没有提高两倍。我们把显示器的这个伽马曲线称为<strong>显示伽马 diplay gamma</strong>。非常巧合的是，CRT 的显示伽马值大约就是编码伽马的倒数。CRT 显示器的这种特性，正好补偿了图像捕捉设备的伽马曲线。虽然现在 CRT 设备很少见了，并且后来出现的显示设备有着不同的伽马响应曲线，但是，人们仍在硬件上做了调整来提供兼容性。下图展示了编码伽马和显示伽马在图像捕捉和显示时的作用：  </p><div  align="center">  <img src="https://s2.loli.net/2024/01/09/xI3SbLC8jWRMGUm.jpg" width = "80%" height = "80%" alt="图96- 编码伽马和显示伽马"/></div><p>随后，微软联合爱普生、惠普提供了 <strong>sRGB 颜色空间标准</strong>，推荐显示器的显示伽马值为 2.2，并配合 0.45 的编码伽马就可以保证最后伽马曲线之间可以相互抵消（因为 2.2 × 0.45 ≈ 1）。绝大多数的摄像机、PC 和打印机都使用了上述的 sRGB 标准。</p><p>事实上，由于游戏界长期以来都忽视了伽马校正的问题，造成了我们渲染出来的游戏总是暗沉沉的，总是和真实世界不像。由于编码伽马和显示伽马的存在，我们一不小心就可能在非线性空间下进行计算，或是使得输出的图像是非线性的。</p><p>对于输出来说，如果我们直接输出渲染结果而不进行任何处理，在经过显示器的显示伽马处理后，会导致图像整体偏暗，出现失真的状况。使用了线性空间，Unity 会在把像素写入颜色缓冲前进行一次伽马校正，来抵消屏幕的显示伽马的作用，此时得到屏幕亮度才是真正跟像素值成正比的。伽马的存在还会对颜色<strong>混合</strong>造成影响。</p><hr><p>实际上，渲染中非线性输入最有可能的来源就是纹理。为了充分利用存储空间，大多数图像文件都进行了提前的校正，即已经使用了一个编码伽马对像素值编码。但这意味着它们是非线性的，如果我们在 Shader 中直接使用纹理采样值就会造成在非线性空间的计算，使得结果和真实世界的结果不一致。我们在使用多级渐远纹理 mipmaps 时也需要注意。如果纹理存储在非线性空间中，那么在计算多级渐远纹理时就会在非线性空间里计算。由于多级渐远纹理的计算是种线性计算 - 即采样的过程，需要对某个方形区域内的像素取平均值，这样就会得到错误的结果。正确的做法是，我们要把非线性的纹理转换到线性空间后再计算多级渐远纹理。</p><p>如上所说，伽马的存在使得我们很容易得到非线性空间下的渲染结果。在游戏渲染中，我们应该保证所有的输入都被转换到了线性空间下，并在线性空间下进行各种光照计算，最后在输出前通过一个编码伽马进行伽马校正后再输出到颜色缓冲中。Unity 的颜色空间设置就可以满足我们的需求。</p><p>当我们选择<strong>伽马空间</strong>时，实际上就是“放任模式”，不会对 Shader 的输入进行任何处理，即使输入可能是非线性的；也不会对输出像素进行任何处理，这意味着输出的像素会经过显示器的显示伽马转换后得到非预期的亮度，通常表现为整个场景会比较昏暗。</p><p>当选择<strong>线性空间</strong>时，Unity 会把输入纹理设置为 sRGB 模式，在这种模式下，硬件在对纹理进行采样时会自动将其转换到线性空间中；并且，GPU 会在 Shader 写入颜色缓冲前自动进行伽马校正或是保持线性在后面进行伽马校正，这取决于当前的渲染配置：<br>①如果我们开启了 HDR 的话，渲染就会使用一个浮点精度的缓冲。这些缓冲有足够的精度不需要我们进行任何伽马校正，此时所有的混合和屏幕后处理都是在线性空间下进行的。当渲染完成要写入显示设备的后备缓冲区 back buffer 时，再进行一次最后的伽马校正。<br>②如果我们没有使用 HDR，那么 Unity 就会把缓冲设置成 sRGB 格式，这种格式的缓冲就像一个普通的纹理一样，在写入缓冲前需要进行伽马校正，在读取缓冲时需要再进行一次解码操作。如果此时开启了混合（像我们之前的那样），在每次混合时，硬件会首先把之前颜色缓冲中存储的颜色值转换回线性空间中，然后再与当前的颜色进行混合，完成后再进行伽马校正，最后把校正后的混合结果写入颜色缓冲中。这里需要注意，透明通道是不会参与伽马校正的。</p><p>然而，Unity 的线性空间并不是所有平台都支持的，例如，移动平台就无法使用线性空间。此时，我们就需要自己在 Shader 中进行伽马校正。对非线性输入纹理的校正代码通常如下：  </p><pre><code>float3 diffuseCol = pow(tex2D( diffTex, texCoord ), 2.2 );</code></pre><p>在最后输出前，对输出像素值的校正代码通常如下面这样：  </p><pre><code>fragColor.rgb = pow(fragColor.rgb, 1.0/2.2);return fragColor;</code></pre><p>但是，手工对输出像素进行伽马校正会在使用混合时出现问题。这是因为，校正会导致写入颜色缓冲内的颜色是非线性的，这样混合就发生在非线性空间中。一种解决方法是，在中间计算时不要对输出颜色值进行伽马校正，但在最后需要进行一个屏幕后处理操作来对最后的输出进行伽马校正，也就是说我们需要保证伽马校正发生在渲染的最后一步中，但这可能会造成一定的性能损耗。</p><p>若我们有足够多的颜色空间可以利用，不需要为了充分利用存储空间进行伽马编码的工作了。这就是我们下面要讲的 HDR。</p><h3 id="什么是-HDR"><a href="#什么是-HDR" class="headerlink" title="什么是 HDR"></a>什么是 HDR</h3><p><strong>HDR</strong> 是 <strong>High Dynamic Range</strong> 的缩写，即<strong>高动态范围</strong>，与之相对的是<strong>低动态范围 Low Dynamic Range，LDR</strong>。</p><p>通俗来讲，动态范围指的就是最高的和最低的亮度值之间的比值。在真实世界中，一个场景中最亮和最暗区域的范围可以非常大，例如，太阳发出的光可能要比场景中某个影子上的点的亮度要高出几万倍，这些范围远远超过图像或显示器能够显示的范围。</p><p>通常在显示设备使用的颜色缓冲中每个通道的精度为 8 位，意味着我们只能用这 256 种不同的亮度来表示真实世界中所有的亮度，因此，在这个过程中一定会存在一定的精度损失。早期的拍摄设备利用人眼的特点，使用了伽马曲线来对捕捉到的图像进行编码，尽可能充分地利用这些有限的存储空间。</p><p>HDR 使用远远高于 8 位的精度（如 32 位）来记录亮度信息，使得我们可以表示超过 0～1 内的亮度值，从而可以更加精确地反映真实的光照环境。尽管我们最后还是需要把信息转换到显示设备使用的 LDR 内，但中间的计算却可以让我们得到更加真实可信的效果。Nvidia 曾总结过使用 HDR 进行渲染的动机：让亮的物体可以真的非常亮，暗的物体可以真的非常暗，同时又可以看到两者之间的细节。</p><p>使用 HDR 来存储的图像被称为<strong>高动态范围图像 HDRI</strong>。使用了一张 HDRI 图像来作为场景的 Skybox 可以更加真实地反映物体周围的环境，从而得到更加真实的反射效果。不仅如此，HDR 对与光照叠加也有非常重要的作用。如果我们的场景中有很多光源或是光源强度很大，那么一个物体在经过多次光照渲染叠加后最终得到的光照亮度很可能会超过 1。如果没有使用 HDR，这些超过 1 的部分全部会截取到 1，使得场景丢失了很多亮部区域的细节。但如果开启了 HDR，我们就可以保留这些超过范围的光照结果，尽管最后我们仍然需要把它们转换到 LDR 进行显示，但我们可以使用<strong>色调映射 tonemapping</strong> 技术来控制这个转换的过程，从而允许我们最大限度地保留需要的亮度细节。</p><p>HDR 的使用可以允许我们在屏幕后处理中拥有更多的控制权，比如 Bloom 效果。Bloom 效果需要检测屏幕中亮度大于某个阈值的像素，把它们提取出来后进行模糊，再叠加到原图像中。但是，如果不使用 HDR 的话，我们只能使用小于 1 的阈值来提取需要的像素，会造成某些偏白的不希望的区域也会出现泛光的效果。如果我们使用 HDR，我们只需要使用超过 1 的阈值来只提取那些非常亮的区域即可。</p><p>HDR 也有自身的缺点，首先由于使用了浮点缓冲来存储高精度图像，不仅需要更大的显存空间，渲染速度会变慢，除此之外，一些硬件并不支持 HDR。而且一旦使用了 HDR，我们无法再利用硬件的抗锯齿功能。事实上，在 Unity 中如果我们同时打开了硬件的抗锯齿（在 Edit -&gt; Project Settings -&gt; Quality -&gt; Anti Aliasing 中打开）和摄像机的 HDR，Unity 会发出警告来提示我们由于开启了抗锯齿，因此，无法使用 HDR 缓冲。尽管如此，我们可以使用基于屏幕后处理的抗锯齿操作来弥补这一点。</p><p>在 Unity 中使用 HDR 也非常简单，我们可以在 Camera 组件面板中打开 HDR 选项即可。此时，场景就会被渲染到一个 HDR 的图像缓冲中，这个缓冲的精度范围可以远远超过 0～1。最后，我们可以再使用一个色调映射的屏幕后处理脚本来把 HDR 图像转换到 LDR 图像进行显示。详见 Unity 官方手册中的高动态范围渲染一节。</p><h2 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>近年来，Unity 在 Unite 和 SIGGRAPH 等大会上也分享不少关于 PBS 的技术资料，可以在这些地方找到非常丰富的资料。</p>]]></content>
      
      
      <categories>
          
          <category> unity </category>
          
          <category> unity shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> unity </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Unity Shader入门精要》读书笔记（四）</title>
      <link href="/2023/12/19/2023-12-19-UnityShader4/"/>
      <url>/2023/12/19/2023-12-19-UnityShader4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本读书笔记为高级篇的前 4 章，主要内容为屏幕后处理的边缘检测、高斯模糊、Bloom 效果和运动模糊；使用深度法线纹理的屏幕后处理的运动模糊、全局雾效和边缘检测；非真实感渲染的卡通渲染、素描风格；使用噪声的消融、水波、全局雾效效果。<br>读书笔记是对知识的记录与总结，但是对比较熟悉的内容不会再行描述。</p></blockquote><h1 id="第十一章-屏幕后处理效果"><a href="#第十一章-屏幕后处理效果" class="headerlink" title="第十一章 屏幕后处理效果"></a>第十一章 屏幕后处理效果</h1><h2 id="建立一个基本的屏幕后处理脚本系统"><a href="#建立一个基本的屏幕后处理脚本系统" class="headerlink" title="建立一个基本的屏幕后处理脚本系统"></a>建立一个基本的屏幕后处理脚本系统</h2><p><strong>屏幕后处理效果 screen post-processing effects</strong> 通常指在渲染完整个场景得到屏幕图像后，再对图像进行一系列操作，实现各种屏幕特效。使用这种技术，可以为游戏画面添加更多的艺术效果，例如<strong>景深 Depth of Field</strong>、<strong>运动模糊 Motion Blur</strong> 等。</p><p>因此，想要实现屏幕后处理首先要得到渲染后的屏幕图像，即抓取屏幕，Unity 为我们提供了一个方便的接口 <code>OnRenderImage</code> 函数，声明如下：  </p><pre><code>MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)</code></pre><p>Unity 会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，通过函数中的一系列操作后，再把目标渲染纹理，即第二个参数对应的渲染纹理显示到屏幕上。在 OnRenderImage 函数中，通常利用 <code>Graphics.Blit</code> 函数来完成对渲染纹理的处理。它有 3 中函数声明：  </p><pre><code>public static void Blit(Texture src, RenderTexture dest);public static void Blit(Texture src, RenderTexture dest, Material mat, int pass = -1);public static void Blit(Texture src, Material mat, int pass = -1);</code></pre><p>参数 src 即源纹理，参数 dest 为目标纹理，若 dest 为 null 就会直接将结果显示在屏幕上。参数 mat 是我们使用的材质，在这个材质使用的 Unity Shader 里进行各种屏幕后处理操作，而 src 纹理将会被传递给 Shader 中名为 _MainTex 的纹理属性。参数 pass 的默认值为 -1，表示将会依次调用 Shader 内的所有 Pass。否则，只会调用给定索引的 Pass。</p><hr><p>在默认情况下，OnRenderImage 函数会在所有不透明和透明的 Pass 执行完毕后被调用，以便对场景中所有游戏对象都产生影响。但有时，会希望在不透明的 Pass（RenderQueue &lt;= 2500，内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内）执行完毕后立即调用 OnRenderImage 函数，从而不对透明物体产生任何影响。可在 OnRenderImage 函数前添加 <code>ImageEffectOpaque</code> 属性实现这样的目的（见第 12 章，利用深度和法线纹理进行边缘检测从而实现描边效果，但是不希望透明物体也被描边）。</p><hr><p>因此，要在 Unity 中实现屏幕后处理效果，过程通常如下：<br>①在摄像机中添加一个用于屏幕后处理的脚本，用于实现 OnRenderImage 函数；<br>②调用 Graphics.Blit 函数使用特定的 Unity Shader 对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。对于一些复杂的屏幕特效可多次调用 Graphics.Blit 函数对上一步的输出结果做进一步处理。  </p><p>但是，在进行屏幕后处理之前，需要检查一系列条件是否满足，例如当前平台是否支持渲染纹理和屏幕特效，是否支持当前使用的 Unity Shader 等。为此，我们创建了一个用于屏幕后处理效果的基类，在实现各种屏幕特效时，我们只需要继承自该基类，再实现派生类中不同的操作即可。代码如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent (typeof(Camera))</span>] <span class="comment">//屏幕效果需要绑定在某个摄像机中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了提前检查各种资源和条件是否满足，在 Start 函数调用 CheckResources 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResources</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isSupported == <span class="literal">false</span>) &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>) &#123;</span><br><span class="line">            Debug.LogWarning(<span class="string">&quot;This platform does not support image effects or render textures.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>()</span> &#123;</span><br><span class="line">        enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        CheckResources();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为每一个屏幕处理效果通常都需要制定一个 shader 来创建一个用于处理渲染纹理的材质，从而基类中也提供了该方法。该函数首先检查 Shader 的可用性，检查通过后就返回一个使用了该 shader 的材质</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!shader.isSupported) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">            material.hideFlags = HideFlags.DontSave;</span><br><span class="line">            <span class="keyword">if</span> (material)</span><br><span class="line">                <span class="keyword">return</span> material;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调整屏幕的亮度、饱和度和对比度"><a href="#调整屏幕的亮度、饱和度和对比度" class="headerlink" title="调整屏幕的亮度、饱和度和对比度"></a>调整屏幕的亮度、饱和度和对比度</h2><p>准备工作如下：<br>①新建名为 Scene_12_2 的场景，并去掉天空盒子；<br>②导入一张图片（案例图路径：Assets/Textures/Chapter12/Sakura0.jpg），调整图片纹理类型为 Sprite (2D and UI)，并拖拽到场景中，使其生成一个 Sprite；<br>③新建名为 BrightnessSaturationAndContrast 的脚本，并拖拽到相机上；<br>④新建名为 Chapter12-BrightnessSaturationAndContrast 的 Unity Shader；</p><p>BrightnessSaturationAndContrast 脚本代码如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrightnessSaturationAndContrast</span> : <span class="title">PostEffectsBase</span> &#123; <span class="comment">//继承 PostEffectsBase 基类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader briSatConShader; <span class="comment">//声明该效果需要的 shader</span></span><br><span class="line">    <span class="keyword">private</span> Material briSatConMaterial; <span class="comment">//并创建相应的材质</span></span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);</span><br><span class="line">            <span class="keyword">return</span> briSatConMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供调整亮度、饱和度和对比度的参数</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> brightness = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> saturation = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> contrast = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123; <span class="comment">//如果材质不为空，则把参数传递给材质，若不可用，则直接把源图像显示到屏幕上，不做任何处理</span></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Brightness&quot;</span>, brightness);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Saturation&quot;</span>, saturation);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_Contrast&quot;</span>, contrast);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chapter12-BrightnessSaturationAndContrast 的 Unity Shader 代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 12/Brightness Saturation And Contrast&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">//Graphics.Blit 把第一个参数传递给名为 _MainTex 的属性，所以必需声明 _MainTex</span></span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; </span><br><span class="line">        <span class="comment">//下面三个属性的值由脚本传递而得，事实上，这些属性声明可以省略，Properties 中声明属性仅仅是为了显示在材质面板里，但对于屏幕特效来说，使用的材质是临时创建的，不需要在材质面板上调整参数</span></span><br><span class="line">        _Brightness (<span class="string">&quot;Brightness&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">        _Saturation(<span class="string">&quot;Saturation&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">        _Contrast(<span class="string">&quot;Contrast&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">//屏幕后处理实际上是在场景中绘制了一个与屏幕同宽同高的四边形面片，为了防止它对物体产生影响，需要设置相关的渲染状态。关闭深度写入为了防止挡住其他后面被渲染的物体。如果当前 OnRenderImage 函数在所有不透明的 Pass 执行完毕后立刻被调用，不关闭深度写入就会影响后面透明的 Pass 渲染，该设置可以看作是用于屏幕后处理的 shader 的标配</span></span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span>  </span></span><br><span class="line">             </span><br><span class="line">            sampler2D _MainTex;  </span><br><span class="line">            half _Brightness;</span><br><span class="line">            half _Saturation;</span><br><span class="line">            half _Contrast;</span><br><span class="line">              </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用 Unity 内置的 appdata_img 结构体作为顶点着色器的输入，其只包含图像处理时必须的顶点坐标和纹理坐标等变量。屏幕特效使用的顶点着色器通常比较简单，只需要进行必要的顶点变换，把正确的纹理坐标传递给片元着色器，以便对屏幕图像进行正确的采样</span></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed4 renderTex = tex2D(_MainTex, i.uv); <span class="comment">//原屏幕图像采样</span></span><br><span class="line">                </span><br><span class="line">                fixed3 finalColor = renderTex.rgb * _Brightness; <span class="comment">//利用 _Brightness 来调整亮度，亮度调整只需要把原颜色乘以亮度系数即可</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//luminance 亮度值：通过对每个颜色分量乘以一个特定的系数再相加即可得到。我们使用该亮度值创建一个饱和度为 0 的颜色值，并使用 _Saturation 和上一步得到的颜色值进行插值从而得到希望的饱和度颜色</span></span><br><span class="line">                fixed luminance = <span class="number">0.2125</span> * renderTex.r + <span class="number">0.7154</span> * renderTex.g + <span class="number">0.0721</span> * renderTex.b;</span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance, luminance, luminance);</span><br><span class="line">                finalColor = lerp(luminanceColor, finalColor, _Saturation);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//对比度：首先创建对比度为 0 的颜色值（各分量均为 0.5），使用 _Contrast 和上一步得到的颜色值进行插值从而得到最终的处理结果</span></span><br><span class="line">                fixed3 avgColor = fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">                finalColor = lerp(avgColor, finalColor, _Contrast);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, renderTex.a);  </span><br><span class="line">            &#125; </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    Fallback Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>补充：<br>①亮度：很简单，用 _Brightness 对 RGB 进行统一缩放，但各自混合比例不变，保证了颜色不变，但亮度变大。<br>②饱和度：饱和度指色彩的纯净程度，在同一色相中添加白色、黑色或灰色会降低纯度。因为有 Cg 的 Lerp 函数的存在，只要得到饱和度为 0 时的 RGB 值，当 _Saturation &gt; 1 时，就可以增大颜色饱和度。由上面的饱和度概念可推，往一种颜色添加大量黑白灰色，即该颜色的灰度图就是该颜色的饱和度为 0 时的 RGB 值。因此当一个画面饱和度为 0 时，得到的是该画面对应的灰度图。<br>③上述代码的 luminance 值的计算公式就是求 RGB 颜色值对应的灰度值，这个公式是 RGB 转 YUV 的 BT709 明亮度转换公式，YUV 颜色模型起源于解决彩色电视和黑白电视的兼容性问题，其中 Y 值即 Luminance 就是灰阶值。至于三个系数不统一，是因为人眼对 RGB 三原色的敏感程度不同，有兴趣了解色度学（将主观颜色感知和客观物理测量联系的科学）。<br>④对比度：对比度指一个画面显示的 RGB 值最大的像素和最小的像素之间的差值的大小，即最亮与最暗的像素之间的差值为对比度。使用（0.5, 0.5, 0.5）对原 RGB 值进行插值。所以 _Contrast 值越小，画面中像素的 RGB 的值都会越来越接近 0.5，对比度就会越小；值越大，特别是 &gt; 1 时，画面中像素的 RGB 的值都会越来越远离 0.5，对比度就会越大。</p></blockquote><p>将编写好的 Shader 文件拖拽到摄像机 C# 脚本组件的 Bri Sat Con Shader 属性中，调整参数，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/20/mytDJOCMLgZro56.png" width = "70%" height = "70%" alt="图62-  左图：原效果。右图：调整了亮度（值为 1.2）、饱和度（值为 1.5）和对比度（值为 1.1）后的效果"/></div><h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><p>边缘检测是描边效果的一种实现方法，其原理是利用一些边缘检测算子对图像进行<strong>卷积 convolution</strong> 操作。</p><h3 id="什么是卷积"><a href="#什么是卷积" class="headerlink" title="什么是卷积"></a>什么是卷积</h3><p>在图像处理中，卷积操作指的是使用一个<strong>卷积核 kernel</strong> 对一张图像中的每个像素进行一系列操作。卷积核通常是一个四方形网格结构（例如：2x2、3x3的方形区域），该区域内每个方格都有一个权重值。当对图形中的某个像素进行卷积时，我们会把卷积核的中心放置到该像素上，如下图所示，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是该位置的新像素值。</p><div  align="center">  <img src="https://s2.loli.net/2023/12/20/3t2MPVUadi5zWno.png" width = "70%" height = "70%" alt="图63-  卷积核与卷积。使用一个3×3大小的卷积核对一张5×5大小的图像进行卷积操作，当计算图中红色方块对应的像素的卷积结果时，我们首先把卷积核的中心放置在该像素位置，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到新的像素值"/></div><p>卷积操作可用于图像模糊、边缘检测、锐化等效果，例如：均值模糊，可以使用 3x3 的卷积核，核内每个元素的值均为 1/9。</p><h3 id="常见的边缘检测算子"><a href="#常见的边缘检测算子" class="headerlink" title="常见的边缘检测算子"></a>常见的边缘检测算子</h3><p>卷积操作的神奇之处在于选择的卷积核。用于边缘检测的卷积核，也被称为<strong>边缘检测算子</strong>。</p><p>如果相邻像素之间存在差别明显的颜色、亮度、纹理等属性，可以认为他们之间有一条边界，这种相邻像素之间的差异用<strong>梯度 gradient</strong> 来表示，边缘处的梯度绝对值会比较大。基于这样的理解，有几种不同的边缘检测算子被先后提出：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/20/ZrSGUK6ya3WeFJ4.png" width = "70%" height = "70%" alt="图64-  三种常见的边缘检测算子"/></div><p>上图的三种常见的边缘检测算子都包含了 2 个方向的卷积核，分别用于检测水平方向和竖直方向上的边缘信息。边缘检测时，需要对每个像素分别进行一次卷积计算，得到 2 个方向上的梯度值 $\,G_x\,$ 和 $\,G_y\,$，而整体的梯度可按如下公式计算得到：  </p><script type="math/tex; mode=display">G = \sqrt {G_x^2 + G_y^2}</script><p>考虑到性能，有时会用绝对值操作代替开根号操作：  </p><script type="math/tex; mode=display">G = \lvert G_x \rvert + \lvert G_y \rvert</script><p>得到梯度 G 后，可据此判断哪些像素对应了边缘（梯度值越大，越有可能是边缘点）。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>准备工作如下：<br>①新建名为 Scene_12_3 的场景，并去掉天空盒子；<br>②导入一张图片（案例图路径：Assets/Textures/Chapter12/Sakura0.jpg），调整图片纹理类型为Sprite (2D and UI)，并拖拽到场景中，使其生成一个 Sprite；<br>③新建名为 EdgeDetection 的 C#脚本，并拖拽到相机上；<br>④新建名为 Chapter12-EdgeDetection 的 Unity Shader。</p><p>首先是 C# 脚本文件，代码如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetection</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shader edgeDetectShader;</span><br><span class="line">    <span class="keyword">private</span> Material edgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            <span class="keyword">return</span> edgeDetectMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供调整边缘性强度、描边颜色以及背景颜色的参数</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>; <span class="comment">//当其为 0 时，边缘将会叠加在原渲染图像上；当为 1 时，则只会显示边缘，不显示原渲染图像</span></span><br><span class="line">    <span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, edgesOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>, edgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chapter12-EdgeDetection 的 Shader 代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 12/Edge Detection&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _EdgeOnly (<span class="string">&quot;Edge Only&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (<span class="string">&quot;Edge Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (<span class="string">&quot;Background Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;  </span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragSobel</span></span><br><span class="line">            </span><br><span class="line">            sampler2D _MainTex;  </span><br><span class="line">            uniform half4 _MainTex_TexelSize; <span class="comment">//xxx_TexelSize 是 Unity 为开发者提供的访问 xxx 纹理对应的每个纹素的大小（一张 512 × 512 大小的纹理，该值为 1/512）；因为卷积需要对相邻区域内的纹理进行采样，因此需要利用 _Main_TexelSize 来计算各个相邻区域的纹理坐标。</span></span><br><span class="line">            fixed _EdgeOnly;</span><br><span class="line">            fixed4 _EdgeColor;</span><br><span class="line">            fixed4 _BackgroundColor;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                half2 uv[<span class="number">9</span>] : TEXCOORD0; <span class="comment">//维数为 9 的纹理数组，对应算子需求的 9 个纹理坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在顶点着色器中计算采样纹理坐标减少性能消耗。由于从顶点着色器到片元着色器的插值是线性的，因此不会影响纹理坐标的计算结果</span></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                </span><br><span class="line">                half2 uv = v.texcoord;</span><br><span class="line">                o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed <span class="title function_">luminance</span><span class="params">(fixed4 color)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            half <span class="title function_">Sobel</span><span class="params">(v2f i)</span> &#123;</span><br><span class="line">                <span class="type">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>, <span class="comment">//定义了水平方向的卷积核 Gx</span></span><br><span class="line">                                    <span class="number">-2</span>,  <span class="number">0</span>,  <span class="number">2</span>,</span><br><span class="line">                                    <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="type">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="comment">//定义了竖直方向的卷积核 Gy</span></span><br><span class="line">                                    <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">                                    <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span>&#125;;        </span><br><span class="line">                </span><br><span class="line">                half texColor;</span><br><span class="line">                half edgeX = <span class="number">0</span>;</span><br><span class="line">                half edgeY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">0</span>; it &lt; <span class="number">9</span>; it++) &#123;</span><br><span class="line">                    texColor = luminance(tex2D(_MainTex, i.uv[it])); <span class="comment">//依次对 9 个像素进行采样，计算他们的亮度值</span></span><br><span class="line">                    edgeX += texColor * Gx[it]; <span class="comment">//再与 Gx 和 Gy 对应的权重进行相乘，得到各自的梯度值</span></span><br><span class="line">                    edgeY += texColor * Gy[it];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                half edge = <span class="number">1</span> - <span class="built_in">abs</span>(edgeX) - <span class="built_in">abs</span>(edgeY); <span class="comment">//从 1 中减去水平方向和竖直方向的梯度值的绝对值，得到 edge，edge 值越小则表明该位置越可能是一个边缘点</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">fragSobel</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                half edge = Sobel(i); <span class="comment">//调用 Soble 函数计算当前像素的梯度值 edge</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//利用 edge 分别计算了背景为原图和纯色下的颜色值</span></span><br><span class="line">                fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>]), edge);</span><br><span class="line">                fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">                <span class="comment">//利用 _EdgeOnly 在两者之间插值得到最终的像素值</span></span><br><span class="line">                <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">             &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将编写好的 Shader 文件拖拽到 C# 组件的 Edge Detect Shader 属性中，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/20/F1qZG5ioYhjOKmk.png" width = "100%" height = "100%" alt="图65-  左图：原效果。中图：Edges Only 为 0。右图：Edges Only 为 1。"/></div><p>需要注意的是，本节实现的边缘检测仅仅利用了屏幕颜色信息，而在实际的应用中，物体的纹理、阴影等信息都会影响到边缘检测的结果。为了得到更加准确的边缘信息，往往会在屏幕的深度纹理和法线纹理上进行边缘检测，在 第 12 章实现这种方法。</p><h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>常见的使用卷积的模糊有均值模糊和中值模糊。均值模糊使用的卷积核各个元素都相等，且相加等于1，即卷积后得到的像素值是其邻域内各个像素值的平均值。中值模糊，则是选择邻域内所有像素排序后的中值替换掉原颜色。而<strong>高斯模糊</strong>是一个更高级的模糊方式。</p><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>高斯模糊同样利用了卷积计算，它使用的卷积核名为<strong>高斯核</strong>。高斯核是一个正方形大小的滤波核，其中每个元素都是基于下面的高斯方程：  </p><script type="math/tex; mode=display">G(x,y) = \cfrac {1}{2 \pi \sigma ^ 2} e ^ {- \cfrac {x^2 + y^2} {2 \sigma ^2} }</script><p>其中，$\,\sigma\,$ 是标准方差，一般取值为 1；$\,x\,$  和 $\,y\,$ 分别对应了当前位置到卷积核中心的整数距离。要构建高斯核，只需要计算高斯核中各个位置对应的高斯值。为了保证滤波后的图像不会变暗，需要对高斯核中的权重进行归一化，即让每一个权重除以所有权重的和，以保证所有权重的和为 1，因此高斯函数中的 $\,e\,$  前面的系数实际不会对结果有任何影响。</p><p>高斯方程很好地模拟了邻域每个像素对当前处理像素的影响程度 —— 距离越近，影响越大。高斯核的维数越高，模糊程度越大。使用 N x N 的高斯核对图像进行卷积滤波，需要进行 N x N x W x H（W 和 H分别是图像的宽和高）次纹理采样。N 不断增大，采样次数会变得非常巨大。</p><p>为了节省性能，可以把二维高斯函数可以拆分成两个一维函数。使用两个一维的高斯核先后对图像进行滤波，得到的结果和直接使用二位高斯核是一样的，但采样次数只需要 2 x N x W x H。对于一个大小为 5 的一维高斯核，只需要记录 3 个权重值即可，因为左右权重有重复的值。如下图：</p><div  align="center">  <img src="https://s2.loli.net/2023/12/21/XCzRgKkvqG6Q7a5.png" width = "70%" height = "70%" alt="图66-  一个 5×5 大小的高斯核。左图显示了标准方差为 1 的高斯核的权重分布。我们可以把这个二维高斯核拆分成两个一维的高斯核（右图）。"/></div><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>接下来使用上述的 5 x 5 的高斯核对原图像进行高斯模糊。先后调用两个 Pass，第一个 Pass 将会使用竖直方向的一维高斯核对图像进行滤波，第二个 Pass 再使用水平方向的一维高斯核对图像进行滤波，得到最终的目标图像。在现实中还会利用图像缩放来进一步提高性能，通过调整高斯滤波的应用次数来控制模糊程度（次数越多，图像越模糊）。</p><p>准备工作如下：<br>①新建名为 Scene_12_4 的场景，并去掉天空盒子；<br>②导入一张图片（资源路径：Assets/Textures/Chapter12/Sakura1.jpg），调整图片纹理类型为 Sprite (2D and UI)，并拖拽到场景中，使其生成一个 Sprite；<br>③新建名为 GaussianBlur 的 C# 脚本，将脚本拖拽到相机；<br>④新建名为 Chapter12-GaussianBlur 的 Unity Shader。</p><p>GaussianBlur 的 C# 脚本的代码如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GaussianBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader gaussianBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material gaussianBlurMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> gaussianBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>; <span class="comment">//高斯模糊迭代次数</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>; <span class="comment">//模糊范围，计算得到 shader 中的 _BlurSize。_BlurSize 越大，模糊程度越大，但采样数不会受到影响，过大的 _BlueSize 值会造成虚影</span></span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Range(1, 8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>; <span class="comment">//缩放图像降采样的系数，downSample 越大，需要处理的像素数越少，同时也可以进一步提高模糊程度，但过大的 downSample 会造成图像像素化</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 第一个版本：简单的 OnRenderImage 实现，不使用上面 3 个字段。首先利用 RenderTexture.GetTemporary 函数分配一块与屏幕图像大小相同的缓冲区。因为模糊需要调用两个Pass，从而需要使用一块中间缓存来存储第一个 Pass 执行完毕后得到的模糊结果。</span></span><br><span class="line"><span class="comment">//    void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//        if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//            int rtW = src.width;</span></span><br><span class="line"><span class="comment">//            int rtH = src.height;</span></span><br><span class="line"><span class="comment">//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);        </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, buffer, material, 0); //参数为 0，即使用 Shader 中的第一个 Pass（即使用竖直方向的一维高斯核进行滤波）对 src 进行处理，并将结果存储在 buffer中</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(buffer, dest, material, 1); //然后利用第二个 pass 对 buffer 进行处理，返回最终的屏幕图像</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            RenderTexture.ReleaseTemporary(buffer); //调用这个释放之前分配的缓存</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个版本：利用缩放系数对图像进行降采样，从而减少需要处理的像素个数，提高性能</span></span><br><span class="line"><span class="comment">//    void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//        if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//            int rtW = src.width/downSample;</span></span><br><span class="line"><span class="comment">//            int rtH = src.height/downSample;</span></span><br><span class="line"><span class="comment">//            RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span></span><br><span class="line"><span class="comment">//            buffer.filterMode = FilterMode.Bilinear; //声明缓冲区的大小时，使用了小于原屏幕分辨率的尺寸，并将该临时渲染纹理的滤波模式设置为双线性，从而不仅减少需要处理的像素个数，同时更提高了性能，适当的降采样还可以得到更好的模糊效果，但过大的 downSample 会造成图像像素化</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, buffer, material, 0);</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(buffer, dest, material, 1);</span></span><br><span class="line"><span class="comment">//            RenderTexture.ReleaseTemporary(buffer);</span></span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 第三个版本相比第二个版本增加了迭代次数和模糊范围，下面代码显示了如何利用两个临时缓存在迭代之间进行交替的过程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//首先定义第一个缓存 buffer0，并直接把 scr 的图像缩放后存储到 buffer0 中</span></span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">            Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在迭代过程中，定义第二个缓存 buffer1。在执行第一个 Pass 时，输入的是 buffer0，输出的是 buffer1，完毕之后，释放 buffer0，将 buffer1 存储到 buffer0 中，重新分配 buffer1，再调用第二个 Pass，不断重复</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line">            </span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>); <span class="comment">//第一个 Pass</span></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>); <span class="comment">//第二个 Pass</span></span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(buffer0, dest);        <span class="comment">//把结果显示在屏幕上</span></span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chapter12-GaussianBlur 的 Unity Shader 代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 12/Gaussian Blur&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _BlurSize (<span class="string">&quot;Blur Size&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">//第一次使用 CGINCLUDE，该代码不需要包含任何 Pass 语义块，在使用时只需要在 Pass 中直接指定需要使用的顶点着色器和片元着色器函数名即可，类似于 C++ 中的头文件，这样可以避免编写相同的片元着色器</span></span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex;  </span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line">          </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>]: TEXCOORD0; <span class="comment">//因为可以拆分成 2 个大小为 5 的一维高斯核，从而只需要计算 5 个纹理坐标即可</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//竖直方向的顶点着色器代码</span></span><br><span class="line">        v2f <span class="title function_">vertBlurVertical</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//利用与属性 _BlurSize 相乘来控制采样距离。在高斯核维数不变的情况下，_BlurSize 越大，模糊程度越高，但采样数不受到影响</span></span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//水平方向的顶点着色器代码</span></span><br><span class="line">        v2f <span class="title function_">vertBlurHorizontal</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;   </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个 Pass 共用的片元着色器</span></span><br><span class="line">        fixed4 <span class="title function_">fragBlur</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;; <span class="comment">//高斯核的三个不重复的权重</span></span><br><span class="line">            </span><br><span class="line">            fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>]; <span class="comment">//权重和 sum 初始化为当前的像素值乘以它的权重值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据对称性，进行两次迭代，每次迭代包含了两次纹理采样</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++) &#123;</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">                sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>); <span class="comment">//返回滤波结果sum</span></span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义第一个竖直的 Pass</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">//使用 NAME 语义定义了它们的名字，为 Pass 定义名字可以在其他 shader 中直接通过它们的名字来使用该 Pass，而不需要重新写代码</span></span><br><span class="line">            NAME <span class="string">&quot;GAUSSIAN_BLUR_VERTICAL&quot;</span></span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">              </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vertBlurVertical <span class="comment">//告诉 Unity，顶点着色器的代码在 vertBlurVertical 函数中</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragBlur <span class="comment">//告诉 Unity，片元着色器的代码在 fragBlur 函数中</span></span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            NAME <span class="string">&quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span></span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vertBlurHorizontal  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragBlur</span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将编写好的 Shader 文件拖拽到 C# 脚本组件的 Gaussian Blur Shader 属性中，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/21/6IuoeZQXA2YzkGt.png" width = "70%" height = "70%" alt="图67-  左图：原效果。右图：高斯模糊后的效果（Iterations 为 3，Blur Spread 为 0.6，Down Sample 为 2）。"/></div><h2 id="Bloom-效果"><a href="#Bloom-效果" class="headerlink" title="Bloom 效果"></a>Bloom 效果</h2><p>Bloom 特效是游戏中常见的一种屏幕效果，可以模拟真实相机的一种图像效果，它让画面中较亮的区域“扩散”到周围的区域中，产生一种朦胧的效果。</p><p>Bloom 的实现原理非常简单：<br>①根据一个阈值提取出图像中的较亮区域，把它们存储在一张渲染纹理中；<br>②再利用高斯模糊对这张纹理进行模糊处理，模拟光线扩散的效果；<br>③最后与原图像进行混合，得到最终效果。</p><p>准备工作如下：<br>①新建名为 Scene_12_5 的场景，并去掉天空盒子；<br>②导入一张图片（资源图路径：Assets/Textures/Chapter12/Sakura1.jpg），调整图片纹理类型为 Sprite (2D and UI)，并拖拽到场景中，使其生成一个 Sprite；<br>③新建名为 Bloom 的 C# 脚本；<br>④新建名为 Chapter12-Bloom 的 Unity Shader。</p><p>Bloom.cs 的脚本代码如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bloom</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader bloomShader;</span><br><span class="line">    <span class="keyword">private</span> Material bloomMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);</span><br><span class="line">            <span class="keyword">return</span> bloomMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0, 4)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(1, 8)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加 luminanceThreshold 来控制提取较亮的区域时使用的阈值大小。尽管在绝大多数的情况下，图像的亮度值不会超过 1，但如果开启了 HDR，硬件会允许把颜色值存储在一个更高精度范围的缓冲中，此时像素的亮度值可能会超过 1，这里把 luminanceThreshold 的值规定在 [0,4] 中</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 4.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> luminanceThreshold = <span class="number">0.6f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Bloom 建立在高斯模糊之上实现，从而与高斯模糊的代码有大量重复的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold); </span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">            <span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//先使用 Shader 中的第一个 Pass 提取图像中的较亮区域，存储到 buffer0 中</span></span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">            Graphics.Blit(src, buffer0, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//和之前相同的高斯模糊迭代处理，只不过 Pass 对应的是 Shader 的第二个和第三个 Pass</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">                material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line">                </span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0); </span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>); </span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, <span class="number">2</span>);</span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将 buffer0 传递给材质中的 _Bloom 纹理属性，使用第四个 pass 进行最后的混合，并存储到目标渲染纹理 dest 中</span></span><br><span class="line">            material.SetTexture (<span class="string">&quot;_Bloom&quot;</span>, buffer0);</span><br><span class="line">            Graphics.Blit (src, dest, material, <span class="number">3</span>);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chapter12-Bloom 的 Shader 代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 12/Bloom&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Bloom (<span class="string">&quot;Bloom (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//高斯模糊后较亮的区域的输出纹理</span></span><br><span class="line">        _LuminanceThreshold (<span class="string">&quot;Luminance Threshold&quot;</span>, Float) = <span class="number">0.5</span> <span class="comment">//提取较亮区域的阈值</span></span><br><span class="line">        _BlurSize (<span class="string">&quot;Blur Size&quot;</span>, Float) = <span class="number">1.0</span> <span class="comment">//控制不同迭代之间高斯模糊的模糊区域范围</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;        </span><br><span class="line">        sampler2D _Bloom;</span><br><span class="line">        <span class="type">float</span> _LuminanceThreshold;</span><br><span class="line">        <span class="type">float</span> _BlurSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面先定义提取较亮区域需要使用的结构体、顶点着色器和片元着色器</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION; </span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;    </span><br><span class="line"></span><br><span class="line">        v2f <span class="title function_">vertExtractBright</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed <span class="title function_">luminance</span><span class="params">(fixed4 color)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 <span class="title function_">fragExtractBright</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">            fixed val = clamp(luminance(c) - _LuminanceThreshold, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">//采样得到的亮度值减去阈值 _LuminanceThreshold，并把结果截取在 0～1 之间</span></span><br><span class="line">            <span class="keyword">return</span> c * val; <span class="comment">//把该值和愿像素相乘，得到提取后的亮度区域</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义混合亮部图像和原图像时使用的结构体、顶点着色器和片元着色器</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2fBloom</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION; </span><br><span class="line">            half4 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        v2fBloom <span class="title function_">vertBloom</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2fBloom o;</span><br><span class="line">            o.pos = UnityObjectToClipPos (v.vertex);</span><br><span class="line">            <span class="comment">//定义两个纹理坐标，并存储在同一个类型为 half4 的变量 uv 中，xy 对应 _MainTex，即原图像的纹理坐标；zw 对应 _Bloom，即对应模糊后的较亮区域的纹理坐标</span></span><br><span class="line">            o.uv.xy = v.texcoord;</span><br><span class="line">            o.uv.zw = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//平台差异化处理的代码</span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP            </span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0.0</span>)</span><br><span class="line">                o.uv.w = <span class="number">1.0</span> - o.uv.w;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                            </span><br><span class="line">            <span class="keyword">return</span> o; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 <span class="title function_">fragBloom</span><span class="params">(v2fBloom i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义 Bloom 效果需要的 4 个 pass</span></span><br><span class="line">        Pass &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vertExtractBright  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragExtractBright  </span></span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二、第三个 pass 使用上一节的高斯模糊定义的两个 pass，该是通过 UsePass 语义来指明所使用的 pass，注意：Unity 内部会把 shader 名字全部转换为大写字母，从而使用时需要大写字母</span></span><br><span class="line">        </span><br><span class="line">        UsePass <span class="string">&quot;Unity Shaders Book/Chapter 12/Gaussian Blur/GAUSSIAN_BLUR_VERTICAL&quot;</span></span><br><span class="line">        </span><br><span class="line">        UsePass <span class="string">&quot;Unity Shaders Book/Chapter 12/Gaussian Blur/GAUSSIAN_BLUR_HORIZONTAL&quot;</span></span><br><span class="line">        </span><br><span class="line">        Pass &#123;  </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vertBloom  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragBloom  </span></span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将编写好的 Shader 文件拖拽到 C# 脚本组件的 Bloom Shader 属性中，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/21/GnsWkg5EzRAZoX4.png" width = "70%" height = "70%" alt="图68-  左图：原效果。右图：Bloom 处理后的效果（Iterations 为 4，Blur Spread 为 1.5，Down Sample 为 4，Luminance Threshold 为 0.1）。"/></div><h2 id="运动模糊"><a href="#运动模糊" class="headerlink" title="运动模糊"></a>运动模糊</h2><p>运动模糊是真实世界中的摄像机的一种效果。摄像机曝光时如果拍摄场景发生了变化，就会产生模糊的画面。由于在计算机生成的图像中，不存在在曝光这一物理现象，渲染出来的图像往往都是棱角分明，缺少运动模糊。  </p><p>运动模糊的实现有多种方法：<br>①<strong>累积缓存 accumulation buffer</strong>：混合多张连续图像。当物体快速移动产生多张图像后，我们取它们之间的平均值作为最后的运动模糊图像。这种暴力的方法对性能消耗很大，想要获取多张帧图像意味着我们需要在同一帧里渲染多次场景。<br>②<strong>速度缓存 velocity buffer</strong>：这个缓存中存储了各个像素当前的运动速度，然后利用该值来觉得模糊的方向和大小。</p><p>本节中，我们将使用类似于累积缓存的方法来实现运动模糊。我们不需要在一帧中把场景渲染多次，但需要保存之前的渲染结果，不断把当前的渲染图像叠加到之前的渲染图像中，从而产生一种运动轨迹的视觉效果。这种方法与原始的利用累计缓存的方法相比性能更好，但模糊效果可能略有影响。</p><p>准备工作如下：<br>①新建名为 Scene_12_6 的场景，并去掉天空盒子；<br>②往场景里放置几个立方体和平面；<br>③新建名为 Translating 的 C# 脚本，并拖拽到相机，用于控制相机围绕目标物体旋转；<br>④新建名为 MotionBlur 的 C# 脚本，并把脚本拖拽到相机；<br>⑤新建名为 Chapter12-MotionBlur 的 Unity Shader。</p><p>Translating.cs 的代码如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Translating</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">10.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Vector3 startPoint = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector3 endPoint = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> Vector3 lookAt = Vector3.zero;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> pingpong = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 curEndPoint = Vector3.zero;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.position = startPoint;</span><br><span class="line">        curEndPoint = endPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.position = Vector3.Slerp(transform.position, curEndPoint, Time.deltaTime * speed);</span><br><span class="line">        transform.LookAt(lookAt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pingpong)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Vector3.Distance(transform.position, curEndPoint) &lt; <span class="number">0.001f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                curEndPoint = Vector3.Distance(curEndPoint, endPoint) &lt; Vector3.Distance(curEndPoint, startPoint) ? startPoint : endPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MotionBlur.cs 的代码如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MotionBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shader motionBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material motionBlurMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> motionBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义运动模糊在混合图像时使用的模糊参数，并限定范围值，blurAmount 越大，运动拖尾越明显</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 0.9f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurAmount = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个RenderTexture类型的变量，并且保存之前图像叠加的结果</span></span><br><span class="line">    <span class="keyword">private</span> RenderTexture accumulationTexture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在该脚本不运行时，即调用 OnDisable 函数时，立即销毁 accumulationTexture。保证下一次开始应用运动模糊时重新叠加图像</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span> &#123;</span><br><span class="line">        DestroyImmediate(accumulationTexture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断用于混合图像的 accumulationTexture 是否满足条件：不为空且与当前的屏幕分辨率相等</span></span><br><span class="line">            <span class="keyword">if</span> (accumulationTexture == <span class="literal">null</span> || accumulationTexture.width != src.width || accumulationTexture.height != src.height) &#123;</span><br><span class="line">                DestroyImmediate(accumulationTexture);</span><br><span class="line">                accumulationTexture = <span class="keyword">new</span> RenderTexture(src.width, src.height, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// HideAndDontSave 表示该变量不会显示在Hierarchy，也不会保存到场景中</span></span><br><span class="line">                accumulationTexture.hideFlags = HideFlags.HideAndDontSave;</span><br><span class="line">                Graphics.Blit(src, accumulationTexture);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用 accumulationTexture.MarkRestoreExpected() 来表示需要进行一个渲染纹理的恢复操作，恢复操作指发生在纹理到渲染而该纹理又没有被提前清空或销毁的情况下。在本例中每次调用 OnRenderImage 都需要把当前帧图像和 accumulationTexture 中的图像混合，accumulationTexture 不需要提前清空，因为保存了之前的混合结果</span></span><br><span class="line">            accumulationTexture.MarkRestoreExpected();</span><br><span class="line"></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurAmount&quot;</span>, <span class="number">1.0f</span> - blurAmount);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, accumulationTexture, material);</span><br><span class="line">            Graphics.Blit (accumulationTexture, dest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chapter12-MotionBlur.shader 的代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 12/Motion Blur&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _BlurAmount (<span class="string">&quot;Blur Amount&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex; </span><br><span class="line">        fixed _BlurAmount;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;   </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义两个片元着色器，一个用于更新渲染纹理的 RGB 通道部分，一个用于更新渲染纹理的 A 通道部分。RGB 通道的 shader 对当前图像进行采样，并将其 A 通道设置为 _BlurAmount，以便可以在后面使用它的透明通道进行混合。A 通道直接返回采样结果，该只是为了维护渲染纹理的透明通道，不让其收到混合时使用的透明度值的影响</span></span><br><span class="line">        fixed4 <span class="title function_">fragRGB</span> <span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        half4 <span class="title function_">fragA</span> <span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新渲染纹理的 RGB 通道的 Pass，利用 A 通道来混合图像，但不希望该 A 通道写入渲染纹理</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ColorMask RGB</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragRGB  </span></span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新 A 通道的 Pass</span></span><br><span class="line">        Pass &#123;   </span><br><span class="line">            Blend One Zero</span><br><span class="line">            ColorMask A</span><br><span class="line">                   </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragA</span></span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Chapter12-MotionBlurShader 文件拖拽到脚本的 Motion Blur Shader 属性上，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/23/nQmI5FfOdJ9g3k7.gif" width = "70%" height = "70%" alt="图69-  运动模糊后的效果。"/></div><h1 id="第十二章-使用深度和法线纹理"><a href="#第十二章-使用深度和法线纹理" class="headerlink" title="第十二章 使用深度和法线纹理"></a>第十二章 使用深度和法线纹理</h1><p>在前一章节，学习的屏幕后处理效果都只是在屏幕颜色图像上进行各种操作来实现的。然而，很多时候我们不仅需要当前屏幕的颜色信息，还希望得到深度和法线信息。比如，在进行边缘检测时，直接利用颜色信息会使检测到的边缘信息受物体纹理和光照等外部因素的影响，得到很多不需要的边缘点。一种更好的方法是，我们可以在深度纹理和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。</p><h2 id="获取深度和法线纹理"><a href="#获取深度和法线纹理" class="headerlink" title="获取深度和法线纹理"></a>获取深度和法线纹理</h2><h3 id="背后的原理"><a href="#背后的原理" class="headerlink" title="背后的原理"></a>背后的原理</h3><p>深度纹理实际就是一张渲染纹理，里面存储的像素值不是颜色值，而是一个高精度的深度值。由于被存储在一张纹理中，深度纹理的深度值范围是 [0, 1]，而且通常是非线性分布的。</p><p><strong>深度值来自于顶点变换后得到的归一化的设备坐标 Normalized Device Coordinates, NDC 的 z 分量</strong>。一个模型要想最终被绘制在屏幕上，需要把它的顶点从模型空间变换到齐次裁剪坐标系下，通过在顶点着色器中乘以 MVP 矩阵变换得到的。在变换到最后一步，需要使用一个投影矩阵来变换顶点，而透视投影的投影矩阵就是非线性的（正交投影的投影矩阵是线性的）。</p><blockquote><p>回忆一下：顶点着色器阶段要把模型空间一步步转换到应用透视裁剪矩阵（或者正交）后的变换结果，合起来即 MVP 矩阵变换。而齐次除法则是底层硬件进行的，得到归一化的设备坐标。OpenGL 中 NDC 的 z 分量范围在 [-1, 1] 之间，而在 DirectX 中，z 分量在 [0, 1] 之间。</p></blockquote><p>在得到 NDC 之后，深度纹理中的像素值就可以得到了。NDC 的 z 分量范围在 [-1, 1] 之间，为了让这些值能够存储到一张图上，需要对其进行映射（d 对应了深度纹理中的像素值）：  </p><script type="math/tex; mode=display">d = 0.5 \cdot z_{NDC} + 0.5</script><hr><p>在 Unity 中，深度纹理可以直接来自于真正的深度缓存，也可以是由一个单独的 Pass 渲染而得，这取决于使用的渲染路径和硬件。<br>①当使用延迟渲染路径时，因为延迟渲染会把深度信息渲染到 G-buffer 中。<br>②当无法直接获取深度缓存时，深度和法线纹理是通过一个渲染。具体实现是：Unity 会使用着色器替换 Shader Replacement 技术选择那些渲染类型（即 SubShader 的 RenderType 标签）为 Opaque 的物体，判断它们使用的渲染队列是否小于等于 2500（内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内），如果满足条件，就把它渲染到深度和法线纹理中。因此，要想让物体能够出现在深度和法线纹理中，就<strong>必须在 Shader 中设置正确的 RenderType 标签</strong>。</p><p>在 Unity 中，我们可以选择让一个摄像机生成一张深度纹理或是一张深度 + 法线纹理。<br>①当只需要一张单独的深度纹理时，Unity 会直接获取深度缓存或是按之前讲到的着色器替换技术，选取需要的不透明物体，并使用它投射阴影时使用的 Pass （即 LightMode 设置为 ShaowCaster 的 Pass）来得到深度纹理。如果 Shader 中不包含这样一个 Pass，那么这个物体就不会出现在深度纹理中（当然，它也不能向其他物体投射阴影）。深度纹理的精度通常是 24 位或 16 位，这取决于使用的深度缓存的精度。<br>②如果选择生成一张深度 + 法线纹理，Unity 会创建一张和屏幕分辨率相同、 精度为 32 位（每个通道为 8 位）的纹理，其中观察空间下的法线信息会被编码进纹理的 R 和 G 通道，而深度信息会被编码进 B 和 A 通道。法线信息的获取在延迟渲染中是非常容易得到的，Unity 只需要合并深度和法线缓存即可。而在前向渲染中，默认情况下是不会去创建法线缓存的，因此 Unity 底层使用了一个单独的 Pass 把整个场景再次渲染一遍来完成。这个 Pass 被包含在 Unity 的内置的一个 Unity Shader 中，我们可以在内置的 build_shaders-xxx/DefaultResourcesExtra/Internal-DepthNormalsTexture.shader 文件中找到这个用于渲染深度和法线信息的的 Pass。</p><h3 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h3><p>在 Unity 中，首先获取深度纹理需要通过脚本中设置摄像机的 depthTextureMode：</p><pre><code>camera.depthTextureMode = DepthTextureMode.Depth;</code></pre><p>一旦设置好了上面的摄像机模式后，我们就可以在 Shader 中通过声明 <code>_CameraDepthTexture</code> 变量来访问它。</p><p>同理，如果想要获取深度 + 法线纹理，我们需要在代码中这样设置：</p><pre><code>camera.depthTextureMode = DepthTextureMode.DepthNormals;</code></pre><p>然后在 Shader 中通过声明 <code>_CameraDepthNormalsTexture</code> 来访问它。</p><p>我们还可以组合这些模式，让一个摄像机同时产生一张深度和深度 + 法线纹理：  </p><pre><code>camera.depthTextureMode |= DepthTextureMode.Depth;camera.depthTextureMode |= DepthTextureMode.DepthNormals;</code></pre><hr><p>在 Unity 5 中，我们还可以在摄像机的 Camera 组件上看到当前摄像机是否需要渲染深度或深度 + 法线纹理，当在 Shader 中访问到深度纹理 _CameraDepthTexture 后，我们就可以使用当前像素的纹理坐标对它进行采样。绝大多数情况下，我们直接使用 <code>tex2D</code> 函数采样即可，但在某些平台上，我们需要一些特殊处理。Unity 为我们提供了一个统一的宏 <code>SAMPLE_DEPTH_TEXTURE</code>，用来处理这些由于平台差异造成的问题。而我们只需要在 Shader 中使用 SAMPLE_DEPTH_TEXTURE 宏对深度纹理进行采样，得到深度值，例如：</p><pre><code>float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);</code></pre><p>其中，i.uv 是一个 float2 类型的变量，对应了当前像素的纹理坐标。类似的宏还有 <code>SAMPLE_DEPTH_TEXTURE_PROJ</code> 和 <code>SAMPLE_DEPTH_TEXTURE_LOD</code>。</p><p><code>SAMPLE_DEPTH_TEXTURE_PROJ</code> 宏同样接收两个参数 – 深度纹理和一个 float3 或 float4 类型的纹理坐标，它内部使用了 tex2Dproj 这样的函数进行纹理采样，纹理坐标的前两个分量首先会除以最后一个分量，再进行纹理采样。如果提供了第四个分量，还会进行一次比较，通常用于阴影的实现中。第二个参数通常是由顶点着色器输出插值而得的屏幕坐标。例如：  </p><pre><code>float d = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTetxure, UNITY_PROJ_COORD(i.scrPos));</code></pre><p>其中，i.scrPos 是在顶点着色器中通过调用 ComputeScreenPos(o.pos) 得到的屏幕坐标，上述这些宏的定义都可以在 Unity 内置的 HLSLSupport.cingc 文件中找到。</p><blockquote><p>ComputeScreenPos(o.pos) 得到是一个未进行齐次除法的“假视口坐标”，SAMPLE_DEPTH_TEXTURE_PROJ 宏使用了  tex2Dproj 函数将 i.scrPos 齐次除法后得到真正的视口坐标，再进行采样。而 UNITY_PROJ_COORD 返回一个适合投影纹理读取的纹理坐标，在大多数平台上，它直接返回给定值。</p></blockquote><hr><p>之前讲过，通过纹理采样得到的深度值，这些深度值往往是非线性的，这种非线性来自于透视投影使用的裁剪矩阵。然而，在我们的计算过程中通常是需要线性的深度值，也就是说，我们需要把投影后的深度值变换到线性空间下，例如视角空间（观察空间）下的深度值。下面以透视投影为例，推导如何由深度纹理的深度信息倒推顶点变换回到视角空间下的深度值：  </p><p>第三章中讲过，当我们使用透视投影的裁剪矩阵 $\,P_{clip}\,$ 对观察空间下的一个顶点进行变换后，裁剪空间下顶点的 z 和 w 分量为：  </p><script type="math/tex; mode=display">z_{clip} = - z_{view} \cfrac {Far + Near}{Far - Near} - \cfrac {2 \cdot Far \cdot Near}{Far - Near}</script><script type="math/tex; mode=display">w_{clip} = - z_{view}</script><p>然后通过齐次除法得到 NDC 下的 z 分量：  </p><script type="math/tex; mode=display">z_{ndc} = \cfrac {z_{clip}} {w_{clip}} = \cfrac {Far + Near}{Far - Near} + \cfrac {2 \cdot Far \cdot Near}{(Far - Near) \cdot z_{view} }</script><p>在本章最前面提到，深度纹理的深度值是 NDC 的 z 分量映射而得的：  </p><script type="math/tex; mode=display">d = 0.5 \cdot z_{NDC} + 0.5</script><p>由上面公式可以反向推导出 $\,z_{view}\,$ ：  </p><script type="math/tex; mode=display">z_{view} = \cfrac {1} { \cfrac { Far - Near }{ Far \cdot Near } d - \cfrac { 1 }{ Near } }</script><p>由于在 Unity 中使用的观察空间中，摄像机正向对应的 z 值均为负值，因此为了得到深度值的正数表示，我们需要对上面的结果取反，最后得到的结果如下：</p><script type="math/tex; mode=display">z_{view}' = \cfrac {1} { \cfrac { Near - Far }{ Near \cdot Far } d + \cfrac { 1 }{ Near } }</script><p>它的取值范围就是视锥体深度范围，即 [Near, Far]。如果我们想得到范围在 [0, 1] 之间的深度值，只需要把上面的结果除以 Far 即可。这样，0 就表示该点与摄像机位于同一位置，1 表示该点位于视锥体的远裁剪平面上，结果如下：</p><script type="math/tex; mode=display">z_{01} = \cfrac {1} { \cfrac { Near - Far }{ Near } d + \cfrac { Far }{ Near } }</script><p>幸运的是，Unity 提供了两个辅助函数来为我们进行上述的计算过程 —— <code>LinearEyeDepth</code> 和 <code>Linear01Depth</code>。<br>①<code>LinearEyeDepth</code> 负责把深度纹理的采样结果转换到观察空间下的深度值，也就是上面的 $\,z_{view}’\,$ ；<br>②<code>Linear01Depth</code> 则返回一个范围在 [0, 1] 的线性深度值，也就是上面得到的 $z_{01}$。<br>这两个函数内置使用了内置的 <code>_ZBufferParams</code> 变量来得到远近裁剪平面的距离。</p><hr><p>如果我们需要获取深度 + 法线纹理，可以直接使用 tex2D 函数对 _CameraDepthNormalsTexture 进行采样，得到里面存储的深度和法线信息。Unity 提供了辅助函数来为我们对这个采样结果进行解码，从而得到深度值和法线方向。这个函数是 <code>DecodeDepthNormal</code>，它在 UnityCG.cginc 被定义：  </p><pre><code>inline void DecodeDepthNormal(float4 enc, out float depth, out float3 normal)&#123;    depth = DecodeFloatRG(enc.zw);    normal = DecodeViewNormalStereo(enc);&#125;</code></pre><p><code>DecodeDepthNormal</code> 的第一个参数是对深度 + 法线纹理的采样结果，这个采样结果是 Unity 对深度和法线信息编码后的结果，它的 xy 分量存储的是观察空间下的法线信息，而深度信息被编码进了 zw 分量。通过调用 DecodeDepthNormal 函数对采样结果解码后，我们就可以得到解码后的深度值和法线，这个深度值是范围在 [0, 1] 的线性深度值（<strong>这和单独的深度纹理中存储的深度值不同</strong>），得到的法线则是观察空间下的法线方向。同样，我们也可以通过调用 DecodeFloatRG 和 DecodeViewNormalStereo 来解码 + 深度法线纹理中的深度和法线信息。</p><h3 id="查看深度和法线纹理"><a href="#查看深度和法线纹理" class="headerlink" title="查看深度和法线纹理"></a>查看深度和法线纹理</h3><p>可以使用帧调试器查看摄像机生成的深度纹理和深度+法线纹理，图片这里不放出了，在 Camera Render 事件中的 UpdateDepthTexture 和 UpdateDepthNormalsTexture 事件中。</p><p>帧调试器看到的深度纹理是非线性空间的深度值，而深度+法线纹理都是由 Unity 编码后的结果。有时线性空间下的深度信息或解码后的法线方向会更加有用，此时可在片元着色器中做转换或解码逻辑：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">\\使用类似代码来输出线性深度值</span><br><span class="line"><span class="built_in">float</span>  depth  =  SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,  i.uv);</span><br><span class="line"><span class="built_in">float</span>  linearDepth  =  Linear01Depth(depth);</span><br><span class="line"><span class="keyword">return</span>  fixed4(linearDepth,  linearDepth,  linearDepth,  <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">\\或是输出解码后的法线方向</span><br><span class="line">fixed3  normal  =  DecodeViewNormalStereo(tex2D(_CameraDepthNormalsTexture,  i.uv).xy);</span><br><span class="line"><span class="keyword">return</span>  fixed4(normal  ＊  <span class="number">0.5</span>  +  <span class="number">0.5</span>,  <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>查看深度纹理时，如果画面几乎是全黑或全白时，可以将相机的远裁剪平面的距离（Unity 默认为1000）调小，使之刚好覆盖场景的所在区域即可。若裁剪平面的距离过大，会导致距离相机较近的物体会被映射到非常小的深度值，导致看起来全黑（场景为封闭区域比较常见）；相反，若场景为开放区域，物体距离相机较远，则会导致画面几乎全白。</p><h2 id="再谈运动模糊"><a href="#再谈运动模糊" class="headerlink" title="再谈运动模糊"></a>再谈运动模糊</h2><p>上一章学习了如何混合多张屏幕图像来模拟运动模糊的效果。而应用更加广泛的技术则是使用<strong>速度映射图</strong>。速度映射纹理中存储每个像素的速度，基于这个速度决定模糊的方向和大小。</p><p><strong>《GPU Gems3》</strong> 在第 27 章(<a href="https://developer.nvidia.cn/gpugems/gpugems3/part-iv-image-effects/chapter-27-motion-blur-post-processing-effect">https://developer.nvidia.cn/gpugems/gpugems3/part-iv-image-effects/chapter-27-motion-blur-post-processing-effect</a>) 中介绍了一种生成速度映射图的方法。这种方法利用深度纹理在片元着色器中为每个像素计算其在世界空间下的位置，这是通过使用当前的观察 * 投影矩阵的逆矩阵对 NDC 下的顶点坐标进行变换得到的。当得到世界空间下的顶点坐标后，我们使用前一帧的观察 * 投影矩阵得到该位置在前一帧中的 NDC 坐标。我们计算前一帧和当前帧的位置差，生成该像素的速度。优点是可以在一个屏幕后处理步骤中完成整个效果的模拟，但缺点是需要在片元着色器中进行两次矩阵乘法的操作，对性能有所影响。</p><p>为了使用深度纹理模拟运动模糊，需要进行如下准备工作：<br>①新建名为 Scene_13_2 的场景，并关闭天空盒子；<br>②搭建测试运动模糊的场景，放置 3 面墙，4 个立方体；<br>③将 Translating.cs 脚本拖拽给摄像机，让其在场景中不断运动；<br>④新建名为 MotionBlurWithDepthTexture.cs 脚本，并拖拽给相机；<br>⑤新建名为 Chapter13-MotionBlurWithDepthTexture 的 Unity Shader；</p><p>MotionBlurWithDepthTexture.cs 脚本的 C# 代码如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MotionBlurWithDepthTexture</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Shader motionBlurShader;</span><br><span class="line">    <span class="keyword">private</span> Material motionBlurMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);</span><br><span class="line">            <span class="keyword">return</span> motionBlurMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本节需要得到摄像机的视角和投影矩阵，定义一个 Camera 变量获取脚本所在的摄像机组件</span></span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;        </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义运动模糊时模糊图像大小的参数</span></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurSize = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个变量来保存上一帧摄像机的视角 × 投影矩阵</span></span><br><span class="line">    <span class="keyword">private</span> Matrix4x4 previousViewProjectionMatrix;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        <span class="comment">//为了获取摄像机的深度纹理，在 OnEnable 函数中设置摄像机的状态</span></span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line"></span><br><span class="line">        previousViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, blurSize);</span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_PreviousViewProjectionMatrix&quot;</span>, previousViewProjectionMatrix); <span class="comment">//设置矩阵参数并赋给 shader 中对应的参数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用 camera.projectionMatrix 和 camera.worldToCameraMatrix 分别获得当前摄像机的视角矩阵和投影矩阵</span></span><br><span class="line">            Matrix4x4 currentViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;</span><br><span class="line">            <span class="comment">//取逆得到当前帧的视角*投影矩阵的逆矩阵</span></span><br><span class="line">            Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;</span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_CurrentViewProjectionInverseMatrix&quot;</span>, currentViewProjectionInverseMatrix);</span><br><span class="line">            previousViewProjectionMatrix = currentViewProjectionMatrix;        <span class="comment">//将未取逆的结果存储到 previousViewProjectionMatrix 以便在下一帧时传递给材质。</span></span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);        <span class="comment">//若有material，则混合；若无则输出原图</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chapter13-MotionBlurWithDepthTexture 的 Shader 代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 13/Motion Blur With Depth Texture&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//输入的渲染纹理</span></span><br><span class="line">        _BlurSize (<span class="string">&quot;Blur Size&quot;</span>, Float) = <span class="number">1.0</span> <span class="comment">//脚本中模糊图像的控制参数</span></span><br><span class="line">        <span class="comment">//我们没有声明 _PreviousViewProjectionMatrix 和 _CurrentViewProjectionInverseMatrix 属性，是因为 Unity 没有提供矩阵的属性，但是仍然可以在 CG 代码块中定义这些矩阵</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        sampler2D _CameraDepthTexture;</span><br><span class="line">        float4x4 _CurrentViewProjectionInverseMatrix;</span><br><span class="line">        float4x4 _PreviousViewProjectionMatrix;</span><br><span class="line">        half _BlurSize;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">            half2 uv_depth : TEXCOORD1; <span class="comment">//对深度纹理采样的纹理坐标变量</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="type">float</span> d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth); <span class="comment">//对深度纹理进行采样得到该像素的深度缓冲值</span></span><br><span class="line">            </span><br><span class="line">            float4 H = float4(i.uv.x * <span class="number">2</span> - <span class="number">1</span>, i.uv.y * <span class="number">2</span> - <span class="number">1</span>, d * <span class="number">2</span> - <span class="number">1</span>, <span class="number">1</span>);    <span class="comment">//d 是 NDC 坐标映射而来，若要构建像素的 NDC 坐标 H，需要把这个深度值重新映射回 NDC，使用原映射的反函数，得到范围在 [-1, 1] 的 NDC 坐标。而渲染纹理的 uv 就是范围在 [0, 1] 的视口坐标，NDC 是范围在 [-1, 1] 的视口坐标，也需要映射回去</span></span><br><span class="line">            float4 D = mul(_CurrentViewProjectionInverseMatrix, H); <span class="comment">//逆矩阵回推</span></span><br><span class="line">            float4 worldPos = D / D.w; <span class="comment">//将结果除以 w 分量得到世界空间下的坐标表示 worldPos，这里除是因为 NDC 是被齐次除法后的坐标，需要乘回去，而经过逆矩阵回推的 D 的 w 分量，因为 H 的 w 分量为 1，逆矩阵会使 D 的 w 分量包含齐次除法的信息，而且这个值应该是齐次除法值的倒数，所以是除不是乘（可以尝试推导）</span></span><br><span class="line"></span><br><span class="line">            float4 currentPos = H; <span class="comment">//该像素现在的 NDC 坐标</span></span><br><span class="line">             </span><br><span class="line">            float4 previousPos = mul(_PreviousViewProjectionMatrix, worldPos); <span class="comment">//使用前一帧的视角 × 投影矩阵对它进行变换，得到前一帧在 NDC 下的坐标 previousPos </span></span><br><span class="line">            previousPos /= previousPos.w; <span class="comment">//齐次除法得到前一帧 NDC 的坐标</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//使用前一帧和当前帧的 NDC 的视口坐标下的位置差</span></span><br><span class="line">            float2 velocity = (currentPos.xy - previousPos.xy) / <span class="number">2.0f</span>;</span><br><span class="line">            </span><br><span class="line">            float2 uv = i.uv;</span><br><span class="line">            float4 c = tex2D(_MainTex, uv);</span><br><span class="line"></span><br><span class="line">            uv += velocity * _BlurSize;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++, uv += velocity * _BlurSize) &#123;</span><br><span class="line">                float4 currentColor = tex2D(_MainTex, uv); <span class="comment">//使用速度值对像素进行偏移后进行采样</span></span><br><span class="line">                c += currentColor;</span><br><span class="line">            &#125;</span><br><span class="line">            c /= <span class="number">3</span>; <span class="comment">//取平均值</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fixed4(c.rgb, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义模糊所需要的Pass</span></span><br><span class="line">        Pass &#123;      </span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">                    </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把该脚本拖拽到摄像机的 MotionBlurWithDepthTexture.cs 脚本中的 Motion Blur Shader 参数中，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/25/Jp5ENyLDY2o1TBI.gif" width = "70%" height = "70%" alt="图70-  运用速度映射图的运动模糊后的效果。"/></div><p>注意：本节实现的运动模糊只适用于场景静止，摄像机运动的情况，因为只考虑了摄像机的运动。如果想要对快速移动的物体产生运动模糊后的效果，就需要更加精确的速度映射图，可以在 Unity 的 ImageEffect 包中找到更多的运动模糊的实现方法。</p><h2 id="全局雾效"><a href="#全局雾效" class="headerlink" title="全局雾效"></a>全局雾效</h2><p><strong>雾效 Fog</strong>是游戏里经常使用的一种效果。Unity 内置的雾效可以产生基于距离的线性或指数雾效。然而，想要在自己编写的顶点/片元着色器中实现这种雾效，我们需要在 Shader 中添加 <code>#paragma multi_compile_fog</code> 指令，同时还需要相关的内置宏，例如 UNITY_FOG_COORDS、UNITY_TRANSFER_FOG 和 UNITY_APPLY_FOG 等。这种方法的缺点在于，我们不仅需要为场景中所有物体添加相关的渲染代码，而且能够实现的效果也非常有限。我们需要对雾效进行一些个性化操作时，例如使用基于高度的雾效等，仅仅使用 Unity 内置的雾效就变得不再可行。</p><p>在本节中，我们将会学习一种基于屏幕后处理的全局雾效的实现。使用这种方法，我们不需要更改场景内渲染到物体所使用的 Shader 代码，而仅仅依靠一次屏幕后处理的步骤即可。这种方法的自由性很高，我们可以方便地模拟各种雾效，例如均匀的雾效、基于距离的线性/指数雾效、基于高度的雾效等。</p><p>基于屏幕后处理的全局雾效的关键是，根据深度纹理来重建每个像素在世界空间下的位置。我们在模拟运动模糊时已经实现了这个要求，即构建出当前像素的 NDC 坐标，再通过当前摄像机中的视角 * 投影矩阵的逆矩阵来得到世界空间下的像素坐标，但是，这样的实现需要在片元着色器中进行矩阵乘法的操作，而这通常会影响游戏性能。</p><p>本节中，我们将会学习一个快速从深度纹理中重构世界坐标的方法。这种方法首先对图像空间下的视锥体射线（从摄像机出发，指向图像上的某点的射线）进行插值，这条射线存储了该像素在世界空间下到摄像机的方向信息。然后，我们把该射线和线性化后的观察空间下的深度值相乘，再加上摄像机的世界位置，就可以得到该像素在世界空间下的位置。当我们得到世界坐标后，就可以轻松的使用各个公式来模拟全局雾效了。</p><h3 id="重建世界坐标"><a href="#重建世界坐标" class="headerlink" title="重建世界坐标"></a>重建世界坐标</h3><p>坐标系中的一个顶点坐标可以通过它相对于另一个顶点坐标的偏移量来求得。重建像素的世界坐标也是基于这种思想。我们只需要知道摄像机在世界空间下的位置，以及世界空间下该像素相对于摄像机的偏移量，把它们相加就可以得到该像素的世界坐标：  </p><pre><code>float4 worldPos = _WorldSpaceCamearaPos + linearDepth * interpolatedRay;</code></pre><p>其中，<strong>_WorldSpaceCamearaPos</strong> 是摄像机在世界空间下的位置，这可以由 Unity 的内置变量直接访问得到。而 linearDepth <em> interpolatedRay 则可以计算得到该像素相对于摄像机的偏移量，<strong>linearDepth</strong> 是由深度纹理得到的线性深度值，<em>*interpolatedRay</em></em> 是由顶点着色器输出并插值后得到的射线，它不仅包含了该像素到摄像机的方向，也包含了距离信息。</p><p><strong>interpolatedRay 来源于对近裁剪平面的 4 个角的某个特定向量的插值</strong>，这 4 个向量包含了它们到摄像机的方向和距离信息，我们可以利用摄像机的近裁剪平面距离、FOV、横纵比计算而得。下图显示了计算时使用的一些辅助向量：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/26/gOjhfcrTqSiNUPw.jpg" width = "50%" height = "50%" alt="图71-  计算 interpolatedRay"/></div><p>为了方便计算，我们可以先计算两个向量 —— toTop 和 toRight，它们是起点位于近裁剪平面中心、分别指向摄像机正上方和正右方的向量，它们的计算公式如下：  </p><script type="math/tex; mode=display">halfHeight = Near \times tan( \cfrac {FOV} {2} )</script><script type="math/tex; mode=display">toTop = camera.up \times halfHeight</script><script type="math/tex; mode=display">toRight = camera.right \times halfHeight \cdot aspect</script><p>有了这两个辅助向量后，就可以计算 4 个角相对于摄像机的方向：  </p><script type="math/tex; mode=display">TL = camera.forward \cdot Near + toTop - toRight</script><script type="math/tex; mode=display">TR = camera.forward \cdot Near + toTop + toRight</script><script type="math/tex; mode=display">BL = camera.forward \cdot Near - toTop - toRight</script><script type="math/tex; mode=display">BR = camera.forward \cdot Near - toTop + toRight</script><p>上面求得的 4 个向量不仅包含了方向信息，它们的模对应了 4 个点到摄像机的空间距离。由于我们得到的线性深度值并非是点到摄像机的欧式距离，而是在 z 方向上的距离，不能直接使用深度值和 4 个角的单位方向的乘积来计算它们到相机的偏移量。要把深度值转换成到摄像机的欧式距离，我们以 TL 点为例，如下图：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/26/t9m42ryzPfjTOIB.jpg" width = "40%" height = "40%" alt="图72-  采样得到的深度值并非是点到摄像机的欧式距离"/></div><p>根据相似三角形原理，TL 所在的射线上，像素的深度值和它到摄像机的实际距离的比等于近裁剪平面的距离和 TL 向量的模的比，即：  </p><script type="math/tex; mode=display">\cfrac {depth}{dist} = \cfrac {Near}{|TL|}</script><p>即 TL 所在的射线上的像素距离摄像机的欧式距离 dist：  </p><script type="math/tex; mode=display">dist = \cfrac {|TL|}{Near} \times depth</script><p>为了得到 linearDepth * interpolatedRay 中的 interpolatedRay，需要求得近裁切平面的四个角的向量的类似于  interpolatedRay 的值作插值，以 TL 为例子，即：</p><script type="math/tex; mode=display">linearDepth \times Ray_{TL} = depth \times Ray_{TL} = dist \times \cfrac {TL}{|TL|}</script><script type="math/tex; mode=display">Ray_{TL} = \cfrac {|TL|}{Near} \times depth \times \cfrac {TL}{|TL|} \div depth = \cfrac {TL}{Near}</script><p>因为近裁切平面的四个角相互对称，令 $\,scale = |TL| / Near\,$，则：  </p><script type="math/tex; mode=display">Ray_{TL} = \cfrac {TL}{|TL|} \times scale , Ray_{TR} = \cfrac {TR}{|TR|} \times scale</script><script type="math/tex; mode=display">Ray_{BL} = \cfrac {BL}{|BL|} \times scale , Ray_{BR} = \cfrac {BR}{|BR|} \times scale</script><p>屏幕后处理的原理就是使用特定的材质去渲染一个刚好填充整个屏幕的四边形面片，<strong>屏幕后处理所用的模型是一个四边形网格，只包含 4 个顶点</strong>。这个四边形面片的 4 个顶点就对应了近裁剪平面的 4 个角。因此，我们可以把上面的计算结果传递给顶点着色器，顶点着色器根据当前的位置选择它所对应的向量，然后将其输出，经插值后传递给片元着色器得到基于像素的 interpolatedRay，我们就可以直接利用本节一开始提到的公式重建该像素在世界空间下的位置了。</p><h3 id="雾的计算"><a href="#雾的计算" class="headerlink" title="雾的计算"></a>雾的计算</h3><p>在简单的雾效实现中，我们需要计算一个雾效系数 f，作为混合原始颜色和雾的颜色的混合系数：  </p><pre><code>float3 afterFog = f * fogColor + (1 - f) * origColor</code></pre><p>这个雾效系数 f 有很多计算方法。在 Unity 内置的雾效实现中，支持三种雾的计算方式 —— 线性 Linear、指数 Exponential 以及指数的平方 Exponential Squared。当给定距离 z 后，f 的计算公式分别如下：<br>①Linear：  </p><script type="math/tex; mode=display">f= \cfrac {d_{max} - |z|}{d_{max} - d_{min}},d_{max}和d_{min}分别表示受雾影响的最大最小距离</script><p>②Exponential：</p><script type="math/tex; mode=display">f= e^{-d \cdot |z|},d是控制雾的浓度的参数</script><p>③Exponential Squared：</p><script type="math/tex; mode=display">f= e^{-(d \cdot |z|)^2},d是控制雾的浓度的参数</script><p>在本节中，我们将使用类似线性雾的计算方式，计算基于高度的雾效。具体方法是，当给定一点在世界空间下的高度 y 后，f 的计算公式为：  </p><script type="math/tex; mode=display">f = \cfrac {H_{end} - y}{H_{end} - H_{start}},H_{start}和H_{end} 分别表示受雾影响的起始高度和终止高度</script><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>准备工作如下：<br>①新建名为 Scene_13_3 的场景，并去掉天空盒子；<br>②搭建一个雾效场景，构建包含 3 面墙的房间，并放置几个立方体；<br>③拖拽一个控制相机不断围绕一个中心运动的脚本 Translating.cs 到相机组件；<br>④新建一个名为 FogWithDepthTexture 的 C# 脚本，并拖拽给相机；<br>⑤新建一个名为 Chapter13-FogWithDepthTexture 的 Unity Shader。</p><p>FogWithDepthTexture.cs 的 C# 脚本代码如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FogWithDepthTexture</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shader fogShader;</span><br><span class="line">    <span class="keyword">private</span> Material fogMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);</span><br><span class="line">            <span class="keyword">return</span> fogMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Transform myCameraTransform;</span><br><span class="line">    <span class="keyword">public</span> Transform cameraTransform &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCameraTransform == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCameraTransform = camera.transform;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCameraTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogDensity = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Color fogColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//雾效的起始高度和终止高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogStart = <span class="number">0.0f</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogEnd = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        camera.depthTextureMode |= DepthTextureMode.Depth; <span class="comment">//设置模式以在 shader 里获取深度纹理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            Matrix4x4 frustumCorners = Matrix4x4.identity; <span class="comment">//frustum：视锥体，初始化为单位矩阵，把计算近裁剪平面的四个角对应的向量，存储到这个矩阵类型的变量</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">            <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">            <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//本节最开始的公式的计算过程如下</span></span><br><span class="line">            <span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">            Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">            Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line">            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">            <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line">            topLeft.Normalize();</span><br><span class="line">            topLeft *= scale;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算各点的欧式距离</span></span><br><span class="line">            Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">            topRight.Normalize();</span><br><span class="line">            topRight *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">            bottomLeft.Normalize();</span><br><span class="line">            bottomLeft *= scale;</span><br><span class="line"></span><br><span class="line">            Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">            bottomRight.Normalize();</span><br><span class="line">            bottomRight *= scale;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按一定顺序把四个方向存储到 frustumCorners 的不同的行中</span></span><br><span class="line">            frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line"></span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chapter13-FogWithDepthTexture 的 Shader 代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 13/Fog With Depth Texture&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _FogDensity (<span class="string">&quot;Fog Density&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _FogColor (<span class="string">&quot;Fog Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _FogStart (<span class="string">&quot;Fog Start&quot;</span>, Float) = <span class="number">0.0</span></span><br><span class="line">        _FogEnd (<span class="string">&quot;Fog End&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        float4x4 _FrustumCornersRay;</span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        sampler2D _CameraDepthTexture;</span><br><span class="line">        half _FogDensity;</span><br><span class="line">        fixed4 _FogColor;</span><br><span class="line">        <span class="type">float</span> _FogStart;</span><br><span class="line">        <span class="type">float</span> _FogEnd;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv : TEXCOORD0;</span><br><span class="line">            half2 uv_depth : TEXCOORD1;</span><br><span class="line">            float4 interpolatedRay : TEXCOORD2;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//决定该顶点对应了 4 个角中的哪个角，这里使用判断语句是因为屏幕后处理所用的模型是一个四边形网格，只包含 4 个顶点，因此对性能影响不大</span></span><br><span class="line">            <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (v.texcoord.x &lt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                index = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                index = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                index = <span class="number">3</span> - index;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            </span><br><span class="line">            o.interpolatedRay = _FrustumCornersRay[index]; <span class="comment">//利用索引值来获取 _FrustumCornersRay 中对应的行</span></span><br><span class="line">              </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth)); <span class="comment">//对深度纹理采样后，使用 LinearEyeDepth 得到观察空间下的线性深度值</span></span><br><span class="line">            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;</span><br><span class="line">                        </span><br><span class="line">            <span class="type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); </span><br><span class="line">            fogDensity = saturate(fogDensity * _FogDensity); <span class="comment">//控制雾效系数</span></span><br><span class="line">            fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line">            <span class="keyword">return</span> finalColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">                     </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 Chapter13-FogWithDepthTexture 拖拽到摄像机的脚本的 Fog Shader 参数中，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/26/VpA56mbuRcKTIMg.jpg" width = "70%" height = "70%" alt="图73-  添加全局雾效后的效果"/></div><p><strong>本节介绍的使用深度纹理重构像素的世界坐标的方法是非常有用的</strong>。但是需要注意的是，这里的实现是基于摄影机的投影类型是透视投影的前提下。若需要在正交投影的情况下重建世界坐标，需要使用不同的公式，有兴趣可以自己推导。</p><h2 id="再谈边缘检测"><a href="#再谈边缘检测" class="headerlink" title="再谈边缘检测"></a>再谈边缘检测</h2><p>在上一章节，使用的是 <strong>Sobel 算子</strong> 对屏幕图像进行边缘检测，这种直接利用颜色信息进行边缘检测的方法会受纹理、阴影等因素的影响，导致最终的描边并不精确。</p><p>在本节中，将利用深度和法线纹理，通过 <strong>Roberts 算子</strong>进行边缘检测，不受纹理和光照影响。Roberts 算子使用的卷积核如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/26/V6PIaFLX7sToSvt.jpg" width = "20%" height = "20%" alt="图74-   Roberts 算子"/></div><p>Roberts 算子的本质是就是计算左上角和右上角的差值，乘以右上角和左下角的差值，作为评估边缘的依据。在下面的实现中，我们也会按照这样的方式，取对角方向的深度或法线值，比较它们之间的差值，如果超过某个阈值，就认为它们之间存在一条边。</p><p>准备工作如下：<br>①新建名为 Scene_13_4 的场景，并去掉天空盒；<br>②搭建类似上一节全局雾效的场景；<br>③将上一节中用到的 Translating.cs 脚本拖拽给相机；<br>④新建名为 EdgeDetectNormalsAndDepth 的 C# 脚本，并拖拽给相机；<br>⑤新建名为 Chapter13-EdgeDetectNormalAndDepth 的 Unity Shader；  </p><p>EdgeDetectNormalsAndDepth.cs 的 C# 脚本代码如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeDetectNormalsAndDepth</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shader edgeDetectShader;</span><br><span class="line">    <span class="keyword">private</span> Material edgeDetectMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);</span><br><span class="line">            <span class="keyword">return</span> edgeDetectMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Color edgeColor = Color.black;</span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor = Color.white;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sampleDistance = <span class="number">1.0f</span>; <span class="comment">//用于控制对深度+法线纹理采样时，使用的采样距离。从视觉上看，为描边粗细程度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//sensitivityDepth 和 sensitivityNormals 则影响当邻域的深度值或法线值相差多少时被认为存在一条边界，而如果灵敏度调的很大，那么可能是深度或法线上很小的变化也会成为一条边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sensitivityDepth = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sensitivityNormals = <span class="number">1.0f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ImageEffectOpaque 特性，见第 11 章最前面，目的是为了在不透明的 Pass 执行完毕后立即调用该函数，不对透明物体产生影响。在本例中，不希望对透明物体也被描边</span></span><br><span class="line">    [<span class="meta">ImageEffectOpaque</span>]</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_EdgeOnly&quot;</span>, edgesOnly);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_EdgeColor&quot;</span>, edgeColor);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_BackgroundColor&quot;</span>, backgroundColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_SampleDistance&quot;</span>, sampleDistance);</span><br><span class="line">            material.SetVector(<span class="string">&quot;_Sensitivity&quot;</span>, <span class="keyword">new</span> Vector4(sensitivityNormals, sensitivityDepth, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chapter13-EdgeDetectNormalAndDepth 的 Shader 代码如下：</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 13/Edge Detection Normals And Depth&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _EdgeOnly (<span class="string">&quot;Edge Only&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _EdgeColor (<span class="string">&quot;Edge Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _BackgroundColor (<span class="string">&quot;Background Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _SampleDistance (<span class="string">&quot;Sample Distance&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _Sensitivity (<span class="string">&quot;Sensitivity&quot;</span>, Vector) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        fixed _EdgeOnly;</span><br><span class="line">        fixed4 _EdgeColor;</span><br><span class="line">        fixed4 _BackgroundColor;</span><br><span class="line">        <span class="type">float</span> _SampleDistance;</span><br><span class="line">        half4 _Sensitivity;</span><br><span class="line">        </span><br><span class="line">        sampler2D _CameraDepthNormalsTexture;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            half2 uv[<span class="number">5</span>]: TEXCOORD0; <span class="comment">//定义维数为 5 的纹理坐标数组，第一个坐标存储了屏幕颜色图像的采样纹理，剩下四个存储使用 Roberts 算子时需要采样的纹理坐标</span></span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            half2 uv = v.texcoord;</span><br><span class="line">            o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP <span class="comment">//解决平台差异性</span></span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                uv.y = <span class="number">1</span> - uv.y;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算罗伯特算子，使用 _SampleDistance 控制采样距离</span></span><br><span class="line">            o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">            o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        half <span class="title function_">CheckSame</span><span class="params">(half4 center, half4 sample)</span> &#123;</span><br><span class="line">            <span class="comment">//对输入的两个点的采样后的深度和法线信息进行处理。注意，这里没有解码得到真正的法线值，而是直接使用了 xy 分量。是因为我们只需要比较两个采样值的差异，不需要知道它们真正的法线</span></span><br><span class="line">            half2 centerNormal = center.xy;        </span><br><span class="line">            <span class="type">float</span> centerDepth = DecodeFloatRG(center.zw);        </span><br><span class="line">            half2 sampleNormal = sample.xy;</span><br><span class="line">            <span class="type">float</span> sampleDepth = DecodeFloatRG(sample.zw);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//两个采样点的对应值相减并取绝对值在乘以灵敏度参数，再把差异值的每个分量相加和一个阈值比较，若小于阈值则返回 1，说明差异不明显，否则则返回 0</span></span><br><span class="line">            half2 diffNormal = <span class="built_in">abs</span>(centerNormal - sampleNormal) * _Sensitivity.x;</span><br><span class="line">            <span class="type">int</span> isSameNormal = (diffNormal.x + diffNormal.y) &lt; <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用偏差是否达到深度的十分之一来判定深度值是否相近</span></span><br><span class="line">            <span class="type">float</span> diffDepth = <span class="built_in">abs</span>(centerDepth - sampleDepth) * _Sensitivity.y;</span><br><span class="line">            <span class="type">int</span> isSameDepth = diffDepth &lt; <span class="number">0.1</span> * centerDepth;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// return:</span></span><br><span class="line">            <span class="comment">// 1 - if normals and depth are similar enough</span></span><br><span class="line">            <span class="comment">// 0 - otherwise</span></span><br><span class="line">            <span class="keyword">return</span> isSameNormal * isSameDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 <span class="title function_">fragRobertsCrossDepthAndNormal</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="comment">//使用 4 个纹理坐标对深度+法线纹理进行法线采样</span></span><br><span class="line">            half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">1</span>]);</span><br><span class="line">            half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">2</span>]);</span><br><span class="line">            half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">3</span>]);</span><br><span class="line">            half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">4</span>]);</span><br><span class="line">            </span><br><span class="line">            half edge = <span class="number">1.0</span>;</span><br><span class="line">            edge *= CheckSame(sample1, sample2); <span class="comment">//调用 checksame 计算对角线上两个纹理值的差值，若返回 0 则两点间存在一条边界，反之则为 1</span></span><br><span class="line">            edge *= CheckSame(sample3, sample4);</span><br><span class="line">            </span><br><span class="line">            fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">0</span>]), edge);</span><br><span class="line">            fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">            <span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        Pass &#123; </span><br><span class="line">            ZTest Always Cull Off ZWrite Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM      </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment fragRobertsCrossDepthAndNormal</span></span><br><span class="line">            </span><br><span class="line">            ENDCG  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Chapter13-EdgeDetectNormalAndDepth 拖入摄像机脚本的 Edge Detect Shader 参数中，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/27/5DIAmgKqwtXaZhV.png" width = "60%" height = "60%" alt="图75-   在深度和法线纹理上进行更健壮的边缘检测。上图：在原图上描边的效果（Edges only 为 0）。右图：只显示描边的效果（Edges only 为 1）"/></div><p>本节实现的描边效果是基于整个屏幕空间进行的，场景内所有物体都会被添加描边效果。但有时，我们希望只对特定的物体进行描边，这时需要 Unity 提供的 Graphics.DrawMesh 或 Graphics.DrawMeshNow 函数，把需要描边的物体再次渲染一次（在所有不透明物体渲染完毕之后），再使用本节提到的边缘检测算法计算深度或法线纹理中每个像素的梯度值，判断它们是否小于阈值。若是，则在 Shader 中使用 clip() 函数将该像素剔除掉，从而显示出原来的颜色。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>在本章中，我们只使用了深度和法线纹理，但实际上我们可以在 Unity 中创建任何需要的缓存纹理。这可以通过使用 Unity 的着色器替换 shader replacement 功能，即调用 Camera.RenderWithShader(shader, replacementTag) 函数，把整个场景再次渲染一遍来得到，而在很多时候，这实际上也是 Unity 创建深度和法线纹理时使用的方法。</p><p>深度和法线纹理在屏幕特效的实现中扮演很重要的角色，很多特殊的屏幕效果都可以基于深度和法线纹理去实现，原作者给出了 Unity 在 2011 年的 SIGGRAPH（计算机图形学的顶级会议）上做的一个关于使用深度纹理实现各种特效的演讲，感兴趣可前往阅读：<a href="https://blog.unity.com/community/special-effects-with-depth-talk-at-siggraph">https://blog.unity.com/community/special-effects-with-depth-talk-at-siggraph</a></p><h1 id="第十三章-非真实感渲染"><a href="#第十三章-非真实感渲染" class="headerlink" title="第十三章 非真实感渲染"></a>第十三章 非真实感渲染</h1><p>一些游戏渲染是以<strong>照相写实主义 photorealism</strong> 作为主要目标，但也有一些游戏使用了<strong>非真实感渲染 Non-Photorealistic Rendering, NPR</strong> 的方法来渲染游戏画面。非真实感渲染的一个主要目标是，使用一些渲染方法使得画面达到和某些特殊的绘画风格相似的效果，例如卡通、水彩风格等。</p><h2 id="卡通风格的渲染"><a href="#卡通风格的渲染" class="headerlink" title="卡通风格的渲染"></a>卡通风格的渲染</h2><p>要实现卡通渲染有很多方法，其中之一就是使用<strong>基于色调的着色技术 tone-based shading</strong>。在实现中，我们往往会使用漫反射系数对一张一维纹理进行采样，以控制漫反射的色调，也就是第六章实现的渐变纹理。</p><p>卡通的高光效果和之前学习的光照不同，模型的高光往往是一块块分界明显的纯色区域。</p><p>除了光照模型不同外，卡通风格通常还需要在物体边缘部分绘制轮廓。在上一章节，使用的是屏幕后处理技术对屏幕图像进行描边。在本节中，将介绍基于模型的描边方法，这种方法的实现更加简单，而且大多数情况下效果不错。</p><h3 id="渲染轮廓线"><a href="#渲染轮廓线" class="headerlink" title="渲染轮廓线"></a>渲染轮廓线</h3><p>在实时渲染中，轮廓线的渲染应用广泛。在《Real Time Rendering, third edition》中，作者将绘制模型轮廓的方法分为了 5 种：<br>①基于观察角度和表面法线的轮廓线渲染：使用视角方向和表面法线的点乘结果来得到轮廓线的信息。这种方法简单快捷，可以在一个 Pass 中就得到渲染结果，但局限性很大，很多模型渲染出来的描边效果都不尽人意。<br>②过程式几何轮廓渲染：使用两个 Pass 渲染。第一个 Pass 渲染背面的面片，并使用某些技术让它的轮廓可见；第二个 Pass 再正常渲染正面的面片。这种方法的优点在于快速有效，并且适用于绝大多数表面平滑的模型，但它的缺点是不适用于类似于立方体这样的平整的模型。<br>③基于图像处理的轮廓线渲染：我们在 11、12 章介绍的边缘检测的方法就属于这个类别。这种方法的优点在于，可以适用于任何种类的模型。但它也有自身的局限所在，一些深度和法线变化很小的轮廓无法被检测出来，例如桌子上的纸张。<br>④基于轮廓边检测的轮廓线渲染：上面提到的各种方法，一个最大的问题是，无法控制轮廓线的风格渲染。对于一些情况，我们希望可以渲染出独特风格的轮廓线，例如水墨风格等。为此，我们希望可以检测出精确的轮廓边，然后直接渲染它们。检测一条边是否是轮廓边的公式也很简单，我们只需要检查和这条边相邻的两个三角面片是否满足以下条件：</p><script type="math/tex; mode=display">(n_0 \cdot v > 0) \neq (n_1 \cdot v > 0)</script><p>其中，$\,n_0\,$ 和 $\,n_1\,$ 分别表示两个相邻三角面片的法向，v 是从视角到该边上任意顶点的方向。上述公式的本质在于检查两个相邻的三角面片是否一个朝正面、一个朝背面。我们可以在几何着色器 Geometry Shader 的帮助下实现上面的检测过程。当然，这种方法也有缺点，除了实现相对复杂外，它还会有动画连贯性的问题。也就是说，由于是逐帧单独提取轮廓，所以在帧与帧之间会出现跳跃性。<br>⑤最后一个种类就是混合了上述几种渲染方法。例如，首先找到精确的轮廓边，把模型和轮廓边渲染到纹理中，再使用图像处理的方法识别出轮廓线，并在图像空间下进行风格化渲染。</p><hr><p>在本节中，我们将会在 Unity 中使用<strong>过程式几何轮廓线渲染</strong>的方法来对模型进行轮廓描边。我们将使用两个 Pass 渲染模型：在第一个 Pass 中，我们会使用轮廓线颜色渲染整个背面的面片，并在视角(观察)空间下把模型顶点沿着法线方向向外扩张一段距离，一次来让背部轮廓线可见。代码如下：  </p><pre><code>viewPos = viewPos + viewNormal * _Outline;</code></pre><p>但是，如果直接使用顶点法线进行扩展，对于一些内凹的模型，就可能发生背面面片遮挡正面面片的情况。为了尽可能防止出现这样的情况，在扩张背面顶点之前，我们首先对顶点法线的 z 分量进行处理，使它们等于一个定值，然后把法线归一化再对顶点进行扩张。这样的好处在于，扩展后的背面更加扁平化，从而降低了遮挡正面面片的可能性。代码如下：  </p><pre><code>viewNormal.z = -0.5;viewNormal = normalize(viewNormal);viewPos = viewPos + viewNormal * _Outline;</code></pre><h3 id="添加高光"><a href="#添加高光" class="headerlink" title="添加高光"></a>添加高光</h3><p>卡通风格中的高光是模型上一块块分界明显的纯色区域。因此不能在使用之前学习的光照模型，回顾一下之前实现的 Blinn-Phong 模型，我们使用法线点乘光照方向以及视角方向和的一半，再和另一个参数进行指数操作得到高光反射系数，代码如下：  </p><pre><code>float spec = pow(max(0, dot(normal, halfDir)), _Gloss);</code></pre><p>对于卡通渲染需要的高光反射光照模型，我们同样需要计算 normal 和 halfDir 的点乘结果，但不同的是，我们把该值和一个阈值进行比较，如果小于该阈值，则高光反射系数为 0，否则返回 1：  </p><pre><code>float spec = dot(worldNormal, worldHalfDir);spec = step(threshold, spec);</code></pre><p>在上面的代码中，我们使用 Cg 的 <code>step</code> 函数来实现和阈值比较的目的。step 函数接受两个参数，第一个参数是参考值，第二个参数是待比较的数值。如果第二个参数大于等于第一个参数，则返回 1，否则返回 0。</p><p>但是，这种粗暴的判断方法会在高光区域的边界造成锯齿，因为高光区域的边缘不是平滑渐变的，而是从 0 突破到 1。要想对其进行抗锯齿处理，我们可以在边界很小的一块区域内，进行平滑处理，代码如下：  </p><pre><code>float spec = dot(worldNormal, worldHalfDir);spec = lerp(0, 1, smoothstep(-w, w, spec - threshold))</code></pre><p>使用了 Cg 的 <code>smoothstep</code> 函数。其中，w 是一个很小的值，当 spec - threshold 小于 -w 时，返回 0，大于 w 时，返回 1，否则在 0 到 1 之间进行插值。这样的效果是，我们可以在 [-w, w] 区间内，即高光区域的边界处，得到一个从 0 到 1 平滑变化的 spec 值，从而实现抗锯齿的目的。尽管我们可以把 w 设为一个很小的定值，但在本例中，我们选择使用领域像素之间的近似导数值，这可以通过 CG 的 <code>fwidth</code> 函数来得到。</p><blockquote><pre><code>ddx(v) = 该像素点右边的值 - 该像素点的值  ddy(v) = 该像素点下面的值 - 该像素点的值  fwidth（v） = abs(ddx(v)) + abs(ddy(v))  //邻域像素之间的近似导数值  </code></pre><p>当代 GPU 在像素化的时候一般是以 2 x 2 像素为基本单位，那么在这个 2 x 2 像素块当中，右侧的像素对应的 fragment 的 x 坐标减去左侧的像素对应的 fragment 的 x 坐标就是ddx；下侧像素对应的 fragment 的坐标 y 减去上侧像素对应的 fragment 的坐标 y 就是 ddy，ddx 和 ddy 代表了相邻两个像素在设备坐标系当中的距离。</p></blockquote><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>准备工作如下：<br>①新建名为 Scene_14_1 的场景，并去掉天空盒；<br>②往场景中拖入一个 Suzanne 模型；<br>③新建名为 ToonShadingMat 的材质，并赋给上一步的模型；<br>④新建名为 Chapter14-ToonShading 的 Unity Shader，并赋给上一步的材质。</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 14/Toon Shading&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Ramp (<span class="string">&quot;Ramp Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Outline (<span class="string">&quot;Outline&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span> <span class="comment">//控制轮廓线宽度</span></span><br><span class="line">        _OutlineColor (<span class="string">&quot;Outline Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) </span><br><span class="line">        _Specular (<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _SpecularScale (<span class="string">&quot;Specular Scale&quot;</span>, Range(<span class="number">0</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span> <span class="comment">//控制高光反射的阈值</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            NAME <span class="string">&quot;OUTLINE&quot;</span> <span class="comment">//定义名称，方便其他 shader 调用</span></span><br><span class="line">            </span><br><span class="line">            Cull Front <span class="comment">//把正面的三角面片剔除掉，只渲染背面</span></span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="type">float</span> _Outline;</span><br><span class="line">            fixed4 _OutlineColor;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span>        </span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;; </span><br><span class="line">                </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span>        </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//先变换到观察空间</span></span><br><span class="line">                float4 pos = mul(UNITY_MATRIX_MV, v.vertex); </span><br><span class="line">                float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);</span><br><span class="line">                <span class="comment">//观察空间是右手坐标系，所以是减</span></span><br><span class="line">                normal.z = <span class="number">-0.5</span>;</span><br><span class="line">                pos = pos + float4(normalize(normal), <span class="number">0</span>) * _Outline;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_P, pos); <span class="comment">//变换到裁剪空间中</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            float4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> float4(_OutlineColor.rgb, <span class="number">1</span>); <span class="comment">//渲染着整个背面即可       </span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125; <span class="comment">//前向渲染标签，光照模型需要 Unity 提供光照等信息，从而要对pass进行相应的设置</span></span><br><span class="line">            </span><br><span class="line">            Cull Back</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">        </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">        </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityShaderVariables.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _Ramp;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            fixed _SpecularScale;</span><br><span class="line">        </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">            &#125;; </span><br><span class="line">        </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float3 worldNormal : TEXCOORD1;        </span><br><span class="line">                float3 worldPos : TEXCOORD2;    </span><br><span class="line">                SHADOW_COORDS(<span class="number">3</span>) <span class="comment">//阴影相关宏</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos( v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX (v.texcoord, _MainTex);</span><br><span class="line">                o.worldNormal  = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                TRANSFER_SHADOW(o); <span class="comment">//阴影相关宏</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            float4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123; </span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 worldHalfDir = normalize(worldLightDir + worldViewDir);</span><br><span class="line">                </span><br><span class="line">                fixed4 c = tex2D (_MainTex, i.uv);</span><br><span class="line">                fixed3 albedo = c.rgb * _Color.rgb;</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); <span class="comment">//利用内置宏计算当前世界坐标下的阴影值</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//半兰伯特漫反射系数和阴影值相乘得到最终的漫反射系数</span></span><br><span class="line">                fixed diff =  dot(worldNormal, worldLightDir);</span><br><span class="line">                diff = (diff * <span class="number">0.5</span> + <span class="number">0.5</span>) * atten;</span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;</span><br><span class="line">                </span><br><span class="line">                fixed spec = dot(worldNormal, worldHalfDir);</span><br><span class="line">                fixed w = fwidth(spec) * <span class="number">2.0</span>; <span class="comment">//抗锯齿操作</span></span><br><span class="line">                fixed3 specular = _Specular.rgb * lerp(<span class="number">0</span>, <span class="number">1</span>, smoothstep(-w, w, spec + _SpecularScale - <span class="number">1</span>)) * step(<span class="number">0.0001</span>, _SpecularScale); <span class="comment">//0.0001是为了在 _SpecularScale 为 0 时完全消除高光反射的光照</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>); <span class="comment">//环境光、漫反射和高光反射相加的结果</span></span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/28/vxXMywPiJB6pWNK.jpg" width = "70%" height = "70%" alt="图76- 卡通风格的渲染效果"/></div><p>本节实现的卡通渲染光照模型是一种非常简单的实现，要获取更出色的卡通效果，需自行查阅更多资料。</p><h2 id="素描风格的渲染"><a href="#素描风格的渲染" class="headerlink" title="素描风格的渲染"></a>素描风格的渲染</h2><p>另一个非常流行的非真实渲染时素描风格的渲染。微软研究院的 Praun 等人在 2001 年的 SIGGRAPH 上发表了一篇非常著名的论文。在这篇文章中，他们使用了提前生成的素描纹理来实现实时的素描风格渲染，这些纹理组成了一个<strong>色调艺术映射 Tonal Art Map，TAM</strong>，如下图所示：</p><div  align="center">  <img src="https://s2.loli.net/2023/12/28/8ChEtLKZicqxYJ2.jpg" width = "70%" height = "70%" alt="图77- 一个 TAM 的例子（来源：Praun E, et al. Real-time hatching）"/></div><p>上图中，从左到右纹理中的笔触逐渐增多，用于模拟不同光照下的漫反射效果，从上到下对应了每张纹理的<strong>多级渐远纹理 mipmaps</strong>。这些纹理的生成并不是简单的对上一层纹理进行降采样，而是需要保持笔触之间的间隔，以便真实模拟素描的效果。</p><p>本节将会实现简化版的论文中提出的算法，我们不考虑多级渐远纹理的生成，而直接使用 6 张纹理进行渲染。在渲染阶段，我们首先在顶点着色阶段计算逐顶点的光照，根据光照结果来决定 6 张纹理的混合权重，并传递给片元着色器。然后，在片元着色器中根据这些权重来混合 6 张纹理的采样结果。</p><p>准备工作如下：<br>①新建名为 Scene_14_2 的场景，并去掉天空盒；<br>②拖拽 TeddyBear 模型到场景。可以往场景中拖入一张纸张图像作为背景；<br>③新建名为 HatchingMat 的材质，并赋给上一步的模型；<br>④新建名为 Chapter14-Hatching 的 Unity Shader，并赋给上一步创建的材质。</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 14/Hatching&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _TileFactor (<span class="string">&quot;Tile Factor&quot;</span>, Float) = <span class="number">1</span> <span class="comment">//纹理的平铺系数，越大，素描线条越密</span></span><br><span class="line">        _Outline (<span class="string">&quot;Outline&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span> <span class="comment">//描边的粗细</span></span><br><span class="line">        <span class="comment">//渲染时的6张素描纹理，其线条密度依次增加</span></span><br><span class="line">        _Hatch0 (<span class="string">&quot;Hatch 0&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Hatch1 (<span class="string">&quot;Hatch 1&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Hatch2 (<span class="string">&quot;Hatch 2&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Hatch3 (<span class="string">&quot;Hatch 3&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Hatch4 (<span class="string">&quot;Hatch 4&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Hatch5 (<span class="string">&quot;Hatch 5&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        UsePass <span class="string">&quot;Unity Shaders Book/Chapter 14/Toon Shading/OUTLINE&quot;</span> <span class="comment">//使用卡通渲染的 pass 进行渲染轮廓，别忘了 Pass 名字要全部转为大写</span></span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag </span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityShaderVariables.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _TileFactor;</span><br><span class="line">            sampler2D _Hatch0;</span><br><span class="line">            sampler2D _Hatch1;</span><br><span class="line">            sampler2D _Hatch2;</span><br><span class="line">            sampler2D _Hatch3;</span><br><span class="line">            sampler2D _Hatch4;</span><br><span class="line">            sampler2D _Hatch5;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float3 normal : NORMAL; </span><br><span class="line">                float2 texcoord : TEXCOORD0; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                <span class="comment">//因为声明了 6 张纹理，从而需要 6 个混合权重，把其存储在两个 fixed3 类型的变量中</span></span><br><span class="line">                fixed3 hatchWeights0 : TEXCOORD1;</span><br><span class="line">                fixed3 hatchWeights1 : TEXCOORD2;</span><br><span class="line">                float3 worldPos : TEXCOORD3; <span class="comment">//为添加阴影，从而需要声明 worldPos 变量</span></span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>) <span class="comment">//使用 SHADOW_COORDS 宏声明阴影纹理的采样坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord.xy * _TileFactor; <span class="comment">//使用 _TileFactor 得到纹理采样坐标</span></span><br><span class="line">                </span><br><span class="line">                fixed3 worldLightDir = normalize(WorldSpaceLightDir(v.vertex));</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed diff = max(<span class="number">0</span>, dot(worldLightDir, worldNormal)); <span class="comment">//漫反射系数</span></span><br><span class="line"></span><br><span class="line">                o.hatchWeights0 = fixed3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//把权重值初始化定位0</span></span><br><span class="line">                o.hatchWeights1 = fixed3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把 diff 缩放到 [0,7] 得到 hatchFactor，通过 hatchFactor 来计算其所处的自区间来计算对应的纹理混合权重</span></span><br><span class="line">                <span class="type">float</span> hatchFactor = diff * <span class="number">7.0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (hatchFactor &gt; <span class="number">6.0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Pure white, do nothing</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">5.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor - <span class="number">5.0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">4.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.x = hatchFactor - <span class="number">4.0</span>;</span><br><span class="line">                    o.hatchWeights0.y = <span class="number">1.0</span> - o.hatchWeights0.x;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">3.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.y = hatchFactor - <span class="number">3.0</span>;</span><br><span class="line">                    o.hatchWeights0.z = <span class="number">1.0</span> - o.hatchWeights0.y;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">2.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights0.z = hatchFactor - <span class="number">2.0</span>;</span><br><span class="line">                    o.hatchWeights1.x = <span class="number">1.0</span> - o.hatchWeights0.z;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">                    o.hatchWeights1.x = hatchFactor - <span class="number">1.0</span>;</span><br><span class="line">                    o.hatchWeights1.y = <span class="number">1.0</span> - o.hatchWeights1.x;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    o.hatchWeights1.y = hatchFactor;</span><br><span class="line">                    o.hatchWeights1.z = <span class="number">1.0</span> - o.hatchWeights1.y;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                TRANSFER_SHADOW(o); <span class="comment">//计算阴影纹理的采样坐标</span></span><br><span class="line">                <span class="keyword">return</span> o; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                <span class="comment">//混合权重，对每张纹理进行采样，并和他们对应的权重值相乘得到每张纹理的采样颜色</span></span><br><span class="line">                fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x;</span><br><span class="line">                fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y;</span><br><span class="line">                fixed4 hatchTex2 = tex2D(_Hatch2, i.uv) * i.hatchWeights0.z;</span><br><span class="line">                fixed4 hatchTex3 = tex2D(_Hatch3, i.uv) * i.hatchWeights1.x;</span><br><span class="line">                fixed4 hatchTex4 = tex2D(_Hatch4, i.uv) * i.hatchWeights1.y;</span><br><span class="line">                fixed4 hatchTex5 = tex2D(_Hatch5, i.uv) * i.hatchWeights1.z;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算纯白在渲染中的贡献度，主要是为了光照最亮的部分是纯白色，即素描的留白部分</span></span><br><span class="line">                fixed4 whiteColor = fixed4(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * (<span class="number">1</span> - i.hatchWeights0.x - i.hatchWeights0.y - i.hatchWeights0.z - i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z);</span><br><span class="line">                </span><br><span class="line">                fixed4 hatchColor = hatchTex0 + hatchTex1 + hatchTex2 + hatchTex3 + hatchTex4 + hatchTex5 + whiteColor;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); <span class="comment">//得到阴影值</span></span><br><span class="line">                                </span><br><span class="line">                <span class="keyword">return</span> fixed4(hatchColor.rgb * _Color.rgb * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/28/PRnjh2JEz5oZC3A.jpg" width = "70%" height = "70%" alt="图78- 素描风格的渲染效果"/></div><h1 id="第十四章-使用噪声"><a href="#第十四章-使用噪声" class="headerlink" title="第十四章 使用噪声"></a>第十四章 使用噪声</h1><h2 id="消融效果"><a href="#消融效果" class="headerlink" title="消融效果"></a>消融效果</h2><p><strong>消融 dissolve</strong> 效果常见于游戏中的角色死亡、地图烧毁等效果。在这些效果中，消融往往从不同的区域开始，并向看似随机的方向扩张，最后整个物体都将消失不见。在本节中，我们将在 Unity 中实现这种效果。</p><p>消融效果的原理：概括来说就是噪声纹理+透明度测试。我们使用噪声纹理采样的结果和某个控制消融程度的阈值比较，如果小于阈值，就使用 clip 函数把它对应的像素裁剪掉，这些部分就对应了被“烧毁”的区域。而镂空区域边缘的烧焦效果则是将两种颜色混合，再用 pow 函数处理后，与原纹理颜色混合后的的结果。</p><p>准备工作如下：<br>①新建名为 Scene_15_1 的场景，并去掉天空盒；<br>②往场景中放置一个立方体；<br>③新建名为 DissolveMat 的材质，并赋给上一步创建的立方体；<br>④新建名为 Chapter15-Dissolve 的 Unity Shader，并赋给上一步创建的材质。</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 15/Dissolve&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _BurnAmount (<span class="string">&quot;Burn Amount&quot;</span>, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.0</span> <span class="comment">//控制燃烧的效果</span></span><br><span class="line">        _LineWidth(<span class="string">&quot;Burn Line Width&quot;</span>, Range(<span class="number">0.0</span>, <span class="number">0.2</span>)) = <span class="number">0.1</span> <span class="comment">//控制燃烧烧焦效果时的线宽</span></span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _BumpMap (<span class="string">&quot;Normal Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">        _BurnFirstColor(<span class="string">&quot;Burn First Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">//燃烧边界的第一种颜色</span></span><br><span class="line">        _BurnSecondColor(<span class="string">&quot;Burn Second Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">//燃烧边界的渐变的第二种颜色</span></span><br><span class="line">        _BurnMap(<span class="string">&quot;Burn Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125; <span class="comment">//对应的噪声纹理</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            Cull Off</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            fixed _BurnAmount;</span><br><span class="line">            fixed _LineWidth;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            fixed4 _BurnFirstColor;</span><br><span class="line">            fixed4 _BurnSecondColor;</span><br><span class="line">            sampler2D _BurnMap;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            float4 _BurnMap_ST;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uvMainTex : TEXCOORD0;</span><br><span class="line">                float2 uvBumpMap : TEXCOORD1;</span><br><span class="line">                float2 uvBurnMap : TEXCOORD2;</span><br><span class="line">                float3 lightDir : TEXCOORD3;</span><br><span class="line">                float3 worldPos : TEXCOORD4;</span><br><span class="line">                SHADOW_COORDS(<span class="number">5</span>) <span class="comment">//阴影纹理</span></span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line">                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把光源信息从模型空间变换到切线空间</span></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line">                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                  </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                TRANSFER_SHADOW(o); <span class="comment">//得到阴影信息</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将采样结果和用于控制消融效果的属性 _BurnAmount 相减并传递给 clip 函数，如果结果小于 0 则该像素将会被剔除，从而不会显示到屏幕上，而如果通过了测试，则将进行正常的光照效果</span></span><br><span class="line">                clip(burn.r - _BurnAmount);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果通过了测试，则进行正常的光照计算</span></span><br><span class="line">                float3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line">                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));</span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="number">0</span>, dot(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算燃烧颜色 burncolor，在 _LineWidth 范围内模拟烧焦的颜色变化，使用 smoothstep 函数计算混合系数 t，当 t 为 1 时，表明该像素位于消融的边界，当 t 为 0 时，表明该像素为正常的模型颜色</span></span><br><span class="line">                fixed t = <span class="number">1</span> - smoothstep(<span class="number">0.0</span>, _LineWidth, burn.r - _BurnAmount);</span><br><span class="line">                fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t); <span class="comment">//混合两种火焰颜色</span></span><br><span class="line">                burnColor = <span class="built_in">pow</span>(burnColor, <span class="number">5</span>); <span class="comment">//pow 让其更加接近烧焦效果</span></span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);        </span><br><span class="line">                fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(<span class="number">0.0001</span>, _BurnAmount)); <span class="comment">//使用 t 来混合正常的光照颜色（环境光+漫反射）和烧焦颜色，而 step 是保证 _BurnAmount 为 0 时不显示任何消融效果</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义投射阴影的 pass，让阴影能够配合透明度测试产生正确的效果</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ShadowCaster&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_shadowcaster</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            fixed _BurnAmount;</span><br><span class="line">            sampler2D _BurnMap;</span><br><span class="line">            float4 _BurnMap_ST;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                V2F_SHADOW_CASTER; <span class="comment">//得到定义阴影投射所需要定义的变量</span></span><br><span class="line">                float2 uvBurnMap : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(appdata_base v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o) <span class="comment">//该宏用于填充 V2F_SHADOW_CASTER 背后声明的一些变量</span></span><br><span class="line">                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">                clip(burn.r - _BurnAmount); <span class="comment">//利用噪声纹理的采样结果 uvBurnMap 来剔除片元</span></span><br><span class="line">                SHADOW_CASTER_FRAGMENT(i) <span class="comment">//完成阴影投射部分，把结果输出到深度图和阴影映射纹理中</span></span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将噪声纹理拖拽到材质的 Burn Map 属性上，再调整材质的 Burn Amount 属性，就可以看到消融的效果了。可以自己实现一个辅助脚本用于控制材质的 Burn Amount 属性，或者使用 Shader 动画来实现动画效果。效果如下：  </p><table><tr><td><img src='https://s2.loli.net/2023/12/29/i8PvuV4ZhpKW2EX.jpg' width="330" alt="图79- 消融效果使用的噪声纹理"></td><td><img src='https://s2.loli.net/2023/12/29/DPnZNSjpFLer56R.gif' width="600" alt="图80- 箱子的消融效果"></td></tr></table><h2 id="水波效果"><a href="#水波效果" class="headerlink" title="水波效果"></a>水波效果</h2><p>在模拟水面的过程中，我们往往也会使用噪声纹理。此时，噪声纹理通常会用作一个高度图，以不断修改水面的法线方向。为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，再进行正常的反射 + 折射计算，得到最后的水面波动效果。</p><p>本节中，我们将使用一个由噪声纹理得到的法线贴图，实现一个包含菲涅尔反射的水面效果。和第 9 章实现的透明玻璃类似。首先使用一张立方体纹理 Cubemap 作为环境纹理，模拟反射。为了模拟折射效果，我们使用 GrabPass 来获取当前屏幕的渲染纹理，并使用切线空间下的法线方向对像素的屏幕坐标进行偏移，再使用该坐标对渲染纹理进行屏幕采样，从而模拟近似的折射效果。</p><p>和之前不同，水波的法线纹理是由一张噪声纹理生成而得。除此之外，我们没有使用一个定值来混合反射和折射颜色，而是使用之前菲涅尔系数来动态决定混合系数。我们使用的公式计算菲涅尔系数：  </p><script type="math/tex; mode=display">fresnel = pow(1 - max(0, v \cdot n),4)</script><p>其中，v 和 n 分别对应了视角方向和法线方向。它们之间的夹角越小，fresnel 值越小，反射越弱，折射越强。菲涅尔系数还经常会用于边缘光照的计算中。</p><hr><p>准备工作如下：<br>①新建名为 Scene_15_2 的场景，并去掉天空盒；<br>②搭建水波效果的测试场景，构建一个由 6 面墙围成的封闭房间，房间中放置一个平面来模拟水面；<br>③新建名为 WaterWaveMat 的材质，并赋给上一步的平面（水面）；<br>④新建名为 Chapter15-WaterWave 的 Unity Shader，并赋给上一步的材质；<br>⑤使用第 9 章 1.2节中实现的创建立方体纹理的脚本创建一个立方体纹理，用于得到本场景适用的环境纹理。在 Project 创建一张名为 Wave_Cubemap 的立方体纹理（右键 -&gt; Create -&gt; Legacy -&gt; Cubemap）；点击菜单栏 GameObject -&gt; Render into CubeMap。  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 15/Water Wave&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Main Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0.15</span>, <span class="number">0.115</span>, <span class="number">1</span>) <span class="comment">//控制水面颜色</span></span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//水面波纹材质纹理</span></span><br><span class="line">        _WaveMap (<span class="string">&quot;Wave Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125; <span class="comment">//由噪声纹理生成的法线纹理</span></span><br><span class="line">        _Cubemap (<span class="string">&quot;Environment Cubemap&quot;</span>, Cube) = <span class="string">&quot;_Skybox&quot;</span> &#123;&#125;</span><br><span class="line">        _WaveXSpeed (<span class="string">&quot;Wave Horizontal Speed&quot;</span>, Range(<span class="number">-0.1</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span> <span class="comment">//法线纹理在 x 方向上的平移速度</span></span><br><span class="line">        _WaveYSpeed (<span class="string">&quot;Wave Vertical Speed&quot;</span>, Range(<span class="number">-0.1</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span> <span class="comment">//法线纹理在 y 方向上的平移速度</span></span><br><span class="line">        _Distortion (<span class="string">&quot;Distortion&quot;</span>, Range(<span class="number">0</span>, <span class="number">100</span>)) = <span class="number">10</span> <span class="comment">//模拟折射时图像的扭曲程度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125; <span class="comment">//Queue 设置成 Transparent 可以确保该物体渲染时，其他所有不透明物体都已经被渲染到屏幕上，否则可能无法正确得到“透过水面看到的图像”；而设置为 RenderType 则是为了在使用着色器替换时，该物体可以在需要时被正确渲染，见第 12 章开头</span></span><br><span class="line">        </span><br><span class="line">        GrabPass &#123; <span class="string">&quot;_RefractionTex&quot;</span> &#125; <span class="comment">//GrabPass 定义了一个抓去屏幕图像的 Pass，在该 Pass 中定义一个字符串，该字符串内部的名称决定了抓去得到的屏幕图像将会被存入哪个纹理中</span></span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125; </span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _WaveMap;</span><br><span class="line">            float4 _WaveMap_ST;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            fixed _WaveXSpeed;</span><br><span class="line">            fixed _WaveYSpeed;</span><br><span class="line">            <span class="type">float</span> _Distortion;    </span><br><span class="line">            sampler2D _RefractionTex;</span><br><span class="line">            float4 _RefractionTex_TexelSize;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 scrPos : TEXCOORD0;</span><br><span class="line">                float4 uv : TEXCOORD1;</span><br><span class="line">                float4 TtoW0 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD4; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.scrPos = ComputeGrabScreenPos(o.pos); <span class="comment">//通过调用 ComputeGrabScreenPos 来得到对应被抓取屏幕图像的采样坐标，它的主要代码和 ComputeScreenPos 类似，最大的不同是针对平台差异问题</span></span><br><span class="line">                </span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex); </span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _WaveMap);</span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line"></span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x); </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y); </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z); </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//通过 _Time.y 变量和 _WaveXSpeed、_WaveYSpeed 计算法线纹理当前偏移量</span></span><br><span class="line">                float2 speed = _Time.y * float2(_WaveXSpeed, _WaveYSpeed);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//利用偏移量对法线纹理进行两次采样从而模拟两层交叉的水面波动的效果</span></span><br><span class="line">                fixed3 bump1 = UnpackNormal(tex2D(_WaveMap, i.uv.zw + speed)).rgb;</span><br><span class="line">                fixed3 bump2 = UnpackNormal(tex2D(_WaveMap, i.uv.zw - speed)).rgb;</span><br><span class="line">                fixed3 bump = normalize(bump1 + bump2); <span class="comment">//两次结果相加并归一化得到切线空间下的法线方向</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//利用 _Distortion 和 _RefractionTex_TexelSize 来对屏幕图像的采样坐标进行偏移，模拟折射效果，offset 越大，水面扭曲程度越大</span></span><br><span class="line">                float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//选择切线空间下的法线方向来进行偏移，因为该空间下的法线可以反应顶点局部空间下的法线方向，在计算偏移后的屏幕坐标，需要把偏移量和屏幕坐标的 z 分量相乘，从而模拟深度变大、折射程度越大的效果</span></span><br><span class="line">                i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//对 scrPos 进行透视除法，再使用该坐标对抓取的屏幕图像 _RefractionTex 进行采样</span></span><br><span class="line">                fixed3 refrCol = tex2D( _RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//把法线方向从切线空间变换到世界空间下</span></span><br><span class="line">                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));</span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv.xy + speed);</span><br><span class="line">                fixed3 reflDir = reflect(-viewDir, bump); <span class="comment">//根据视角方向和法线方向得到反射方向</span></span><br><span class="line">                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb * _Color.rgb; <span class="comment">//使用Cubemap进行采样并把结果和主纹理颜色相乘后得到反射颜色</span></span><br><span class="line">                </span><br><span class="line">                fixed fresnel = <span class="built_in">pow</span>(<span class="number">1</span> - saturate(dot(viewDir, bump)), <span class="number">4</span>); <span class="comment">//计算菲涅尔系数</span></span><br><span class="line">                fixed3 finalColor = reflCol * fresnel + refrCol * (<span class="number">1</span> - fresnel); <span class="comment">//混合折射和反射颜色，并作为最终的输出颜色</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do not cast shadow</span></span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>水面使用的噪声纹理是本书资源的 Water_Noise.png，只不过我们需要的是法线纹理，可以通过在它的纹理面板把纹理类型设置为 Normal Map，同时选中 Create from grayscale 来把灰度图生成法线纹理。将生成的法线纹理拖拽到 Wave Map 上，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/29/SJ8wQrMc2nfT5Zp.gif" width = "70%" height = "70%" alt="图81- 包含菲涅耳反射的水面波动效果。视角方向和水面法线的夹角越大，反射效果越强"/></div><h2 id="再谈全局雾效"><a href="#再谈全局雾效" class="headerlink" title="再谈全局雾效"></a>再谈全局雾效</h2><p>第十二章讲过如何使用深度纹理来实现一种基于屏幕后处理的全局雾效，效果是基于高度的均匀雾效，即在同一个高度上，雾的浓度是相同的。然而一些时候我们希望可以模拟一种不均匀的雾效，同时让雾不断飘动，使雾看起来更飘渺。而这就可以通过一张噪声纹理来实现。</p><p>本节的实现大部分和第十二章完全一样，只是增加了噪声相关参数和属性，准备工作如下：<br>①新建名为 Scene_15_3 的场景，并去掉天空盒；<br>②搭建雾效测试场景，3 面墙的房间，放置几个立方体；<br>③新建名为 FogWithNoise 的 C# 脚本，并拖拽给场景中的相机；<br>④新建名为 Chapter15-FogWithNoise 的 Unity Shader。</p><p>FogWithNoise.cs 的 C# 脚本代码如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FogWithNoise</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shader fogShader;</span><br><span class="line">    <span class="keyword">private</span> Material fogMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Material material &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);</span><br><span class="line">            <span class="keyword">return</span> fogMaterial;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Camera myCamera;</span><br><span class="line">    <span class="keyword">public</span> Camera camera &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCamera = GetComponent&lt;Camera&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCamera;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform myCameraTransform;</span><br><span class="line">    <span class="keyword">public</span> Transform cameraTransform &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (myCameraTransform == <span class="literal">null</span>) &#123;</span><br><span class="line">                myCameraTransform = camera.transform;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> myCameraTransform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(0.1f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogDensity = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> Color fogColor = Color.white;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogStart = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogEnd = <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Texture noiseTexture;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Range(-0.5f, 0.5f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogXSpeed = <span class="number">0.1f</span>;</span><br><span class="line">    [<span class="meta">Range(-0.5f, 0.5f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fogYSpeed = <span class="number">0.1f</span>;</span><br><span class="line">    [<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> noiseAmount = <span class="number">1.0f</span>; <span class="comment">//控制噪声的程度，当 noiseAmount 为 0 时，得到一个均匀的雾效</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">        GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//下面计算原理详见 12.3 章节</span></span><br><span class="line">            Matrix4x4 frustumCorners = Matrix4x4.identity;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">            <span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">            <span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">            Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">            Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line">            </span><br><span class="line">            Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">            <span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line">            </span><br><span class="line">            topLeft.Normalize();</span><br><span class="line">            topLeft *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">            topRight.Normalize();</span><br><span class="line">            topRight *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">            bottomLeft.Normalize();</span><br><span class="line">            bottomLeft *= scale;</span><br><span class="line">            </span><br><span class="line">            Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">            bottomRight.Normalize();</span><br><span class="line">            bottomRight *= scale;</span><br><span class="line">            </span><br><span class="line">            frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">            frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line">            </span><br><span class="line">            material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line"></span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">            material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">            material.SetTexture(<span class="string">&quot;_NoiseTex&quot;</span>, noiseTexture);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogXSpeed&quot;</span>, fogXSpeed);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_FogYSpeed&quot;</span>, fogYSpeed);</span><br><span class="line">            material.SetFloat(<span class="string">&quot;_NoiseAmount&quot;</span>, noiseAmount);</span><br><span class="line"></span><br><span class="line">            Graphics.Blit (src, dest, material);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chapter15-FogWithNoise 的  Shader 代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 15/Fog With Noise&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">    <span class="comment">//声明属性</span></span><br><span class="line">        _MainTex (<span class="string">&quot;Base (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _FogDensity (<span class="string">&quot;Fog Density&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _FogColor (<span class="string">&quot;Fog Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _FogStart (<span class="string">&quot;Fog Start&quot;</span>, Float) = <span class="number">0.0</span></span><br><span class="line">        _FogEnd (<span class="string">&quot;Fog End&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _NoiseTex (<span class="string">&quot;Noise Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _FogXSpeed (<span class="string">&quot;Fog Horizontal Speed&quot;</span>, Float) = <span class="number">0.1</span></span><br><span class="line">        _FogYSpeed (<span class="string">&quot;Fog Vertical Speed&quot;</span>, Float) = <span class="number">0.1</span></span><br><span class="line">        _NoiseAmount (<span class="string">&quot;Noise Amount&quot;</span>, Float) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">        </span><br><span class="line">        float4x4 _FrustumCornersRay; <span class="comment">//Unity 没有提供矩阵的属性，所以没在 Properties 中声明</span></span><br><span class="line">        </span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        half4 _MainTex_TexelSize;</span><br><span class="line">        sampler2D _CameraDepthTexture;</span><br><span class="line">        half _FogDensity;</span><br><span class="line">        fixed4 _FogColor;</span><br><span class="line">        <span class="type">float</span> _FogStart;</span><br><span class="line">        <span class="type">float</span> _FogEnd;</span><br><span class="line">        sampler2D _NoiseTex;</span><br><span class="line">        half _FogXSpeed;</span><br><span class="line">        half _FogYSpeed;</span><br><span class="line">        half _NoiseAmount;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            float2 uv : TEXCOORD0;</span><br><span class="line">            float2 uv_depth : TEXCOORD1;</span><br><span class="line">            float4 interpolatedRay : TEXCOORD2;        </span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        v2f <span class="title function_">vert</span><span class="params">(appdata_img v)</span> &#123;</span><br><span class="line">            v2f o;</span><br><span class="line">            o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">            o.uv = v.texcoord;</span><br><span class="line">            o.uv_depth = v.texcoord;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP <span class="comment">//适配不同平台</span></span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (v.texcoord.x &lt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                index = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">                index = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">            <span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">                index = <span class="number">3</span> - index;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            </span><br><span class="line">            o.interpolatedRay = _FrustumCornersRay[index];</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">            <span class="type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth)); <span class="comment">//根据深度纹理构建该像素在世界空间中的位置</span></span><br><span class="line">            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;    </span><br><span class="line">            </span><br><span class="line">            float2 speed = _Time.y * float2(_FogXSpeed, _FogYSpeed); <span class="comment">//计算雾的偏移量</span></span><br><span class="line">            <span class="type">float</span> noise = (tex2D(_NoiseTex, i.uv + speed).r - <span class="number">0.5</span>) * _NoiseAmount; <span class="comment">//对噪声纹理进行采样从而得到噪声值</span></span><br><span class="line">                    </span><br><span class="line">            <span class="type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart);         </span><br><span class="line">            fogDensity = saturate(fogDensity * _FogDensity * (<span class="number">1</span> + noise)); <span class="comment">//计算雾效混合系数</span></span><br><span class="line">            </span><br><span class="line">            fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);</span><br><span class="line">            <span class="keyword">return</span> finalColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        Pass &#123;              </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag  </span></span><br><span class="line">              </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Chapter15-FogWithNoise 拖拽到摄像机的脚本中的 Fog Shader 属性中，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/30/YK8PdcguWLUmRfQ.gif" width = "70%" height = "70%" alt="图82- ：使用噪声纹理后的非均匀雾效"/></div><h2 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>噪声纹理由计算机利用某些算法生成的，可以被认为是一种程序纹理 Procedure Texture。Perlin 纹理、Worley 纹理是比较常使用的噪声纹理类型。Perlin 噪声可以用于生成更自然的噪声纹理；Worley 噪声则通常用于模拟诸如石头、水、纸张等多孔噪声。有兴趣自行查阅资料。</p>]]></content>
      
      
      <categories>
          
          <category> unity </category>
          
          <category> unity shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> unity </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Unity Shader入门精要》读书笔记（三）</title>
      <link href="/2023/11/22/2023-11-22-UnityShader3/"/>
      <url>/2023/11/22/2023-11-22-UnityShader3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本读书笔记为中级篇，主要内容为更复杂的光照的前向渲染、延迟渲染、光照衰减和阴影；高级纹理的立方体纹理、渲染纹理和程序纹理；动画的纹理动画和顶点动画。<br>读书笔记是对知识的记录与总结，但是对比较熟悉的内容不会再行描述。</p></blockquote><h1 id="第八章-更复杂的光照"><a href="#第八章-更复杂的光照" class="headerlink" title="第八章 更复杂的光照"></a>第八章 更复杂的光照</h1><p>在前面的学习中，场景中仅有一个光源且光源类型是平行光。但是在实际的游戏开发中，往往需要处理数量更多、类型更复杂的光源。更重要的是，想要得到阴影。本章最后会给出包含了完整光照计算的 Unity Shader。</p><h2 id="Unity-的渲染路径"><a href="#Unity-的渲染路径" class="headerlink" title="Unity 的渲染路径"></a>Unity 的渲染路径</h2><p>在 Unity 中，<strong>渲染路径 Rendering Path</strong> 决定了光照是如何应用到 Unity Shader 中的。我们需要为每个 Pass 指定它使用的渲染路径，这样才能让它告诉 Unity 光源和处理后的光照信息从哪些数据中去取。</p><p>Unity 5.0 之前，有 3 种渲染路径：<strong>前向渲染路径 Forward Rendering Path</strong>、<strong>延迟渲染路径 Deferred Rendering Path</strong> 和<strong>顶点照明渲染路径 Vertex Lit Rendering Path</strong>。Unity 5.0 之后，顶点照明渲染路径已不建议使用（但 Unity 依然兼容）；且新的延迟渲染路径代替了原来的延迟渲染路径（老版本的延迟渲染路径在 Unity 中依然兼容）。</p><p>大多数情况下，一个项目只会使用一种渲染路径。可以为整个项目设置渲染时的渲染路径：Edit -&gt; Project Settings -&gt; Graphics -&gt; Tier Settings -&gt; Rendering Path。但有时，希望可以使用多个渲染路径，例如摄像机 A 渲染的物体使用前向渲染路径，摄像机 B 渲染的物体使用延迟渲染路径，可以在每个摄像机组件的 Rendering Path 修改，以覆盖 Project Settings 中的设置。如果当前显卡不支持所选择的渲染路径，Unity 会自动使用更低一级的渲染路径。比如：GPU 不支持延迟渲染，则会使用前向渲染。</p><p>完成设置后，就可以在 Unity Shader 的 Pass 中设置标签 LightMode。</p><pre><code>Pass &#123;    Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</code></pre><p>下表给出了 Pass 的 LightMode 标签支持的渲染路径设置选项：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">标签名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Always</td><td style="text-align:left">不管使用哪种渲染路径，该 Pass 总会被渲染，但不会计算任何光照</td></tr><tr><td style="text-align:left">ForwardBase</td><td style="text-align:left">用于<strong>前向渲染</strong>。该 Pass 会计算环境光、最重要的平行光，逐顶点/SH 光源和 Lightmaps</td></tr><tr><td style="text-align:left">ForwardAdd</td><td style="text-align:left">用于<strong>前向渲染</strong>。该 Pass 会计算额外的逐像素光源，每个 Pass 对应一个光源</td></tr><tr><td style="text-align:left">Deferred</td><td style="text-align:left">用于<strong>延迟渲染</strong>。该 Pass 会渲染 G 缓冲(G-buffer)</td></tr><tr><td style="text-align:left">ShadowCaster</td><td style="text-align:left">把物体的深度信息渲染到阴影映射纹理(shadowmap)或一张深度纹理中</td></tr><tr><td style="text-align:left">PrepassBase</td><td style="text-align:left">用于<strong>遗留的延迟渲染</strong>。该 Pass 会渲染法线和高光反射的指数部分</td></tr><tr><td style="text-align:left">PrepassFinal</td><td style="text-align:left">用于<strong>遗留的延迟渲染</strong>。该 Pass 通过合并纹理、光照和自发光来渲染得到最后的颜色</td></tr><tr><td style="text-align:left">Vertex、VertexLMRGBM 和 VertexLM</td><td style="text-align:left">用于<strong>遗留的顶点照明渲染</strong></td></tr></tbody></table></div><p>指定渲染路径是我们和 Unity 底层渲染引擎的一次重要的沟通。Unity 会根据 Pass 中 LightMode 标签的设置，对一些内置光照变量进行赋值。如果没有设置标签或设置了不正确的标签，当我们调用光照变量时，会得到不正确的结果。如果没有指定任何渲染路径，在 Unity 5.x 版本中会被当成一个和顶点照明渲染路径等同的 Pass。</p><h3 id="前向渲染路径"><a href="#前向渲染路径" class="headerlink" title="前向渲染路径"></a>前向渲染路径</h3><p>前向渲染路径是传统的渲染方式，也是最常用的一种渲染路径。</p><h4 id="前向渲染路径的原理"><a href="#前向渲染路径的原理" class="headerlink" title="前向渲染路径的原理"></a>前向渲染路径的原理</h4><p>每进行一次完整的前向渲染，我们需要渲染该对象的图元，并计算两个缓冲区的信息：颜色缓冲区、深度缓冲区。先根据深度缓冲来决定一个片元是否可见，如果可见再更新颜色缓冲区中的颜色值。下面伪代码描述了大致的过程：  </p><pre><code>Pass &#123;    for (each primitive in this model) &#123;        for (each fragment covered by this primitive) &#123;            if (failed in depth test) &#123;                // 如果没有通过深度测试，说明该片元不可见                discard;            &#125;            else &#123;                // 如果该片元可见，则进行光照计算                float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);                // 更新帧缓冲                writeFrameBuffer(fragment, color);            &#125;        &#125;    &#125;&#125;</code></pre><p>每个逐像素光源都需要进行上述渲染流程。如果一个物体受到多个逐像素光源的影响，则需要执行多个 Pass，每个 Pass 计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合，得到最终的颜色值。Pass 执行次数 = N 个物体 * M 个光源。渲染引擎会限制每个物体的逐像素光照数目，以此来限制 Pass 执行的次数。</p><h4 id="Unity-中的前向渲染"><a href="#Unity-中的前向渲染" class="headerlink" title="Unity 中的前向渲染"></a>Unity 中的前向渲染</h4><p>Unity 中，前向渲染路径有 3 种处理光照的方式：<strong>逐顶点处理</strong>、<strong>逐像素处理</strong>、<strong>球谐函数 Spherical Harmonics, SH 处理</strong>。</p><p>而决定一个光源使用哪种处理模式取决于它的<strong>类型 Type</strong> 和<strong>渲染模式 Render Mode</strong>（光源的 Light 组件中可以设置这些属性）。光源类型指的是该光源是平行光、点光或者聚光，而光源的渲染模式指的是该光源是否是<strong>重要的 Important</strong>，如果把一个光照模式设置为 Important，意味着我们希望 Unity 认真对待它，把它当作逐像素光源来处理。</p><p>在前向渲染中，当我们渲染一个物体时，Unity 会根据场景中各个光源的设置以及这些光源对物体的影响程度（比如距离物体远近、光源强度等）对这些光源进行一个重要度排序。其中，一定数目的光源会按逐像素的方式处理，然后最多有 4 个光源按逐顶点的方式处理，剩下的光源可以按 SH 方式处理，Unity 使用的判断规则如下：<br>①场景中最亮的平行光总是按逐像素处理；<br>②渲染模式被设置成 <strong>Not Important</strong> 的光源，会按逐顶点或 SH 处理；<br>③渲染模式被设置成 <strong>Important</strong> 的光源，会按逐像素处理；<br>④如果根据以上规则得到的像素光源数量小于 <strong>Quality Setting</strong> 中的逐像素光源数量 Pixel Light Count，会有更多的光源以逐像素的方式进行渲染。</p><p>在 Pass 中进行光照计算时，前向渲染一共有两种：Base Pass 和 Addtional Pass。通常来说，这两种 Pass 进行的标签和渲染设置以及常规光照计算如下图所示：</p><div  align="center">  <img src="https://s2.loli.net/2023/11/23/q8WythHV5gzfed9.jpg" width = "60%" height = "60%" alt="图35- 前向渲染的两种 Pass"/></div><p>上图的说明：<br>①在渲染设置中，除了设置了 Pass 标签外，还使用了 <strong>#pragma multi_compile_fwdbase</strong> 和 <strong>#pragma multi_compile_fwdadd</strong> 这样的编译指令。这些编译指令会保证 Unity 为相应类型的 Pass 生成需要的 Shader 变种，这些变种会处理不同条件下的渲染逻辑，比如是否使用光照贴图、当前处理哪些光源类型、是否开启了阴影等，同时 Unity 也会在背后声明内置变量传递给 Shader 中。总的来说，只有分别为 Base Pass 和 Addtional Pass 使用以上指令才可以在 Pass 中得到一些正确的光照变量，例如光照衰减值等。<br>②Base Pass 旁边的注释给出了 Base Pass 中支持的一些光照特性，例如在 Base Pass 中，可以访问光照纹理 lightmap。<br>③Base Pass 中的渲染的平行光默认是支持阴影的（如果开启了光源的阴影功能），而 Addtional Pass 中渲染的光源在默认情况下是没有阴影效果的，即便我们在它的 Light 组件中设置了有阴影的 Shadow Type 也无济于事。但是在 Additional Pass 中，使用 #pragma multi_compile_fullshadows 代替 #pragma multi_compile_fwdadd 编译指令，为点光源和聚光灯开启阴影效果，但这需要 Unity 在内部使用更多的 Shader 变种。<br>④环境光和自发光也是在 Base Pass 中计算的。这是因为，对于一个物体来说，环境光和自发光我们只希望计算一次即可，而如果在 Addtional Pass 中计算这两种光照，就会造成叠加多次环境光和自发光，不是我们想要的。<br>⑤在 Addtional Pass 的渲染设置中，我们还开启和设置了混合模式。我们希望每个 Addtional Pass 可以与上一次的光照结果在帧缓存中进行叠加，从而得到最终的有多个光照的渲染效果。如果我们没有开启和设置混合模式，那么 Addtional Pass 的渲染结果会覆盖掉之前的渲染结果，看起来就好像该物体只受该光源影响。通常情况下，选择的混合模式是 <strong>Blend One One</strong>。<br>⑥对于前向渲染来说，一个 Unity Shader 通常会定义一个 Base Pass (也可以定义多次，例如双面渲染的情况)以及一个 Additional Pass。一个 Base Pass 只会执行一次(定义了多个 Base Pass 的情况除外)，而一个 Additional Pass 的渲染结果会根据影响该物体的其他逐像素光源的数目被调用多次，即每个逐像素光源都会调用一次 Addtional Pass。</p><p>上述给出的光照计算是通常情况下我们在每种 Pass 中进行的计算。实际上渲染路径的设置用于告诉 Unity 该 Pass 在前向渲染路径中的位置，然后底层的渲染引擎会进行相关计算并填充一些内置变量，至于怎么使用内置变量完全看开发者。</p><h4 id="内置的光照变量和函数"><a href="#内置的光照变量和函数" class="headerlink" title="内置的光照变量和函数"></a>内置的光照变量和函数</h4><p>对于前向渲染（即 LightMode 为 <strong>ForwardBase</strong> 和 <strong>ForwardAdd</strong>）来说，可以访问到以下变量：</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">_LightColor0</td><td style="text-align:left">float4</td><td style="text-align:left">该 Pass 处理的逐像素光源的颜色</td></tr><tr><td style="text-align:left">_WorldSpaceLightPos0</td><td style="text-align:left">float4</td><td style="text-align:left">_WorldSpaceLightPos0.xyz 是该 Pass 处理的逐像素光源的位置，如果该光源是平行光源，那么 _WorldSpaceLightPos.w 是 0，其他光源类型 w 的值为 1</td></tr><tr><td style="text-align:left">_LightMatrix0</td><td style="text-align:left">float4x4</td><td style="text-align:left">从世界空间到光源空间的变换矩阵，可以用于采样 cookie 和光强衰减 attenuation 纹理</td></tr><tr><td style="text-align:left">unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0</td><td style="text-align:left">float4</td><td style="text-align:left">仅用于 Base Pass，前 4 个非重要的点光源在世界空间中的位置</td></tr><tr><td style="text-align:left">unity_4LightAtten0</td><td style="text-align:left">float4</td><td style="text-align:left">仅用于 Base Pass，存储了前 4 个非重要的点光源的衰减因子</td></tr><tr><td style="text-align:left">unity_LightColor</td><td style="text-align:left">half4[4]</td><td style="text-align:left">仅用于 Base Pass，存储了前 4 个非重要的点光源的颜色</td></tr></tbody></table></div><p>前向渲染中可以使用的内置函数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">float3 WorldSpaceLightDir(float4 v)</td><td style="text-align:left"><strong>仅可用于前向渲染中</strong>。输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向。内部实现使用了 UnityWorldSpaceLightDir 函数，没有被归一化</td></tr><tr><td style="text-align:left">float3 UnityWorldSpaceLightDir(float4 v)</td><td style="text-align:left"><strong>仅可用于前向渲染中</strong>。输入一个世界空间中的顶点位置，返回世界空间中从该点到光源的光照方向，没有被归一化</td></tr><tr><td style="text-align:left">float3 ObjSpaceLightDir(float4 v)</td><td style="text-align:left"><strong>仅可用于前向渲染中</strong>。输入一个模型空间中的顶点位置，返回模型空间中从该点到光源的光照方向，没有被归一化</td></tr><tr><td style="text-align:left">float3 Shade4PointLights(…)</td><td style="text-align:left"><strong>仅可用于前向渲染中</strong>。计算四个点光源的光照，它的参数是已经打包进矢量的光照数据，通常就是上一个表格中的内置变量，前向渲染通常会使用这个函数来计算逐顶点光照</td></tr></tbody></table></div><p>上面列出的内置变量和函数只是一部分，后面学习中会用到其他一些变量和函数。</p><h3 id="顶点照明渲染路径"><a href="#顶点照明渲染路径" class="headerlink" title="顶点照明渲染路径"></a>顶点照明渲染路径</h3><p>顶点照明渲染路径是对硬件配置要求最少、运算性能最高，但同时得到效果最差的一种类型。它仅支持逐顶点的光源计算，不支持逐像素，所以无法得到：阴影、法线映射、高精度的高光反射等效果，它是前向渲染的一个子集。</p><h4 id="Unity-中的顶点照明渲染"><a href="#Unity-中的顶点照明渲染" class="headerlink" title="Unity 中的顶点照明渲染"></a>Unity 中的顶点照明渲染</h4><p>顶点照明渲染路径通常在一个 Pass 中就可以完成对物体的渲染，在这个 Pass 中，我们会计算关心的光源对物体的照明，且是按照逐顶点处理的。它是 Unity 中最快速的渲染路径，且具有最广泛的硬件支持（游戏机上不支持这种路径）。Unity 5 以后被作为一个遗留的渲染路径，未来的版本中可能会被移除。</p><h4 id="可访问的内置变量和函数"><a href="#可访问的内置变量和函数" class="headerlink" title="可访问的内置变量和函数"></a>可访问的内置变量和函数</h4><p>在 Unity 中一个顶点照明的 Pass 中最多可以访问 8 个逐顶点光源。顶点照明渲染路径中可以使用的内置变量：</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">unity_LightColor</td><td style="text-align:left">half4[8]</td><td style="text-align:left">光源颜色</td></tr><tr><td style="text-align:left">unity_LightPosition</td><td style="text-align:left">float4[8]</td><td style="text-align:left">xyz 分量是视角空间中的光源位置。如果光源是平行光，那么 z 分量值为 0，其他光源类型 z 分量值为 1</td></tr><tr><td style="text-align:left">unity_LightAtten</td><td style="text-align:left">half4[8]</td><td style="text-align:left">光源衰减因子，如果光源是聚光灯，x 分量 cos(spotAngle/2)，y 分量是 1/cos(spotAngle/4)。如果是其他类型的光源，x 分量是 -1，y 分量是 1，z 分量是衰减的平方，w 分量是光源范围开更号的结果</td></tr><tr><td style="text-align:left">unity_SpotDirection</td><td style="text-align:left">float4[8]</td><td style="text-align:left">如果光源是聚光灯的话，值为视角空间的聚光灯的位置；如果是其他类型的光源，值为(0， 0， 1， 0)</td></tr></tbody></table></div><p>如果影响该物体的光源数目小于 8，则数组中剩余的光源颜色会被设置成黑色。有些变量我们同样可以在前向渲染路径中使用，如：unity_LightColor，但这些变量的数组的维度和数值在不同渲染路径下的值是不同的。</p><p>顶点照明渲染路径中可以使用的内置函数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">float3 ShadeVertexLights(float4 vertex, float3 normal)</td><td style="text-align:left">输入模型空间中的顶点位置和法线，计算四个逐顶点光源的光照以及环境光，内部实现实际上调用了 ShadeVertexLightsFull 函数</td></tr><tr><td style="text-align:left">float3 ShadeVertexLightsFull(float4 vertex, float3 normal, int lightCount, bool spotLight)</td><td style="text-align:left">输入模型空间中的顶点位置和法线，计算 lightCount 个光源的光照以及环境光，如果 spotLight 值为 true，那么这些光源会被当成聚光灯来处理，虽然结果更精确，但计算更加耗时，否则按点光源处理</td></tr></tbody></table></div><h3 id="延迟渲染路径"><a href="#延迟渲染路径" class="headerlink" title="延迟渲染路径"></a>延迟渲染路径</h3><p>前向渲染的问题是：当场景中包含大量实时光源，使用前向渲染会造成性能急剧下降。每个光源会导致每个物体都会执行多个 Pass，每执行一个 Pass 都重复地渲染一遍物体会存在很多相同的重复计算。</p><p>延迟渲染是一种更古老的渲染方式，除了前向渲染中使用的颜色缓冲和深度缓冲外，延迟渲染还使用了额外的缓冲区。这些缓冲区也被称为 <strong>G 缓冲</strong>（<strong>Geometry Buffer</strong>，<strong>G-buffer</strong>）。G 缓冲区存储了我们关心的表面（通常指离相机最近的表面）的其他信息，如：表面的法线、位置、用于光照计算的材质属性等。</p><h4 id="延迟渲染的原理"><a href="#延迟渲染的原理" class="headerlink" title="延迟渲染的原理"></a>延迟渲染的原理</h4><p>延迟渲染主要包含了两个 Pass。在第一个 Pass 中，不进行任何光照计算，而是仅仅计算哪些片元是可见的，这主要是通过深度缓冲技术来实现，当发现一个片元是可见的，我们就把它的相关信息存储到 G 缓冲区中。然后，在第二个 Pass 中，利用 G 缓冲区中的各个片元信息，例如表面法线、视角方向、漫反射系数等进行真正的光照计算。  </p><p>大致可以用下面的伪代码来描述：  </p><pre><code>Pass 1 &#123;    // 第一个 Pass 不进行真正的光照计算，仅仅把光照计算需要的信息存储到 G 缓冲中    for (each primitive in this model) &#123;        for (each fragment covered by this primitive) &#123;            if (failed in depth test) &#123;                // 如果没有通过深度测试，说明该片元是不可见的                discard;            &#125; else &#123;                // 如果该片元可见，就把需要的信息存储到G缓冲中                writeGbuffer(materialInfo, pos, normal, lightDir, viewDir)            &#125;        &#125;    &#125;&#125;Pass 2 &#123;    // 利用 G 缓冲中的信息进行真正的光照计算    for (each pixel in the screen) &#123;         if (the pixel is valid) &#123;             // 如果像素是有效的             // 读取它对应的 G 缓冲中的信息             readGBuffer(pixel, materialInfo, pos, normal, lightDir, viewDir)             // 根据读取到的信息进行光照计算             float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);             // 更新帧缓冲             writeFrameBuffer(pixel, color);         &#125;    &#125;&#125;</code></pre><p>延迟渲染使用的 Pass 数目通常是2个，与场景中包含的光源数目没有关系，和屏幕的大小有关。</p><h4 id="Unity-中的延迟渲染"><a href="#Unity-中的延迟渲染" class="headerlink" title="Unity 中的延迟渲染"></a>Unity 中的延迟渲染</h4><p>目前 Unity 有 2 种延迟渲染路径：一种是遗留的延迟渲染路径，一种是 Unity 5 及以后使用的延迟渲染路径。如果游戏中使用了大量的实时光照，那么可以选择延迟渲染路径，但是这种路径需要一定的硬件支持。</p><p>新旧延迟渲染路径之间的差别很小，只是使用了不同的技术来权衡不同的需求，比如：旧版的延迟渲染路径不支持 Unity 5 以后版本的基于物理的 Standard Shader。</p><p>延迟渲染适合在光源数目众多、使用前向渲染造成性能瓶颈的情况下使用，每个光源都可以按逐像素处理。但它也有缺点：<br>①不支持真正的<strong>抗锯齿 anti-aliasing</strong> 功能；<br>②不能处理半透明物体；<br>③对显卡有要求，必须支持 MRT（Multiple Render Targets）、Shader Mode 3.0 及以上、深度渲染纹理以及双面的模板缓冲。</p><p>当使用延迟渲染，Unity 提供了两个 Pass：<br>①第一个 Pass 用于渲染 G 缓冲。该 Pass 中把物体的漫反射颜色、高光反射颜色、平滑度、法线、自发光和深度等信息渲染到屏幕空间的 G 缓冲区中对每个物体来说，这个 Pass 仅执行一次。<br>②第二个 Pass 用于计算真正的光照模型。这个 Pass 会使用上一个 Pass 中渲染的数据来计算最终的颜色光照颜色，再存储到帧缓冲中。</p><p>默认的 G 缓冲区包含了以下几个<strong>渲染纹理 Render Texture，RT</strong>（不同版本的 Unity 可能会不同）：<br>①RT0：ARGB32 格式，RBG 通道存储漫反射颜色，A 通道未被使用；<br>②RT1：ARGB32 格式，RGB 通道存储高光反射颜色，A 通道存储高光反射的指数部分；<br>③RT2：ARGB2101010 格式，RGB 通道存储法线，A 通道未被使用；<br>④RT3：ARGB32 格式（非 HDR）或 ARGBHalf（HDR），用于存储自发光 + lightmap + 反射探针（reflection probes）；<br>⑤深度缓冲和模板缓冲。</p><p>第二个 Pass 计算光照，默认情况下仅可以使用 Unity 内置的 Standard 光照模型。若想使用其他模型，需要替换掉原来的 Internal-DeferredShading.shader 文件，详见信息见 <a href="http://docs.unity3d.com/Manual/RenderTech-DeferredShading.html">docs.unity3d.com/Manual/RenderTech-DeferredShading.html </a></p><h4 id="可访问的内置变量和函数-1"><a href="#可访问的内置变量和函数-1" class="headerlink" title="可访问的内置变量和函数"></a>可访问的内置变量和函数</h4><p>延迟渲染路径中可以使用的内置变量，这些变量可以在 UnityDeferredLibrary.cginc 文件中找到声明：</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">_LightColor</td><td style="text-align:left">float4</td><td style="text-align:left">光源颜色</td></tr><tr><td style="text-align:left">_LightMatrix0</td><td style="text-align:left">float4x4</td><td style="text-align:left">从世界空间到光源空间的变换矩阵，可以用于采样 cookie 和光强衰减纹理</td></tr></tbody></table></div><h3 id="选择哪种渲染路径"><a href="#选择哪种渲染路径" class="headerlink" title="选择哪种渲染路径"></a>选择哪种渲染路径</h3><p>Unity 的官方文档（<a href="http://docs.unity3d.com/Manual/RenderingPaths.html">docs.unity3d.com/Manual/RenderingPaths.html</a>）中给出了渲染路径的详细比较，包括它们的特性比较（是否支持逐像素光照、半透明物体、实时阴影等）、性能比较以及平台支持。</p><p>总的来说，需要根据渲染平台来选择渲染路径。如果当前显卡不支持当前渲染路径，Unity 会自动使用低一级的渲染路径。</p><p>本书中，主要使用 Unity 的前向渲染路径。</p><h2 id="Unity-的光源类型"><a href="#Unity-的光源类型" class="headerlink" title="Unity 的光源类型"></a>Unity 的光源类型</h2><p>Unity 一共支持 4 种光源类型：平行光、点光源、聚光灯和面光源。面光源仅在烘焙时才有用，不在我们讨论的范围。由于每种光源的几何定义不同，因此它们对应的光源属性也不同。</p><h3 id="光源类型有什么影响"><a href="#光源类型有什么影响" class="headerlink" title="光源类型有什么影响"></a>光源类型有什么影响</h3><p>光源的不同属性会对 Shader 带来影响。最常使用的光源属性有：光源的位置、方向（到某点的方向）、颜色、强度以及衰减（到某点的衰减，与点到光源的距离有关）。这些属性和光源的几何定义息息相关。</p><p>①平行光<br>平行光可以照亮的范围是没有限制的，它通常作为太阳这样的角色在场景中出现，它没有位置的概念，将它放到场景中任意位置都不影响光照的效果，它的几何属性只有方向，通过调整 Transform 组件中的 Rotation 属性来改变它的光源方向。平行光也没有衰减的概念，即光照强度不会随着距离而发生改变。</p><p>②点光源<br>点光源的照亮空间是有限的，由空间中的一个球体定义的，点光源可以表示由一个点发出的、向所有方向延展的光。球体的半径可以由面板中的 Range 属性来调整，也可以在 Scene 视图中直接拖拉点光源的线框来修改它的属性。</p><p>点光源是有位置属性的，由光源的 Transform 组件中的 Position 属性定义。对于方向属性，我们需要用点光源的位置减去某点的位置得到它到该点的方向。点光源的颜色和强度可以在 Light 组件中调整，同时点光源是会衰减的，随着物体逐渐远离点光源，它接受的光照强度也会越弱。点光源球心处的光照强度最强，球体边界处的最弱，值为 0。其中间的衰减值可以由一个函数定义。</p><p>③聚光灯<br>聚光灯由空间中的一个锥形区域定义。锥形区域的半径由面板中的 Range 属性决定，锥形的张开角度由 Spot Angle 属性决定。同样可以在 Scene 视图中直接拖拉聚光灯的线框来改变它的属性。同样，对于方向属性，可以用聚光灯的位置减去某点的位置得到它到该点的方向。聚光灯的衰减随物体的远离逐渐减小，锥形的顶点处光照强度最强，锥形的边界处强度为0，中间的衰减值可由一个函数定义，这个函数相比点光源衰减的计算公式更加复杂，因为需要判断一个点是否在椎体的范围内。</p><h3 id="在前向渲染中处理不同的光源类型"><a href="#在前向渲染中处理不同的光源类型" class="headerlink" title="在前向渲染中处理不同的光源类型"></a>在前向渲染中处理不同的光源类型</h3><p>下面来看如何在 Unity Shader 中访问它们的属性：位置、方向、颜色、强度和衰减。本节使用的是前向渲染。</p><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p><strong><em>1. 准备工作</em></strong><br>①新建名为 Scene_9_2_2_1 的场景，并去掉天空盒子；<br>②新建名为 ForwardRenderingMat 的材质；<br>③新建名为 Chapter9-ForwardRendering 的 Unity Shader，并赋给上一步的材质；<br>④在场景中创建一个胶囊体，并将第二步创建的材质赋给它；<br>⑤为了让胶囊体受到多个光源的影响，在场景中新建一个点光源，并将颜色设为绿色（和平行光区分开）；<br>⑥保存场景。</p><p><strong><em>2. 编写 Shader</em></strong><br>将之前笔记中写过的 Chapter6-BlinnPhong 代码复制覆盖到 Chapter9-ForwardRendering 文件中，做部分修改。关于光源属性的访问代码已用注释说明，代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 9/Forward Rendering&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Diffuse(<span class="string">&quot;Diffuse&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular(<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss(<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Base pass，处理环境光和第一个逐像素光照（平行光）</span></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行该指令，让前向渲染路径的光照衰减等变量可以被正确赋值，不可缺少</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 环境光只需要计算在 Base Pass 中计算一次即可，Additional Pass 不会再计算。自发光同理，但本例中，假设无自发光效果。</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若场景中包含了多个平行光，Unity 会选择最亮的平行光传递给 Base Pass 进行逐像素处理，其他平行光会按照逐顶点或在 Additional Pass 中按逐像素的方式处理。如果场景中没有任何平行光，那么 Base Pass 会当成全黑的光源处理。</span></span><br><span class="line">                <span class="comment">// 对于 Base Pass 来说，处理逐像素光源类型一定是平行光，可以使用 _WorldSpaceLightPos0 得到这个平行光的方向；使用 _LightColor0 得到平行光的颜色和强度（_LightColor0 已经是颜色和强度相乘后的结果）</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(max(<span class="number">0</span>, dot(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 因为平行光没有衰减，直接令衰减值为 1.0</span></span><br><span class="line">                fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Additional pass，处理其他逐像素光照。Additional pass 中的顶点、片元着色器代码是根据 Base Pass 中的代码复制修改得到的，这些修改一般包括：去掉 Base Pass 中的环境光、自发光、逐顶点光照、SH 光照（球谐光照）的部分，并添加一些对不同光源类型的支持。</span></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardAdd&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开启混合模式，因为希望帧缓冲中的颜色值和之前的光照结果进行叠加。如果没有使用 Blend 命令的话，Additional Pass 会直接覆盖掉之前的光照结果。本例中，选择的混合系数是 Blend One One，也可以使用其他 Blend 指令，比如：Blend SrcAlpha One</span></span><br><span class="line">            Blend One One</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同样执行该指令，保证 Additional Pass 中访问到正确的光照变量</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdadd</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//由于 Additional Pass 处理的光源类型可能是平行光、点光源或聚光灯。通过使用 #ifdef 指令判断是否定义了 USING_DIRECTIONAL_LIGHT。若当前前向渲染 Pass 处理的光源类型是平行光，那么 Unity 的底层就会定义 USING_DIRECTIONAL_LIGHT。</span></span><br><span class="line">                <span class="meta">#<span class="keyword">ifdef</span> USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">                    <span class="comment">// 若判断是平行光，方向可以直接通过 _WorldSpaceLightPos0.xyz 得到</span></span><br><span class="line">                    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                    <span class="comment">// 若判断是点光源或聚光灯，_WorldSpaceLightPos0 表示世界空间下的光源位置，需要减去世界空间下的顶点位置才能得到光源方向</span></span><br><span class="line">                    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);</span><br><span class="line">                <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用 _LightColor0 得到光源（可能是平行光、点光源或聚光灯）的颜色和强度</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(max(<span class="number">0</span>, dot(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理不同光源的衰减</span></span><br><span class="line">                <span class="meta">#<span class="keyword">ifdef</span> USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">                    <span class="comment">// 若为平行光，不衰减，衰减值为 1.0</span></span><br><span class="line">                    fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                    <span class="comment">// 若为其他光源，可以使用数学公式来计算衰减，但这些计算往往涉及开根号等计算量大的操作。因此 Unity 选择使用一张纹理作为查找表（Lookup Table, LUT），以在片元着色器中得到光源的衰减</span></span><br><span class="line">                    <span class="comment">// 首先将片元的坐标由世界空间转到光源空间，再对衰减纹理进行采样得到衰减值</span></span><br><span class="line">                    float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>)).xyz;</span><br><span class="line">                    fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">                <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fallback <span class="string">&quot;Specular&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到如下效果：</p><div  align="center">  <img src="https://s2.loli.net/2023/11/27/xM2JtD8bZmwKSdr.png" width = "70%" height = "70%" alt="图36- 使用一个平行光和一个点光源共同照亮物体。"/></div><h4 id="实验：Base-Pass-和-Additional-Pass-的调用"><a href="#实验：Base-Pass-和-Additional-Pass-的调用" class="headerlink" title="实验：Base Pass 和 Additional Pass 的调用"></a>实验：Base Pass 和 Additional Pass 的调用</h4><p>为了更直观地理解前向渲染的细节，接下来通过实验学习了解：</p><p><strong><em>1. 准备工作</em></strong><br>①新建名为 Scene_9_2_2_2 的场景，并去掉天空盒子；<br>②将平行光的颜色调为绿色；<br>③在场景中创建一个胶囊体，将上一节的 ForwardRenderingMat 材质赋给该胶囊体；<br>④新建 4 个点光源，颜色调整成相同的红色；<br>⑤保存场景。</p><p>得到如下效果：</p><div  align="center">  <img src="https://s2.loli.net/2023/11/27/aejdl6LvOsbHEtf.png" width = "70%" height = "70%" alt="图37- 使用1个平行光 + 4个点光源照亮一个物体。"/></div><p>当我们创建一个光源时，它的默认 Render Mode（Light 组件中设置）是 Auto，意味着 Unity 会自动为我们判断哪些光源会逐像素处理，哪些会逐顶点或球谐（SH）的方式处理。</p><p>由于我们没有更改 Edit -&gt; Project Settings -&gt; Quality -&gt; Pixel Light Count 中，因此默认情况下，一个物体可以接收出除最亮的平行光外的 4 个逐像素光照。</p><p>而除了平行光在 Base Pass 中按逐像素的方式被处理，场景里刚好有 4 个点光源，它们的 Render Mode 为 Auto，因此它们会在 Additional Pass 中以逐像素的方式被处理，每个光源调用一次 Additional Pass。</p><p><strong><em>2. 使用帧调试器 Frame Debugger 来查看场景的绘制过程</em></strong><br>Window -&gt; Analysis -&gt; Frame Debugger，点击 Enable 按钮可以看到场景的渲染事件（这里图就不放出来了）</p><p>可以看到渲染胶囊体一共有 6 个关键事件（包括 Clear），它们分别为：在第一个，即 Clear 渲染事件中，Unity 首先清除颜色、深度和模板缓冲，为后续渲染做准备；在第二个渲染事件中，Unity 使用第一个 Pass，即 Base Pass，将平行光的光照渲染到帧缓存中；在后面的四个渲染事件中，Unity 使用第二个 Pass，即 Additional Pass，依次将 4 个点光源的光照应用到物体上，得到最后的渲染结果。</p><p>Unity 处理这些点光源的顺序是按照它们的重要度排序的。在这个例子中，由于所有点光源的颜色和强度都相同，因此它们的重要度取决于它们距离胶囊体的远近。若光源的强度和颜色互不相同，那么距离就不再是唯一的衡量标准。Unity 官方文档中，并没有给出上述三个影响因素是如何具体影响排序的，我们仅知道排序结果和这三者都有关系。</p><p>如果我们将点光源的 Render Mode 设置为 Not Important，因为我们没有在 Shader 的 Base Pass 中计算逐顶点和球谐 SH 光源，因此这 4 个点光源不会对物体产生任何光照效果。若把平行光的 Render Mode 也设置为 Not Important，物体就会仅显示环境光的光照结果。</p><h2 id="Unity-的光照衰减"><a href="#Unity-的光照衰减" class="headerlink" title="Unity 的光照衰减"></a>Unity 的光照衰减</h2><p>之前提到过，Unity 使用一张纹理作为查找表来在片元着色器中计算逐像素光照的衰减。这样计算衰减不依赖于数学公式，只需要使用一个参数值去纹理采样即可。但是使用纹理也有弊端：<br>①需要预处理得到纹理采样，而且纹理大小会影响衰减的精度；<br>②不直观，不方便，一旦把数据存储到查找表中，就无法使用其他数学公式来计算衰减。</p><p>由于这种方法在一定程度上可以提升性能，而且得到的效果在大部分情况下都是良好的，因此 Unity 默认使用这种纹理查找的方法来计算逐像素的点光源和聚光灯的衰减。</p><h3 id="用于光照衰减的纹理"><a href="#用于光照衰减的纹理" class="headerlink" title="用于光照衰减的纹理"></a>用于光照衰减的纹理</h3><p>Unity 内部使用一张名为 _LightTexture0 的纹理来计算光照衰减（使用 cookie 的光源的衰减查找纹理是 _LightTextureB0）。</p><p>我们通常只关心 _LightTexture0 对角线上的纹理颜色值，这些值表明了在光源空间中不同位置的点的衰减值。（0，0）表示与光源位置重合的点的衰减值，而（1，1）表示在光源空间中距离最远的点的衰减。</p><p>为了对 _LightTexture0 衰减纹理采样得到给定点到光源的衰减值，需要得到该点在光源空间的位置，可以通过 _LightMatrix0 矩阵把给定点的坐标由世界空间转到光源空间：<code>float3 lightCoord = mul(_LightMatrix0, float4(i.worldPosition, 1)).xyz;</code>。然后，使用这个坐标的模的平方对衰减纹理进行采样，得到衰减值：<code>fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</code>。之所以使用光源空间中顶点距离的平方（通过 dot 函数得到）是为了避免开方操作，然后使用宏 UNITY_ATTEN_CHANNEL 来得到衰减纹理中衰减值所在的分量，得到最终的衰减值。</p><h3 id="使用数学公式计算衰减"><a href="#使用数学公式计算衰减" class="headerlink" title="使用数学公式计算衰减"></a>使用数学公式计算衰减</h3><p>下面代码可以计算光源的线性衰减：  </p><pre><code>float distance = length(_WorldSpaceLightPos0.xyz - i.worldPosition.xyz);atten = 1.0 / distance; </code></pre><p>Unity 文档中没有给出内置衰减计算的相关说明，我们无法在 Shader 中通过内置变量得到光源的范围、聚光灯的朝向、张开角度等信息，因此使用公式计算衰减的效果有时不尽如人意，尤其在物体离开光源照明范围时，因为不再执行该光照的 Additional Pass，所以光照效果会发生突变。虽然可以利用脚本将光源信息传递给 Shader，但这样灵活性很低，只能期待未来版本中 Unity 可以完善文档并开放更多参数给开发者。</p><h2 id="Unity-的阴影"><a href="#Unity-的阴影" class="headerlink" title="Unity 的阴影"></a>Unity 的阴影</h2><h3 id="阴影是如何实现的"><a href="#阴影是如何实现的" class="headerlink" title="阴影是如何实现的"></a>阴影是如何实现的</h3><p>实时渲染中，我们最常使用一种名为 <strong>Shadow Map</strong> 的技术，它会首先把摄像机的位置放在与光源重合的位置上，那么场景中该光源的阴影区域就是那些摄像机看不到的地方。Unity 就是使用这种技术。</p><p>在前向渲染路径中，如果场景中最重要的平行光开启了阴影，Unity 就会为该光源计算它的阴影映射纹理 shadowmap，这张阴影纹理本质上也是一张深度图，它记录了从该光源的位置出发、能看到的场景中距离它最近的表面位置(深度信息)。</p><p>为了得到阴影映射纹理中的深度信息，一种方法是：先把摄像机放到光源的位置，然后按照正常的渲染流程，即调用 Base Pass 和 Additional Pass 来更新深度信息。但是这样会造成一定的性能浪费，所以Unity 使用了一个额外的 Pass 专门更新光源的阴影映射纹理，这个 Pass 的 LightMode 标签设置为 <strong>ShadowCaster</strong>。这个 Pass 的渲染目标不是帧缓存，而是阴影映射纹理（或深度纹理）。Unity 会首先把摄像机放置到光源的位置上，然后调用该 Pass，通过对顶点变换后得到光源空间下的位置，并据此来输出深度信息到阴影映射纹理中。因此当开启了光源的阴影效果后，底层渲染会优先在当前渲染物体的 Unity Shader 中找到 LightMode 为 ShadowCaster 的 Pass，如果没有，会继续在 Fallback 指定的 Unity Shader 中找，如果仍然没有找到，该物体就不会向其他物体投射阴影（它仍然可以接收来自其他物体的阴影）。当找到后，Unity 会使用该 Pass 来更新光源的阴影映射纹理。</p><hr><p>①传统的阴影映射纹理实现：<br>在正常渲染的 Pass 中把顶点位置变换到光源空间下，以得到光源空间中顶点的位置。然后使用 xy 分量对阴影映射纹理进行采样，得到阴影纹理记录的深度值，如果它小于这个顶点的 z 分量，则说明这个顶点在阴影中。</p><p>②Unity 5 中的阴影采样技术：<br>Unity 使用了不同于上述传统的阴影采样技术，即<strong>屏幕空间的阴影映射技术 Screenspace Shadow Map</strong>。该技术原本是延迟渲染中产生阴影的方法，但并不是所有的 Unity 平台都是用该技术，因为其需要显卡支持 MRT，而有些移动平台不支持这种特性。使用该技术时，Unity 会首先调用 LightMode 为 ShadowCaster 的 Pass 得到可投射阴影的光源的阴影映射纹理和相机的深度纹理。然后，根据光源的阴影映射纹理和相机的深度纹理来得到屏幕空间的阴影图。</p><p>如果相机深度纹理记录的深度大于转换到光源阴影映射纹理中的深度值，则说明这个物体表面虽然是可见的，但是却处于该光源的阴影中。通过这样的方式，生成的阴影图包含了屏幕空间中所有有阴影的区域。</p><p>如果我们想要一个物体接受来自其他物体的阴影，首先需要把表面坐标从模型空间转换到屏幕空间中，然后使用该坐标对阴影图进行采样即可。</p><hr><p>总结，一个物体接收来自其他物体的阴影，以及它向其他物体投射阴影是两个过程：<br>①如果想要一个物体接收来自其他物体的阴影，就必须在 Shader 中对阴影映射纹理（包括屏幕空间的阴影图）进行采样，把采样结果和最后的光照结果相乘来产生阴影效果。<br>②如果想要一个物体向其他物体投射阴影，就必须把该物体加入光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。 </p><h3 id="不透明物体的阴影的实践"><a href="#不透明物体的阴影的实践" class="headerlink" title="不透明物体的阴影的实践"></a>不透明物体的阴影的实践</h3><p>准备工作：<br>①新建名为 Scene_9_4_2 的场景，并去掉天空盒子；<br>②新建名为 ShadowMat 的材质，并将上面一节的 ForwardRendering 赋给它；<br>③在场景中创建 1 个正方体、2 个平面，并把上一步创建的材质赋给正方体，平面的材质保持默认；<br>④保存场景。</p><p>本例中，平行光的 Shadow Type 选择了 Soft Shadows。</p><h4 id="让物体投射阴影"><a href="#让物体投射阴影" class="headerlink" title="让物体投射阴影"></a>让物体投射阴影</h4><p>在 Unity 中，可以选择是否让一个物体投射或接受阴影，通过设置 Mesh Renderer 组件中的 Cast Shadows 和 Receive Shadows 属性来实现。</p><p>当 <strong>Cast Shadows</strong> 被设置为 On，Unity 就会把该物体加入光源的阴影映射纹理的计算中。这个过程是通过为该物体执行 LightMode 为 ShadowCaster 的 Pass 来实现的。</p><p>若 <strong>Receive Shadows</strong> 没有开启，当我们调用 Unity 的内置宏和变量计算阴影时，这些宏通过判断该物体没有开启接受阴影的功能，就不会再内部计算阴影。</p><p>我们把正方形和两个平面的 Cast Shadows 和 Receive Shadows 都设为开启状态，可以得到下图的结果：</p><div  align="center">  <img src="https://s2.loli.net/2023/12/02/Hbt5K4L3Bo9RSOX.png" width = "70%" height = "70%" alt="图38- 开启 Cast Shadows 和 Receive Shadows，从而让正方体可以投射和接收阴影。"/></div><p>可以看到，尽管没有对正方体使用的 ForwardRendering 进行任何更改，正方体还是可以向下面的平面投射阴影。这是因为我们将内置的 Specular 作为 Fallback，虽然 Specular 本身也没有包含 LightMode 为 ShadowCaster 的 Pass，但是 Specular 的 Fallback 调用了 VertexLit。我们可以在 Unity 内置的着色器中找到它（内置着色器可以在官网上下载 <a href="http://unity3d.com/cn/get-unity/download/archive">http://unity3d.com/cn/get-unity/download/archive </a>，选择下载的下拉菜单里的 Built in shaders，下载得到的压缩包里面打开 DefaultResourcesExtra -&gt; Normal-VertexLit.shader）。该 shader 里面就有 LightMode 为 ShadowCaster 的 Pass。</p><p>这个 LightMode 为 ShadowCaster 的 Pass 在这里就不摘抄了，里面使用了一些宏，主要是为了把深度信息输出到一张深度图或者阴影映射纹理中。总之，想要在 Unity 让物体能够向其他物体投射阴影，一定要在它使用的 Unity Shader 中提供一个 LightMode 为 ShadowCaster 的 Pass。</p><p>上图还有个特殊现象，就是右侧的平面没有向下面的平面投射阴影，尽管它的 Cast Shadow 已经被开启了。在默认情况下，计算光源的阴影映射纹理会剔除掉物体的背面。我们可以将 Cast Shadow 设置为 <strong>Two Sided</strong> 来允许对物体的所有面都计算阴影信息。</p><div  align="center">  <img src="https://s2.loli.net/2023/12/04/QXquABdU7ztsi9r.png" width = "70%" height = "70%" alt="图39- 把 Cast Shadows 设置为 Two Sided 可以让右侧平面的背光面也产生阴影。"/></div><p>但是，这种图中正方体无法接收阴影，是因为使用的 Shader 没有对阴影进行任何处理。而下面的平面可以接收阴影是因为内置的 Standard Shader，该 Shader 进行了接受阴影的相关操作。</p><h4 id="让物体接收阴影"><a href="#让物体接收阴影" class="headerlink" title="让物体接收阴影"></a>让物体接收阴影</h4><p>为了让立方体可以接收阴影，我们新建一个 Unity Shader，命名为 Chapter9-Shadow，复制 Chapter9-ForwardRendering 的代码，并做部分修改：</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 9/Shadow&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Diffuse(<span class="string">&quot;Diffuse&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular(<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss(<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span> <span class="comment">// 下面计算阴影需要使用的宏都是在这个文件声明的</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                SHADOW_COORDS(<span class="number">2</span>) <span class="comment">// 这个宏声明一个用于对阴影纹理采样的坐标。这个宏的参数是下一个可用的插值寄存器的索引值，0 和 1 都使用了，所以传入 2</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                TRANSFER_SHADOW(o); <span class="comment">// 这个宏计算 v2f 结构中声明的阴影纹理坐标</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(max(<span class="number">0</span>, dot(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                fixed atten = <span class="number">1.0</span>;</span><br><span class="line">                fixed shadow = SHADOW_ATTENUATION(i); <span class="comment">// 这个宏计算阴影值</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten * shadow, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            ... <span class="comment">// 和 Chapter9-ForwardRendering 里一样</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Specular&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SHADOW_COORDS</strong>、<strong>TRANSFER_SHADOW</strong> 和 <strong>SHADOW_ATTENUATION</strong> 是计算阴影的“三剑客”。这些内置宏帮我们计算了光源的阴影，在 AutoLight.cginc 中可以找到它们的声明：<br>①<strong>SHADOW_COORDS</strong>：声明一个名为 _ShadowCoord 的阴影纹理坐标变量；<br>②<strong>TRANSFER_SHADOW</strong>：实现会根据平台变化。如果平台支持屏幕空间的阴影映射技术（通过判断是否定义了 UNITY_NO_SCREENSPACE_SHADOWS 来得到），会调用内置的 ComputeScreenPos 函数来计算 _ShadowCoord。如果不支持，会把顶点坐标从模型空间变换到光源空间后存储到 _ShadowCoord 中；<br>③<strong>SHADOW_ATTENUATION</strong>：使用 _ShadowCoord 对相关纹理进行采样，得到阴影信息。</p><p>内置代码也定义了关闭阴影的处理代码，当关闭阴影时，SHADOW_COORDS 和 TRANSFER_SHADOW 实际没有任何作用，而 SHADOW_ATTENUATION 会直接等于数值 1。</p><p>需要注意的是，由于这这宏中会使用上下文变量进行相关计算，例如 TRANSFER_SHADOW 会使用 v.vertex 或 a.pos 来计算坐标，因此为了这些宏能够正常工作，我们需要保证 a2f 结构体中顶点坐标变量名必须是 vertex，顶点着色器的输出结构体必须命名为 v， 且 v2f 中的顶点位置变量必须命名为 pos。</p><div  align="center">  <img src="https://s2.loli.net/2023/12/04/zjDXnOVRS9MwZiY.jpg" width = "70%" height = "70%" alt="图40- 正方体可以接收来自右侧平面的阴影。"/></div><h3 id="使用帧调试器查看阴影绘制过程"><a href="#使用帧调试器查看阴影绘制过程" class="headerlink" title="使用帧调试器查看阴影绘制过程"></a>使用帧调试器查看阴影绘制过程</h3><p>在 Window -&gt; Analysis -&gt; Frame Debugger 中打开帧调试器。可以看到主要分为 4 个渲染事件：<br>①UpdateDepthTexture：更新摄像机的深度纹理；<br>②Shadows.RenderShadowMap：渲染得到平行光的阴影映射纹理；<br>③RenderForwardOpaque.CollectShadows：根据深度纹理和阴影映射纹理得到屏幕空间的阴影图；<br>④RenderForward.RenderLoopJob：绘制渲染结果。</p><div  align="center">  <img src="https://s2.loli.net/2023/12/04/JPxETG6s1kKIYzL.jpg" width = "80%" height = "80%" alt="图41- 使用帧调试器查看阴影绘制过程。"/></div><p>上述四个渲染事件的具体图片不在这里放出了。帧调试器右侧面板可以看到具体调用了哪个 Shader 的哪个 Pass 绘制了当前纹理或图片。</p><h3 id="统一管理光照衰减和阴影"><a href="#统一管理光照衰减和阴影" class="headerlink" title="统一管理光照衰减和阴影"></a>统一管理光照衰减和阴影</h3><p>前面的例子实现中，我们把光照衰减因子、阴影值和光照结果相乘得到最终的渲染结果。其实，Unity 提供了 <strong>UNITY_LIGHT_ATTENUATION</strong> 这个内置宏来同时计算这两个信息。</p><p>我们新建一个材质，命名为 AttenuationAndShadowUseBuildInFunctionsMat；同时新建名为 Chapter9-AttenuationAndShadowUseBuildInFunctions 的 Shader。将上一节的 Chapter9-Shadow 的代码复制进去，将下面代码删除：</p><pre><code>fixed atten = 1.0;fixed shadow = SHADOW_ATTENUATION(i);</code></pre><p>修改为</p><pre><code>UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</code></pre><p><strong>UNITY_LIGHT_ATTENUATION</strong> 接收 3 个参数，它会将光照衰减和阴影值相乘后的结果存储到第一个参数中。无需在代码中声明 atten 参数，该宏会帮我们声明这个变量。第二个参数是结构体 v2f ，这个参数会传递给 <strong>SHADOW_ATTENUATION</strong> ，用来计算阴影值。第三个参数是世界空间下的坐标，这个参数会用于计算光源空间下的坐标，再对光照衰减纹理采样来得到光照衰减。</p><p>由于使用了 <strong>UNITY_LIGHT_ATTENUATION</strong>，Base Pass 和 Additional Pass 的代码可以统一，我们不需要在 Base Pass 里单独处理阴影，也不需要在 Additional Pass 中判断光源类型来处理关照衰减，一切都可以通过 <strong>UNITY_LIGHT_ATTENUATION</strong> 来完成。将 Additional Pass 中的两个结构体、顶点着色器和片元着色器中的代码改为和 Bass Pass 一模一样即可。如果希望在 Additional Pass 中也添加阴影效果，需要使用 <code>#pragma multi_compile_fwdadd_fullshadows</code> 来代替  Additional Pass 中的 <code>#pragma multi_compile_fwdadd</code> 指令。这样，Unity 也会为这些额外的逐像素光源计算阴影，并传递给 Shader。</p><h3 id="透明度物体的阴影"><a href="#透明度物体的阴影" class="headerlink" title="透明度物体的阴影"></a>透明度物体的阴影</h3><p>对于大多数不透明的物体，把 Fallback 设为 VertexLit 就可以得到正确的阴影；但是对于透明物体来说，透明物体的实现通常会使用<strong>透明度测试</strong>或<strong>透明度混合</strong>，我们需要小心设置这些物体的 Fallback。</p><h4 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h4><p>透明度测试的处理比较简单，但是如果我们仍然直接使用 VertexLit、Diffuse、Specular 等作为回调，往往无法得到正确的阴影，因为透明度测试需要在片元着色器中舍弃某些片元，而 VertexLit 中的阴影映射纹理并没有进行这样的操作，所以会导致被舍弃的片元依然投射了阴影。</p><p>我们新建一个 Scene_9_4_5_a 的场景，新建 AlphaTestWithShadowMat 的材质和 Chapter9-AlphaTestWithShadow 的 Unity Shader，将 Chapter8-AlphaTestBothSided 复制进去，然后添加阴影的计算：<br>①增加 <code>#include &quot;AutoLight.cginc&quot;</code> 头文件<br>②在 v2f 使用内置宏：<code>SHADOW_COORDS(3)</code><br>③在顶点着色器中使用内置宏：<code>TRANSFER_SHADOW(o);</code><br>④在片元着色器中使用内置宏：<code>UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</code><br>⑤把 Fallback 改为 VertexLit</p><p>效果如下：</p><div  align="center">  <img src="https://s2.loli.net/2023/12/05/ENogdGBhvMmIlZn.jpg" width = "70%" height = "70%" alt="图42- 错误设置了 Fallback 的使用透明度测试的物体投射阴影。"/></div><p>可以看出镂空的区域出现了不正常的阴影，这就是因为内置的 VertexLit 提供的 ShadowCaster 的 Pass 没有进行任何透明度测试的计算，因此，它会把整个物体的深度信息写入深度图和者阴影映射纹理中。</p><p>而当我们把 Fallback 改为 Transparent/Cutout/VertexLit（之前透明度测试时候使用过的），它的 ShadowCaster Pass 计算了透明度测试，会把裁剪后的物体的深度信息写入深度图和者阴影映射纹理中。需要注意，Transparent/Cutout/VertexLit 计算透明度测试使用了名为 _Cutoff 的属性来进行透明度测试，即我们的 Shader 里必须提供名为 _Cutoff 的属性。更改了 Fallback 后的效果如下：</p><div  align="center">  <img src="https://s2.loli.net/2023/12/05/CEeXPQwrJG8I9Lc.jpg" width = "70%" height = "70%" alt="图43- 正确设置了 Fallback 的使用透明度测试的物体投射阴影。"/></div><p>但是这样还是不对，出现了一些不应该透过光的部分。出现这种情况的原因是，默认情况下把物体渲染到深度图和阴影映射纹理中仅考虑物体的正面。所以需要把正方体的 Mesh Renderer 组件中的 Cast Shadows 属性设置为 Two Sided。效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/05/JjhxkbsoByz5tdZ.jpg" width = "70%" height = "70%" alt="图44- 正确设置了 Cast Shadow 属性的使用透明度测试的物体投射阴影。"/></div><h4 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h4><p>透明度混合添加阴影相比透明度测试更复杂。所有 Unity 内置的透明度混合，比如：Transparent/VertexLit 等，都没有阴影投射的 Pass，这意味着半透明物体不参与深度图和阴影映射纹理的计算，即不会向其他物体投射阴影，同时也不会接受其他物体的阴影。</p><p>我们新建一个 Scene_9_4_5_b 的场景，新建 AlphaBlendWithShadowMat 的材质和 Chapter9-AlphaBlendWithShadow 的 Unity Shader，将 Chapter8-AlphaBlend 复制进去，然后添加阴影的计算，并且它的 Fallback 是内置的 Transparent/VertexLit。效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/11/gRJxAd3GZVUrvFH.jpg" width = "70%" height = "70%" alt="图45- 把使用了透明度混合的 Unity Shader 的 Fallback 设置为内置的 Transparent/VertexLit。半透明物体不会向下方的平面投射阴影，也不会接收来自右侧平面的阴影，它看起来就像是完全透明一样"/></div><p>Unity 不处理半透明物体的阴影，是由于透明度混合需要关闭深度写入，会影响阴影的生成。若想为半透明物体产生正确的阴影，需要在每个光源空间下仍然严格按照从后往前的顺序进行渲染，这会让阴影处理变得复杂，从而影响性能。因此，在 Unity 中，所有内置的半透明 Shader 是不会产生任何阴影效果的。</p><p>但是可以通过把它们的 Fallback 设置为 VertexLit、Diffuse 这些不透明物体使用的 Unity Shader，这样 Unity 就会在它的 Fallback 找到一个阴影投射的 Pass。</p><h2 id="本书使用的标准-Unity-Shader"><a href="#本书使用的标准-Unity-Shader" class="headerlink" title="本书使用的标准 Unity Shader"></a>本书使用的标准 Unity Shader</h2><p>将截止到本节所学的所有基础光照计算整合在一起实现的标准光照着色器如下，都包含了对法线纹理、多光源、光照衰减和阴影的相关处理：<br>①BumpedDiffuse，使用 Phong 光照模式，链接如下：<br><a href="https://github.com/candycat1992/Unity_Shaders_Book/blob/master/Assets/Shaders/Common/BumpedDiffuse.shader">https://github.com/candycat1992/Unity_Shaders_Book/blob/master/Assets/Shaders/Common/BumpedDiffuse.shader</a><br>②BumpedSpecular，使用 Blinn-Phong 光照模型，链接如下：<br><a href="https://github.com/candycat1992/Unity_Shaders_Book/blob/master/Assets/Shaders/Common/BumpedSpecular.shader">https://github.com/candycat1992/Unity_Shaders_Book/blob/master/Assets/Shaders/Common/BumpedSpecular.shader</a></p><h1 id="第九章-高级纹理"><a href="#第九章-高级纹理" class="headerlink" title="第九章 高级纹理"></a>第九章 高级纹理</h1><h2 id="立方体纹理"><a href="#立方体纹理" class="headerlink" title="立方体纹理"></a>立方体纹理</h2><p>在图形学中，<strong>立方体纹理 Cubemap</strong> 是<strong>环境映射 Environment Mapping</strong> 的一种实现方法。环境映射可以模拟物体周围的环境，而使用了环境映射的物体可以看起来像镀了层金属一样反射出周围的环境。</p><p>和之前的纹理不同，立方体纹理一共包含了 6 张图像，这些图像对应了一个立方体的 6 个面。立方体的每个面表示沿着世界空间下的轴向（上下左右前后）观察所得的图像。而对立方体纹理采样，需要提供一个三维的纹理坐标。这个方向矢量从立方体的中心出发，当它向外部延伸时就会和立方体的 6 个纹理之一发生相交，而采样得到的结果就是由该交点计算而来的。</p><p>使用立方体纹理的好处在于，它的实现简单快速，而且得到的效果也比较好。而它的缺点为，例如当场景中引入了新的物体、光源或者物体发生移动时，就需要重新生成立方体纹理。除此之外，立方体纹理也仅可以反射环境，但不能反射使用了该立方体纹理的物体本身。因为立方体纹理不能模拟多次反射的结果，例如两个金属球互相反射的情况（Unity 5 引入的全局光照系统允许实现这样的自反射效果，见第 17 章）。因此应该尽量对于凸面体而不是凹面体使用立方体纹理（因为凹面体回反射自身）。</p><p>立方体纹理在实时渲染中有很多应用，最常见的是用于天空盒子 Skybox 以及环境映射。</p><h3 id="天空盒子"><a href="#天空盒子" class="headerlink" title="天空盒子"></a>天空盒子</h3><p><strong>天空盒子 sky box</strong> 是游戏中用于模拟背景的一种方法。它用来模拟天空（尽管仍可以用它模拟室内等背景）。当我们在背景中使用了天空盒子时，整个场景被包围在一个立方体内。这个立方体每个面使用的技术就是立方体纹理映射技术。</p><p>在 Unity 中，使用天空盒子，只需要创建一个 Skybox 材质，再把它赋给该场景的相关设置即可：<br>①新建名为 SkyboxMat 的材质；<br>②将新建的材质选择 Unity 自带的 Shader - Skybox/6Sided，该材质需要 6 张纹理；<br>③使用原书的 6 张纹理资源，在 \Assets\Textures\Chapter10\Cubemaps 目录下，并在纹理的 Inspector 面板上将 Wrap Mode 设置为 Clamp，防止衔接处出现不匹配的现象；<br>④将 6 张纹理拖到材质面板对应的纹理属性上（注意位置，posz 纹理对应 Front[+Z] 属性）</p><p>上面的材质中，除了 6 张纹理属性外还有 3 个属性：<br>①<strong>Tint Color</strong>，用于控制该材质的整体颜色；<br>②<strong>Exposure</strong>，用于控制天空盒子的亮度；<br>③<strong>Rotation</strong>，用于调整天空盒子沿 +y 轴方向的旋转角度。</p><p>下面为场景添加 Skybox：<br>①新建名为 Scene_10_1_1 的场景；<br>②在 Unity 菜单 Window -&gt; Rendering -&gt; Environment 中，将 SkyboxMat 材质赋给 SkyBox 选项；<br>③确保场景主相机的 Camera 组件中的 Clear Flags 被设置为 Skybox。</p><p>效果如下：</p><div  align="center">  <img src="https://s2.loli.net/2023/12/11/qVs5DNiCmgXUMTJ.jpg" width = "70%" height = "70%" alt="图46- 使用了天空盒子的场景"/></div><p>需要说明的是，在 Window -&gt; Rendering -&gt; Environment 中设置的天空盒子会应用于该场景中的所有摄像机，如果希望某个摄像机使用不同的 Skybox，需要为该摄像机添加 Skybox 的组件来单独为该摄像机设置 Skybox。</p><p>在 Unity 中，天空盒子是在所有不透明物体之后渲染的，而其背后使用的网格式一个立方体或一个细分后的球体。</p><h3 id="创建用于环境映射的立方体纹理"><a href="#创建用于环境映射的立方体纹理" class="headerlink" title="创建用于环境映射的立方体纹理"></a>创建用于环境映射的立方体纹理</h3><p>除了天空盒子，立方体纹理最常见的用处是用于环境映射。通过这种办法，可以模拟出金属质感的材质。</p><p>在 Unity 5 中，创建用于环境映射的立方体纹理的办法有三种：<br>①第一种方法是直接由一些特殊布局的纹理创建，提供一张具有特殊布局的纹理，例如类似立方体展开图的交叉布局、全景布局等。然后把该纹理的 Texture Type 设置为 Cubemap 即可。在基于物理的渲染中，通常使用一张 HDR 图像来生成高质量的 Cubemap；<br>②第二种方法是手动创建一个 Cubemap 资源，再把 6 张图赋给它。在 Unity 5 中，官方推荐使用第一种方法创建立方体纹理，因为第一种方法可以对纹理数据进行压缩，而且支持边缘修正、光滑反射（glossy reflection）和 HDR 等功能；<br>③由脚本生成。</p><p>前两种方法都需要提前准备好立方体纹理的图像，它们得到的立方体纹理常常是背场景中的物体所共用。而理想情况下，我们希望根据物体在场景中位置的不同，生成它们各自不同的立方体纹理。这时，可以通过利用 Unity 提供的 <strong>Camera.RenderToCubemap</strong> 来实现。该函数可以把从任意位置观察到的场景图像存储到 6 张图像中，从而创建出该位置上对应的立方体纹理。代码如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RenderCubemapWizard</span> : <span class="title">ScriptableWizard</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Transform renderFromPosition;</span><br><span class="line">    <span class="keyword">public</span> Cubemap cubemap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardUpdate</span> ()</span> &#123;</span><br><span class="line">        helpString = <span class="string">&quot;Select transform to render from and cubemap to render into&quot;</span>;</span><br><span class="line">        isValid = (renderFromPosition != <span class="literal">null</span>) &amp;&amp; (cubemap != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnWizardCreate</span> ()</span> &#123;</span><br><span class="line">        <span class="comment">// create temporary camera for rendering</span></span><br><span class="line">        GameObject go = <span class="keyword">new</span> GameObject( <span class="string">&quot;CubemapCamera&quot;</span>);</span><br><span class="line">        go.AddComponent&lt;Camera&gt;(); </span><br><span class="line">        <span class="comment">// place it on the object</span></span><br><span class="line">        go.transform.position = renderFromPosition.position;</span><br><span class="line">        <span class="comment">// render into cubemap        </span></span><br><span class="line">        go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// destroy temporary camera</span></span><br><span class="line">        DestroyImmediate( go );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;GameObject/Render into Cubemap&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCubemap</span> ()</span> &#123;</span><br><span class="line">        ScriptableWizard.DisplayWizard&lt;RenderCubemapWizard&gt;(</span><br><span class="line">            <span class="string">&quot;Render cubemap&quot;</span>, <span class="string">&quot;Render!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们在 renderFromPosition（由用户指定）位置处动态创建一个摄像机，并调用 Camera.RenderToCubemap 函数把从当前位置观察到的图像渲染到用户指定的立方体纹理 cubemap 中，完成后再销毁临时摄像机。由于该代码需要添加菜单栏条目，因此需要把它放在 Editor 文件夹中才能正确执行。</p><p>准备完上述代码后，创建一个立方体纹理的其他步骤如下：<br>①使用上面相同的场景，并创建一个空的 GameObject 对象，我们会使用该 GameObject 的位置信息来渲染立方体纹理；<br>②新建一个存储的立方体纹理，在 Project 下右键 Creat -&gt; Legacy -&gt; Cubemap 来创建，同时还需要在其面板上勾选 Readable 选项，让脚本顺利将图像渲染到该立方体纹理中；<br>③在 Unity 菜单栏选择 GameObject -&gt; Render into Cubemap，打开在脚本中实现的用于渲染立方体纹理的窗口，并把第一步的 GameObject 和第二步的 Cubemap_0 拖拽给 Render From Position 和 Cubemap 选项；<br>④点击窗口中的 Render! 按钮可观察到现象。而 Face size 选项越大，渲染出来的立方体纹理分辨率越大，效果越好，占用的内存更大。如下图所示：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/11/HzXGrBQZp6cFRYf.jpg" width = "40%" height = "40%" alt="图47- 使用脚本渲染立方体纹理"/></div><p>准备好了需要的立方体纹理后，就可以对物体使用环境映射技术。而环境映射最常见的应用就是反射和折射。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>使用了反射的物体可以看起来像镀了层金属。模拟反射效果，只需要通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样即可。</p><p>准备工作如下：<br>①新建名为 Scene_10_1_3 的场景，并将天空盒替换成第一小节定义的天空盒；<br>②向场景中拖拽一个 Teapot 模型，将其位置调整为前面小节创建的 Cubemap_0 时使用的空 GameObject 的位置；<br>③新建名为 ReflectionMat 的材质，并赋给 Teapot 模型；<br>④新建名为 Chapter10-Reflection 的 Unity Shader，并赋给上一步创建的材质；</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 10/Reflection&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _ReflectColor (<span class="string">&quot;Reflect Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 反射颜色</span></span><br><span class="line">        _ReflectAmount (<span class="string">&quot;Refect Amount&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span> <span class="comment">// 反射程度</span></span><br><span class="line">        _Cubemap (<span class="string">&quot;Reflection Cubemap&quot;</span>, Cube) = <span class="string">&quot;_Skybox&quot;</span> &#123;&#125; <span class="comment">// 反射的环境映射纹理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _ReflectColor;</span><br><span class="line">            fixed _ReflectAmount;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                o.worldRefl = reflect(-o.worldViewDir, o.worldNormal); <span class="comment">//计算该顶点的反射方向，通过 reflect 函数实现。同时物体反射到摄像机中的光线方向，可以通过光路可逆的原则来反向求得。即，计算视角方向关于顶点法线的反射方向来求得入射光线的方向。</span></span><br><span class="line">                </span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));        </span><br><span class="line">                fixed3 worldViewDir = normalize(i.worldViewDir);        </span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb; <span class="comment">//对立方体纹理采样使用的是 Cg 的 texCUBE 函数。利用反射方向来对立方体纹理采样，而没有对 worldRefl 归一化是因为采样的参数仅仅是作为方向变量传递给 texCUBE，因此没有必要归一化。</span></span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten; <span class="comment">//用 ReflectAmount 进行混合漫反射颜色和反射颜色，并和环境光照相加后返回</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Reflective/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面计算中，选择的是在顶点着色器中计算反射方向，若在片元着色器中计算，效果会跟细腻。但是这种差别很小，出于性能的考虑，选择了顶点着色器中计算反射方向。</p><p>在材质面板中把 Cubemap_0 拖拽到 Reflection Cubemap 属性中，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/12/rThjxqKUcZPRJiN.jpg" width = "70%" height = "70%" alt="图48- 使用了反射效果的 Teapot 模型"/></div><h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><p>折射，即当光线从一种介质（比如：空气）斜射入另一种介质（比如：玻璃）时，传播方向会发生改变。当给定入射角时，可以使用<strong>斯涅尔定律 Snell’s Law</strong> 来计算反射角。</p><p>当光从介质 1 沿着和表面法线夹角为 $\,{\theta}_1\,$ 的方向斜射入介质 2 时，可以使用如下公式计算折射光线与法线的夹角 $\,{\theta}_2\,$ ：</p><script type="math/tex; mode=display">{\eta}_1 \sin {\theta}_1 = {\eta}_2 \sin {\theta}_2</script><p>其中，$\,{\eta}_1\,$ 和 $\,{\eta}_2\,$ 分别是两个介质的<strong>折射率 index of refraction</strong>。如下图：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/12/LoNTm43c9qPzeDj.jpg" width = "40%" height = "40%" alt="图49- 斯涅尔定律"/></div><p>通常来讲，当得到折射方向后，我们会直接使用它来对立方体纹理进行采样，这不符合物理规律。对一个透明物体来说，更准确的模拟方法需要计算两次折射，即进入物体一次，出去一次。但是，想要在实时渲染中模拟出第二次折射方向是比较复杂的，而且由于仅仅模拟一次的效果从视觉上也还过得去，所有通常只模拟一次折射。</p><p>准备工作如下：<br>①新建名为 Scene_10_1_4 的场景，并将天空盒替换成第一小节定义的天空盒；<br>②向场景中拖拽一个 Teapot 模型，并调整其位置；<br>③新建名为 RefractionMat 的材质，赋给上一步创建的模型；<br>④新建名为 Chapter10-Refraction 的 Unity Shader，赋给上一步创建的材质。</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 10/Refraction&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _RefractColor (<span class="string">&quot;Refraction Color&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _RefractAmount (<span class="string">&quot;Refraction Amount&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span> </span><br><span class="line">        _RefractRatio (<span class="string">&quot;Refraction Ratio&quot;</span>, Range(<span class="number">0.1</span>, <span class="number">1</span>)) = <span class="number">0.5</span> <span class="comment">//不同介质的折射率透射比</span></span><br><span class="line">        _Cubemap (<span class="string">&quot;Refraction Cubemap&quot;</span>, Cube) = <span class="string">&quot;_Skybox&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed4 _RefractColor;</span><br><span class="line">            <span class="type">float</span> _RefractAmount;</span><br><span class="line">            fixed _RefractRatio;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                fixed3 worldRefr : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">                </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(_Object2World, v.vertex).xyz;</span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//使用 Cg 的 refract 函数来计算折射方向。第一个参数为入射光线的方向，必须是归一化后的矢量；第二个参数是归一化后的表面法线；第三个参数是入射光线所在介质的折射率和折射光线所在介质的折射率的比值。它返回折射方向，它的模等于入射光线的模</span></span><br><span class="line">                o.worldRefr = refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio);</span><br><span class="line">                </span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = normalize(i.worldViewDir);</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//也不需要对 i.worldRefr 进行归一化处理</span></span><br><span class="line">                fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//混合颜色</span></span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack <span class="string">&quot;Reflective/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在材质面板中把 Cubemap_0 拖拽到 Reflection Cubemap 属性中，效果如下：</p><div  align="center">  <img src="https://s2.loli.net/2023/12/12/tW4vblJYuIzegXN.jpg" width = "70%" height = "70%" alt="图50- 使用了折射效果的 Teapot 模型"/></div><h3 id="菲涅耳反射"><a href="#菲涅耳反射" class="headerlink" title="菲涅耳反射"></a>菲涅耳反射</h3><p>实时渲染中，我们经常会使用<strong>菲涅耳反射 Fresnel reflection</strong> 来根据视角方向控制反射程度。</p><p>简单的讲，就是视线垂直于表面时，反射较弱；而当视线非垂直表面时，夹角越小，反射越明显。菲涅尔反射描述了这种光学现象，当光线照射到物体表面时，一部分发生反射，一部分进入物体内部，发生折射或散射。被反射的光和入射光之间存在一定的比率关系，这个比率关系可以通过菲涅尔等式进行计算。</p><p>一个常见的例子是，站在湖边，低头看湖面，会发现水是透明的，但是抬头看远处的水面时，只能看到水面反射的效果，几乎看不到水下的情景。事实上，几乎所有物体都包含了菲涅耳效果，这是基于物理的渲染中非常重要的一项高光反射计算因子（详见第 17 章）。</p><blockquote><p>可以在 John Hable 的一篇非常有名的文章 Everything Has Fresnel 中看到现实生活中各种物体的菲涅耳反射效果：<a href="http://filmicworlds.com/blog/everything-has-fresnel/">http://filmicworlds.com/blog/everything-has-fresnel/</a></p></blockquote><p>真实世界的菲涅耳等式非常复杂，在实时渲染中，会使用一些近似公式来计算。其中一个著名的近似公式就是 <strong>Schlick 菲涅耳近似等式</strong>：</p><script type="math/tex; mode=display">F_{Schlick}(v, n) = F_0 + (1 - F_0)(1 - v \cdot n)^5</script><p>$\,F_0\,$ 是一个反射系数，根据材质的不同数值会有所不同。折射率可以用来计算 $\,F_0\,$，假设折射率 $\,{\eta}_1$ 和 $\,{\eta}_2\,$ ，可以得到以下公式：</p><script type="math/tex; mode=display">F_0 = (\cfrac {\eta_1 - \eta_2}{\eta_1 + \eta_2})^2</script><p>另一个应用比较广泛的等式是 <strong>Empirical 菲涅耳近似等式</strong></p><script type="math/tex; mode=display">F_{Empirical}(v, n) = max(0, min(1, bias + scale \times (1 - v \cdot n)^{power}))</script><p>其中，bias、scale 和 power 是控制项。</p><hr><p>使用上面的菲涅耳近似等式，我们可以在边界处模拟反射光强和折射光强/漫反射光强之间的变化，来模拟更加真实的反射效果。下面使用 Schlick 菲涅耳近似等式来模拟，准备工作如下：<br>①新建名为 Scene_10_1_5 的场景，并将天空盒替换成前面小节自定义的天空盒材质；<br>②向场景中拖拽一个 Teapot 模型，并调整其位置；<br>③新建名为 FresnelMat 的材质，赋给上一步的模型；<br>④新建名为 Chapter10-Fresnel 的 Unity Shader，赋给上一步的材质。</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 10/Fresnel&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _FresnelScale (<span class="string">&quot;Fresnel Scale&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">        _Cubemap (<span class="string">&quot;Reflection Cubemap&quot;</span>, Cube) = <span class="string">&quot;_Skybox&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> multi_compile_fwdbase</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AutoLight.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed _FresnelScale;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">                fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">                fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">                SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">                o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);</span><br><span class="line">                TRANSFER_SHADOW(o);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">                fixed3 worldViewDir = normalize(i.worldViewDir);</span><br><span class="line">                </span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">                </span><br><span class="line">                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;</span><br><span class="line">                </span><br><span class="line">                fixed fresnel = _FresnelScale + (<span class="number">1</span> - _FresnelScale) * <span class="built_in">pow</span>(<span class="number">1</span> - dot(worldViewDir, worldNormal), <span class="number">5</span>); <span class="comment">//菲尼尔近似等式    </span></span><br><span class="line">                </span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten; <span class="comment">//混合漫反射光照和反射光照。一些实现也会直接把 fresnel 和反射光照相乘后叠加到漫反射光照上，来模拟光照的效果</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack <span class="string">&quot;Reflective/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在材质面板中把 Cubemap_0 拖拽到 Cubemap 属性中。将 _FresnelScale 调节到 1 时，物体完全反射 Cubemap 中的图像；当 _FresnelScale 为 0 时，则是一个具有边缘光照效果的漫反射物体。下图是 _FresnelScale 为 0.5 时的效果。</p><div  align="center">  <img src="https://s2.loli.net/2023/12/13/7TYAsJfDdVH4WrU.jpg" width = "70%" height = "70%" alt="图51- 使用了菲涅耳反射的 Teapot 模型"/></div><p>在第 14 章会使用菲涅耳反射来模拟一个简单的水面效果。</p><h2 id="渲染纹理"><a href="#渲染纹理" class="headerlink" title="渲染纹理"></a>渲染纹理</h2><p>在之前的学习中，一个摄像机的渲染结果会输出到颜色缓冲中，并显示到我们的屏幕上。现代 GPU 允许我们把整个三维场景渲染到一个中间缓冲中，即<strong>渲染目标纹理 Render Target Texture, RTT</strong>，而不是传统的帧缓冲或后备缓冲 back buffer。与之相关的是<strong>多重渲染目标 Multiple Render Target, MRT</strong>，这种技术指的是 GPU 允许我们把场景同时渲染到多个渲染目标纹理中，而不再需要为每个渲染目标纹理单独渲染完整的场景。延迟渲染就是使用多重渲染目标的一个应用。</p><p>Unity 为渲染目标纹理定义了一种专门的纹理类型，即<strong>渲染纹理 Render Texture</strong>。在 Unity 中使用渲染纹理通常有两种方式：<br>①在 Project 目录下创建一个渲染纹理，然后把某个摄像机的渲染目标设置成该渲染纹理，这样一来该摄像机的渲染结果就会实时更新到渲染纹理中，而不是显示到屏幕上。使用这种方法，我们还可以选择渲染纹理的分辨率、滤波模式等纹理属性；<br>②在屏幕后处理时使用 GrabPass 命令或 OnRenderImage 函数来获取当前屏幕图像，Unity 会把这个屏幕图像放到一张和屏幕分辨率等同的渲染纹理中，我们可以在自定义的 Pass 中把它们当成普通的纹理来处理，从而实现各种屏幕特效。</p><p>我们将依次学习这两种方法在 Unity 中的实现（OnRenderImage 函数在第 11 章讲）</p><h3 id="镜子效果"><a href="#镜子效果" class="headerlink" title="镜子效果"></a>镜子效果</h3><p>准备工作：<br>①新建名为 Scene_10_2_1 的场景，并去掉天空盒子；<br>②新建名为 MirrorMat 的材质；<br>③新建名为 Chapter10-Mirror 的 Unity Shader，并赋给上一步创建的材质；<br>④创建 6 个立方体，调整其位置和大小，搭建出一个围绕摄像机的封闭空间，给它们附上合适的材质，使其看起来像房间的墙；往封闭空间内加入3个点光源，调整位置，使其照亮封闭空间；<br>⑤在封闭空间内创建 3 个球体和 2 个正方体，调整其位置和大小，附上合适的材质，使其作为封闭空间内的装饰物；<br>⑥创建一个四边形 Quad，调整其大小和位置，使其作为空间内的一面镜子，并附上第二步创建的材质；<br>⑦Project 视图下创建一个渲染纹理（右键单击 Create -&gt; Render Texture），并命名为 MirrorTexture；<br>⑧为了得到从镜子出发观察到的场景图像，需要创建一个摄像机，调整它的位置、裁剪平面、视角等，使它显示的图像是我们希望的镜子图像。由于这个摄像机不需要直接显示在屏幕上，而是用于渲染到纹理。因此，把第七步中创建的 MirrorTexture 拖拽到该摄像机的 Target Texture 上。</p><p>镜子的实现原理很简单，使用一个渲染纹理作为输入属性，并把该渲染纹理在水平方向上翻转后直接显示到物体上即可，代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 10/Mirror&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;        <span class="comment">//计算纹理坐标</span></span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.texcoord;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//反转 x 分量的纹理坐标，镜子的图像都是左右相反</span></span><br><span class="line">                o.uv.x = <span class="number">1</span> - o.uv.x;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> tex2D(_MainTex, i.uv); <span class="comment">//对纹理进行采样和输出</span></span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将创建的 MirrorTexture 渲染纹理拖拽到材质的 Main Tex 属性中，效果如下。若图像模糊不清，可以使用更高的分辨率或更多的抗锯齿采样等。但是，更高的分辨率会影响带宽和性能。</p><div  align="center">  <img src="https://s2.loli.net/2023/12/13/zsfMUPOyrHaT3Wq.jpg" width = "70%" height = "70%" alt="图52- 镜子效果"/></div><h3 id="玻璃效果"><a href="#玻璃效果" class="headerlink" title="玻璃效果"></a>玻璃效果</h3><p>在 Unity 中，我们还可以在 Unity Shader 中使用一种特殊的 Pass 来完成获取屏幕图像的目的，这就是 <strong>GrabPass</strong>。当我们在 Shader 中定义了一个 GrabPass 后，Unity 会把当前屏幕的图像绘制在一张纹理中，以便我们在后续的 Pass 中访问它。我们通常会使用 GrabPass 来实现诸如玻璃等透明材质的模拟，与使用简单的透明混合不同，使用 GrabPass 可以让我们对该物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不再是简单的和原屏幕颜色进行混合。</p><p>需要注意的是，在使用 GrabPass 的时候，需要额外小心物体的渲染队列设置。正如之前所说，GrabPass 通常用于渲染透明物体，尽管代码里不包含混合指令，但是仍然要设置透明队列，即 “Queue”=”Transparent”。这样才能保证不透明的物体绘制在屏幕上。</p><p>下面会使用 GrabPass 来模拟一个玻璃效果。首先使用了一张法线纹理来修改模型的法线信息，然后通过一个 Cubemap 来模拟玻璃的反射。模拟折射的时候，使用 GrabPass 获取玻璃后面的屏幕图像，并使用切线空间下的法线对屏幕纹理坐标偏移后，再对屏幕图像进行采样来模拟近似的折射效果。</p><p>准备工作：<br>①新建名为 Scene_10_2_2 的场景，并去掉天空盒子；<br>②新建名为 GlassRefractionMat 的材质；<br>③新建名为 Chapter10-GlassRefraction 的 Unity Shader，并赋给上一步的材质；<br>④在场景中创建 6 个平面，调整其位置和大小，以其作为墙，构成封闭的房间。在房间内放置 1 个立方体和一个球体，其中球体位于立方体内部，为了模拟玻璃对内部物体的折射效果，将第 2 步创建的材质赋给立方体；<br>⑤使用之前小节实现的创建 Cubemap 的脚本来创建使用本场景的环境映射纹理：Project 视图目下右键 Create -&gt; Legacy -&gt; Cubemap，创建立方体纹理，命名为 Glass_Cubemap，并在创建后的 Cubemap 的 Inspector 窗口中勾选 Readable；然后通过在菜单栏 GameObject -&gt; Render into Cubemap，在出现的窗口中将场景里的立方体拖拽到 Render From Position 项，将上一步创建的 Cubemap 拖拽到 Cubemap 项。</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 10/Glass Refraction&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//材质纹理</span></span><br><span class="line">        _BumpMap (<span class="string">&quot;Normal Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125; <span class="comment">//法线纹理</span></span><br><span class="line">        _Cubemap (<span class="string">&quot;Environment Cubemap&quot;</span>, Cube) = <span class="string">&quot;_Skybox&quot;</span> &#123;&#125; <span class="comment">//模拟反射的环境纹理</span></span><br><span class="line">        _Distortion (<span class="string">&quot;Distortion&quot;</span>, Range(<span class="number">0</span>, <span class="number">100</span>)) = <span class="number">10</span> <span class="comment">//控制模拟折射时图像的扭曲程度</span></span><br><span class="line">        _RefractAmount (<span class="string">&quot;Refract Amount&quot;</span>, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">1.0</span> <span class="comment">//控制折射程度，若为 0 则该玻璃只包含反射效果，若为 1 则只包含折射效果</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> &#125;</span><br><span class="line">        <span class="comment">//一个 Transparent，一个 Opaque 看似矛盾。是因为把 Queue 设置为 Transparent 是为了确保该物体渲染时，其他不透明物体已经渲染在屏幕上了。设置 RenderType 是为了使用着色器替换时，该物体在需要时被正确渲染，详见第 12 章</span></span><br><span class="line">        </span><br><span class="line">        GrabPass &#123; <span class="string">&quot;_RefractionTex&quot;</span> &#125;</span><br><span class="line">        <span class="comment">//通过关键词 GrabPass 定义了一个抓取屏幕图像的 Pass，在该 Pass 中定义了一个字符串，该字符串内部的名称决定了抓取得到的屏幕图像会被存入到哪个纹理中。实际上可以省略该字符串，但是声明性能更好，原因见后面</span></span><br><span class="line">        </span><br><span class="line">        Pass &#123;        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            samplerCUBE _Cubemap;</span><br><span class="line">            <span class="type">float</span> _Distortion;</span><br><span class="line">            fixed _RefractAmount;</span><br><span class="line">            sampler2D _RefractionTex; <span class="comment">//对应 GrabPass 指定的纹理名称</span></span><br><span class="line">            float4 _RefractionTex_TexelSize; <span class="comment">//得到该纹理的纹素大小，例如一个大小为 256×512 的纹理，它的纹素大小为(1/256, 1/512)。在对屏幕图像采样坐标进行偏移时使用该变量 </span></span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT; </span><br><span class="line">                float2 texcoord: TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 scrPos : TEXCOORD0;</span><br><span class="line">                float4 uv : TEXCOORD1;</span><br><span class="line">                float4 TtoW0 : TEXCOORD2;  </span><br><span class="line">                float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">                float4 TtoW2 : TEXCOORD4; </span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.scrPos = ComputeGrabScreenPos(o.pos); <span class="comment">//得到对应被抓取的屏幕图像的采样坐标</span></span><br><span class="line">                </span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex); <span class="comment">//_MainTex 的采样坐标</span></span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap); <span class="comment">//_BumpMap 的采样坐标</span></span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">                </span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target &#123;        </span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">                </span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw)); <span class="comment">//获取切线空间法线方向</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//对屏幕图像的采样坐标进行偏移， _Distortion 越大偏移越大，则变形程度越大。选择使用切线空间下的法线方向来偏移，是因为该空间下法线反映顶点局部坐标下的方向。</span></span><br><span class="line">                float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line">                i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;</span><br><span class="line">                <span class="comment">//对 scrPos 透视除法得到真正的屏幕坐标（原理见数学基础），再使用该坐标对抓取的屏幕图像进行采样，得到模拟的折射颜色</span></span><br><span class="line">                fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//将法线从切线空间转换到世界空间</span></span><br><span class="line">                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));</span><br><span class="line">                fixed3 reflDir = reflect(-worldViewDir, bump); <span class="comment">//得到反射方向</span></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb; <span class="comment">//用反射方向对 Cubemap 进行采样</span></span><br><span class="line">                </span><br><span class="line">                fixed3 finalColor = reflCol * (<span class="number">1</span> - _RefractAmount) + refrCol * _RefractAmount; <span class="comment">//混合反射折射颜色</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将书中资源中的 Glass_Diffuse.jpg 、Glass_Normal.jpg 文件和创建的 Glass_Cubemap 赋给材质的 Main Tex 、Normal Map 和 Cubemap 属性后，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/15/YGCFPOfcRNzMyo7.jpg" width = "70%" height = "70%" alt="图53- 玻璃效果"/></div><p>在前面的实现中，我们在 GrabPass 中使用了一个字符串指明了被抓取的屏幕图像会存储在哪个名称的纹理中，实际上，GrabPass 支持两种形式：<br>①直接使用 GrabPass {}，然后在后续的 Pass 中直接使用 _GrabTexture 来访问屏幕图像。当场景中有多个物体都使用了这样的形式来抓取屏幕时，这种方法的性能消耗比较大，因为对于每一个使用了它的物体，Unity 都会为它单独进行一次昂贵的屏幕抓取操作。但这种方法可以让每个物体得到不同的屏幕图像，这取决于它们的渲染队列以及渲染它们时当前屏幕缓冲中的颜色；<br>②使用 GrabPass {“TextureName”}，我们可以在后续 Pass 中利用 TextureName 来访问屏幕图像。使用这种方法同样可以抓取屏幕，但 Unity 只会在每一帧时为第一个使用名为 TextureName 的纹理的物体执行一次抓取屏幕操作，而这个纹理同样可以在其他 Pass 中被访问。</p><h3 id="渲染纹理-vs-GrabPass"><a href="#渲染纹理-vs-GrabPass" class="headerlink" title="渲染纹理 vs GrabPass"></a>渲染纹理 vs GrabPass</h3><p>GrabPass 实现简单，只需几行代码。但在效率上，使用渲染纹理允许我们自定义渲染纹理的大小。而使用 GrabPass 获取到的图像分辨率和显示屏幕是一致的，意味着高分辨率屏幕的设备会造成严重的带宽影响。在移动设备上，GrabPass 不会重新渲染场景，但往往需要 CPU 直接读取后备缓冲（back buffer）中的数据，破坏 CPU 和 GPU 之间的并行性，比较耗时，且在一些移动设备上不支持。  </p><p>在 Unity 5 中，Unity 引入了<strong>命令缓冲 Command Buffers</strong> 来允许我们扩展 Unity 的渲染流水线。使用命令缓冲我们也可以得到类似于抓屏的效果，它可以在不透明物体渲染后把当前图像复制到一个临时的渲染目标纹理中，然后在那里进行一些额外的操作，例如模糊等。最后把图像传递给需要使用它的物体进行处理和显示。除此之外，命令缓冲允许我们实现很多特殊的效果，详见 Unity 官方手册的图像命令缓冲：<a href="https://docs.unity3d.com/Manual/GraphicsCommandBuffers.html">https://docs.unity3d.com/Manual/GraphicsCommandBuffers.html</a></p><h2 id="程序纹理"><a href="#程序纹理" class="headerlink" title="程序纹理"></a>程序纹理</h2><p><strong>程序纹理 Procedural Texture</strong> 指的是那些由计算机生成图像，通常由特定的算法来创建个性化图案或非常真实的自然元素，例如木头、石子等。使用程序纹理的好处在于我们可以使用各种参数来控制纹理的外观，而这些参数不仅仅是那些颜色属性，甚至可以是完全不同类型的图案属性，使得我们可以得到更加丰富自然的动画和视角效果。</p><h3 id="在-Unity-中实现简单的程序纹理"><a href="#在-Unity-中实现简单的程序纹理" class="headerlink" title="在 Unity 中实现简单的程序纹理"></a>在 Unity 中实现简单的程序纹理</h3><p>下面使用算法来生成波点纹理，准备工作如下：<br>①新建名为 Scene_10_3_1 的场景，并去掉天空盒；<br>②新建名为 ProceduralTextureMat 的材质；<br>③使用第 7 章创建的名为 Chapter7-SingleTexture 的 Unity Shader，并赋给上一步创建的材质；<br>④在场景中新建一个立方体，并将第 2 步创建的材质赋给它；<br>⑤无需为 ProceduralTextureMat 赋予任何纹理，因为要创建程序纹理。新建名为 ProceduralTextureGeneration 的 C# 脚本，赋给上一步创建的立方体；</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProceduralTextureGeneration</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Material material = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面 region 声明程序纹理的各个参数，SetProperty 是一个开源插件，为了在面板中修改属性时，执行 set 函数，见 http://github.com/LMNRY/SetProperty，在 Assets 下任意名字文件夹下解压即可使用</span></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Material properties</span></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;textureWidth&quot;</span>)</span>] <span class="comment">//纹理的大小，数值通常是 2 的整数幂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> m_textureWidth = <span class="number">512</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> textureWidth &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_textureWidth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_textureWidth = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;backgroundColor&quot;</span>)</span>] </span><br><span class="line">    <span class="keyword">private</span> Color m_backgroundColor = Color.white;</span><br><span class="line">    <span class="keyword">public</span> Color backgroundColor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_backgroundColor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_backgroundColor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;circleColor&quot;</span>)</span>] <span class="comment">//圆点的颜色</span></span><br><span class="line">    <span class="keyword">private</span> Color m_circleColor = Color.yellow;</span><br><span class="line">    <span class="keyword">public</span> Color circleColor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_circleColor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_circleColor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField, SetProperty(<span class="string">&quot;blurFactor&quot;</span>)</span>] <span class="comment">//模糊因子，用于模糊圆形边界</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> m_blurFactor = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> blurFactor &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m_blurFactor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            m_blurFactor = <span class="keyword">value</span>;</span><br><span class="line">            _UpdateMaterial();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Texture2D m_generatedTexture = <span class="literal">null</span>; <span class="comment">//声明 Texture2D 纹理变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123; <span class="comment">//进行一些检测</span></span><br><span class="line">        <span class="keyword">if</span> (material == <span class="literal">null</span>) &#123;</span><br><span class="line">            Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();</span><br><span class="line">            <span class="keyword">if</span> (renderer == <span class="literal">null</span>) &#123;</span><br><span class="line">                Debug.LogWarning(<span class="string">&quot;Cannot find a renderer.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            material = renderer.sharedMaterial; <span class="comment">//得到物体上的材质</span></span><br><span class="line">        &#125;</span><br><span class="line">        _UpdateMaterial(); <span class="comment">//调用 _UpdateMaterial() 来生成程序纹理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> _UpdateMaterial() &#123;</span><br><span class="line">        <span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">            m_generatedTexture = _GenerateProceduralTexture(); <span class="comment">//调用 _GenerateProceduralTexture() 生成一张程序纹理</span></span><br><span class="line">            material.SetTexture(<span class="string">&quot;_MainTex&quot;</span>, m_generatedTexture); <span class="comment">//利用该函数把生成的纹理赋给材质</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Color _MixColor(Color color0, Color color1, <span class="built_in">float</span> mixFactor) &#123;</span><br><span class="line">        Color mixColor = Color.white;</span><br><span class="line">        mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);</span><br><span class="line">        mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);</span><br><span class="line">        mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);</span><br><span class="line">        mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);</span><br><span class="line">        <span class="keyword">return</span> mixColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Texture2D _GenerateProceduralTexture() &#123;</span><br><span class="line">        Texture2D proceduralTexture = <span class="keyword">new</span> Texture2D(textureWidth, textureWidth);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> circleInterval = textureWidth / <span class="number">4.0f</span>; <span class="comment">//定义圆与圆之间的距离</span></span><br><span class="line">        <span class="built_in">float</span> radius = textureWidth / <span class="number">10.0f</span>; <span class="comment">//定义圆半径</span></span><br><span class="line">        <span class="built_in">float</span> edgeBlur = <span class="number">1.0f</span> / blurFactor; <span class="comment">//定义模糊系数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> w = <span class="number">0</span>; w &lt; textureWidth; w++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> h = <span class="number">0</span>; h &lt; textureWidth; h++) &#123;</span><br><span class="line">                Color pixel = backgroundColor; <span class="comment">//使用背景颜色初始化</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//依次画九个圆</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">//计算当前绘制的圆的圆心位置</span></span><br><span class="line">                        Vector2 circleCenter = <span class="keyword">new</span> Vector2(circleInterval * (i + <span class="number">1</span>), circleInterval * (j + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//计算像素与圆的距离</span></span><br><span class="line">                        <span class="built_in">float</span> dist = Vector2.Distance(<span class="keyword">new</span> Vector2(w, h), circleCenter) - radius;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//通过距离模糊圆的边界</span></span><br><span class="line">                        Color color = _MixColor(circleColor, <span class="keyword">new</span> Color(pixel.r, pixel.g, pixel.b, <span class="number">0.0f</span>), Mathf.SmoothStep(<span class="number">0f</span>, <span class="number">1.0f</span>, dist * edgeBlur));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//与之前得到的颜色进行混合</span></span><br><span class="line">                        pixel = _MixColor(pixel, color, color.a);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                proceduralTexture.SetPixel(w, h, pixel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        proceduralTexture.Apply(); <span class="comment">//调用 Texture2D.Apply 函数来强制把像素值写入纹理中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proceduralTexture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><div  align="center">  <img src="https://s2.loli.net/2023/12/15/YzuqtnJWpxZhgaV.jpg" width = "70%" height = "70%" alt="图54- 脚本生成的程序纹理"/></div><h3 id="Unity-的程序材质"><a href="#Unity-的程序材质" class="headerlink" title="Unity 的程序材质"></a>Unity 的程序材质</h3><p>在 Unity 中，有一种专门使用程序纹理的材质，叫做<strong>程序材质 Procedural Materials</strong>。这类材质和我们之前使用的那些材质在本质上是一样的，只是使用的是程序纹理，程序材质使用的程序纹理不是在 Unity 中创建的，而是使用一个名为 <strong>Substance Designer</strong> 的软件在 Unity 外部生成的。这些材质都是以 .sbsar 为后缀的，把这些材质导入 Unity 中后（现在的版本需要在 asset store 中安装 Substance 3D for Unity 插件），Unity 就会生成一个<strong>程序纹理资源 Procedural Material Asset</strong>。程序纹理资源可以包含一个或多个程序材质，通过单击它，我们可以在程序纹理面板中看到材质的使用的 Unity Shader 及其属性、生成程序纹理使用的纹理属性、材质预览等信息。</p><h1 id="第十章-让画面动起来"><a href="#第十章-让画面动起来" class="headerlink" title="第十章 让画面动起来"></a>第十章 让画面动起来</h1><h2 id="Unity-Shader-中的内置时间变量"><a href="#Unity-Shader-中的内置时间变量" class="headerlink" title="Unity Shader 中的内置时间变量"></a>Unity Shader 中的内置时间变量</h2><p>动画效果往往都是把时间添加到一些变量的计算中，而 Unity Shader 提供了一系列关于时间的内置变量：</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">_Time</td><td style="text-align:left">float4</td><td style="text-align:left">t是自该场景加载开始所经过的时间，4个分量的值分别是（t/20, t, 2t, 3t）</td></tr><tr><td style="text-align:left">_SinTime</td><td style="text-align:left">float4</td><td style="text-align:left">t 是时间的正弦值，4 个分量分别是 (t/8, t/4, t/2, t)</td></tr><tr><td style="text-align:left">_CosTime</td><td style="text-align:left">float4</td><td style="text-align:left">t 是时间的余弦值，4 个分量的值分别是 (t/8, t/4, t/2, t)</td></tr><tr><td style="text-align:left">unity_DeltaTime</td><td style="text-align:left">float4</td><td style="text-align:left">dt 是时间增量，4 个分量的值分别是 (dt, 1/dt, smoothDt, 1/smoothDt)</td></tr></tbody></table></div><h2 id="纹理动画"><a href="#纹理动画" class="headerlink" title="纹理动画"></a>纹理动画</h2><p>在资源比较局限的移动平台上，往往会使用纹理动画代替复杂的粒子效果等模拟各种动画效果。</p><h3 id="序列帧动画"><a href="#序列帧动画" class="headerlink" title="序列帧动画"></a>序列帧动画</h3><p>最常见的纹理动画之一就是序列帧动画，其原理很简单，依次播放一系列关键帧图像，当播放速度达到一定数值时，其看起来就是一个连续的动画。其优点在于灵活性很强，不需要任何物理计算就可以得到细腻的动画效果。其缺点在于每张关键帧图像都不一样，从而制造一张出色的序列帧纹理所需要的美术工程量很大。</p><p>本书资源提供了一张包含关键帧图像的图像（Assets/Textures/Chapter11/boom.png），接下来通过案例来了解序列帧动画的实现：</p><p>完成如下准备工作：<br>①新建名为 Scene_11_2_1 的场景，并去掉天空盒；<br>②新建名为 ImageSequenceAnimationMat 的材质；<br>③新建名为 Chapter11-ImageSequenceAnimation 的 Unity Shader，并赋给上一步创建的材质；<br>④在场景中新建一个四边形 Quad，调整它的位置，使其正对相机，并将第2步创建的材质赋给它。</p><p>序列帧动画的精髓在于需要在每个时刻计算该时刻下应该播放的关键帧的位置，并对该关键帧进行纹理采样，代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 11/Image Sequence Animation&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)    </span><br><span class="line">        _MainTex (<span class="string">&quot;Image Sequence&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//包含了所有关键帧图像的纹理</span></span><br><span class="line">        _HorizontalAmount (<span class="string">&quot;Horizontal Amount&quot;</span>, Float) = <span class="number">4</span> <span class="comment">//该图像在水平方向包含的关键帧图像的个数</span></span><br><span class="line">        _VerticalAmount (<span class="string">&quot;Vertical Amount&quot;</span>, Float) = <span class="number">4</span> <span class="comment">//该图像在竖直方向包含的关键帧图像的个数</span></span><br><span class="line">        _Speed (<span class="string">&quot;Speed&quot;</span>, Range(<span class="number">1</span>, <span class="number">100</span>)) = <span class="number">30</span> <span class="comment">//控制序列帧动画的播放速度</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;<span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span>=<span class="string">&quot;True&quot;</span> <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span>&#125; <span class="comment">//序列帧通常是透明纹理，从而需要设置 Pass 相关状态，以渲染透明效果</span></span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off <span class="comment">//关闭深度写入</span></span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha <span class="comment">//开启并设置混合模式</span></span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert  </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            <span class="type">float</span> _HorizontalAmount;</span><br><span class="line">            <span class="type">float</span> _VerticalAmount;</span><br><span class="line">            <span class="type">float</span> _Speed;</span><br><span class="line">              </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span>  </span><br><span class="line">                float4 vertex : POSITION; </span><br><span class="line">                float2 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;  </span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span>  </span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;  </span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span> &#123;  </span><br><span class="line">                v2f o;  </span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);  </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex); </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;  </span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                <span class="comment">//前三列代码计算行列数，以获取关键帧所在的行列索引值</span></span><br><span class="line">                <span class="type">float</span> time = <span class="built_in">floor</span>(_Time.y * _Speed); <span class="comment">//_Time.y 是该场景加载后经过的时间，把其与速度属性相乘得到模拟的时间，并用 Cg 的 floor 函数对结果值取整来得到整数时间 time</span></span><br><span class="line">                <span class="type">float</span> row = <span class="built_in">floor</span>(time / _HorizontalAmount); <span class="comment">//time 除以行的个数的商作为当前对应的行索引</span></span><br><span class="line">                <span class="type">float</span> column = time - row * _HorizontalAmount; <span class="comment">//余数为列索引</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//接下来将采样坐标映射到每个关键帧图像的坐标范围内</span></span><br><span class="line">                <span class="comment">//half2 uv = float2(i.uv.x /_HorizontalAmount, i.uv.y / _VerticalAmount); 这行是将 uv 等分，得到每个子图像的纹理坐标范围</span></span><br><span class="line">                <span class="comment">//uv.x += column / _HorizontalAmount;</span></span><br><span class="line">                <span class="comment">//uv.y -= row / _VerticalAmount; 使用减法是因为序列帧播放顺序是自上而下，而 uv 坐标是自下而上的</span></span><br><span class="line">                half2 uv = i.uv + half2(column, -row);</span><br><span class="line">                uv.x /=  _HorizontalAmount;</span><br><span class="line">                uv.y /= _VerticalAmount;</span><br><span class="line">                </span><br><span class="line">                fixed4 c = tex2D(_MainTex, uv);</span><br><span class="line">                c.rgb *= _Color;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Transparent/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面原书中片元着色器代码有点小问题，直接从图片的最下面一行的第一张开始播放，但因为图片的 Wrap Mode 是 Repeat 模式，所以不影响整体表现。加一行 <code>row -= _VerticalAmount - 1</code> 就可以从第一行开始播放了。</p></blockquote><p>将 Boom.png 勾选 Alpha Is Transparency 属性，任何赋给材质，并将 Horizontal Amount 和 Vertical Amount 设为 8。效果如下：  </p><table><tr><td><img src='https://s2.loli.net/2023/12/18/DxIHLk9ZGjSA8Mr.png' width="400" alt="图55- 本节使用的序列帧图像"></td><td><img src='https://s2.loli.net/2023/12/18/fpnN4ew8GxQo51Z.gif' width="400" alt="图56- 使用序列帧动画来实现爆炸效果"></td></tr></table><h3 id="滚动的背景"><a href="#滚动的背景" class="headerlink" title="滚动的背景"></a>滚动的背景</h3><p>很多 2D 游戏都使用了不断滚动的背景来模拟游戏角色在场景中的穿梭，这些背景往往包含了多个层来模拟一种视差效果。而这些背景的实现往往是利用了纹理动画。</p><p>完成如下准备工作：<br>①新建名为 Scene_11_2_2 的场景，去掉天空盒，同时将相机的投影模式设置为正交投影；<br>②新建名为 ScrollingBackgroundMat 的材质；<br>③新建名为 Chapter11-ScrollingBackground 的 Unity Shader，并赋给上一步创建的材质；<br>④在场景中创建一个四边形 Quad，调整其位置、大小，使它充满相机的视野范围，并将第2步创建的材质赋给它。</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 11/Scrolling Background&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Base Layer (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//第一层（较远）的纹理</span></span><br><span class="line">        _DetailTex (<span class="string">&quot;2nd Layer (RGB)&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//第二层（较近）的纹理</span></span><br><span class="line">        _ScrollX (<span class="string">&quot;Base layer Scroll Speed&quot;</span>, Float) = <span class="number">1.0</span> <span class="comment">//第一层的水平滚动速度</span></span><br><span class="line">        _Scroll2X (<span class="string">&quot;2nd layer Scroll Speed&quot;</span>, Float) = <span class="number">1.0</span> <span class="comment">//第二层的滚动速度</span></span><br><span class="line">        _Multiplier (<span class="string">&quot;Layer Multiplier&quot;</span>, Float) = <span class="number">1</span> <span class="comment">//控制纹理的整体亮度</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            sampler2D _DetailTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            float4 _DetailTex_ST;</span><br><span class="line">            <span class="type">float</span> _ScrollX;</span><br><span class="line">            <span class="type">float</span> _Scroll2X;</span><br><span class="line">            <span class="type">float</span> _Multiplier;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;        </span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex); </span><br><span class="line"></span><br><span class="line">                <span class="comment">//通过利用 TRANSFORM_TEX 来得到初始纹理坐标，再通过 _Time.y 变量在水平空间上对纹理坐标进行偏移，从而达到滚动的效果。Cg 的 frac 函数返回标量或者矢量的小数部分</span></span><br><span class="line">                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, <span class="number">0.0</span>) * _Time.y);</span><br><span class="line">                o.uv.zw = TRANSFORM_TEX(v.texcoord, _DetailTex) + frac(float2(_Scroll2X, <span class="number">0.0</span>) * _Time.y);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//最后将两张纹理的纹理坐标存储到同一个变量 o.uv 中，以减少占用的插值寄存器空间</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed4 firstLayer = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">                fixed4 secondLayer = tex2D(_DetailTex, i.uv.zw);</span><br><span class="line">                </span><br><span class="line">                fixed4 c = lerp(firstLayer, secondLayer, secondLayer.a); <span class="comment">//使用第二层纹理的透明通道来混合两张纹理，利用 lerp 函数</span></span><br><span class="line">                c.rgb *= _Multiplier;        <span class="comment">//使用 _Multiplier 与输出颜色进行相乘从而调整背景亮度</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导入两张背景纹理，资源在 Assets/Textures/Chapter11/far_background.png 和 near_background.png，调整滚动速度，效果如下（只截取了 2 秒时间）：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/18/a6g3Sm9wN1z2fpL.gif" width = "70%" height = "70%" alt="图57- 无限滚动的背景"/></div><h2 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h2><h3 id="流动的河流"><a href="#流动的河流" class="headerlink" title="流动的河流"></a>流动的河流</h3><p>使用正弦函数等来模拟水流的波动效果，准备工作如下：<br>①新建名为 Scene_11_3_1 的场景，并去掉天空盒子；<br>②将场景相机投影类型调整为正交投影；<br>③新建 3 个材质，分别命名为 WaterMat、WaterMat1、WaterMat2（需要模拟多层水流效果）；<br>④新建名为 Chapter11-Water 的 Unity Shader，并分别赋给上一步创建的 3 个材质；<br>⑤在场景中创建 3 个 Water 模型，调整其位置、大小和方向，将第二步创建的材质分别赋给它们（模型详见Assets/Models/Chap11/water_fall.fbx）</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 11/Water&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//河流纹理</span></span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">//用于控制整体颜色</span></span><br><span class="line">        _Magnitude (<span class="string">&quot;Distortion Magnitude&quot;</span>, Float) = <span class="number">1</span> <span class="comment">//控制水流波动的幅度</span></span><br><span class="line">        _Frequency (<span class="string">&quot;Distortion Frequency&quot;</span>, Float) = <span class="number">1</span> <span class="comment">//用于控制波动频率</span></span><br><span class="line">        _InvWaveLength (<span class="string">&quot;Distortion Inverse Wave Length&quot;</span>, Float) = <span class="number">10</span> <span class="comment">//用于控制波长的倒数，其越大，波长越小</span></span><br><span class="line">        _Speed (<span class="string">&quot;Speed&quot;</span>, Float) = <span class="number">0.5</span> <span class="comment">//河流纹理的移动速度</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;<span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span>=<span class="string">&quot;True&quot;</span> <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;DisableBatching&quot;</span>=<span class="string">&quot;True&quot;</span>&#125; <span class="comment">//通过 DisableBatching 标签可以直接指明是否对该 subshader 采用批处理，一些 SubShader 在使用 Unity 的批处理功能时会出现问题，因为批处理会合并所有相关的模型，而这些模型各自的模型空间就会丢失。而在河流模拟中需要在物体的模型空间下对顶点位置进行偏移，从而需要取消对该 shader 进行批处理</span></span><br><span class="line">        </span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            Cull Off <span class="comment">//关闭剔除功能，从而让水流的每个面都能显示</span></span><br><span class="line">            </span><br><span class="line">            CGPROGRAM  </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert </span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span> </span></span><br><span class="line">            </span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="type">float</span> _Magnitude;</span><br><span class="line">            <span class="type">float</span> _Frequency;</span><br><span class="line">            <span class="type">float</span> _InvWaveLength;</span><br><span class="line">            <span class="type">float</span> _Speed;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123; <span class="comment">//在顶点着色器中进行相关的顶点动画</span></span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                float4 offset;</span><br><span class="line">                <span class="comment">//首先计算顶点位移量，因为只希望对顶点的 x 方向进行位移，因此 yzw 的位移量被设置为 0。这里对 x 方向偏移是因为资源里给的模型的 x 轴是上下方向，可以查看模型的 local 坐标确认。</span></span><br><span class="line">                offset.yzw = float3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); </span><br><span class="line">                <span class="comment">//利用 _Frequency 属性和内置的 _Time.y 来控制正弦函数的频率。同时为了让不同的位置具有不同的位移，从而需要加上模型空间下的位置分量，并乘以 _InvWaveLength 来控制波长，最后通过乘以_Magnitude属性来控制波动幅度从而得到最终的位移</span></span><br><span class="line">                offset.x = <span class="built_in">sin</span>(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将位移量添加到顶点位置上，并进行正常的顶点变换即可</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex + offset); </span><br><span class="line">                </span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                o.uv +=  float2(<span class="number">0.0</span>, _Time.y * _Speed); <span class="comment">//这个速度是纹理的流动速度</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">                c.rgb *= _Color.rgb;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125; </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Transparent/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>补充：注意看模型的 object space coordinate，和世界坐标是不一样的。若 _InvWaveLength 为 0，水流是个长方形并且整体上下晃动没有波形。_Magnitude 控制整体上下晃动的幅度，_Frequency 控制上下晃动频率。_InvWaveLength 控制的就是波形，水流的方向和模型空间的 z 轴是一致的，所以对波形影响最大的是 v.vertex.z ，顶点 z 轴的差异产生了波形，而 x 轴也有影响，这个水带的上下波形是有相位差的，这个是由 x 分量产生的影响。</p></blockquote><p>将水体纹理分别赋到3个材质面板的 Main Tex 属性上（纹理详见 Assets/Textures/Chap11/water.psd），并分别配置其他参数，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/19/2pBWSz49kwyIDZE.gif" width = "70%" height = "70%" alt="图58- 使用顶点动画来模拟2D的河流"/></div><h3 id="广告牌"><a href="#广告牌" class="headerlink" title="广告牌"></a>广告牌</h3><p>另一种常见的顶点动画就是<strong>广告牌技术 Billboarding</strong>。广告牌技术会根据视角方向来旋转一个被纹理着色的多边形，使得多边形看起来好像总是面对着摄像机。广告牌技术被用于很多应用，比如渲染烟雾、云朵、闪光效果等。</p><p>广告牌技术的本质就是构建一个<strong>旋转矩阵</strong>，我们知道一个变换矩阵需要 3 个基向量。广告牌技术使用的基向量通常就是<strong>表面法线 normal</strong>、<strong>指向上方向 up</strong> 以及<strong>指向右方向 right</strong> 。除此之外，还需要指定一个<strong>锚点 anchor location</strong>，这个锚点在旋转过程中是不变的，以此来确定多边形在空间中的位置。</p><p>广告牌技术的难点在于如何根据需求来构建 3 个相互正交的基向量。计算过程：<br>①通过初始计算得到目标的表面法线（就是视角方向）、指向上的方向（两者一般不垂直）；<br>②根据需求确定这两个方向哪一个是固定的：如果模拟草丛，我们希望指向上的方向是固定的，永远是（0, 1,  0）。如果模拟粒子效果，我们希望表面法线是固定的，永远指向视角方向；<br>③假设法线方向是固定的，首先根据表面法线、指向上的方向的叉积，得到指向右的方向（通过叉积操作）：  </p><script type="math/tex; mode=display">right = up \times normal</script><p>④对其归一化后，由法线方向、指向右的方向，计算出正交的指向上的方向：  </p><script type="math/tex; mode=display">up' = normal \times right</script><p>这样就可以得到用于旋转的 3 个正交基了，如下图所示：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/19/W36kirHYV9SPwg8.jpg" width = "70%" height = "70%" alt="图59- 法线固定（总是指向视角方向）时，计算广告牌技术中的三个正交基的过程"/></div><p>准备工作如下：<br>①新建名为 Scene_11_3_2 的场景，并去掉天空盒子；<br>②新建名为 BillboardMat 的材质；<br>③新建名为 Chapter11-Billboard 的 Unity Shader，并赋给上一步创建的材质；<br>④在场景中创建多个四边形 Quad，调整其位置和大小，并将第二步创建的材质赋给它们，这些四边形就是用于广告牌技术的广告牌。</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 11/Billboard&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//广告牌显示的透明纹理</span></span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">//用于控制显示整体颜</span></span><br><span class="line">        _VerticalBillboarding (<span class="string">&quot;Vertical Restraints&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span> <span class="comment">//调整固定法线还是固定指向上的方向，即约束垂直方向的程度 </span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;<span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span>=<span class="string">&quot;True&quot;</span> <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;DisableBatching&quot;</span>=<span class="string">&quot;True&quot;</span>&#125; <span class="comment">//关闭批处理，因为本例子中需要处理模型的各顶点</span></span><br><span class="line">        </span><br><span class="line">        Pass &#123; </span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span>=<span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line">            </span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            Cull Off <span class="comment">//关闭剔除功能，从而让广告牌的每个面都能显示出来</span></span><br><span class="line">        </span><br><span class="line">            CGPROGRAM</span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">            </span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line">            </span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            fixed _VerticalBillboarding;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                </span><br><span class="line">                float3 center = float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//选择模型空间的原点作为广告牌的锚点</span></span><br><span class="line">                float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, <span class="number">1</span>)); <span class="comment">//通过内置变量获取模型空间下的视角位置</span></span><br><span class="line">                </span><br><span class="line">                float3 normalDir = viewer - center; <span class="comment">//根据观察位置和锚点计算原法线方向（视角方向）</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//根据 _VerticalBillboarding 控制垂直方向上的约束度。若 _VerticalBillboarding 为 1，意味着法线方向固定为视角方向；当 _VerticalBillboarding 为 0，法线的 y 轴为 0，则意味着向上方向固定为（0，1，0），因为这样法线和向上方向垂直，而 x、z 根据原法线视角方向变化，得到未归一化的新法线方向</span></span><br><span class="line">                normalDir.y = normalDir.y * _VerticalBillboarding;</span><br><span class="line">                normalDir = normalize(normalDir); <span class="comment">//归一化来得到单位矢量</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//为防止法线方向和向上方向平行（如果平行，那么叉积结果为 0），即如果法线已经向上，那么向上方向为朝前方向。</span></span><br><span class="line">                float3 upDir = <span class="built_in">abs</span>(normalDir.y) &gt; <span class="number">0.999</span> ? float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) : float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//根据法线方向和原向上方向得到向右方向，并进行归一化</span></span><br><span class="line">                float3 rightDir = normalize(cross(upDir, normalDir));</span><br><span class="line">                <span class="comment">//根据法线方向和向右方向得到最后的新向上方向</span></span><br><span class="line">                upDir = normalize(cross(normalDir, rightDir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//根据顶点位置对于锚点的偏移量以及 3 个基向量得到新的顶点位置</span></span><br><span class="line">                float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">                float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z; </span><br><span class="line">              </span><br><span class="line">                o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);        </span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed4 c = tex2D (_MainTex, i.uv);</span><br><span class="line">                c.rgb *= _Color.rgb;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    FallBack <span class="string">&quot;Transparent/VertexLit&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>上述 rightDir 和 upDir 是叉乘顺序可能有问题，因为在左手坐标系叉乘结果是左手法则，上述叉乘的顺序会导致基向量从左手坐标系变为右手坐标系，这会导致整个模型镜像变换。若把 Cull Off 改为 Cull back 可以看到模型看不到了。</p></blockquote><p>需要说明的是，上面的例子使用的是 Unity 自带的四边形 Quad 作为广告牌，不能使用平面 Plane。这是因为上述代码的计算是建立在竖直摆放的多边形的基础上的。将星星纹理赋给材质面板的 Main Tex 属性，详见 Assets/Textures/Chap11/star.png，效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/19/QxHBOsTvqCmaeNg.gif" width = "70%" height = "70%" alt="图60- 该图显示了当 Vertical Restraints 属性为1，即固定法线方向为观察视角时所得到的效果"/></div><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>顶点动画虽然灵活有效，但是有一些注意事项：<br>①若在模型空间下进行顶点动画计算，那么批处理往往会破坏这种动画效果。然而，强制取消批处理，会带来一定的性能下降，增加 Draw Call。所以尽量避免使用模型空间下的一些绝对位置和方向来进行计算；<br>②给包含顶点动画的物体添加阴影，无法通过调用内置 ShadowCaster Pass 实现，因为这个 Pass 里没有进行相关的顶点动画，得到的阴影是顶点变化前的。此时需要自定义 ShadowCaster Pass，在顶点着色器中重新计算一遍顶点的位置。在前面的实现中，因为 Fallback 设置为 Transparent/VertexLit，而 Transparent/VertexLit 没有定义  ShadowCaster Pass，因此不会产生阴影。</p><p>ShadowCaster Pass 的相关代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ShadowCaster&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> multi_compile_shadowcaster</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> _Magnitude;</span><br><span class="line">    <span class="type">float</span> _Frequency;</span><br><span class="line">    <span class="type">float</span> _InvWaveLength;</span><br><span class="line">    <span class="type">float</span> _Speed;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span> </span><br><span class="line">        V2F_SHADOW_CASTER;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    v2f <span class="title function_">vert</span><span class="params">(appdata_base v)</span> &#123;</span><br><span class="line">        v2f o;</span><br><span class="line"></span><br><span class="line">        float4 offset;</span><br><span class="line">        offset.yzw = float3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        offset.x = <span class="built_in">sin</span>(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">        v.vertex = v.vertex + offset;</span><br><span class="line"></span><br><span class="line">        TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">        SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/12/19/PFGwerLgQTdDJn7.jpg" width = "70%" height = "70%" alt="图61- 使用自定义的 ShadowCaster Pass 为变形物体绘制正确的阴影"/></div><p>在自定义的阴影投射的 Pass 中，我们通常会使用 Unity 提供的内置宏 V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET（旧版本中为 TRANSFER_SHADOW_CASTER）和 SHADOW_CASTER_FRAGMENT 来计算阴影投射时需要的各自变量。  </p><p>在上面代码中，首先在 v2f 结构体中使用了 V2F_SHADOW_CASTER 来定义阴影投射所需要定义的变量。在顶点着色器中计算偏移量，加到顶点位置变量中，剩下的交给 TRANSFER_SHADOW_CASTER_NORMALOFFSET。在片元着色器中，直接使用 SHADOW_CASTER_FRAGMENT 让 Unity 自动完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。</p><p>TRANSFER_SHADOW_CASTER_NORMALOFFSET 会使用名称 v 作为输入结构体，v 中需要包含顶点位置 v.vertex 和顶点法线 v.normal 的信息，我们也可以直接使用内置的 appdata_base 结构体，它包含了这些必需的顶点变量。</p>]]></content>
      
      
      <categories>
          
          <category> unity </category>
          
          <category> unity shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> unity </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Unity Shader入门精要》读书笔记（二）</title>
      <link href="/2023/10/13/2023-10-13-UnityShader2/"/>
      <url>/2023/10/13/2023-10-13-UnityShader2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本读书笔记为初级篇，主要内容为 Unity Shader 的结构及 Unity 提供的便利、基础光照、基础纹理和透明效果。<br>读书笔记是对知识的记录与总结，但是对比较熟悉的内容不会再行描述。</p></blockquote><h1 id="第四章-开始-Unity-Shader-学习之旅"><a href="#第四章-开始-Unity-Shader-学习之旅" class="headerlink" title="第四章 开始 Unity Shader 学习之旅"></a>第四章 开始 Unity Shader 学习之旅</h1><h2 id="一个简单的顶点-片元着色器"><a href="#一个简单的顶点-片元着色器" class="headerlink" title="一个简单的顶点/片元着色器"></a>一个简单的顶点/片元着色器</h2><h3 id="顶点-片元着色器的基本结构"><a href="#顶点-片元着色器的基本结构" class="headerlink" title="顶点/片元着色器的基本结构"></a>顶点/片元着色器的基本结构</h3><p>Unity Shader 的基本结构包含了 Shader、Properties、SubShader、Fallback 等语义块，顶点/片元着色器也是若此，结构如下：</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;MyShaderName&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 针对显卡 A 的 SubShader</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// 设置渲染状态和标签</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始 Cg 代码片段</span></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">// 该代码片段的编译指令。例如：</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Cg 代码写在这里</span></span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其他设置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他需要的 Pass</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// 针对显卡 B 的 SubShader</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上述 SubShader 都失败后用于回调的 Unity Shader</span></span><br><span class="line">    Fallback <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最重要的部分是 Pass 语义块，绝大部分代码都写在这里面。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p><strong><em>1. 案例常用操作说明</em></strong><br>后续所有的案例代码编写都会涉及创建场景、创建 Shader、创建材质、关闭天空盒等操作，在此做一下说明。为统一规范，建议在新建项目的 Assets 根目录下创建如下几个文件夹：</p><p>①Scenes 存放场景 ②Shaders 存放着色器代码 ③Materials 存放材质 ④Textures 存放贴图 ⑤Models 存放案例需要用到的模型 ⑥Scripts 存放案例需要编写的 C# 代码 ⑦Prefabs 存放预制体。</p><p>关闭天空盒：为了更清楚地看到 Shader 实现的效果，我们一般选择关闭天空盒。选中对应场景后，在单击菜单栏 -&gt; Window -&gt; Rendering -&gt; Lighting Settings -&gt; Environment -&gt; Skybox Material，选择为 None 即可。</p><p><strong><em>2. 简单的顶点/片元着色器示例</em></strong><br>①新建一个场景，命名为 Scene_5_2 ，并关闭天空盒；<br>②新建一个 Unity Shader，命名为 Chapter5-SimpleShader；<br>③新建一个材质，命名为 SimpleShaderMat，并选择步骤 2 创建的 Shader 赋给它；<br>④新建一个球体，并更换材质为刚刚创建的 SimpleShaderMat。<br>⑤双击打开步骤 2 创建的 Shader 。删除里面所有代码，替换为下面代码：</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一行，通过 Shader 语义，定义这个 Shader 的名字，名字中使用&#x27;/&#x27;可定义该Shader的路径（或分组）</span></span><br><span class="line"><span class="comment">// 回到之前创建的材质，选择 Shader，可以看到多了一个 Unity Shaders Book 目录，下面的子目录 Chapter 5 里面就有我们目前的 Shader</span></span><br><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 5/Simple Shader&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// Properties 语义并不是必需的</span></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">// SubShader 中没有进行任何渲染设置和标签设置，所以该 SubShader 将使用默认的设置</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// Pass 中没有进行任何渲染设置和标签设置，所以该 Pass 将使用默认的设置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由 CGPROGRAM 和 ENDCG 包围 CG 代码片段</span></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 告诉 Unity，顶点着色器的代码在 vert 函数中 （格式：#pragma vertex name）</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="comment">// 告诉 Unity，片元着色器的代码在 frag 函数中 （格式：#pragma fragment name）</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 顶点着色器代码，它是逐顶点执行的</span></span><br><span class="line">            <span class="comment">// 通过 POSITION 语义，告诉顶点着色器，输入 v 是这个顶点的模型坐标</span></span><br><span class="line">            <span class="comment">// SV_POSITION 语义表示返回的 float4 类型的变量，是当前顶点在裁剪空间中的坐标</span></span><br><span class="line">            <span class="comment">// 注意：这两个语义是不能省略的，着色器通过语义来辨识各个变量是用来做什么的，并用在不同的底层处理中</span></span><br><span class="line">            float4 <span class="title function_">vert</span><span class="params">(float4 v : POSITION)</span> : SV_POSITION &#123;</span><br><span class="line">                <span class="keyword">return</span> UnityObjectToClipPos(v); </span><br><span class="line">                <span class="comment">// 或者使用这个语句 return mul(UNITY_MATRIX_MVP, v); 会被自动替换为上面语句</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 片元着色器代码</span></span><br><span class="line">            <span class="comment">// frag 函数没有任何输入，输出是一个 fixed4 类型的变量，并且使用了 SV_Target 语义进行限定</span></span><br><span class="line">            <span class="comment">// 通过 SV_Target 语义，告诉渲染器，把用户的输出颜色存储到一个渲染目标中（比如默认的帧缓存中）</span></span><br><span class="line">            <span class="comment">// 颜色的 RGBA 每个分量范围在[0, 1]，所以使用 fixed4 类型</span></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">()</span> : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>pragma 的释义和渊源：A pragma (from the Greek word meaning action) is used to direct the actions of the compiler in particular ways, but has no effect on the semantics of a program (in general).The programming language Ada was quite possibly the first compiler to use pragma to specify preprocessor directives. The word was used as a shortened form of “pragmatic information”. When the C programming language was designed it didn’t initially have pragma directives, but was quickly added to the specification to support custom compiler features.   </p><p>sv_position 中的 sv 指 system value，系统值语义是 Direct3D 10 的新增功能。所有系统值都以 SV 前缀开头。详见：<a href="https://learn.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics?redirectedfrom=MSDN#System_Value">https://learn.microsoft.com/zh-cn/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics?redirectedfrom=MSDN#System_Value</a> </p></blockquote><h3 id="使用结构体获取模型数据"><a href="#使用结构体获取模型数据" class="headerlink" title="使用结构体获取模型数据"></a>使用结构体获取模型数据</h3><p>上面的例子中，顶点着色器使用 POSITION 语义得到了模型的顶点坐标，除了需要当前顶点的坐标外，还需要诸如：法线、切线、纹理坐标等信息时，通常会定义一个结构体，在结构体声明多个变量，并赋予其语义，可将更多的顶点信息传入到顶点着色器中。修改后的代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 5/Simple Shader&quot;</span> &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用结构体作为顶点着色器的输入，可以包含更多模型数据</span></span><br><span class="line">            <span class="comment">// a2v 是当前结构体的名字，可自行定义（写法：struct [StructName]）</span></span><br><span class="line">            <span class="comment">// 这里 a2v 表示 application to vertex ，意思是：把数据从应用阶段传递到顶点着色器中</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                <span class="comment">// POSITION 语义告诉 Unity，用模型的顶点空间坐标填充 vertex 变量</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                <span class="comment">// Normal 语义告诉 Unity，用模型的法线方向填充 normal 变量</span></span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                <span class="comment">// TEXCOORD0 语义告诉 Unity，用模型的第一套纹理坐标填充 texcoord 变量</span></span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">                <span class="comment">// 上述语义中的数据由使用该材质的 Mesh Renderer 组件提供。在每帧调用 Draw Call 时，Mesh Renderer 组件会把它负责渲染的模型数据发送给 Unity Shader</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用结构体作为输入参数，不需要写语义，因为语义在结构体里已经声明了</span></span><br><span class="line">            float4 <span class="title function_">vert</span><span class="params">(a2v v)</span> : SV_POSITION &#123;</span><br><span class="line">                <span class="comment">// 从结构体中访问当前顶点的模型空间坐标，将其转为裁剪空间下的坐标</span></span><br><span class="line">                <span class="keyword">return</span> UnityObjectToClipPos(v.vertex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">()</span> : SV_Target &#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①一个自定义结构体的格式如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct StructName &#123;</span><br><span class="line">    Type Name: Semantic;</span><br><span class="line">    Type Name: Semantic;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>②对于顶点着色器的输入，Unity 支持的语义有：POSITION 、 NORMAL 、 TANGENT 、TEXCOORD0 、 TEXCOORD1 、 TEXCOORD2 、 TEXCOORD3 、 COLOR 等  </p><h3 id="顶点着色器和片元着色器的通信"><a href="#顶点着色器和片元着色器的通信" class="headerlink" title="顶点着色器和片元着色器的通信"></a>顶点着色器和片元着色器的通信</h3><p>因为我们往往希望从顶点着色器输出一些数据，例如把模型的法线、纹理坐标等传给片元着色器，此时将涉及顶点着色器与片元着色器之间的通信，通过定义新的结构体可以解决该问题，修改后的代码如下：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 5/Simple Shader&quot;</span> &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用一个结构体定义顶点着色器的输出</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                <span class="comment">// SV_POSITION 语义告诉 Unity，pos 存储了顶点在裁剪空间中的位置信息</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                <span class="comment">// COLOR0 语义用于存储颜色信息，当需要存储更多颜色时，可继续用 COLOR1 、 COLOR2 等</span></span><br><span class="line">                fixed3 color : COLOR0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">                <span class="comment">// 声明输出结构</span></span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 将法线的值转变成颜色值，呈现到模型上</span></span><br><span class="line">                <span class="comment">// 因为 v.normal 的顶点法线方向，各分量范围是[-1, 1]，为了让其转变到颜色的范围[0, 1]，故做如下运算：</span></span><br><span class="line">                o.color = v.normal * <span class="number">0.5</span> + fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将顶点输出的结构体传入片元着色器中</span></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                <span class="comment">// 结构体里定义的 color 是 fixed3 类型</span></span><br><span class="line">                <span class="comment">// 输出的颜色为 fixed4 类型，所以需要补上第四个分量</span></span><br><span class="line">                <span class="comment">// 将插值后的 i.color 显示到屏幕上</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①此时保存代码后，回到 Unity 的 Scene 窗口，可以看到一个 RGB 色彩空间球体。<br>②顶点着色器的输出结构中，必须包含一个变量，它的语义是 SV_POSITION。否则渲染器无法获取裁剪空间中的顶点坐标，也就无法把顶点渲染到屏幕上。<br>③顶点着色器是逐顶点调用的，片元着色器是逐片元（像素）调用的，这意味着顶点着色器的调用次数远远小于片元着色器。为了让每个片元着色器都能有一个结构体的输入，Unity 会将非顶点像素的片元着色器的输入结构体的数据由顶点着色器的输出经过插值后得到结果。比如三角形面片中某个像素点 V：</p><script type="math/tex; mode=display">V=\alpha V_A + \beta V_B + \gamma V_C</script><center>$V_A, V_B, V_C$  can be positions, texture, coordinates, color, normal, depth, material attributes...</center><h3 id="如何使用属性"><a href="#如何使用属性" class="headerlink" title="如何使用属性"></a>如何使用属性</h3><p>若将参数写在 Properties 语义块中，就可以在材质面板中快速调节 Unity Shader 中的参数。一个 Shader 通常会被多个材质使用，不同的材质会对 Shader 进行不同的设置，而属性则是材质和 Shader 之间的通道，允许材质传入不同的值给 Shader，以实现不同的视觉效果。继续修改之前的代码：</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 5/Simple Shader&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        <span class="comment">// 声明一个 Color 类型的属性</span></span><br><span class="line">        _Color(<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// CG 代码中，若需要使用属性数值，需要声明变量，变量名与属性名一致，一般以下划线开头</span></span><br><span class="line">            fixed4 _Color;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span> &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span> &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span> &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.color = v.normal * <span class="number">0.5</span> + fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span><br><span class="line">                fixed3 color = i.color;</span><br><span class="line">                <span class="comment">// 使用 _Color 属性来影响法线转换成的颜色效果</span></span><br><span class="line">                color *= _Color.rgb;</span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①保存代码并回到 Unity，可以看到使用该 Shader 的材质，多了一个 Color Tint 属性，可以直接在上面更改。<br>②ShaderLab 中属性的类型和 Cg 中变量的类型之间的匹配关系如下表：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">ShaderLab 属性类型</th><th style="text-align:left">Cg 变量类型</th></tr></thead><tbody><tr><td style="text-align:left">Color, Vector</td><td style="text-align:left">float4, half4, fixed4</td></tr><tr><td style="text-align:left">Range, Float</td><td style="text-align:left">float, half, fixed</td></tr><tr><td style="text-align:left">2D</td><td style="text-align:left">sampler2D</td></tr><tr><td style="text-align:left">3D</td><td style="text-align:left">sampler3D</td></tr><tr><td style="text-align:left">Cube</td><td style="text-align:left">samplerCube</td></tr></tbody></table></div><p>③关于 uniform 关键字，例如：<code>uniform fixed4 _Color;</code>。uniform 关键词是 Cg 语言中修饰变量和参数的一种修饰词，仅用于提供一些该变量的初始值是如何指定和存储的相关信息，在 Unity Shader 中可以省略。</p><h2 id="Unity-提供的内置文件和变量"><a href="#Unity-提供的内置文件和变量" class="headerlink" title="Unity 提供的内置文件和变量"></a>Unity 提供的内置文件和变量</h2><p>为了方便开发者的编码过程，Unity 提供了很多内置文件，这些文件包括了很多提前定义的函数、变量和宏等。本节将给出这些文件和变量的概览。</p><h3 id="内置的包含文件"><a href="#内置的包含文件" class="headerlink" title="内置的包含文件"></a>内置的包含文件</h3><p><strong>包含文件 include file</strong>，是类似于 C++ 中头文件的一种文件。在 Unity 中，它们的文件后缀为 .cginc。使用 #include 指令引入，在 CGPROGRAM 和 ENDCG 之间编写，这样就可以使用 Unity 提供的一些有用的变量和帮助函数，例如：</p><pre><code>CGPROGRAM//...#include &quot;UnityCG.cginc&quot;//...ENDCG</code></pre><p>内置文件一般在 Unity 安装路径下的 /Data/CGIncludes 中可以找到。下表给出一些 CGIncludes 中主要的包含文件和主要用处：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">文件名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">UnityCG.cginc</td><td style="text-align:left">包含了最常用的帮助函数，宏和结构体等</td></tr><tr><td style="text-align:left">UnityShaderVariables.cginc</td><td style="text-align:left">在编译 Unity Shader 时会被自动包含进来，包含了许多内置全局变量，如 UNITY_MATRIX_MVP 等</td></tr><tr><td style="text-align:left">Lighting.cginc</td><td style="text-align:left">包含了各种内置光照模型，如果编写的是 Surface Shader，会被自动包含进来</td></tr><tr><td style="text-align:left">HLSLSupport.cginc</td><td style="text-align:left">在编译 Unity Shader 时会被自动包含进来，声明了许多用于跨平台编译的宏的定义</td></tr><tr><td style="text-align:left">UnityStandardBRDF.cginc <br> UnityStandardCore.cginc</td><td style="text-align:left">用于实现基于物理的渲染，后面章节会遇到</td></tr></tbody></table></div><h3 id="UnityCG-cginc"><a href="#UnityCG-cginc" class="headerlink" title="UnityCG.cginc"></a>UnityCG.cginc</h3><p>UnityCG.cginc 是经常被使用的内置文件，里面预先定义了一些结构体和函数，可以直接使用作为顶点着色器的输入和输出。下表给出了 UnityCG.cginc 中一些常用的结构体和包含的变量：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">描述</th><th style="text-align:left">包含的变量</th></tr></thead><tbody><tr><td style="text-align:left">appdata_base</td><td style="text-align:left">可用于顶点着色器的输入</td><td style="text-align:left">顶点位置、顶点法线、第一组纹理坐标</td></tr><tr><td style="text-align:left">appdata_tan</td><td style="text-align:left">可用于顶点着色器的输入</td><td style="text-align:left">顶点位置、顶点切线、顶点法线、第一组纹理坐标</td></tr><tr><td style="text-align:left">appdata_full</td><td style="text-align:left">可用于顶点着色器的输入</td><td style="text-align:left">顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标</td></tr><tr><td style="text-align:left">appdata_img</td><td style="text-align:left">可用于顶点着色器的输入</td><td style="text-align:left">顶点位置、第一组纹理坐标</td></tr><tr><td style="text-align:left">v2f_img</td><td style="text-align:left">可用于顶点着色器的输出</td><td style="text-align:left">裁剪空间中的位置、纹理坐标</td></tr></tbody></table></div><p>UnityCG.cginc 也预定义了一些帮助函数，使用频率较高的有：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">函数名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">float3 WorldSpaceViewDir(float4 v)</td><td style="text-align:left">输入一个模型空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向</td></tr><tr><td style="text-align:left">float3 ObjSpaceViewDir(float4 v)</td><td style="text-align:left">输入一个模型空间中的顶点位置，返回模型空间中从该点到摄像机的观察方向</td></tr><tr><td style="text-align:left">float3 WorldSpaceLightDir(float4 v)</td><td style="text-align:left">仅可用于前向渲染中，输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向，没有被归一化</td></tr><tr><td style="text-align:left">float3 ObjSpaceLightDir(float4 v)</td><td style="text-align:left">仅可用于前向渲染中，输入一个模型空间中的顶点位置，返回模型空间中从该点到光源的光照方向，没有被归一化</td></tr><tr><td style="text-align:left">float3 UnityObjectToWorldNormal(float3 norm)</td><td style="text-align:left">把法线方向从模型空间转换到世界空间中</td></tr><tr><td style="text-align:left">float3 UnityObjectToWorldDir(float3 dir)</td><td style="text-align:left">把方向矢量从模型空间变换到世界空间中</td></tr><tr><td style="text-align:left">float3 UnityWorldToObjectDir(float3 Dir)</td><td style="text-align:left">把方向矢量从世界空间变换到模型空间中</td></tr></tbody></table></div><p>建议在 UnityCG.cginc 中找到上述结构体的声明和函数的定义，并尝试去理解。</p><h2 id="Unity-提供的-CG-HLSL-语义"><a href="#Unity-提供的-CG-HLSL-语义" class="headerlink" title="Unity 提供的 CG/HLSL 语义"></a>Unity 提供的 CG/HLSL 语义</h2><h3 id="什么是语义"><a href="#什么是语义" class="headerlink" title="什么是语义"></a>什么是语义</h3><p>上面提到的 POSITION、SV_POSITION、COLOR0 这些都是 Cg/HLSL 提供的<strong>语义 semantics</strong>。可以在微软官网查看关于 DirectX 的文档中查看语义的详细说明。语义实际上是一个赋给 shader 输入和输出的字符串，该字符串表达了这个参数的含义，即这些语义可以让 shader 知道从哪里读取数据，并把数据输出到哪里。</p><p>DirectX 10 以后出现了一种新的语义类型，就是<strong>系统数值语义 system-value semantics</strong>。这些语义以 SV，即 system-value 系统数值开头，在渲染流水线中有特殊的含义。</p><p>例如，在上面的代码中 SV_POSITION 语义去修饰顶点着色器的输出变量 pos，那么就表示 pos 包含了可用于光栅化的变换后的顶点坐标(即齐次裁剪坐标系中的坐标)。用这些语义描述的变量是不可以随便赋值的，因为流水线需要使用它们来完成特定的目的，例如渲染引擎会把用 SV_POSITION 修饰的变量经过光栅化后显示在屏幕上。绝大多数平台上 SV_POSITION 和 POSITION 是等价的，一些 Shader 会使用 POSITION 而非 SV_POSITION 来修饰顶点着色器的输出。但是在某些平台上必须使用 SV_POSITION 来修饰顶点着色器的输出(例如索尼 PS4 )，为了让 Shader 有更好的跨平台性，对于一些有特殊含义的变量最好用 SV 开头进行修饰。</p><h3 id="Unity-支持的语义"><a href="#Unity-支持的语义" class="headerlink" title="Unity 支持的语义"></a>Unity 支持的语义</h3><p>①下表总结了从应用阶段传递模型数据给顶点着色器时 Unity 使用的常用语义。这些语义虽然没有使用 SV 开头，但 Unity 内部赋予了它们特殊的含义：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">语义</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">POSITION</td><td style="text-align:left">模型空间中的顶点位置，通常为 float4 类型</td></tr><tr><td style="text-align:left">NORMAL</td><td style="text-align:left">顶点法线，通常是 float3 类型</td></tr><tr><td style="text-align:left">TANGENT</td><td style="text-align:left">顶点切线，通常是 float4 类型</td></tr><tr><td style="text-align:left">TEXCOORDn</td><td style="text-align:left">该顶点的纹理坐标，TEXCOORD0 表示第一组纹理坐标，依次类推。通常是 float2 或 float4 类型</td></tr><tr><td style="text-align:left">COLOR</td><td style="text-align:left">顶点颜色，通常是 fixed4 或 float4 类型</td></tr></tbody></table></div><p>其中，TEXCOORDn 中 n 的数目是和 Shader Model 有关的，例如一般在 Shader Model 2（Unity 默认编译到的 Shader Model 版本）和 Shader Model 3 中，n = 8，而在 Shader Model 4 和 5 中，n = 16，一个模型的纹理坐标组数一般不超过2，往往只使用 TEXCOORD0 和 TEXCOORD1，在 Unity 内置结构体 appdata_full 中，最多使用 6 个纹理坐标。</p><p>②下表总结了从顶点着色器到片元着色器阶段 Unity 支持的语义：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">语义</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">SV_POSITION</td><td style="text-align:left">裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量。等同于DiectX9中的 POSITION，但最好使用 SV_POSITION</td></tr><tr><td style="text-align:left">COLOR0</td><td style="text-align:left">通常用于输出第一组顶点颜色，但不是必需的</td></tr><tr><td style="text-align:left">COLOR1</td><td style="text-align:left">通常用于输出第二组顶点颜色，但不是必需的</td></tr><tr><td style="text-align:left">TEXCOORD0~TEXCOORD7</td><td style="text-align:left">通常用于输出纹理坐标，但不是必需的</td></tr></tbody></table></div><p>除了 SV_POSITION 有特别含义外，其他语义没有明确要求，我们可以随意存储任意值到这些语义描述变量中，比如把一些自定义的数据从顶点着色器传递给片元着色器。</p><p>③下表给出了 Unity 中支持的片元着色器的输出语义</p><div class="table-container"><table><thead><tr><th style="text-align:left">语义</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">SV_Target</td><td style="text-align:left">输出值将存储到渲染目标 render target 中。等同于 DirectX 9 中的 COLOR 语义，但最好使用 SV_Target</td></tr></tbody></table></div><blockquote><p>一个语义可以使用的寄存器只能处理 4 个浮点数 float。因此，若想定义矩阵类型，比如 float3×4、float4×4 等变量就需要使用更多空间。一个方法就是把这些变量拆分为多个变量，比如拆分为 4 个 float4 类型的变量。  </p><p>为什么一个 float4x4 还要拆开来存储，主要是因为在 GPU 中，寄存器的数量是有限的。为了最大限度地利用寄存器的空间，Unity Shader 将 float4x4 拆成四个 float4 存储。这样可以确保矩阵的每一列都能被存储在一个寄存器中，从而提高了 Shader 的运行效率。需要注意的是，即使寄存器可以存储数组，但是在实际开发中，应该尽量避免在 Shader 中使用大量的数组。因为数组的使用会占用大量的寄存器，导致 Shader 的性能下降。如果必须使用数组，可以尝试使用常量缓冲区来传递数组数据，以减少寄存器的占用量。</p></blockquote><h2 id="Unity-内置的帧调试器"><a href="#Unity-内置的帧调试器" class="headerlink" title="Unity 内置的帧调试器"></a>Unity 内置的帧调试器</h2><p>Unity 内置的<strong>帧调试器 Frame Debugger</strong> 可方便快捷地为我们呈现模型的每一帧渲染情况，单击菜单 - Window - Analysis - FrameDebuger，可打开帧调试器窗口。</p><p>单击 Frame Debug 窗口的左上角的 Enable 按钮，可看到渲染情况。单击前进后退按钮，可以重放渲染事件。这里不做详细介绍，有需求需额外了解。</p><h2 id="渲染平台的差异"><a href="#渲染平台的差异" class="headerlink" title="渲染平台的差异"></a>渲染平台的差异</h2><p>Unity 具有跨平台的特性，大多数的平台差异 Unity 底层都帮我们处理了，但是依然有些差异需要我们自己处理。这里不做摘抄，详见书第115-117页，遇到问题再解决。</p><h2 id="规范-Shader-代码的建议"><a href="#规范-Shader-代码的建议" class="headerlink" title="规范 Shader 代码的建议"></a>规范 Shader 代码的建议</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>Cg/HLSL 中三种精度的数值类型：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">精度</th></tr></thead><tbody><tr><td style="text-align:left">float</td><td style="text-align:left">最高精度的浮点值。通常使用 32 位来存储</td></tr><tr><td style="text-align:left">half</td><td style="text-align:left">中等精度的浮点值。通常使用 16 位来存储，精度范围是 -60,000 ~ +60,000</td></tr><tr><td style="text-align:left">fixed</td><td style="text-align:left">最低精度的浮点值。通常使用 11 位来存储，精度范围是 -2.0 ~ +2.0</td></tr></tbody></table></div><p>不同的平台和 GPU 上，三者实际的精度可能和上面描述的不一致：<br>①大多数现代桌面 GPU 会把所有计算按最高的浮点精度计算，即：float、half、fixed 在这些平台上是等价的，都等同于 float；<br>②但在移动平台 GPU 上，它们的确有不同的精度范围，不同的精度浮点运算速度会有差异；<br>③fixed 精度在现代大多数GPU上，被当做和 half 同等精度对待。</p><p>但是在书写上，我们还是要保证尽可能使用精度较低的类型，以此来优化 Shader 的性能，尤其在移动平台上。fixed 用来存储颜色和单位矢量；half 存储更大范围的数据；最差情况下再选择使用 float。</p><h3 id="规范语法"><a href="#规范语法" class="headerlink" title="规范语法"></a>规范语法</h3><p>DirectX 平台对 Shader 的语义有更加严格的要求。按最严格的要求书写，防止偏门的写法导致某些平台无法运行。比如：</p><pre><code>// 规范的写法float4 v = float4(0.0, 0.0, 0.0, 0.0);// 不规范的写法float4 v = float4(0.0);</code></pre><h3 id="避免不必要的计算"><a href="#避免不必要的计算" class="headerlink" title="避免不必要的计算"></a>避免不必要的计算</h3><p>在 Shader 中进行过多的运算，可能会收到以下 Unity 的错误提示：<br>① temporary register limit of 8 exceeded<br>② Arithmetic instruction limit of 64 exceeded; 65 arithmetic instructions needed to complie program</p><p>这是因为需要的临时寄存器数目或指令数目超过了当前可支持的数目。不同的 Shader Target、不同的着色器阶段，我们可使用的寄存器数目和指令数目都是不同的。通常，可以通过指定更高等级的 Shader Target 来消除这些错误。下表给出了 Unity 目前支持的一些 Shader Target：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">#pragma target 2.0</td><td style="text-align:left">默认的 Shader Target 等级。相当于 Direct3D 9 上的 Shader Model 2.0，不支持对顶点纹理的采样，不支持显式的 LOD 纹理采样等</td></tr><tr><td style="text-align:left">#pragma target 3.0</td><td style="text-align:left">相当于 Direct3D 9 上的 Shader Model 3.0，支持对顶点纹理的采样等</td></tr><tr><td style="text-align:left">#pragma target 4.0</td><td style="text-align:left">相当于 Direct3D 10 上的 Shader Model 4.0，支持几何着色器等</td></tr><tr><td style="text-align:left">#pragma target 5.0</td><td style="text-align:left">相当于 Direct3D 11 上的 Shader Model 5.0</td></tr></tbody></table></div><p>Shader Model 是微软提出的一套规范，决定了 Shader 的各个特性的能力，比如能使用的运算指令数目、寄存器个数等等。</p><h3 id="慎用分支和循环语句"><a href="#慎用分支和循环语句" class="headerlink" title="慎用分支和循环语句"></a>慎用分支和循环语句</h3><p>对于分支和循环语句，GPU 的实现和 CPU 是不同的，GPU 处理这些语句会消耗更多的性能，降低 GPU 并行处理的速度。因此最好把计算往渲染管线的前面移动，比如把片元着色器计算放在顶点着色器中，或者直接在 CPU 进行预运算，再将结果传给 Shader。若无法避免使用分支语句，最好：<br>①分支判断语句中使用的条件变量最好是常量；<br>②每个分支中包含的操作指令数尽可能少；<br>③分支的嵌套层数尽可能少。</p><h1 id="第五章-Unity-中的基础光照"><a href="#第五章-Unity-中的基础光照" class="headerlink" title="第五章 Unity 中的基础光照"></a>第五章 Unity 中的基础光照</h1><p>从宏观上说，渲染包含了两大部分：决定一个像素的可见性，决定这个像素上的光照计算。而光照模型就是用于决定着一个像素上进行怎样的光照计算。</p><p>本章着重描述光照模型的原理，因此实现的 Shader 往往不能直接应用到实现项目中，会缺少阴影、光照衰减等效果。</p><h2 id="光的物理知识"><a href="#光的物理知识" class="headerlink" title="光的物理知识"></a>光的物理知识</h2><p>通过模拟真实的光照环境来生成一张图像，需要考虑三种物理现象：<br>①首先，光线从<strong>光源 light source</strong> 中被发射出来；<br>②然后，光线和场景中的一些物体相交：一些光线被物体吸收了，而另一些光线被散射到其他方向；<br>③最后，摄像机吸收了一些光，产生了一张图像。</p><h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><p>实时渲染中，光源通常被当成一个没有体积的点，用 $l$ 来表示它的方向。在光学中，用<strong>辐照度 irradiance</strong> 来量化光。</p><p>①对于平行光来说，辐照度可通过计算垂直于 $l$ 的单位面积上单位时间内穿过的能量得到。<br>②对于不垂直于物体表面的光，辐照度可使用光源方向 $l$ 和表面法线 $n$ 之间的余弦值得到。<br>如下图：  </p><div  align="center">  <img src="https://s2.loli.net/2023/11/03/zOSb96wcEgG4FB5.jpg" width = "70%" height = "70%" alt="图13- 在左图中，光是垂直照射到物体表面，因此光线之间的垂直距离保持不变；而在右图中，光是斜着照射到物体表面，在物体表面光线之间的距离是d/cosθ，因此单位面积上接收到的光线数目要少于左图"/></div><p>因为辐照度是和照射在物体表面时光线之间的距离 d/cosθ 成反比，因此辐照度和 cosθ 成正比。cosθ 可用光源方向 $l$ 和表面法线 $n$ 的点积得到，这就是使用点积来计算辐照度的由来。</p><h3 id="吸收和散射"><a href="#吸收和散射" class="headerlink" title="吸收和散射"></a>吸收和散射</h3><p>光线由光源发射出来后，就会与一些物体相交。通常，相交的结果只有两个，即<strong>散射 scattering</strong> 和<strong>吸收 absorption</strong>。  </p><p>①散射：只改变光线的方向，不改变光线的密度和颜色。光线在物体表面经过散射后，有两种方向：<br>&emsp;&emsp; - 散射到物体内部：被称为<strong>折射 refraction</strong> 或<strong>透射 transmission</strong>；<br>&emsp;&emsp; - 散射到物体外部：被称为<strong>反射 reflection</strong>。<br>对于不透明物体，折射进入物体内部的光线会继续和内部的颗粒进行相交，其中一部分光线重新发射出物体表面，另一部分则被物体吸收。那些从物体表面重新发射出的光线具有和入射光线不同的方向分布和颜色。<br>②吸收：只改变光线的密度和颜色，不改变光线的方向。</p><p>为了区分上述两种不同的 <em>散射</em> 方向，在光照模型中用了不同的部分来计算它们：<br>①<strong>高光反射 specular</strong> 部分表示物体表面是如何反射光线的。<br>②<strong>漫反射 diffuse</strong> 部分表示有多少光线会被折射、吸收和散射出表面。</p><p>根据入射光线的数量和方向，可以计算出出射光线的数量和方向，通常用<strong>出射度 exitance</strong> 来描述它。辐照度和出射度之间满足线性关系，它们之间的比值就是材质的漫反射和高光反射属性。</p><p>在本章中，假设漫反射部分是没有方向性的，即光线在所有方向上平均分布的，同时也只考虑在某一特定方向上的高光反射。</p><h3 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h3><p><strong>着色 shading</strong> 指根据材质属性（如漫反射属性等）、光源信息（如光源方向、辐照度等），使用一个公式去计算沿某个观察方向的出射度的过程。这个公式称为<strong>光照模型 lighting model</strong>。不同光照模型有不同的目的，有些描述粗糙物体表面，有些描述金属表面等。</p><h3 id="BRDF-光照模型"><a href="#BRDF-光照模型" class="headerlink" title="BRDF 光照模型"></a>BRDF 光照模型</h3><p>BRDF，即<strong>双向反射分布函数 Bidirectional Reflectance Distribution Function</strong>，即给定入射光线的方向和辐照度，可以用它得到某个出射方向上的光照能量分布。</p><p>本文涉及的 BRDF 是对真实场景进行理想化或简化后的模型。也就是说，他们不能真实地反映问题和光线之间的交互，这些模型被称为经验模型。在实时渲染中，考虑到性能消耗，一般还是会使用经验模型。虽然他们不能很真实地反映光照情况，但是它们“看起来是对的”。如果希望更真实地模拟光和物体的交互，一般会使用基于物理的 BRDF 模型（后面章节会学到）。</p><h2 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h2><p>在 BRDF 理论被提出来之前，标准光照模型已经被广泛使用了。</p><p><strong>标准光照模型</strong>，也称为 <strong>Phong 光照模型</strong>，由著名 CG 学者裴祥风 Bui Tuong Phong 于 1973 年提出。标准光照模型只关心直接光照，即直接从光源发射出来照射到物体表面后，经过物体表面地一次反射直接进入摄像机的光线。</p><p>其基本方法就是把进入到摄像机内的光线分为 4 个部分，每个部分使用一种方法计算它的贡献度：<br>①<strong>自发光 emissive</strong> 部分，使用 $c_{emissive}$ 表示。描述给定一个方向时，一个表面本身会向该方向发射多少辐射量。注意：如果没有全局光照技术，自发光的表面并不会照亮周围物体，只是本身看起来更亮了。<br>②<strong>高光反射 specular</strong> 部分，使用 $c_{specular}$ 表示。描述当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量。<br>③<strong>漫反射 diffuse</strong> 部分，使用 $c_{diffuse}$ 表示。描述当光线从光源照射到模型表面时该表面会向每个方向散射多少能量。<br>④<strong>环境光 ambient</strong> 部分，使用 $c_{ambient}$ 表示。用于描述其他所有间接光照。  </p><h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><p>利用环境光来模拟所有的间接光照，场景中的所有物体都使用这个环境光，通常是一个全局变量：</p><script type="math/tex; mode=display">c_{ambient} = g_{ambient}</script><blockquote><p>间接光照指，光线经过多个物体反射后，即不止一次的物体反射，最后进入摄像机。比如红地毯导致沙发底部泛红色。</p></blockquote><h3 id="自发光"><a href="#自发光" class="headerlink" title="自发光"></a>自发光</h3><p>光线直接由由光源发射进入摄像机，不需要经过任何物体反射，所以直接使用该材质的自发光颜色来计算：  </p><script type="math/tex; mode=display">c_{emissive} = g_{emissive}</script><p>通常在实时渲染中，自发光的表面往往不会照亮周围的表面，即这个物体不会被当成一个光源。Unity 中引入的全局光照系统可以模拟这类自发光物体对周围物体的影响。</p><h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><p>漫反射光照是用于对那些被物体表面随机散射到各个方向的辐射度进行建模的。在漫反射中，视角的位置不重要，因为反射完全随机，即可以认为在任何反射方向上的分布是均匀的。但是入射光线的角度很重要。  </p><p>漫反射光照符合<strong>兰伯特定律 Lambert’s law</strong>：反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比。</p><script type="math/tex; mode=display">c_{diffuse} = (c_{light} \cdot m_{diffuse}) max(0, \hat n \cdot \hat l)</script><p>其中，$\hat n\,$ 是表面法线，$\hat l\,\,$ 是指向光源的单位矢量，$m_{diffuse}\,$ 是材质的漫反射颜色，$c_{light}\,$ 是光源颜色。取最大值是为了防止点乘结果为负值，可以防止物体被后面来的光照亮。</p><h3 id="高光反射"><a href="#高光反射" class="headerlink" title="高光反射"></a>高光反射</h3><p>这里的高光反射是一种经验模型，即并不完全符合真实世界中的高光反射现象。它可用于计算那些沿着完全镜面反射方向被反射的光线。</p><p>计算高光反射需要信息较多，如表面法线 n、视角方向 v、光源方向 l、反射方向 r 等。假设这些矢量都是单位矢量，反射方向可以通过法线方向和光源方向计算得到：  </p><script type="math/tex; mode=display">\hat {r} = 2(\hat {n} \cdot \hat {l})\hat {n} - \hat {l}</script><p>利用 Phong 模型来计算高光反射的部分：  </p><script type="math/tex; mode=display">c_{specular} = (c_{light} \cdot m_{specular}) max(0, \hat {v} \cdot \hat {r})^{m_{gloss}}</script><p>① $m_{gloss}\,$ 是材质的<strong>光泽度 gloss</strong>，也称为<strong>反光度 shininess</strong>，用于控制高光区域的亮点有多宽，$m_{gloss}\,$ 越大，亮点就越小。<br>② $m_{specular}\,$ 是材质的高光反射颜色，用于控制该材质对于高光反射的强度和颜色。<br>③ $c_{light}\,$ 是光源的颜色和强度。</p><div  align="center">  <img src="https://s2.loli.net/2023/11/06/tQmMHVJ4WfZSw3j.jpg" width = "50%" height = "50%" alt="图14- 使用 Phong 模型计算高光反射"/></div><p>在 Phong 模型基础上，Blinn 简化了计算来得到类似的效果。为了避免计算反射方向 $\,\hat r\,$，Blinn 模型引入了一个新的矢量 $\,\hat h\,$ （<strong>半角向量 halfway vector</strong>），它是通过对 $\,\hat v\,$ 和 $\,\hat l\,\,$ 的取平均后再归一化得到的，即：  </p><script type="math/tex; mode=display">\hat {h} = \cfrac {\hat {v} + \hat {l}} {|\hat {v} + \hat {l}|}</script><p>然后使用 $\,\hat n\,$ 和 $\,\hat h\,$ 之间的夹角进行计算，而非 $\,\hat v\,$ 和 $\,\hat r\,$ 之间的夹角：  </p><script type="math/tex; mode=display">c_{specular} = (c_{light} \cdot m_{specular}) max(0, \hat {n} \cdot \hat {h})^{m_{gloss}}</script><div  align="center">  <img src="https://s2.loli.net/2023/11/06/8Ky4CHnVqdlcUXP.jpg" width = "50%" height = "50%" alt="图15- 使用 Blinn 模型计算高光反射"/></div><p>在硬件实现时，如果摄像机和光源距离模型足够远，Blinn 模型会快于 Phong 模型，因为此时可以认为 v 和 l 都是定值，因此 h 是一个常量。但是当 v 和 l 不是定值时，Phong 模型反而可能更快。注意，这两种光照模型都是经验模型，不能认为 Blinn 模型是对“正确的” Phong 模型的近似。在一些情况下 Blinn 模型更符合实验结果。</p><h3 id="逐像素还是逐顶点"><a href="#逐像素还是逐顶点" class="headerlink" title="逐像素还是逐顶点"></a>逐像素还是逐顶点</h3><p>①<strong>逐像素光照 per-pixel lighting</strong>：在片元着色器中计算，以每个像素为基础，得到它的法线（可以是对顶点法线插值得到的，也可以是从法线纹理中采样得到的），然后进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术称为 <strong>Phong 着色</strong>，不同于与前面的 Phong 光照模型，也称 Phong 插值、法线插值着色技术。</p><p>②<strong>逐顶点光照 per-vertex lighting</strong>：也被称为<strong>高洛德着色 Gouraud shading</strong>。在顶点着色器中计算，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。</p><p>由于顶点数往往小于像素数目，因此逐顶点光照的计算量往往小于逐像素光照。但是逐顶点光照依赖于线性插值来得到像素光照，因此，当光照模型中有非线性计算（比如：高光反射计算）时，逐顶点光照的效果会出现问题。而且由于逐顶点光照会在渲染图元内部对顶点颜色进行插值，这会导致渲染图元内部的颜色总是暗于顶点处的最高颜色值，某些情况下会产生明显的棱角现象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然 Blinn-Phong 模型并不完全符合真实世界中的光照现象，但由于易用性和计算速度快的特点，使它仍被广泛使用。</p><p>但该模型也有很多的局限性，例如<strong>菲涅尔反射 Fresnel reflection</strong> 等物理现象就无法用 Blinn-Phong 模型表现出来，其次，Blinn-Phong 模型是<strong>各向同性 isotropic</strong> 的，即当我们固定视角和光源方向旋转这个表面时，反射不会发生任何改变。但是某些物体表面是<strong>各向异性 anisotropic</strong> 的，比如拉丝金属、毛发等。</p><h2 id="Unity-中的环境光和自发光"><a href="#Unity-中的环境光和自发光" class="headerlink" title="Unity 中的环境光和自发光"></a>Unity 中的环境光和自发光</h2><p>在 Unity 中，场景中的环境光可以在 Window -&gt; Rendering -&gt; Lighting -&gt; Environment -&gt; Environment Lighting 中控制。在 Shader 中，我们可以调用 Unity 的内置变量 UNITY_LIGHTMODEL_AMBIENT 就可以得到环境光的颜色和强度信息。  </p><p>由于大多数物体没有自发光特性，因此在本书中绝大部分 Shader 都没有计算自发光 Shader。若需要，只需要在片元着色器输出最后的颜色之前，把材质的自发光颜色添加到输出颜色上即可。</p><h2 id="在-Unity-Shader-中实现漫反射光照模型"><a href="#在-Unity-Shader-中实现漫反射光照模型" class="headerlink" title="在 Unity Shader 中实现漫反射光照模型"></a>在 Unity Shader 中实现漫反射光照模型</h2><p>上面给出了基本光照模型中漫反射部分的计算公式，公式中 max 函数是为了防止点积结果为负值，Cg 语言中有另一个函数可以达到同样的目的，即 saturate 函数：</p><pre><code>// 参数 x：可以是标量或矢量，float、float2、float3 等类型// 如果是标量，将 x 截取在 [0, 1] 范围内；// 如果是矢量，会对矢量的每一个分量进行 [0, 1] 范围的限制；saturate(x)</code></pre><h3 id="逐顶点光照实践"><a href="#逐顶点光照实践" class="headerlink" title="逐顶点光照实践"></a>逐顶点光照实践</h3><p><strong><em>1. 准备工作</em></strong><br>①新建名为 Scene_6_4 的场景，去掉天空盒子；<br>②新建名为 DiffuseVertexLevelMat 的材质；<br>③新建名为 Chapter6-DiffuseVertexLevel 的 Unity Shader，并赋给上一步创建的材质；<br>④在场景中创建一个胶囊体，并将之前创建的材质赋给它；<br>⑤保存场景；</p><p><strong><em>2. 编写 Shader</em></strong><br>打开 Chapter6-DiffuseVertexLevel，删除里面的所有代码，从第一行开始跟着下面的代码一行一行往下写，注释中已详细地对关键代码作了说明：</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给Shader命名</span></span><br><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 6/Diffuse Vertex-Level&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 漫反射颜色的属性，默认设为白色</span></span><br><span class="line">        _Diffuse(<span class="string">&quot;Diffuse&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// LightMode 标签用于定义该 Pass 在 Unity 的光照流水线中的角色</span></span><br><span class="line">            <span class="comment">// 后续会详细地了解，这里有个概念即可</span></span><br><span class="line">            <span class="comment">// 只有定义了正确的 LightMode，才能得到一些 Unity 的内置光照变量，比如下面的 _LightColor0</span></span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为了使用 Unity 内置的一些变量，比如：_LightColor0</span></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 需要定义和 Properties 语义块中声明的属性相匹配的变量，用于获取漫反射参数，别忘了</span></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION; <span class="comment">// 模型空间中的顶点位置 </span></span><br><span class="line">                float3 normal : NORMAL; <span class="comment">// 模型顶点的法线信息</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION; <span class="comment">// 裁剪空间中的顶点坐标</span></span><br><span class="line">                fixed3 color : COLOR; <span class="comment">// 将顶点信息计算的光照颜色传递给片元着色器，这里不是必须使用 COLOR 语义，也可以使用 TEXCOORD0 语义</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">// 将顶点坐标由模型空间转到裁剪空间</span></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过 Unity 内置变量得到环境光的颜色值</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 见下面注</span></span><br><span class="line">                fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过内置变量 _WorldSpaceLightPos0 获取世界空间下的光源方向，并进行归一化</span></span><br><span class="line">                <span class="comment">// 因为本案例中光源只有一个并且是平行光，所以可以直接取该变量进行归一化，若还有其他类型光源，则该内置变量不能得到正确的结果</span></span><br><span class="line">                fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下面使用漫反射公式得到漫反射的颜色值</span></span><br><span class="line">                <span class="comment">// 通过内置变量 _LightColor0，来访问该 Pass 处理的光源的颜色和强度信息</span></span><br><span class="line">                <span class="comment">// 利用 _Diffuse.rgb 获取材质漫反射颜色</span></span><br><span class="line">                <span class="comment">// saturate，把取值范围截取到 [0, 1] 的范围内</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 最后对环境光和漫反射光部分相加，得到最终的光照结果</span></span><br><span class="line">                o.color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将顶点输出的颜色值作为片元着色器的颜色输出，输出到屏幕上</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用内置的 Diffuse 作为该 Unity Shader 的回调 shader</span></span><br><span class="line">    Fallback <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：为了计算法线和光源方向的点积（即它们之间夹角的余弦值，因为是单位向量），需要把两者放置在同一坐标空间下，计算才有效，这里选择的是世界坐标空间。而 a2v 得到的顶点法线是在模型空间下，所以需要把法线转换到世界空间下。至于为什么法线的坐标空间转换需要用逆矩阵反向相乘，详见 Shader 数学基础的法线变换。法线变换矩阵为顶点变换矩阵的逆转置矩阵，所以使用模型空间到世界空间的逆矩阵 _World2Object，然后调换 mul 函数中的位置得到转置矩阵。由于法线是方向，所以只需要截取 _World2Object 的三行三列即可。（ _World2Object 因为版本问题更新为了 unity_WorldToObject）</p><p>对于细分程度较高的模型，逐顶点光照已经可以得到较好的光照效果了。但是对于细分程度较低的模型，逐顶点光照会出现一些视觉问题，比如上述代码的胶囊体的背光面和向光面交界处会有一些锯齿，图见后面。</p><h3 id="逐像素光照实践"><a href="#逐像素光照实践" class="headerlink" title="逐像素光照实践"></a>逐像素光照实践</h3><p><strong><em>1. 准备工作</em></strong><br>①新建名为 DiffusePixelLevelMat 的材质；<br>②新建名为 Chapter6-DiffusePixelLevel 的 Unity Shader，并赋给上一步创建的材质；<br>③在原来的场景中创建一个新的胶囊体，将刚刚创建的材质赋给它；<br>④保存场景；</p><p><strong><em>2. 编写 Shader</em></strong><br>打开 Chapter6-DiffusePixelLevel，删除里面的所有代码，并复制粘贴上一节编写的 Shader 代码，做部分修改。下面是逐像素光照的 Shader 代码，修改部分已用注释说明：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改着色器的名字</span></span><br><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 6/Diffuse Pixel-Level&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Diffuse(<span class="string">&quot;Diffuse&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD0; <span class="comment">// 顶点着色器输出的世界空间下的法线，用于在片元着色器中编写光照计算逻辑</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">// 顶点着色器只需要计算世界空间下的法线矢量，并传递给片元着色器即可</span></span><br><span class="line">                o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器计算漫反射光照模型：</span></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取环境光颜色</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将世界空间下的法线矢量进行归一化</span></span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                <span class="comment">// 通过内置变量 _WorldSpaceLightPos0 获取世界空间下的光照方向，并进行归一化</span></span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据漫反射公式计算漫反射颜色值</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将环境光和漫反射光相加，输出到屏幕</span></span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fallback <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逐像素光照可以的得到更加平滑的效果，图见后面。光照无法到达的区域模型外观通常是全黑的，使模型背光的区域看起来和一个平面一样，失去了模型的细节表现，如果从完全背对光的一面看模型，模型几乎看不到立体的效果。对于此问题，使用<strong>半兰伯特 Half Lambert</strong> 光照模型改善。</p><h3 id="半兰伯特模型"><a href="#半兰伯特模型" class="headerlink" title="半兰伯特模型"></a>半兰伯特模型</h3><p>之前使用的漫反射光照模型也被称为兰伯特光照模型，符合兰伯特定律，即在平面某点漫反射光的光强和该反射点的法线和入射角度的余弦值成正比。</p><p>为了改善上一小节提到的问题，Valve 公司在开发半条命时提出了<strong>半兰伯特光照模型</strong>，对原模型进行了简单的修改。广义的半兰伯特光照模型的公式如下：  </p><script type="math/tex; mode=display">c_{diffuse} = (c_{light} \cdot m_{diffuse}) (α(\hat n \cdot \hat l) + β)</script><p>半兰伯特光照模型没有使用 max 操作防止点乘出现负值，而是对其结果进行了 α 倍的缩放再加上 β 的偏移，绝大多数情况下 α 和 β 的值均为 0.5 。即公式为：  </p><script type="math/tex; mode=display">c_{diffuse} = (c_{light} \cdot m_{diffuse}) (0.5(\hat n \cdot \hat l) + 0.5)</script><p>这样可以将两个矢量点积的结果范围由 [-1, 1] 映射到 [0, 1]，也就实现了：即使观察点在背光面，原模型的点积都是 0，而新模型中，背面也将会有明暗变化。</p><p><strong><em>1. 准备工作</em></strong><br>①新建名为 HalfLambertMat 的材质；<br>②新建名为 Chapter6-HalfLambert 的 Unity Shader，并赋给上一步创建的材质；<br>③在原来场景中创建一个新的胶囊体，并将第一步创建的材质赋给它；<br>④保存场景；</p><p><strong><em>2. 编写 Shader</em></strong><br>打开 Chapter6-HalfLambert，删除里面的所有代码，并复制粘贴 Chapter6-DiffusePixelLevel 的代码，并使用半兰伯特公式修改片元着色器中计算漫反射光照的部分（别忘了修改着色器名字）：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算漫反射的半兰伯特值</span></span><br><span class="line">    fixed halfLambert = dot(worldNormal, worldLightDir) * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 将公式修改为半兰伯特模型的公式</span></span><br><span class="line">    fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * halfLambert;</span><br><span class="line"></span><br><span class="line">    fixed3 color = ambient + diffuse;</span><br><span class="line">    <span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是上面三种光照的对比效果，从左到右分别是逐顶点漫反射光照、逐像素漫反射光照、半兰伯特光照，可以看到逐顶点会有一些锯齿，半兰伯特光照太白是因为 0.5 的偏移值太大了：  </p><div  align="center">  <img src="https://s2.loli.net/2023/11/07/9OnPoypKNL8Yi7g.png" width = "70%" height = "70%" alt="图16- 逐顶点漫反射光照、逐像素漫反射光照、半兰伯特光照的对比效果"/></div><h2 id="在-Unity-Shader-中实现高光反射光照模型"><a href="#在-Unity-Shader-中实现高光反射光照模型" class="headerlink" title="在 Unity Shader 中实现高光反射光照模型"></a>在 Unity Shader 中实现高光反射光照模型</h2><p>之前给出了基本光照模型中高光反射部分的计算公式：  </p><script type="math/tex; mode=display">c_{specular} = (c_{light} \cdot m_{specular}) max(0, \hat {v} \cdot \hat {r})^{m_{gloss}}</script><p>计算高光反射需要知道 4 个参数：入射光线的颜色和强度 $c_{light}$，材质的高光反射系数 $m_{specular}$，视角方向 $\,\hat v\,$ 以及反射方向 $\,\hat r\,$。其中，反射方向 $\,\hat r\,$ 由表面法线 $\,\hat n\,$ 和光源方向 $\,\hat l\,$ 计算而得：  </p><script type="math/tex; mode=display">\hat {r} = \hat {l} - 2(\hat {n} \cdot \hat {l})\hat {n}</script><blockquote><p>这里的公式和之前是反过来的，原因是光源方向和之前相反（点乘结果为负数），见下图。</p></blockquote><p>Cg 提供了计算反射方向的函数 <code>reflect(i , n)</code>，其中 i 为<strong>入射方向</strong>（与之前指向光源的方向相反），n 是法线方向，可以是 float，float2，float3 等类型。</p><div  align="center">  <img src="https://s2.loli.net/2023/11/08/D4gSraRV1XhTG2K.jpg" width = "50%" height = "50%" alt="图17- Cg 的 reflect 函数"/></div><h3 id="逐顶点光照实践-1"><a href="#逐顶点光照实践-1" class="headerlink" title="逐顶点光照实践"></a>逐顶点光照实践</h3><p><strong><em>1. 准备工作</em></strong><br>①新建名为 Scene_6_5 的场景，并去掉天空盒子；<br>②新建名为 SpecularVertexLevelMat 的材质；<br>③新建名为 Chapter6-SpecularVertexLevel 的 Unity Shader，并赋给刚刚创建的材质；<br>④在场景中创建一个胶囊体，并将刚刚创建的材质赋给赋给它；<br>⑤保存场景；</p><p><strong><em>2. 编写 Shader</em></strong><br>打开 Chapter6-SpecularVertexLevel，删除里面的所有代码，编写如下代码：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 6/Specular Vertex-Level&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Diffuse (<span class="string">&quot;Diffuse&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 控制漫反射颜色</span></span><br><span class="line">        _Specular (<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 控制高光反射颜色</span></span><br><span class="line">        _Gloss (<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span> <span class="comment">// 控制高光区域大小，值越小，区域越大，因为点乘结果小于 1，指数越大，结果越小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 为了正确地得到一些 Unity 的内置光照变量，如_LightColor0</span></span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 Properties 语义中声明的属性</span></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss; <span class="comment">// 光泽度数值范围较大，使用 float 精度</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算出漫反射光</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 计算反射方向</span></span><br><span class="line">                <span class="comment">// 使用 reflect 函数求出入射光线关于表面法线的反射方向，并进行归一化</span></span><br><span class="line">                <span class="comment">// 因为 reflect 函数的入射方向要求由光源指向交点处（worldLightDir 是交点处指向光源），所以需要取反</span></span><br><span class="line">                fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算视角方向</span></span><br><span class="line">                <span class="comment">// 通过 Unity 内置变量 _WorldSpaceCameraPos 得到世界空间中的相机位置</span></span><br><span class="line">                <span class="comment">// 通过与世界空间中的顶点坐标进行相减，得到世界空间下的视角方向</span></span><br><span class="line">                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, v.vertex).xyz);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算出高光反射光</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(dot(reflectDir, viewDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 环境光 + 漫反射 + 高光反射</span></span><br><span class="line">                o.color = ambient + diffuse + specular;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Specular&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用逐顶点的方法得到的高光效果会有较大问题，因为高光反射的计算是非线性的，而顶点着色器中计算光照再进行插值的过程是线性的，破坏了原计算的非线性关系，就会有较大的视觉问题。效果图见后面。</p><h3 id="逐像素光照实践-1"><a href="#逐像素光照实践-1" class="headerlink" title="逐像素光照实践"></a>逐像素光照实践</h3><p><strong><em>1. 准备工作</em></strong><br>①新建名为 SpecularPixelLevelMat 的材质；<br>②新建名为 Chapter6-SpecularPixelLevel 的 Unity Shader，并赋给上一步的材质；<br>③在原来的场景新建一个胶囊体，并将刚刚创建的材质赋给它；<br>④保存场景；</p><p><strong><em>2. 编写 Shader</em></strong><br>打开 Chapter6-SpecularPixelLevel，删除里面所有代码，并复制粘贴上一节编写 Chapter6-SpecularVertexLevel 代码，做部分修改，修改后的代码如下，修改部分已用注释说明：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 6/Specular Pixel-Level&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Diffuse(<span class="string">&quot;Diffuse&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Specular(<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss(<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0; <span class="comment">//顶点着色器输出的世界空间下的法线</span></span><br><span class="line">                float3 worldPos : TEXCOORD1; <span class="comment">//顶点着色器输出的世界空间下的坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将法线由模型空间转到世界空间</span></span><br><span class="line">                o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">                <span class="comment">// 将顶点坐标由模型空间转到世界空间</span></span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取环境光</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对法线进行归一化</span></span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                <span class="comment">// 对光照方向进行归一化</span></span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算漫反射</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算反射方向并进行归一化</span></span><br><span class="line">                fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));</span><br><span class="line">                <span class="comment">// 计算视角方向并进行归一化</span></span><br><span class="line">                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">                <span class="comment">// 计算高光反射</span></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(dot(reflectDir, viewDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Specular&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逐像素处理光照可以得到更加平滑的高光效果，效果见后面图。至此，实现了一个完整的 Phong 光照模型。</p><h3 id="Blinn-Phong-光照模型"><a href="#Blinn-Phong-光照模型" class="headerlink" title="Blinn-Phong 光照模型"></a>Blinn-Phong 光照模型</h3><p>之前提过 Blinn 光照模型，不使用反射方向，而是引入了一个新的矢量 $\,\hat h\,$ ，它是通过对 $\,\hat v\,$ 和 $\,\hat l\,\,$ 的取平均后再归一化得到的，即：  </p><script type="math/tex; mode=display">\hat {h} = \cfrac {\hat {v} + \hat {l}} {|\hat {v} + \hat {l}|}</script><p>而 Blinn 光照模型计算高光反射的公式如下：  </p><script type="math/tex; mode=display">c_{specular} = (c_{light} \cdot m_{specular}) max(0, \hat {n} \cdot \hat {h})^{m_{gloss}}</script><p><strong><em>1. 准备工作</em></strong><br>①新建名为 BlinnPhongMat 的材质；<br>②新建名为 Chapter6-BlinnPhong 的 Unity Shader，并赋给上一步创建的材质；<br>③在原来的场景中新建一个胶囊体，并将第一步创建的材质赋给它；<br>④保存场景；</p><p><strong><em>2. 编写 Shader</em></strong><br>打开 Chapter6-BlinnPhong，删除里面的所有代码，将上一节 Chapter6-SpecularPixelLevel 代码复制粘贴进去，做部分修改：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">    <span class="comment">// 通过归一化入射方向 + 视角方向，得到半角向量 h</span></span><br><span class="line">    fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">    <span class="comment">// 根据 Blinn 光照模型公式计算高光反射部分</span></span><br><span class="line">    fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(dot(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Blinn-Phong 的高光反射部分看起来更大更亮，实际渲染中绝大多数情况会选择 Blinn-Phong 光照模型。注意，上述模型都是经验模型。</p><p>下图是上面三种光照的对比效果（为了更清晰看到高光效果，把漫反射颜色改为了灰色），从左到右分别是逐顶点高光反射光照、逐像素高光反射光照、Blinn-Phong 光照：</p><div  align="center">  <img src="https://s2.loli.net/2023/11/13/YSbDIz87glZePkV.png" width = "70%" height = "70%" alt="图18- 逐顶点的高光反射光照、逐像素的高光反射光照（Phong 光照模型）和 Blinn-Phong 高光反射光照的对比结果"/></div><h2 id="使用-Unity-内置的函数"><a href="#使用-Unity-内置的函数" class="headerlink" title="使用 Unity 内置的函数"></a>使用 Unity 内置的函数</h2><p>在之前的案例中，我们手动计算了光源方向和视角方向信息。光源方向是基于平行光的实现，如果遇到更复杂的光照类型（比如：点光源、聚光灯），使用上面的代码会得到错误的结果。这需要我们在代码中先判断光源类型，在计算其他光源信息，在后面会讲到。</p><p>手动计算光源信息的过程比较麻烦，Unity 则提供了一些内置函数来帮助我们计算这些信息。详见第五章的 UnityCG.cginc 的内容。表格中的 9 个函数中，有 5 个我们已经掌握了其内部实现，甚至在案例中已经写过，例如 WorldSpaceViewDir 函数实现如下：  </p><pre><code>inline float3 UnityWorldSpaceViewDir(float3 worldPos)&#123;    return _WorldSpaceCameraPos.xyz - worldPos;&#125;</code></pre><p>可以看出，这和之前计算视角方向的方法一致，<strong>但要注意的是，使用前要先归一化</strong>。  </p><p>与计算光源方向相关的 3 个函数：WorldSpaceLightDir、UnityWorldSpaceLightDir 和 ObjSpaceLightDir，它们的内部逻辑会稍微复杂一些，因为 Unity 要针对不同种类的光源做不同的逻辑。需要注意的是，这 3 个函数仅可用于前向渲染（也就是之前 Pass 中 Tags 写的 “LightMode” = “ForwardBase”，后续会详细了解），因为函数内使用的一些内置变量，如 _WorldSpaceLightPos0 等，只有在前向渲染中才会被正确赋值。</p><p>接下来基于前面写的 Blinn-Phong 案例代码，使用内置函数进行调整：<br>①在顶点着色器中，使用内置的 UnityObjectToWorldNormal 来计算世界空间下的法线方向：<code>o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</code> 改为 <code>o.worldNormal = UnityObjectToWorldNormal(v.normal);</code><br>②在片元着色器中，使用内置的 UnityWorldSpaceLightDir 计算世界坐标下光照方向，使用内置的 UnityWorldSpaceViewDir 计算世界坐标下的视角方向：<code>fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</code> 改为 <code>fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</code>，<br>以及 <code>fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</code> 改为 <code>fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</code></p><h1 id="第六章-基础纹理"><a href="#第六章-基础纹理" class="headerlink" title="第六章 基础纹理"></a>第六章 基础纹理</h1><p>纹理，即使用<strong>纹理映射 texture mapping</strong> 技术来使用图片控制模型的外观，逐<strong>纹素 texel</strong> (用于和像素区分)地控制模型颜色。美术建模时，通常会在建模软件中利用纹理展开技术把纹理映射坐标存储在每个顶点上。<strong>纹理映射坐标</strong>定义了该顶点在纹理中对应的 2D 坐标。通常使用二维变量 (u, v) 来表示，u 是横向坐标，v 是纵向坐标，因此纹理映射坐标也被称为 <strong>UV 坐标</strong>。</p><p>尽管纹理大小各不相同，但是顶点 UV 坐标的范围通常都被归一化为 [0, 1] 范围内。但，纹理采样使用的纹理坐标不一定在 [0, 1] 范围内。实际上，不在 [0, 1] 范围内的纹理坐标有时很有用，与之关系紧密的是纹理的平铺模式，详见后面章节。</p><p>OpenGL 的纹理空间的原点位于左下角；DirectX 的纹理空间的原点位于左上角；Unity 在绝大多数情况下会帮我们处理好差异。但 Unity 本身使用的是符合 OpenGL 传统的，即原点位于左下角。</p><h2 id="单张纹理"><a href="#单张纹理" class="headerlink" title="单张纹理"></a>单张纹理</h2><p>本节学习使用一张纹理代替物体的漫反射颜色。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>本例中仍然使用 Blinn-Phong 光照模型来计算光照。</p><p><strong><em>1. 准备工作</em></strong><br>①新建名为 Scene_7_1 的场景，并去掉天空盒子；<br>②新建名为 SingleTextureMat 的材质；<br>③新建名为 Chapter7-SingleTexture 的 Shader，并赋给上一步创建的材质；<br>④在场景中新建一个胶囊体，并把第二步的材质赋给它；<br>⑤保存场景；</p><p><strong><em>2. 编写 Shader</em></strong><br>打开 Chapter7-SingleTexture，删除里面所有代码，编写如下代码：</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 7/Single Texture&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用纹理替代了漫反射颜色，漫反射颜色由 Color 和纹理颜色共同作用</span></span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">//控制物体整体色调</span></span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//之前提到过，2D 是纹理属性的声明方式，&quot;white&quot; 是内置纹理的名字</span></span><br><span class="line">        _Specular (<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            <span class="comment">// 纹理和其他属性类型不同，还需要为纹理类型的属性声明一个 float4 类型的变量 _MainTex_ST。这个名字是因为在 Unity 中需要使用 纹理名_ST 的方式来声明某个纹理的属性</span></span><br><span class="line">            <span class="comment">// ST 指纹理缩放 scale 和平移 translation，_MainTex_ST.xy 存储缩放值，_MainTex_ST.zw 存储偏移值，在材质面板的纹理属性中可以调节（Tiling 平铺即缩放，Offset 偏移即平移）</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0; <span class="comment">// 存储模型的第一组纹理坐标</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                <span class="comment">// 存储纹理坐标的 uv 值，以便在片元着色器中使用该坐标进行纹理采样</span></span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span><span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过缩放和平移后的纹理 uv 值</span></span><br><span class="line">                o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                <span class="comment">// 也可以调用 Unity 提供的内置宏 TRANSFORM_TEX，得到缩放和平移后的纹理 uv 值，与上面的计算逻辑是一致的，可以在 UnityCG.cginc 中找到该内置宏的定义：</span></span><br><span class="line">                <span class="comment">// #define TRANSFORM_TEX(tex, name) (tex.xy * name##_ST.xy + name##_ST.zw)</span></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            float4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过 Cg 的 tex2D 函数对纹理进行采样。第一个参数是被采样的纹理，第二个参数是一个 float2 类型的纹理坐标，函数返回计算得到的纹素值</span></span><br><span class="line">                <span class="comment">// 使用采样结果和颜色属性的乘积作为材质的反射率颜色 albedo</span></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 环境光照和反射率相乘得到环境光部分</span></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用反射率颜色 albedo 来计算漫反射光照的结果</span></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(max(<span class="number">0</span>, dot(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Specular&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对材质的纹理进行赋值后，效果如下图：  </p><div  align="center">  <img src="https://s2.loli.net/2023/11/13/ZPDyJmzEOpkVNg9.png" width = "70%" height = "70%" alt="图19- 使用单张纹理"/></div><h3 id="纹理的属性"><a href="#纹理的属性" class="headerlink" title="纹理的属性"></a>纹理的属性</h3><p>向 Unity 导入一张纹理资源后，可以在其 Inspector 面板中调整其属性。第一个属性是纹理类型，在后面的法线纹理一节中，会使用 Normal Map 类型，之后会看到更多高级纹理。</p><p>纹理的类型默认为 Default，Alpha Source 属性对应的下拉框会有 From Gray Scale，如果选择它，透明通道的值将会由每个像素的灰度值生成。透明效果会在第 7 章讲到，这里先不需要勾选它。</p><p><strong>Wrap Mode</strong> 属性比较重要，决定了当纹理坐标超过 [0, 1] 范围后会如何被平铺：<br>① Repeat 模式：在这模式下，若纹理坐标超过了 1，那么它的整数部分会被截断，直接使用小数部分进行采样，这样的结果就是纹理会不断重复；<br>② Clamp 模型：在这模式下，若纹理坐标超过了 1，那么将会截取到 1，若小于 0，则截取到 0。</p><p><strong>Filter Mode</strong> 属性决定了当纹理由于变换而产生拉伸时，采用哪种滤波模式。Filter Mode 支持 3 种模式：Point，Bilinear 以及 Trilinear。它们得到的图片滤波效果依次提升，但性能消耗也依次增大，纹理滤波会影响放大或缩小纹理时得到的图片质量。<br>① Point 模式：使用<strong>最近邻 nearest neighbor</strong> 滤波，在放大缩小时，采样像素数目通常只有一个，所以图像呈现像素风格的效果。若需要像素风格，使用这个；<br>② Bilinear 模式：使用线性滤波，对每个目标像素，会找到 4 个邻近像素，对其线性插值混合后得到最终像素，所以图像看起来被模糊了；<br>③ Trilinear 模式：原理和 Bilinear 一样，只是 Trilinear 会在多级渐远纹理（下面讲）之间进行混合，如果一张纹理没有使用多级渐远纹理技术，Trilinear 得到的结果和 Bilinear 就是一样的。</p><p>纹理缩小的同时还要解决抗锯齿问题（即会出现一个个很明显的像素边界），常用的方法是使用<strong>多级渐远纹理 mipmapping</strong> 技术。这是一种用空间换取时间的办法，提前将原纹理用滤波器处理来得到更多的小图像，并使用一定的空间用于存放它们，而当物体远离摄像机时，可直接使用较小的纹理进行代替。但通常会多占用 33% 的内存空间。在 Unity 中，在纹理面板中，展开 Advenced，再勾选 Generate Mip Maps 即可开启多级渐远纹理技术。同时可以选择生成多级渐远纹理时是否使用线性空间（用于伽马校正，见第 17 章）以及采用的滤波器等。</p><p><strong>Max Size</strong> 属性：为不同的平台发布游戏时，需要考虑目标平台的纹理尺寸和质量问题，Unity 允许不同的平台进行不同的设置。若导入的纹理大小超过了 Max Size 的设置值，Unity 会把该纹理缩放为这个最大分辨率。一般导入的纹理可以是非正方形的，但是长宽需要是 2 的幂，例如：2、4、8、16等，如果使用了非 2 的幂 <strong>Non Power of Two, NPOT</strong> 大小的纹理，那么这些纹理往往会占用更多的内存空间，GPU 读取这些纹理的速度也会下降，。有一些平台甚至不支持 NPOT 纹理，虽然 Unity 内部会把它缩放到最近的 2 的幂大小，但是尽量使用 2 的幂大小的纹理。</p><p><strong>Format</strong> 属性决定了 Unity 内部使用哪些格式来存储该纹理。使用的纹理格式精度越高，占用的内存越大，得到的效果也越好。可以在纹理面板下方的预览中看到该纹理需要占用的内存空间及相关信息（如果开启了多级渐远纹理技术，也会增加纹理的内存占用）。</p><h2 id="凹凸映射"><a href="#凹凸映射" class="headerlink" title="凹凸映射"></a>凹凸映射</h2><p><strong>凹凸映射 bump mapping</strong>，即使用一张纹理来修改模型表面的法线，以便为模型提供更多的细节。该方法不会真的改变模型的顶点位置，只是让模型看起来像是“凹凸不平”，但可以从模型的轮廓看出“破绽”。</p><p>有两种主要方法可以进行凹凸映射：<br>①使用一张<strong>高度纹理 hight map</strong> 来模拟<strong>表面位移 displacement</strong>，然后得到一个修改后的法线值，该方法被称为<strong>高度映射 height mapping</strong>；<br>②使用一张<strong>法线纹理 normal map</strong> 来直接存储表面法线，这种方法被称为<strong>法线映射 normal mapping</strong>。</p><h3 id="高度纹理"><a href="#高度纹理" class="headerlink" title="高度纹理"></a>高度纹理</h3><p>高度图中存储的是强度值，它用于表示模型表面局部的海拔高度。颜色越浅表明该位置的表面越向外凸起，颜色越深表示越往里凹。我们可以通过高度图中明确的知道一个模型表面的凹凸情况，缺点是计算更加复杂，在实时计算中不能直接得到表面法线，而是需要通过由像素的灰度值计算得出，从而消耗更多的性能。</p><p>高度图通常会和法线映射一起使用，用于给出表面凹凸的额外信息，开发者通常会使用法线映射来修改光照。</p><h3 id="法线纹理"><a href="#法线纹理" class="headerlink" title="法线纹理"></a>法线纹理</h3><p>法线纹理中存储的就是表面的法线方向。由于法线方向各分量范围是 [-1, 1] ，而像素分量范围是 [0, 1]，因此需要做一个映射：</p><script type="math/tex; mode=display">pixel = \cfrac {normal + 1} {2}</script><p>这就要求我们在 Shader 中对法线纹理进行纹理采样后，还需要对结果进行一次反映射过程，以得到原先的法线方向，即上面的逆函数：  </p><script type="math/tex; mode=display">normal = pixel \times 2 - 1</script><p>因为模型顶点自带的法线是定义在模型空间中，从而可以将修改后的模型空间中的表面法线存储在一张纹理中，这种纹理被称为<strong>模型空间的法线纹理 object-space normal map</strong>。而在实际制作中，往往会采用另一种坐标空间，即模型顶点的<strong>切线空间 tangent space</strong> 来存储法线。对于模型的顶点，它都有一个属于自己的切线空间，这个切线空间的原点是该顶点本身，而 z 轴是顶点的法线方向 n，x 轴是顶点的切线方向 t，y 轴可由法线和切线叉积而得，也被称为副切线 bitangent 或副法线。该纹理被称为是<strong>切线空间的法线纹理 tangent-space normal map</strong>。</p><div  align="center">  <img src="https://s2.loli.net/2023/11/14/kJdQsIieGKUVNRa.jpg" width = "30%" height = "30%" alt="图20- 模型顶点的切线空间。其中，原点对应了顶点坐标，x 轴是切线方向 t，y 轴是副切线方向 b，z 轴是法线方向 n"/></div><p>①<strong>模型空间下的法线纹理看上去是五颜六色的</strong>，这是因为，所有法线所在的坐标空间是同一个坐标空间，即模型空间，每个点存储的法线方向是各异，有的是（0，1，0），经过映射后存储到纹理中就对应了 RGB（0.5，1，0.5）浅绿色，有的是（0，-1，0），经过映射后存储到纹理中就对应了 RGB（0.5，0，0.5）紫色。<br>②<strong>切线空间下的法线纹理看起来几乎全部是浅蓝色</strong>，这是因为，每个法线方向所在的坐标空间不一样，即表面每点各自的切线空间。这种法线纹理其实是存储了每个点在各自切线空间中的法线扰动方向。也就是说，若每个点的法线方向不变，那么在它的切线空间中，法线方向就是 z 轴方向，即值为（0，0，1），经过映射后存储在纹理中就对应了 RGB（0.5，0.5，1）浅蓝色。由于凹凸效果一般只要对原法线做微小的变化，所以切线空间下的法线纹理一般都有大面积的蓝色。</p><div  align="center">  <img src="https://s2.loli.net/2023/11/14/t3Ku2JL1OXMBwWN.jpg" width = "50%" height = "50%" alt="图21- 左图：模型空间下的法线纹理。右图：切线空间下的法线纹理"/></div><p>①模型空间存储法线的优缺点<br>&emsp;&emsp; - 计算更少，生成简单；<br>&emsp;&emsp; - 可以提供平滑的边界，在纹理坐标缝合处和尖锐的边角部分，可见的突隙较少。因为模型空间的法线纹理是同一个坐标系下，边界处通过插值得到的法线可以平滑变换；而切线空间需要依赖纹理坐标方向得到，边缘处或尖锐部分会造成更多可见的缝合迹象。<br>②切线空间存储法线的优缺点<br>&emsp;&emsp; - 自由度很高，模型空间下的法线纹理记录的是绝对法线信息，仅可用于创建它时的模型，而应用到其他模型上效果就完全错误的。切线空间下的法线纹理记录的是相对法线信息。即把该纹理应用到一个完全不同的网络上，也可以得到一个合理的效果；<br>&emsp;&emsp; - 可进行 UV 动画。如可移动一个纹理的 UV 坐标来实现一个凹凸移动的效果，但使用模型空间下的法线纹理会得到完全错误的结果。UV 动画在水或火山熔岩这种类型上的物体会经常用到；<br>&emsp;&emsp; - 可重用法线纹理，如一个砖块，仅使用一张法线纹理就可以用到所有的 6 个面上了；<br>&emsp;&emsp; - 可压缩。由于切线空间下的法线纹理中法线的 Z 方向总是正方向，因此开发者可以仅存 XY 方向，而推导 Z 方向。而模型空间下的法线纹理由于每个方向都是可能的，从而必须存储 3 个方向的值，不可压缩。</p><p>由以上的优点分析，可见切线空间的灵活性和可重用性让它很多情况下都优于模型空间下的法线纹理，因此大多数情况下会使用切线空间下的纹理坐标，原书使用的也是切线空间下的法线纹理。</p><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>在计算光照模型中需要统一各个方向矢量所在的坐标空间，法线纹理中存储的是切线空间下的法线方向，处理光照有两种选择：<br>①在切线空间下计算光照，将光照方向、视角方向变换到切线空间下；<br>②在世界空间下计算光照，将采样得到的法线方向变换到世界空间下，再和世界空间下的光照方向和视角方向进行计算；  </p><p>从效率上讲，前一种更优，因为前者可在顶点着色器上完成对光照方向和视角方向的变换，而后者因为光照计算在采样获得法线方向之后，所以光照方向和视角方向的变换过程必须在片元着色器上实现；从通用性上将，后一种更优，因为有时候需要在世界空间中进行其他的计算，比如使用 Cubemap 进行环境映射时，需要使用世界空间下的反射方向对 Cubemap 进行采样（见第九章）。</p><h4 id="在切线空间下计算"><a href="#在切线空间下计算" class="headerlink" title="在切线空间下计算"></a>在切线空间下计算</h4><p><strong><em>1. 准备工作</em></strong><br>①新建名为 Scene_7_2_3 的场景，并去掉天空盒子；<br>②新建名为 NormalMapTangentSpaceMat 的材质；<br>③新建名为 Chapter7-NormalMapTangentSpace 的 Shader，并赋给上一步创建的材质；<br>④在场景中新建一个胶囊体，并将第二步创建的材质赋给它；<br>⑤保存场景；</p><p><strong><em>2. 编写 Shader</em></strong><br>在切线空间下计算光照模型的基本思路就是：在片元着色器中通过纹理采样得到切线空间下的法线，然后再与切线空间下的视角方向、光照方向等进行计算，得到最终的光照效果。</p><p>因此我们需要知道从模型空间到切线空间的变化矩阵。这个变化矩阵的逆矩阵，即从切线空间到模型空间的变换矩阵，非常容易求：按切线（x 轴）、副切线（y 轴）、法线（z 轴）的顺序，以它们在模型空间的坐标<strong>按列</strong>排列即可（数学原理忘了详见数学基础章节）。因为从模型空间到切线空间的变换仅存在平移、旋转和缩放变换，而我们只关心方向，并假设不存在非统一缩放，故截取变换矩阵前三列前三行的矩阵是旋转矩阵，而旋转矩阵是正交矩阵，那么这个变换的逆矩阵就等于它的转置矩阵。因此，从模型空间到切线空间的变换矩阵就是从切线空间到模型空间的变换矩阵的转置矩阵，把切线（x 轴）、副切线（y 轴）、法线（z 轴）的顺序<strong>按行</strong>排列即可。</p><blockquote><p>原书中这一段存在些许错误，上面是我更正后的版本，了解逻辑比较重要，故保留书中原代码。作者冯乐乐在 Github 中对该错误进行了修正和解释，可以去看看，下面代码（原书代码）只适用于只存在统一缩放的情形下，不然会出现视觉问题。若存在非统一缩放，就必须求逆，但 Unity 不支持 Cg 的 inverse 函数，需要自己定义一个（冯乐乐的 github 中有写），比较麻烦，建议直接使用转换到世界空间的方法计算，会比较简单，不用求逆（因为不需要将 XX 向量转换到切线空间）。  </p><p>实际上，在 Unity 4.x 版本及其之前的版本中，内置的 shader 一直是原来书上那种不严谨的转换方法，这是因为 Unity 5 之前，如果我们对一个模型 A 进行了非统一缩放，Unity 内部会重新在内存中创建一个新的模型 B，模型 B 的大小和缩放后的 A 是一样的，但是它的缩放系数是统一缩放。换句话说，在 Unity 5 以前，实际上我们在 Shader 中根本不需要考虑模型的非统一缩放问题，因为在 Shader 阶段非统一缩放根本就不存在了。但从 Unity 5 以后，我们就需要考虑非统一缩放的问题了。  </p><p><strong>注意：</strong>区分模型顶点的真实法线和渲染法线（贴图上的法线）。对于模型顶点的真实法线，即切线空间中的法线，不论处于任何空间之时，它必须与模型表面垂直。即切线空间的三条线，切线 Tagent，副切线 Bitangent，法线 Normal，相互垂直。这三条线构成的变换矩阵，称为 <strong>TBN 矩阵</strong>（分为到模型空间和世界空间两种）。注：曲面上某点的切线理论上有无数条，建模软件计算切线时，会选择和 UV 展开方向相同的方向作为切线方向。法线纹理的原理就是修改了法线的方向，来得到看似凹凸的效果，故需要用真实法线的 TBN 矩阵把贴图记录的法线（渲染法线）转换到其他空间上去，以使用法线的偏移信息。渲染法线（用于光照计算）和切线不需要相互垂直，想想 Blender 里面对法线的修改产生不一样的视觉效果。</p></blockquote><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 7/Normal Map In Tangent Space&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _BumpMap (<span class="string">&quot;Normal Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125; <span class="comment">// 法线纹理，默认使用 &quot;bump&quot; ，是 Unity 内置的法线纹理，当没有提供任何法线纹理时，&quot;bump&quot; 就对应模型自带的法线信息</span></span><br><span class="line">        _BumpScale (<span class="string">&quot;Bump Scale&quot;</span>, Float) = <span class="number">1.0</span> <span class="comment">// 控制凹凸程度，当它为 0 时，表示该法线纹理不会对光照产生任何影响</span></span><br><span class="line">        _Specular (<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST; <span class="comment">//同样，为了得到纹理的平铺和偏移属性</span></span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT; <span class="comment">// 切线方向，使用 float4 类型（不同于法线的 float3），因为需要 tangent.w 分量来决定切线空间的副切线的方向性</span></span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0; <span class="comment">// UV 使用 float4 类型，xy 存储主纹理坐标，zw 存储法线纹理坐标，出于减少插值寄存器的使用数量的目的</span></span><br><span class="line">                float3 lightDir : TEXCOORD1; <span class="comment">//输出切线空间下光照方向</span></span><br><span class="line">                float3 viewDir : TEXCOORD2; <span class="comment">//输出切线空间下视角方向</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 存储主纹理的 uv 值</span></span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                <span class="comment">// 存储法线纹理的 uv 值</span></span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算副切线，乘以 w 分量确定副切线的方向性（与法线、切线垂直的有两个方向）</span></span><br><span class="line">                <span class="comment">// float3 binormal = cross(normalize(v.normal), normalize(v.tangent.xyz)) * v.tangent.w;</span></span><br><span class="line">                <span class="comment">// Cg 中 float4×4 是按行排列的，所以获取从从模型空间到切线空间的变换矩阵直接按行排列前后即可</span></span><br><span class="line">                <span class="comment">// float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 直接使用下述内置宏（在 UnityCG.cginc 中被定义)即可，它的实现和上述代码完全一样</span></span><br><span class="line">                TANGENT_SPACE_ROTATION;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将光照、视角方向由模型空间转到切线空间</span></span><br><span class="line">                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line">                fixed3 tangentViewDir = normalize(i.viewDir);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对法线纹理进行采样，获取纹素值</span></span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 tangentNormal;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果纹理没有被标记为 Normal map ，则需要手动反映射得到法线方向</span></span><br><span class="line">                <span class="comment">// tangentNormal.xy = packedNormal.xy * 2 - 1;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果纹理被标记为 Normal map，Unity 就会根据不同的平台来选择不同的压缩方法，需要调用 UnpackNormal 来进行反映射。如果这时再手动计算反映射就会出错，因为 _BumpMap 的 rgb 分量不再是切线空间下的法线方向 xyz 值了。本大节第四小节会解释</span></span><br><span class="line">                tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line"></span><br><span class="line">                tangentNormal.xy *= _BumpScale; <span class="comment">//控制凹凸程度</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 因为贴图存储的法线为单位向量，且 z 分量为正。所以我们可以通过勾股定理计算 z 分量的值，下面通过点乘计算 x 的平方加上 y 的平方</span></span><br><span class="line">                tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="number">0</span>, dot(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(max(<span class="number">0</span>, dot(tangentNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Specular&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果见在世界空间下计算的后面。</p><h4 id="在世界空间下计算"><a href="#在世界空间下计算" class="headerlink" title="在世界空间下计算"></a>在世界空间下计算</h4><p><strong><em>1. 准备工作</em></strong><br>①新建名为 NormalMapWorldSpaceMat 的材质；<br>②新建名为 Chapter7-NormalMapWorldSpace 的 Shader，并赋给上一步创建的材质；<br>③在原来的场景中新建一个胶囊体，并将第一步创建的材质赋给它；<br>④保存场景；</p><p><strong><em>2. 编写 Shader</em></strong><br>在世界空间下计算光照模型的基本思路就是：在顶点着色器中计算从切线空间到世界空间的变换矩阵，传递给片元着色器，然后在片元着色器中将贴图的法线方向从切线空间变换到世界空间：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 7/Normal Map In World Space&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _BumpMap (<span class="string">&quot;Normal Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">        _BumpScale (<span class="string">&quot;Bump Scale&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _Specular (<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 矩阵变量按行拆分存储，因为一个插值寄存器最多只能存储 float4 大小的变量故将切线空间到世界空间的变换矩阵的每一行拆分到对应的 float4 变量中</span></span><br><span class="line">                <span class="comment">// 矩阵是 3X3 大小，但是为了充分利用存储空间，float4的 w 分量用于分别存储世界空间下的顶点位置的 x、y、z 分量</span></span><br><span class="line">                float4 TtoW0 : TEXCOORD1;</span><br><span class="line">                float4 TtoW1 : TEXCOORD2;</span><br><span class="line">                float4 TtoW2 : TEXCOORD3;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; <span class="comment">//这里最好不要使用 UnityObjectToWorldDir 这个帮助函数，因为这个帮助函数会归一化向量，详见源码，这样存储的原点位置会导致片元着色器的计算有点小问题</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这里使用归一化后的向量可行的原因是切线空间到世界空间的变换不存在缩放，必然是一个旋转或者镜像，所以乘上 v.tangent.w。上面的在切线空间下计算的方法存在缩放问题，是因为模型空间到世界空间可能存在非统一缩放，即模型存在非统一缩放，所以当切线空间转换到模型空间也可能存在非统一缩放。不知道对不对，先写着，否则没法解释被归一化的问题</span></span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; <span class="comment">//单位向量与单位向量叉乘得到的也是单位向量</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算切线空间到世界空间的矩阵，并存储到 TtoWX 变量中，将切线、副切线、法线按列拜访，w 分量用来存储顶点在世界空间下的坐标（充分利用插值寄存器的存储空间）</span></span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 解析 w 分量，得到世界空间下的当前坐标</span></span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                <span class="comment">// 使用内置函数计算世界空间下的光照、视角方向（世界坐标被标准化了，计算出的方向就会出问题，所以不能标准化）</span></span><br><span class="line">                fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 采样并反映射得到法线信息，UnpackNormal 函数需要法线纹理的格式为 Normal map，别忘了</span></span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">                bump.xy *= _BumpScale;</span><br><span class="line">                bump.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(dot(bump.xy, bump.xy)));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将法线由切线空间转到世界空间，为什么这么乘，想想矩阵乘法</span></span><br><span class="line">                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="number">0</span>, dot(bump, lightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 halfDir = normalize(lightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(max(<span class="number">0</span>, dot(bump, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Specular&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对材质的纹理进行赋值后，效果如下图（注意叉乘的顺序，会改变凹凸的方向）：  </p><div  align="center">  <img src="https://s2.loli.net/2023/11/15/GcNQ9geDMTlWbmy.jpg" width = "70%" height = "70%" alt="图22- 使用 Bump Scale 属性来调整模型的凹凸程度"/></div><h3 id="Unity-中的法线纹理类型"><a href="#Unity-中的法线纹理类型" class="headerlink" title="Unity 中的法线纹理类型"></a>Unity 中的法线纹理类型</h3><h4 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h4><p>前面代码中提到，必须将法线纹理标识为 Normal map，使用 Unity 的内置函数 UnpackNormal 才能得到正确的法线方向（Unity 会在材质面板中提醒你修正这个问题）。</p><p>这样做可以让 Unity 根据不同平台对纹理进行压缩（例如使用 DXT5nm 格式），再通过 UnpackNormal 函数来针对不同的压缩格式对法线纹理进行正确的采样。UnityCG.cginc 里 UnpackNormal 函数的内部实现（最新版的有细微变化）：  </p><pre><code>inline fixed3 UnpackNormalDXT5nm(fixed4 packednormal)&#123;    fixed3 normal;    normal.xy = packnormal.wy * 2 - 1;    normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));    return normal;&#125;inline fixed3 UnpackNormal(fixed4 packednormal)&#123;#if defined(UNITY_NO_DXT5nm)    return packednormal.xyz * 2 - 1;#else    return UnpackNormalDXT5nm(packednormal);#endif&#125;</code></pre><p>在 DXT5nm 格式的法线纹理中，纹理的 a 通道对应了法线的 x 分量，g 通道对应了法线的 y 分量，而纹理的 r 和 b 通道则会被舍弃，法线的 z 分量可以由 xy 分量推导而得。这种压缩方式可以减少法线纹理占用的内存空间。</p><h4 id="高度图的纹理类型"><a href="#高度图的纹理类型" class="headerlink" title="高度图的纹理类型"></a>高度图的纹理类型</h4><p>若要从高度图生成法线纹理，因为高度图本身记录的是相对高度，是一张灰度图，白色相对高，黑色相对低，所以把一张高度图导入 Unity 之后，除了需要将纹理类型设置为 Normal map 外，还需要勾选 <strong>Create from Grayscale</strong>，然后 Unity 会根据高度图来生成一张切线空间下的法线纹理（灰色变蓝色）。</p><p>勾选 Create from Grayscale 后，会多出 Bumpiness 和 Filtering 两个选项。Bumpiness 用于控制凹凸程度；Filtering 决定了使用什么方式计算凹凸程度，选择 Smooth，法线纹理会比较平滑，选择 Sharp，会使用 Sobel 滤波（一种边缘检测时使用的滤波器）来生成法线。</p><p>Sobel 滤波的实现是在一个 3×3 的滤波器中计算 x 和 y 方向上的导数，然后从中得到法线即可。具体方法是：对于高度图中的每个像素，考虑它与水平方向和竖直方向上的像素差，把它们的差当成该点对应的法线在 x 和 y 方向上的位移，然后使用映射函数存储成法线纹理的 r 和 g 分量即可。</p><h2 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h2><p>最开始纹理只是为了定义物体的颜色，后来发现，纹理可以存储任何表面属性。其中一种用法就是使用渐变纹理来控制漫反射光照的结果。这种技术在游戏《军团要塞 2》（Team Fortress 2）中流行起来，它也是由 Valve 公司提出来的，他们使用这种技术来渲染游戏中具有插画风格的角色。Valve 发表了一篇著名的论文来专门讲述在制作《军团要塞 2》时使用的技术。</p><p>这项技术最初由 Gooch 等人在 1998 年发表的一篇著名的论文《A Non-Photorealistic Lighting Model For Automatic Technical Illustration》中被提出，在这篇论文中，作者提出一种基于<strong>冷到暖色调 cool-to-warm tones</strong> 的着色技术，用来得到一种插画风格的渲染效果。使用这种技术，可以保证物体的轮廓线相比传统的漫反射光照更加明显，而且能够提供多种色调变化。现在，很多卡通风格的渲染中都使用了这种技术，在第十三章，会专门学习如何编写卡通风格的 Unity Shader。</p><h3 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h3><p><strong><em>1. 准备工作</em></strong><br>①新建名为 Scene_7_3 的场景，并关闭天空盒子；<br>②新建名为 RampTextureMat 的材质；<br>③新建名为 Chapter7-RampTexture 的 Shader，并赋给上一步创建的材质；<br>④往场景中拖拽一个名为 Suzanne 的模型，并把第二步创建的材质赋给它，模型可以从文章开头的 Git 仓库中找，路径为 Assets/Models/Chap7/；<br>⑤保存场景</p><p><strong><em>2. 编写 Shader</em></strong>  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 7/Ramp Texture&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _RampTex (<span class="string">&quot;Ramp Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">// 渐变纹理</span></span><br><span class="line">        _Specular (<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _RampTex;</span><br><span class="line">            float4 _RampTex_ST;</span><br><span class="line">            fixed3 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; <span class="comment">//不能使用 UnityObjectToWorldDir ，该帮助函数会把坐标点标准化，适用于方向，不使用于位置</span></span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _RampTex); <span class="comment">//使用内置宏计算经过平铺偏移后的纹理坐标</span></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span> <span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//半兰伯特模型</span></span><br><span class="line">                fixed halfLambert = <span class="number">0.5</span> * dot(worldNormal, worldLightDir) + <span class="number">0.5</span>;</span><br><span class="line">                <span class="comment">//见代码后面补充</span></span><br><span class="line">                fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br><span class="line"></span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">                fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(max(<span class="number">0</span>, dot(worldNormal, halfDir)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Specular&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：为什么这样计算可以使用渐变纹理，即使用 halfLambert 来构建纹理坐标。首先渐变纹理本质上是一个一维纹理（它在纵轴方向上颜色不变），所以渐变纹理本身不是和模型的纹理坐标一一对应的，而是和顶点的法线方向和光照之间的角度，一一对应。首先，halfLambert 被映射到了 [0, 1] 之间，假设顶点法线和光照方向相反，即点乘为 -1 ，halfLambert 值为零，这样得到的是渐变纹理最左边的颜色（一般为深颜色，可以看下面效果图）；若顶点法线和光照方向一致，即点乘为 1，halfLambert 值为 1，这样得到的是渐变纹理最右边的颜色（一般为浅色）。所以通过这样的方法，可以获得一个根据角度进行颜色渐变的模型。这也是为什么按 halfLambert 对渐变纹理进行采样，也就是 diffuseColor 的变量本质上已经反应了半兰伯特模型对光照的修改，所以 diffuse 变量不需要再乘上 halfLambert。</p><p>使用不同的渐变纹理的效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/11/16/nAixmBu37kfQRYg.jpg" width = "80%" height = "80%" alt="图23- 使用不同的渐变纹理控制漫反射光照，左下角给出了每张图使用的渐变纹理"/></div><p>需要注意的是，渐变纹理的 WrapMode 需要设置为 Clamp，否则采样时由于浮点数精度造成问题。使用 Repeat 模式在高光区域会有些黑点，因为使用 halfLambert 采样时，理论上范围在 [0, 1]，但实际上会出现 1.00001 这样的值出现，使用 Repeat 模型，会舍弃整数部分，保留 0.00001 ，对应渐变图的最左边，即黑色。</p><h2 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h2><p><strong>遮罩纹理 mask texture</strong> 允许我们保护某些区域，使其免于被修改。例如之前，我们都是把高光反射应用到模型表面的所有的地方，即所有的像素都使用同样大小的高光强度和高光指数，但有时，我们希望模型表面某些区域的反光强烈一些，而某些区域弱一些。为了得到更细腻的效果，我们使用一张遮罩纹理来控制光照。另一个常见的应用就是在制作地形材质时，需要混合多张图片，例如草地纹理、石子纹理、土地纹理等，使用遮罩纹理可以控制如何混合这些纹理。</p><p>使用遮罩纹理的一般流程：采样得到遮罩纹理的纹素值，然后取纹素值的某个（或某几个）通道的值（如：r，rg）与某种表面属性相乘。这样，若该通道的值为 0，可以保护表面不受该属性影响。总之，遮罩纹理可以让美术人员更加精准（像素级别）地控制模型表面的各种性质。</p><h3 id="实践-3"><a href="#实践-3" class="headerlink" title="实践"></a>实践</h3><p><strong><em>1. 准备工作</em></strong><br>①新建名为 Scene_7_4 的场景，并去掉天空盒子；<br>②新建名为 MaskTextureMat 的材质；<br>③新建名为 Chapter7-MaskTexture 的 Shader，并赋给上一步创建的材质；<br>④在场景中创建一个胶囊体，并将第二步的材质赋给它；<br>⑤保存场景；</p><p><strong><em>2. 编写 Shader</em></strong><br>原书中用的是在切线空间下计算的方法，我把它改为了在世界空间下计算：</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 7/Mask Texture&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _BumpMap (<span class="string">&quot;Normal Map&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;bump&quot;</span> &#123;&#125;</span><br><span class="line">        _BumpScale (<span class="string">&quot;Bump Scale&quot;</span>, Float) = <span class="number">1.0</span></span><br><span class="line">        _SpecularMask (<span class="string">&quot;Specular Mask&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//高光反射遮罩纹理</span></span><br><span class="line">        _SpecularScale (<span class="string">&quot;Specular Scale&quot;</span>, Float) = <span class="number">1.0</span> <span class="comment">//控制遮罩影响程度的系数</span></span><br><span class="line">        _Specular (<span class="string">&quot;Specular&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _Gloss (<span class="string">&quot;Gloss&quot;</span>, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST; <span class="comment">// _MainTex、_BumpMap 和 _SpecularMask 共用同一套纹理属性变量 _MainTex_ST，这样意味着修改主纹理的平铺系数和偏移系数，会同时影响 3 个纹理的采样，这样可以节省存储的纹理坐标数，减少差值寄存器的使用。</span></span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            <span class="type">float</span> _BumpScale;</span><br><span class="line">            sampler2D _SpecularMask; </span><br><span class="line">            <span class="type">float</span> _SpecularScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            <span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;</span><br><span class="line">                float4 TtoW1 : TEXCOORD2;</span><br><span class="line">                float4 TtoW2 : TEXCOORD3;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;</span><br><span class="line"></span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv));</span><br><span class="line">                bump.xy *= _BumpScale;</span><br><span class="line">                bump.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(dot(bump.xy, bump.xy)));</span><br><span class="line">                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="number">0</span>, dot(bump, lightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 halfDir = normalize(lightDir + viewDir);</span><br><span class="line">                <span class="comment">// 先对遮罩纹理进行采样，本书使用的遮罩纹理的每个纹素的 rgb 分量是一样的，表示该点对应的高光强度，这里选择 r 分量来计算掩码值。然后乘上 _SpecularScale 来控制高光反射的强度</span></span><br><span class="line">                fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(max(<span class="number">0</span>, dot(bump, halfDir)), _Gloss) * specularMask;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Specular&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下（为了效果明显一点，把 _Gloss 属性调成了 8）：  </p><div  align="center">  <img src="https://s2.loli.net/2023/11/17/B52lDu4dftmwkg8.png" width = "70%" height = "70%" alt="图24- 使用高光遮罩纹理。从左到右：只包含漫反射，未使用遮罩的高光反射，使用遮罩的高光反射"/></div><h3 id="其他遮罩纹理"><a href="#其他遮罩纹理" class="headerlink" title="其他遮罩纹理"></a>其他遮罩纹理</h3><p>我们可以充分利用一张纹理 RGBA 四个通道，分别存储各种不同的属性来控制模型表面的渲染效果。例如，R 通道存储高光反射的强度；G 通道存储边缘光照的强度；B 通道存储高光反射的参数；A 通道存储自发光强度。</p><p>在《DOTA 2》的开发中，开发人员为每个模型使用了 4 张纹理：一张用于定义模型颜色，一张用于定义表面法线，另外两张则都是遮罩纹理，可提供 8 种额外的表面属性。可以在官网上找到详细的制作资料，是非常好的学习资料。</p><h1 id="第七章-透明效果"><a href="#第七章-透明效果" class="headerlink" title="第七章 透明效果"></a>第七章 透明效果</h1><p>实时渲染中，通过控制渲染模型的<strong>透明通道 Alpha Channel</strong> 来实现透明效果。当开启透明混合后，当一个物体被渲染到屏幕上时，每个片元除了颜色值和深度值，还有透明值属性。</p><p>在 Unity 中，我们通常使用两种方法来实现透明效果：第一种为使用<strong>透明度测试 Alpha Test</strong>，这种方式无法得到真正的半透明效果；另一种是<strong>透明度混合 Alpha Blending</strong>。</p><p>当场景中存在多个模型时，渲染顺序问题非常重要。实际上，对于不透明 opaque 物体，不考虑它们的渲染顺序也能得到正确的排序效果，这是由于<strong>深度缓冲 depth buffer</strong>，也称 <strong>z-buffer</strong>，的存在。在实时渲染中，深度缓冲是用于解决可见性问题的。它的基本思路就是：根据深度缓冲中的值来判断该片元距离摄像机的距离，当渲染一个片元时，需要把它的深度值和已经存在于深度缓冲中的值进行比较（如果开启了深度测试），如果它的值距离摄像机更远，那么说明这个片元不应该被渲染到屏幕上（即有物体挡住了它）；否则，这个片元应该覆盖掉此时颜色缓冲中的像素值，并把它的深度值更新到深度缓冲中（如果开启了深度写入）。使用深度缓冲，可以不用关心不透明物体的渲染顺序，但如果要实现透明效果，就不那么简单了，因为要关闭深度写入。</p><p>①<strong>透明度测试</strong>：只要一个片元的透明度不满足条件（通常是小于某个阈值），则该片元就会被舍弃，否则就按不透明的物体进行处理，即进行深度测试、深度写入等。即透明度测试不需要关闭深度写入，虽然简单，但是它的效果，要么看不见，要么完全不透明。  </p><p>②<strong>透明度混合</strong>：可以得到半透明效果。使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。但是，透明度混合需要关闭深度写入（后面讲为什么），这使得要特别小心物体的渲染顺序。注意，透明度混合只关闭了深度写入（即对于透明度混合来说，深度缓冲是只读地），没关闭深度测试。即当不透明物体在透明物体前面，还是可以正常地遮挡。</p><h2 id="渲染顺序的重要性"><a href="#渲染顺序的重要性" class="headerlink" title="渲染顺序的重要性"></a>渲染顺序的重要性</h2><p>对于透明度混合，关闭深度写入是必要的：如果不关闭深度写入，一个半透明表面背后的表面本来是可以透过它被看到的，但是由于深度测试时判断是该半透明体离摄像机更近，导致后面的表面会被剔除。而关闭深度写入，会导致渲染顺序变得非常重要。</p><p>假设场景里存在半透明物体 A，和不透明物体 B，A 在 B 前面（A 离摄像头更近），此时不同的渲染顺序会有不同的结果：<br>①先渲染 B，再渲染 A：由于不透明物体开启了深度测试和深度写入，B 会首先写入颜色缓冲和深度缓冲。随后渲染 A，透明物体仍然会进行深度测试，因为 A 离摄像头更近，因此使用 A 的透明度和颜色缓冲中 B 的颜色进行混合就可以得到正确的半透明效果。<br>②先渲染 A，再渲染 B：渲染 A 时，深度缓冲区没有任何有效数据，因此 A 直接写入颜色缓冲，但由于对半透明物体关闭了深度写入，因此 A 不会修改深度缓冲。等到渲染 B 时，B 进行深度测试，由于深度缓冲中没有任何有效数据，B 就会写入颜色缓冲，结果就是 B 会直接覆盖 A 的颜色。</p><p>假设场景中 A 和 B 都是半透明物体，半透明物体之间也要符合一定的渲染顺序：<br>①先渲染 B，再渲染 A：B 会正常写入颜色缓冲，然后 A 和颜色缓冲中的 B 颜色进行混合，得到正确的半透明效果。<br>②先渲染 A，再渲染 B：A 先正常写入颜色缓冲，随后 B 会和颜色缓冲中的 A 进行混合，这样混合结果会完全反过来，看起来好像 B 在 A 的前面，得到错误的半透明结构。</p><p>基于上面两个例子，渲染引擎一般会先对物体进行排序，再渲染。常用的方法是：<br>①先渲染所有不透明物体，并开启它们的深度测试和深度写入；<br>②把透明物体按照它们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，开启它们的深度测试，但关闭深度写入。</p><p>但是仍有问题没被解决，因为物体级别的顺序和像素级别的顺序会存在出入。由于某些情况下物体的排序存在循环重叠的情况（比如三个棒子，交叉循环），会导致渲染无法得到正确的结果。即使使用物体网格的相同顶点进行排序，仍然可能存在，A 的顶点在 B 的顶点前，但实际上，B 在 A 前的情况，如下图：</p><table><tr><td><img src='https://s2.loli.net/2023/11/21/mP74J5snRhDW9MA.jpg' width="200" alt="图25- 循环重叠的半透明物体总是无法得到正确的半透明效果"></td><td><img src='https://s2.loli.net/2023/11/21/ifpBgNaZwVH9CPW.jpg' width="200" alt="图26- 使用哪个深度对物体进行排序。红色点分别标明了网格上距离摄像机最近的点、最远的点以及网格中点"></td></tr></table><p>尽管会有一些特殊情况，大多数游戏引擎仍然使用了这样的方法。为了减少错误顺序的情况，开发者尽可能让模型是凸面体，并考虑将复杂的模型拆分成可以独立排序的多个子模型。而若不想分割网格可以将透明通道更加柔和，使穿插不那么明显，同时也可以使用开启深度写入的半透明效果来近似模拟物体的半透明（见本章第 5 节）。</p><h2 id="Unity-Shader-的渲染顺序"><a href="#Unity-Shader-的渲染顺序" class="headerlink" title="Unity Shader 的渲染顺序"></a>Unity Shader 的渲染顺序</h2><p>Unity 为了解决渲染顺序的问题提供了<strong>渲染队列 render queue</strong> 这一解决方案。可以使用 SubShader 的 <strong>Queue</strong> 标签来决定我们的模型将归于哪个渲染队列。Unity 在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染。下表给出了 Unity 提前定义的渲染队列以及它们的描述（在每个队列中间可以使用其他队列）：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">队列索引号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Background</td><td style="text-align:left">1000</td><td style="text-align:left">会在任何其他队列之前渲染，通常使用该队列来渲染那些需要绘制在背景上的物体</td></tr><tr><td style="text-align:left">Geometry</td><td style="text-align:left">2000</td><td style="text-align:left">默认的渲染队列，大多数物体使用这个队列，不透明物体使用这个队列</td></tr><tr><td style="text-align:left">AlphaTest</td><td style="text-align:left">2450</td><td style="text-align:left">需要透明度测试的物体使用这个队列。Unity 5 中将它从 Geometry 中分离出来，因为在所有不透明物体渲染之后再渲染需要透明度测试的物体更加有效</td></tr><tr><td style="text-align:left">Transparent</td><td style="text-align:left">3000</td><td style="text-align:left">这个队列的物体会在所有的 Geometry 和 AlphaTest 物体渲染后，再按<strong>从后往前</strong>的顺序进行渲染。任何使用了透明底混合(例如关闭了深度写入的 Shader)的物体都应该使用该队列</td></tr><tr><td style="text-align:left">Overlay</td><td style="text-align:left">4000</td><td style="text-align:left">用于实现一些叠加效果。任何需要在最后渲染的物体都使用该队列</td></tr></tbody></table></div><p>想要通过透明度测试实现透明效果，代码应该包含类似下面的代码：  </p><pre><code>SubShader &#123;    Tags &#123;&quot;Queue&quot; = &quot;AlphaTest&quot;&#125;    Pass &#123;        ...    &#125;&#125;</code></pre><p>想要通过透明度混合实现透明效果，代码应该包含类似下面的代码：  </p><pre><code>SubShader &#123;    Tags &#123;&quot;Queue&quot; = &quot;Transparent&quot;&#125;    Pass &#123;         ZWrite Off        ...    &#125;&#125;</code></pre><p>其中，<strong>ZWrite Off</strong> 用于关闭深度写入，这里选择写在 Pass 中。也可以写在 SubShader 中，意味着 SubShader 下的所有 Pass 都会关闭深度写入。</p><h2 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h2><p>只要一个片元的透明度不满足条件（通常是小于某个阈值），则这个片元就会被舍弃，不进行任何处理，不会对颜色缓冲产生任何影响。否则按照普通的不透明物体的处理方式进行处理。通常在片元着色器中使用 <code>clip</code> 函数进行透明度测试，clip 是 Cg 中的一个函数，它的定义如下：  </p><pre><code>// 函数的参数是裁剪时使用的标量或矢量条件void clip(float4 x);void clip(float3 x);void clip(float2 x);void clip(float1 x);void clip(float x);// 如果给定参数的任何一个分量是负数，就会舍弃当前像素的输出颜色void clip(float4 x)&#123;    if (any(x &lt; 0))        discard;&#125;</code></pre><h3 id="实践-4"><a href="#实践-4" class="headerlink" title="实践"></a>实践</h3><p><strong><em>1. 准备工作</em></strong><br>①新建名为 Scene_8_3 的场景，并去掉天空盒子；<br>②新建名为 AlphaTestMat 的材质；<br>③新建名为 Chapter8-AlphaTest 的 Shader，并赋给上一步创建的材质；<br>④在场景中创建一个立方体，并把第二步的材质赋给它；<br>⑤保存场景。</p><p><strong><em>2. 编写 Shader</em></strong>  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 8/Alpha Test&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Main Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Cutoff (<span class="string">&quot;Alpha Cutoff&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span> <span class="comment">// 透明度测试的阈值</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 透明度测试常用的三个标签</span></span><br><span class="line">        Tags &#123;</span><br><span class="line">            <span class="comment">// 设置渲染队列为 AlphaTest 队列</span></span><br><span class="line">            <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;AlphaTest&quot;</span></span><br><span class="line">            <span class="comment">// 让当前 Shader 不会受到投射器的影响</span></span><br><span class="line">            <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;True&quot;</span></span><br><span class="line">            <span class="comment">// 让 Unity 把当前 Shader 归入到提前定义的组，这里指 TransparentCutout 组，以指明该 Shader 是一个使用了透明度测试的 Shader</span></span><br><span class="line">            <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;TransparentCutout&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _Cutoff;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 透明度测试：透明度小于 _Cutoff 的值，则当前片元会被丢弃</span></span><br><span class="line">                clip(texColor.a - _Cutoff);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等同于</span></span><br><span class="line">                <span class="comment">// if ((texColor.a - _Cutoff) &lt; 0.0) &#123;</span></span><br><span class="line">                <span class="comment">//     discard;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, <span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用内置的 VertexLit Shader 作为回调 Shader。保证该 SubShader 无法在当前显卡工作时可以有合适的代替 shader，还保证使用透明度测试的物体可以正确地向其他物体投射阴影</span></span><br><span class="line">    Fallback <span class="string">&quot;Transparent/Cutout/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用下图的半透明纹理来实现透明度测试。在 Github 中 /Assets/Textures/Chapter8 文件夹下的 transparent_texure.psd：</p><div  align="center">  <img src="https://s2.loli.net/2023/11/21/VQ2bGYOuZXqWopi.jpg" width = "30%" height = "30%" alt="图27- 一张透明纹理，其中每个方格的透明度都不同"/></div><p>效果如下（从左到右分别给 _Cutoff 值设置 0.6、0.7、0.8）：</p><div  align="center">  <img src="https://s2.loli.net/2023/11/21/MsIvklBULaj94pD.png" width = "70%" height = "70%" alt="图28- 随着 Alpha cutoff 参数的增大，更多的像素由于不满足透明度测试条件而被剔除"/></div><p>可以看出，透明度测试得到的效果，要么完全透明，要么完全不透明。而且，得到的透明效果在边缘处往往参差不齐，有锯齿，这是因为边界处纹理的透明度的变化精度问题。</p><h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合得到新的颜色。但是需要关闭深度写入，所以我们需要非常小心物体的渲染顺序。为了进行混合，Unity 为我们提供了混合命令 —— <strong>Blend</strong>。Blend 是 Unity 提供的设置混合模式的命令。下表中给出了 Blend 命令的语义：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">语义</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Blend Off</td><td style="text-align:left">关闭混合</td></tr><tr><td style="text-align:left">Blend SrcFactor DstFactor</td><td style="text-align:left">开启混合，并设置混合因子。源颜色（当前片元的颜色）x SrcFactor + 目标颜色（已经存在于颜色缓冲中的颜色） x DstFactor，得到的最终颜色存入颜色缓冲中</td></tr><tr><td style="text-align:left">Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td><td style="text-align:left">与上面几乎一样，使用不同的因子来混合透明通道</td></tr><tr><td style="text-align:left">BlendOp BlendOperation</td><td style="text-align:left">并非源颜色和目标颜色的简单相加后混合，而使用 BlendOperation 对它们进行其他操作</td></tr></tbody></table></div><p>在本节中，会使用第二种语义，即 Blend SrcFactor DstFactor 来进行混合（更多混合语义见本章第 6 节）。这个命令在设置混合因子的同时也开启了混合模式。Blend 命令设置混合因子的同时，Unity 会自动帮我们开启混合模式。</p><p>我们把源颜色的混合因子 SrcFactor 设为 SrcAlpha，目标颜色的混合因子 DstFactor 设为 OneMinusSrcAlpha，那么混合后的新颜色是：</p><script type="math/tex; mode=display">DstColor_{new} = SrcAlpha \times SrcColor + (1-SrcAlpha) \times DstColor_{old}</script><p>Src 前缀即 source，Dst 前缀即 destination。OneMinusSrcAlpha （字面意思）就是对应 1 - SrcAlpha。</p><h3 id="实践-5"><a href="#实践-5" class="headerlink" title="实践"></a>实践</h3><p><strong><em>1. 准备工作</em></strong><br>①新建名为 Scene_8_4 的场景，并去掉天空盒子；<br>②新建名为 AlphaBlendMat 的材质；<br>③新建名为 Chapter8-AlphaBlend 的 Shader，并赋给上一步创建的材质；<br>④在场景中创建一个立方体，将第二步创建的材质赋给它；<br>⑤保存场景。</p><p><strong><em>2. 编写 Shader</em></strong>  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 8/Alpha Blend&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Main Tint&quot;</span>, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Main Tex&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _AlphaScale (<span class="string">&quot;Alpha Scale&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span> <span class="comment">// 用于在透明纹理的基础上控制整体的透明度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 透明度混合常用的 3 个标签</span></span><br><span class="line">        Tags &#123;</span><br><span class="line">            <span class="comment">// 将渲染队列修改为透明混合队列 Transparent</span></span><br><span class="line">            <span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span></span><br><span class="line">            <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;True&quot;</span></span><br><span class="line">            <span class="comment">// 将当前 Shader 归入提前定义的组， Transparent 组。用来指明该 Shader 是一个使用了透明度混合的 Shader</span></span><br><span class="line">            <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Transparent&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; <span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭深度写入</span></span><br><span class="line">            ZWrite Off</span><br><span class="line">            <span class="comment">// 将源颜色（该片元着色器产生的颜色）的混合因子设为 SrcAlpha</span></span><br><span class="line">            <span class="comment">// 将目标颜色（已存在颜色缓冲中的颜色）的混合因子设为 OneMinusSrcAlpha</span></span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lighting.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            fixed _AlphaScale;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f <span class="title function_">vert</span> <span class="params">(a2v v)</span></span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 <span class="title function_">frag</span><span class="params">(v2f i)</span> : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">                fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里移除了透明度测试的代码</span></span><br><span class="line"></span><br><span class="line">                fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(<span class="number">0</span>, dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在返回值中设置透明通道</span></span><br><span class="line">                <span class="keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改回调的 Shader</span></span><br><span class="line">    Fallback <span class="string">&quot;Transparent/VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的 Alpha Scale 参数下的半透明效果如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/11/21/Xz57i9gSQTWs2PG.jpg" width = "70%" height = "70%" alt="图29- 随着 Alpha Scale 参数的增大，模型变得越来越透明"/></div><p>之前解释过由于关闭深度写入带来的各自问题，即当模型本身有复杂的遮挡关系或是包含了复杂的非凸网格时，会因为排除错误而导致错误的透明效果。下图给出了使用上面的 Shader 渲染 Knot 模型出现的问题：  </p><div  align="center">  <img src="https://s2.loli.net/2023/11/21/nUf5Yat6L21Qdgs.jpg" width = "30%" height = "30%" alt="图30- 当模型网格之间有互相交叉的结构时，往往会得到错误的半透明效果"/></div><p>这都是由于关闭了深度写入，无法对模型进行像素级别的深度排序。对此，可以通过分割网格或者重新利用深度写入，从而让模型可以像半透明模型一样淡入淡出。</p><h2 id="开启深度写入的半透明效果"><a href="#开启深度写入的半透明效果" class="headerlink" title="开启深度写入的半透明效果"></a>开启深度写入的半透明效果</h2><p>为了解决上面描述的问题，一种解决办法是<strong>使用两个 Pass</strong> 来渲染模型：第一个 Pass 开启深度写入，但不输出颜色，仅仅是为了把模型的深度值写入深度缓冲；第二个 Pass 进行正常的透明度混合，由于上一个 Pass 已经得到了逐像素的正确的深度值，该 Pass 就可以按照像素级别的深度排序进行透明渲染。缺点就是 Pass 多了影响性能。</p><h3 id="实践-6"><a href="#实践-6" class="headerlink" title="实践"></a>实践</h3><p><strong><em>1. 准备工作</em></strong><br>①新建名为 Scene_8_5 的场景，并关闭天空盒子；<br>②新建名为 AlphaBlendZWriteMat 材质；<br>③新建名为 Chapter8-AlphaBlendZWrite 的 Shader，并赋给上一步创建的材质；<br>④在场景中创建一个立方体，并将第二步创建的材质赋给它；<br>⑤保存场景。</p><p><strong><em>2. 编写 Shader</em></strong>  </p><p>这里的代码跟上一节的几乎一模一样，只需要在原来的 Pass 上面再增加一个新的 Pass 即可：  </p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 8/Alpha Blending ZWrite&quot;</span> &#123;</span><br><span class="line">    Properties &#123;...&#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 额外的 pass</span></span><br><span class="line">        Pass &#123;</span><br><span class="line">            ZWrite On</span><br><span class="line">            ColorMask <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass &#123;</span><br><span class="line">            <span class="comment">// 上一节的 pass</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新添加的 Pass 的目的仅仅是将模型的深度信息写入深度缓冲中，从而剔除被遮挡的片元。Pass 的第一行开启了深度写入。第二行，使用了新的渲染命令 ColorMask，在 ShaderLab 中，ColorMask 用于设置颜色通道的写掩码 write mask。语义为 <code>ColorMask RGB | A | 0 | 其他任何R、G、B、A的组合</code> ，当设为 0 时，表示该 Pass 不写入任何颜色通道。与上一节，效果对比如下：  </p><div  align="center">  <img src="https://s2.loli.net/2023/11/21/xj5VIvprgBOuo8S.png" width = "70%" height = "70%" alt="图31- 开启了深度写入的半透明效果（右图）和没有开启深度写入的效果（左图）的对比"/></div><p>可以看出有深度写入的模型内部有遮挡关系，而没有深度写入的模型看不出前后遮挡关系。但有深度写入的物体的内部没有半透明颜色的融合效果。</p><h2 id="ShaderLab-的混合命令"><a href="#ShaderLab-的混合命令" class="headerlink" title="ShaderLab 的混合命令"></a>ShaderLab 的混合命令</h2><p>混合和两个操作数有关：<strong>源颜色 source color</strong> 用 S 表示，指由片元着色器产生的颜色值；<strong>目标颜色 destination color</strong> 用 D 表示，指从颜色缓冲中读取到的颜色值。对它们进行混合后得到的<strong>输出颜色</strong>，用 O 表示，重新写入颜色缓冲中。需要注意，当谈及混合中的源颜色、目标颜色和输出颜色时，它们都包含了 RGBA 四个通道的值。</p><p>想要使用混合，我们必须首先开启它。在 Unity 中，当我们使用 Blend 命令时，除了设置混合状态外也开启了混合。但在其他图形 API 中需要手动开启，比如在 OpenGL 中，需要使用 glEnable(GL_BLEND) 来开启混合。</p><h3 id="混合等式和参数"><a href="#混合等式和参数" class="headerlink" title="混合等式和参数"></a>混合等式和参数</h3><p>混合是一个逐片元的操作，且是不可编程的，却是高度可配置的。我们可以设置混合时使用的运算操作、混合因子等来影响混合。</p><p>从两个操作数 S 和 D，得到输出颜色 O 的等式称为<strong>混合等式 blend equation</strong>。当进行混合时，我们需要使用两个混合等式：一个用于混合 RGB 通道，一个用于混合 A 通道。当设置混合状态时，实际上设置的就是混合等式中的<strong>操作</strong>和<strong>因子</strong>。默认情况下，混合等式使用的操作都是加操作，我们只需要再设置一下混合因子即可。由于需要两个等式，每个等式有两个因子，因此一共需要四个因子。</p><p><code>Blend SrcFactor DstFactor</code> 这个命令只提供了两个因子，意味着使用同样的混合因子来混合 RGB 通道和 A 通道，即：  </p><script type="math/tex; mode=display">O_{rgb} = SrcFactor \times S_{rgb} + DstFactor \times D_{rgb}</script><script type="math/tex; mode=display">O_{a} = SrcFactorA \times S_{a} + DstFactorA \times D_{a}</script><p>这些混合因子可以有以下值，下表给出了 ShaderLab 支持的几种混合因子：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">One</td><td style="text-align:left">因子为 1</td></tr><tr><td style="text-align:left">Zero</td><td style="text-align:left">因子为 0</td></tr><tr><td style="text-align:left">SrcColor</td><td style="text-align:left">因子为源颜色值。用于混合 RGB 时，使用 SrcColor 的 RGB 分量作为混合因子。用于混合 A 时，使用 SrcColor 的 A 分量作为混合因子</td></tr><tr><td style="text-align:left">SrcAlpha</td><td style="text-align:left">因子为源颜色的透明度值（A 通道）</td></tr><tr><td style="text-align:left">DstColor</td><td style="text-align:left">因子为目标颜色值。用于混合 RGB 时，使用 DstColor 的 RGB 分量作为混合因子。用于混合 A 时，使用 DstColor 的 A 分量作为混合因子</td></tr><tr><td style="text-align:left">DstAlpha</td><td style="text-align:left">因子为目标颜色的透明度值（A 通道）</td></tr><tr><td style="text-align:left">OneMinusSrcColor</td><td style="text-align:left">因子为（1-源颜色）。用于混合 RGB 时，使用计算结果的 RGB 分量作为混合因子。用于混合 A 时，使用计算结果的 A 分量作为混合因子</td></tr><tr><td style="text-align:left">OneMinusSrcAlpha</td><td style="text-align:left">因子为（1-源颜色的透明度）</td></tr><tr><td style="text-align:left">OneMinusDstColor</td><td style="text-align:left">因子为（1-目标颜色）。用于混合 RGB 时，使用计算结果的 RGB 分量作为混合因子。用于混合 A 时，使用计算结果的 A 分量作为混合因子</td></tr><tr><td style="text-align:left">OneMinusDstAlpha</td><td style="text-align:left">因子为（1-目标颜色的透明度）</td></tr></tbody></table></div><p>如果想使用不同的参数混合 RGB 通道和 A 通道，可以使用 <code>Blend SrcFactor DstFactor, Srcfactor DstFactorA</code> 指令。例如，下面的命令在混合后，输出颜色的透明值就是源颜色的透明值：<code>Blend SrcAlpha OneMinusSrcAlpha, One Zero</code></p><h3 id="混合操作"><a href="#混合操作" class="headerlink" title="混合操作"></a>混合操作</h3><p>上面涉及的两个混合等式中，都是加操作。若要使用其他混合操作，可以使用 ShaderLab 的 <code>BlendOp BlendOperation</code> 命令，即混合操作命令。下表给出了支持的混合操作：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Add</td><td style="text-align:left">将混合后的颜色相加，默认的混合操作。使用的混合等式是： <br> <script type="math/tex">O_{rgb} = SrcFactor \times S_{rgb} + DstFactor \times D_{rgb}</script> <br> <script type="math/tex">O_{a} = SrcFactorA \times S_{a} + DstFactorA \times D_{a}</script></td></tr><tr><td style="text-align:left">Sub</td><td style="text-align:left">用混合后的源颜色减去混合后的目标颜色。使用的混合等式是： <br> <script type="math/tex">O_{rgb} = SrcFactor \times S_{rgb} - DstFactor \times D_{rgb}</script> <br> <script type="math/tex">O_{a} = SrcFactorA \times S_{a} - DstFactorA \times D_{a}</script></td></tr><tr><td style="text-align:left">RevSub</td><td style="text-align:left">用混合后的目标颜色减去混合后的源颜色。使用的混合等式是： <br> <script type="math/tex">O_{rgb} = DstFactor \times D_{rgb} - SrcFactor \times S_{rgb}</script> <br> <script type="math/tex">O_{a} = DstFactorA \times D_{a} - SrcFactorA \times S_{a}</script></td></tr><tr><td style="text-align:left">Min</td><td style="text-align:left">使用源颜色和目标颜色中较小的值，是逐分量比较的。使用的混合等式是： <br> <script type="math/tex">O_{rgba} = (min(S_r, D_r),min(S_g, D_g),min(S_b, D_b),min(S_a, D_a))</script></td></tr><tr><td style="text-align:left">Max</td><td style="text-align:left">使用源颜色和目标颜色中较大的值，是逐分量比较的。使用的混合等式是： <br> <script type="math/tex">O_{rgba} = (max(S_r, D_r),max(S_g, D_g),max(S_b, D_b),max(S_a, D_a))</script></td></tr><tr><td style="text-align:left">其他逻辑操作</td><td style="text-align:left">仅在 DirectX 11.1 中支持</td></tr></tbody></table></div><p>混合操作命令通常是与混合因子命令一起工作的。但当使用 Min 或 Max 混合操作时，混合因子实际上不起任何作用，它们仅会判断原始的源颜色和目标颜色之间的比较结果。</p><h3 id="常见的混合类型"><a href="#常见的混合类型" class="headerlink" title="常见的混合类型"></a>常见的混合类型</h3><p>通过混合操作和混合因子命令的组合，可以得到一些类似 Photoshop 混合模式中的混合效果：  </p><pre><code>// 正常（Normal），即透明度混合Blend SrcAlpha OneMinusSrcAlpha// 柔和相加（Soft Additive）Blend OneMinusDstColor One// 正片叠底（Multiply），即相乘Blend DstColor Zero// 两倍相乘（2x Multiply）Blend DstColor SrcColor// 变暗（Darken）BlendOp MinBlend One One// 变亮（Lighten）BlendOp MaxBlend One One// 滤色（Screen）Blend OneMinusDstColor One// 等同于Blend One OneMinusSrcColor// 线性减淡（Linear Dodge）Blend One One</code></pre><div  align="center">  <img src="https://s2.loli.net/2023/11/22/ikua92s7pQZ3Mbf.jpg" width = "70%" height = "70%" alt="图32- 不同混合状态设置得到的效果"/></div><p>需要注意的是，虽然上面使用 Min 和 Max 混合操作时仍然设置了混合因子，但实际上它们并不会对结果产生影响。另一点是，虽然上面有些混合模式没有设置混合操作的种类，但是默认是加法操作，相当于设置了 <code>BlendOp Add</code>。</p><h2 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h2><p>在前面实现的透明效果中，无论透明度测试还是混合，都无法观察到正方体内部及其背部的形状。这是因为，默认情况下，渲染引擎剔除了物体背面（相对于摄像机的方向）的渲染图元。如果想要得到双面渲染的效果，可以使用 <strong>Cull</strong> 指令来控制需要剔除哪个面的渲染图元。在 Unity 中，Cull 指令的语法如下：  </p><pre><code>Cull Back | Front | Off</code></pre><p>如果设置为 Back，背对摄像机的渲染图元不会被渲染，这是默认的剔除状态；如果设置为 Front，朝向摄像机的渲染图元不会被渲染；如果设置为 Off，会关闭剔除功能。</p><h3 id="透明度测试的双面渲染"><a href="#透明度测试的双面渲染" class="headerlink" title="透明度测试的双面渲染"></a>透明度测试的双面渲染</h3><p>只要在 Pass 的渲染设置中使用 Cull 指令来关闭剔除即可。新建名为 Scene_8_7_1 的场景，并去掉天空盒子；新建名为 AlphaTestBothSidedMat 的材质；新建名为 Chapter8-AlphaTestBothSided 的 Shader，赋给上一步创建的材质；在场景中创建一个立方体，将第二步的材质赋给它。代码和 Chapter8-AlphaTest 几乎完全一样，只需添加一行代码：  </p><pre><code>Pass &#123;    Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;    // 关闭剔除功能    Cull Off</code></pre><p>效果如下图：  </p><div  align="center">  <img src="https://s2.loli.net/2023/11/22/S5JLAgPENwdWqy8.png" width = "70%" height = "70%" alt="图33- 双面渲染的透明度测试的物体"/></div><h3 id="透明度混合的双面渲染"><a href="#透明度混合的双面渲染" class="headerlink" title="透明度混合的双面渲染"></a>透明度混合的双面渲染</h3><p>透明度混合实现双面渲染会更复杂，因为透明度混合要关闭深度写入，直接关闭剔除功能，无法保证同一个物体的正面和背面图元的渲染顺序，就可能得到错误的半透明效果。</p><p>为此，需要把双面渲染的工作分为两个 Pass，第一个 Pass 只渲染背面，第二个 Pass 只渲染正面，Unity 会顺序执行 Subshader 中的各个 Pass，可以保证背面在正面被渲染之前渲染。</p><p>新建名为 Scene_8_7_2 的场景；新建名为 AlphaBlendBothSidedMat 的材质；新建名为 Chapter8-AlphaBlendBothSided 的 shader，并赋给上一步创建的材质；在场景中创建一个立方体，将第二步创建的材质赋给它；代码和 Chapter8-AlphaBlend 相比较，只要做出两个改动：<br>①复制原 Pass 的代码，得到另一个 Pass；<br>②在两个 Pass 中分别使用 Cull 指令剔除不同朝向的渲染图元：</p><figure class="highlight c"><figcaption><span>C for Graphics</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chapter 8/Alpha Blend With Both Side&quot;</span> &#123;</span><br><span class="line">    Properties &#123;...&#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123;...&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个 Pass 只渲染背面</span></span><br><span class="line">            Cull Front</span><br><span class="line"></span><br><span class="line">            <span class="comment">//和之前一样的代码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass &#123;</span><br><span class="line">            Tags &#123;...&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二个 Pass 只渲染前面</span></span><br><span class="line">            Cull Back</span><br><span class="line"></span><br><span class="line">            <span class="comment">//和之前一样的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：  </p><div  align="center">  <img src="https://s2.loli.net/2023/11/22/8kSUniB62ZGx5EM.png" width = "70%" height = "70%" alt="图34- 双面渲染的透明度混合的物体"/></div>]]></content>
      
      
      <categories>
          
          <category> unity </category>
          
          <category> unity shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> unity </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Unity Shader入门精要》读书笔记（一）</title>
      <link href="/2023/09/15/2023-09-15-UnityShader1/"/>
      <url>/2023/09/15/2023-09-15-UnityShader1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本读书笔记为基础阶段，主要内容为渲染管线介绍、Unity Shader 介绍以及 Shader 的数学基础。<br>读书笔记是对知识的记录与总结，但是对比较熟悉的内容不会再行描述。</p></blockquote><h1 id="第一章-渲染管线-Rendering-Pipeline"><a href="#第一章-渲染管线-Rendering-Pipeline" class="headerlink" title="第一章 渲染管线 Rendering Pipeline"></a>第一章 渲染管线 Rendering Pipeline</h1><h2 id="什么是渲染管线"><a href="#什么是渲染管线" class="headerlink" title="什么是渲染管线"></a>什么是渲染管线</h2><p><strong>渲染管线</strong>也称为<strong>渲染流水线</strong>，是将三维场景模型转换到屏幕像素空间输出的过程。渲染流程可分为三个阶段：<strong>应用阶段</strong>、<strong>几何阶段</strong>、<strong>光栅化阶段</strong>：<br><strong>①应用阶段</strong>：这是一个由开发者完全控制的阶段，在这一阶段将进行数据准备，并通过 CPU 向 GPU 输送数据，例如顶点数据、摄像机位置、视锥体数据、场景模型数据、光源等等；此外，为了提高渲染性能，还会对这些数据进行处理，比如<strong>剔除 culling</strong> 不可见物体；最后还要设置每个模型的渲染状态，这些渲染状态包括但不限于所使用的材质、纹理、shader等。这一阶段最重要的输出是渲染所需的几何信息，即<strong>渲染图元 rendering primitives</strong>，通俗来讲渲染图元可以是点、线、面等；<br><strong>②几何阶段</strong>：几何阶段运行在 GPU 中，几何阶段和每个渲染图元打交道。几何阶段最重要的任务是将顶点坐标变换到屏幕空间中，再交给光栅器进行处理。通过对输入的渲染图元进行处理后，将输出屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息，传递给下个阶段；<br><strong>③光栅化阶段</strong>：光栅化阶段运行在 GPU 中，其主要任务是决定每个渲染图元中哪些像素应该被绘制在屏幕上，它需要对上一阶段得到的逐顶点数据进行插值，然后进行逐像素处理。</p><h2 id="CPU-和-GPU-之间的通信（应用阶段）"><a href="#CPU-和-GPU-之间的通信（应用阶段）" class="headerlink" title="CPU 和 GPU 之间的通信（应用阶段）"></a>CPU 和 GPU 之间的通信（应用阶段）</h2><p>渲染管线的起点是 CPU ，应用阶段可分为以下三个阶段：<br><strong>①把数据加载到显存</strong>：所有渲染所需的数据都需要从硬盘 Hard Disk Drive, HDD 中加载到系统内存 Random Access Memory, RAM 中。然后网格和纹理等数据又被加载到显卡上的存储空间，即显存 Video Random Access Memory, VRAM 中。大多数显卡没有直接访问 RAM 的能力，将数据加载到显存中使 GPU 能更快的访问这些数据。当把数据加载到显存后，内存中的数据便可以释放了，但对于一些还需要使用的数据则需要继续保留在内存中，如 CPU 需要网格数据进行碰撞检测；<br><strong>②设置渲染状态</strong>：渲染状态的一个通俗解释就是，定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器 Vertex Shader /片段着色器 Fragment Shader、光源属性、材质等。<br><strong>③调用 Draw Call</strong>：当所有的数据准备好后，CPU 就需要调用一个渲染指令告诉 GPU，按照上述设置进行渲染，这个渲染命令就是 <strong>Draw Call</strong>。Draw Call 命令仅仅会指向一个需要被渲染的图元列表，而不包含任何材质信息，因为这些信息已经在上一个阶段中完成。给定 Draw Call 后 GPU 就会根据渲染状态和所有输入的顶点数据来进行计算，并输出到显示设备中，所执行的操作便是下述 GPU 渲染管线的内容。  </p><h2 id="GPU-渲染管线（几何阶段和光栅化阶段）"><a href="#GPU-渲染管线（几何阶段和光栅化阶段）" class="headerlink" title="GPU 渲染管线（几何阶段和光栅化阶段）"></a>GPU 渲染管线（几何阶段和光栅化阶段）</h2><div  align="center">  <img src="https://s2.loli.net/2023/09/15/BkGnZ46bTAVrR1J.png" width = "60%" height = "60%" alt="图1- GPU 渲染管线。颜色表示了不同阶段的可配置性或可编程性：绿色表示该流水线阶段是完全可编程控制的，黄色表示该流水线阶段可以配置但不是可编程的，蓝色表示该流水线阶段是由 GPU 固定实现的，开发者没有任何控制权。实线表示该 shader 必须由开发者编程实现，虚线表示该 Shader 是可选的。"/></div><h3 id="顶点着色器-Vertex-Shader"><a href="#顶点着色器-Vertex-Shader" class="headerlink" title="顶点着色器 Vertex Shader"></a>顶点着色器 Vertex Shader</h3><p>顶点着色器的处理单位是顶点，即对于输入的每个顶点都会调用一次顶点着色器。顶点着色器本身无法得到顶点与顶点之间的关系，例如无法得到两个顶点是否属于同一个三角网格，因为这样的独立性，可以优化处理每一个顶点。  </p><p>顶点着色器的两个任务是<strong>坐标变换</strong>和<strong>逐顶点光照</strong>：<br><strong>①坐标变换，即将顶点坐标从模型空间转换到齐次裁剪空间。</strong>当顶点坐标被变换到齐次裁剪空间后，通常再由硬件做透视除法，最终得到<strong>归一化的设备坐标 Normalized Device Coordinates, NDC</strong>。OpenGL（Unity 使用的 NDC）的 z 分量范围在[-1, 1]之间，而在 DirectX 中，NDC 的 z 分量范围是[0, 1]。</p><blockquote><p>内容扩展：<strong>MVP 矩阵</strong>是<strong>模型 Model</strong>、<strong>观察 View</strong>、<strong>投影 Projection</strong> 三个矩阵的合称。这三个矩阵代表了物体顶点坐标从局部空间转换到裁剪空间，最后以屏幕坐标的形式结束。模型矩阵表示顶点坐标从物体自身局部空间 Local Space 转换到世界空间 World Space；观察矩阵表示从世界空间到观察空间 View Space ；投影矩阵表示从观察空间到裁剪空间 Clip Space。需要注意的是：投影矩阵并不代表这一步矩阵乘法过程中包含了投影，而是在下一步通过透视除法将 xyz 分量除以 w 才会发生投影。</p></blockquote><p><strong>②逐顶点光照 per-vertex lighting</strong>，也被称为<strong>高洛德着色 Gouraud Shading</strong>。在逐顶点光照中，会在每个顶点上计算光照，然后会在渲染图元内部进行线性插值，最后输出成像素颜色。</p><p>但顶点光照效果通常不尽人意，因此通常在片元着色器中执行逐片元光照计算。顶点着色器可以有不同的输出方式。最常见的输出路径是经光栅化后交给片元着色器进行处理。而在现代的 Shader Model 中，还可以把数据发送给曲面细分着色器或几何着色器。</p><h3 id="曲面细分着色器-Tessellation-Shader"><a href="#曲面细分着色器-Tessellation-Shader" class="headerlink" title="曲面细分着色器 Tessellation Shader"></a>曲面细分着色器 Tessellation Shader</h3><p>曲面细分着色器是一个可选的阶段。曲面细分是利用镶嵌化处理技术对三角形进行细分，以此来增加物体表面的三角面数量。如果为这些细分的顶点再准备一些位置信息，有助于展现一个细节更加丰富的模型，这也是<strong>贴图置换 Displacement Mapping</strong> 的基本思路。</p><h3 id="几何着色器-Geometry-Shader"><a href="#几何着色器-Geometry-Shader" class="headerlink" title="几何着色器 Geometry Shader"></a>几何着色器 Geometry Shader</h3><p>几何着色器也是一个可选的阶段。顶点着色器以顶点数据作为输入，而几何着色器则以完整的图元 Primitive 作为输入数据。与顶点着色器不能销毁或创建顶点不同，几何着色器的主要亮点就是可以创建或销毁几何图元，此功能让 GPU 可以实现一些有趣的效果。例如，根据输入图元类型扩展为一个或更多其他类型的图元，或者不输出任何图元。需要注意的是，几何着色器的输出图元不一定和输入图元相同。几何着色器的一个拿手好戏就是将一个点扩展为一个四边形(即两个三角形)。</p><h3 id="裁剪-Clipping"><a href="#裁剪-Clipping" class="headerlink" title="裁剪 Clipping"></a>裁剪 Clipping</h3><p>裁剪操作就是将相机看不到的物体、顶点剔除，使其不被下一阶段处理。只有当图元完全位于视锥体内时，才会将它送到下一阶段，对于部分位于视锥体内的图元，外部的顶点将被剔除掉。由于已经知道在 NDC 下的顶点位置，即顶点位置在一个立方体内，因此裁剪就变得简单：只需要将图元裁剪到单位立方体内，只有在单位立方体的图元才需要被继续处理。因此，完全在单位立方体外部的图元被舍弃，完全在单位立方体内部的图元将被保留。和单位立方体相交的图元会被裁剪，新的顶点会被生成，原来在外部的顶点会被舍弃。裁剪这一步骤是硬件的固定操作，因此是不可编程的，但是可以自定义一个裁剪操作来配置。</p><h3 id="屏幕映射-Screen-Mapping"><a href="#屏幕映射-Screen-Mapping" class="headerlink" title="屏幕映射 Screen Mapping"></a>屏幕映射 Screen Mapping</h3><p>主要是<strong>视口变换 Viewport Transformation</strong>。这一步输入的坐标仍是三维坐标（范围在单位立方体内），屏幕映射的任务就是将每个图元的 x、y 值变换到<strong>屏幕坐标系 Screen Coordinates</strong>，屏幕坐标系是一个二维坐标系。由于输入坐标范围在[-1, 1]，因此这是一个缩放到屏幕分辨率大小的过程。对于输入的坐标 z 值不做任何处理，实际上屏幕坐标系和 z 坐标一起构成<strong>窗口坐标系 Window Coordinates</strong>，这些值会被一起传递到光栅化阶段。</p><p>OpenGL 和 DirectX 的屏幕坐标系存在差异：OpenGL 把屏幕的左下角当成最小的窗口坐标值，而 DirectX 则定义了屏幕的左上角为最小的窗口坐标值。</p><h3 id="三角形设置-Triangle-Setup"><a href="#三角形设置-Triangle-Setup" class="headerlink" title="三角形设置 Triangle Setup"></a>三角形设置 Triangle Setup</h3><p>由这一步进入光栅化阶段。上个阶段的输出信息包括屏幕坐标系下的顶点位置以及深度值（z 坐标）、法线方向、视角方向等。光栅化阶段的两个重要目标是<strong>计算每个图元覆盖了那些像素</strong>，以及<strong>为这些像素计算颜色</strong>。</p><p>光栅化第的第一个流水线阶段是<strong>三角形设置</strong>，这个阶段会计算光栅化一个三角形网格所需的信息。上一阶段输出的都是三角网格的顶点，但如果要得到整个三角形网格对像素的覆盖情况，就必须计算每条边上的像素坐标。为了能计算边界像素的坐标信息，就需要得到三角形边界的表示方式。这样一个计算三角网格表示数据的过程就叫做三角形设置。它的输出是为下一阶段做准备。</p><h3 id="三角形遍历-Triangle-Traversal"><a href="#三角形遍历-Triangle-Traversal" class="headerlink" title="三角形遍历 Triangle Traversal"></a>三角形遍历 Triangle Traversal</h3><p>该阶段会检查像素是否被三角网格覆盖，被覆盖则生成一个<strong>片元 fragment</strong>，这个阶段也被称为<strong>扫描变换 Scan Conversion</strong>。</p><div  align="center">  <img src="https://s2.loli.net/2023/09/18/njUJblGaDHO9is4.png" width = "60%" height = "60%" alt="图2- 三角形遍历的过程。根据几何阶段输出的顶点信息，最终得到该三角网格覆盖的像素位置。对应像素会生成一个片元，而片元中的状态是对三个顶点的信息进行插值得到的。例如，图中三个顶点的深度进行插值得到其重心位置对应的片元的深度值为-10.0。"/></div><p>需要注意的是，一个片元并不是真正意义上的像素，而是很多状态的集合，这些状态用于计算每个像素的最终颜色，包括屏幕坐标、深度、法线、纹理坐标等，最后需要一系列测试才会成为像素。</p><h3 id="片元着色器-Fragment-Shader"><a href="#片元着色器-Fragment-Shader" class="headerlink" title="片元着色器 Fragment Shader"></a>片元着色器 Fragment Shader</h3><p><strong>片元着色器</strong>是一个非常重要的可编程着色器阶段，在 DirectX 中，片元着色器被称为<strong>像素着色器 Pixel Shader</strong>。</p><p>前面的光栅化阶段实际上并不会影响屏幕上每个像素的颜色值，而是会产生一系列的数据信息，用来表述一个三角网格是怎样覆盖每个像素的，而片元就负责存储这样一系列信息，真正会对像素产生影响的是下一个流水线阶段：<strong>逐片元操作 Per-Fragment Operations</strong>。</p><p>片元着色器的输入是上一个阶段对顶点信息进行插值的结果，是根据从顶点着色器输出的数据插值得到的。而它的输出是像素颜色值。但是至此，屏幕具体的像素都没有任何变化，这些都是预备的数据，直到逐片元操作。</p><p>这一阶段可以完成很多重要的渲染技术，其中最重要的技术有纹理采样。为了在片元着色器中进行纹理采样，通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网格的三个顶点对应的纹理坐标进行插值后，就可以得到其覆盖的片元的纹理坐标了。</p><div  align="center">  <img src="https://s2.loli.net/2023/09/18/VLsdUI7utyM5boC.png" width = "60%" height = "60%" alt="图3- 根据上一步插值后的片元信息，片元着色器计算该片元的输出颜色。"/></div><h3 id="逐片元操作-Per-Fragment-Operations"><a href="#逐片元操作-Per-Fragment-Operations" class="headerlink" title="逐片元操作 Per-Fragment Operations"></a>逐片元操作 Per-Fragment Operations</h3><p>逐片元操作是渲染管线的最后一个阶段。<strong>逐片元操作</strong>是 OpenGL 的说法，DirectX 称为<strong>输出合并阶段 Output-Merger</strong>。</p><p>这一阶段有几个主要任务：<br>①决定每个片元的可见性，这涉及到很多测试功能，例如模板测试、深度测试；<br>②如果一个片元通过了所有的测试，就需要把这些片元的颜色值和已经存储在颜色缓冲区中的颜色值进行混合。</p><blockquote><p>逐片元操作阶段是高度可配置性的，测试顺序并不是唯一的，不同的图形接口的实现细节也不太一样。这里给出两个最基本的测试：模板测试和深度测试的实现过程。</p></blockquote><p><strong>模板测试 Stencil Test</strong> 与之相关的是模板缓冲 Stencil Buffer。模板测试通常用来限制渲染的区域，渲染阴影，轮廓渲染等。如果开启了模板测试，GPU 会首先读取（使用读取掩码）模板缓冲区中该片元位置的模板值，然后将该值和读取（使用读取掩码）到的参考值进行比较，这个比较函数可以是由开发者指定的，例如，小于时舍弃该片元，或者大于等于时舍弃该片元。模板测试是高度可配置的，无论一个片元有没有经过模板测试，都可以根据模板测试和下面的深度测试结果来修改模板缓冲区。</p><blockquote><p>Stencil 的英英释义：device that has a sheet perforated with printing through which ink or paint can pass to create a printed pattern.</p></blockquote><p><strong>深度测试 Depth Test</strong> 同样是可以高度配置的。如果开启了深度测试，GPU 会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较，这个比较函数也是可以由开发者设置，通常这个值是小于等于的关系，即若这个片元的深度值大于等于当前深度缓冲区中的值，就舍弃它。因为我们总想显示出离相机最近的物体(不包括透明/半透明)，而那些被遮挡的就不需要出现在屏幕。如果一个片元通过了测试，那么开发者还可以指定是否要用这个片元的深度值覆盖所有的深度值。</p><p><strong>混合 Blend</strong> 如果一个片元通过了所有测试，就需要解决是否需要混合操作。渲染的过程是一个物体接着一个物体画到屏幕前。每一个像素的颜色信息被存储在一个名为颜色缓冲的地方。因此当我们执行这次渲染时，颜色缓冲中往往已经有了上次渲染的颜色结果。所以是使用这次渲染得到的颜色完全覆盖掉之前的结果，还是进行其他处理？对于不透明的物体，开发者要关闭混合操作，这样片元着色器计算出的颜色值就会直接覆盖掉颜色缓冲区中的像素值。但对于半透明物体，就需要使用混合操作。</p><blockquote><p>不透明的物体当然是看到最近的，那么透明的呢？需要进行片元着色器中的颜色和颜色缓冲器的颜色混合。举个例子，一个玻璃放在眼前，我既可以看到玻璃，又可以看到玻璃之后的，实际看到的是这两个颜色的混合。</p></blockquote><p>开发者可以选择开启/关闭混合功能。如果没有开启混合，就会直接使用片元的颜色覆盖掉颜色缓冲区中的颜色。如果开启了混合，GPU 会取出片元着色器得到的颜色（<strong>源颜色</strong>）和颜色缓冲区存在的颜色（<strong>目标颜色</strong>），之后按照设定的函数进行混合，这个混合函数通常和透明度通道息息相关，例如可以根据透明通道的值进行相加、相减、相乘等。</p><blockquote><p>上面给出的测试顺序并不是唯一的。逻辑上来说测试是在片元着色器之后进行，但想充分提高 GPU 性能，会尽可能的在执行片元着色器之前就执行测试操作，从而避免将不需要渲染的片元流入到后续的运算中。Unity 中深度测试在片元着色器前，这称为 Early-Z 技术。但将测试提前可能会与片元着色器中的一些操作冲突，如透明度测试，后面章节会提到。</p></blockquote><p>渲染中的图元必定是不能显示的，就像舞台更改背景，背景准备完毕，红布一拉，舞台展现在众人眼前。GPU 会使用<strong>双重缓冲 Double Buffering</strong> 的策略。对场景的渲染在幕后发生，即在<strong>后置缓冲 Back Buffer</strong> 中。<strong>前置缓冲 Front Buffer</strong> 中的内容就是之前显示在屏幕上的图像。GPU 不断交换两者内容，保证看到的都是连续的画面。</p><h2 id="一些专业术语"><a href="#一些专业术语" class="headerlink" title="一些专业术语"></a>一些专业术语</h2><h3 id="图形-API"><a href="#图形-API" class="headerlink" title="图形 API"></a>图形 API</h3><p>OpenGL 和 DirectX 这些图像应用编程接口，架起了上层应用程序和底层 GPU 的沟通桥梁。一个应用程序向这些接口发送渲染命令，即 Draw Call，而这些接口会依次向显卡驱动发生渲染命令，显卡驱动把 OpenGL 或者 DirectX 的函数调用翻译成 GPU 能听懂的语言，同时把数据转换为 GPU 所支持的格式。</p><h3 id="着色语言-Shading-Language"><a href="#着色语言-Shading-Language" class="headerlink" title="着色语言 Shading Language"></a>着色语言 Shading Language</h3><p>在可编程管线出现前，要编写着色器，需要汇编语言。后来出现了相对更“高级”的着色语言，这些语言会被编译为汇编语言，也被称为中间语言 Intermediate Language, IL。这些中间语言再交给显卡驱动来翻译成真正的机器语言，即 GPU 可以理解的语言。</p><p>常见的着色语言有 DirectX 的 <strong>HLSL</strong>，High Level Shading Language；OpenGL 的 <strong>GLSL</strong>，OpenGL Shading Language；NVIDIA 的 <strong>Cg</strong>，C for Graphic。<br>① GLSL 的优点在于它的跨平台性，它可以在 Windows、Linux、Mac 甚至移动平台等多种平台上工作，但这种跨平台性是由于 OpenGL 没有提供着色器编译器，而是由显卡驱动来完成着色器的编译工作。即 GLSL 是依赖硬件，而非操作系统层级的。但这也意味着 GLSL 的编译结果将取决于硬件供应商，这可能造成编译结果不一致的情况。比如 NVIDIA、ATI 对 GLSL 的实现不尽相同。<br>② HLSL 由微软控制着着色器的编译，就算使用了不同的硬件，同一个着色器的编译结果也是一样的。但支持 HSLS 的平台相对较少，几乎完全是微软自己的产品，如Windows、Xbox 360等。这是因为在其他平台上没有可以编译 HSLS 的编译器。<br>③ Cg 则是真正意义上的跨平台。它会根据平台的不同，编译成相应的中间语言。Cg 语言的跨平台性很大原因取决于与微软的合作哦，这也导致 Cg 语言的语法与 HLSL 非常像，Cg 语言可以无缝移植成 HLSL 代码。但缺点是可能无法完全发挥出 OpenGL 的最新特性。</p><h3 id="Draw-Call"><a href="#Draw-Call" class="headerlink" title="Draw Call"></a>Draw Call</h3><p>Draw Call 就是 CPU 调用图像编程接口，如 OpenGL 中的 glDrawElements 命令或者 DirectX 中的 DrawIndexedPrimitive 命令，以命令 GPU 进行渲染操作。</p><p>Draw Call 中造成性能问题的是 CPU，而非 GPU。</p><p>① CPU 和 GPU 并行工作<br>若 CPU 需要等待 GPU 完成上一个渲染任务才能再次发送渲染命令，会造成效率低下。为了并行工作，使用了<strong>命令缓冲区 Command Buffer</strong>：命令缓冲区包含一个命令队列，CPU 通过图像编程接口向命令缓冲区中添加命令，而 GPU 从中读取命令并执行，从而使它们相互独立工作。命令缓冲区的命令有很多种类，而 Draw Call 就是其中的一种。</p><p>②为什么 Draw Call 多了会影响帧率？<br>CPU 每次调用 Draw Call 都要经过一系列工作，多次调用 Draw Call 会进行许多重复性操作。如果 Draw Call 太多，CPU 会把大量时间花费在提交 Draw Call 上，造成 CPU 的过载。</p><p>③如何减少 Draw Call<br>方法很多，其一就是<strong>批处理 Batching</strong> 方法：将许多小的 Draw Call 合并成一个大的 Draw Call。由于要在 CPU 的内存里合并网格，合并的过程很耗时，所以批处理技术跟适用于静态物体。</p><p>在游戏开发中，为减少 Draw Call 的开销，尽量避免使用大量很小的网格，若不可避免考虑合并它们；避免使用过多材质，考虑空用材质。</p><h3 id="固定渲染管线"><a href="#固定渲染管线" class="headerlink" title="固定渲染管线"></a>固定渲染管线</h3><p><strong>固定函数的流水线 Fixed-Function Pipeline，简称固定管线</strong>。通常指在较旧的 CPU 上实现的渲染流水线。这种流水线只给开发者提供一些配置操作，但开发者没有完全控制权。随着时代发展，可编程渲染管线应运而生。</p><h1 id="第二章-Unity-Shader"><a href="#第二章-Unity-Shader" class="headerlink" title="第二章 Unity Shader"></a>第二章 Unity Shader</h1><p>在没有 Unity 这类编辑器的情况下，若想对模型设置渲染状态，需要大量复杂初始化的代码。Unity 提供了能够让开发者管理着色器代码以及渲染设置（比如开启关闭混合、深度测试、设置渲染顺序等）的地方，也就是 Unity Shader。</p><h2 id="Material-和-Unity-Shader"><a href="#Material-和-Unity-Shader" class="headerlink" title="Material 和 Unity Shader"></a>Material 和 Unity Shader</h2><blockquote><p>材质和着色器老是傻傻分不清，材质可以理解为物体的不同物理属性，比如颜色、纹理和反射率等等，而着色器根据这些数据渲染。</p></blockquote><p>在 Unity 中需要配合使用<strong>材质 Material 和 Unity Shader</strong> 来达到需要的效果。首先创建需要的 Unity Shader 和材质，然后把 Unity Shader 赋给材质，并在材质面板上调整属性（如使用的纹理、漫反射系数等）。最后将材质赋给相应模型。Unity Shader 定义了渲染所需代码、属性和指令，而材质允许我们调节这些属性。</p><p>① Unity 中的材质<br>Unity 中材质需要结合一个 GameObject 的 Mesh 或者 Particle Systems 组件来工作。默认情况下新建的材质使用 Unity 内置的 Standard Shader，是一种基于物理渲染的着色器，见后面章节。</p><p>② Unity 中的 Shader<br>Unity 一共提供了五种 Unity Shader 模板：<br>&emsp;&emsp; - Standard Surface Shader：包含了标准光照模型的表面着色器模板；<br>&emsp;&emsp; - Unlit Shader：不包含光照（但包含雾效）的基本的顶点/片元着色器；<br>&emsp;&emsp; - Image Effect Shader：为我们实现各种屏幕后处理效果提供了一个基础模版；<br>&emsp;&emsp; - Compare Shader：产生一种特殊的shader文件，利用GPU的并行性来进行一些与常规渲染流水线无关的计算；<br>&emsp;&emsp; - Ray Tracing Shader：支持光追的着色器。</p><p>Unity Shader 本质上就是一个文本文件。Unity Shader 有导入设置面板，在 project 里点击任意 Unity Shader 可在 Inspector 面板中看到。</p><table><tr><td><img src='https://s2.loli.net/2023/09/19/K4aG83wSf5PVhDJ.png' width="300" alt="图4- Unity Shader导入设置面板"></td><td><img src='https://s2.loli.net/2023/09/19/WQBKVwqGFHhfpvU.png' width="300" alt="图5- Compile and show code下拉列表"></td></tr></table><p>可以在 Default Map 中指定该 Unity Shader 使用的默认纹理。在下方的面板中，Unity 会显示出和该 Unity Shader 相关的信息，例如它是否是一个表面着色器 Surface Shader、是否是一个固定函数着色器 Fixed Function Shader，还有些信息和标签设置有关，如是否会投射阴影、使用的渲染队列、LOD 值等。</p><p>对于表面着色器，点击 Show generated code 可以打开一个新的文件，该文件里将显示 Unity 在背后为该表面着色器生成的顶点/片元着色器。若该 Unity Shader 是固定函数着色器，在 Fixed function 后面也会出现 Show generated code 按钮。Compile and show code 下拉列表可以让开发者检查 Unity Shader 针对不同图像编程接口最终编译成的 Shader 代码。</p><h2 id="Unity-Shader-的基础：ShaderLab"><a href="#Unity-Shader-的基础：ShaderLab" class="headerlink" title="Unity Shader 的基础：ShaderLab"></a>Unity Shader 的基础：ShaderLab</h2><p>在 Unity 中，所有的 Unity Shader 都是使用 ShaderLab 来编写的。ShaderLab 是 Unity 提供的编写 Unity Shader 的一种说明性语言。使用了嵌套在花括号内部的语义来描述结构，这些结构包含了渲染所需的数据，比如 Properties 语句块中定义了着色器所需的各种属性。一个 Unity Shader 的基础结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;ShaderName&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">      // 属性</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">      // 显卡A使用的子着色器</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">      // 显卡B使用的子着色器</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unity 会根据使用的平台来把这些结构编译成真正的代码和 Shader 文件。</p><h2 id="Unity-Shader-的结构"><a href="#Unity-Shader-的结构" class="headerlink" title="Unity Shader 的结构"></a>Unity Shader 的结构</h2><h3 id="Unity-Shader-的名字"><a href="#Unity-Shader-的名字" class="headerlink" title="Unity Shader 的名字"></a>Unity Shader 的名字</h3><p>每个 Unity Shader 文件的第一行都需要通过 Shader 语义来指定 Unity Shader 的名字。当为材质选择使用的 Unity Shader 时，名字就会出现在材质的 Inspector 面板的下拉列表里。通过在名字添加斜杠 / ，可以控制 Unity Shader 在材质面版中出现的位置：<code>Shader &quot;Custom/MyShader&quot;</code>。那么这个 Unity Shader 在材质面板的位置就是：Shader -&gt; Custom -&gt; MyShader。</p><h3 id="Properties-语义块"><a href="#Properties-语义块" class="headerlink" title="Properties 语义块"></a>Properties 语义块</h3><p>Properties 语义块中包含了一系列属性，这些属性会出现在材质面板中。Properties 语义块的定义通常如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">    Name (&quot;display name&quot;, PropertyType) = DefaultValue</span><br><span class="line">    Name (&quot;display name&quot;, PropertyType) = DefaultValue</span><br><span class="line">    // 更多属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Shader 中需要访问材质属性的名字 Name，这些属性名字由一个下划线开始。display name 则是显示在材质面板上的名字。我们需要为每个属性指定它的类型和默认值。常见属性类型如下表：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">属性类型</th><th style="text-align:left">默认值的定义语法</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">Int</td><td style="text-align:left">number</td><td style="text-align:left">_Int(“Int”,Int) = 2</td></tr><tr><td style="text-align:left">Float</td><td style="text-align:left">number</td><td style="text-align:left">_Float(“Float”,Float) = 1.5</td></tr><tr><td style="text-align:left">Range(min, max)</td><td style="text-align:left">number</td><td style="text-align:left">_Range(“Range”,Range(0.0, 5.0)) = 3.0</td></tr><tr><td style="text-align:left">Color</td><td style="text-align:left">(number,number,number,number)</td><td style="text-align:left">_Color(“Color”,Color) = (1,1,1,1)</td></tr><tr><td style="text-align:left">Vector</td><td style="text-align:left">(number,number,number,number)</td><td style="text-align:left">_Vector(“Vector”,Vector) = (2,6,3,1)</td></tr><tr><td style="text-align:left">2D</td><td style="text-align:left">“defaulttexture” { }</td><td style="text-align:left">_2D(“2D”,2D) = “” { }</td></tr><tr><td style="text-align:left">Cube</td><td style="text-align:left">“defaulttexture” { }</td><td style="text-align:left">_Cube(“Cube”,Cube) = “white” { }</td></tr><tr><td style="text-align:left">3D</td><td style="text-align:left">“defaulttexture” { }</td><td style="text-align:left">_3D(“3D”,3D) = “black” { }</td></tr></tbody></table></div><p>对于 2D、Cube、3D 这种纹理类型，默认值的定义稍微复杂，默认值是通过一个字符串后跟一个花括号来指定的，其中，字符串要么是空的，要么是内置的纹理名称，如 “white”，“black”，“gray” 或者 “bump”。</p><h3 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h3><blockquote><p>一个 SubShader 可理解为 Shader 中的一个渲染方案。即针对不同的渲染情况，需要编写不同的子着色器。  </p><p>In a shader program, a <strong>“pass”</strong> refers to a single rendering operation that is performed on a set of geometry or pixels. It can include multiple shader stages, such as vertex, geometry, and fragment shaders. </p></blockquote><p>每一个 Unity Shader 可以包含多个 SubShader 语义块，但最少要有一个。 当 Unity 需要加载这个 Unity Shader 时，Unity 会扫描所有的 SubShader 语义块， 然后选择第一个能够在目标平台上运行的 SubShader。 如果都不支持的话，Unity 就会使用 Fallback 语义指定的 Unity Shader。Unity 提供这种语义的原因是因为不同显卡的能力不同，高级的显卡能支持更多的指令数，我们希望在差性能显卡使用计算复杂度较低的着色器，在高级显卡上使用计算复杂度较高的着色器。</p><p>SubShader 语义块通常如下：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">    // 可选的</span><br><span class="line">    [Tags]</span><br><span class="line"></span><br><span class="line">    // 可选的</span><br><span class="line">    [RenderSetup]</span><br><span class="line"></span><br><span class="line">    Pass &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    // Other Passes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SubShader 中定义了一系列 Pass 以及可选的状态 [RenderSetup] 和标签 [Tags] 设置。每个 Pass 定义了一次完整的渲染流程</strong>，但如果 Pass 的数目过多，往往会造成渲染性能的下降。 因此，我们应尽量使用最小数目的 Pass。状态和标签同样可以在 Pass 声明。不同的是，SubShader 中的一些标签设置是特定的。也就是说，这些标签设置和 Pass 中使用的标签是不一样的。而对于状态设置来说，其使用的语法是相同的。但是，如果我们在 SubShader 进行了这些设置，那么将会用于所有的 Pass。</p><p><strong><em>状态设置</em></strong><br>ShaderLab 提供了一系列渲染状态的指令，这些指令可以设置显卡的各种状态，例如混合/开启深度测试等。常见的渲染状态设置选项如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">状态名称</th><th style="text-align:left">设置指令</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">Cull</td><td style="text-align:left">Cull Back &verbar; Front &verbar; Off</td><td style="text-align:left">设置剔除模式：剔除背面/正面/关闭剔除</td></tr><tr><td style="text-align:left">ZTest</td><td style="text-align:left">ZTest Less Greator &verbar; LEqual &verbar; GEqual &verbar; Equal &verbar; NotEqual &verbar; Always</td><td style="text-align:left">设置深度测试时使用的函数</td></tr><tr><td style="text-align:left">ZWrite</td><td style="text-align:left">ZWrite On &verbar; Off</td><td style="text-align:left">开启/关闭深度写入</td></tr><tr><td style="text-align:left">Blend</td><td style="text-align:left">Blend SrcFactor DstFactor</td><td style="text-align:left">开启并设置混合模式</td></tr></tbody></table></div><p>当在 SubShader 块中设置了上述渲染状态时，将会应用到所有的 Pass，如果不想这样，可以在 Pass 语义块中单独进行上面的设置。</p><p><strong><em>SubShader 的标签</em></strong><br>标签 Tags 是一个键值对，键和值都是字符串类型，这些键值对用来告诉 Unity 的渲染引擎希望怎样以及何时渲染这个对象。标签结构：<code>Tags &#123; &quot;TagName1&quot; = &quot;Value1&quot; &quot;TagName2&quot; = &quot;Value2&quot; &#125;</code></p><p>SubShader 的标签块支持的标签类型如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><font size=2>标签类型</font></th><th style="text-align:left"><font size=2>说明</font></th><th style="text-align:left"><font size=2>例子</font></th></tr></thead><tbody><tr><td style="text-align:left"><font size=2>Queue</font></td><td style="text-align:left"><font size=2>控制渲染顺序，指定该物体属于哪个渲染队列，通过这种方式可以保证所有的透明物体可以在所有不透明物体后面被渲染，我们也可以自定义使用的渲染队列来控制物体的渲染顺序</font></td><td style="text-align:left"><font size=2>Tags {  “Queue” = “Transparent” }</font></td></tr><tr><td style="text-align:left"><font size=2>RenderType</font></td><td style="text-align:left"><font size=2>对着色器进行分类，例如这是一个不透明的着色器，或是一个透明的着色器等。可以被用于着色器替换 Shader Replacement 功能</font></td><td style="text-align:left"><font size=2>Tags { “RenderType” = “Opaque” }</font></td></tr><tr><td style="text-align:left"><font size=2>DisableBatching</font></td><td style="text-align:left"><font size=2>一些 SubShader 在使用 Unity 的批处理功能时会出现问题，例如使用了模型空间下的坐标进行顶点动画。这时可以通过该标签来直接指明是否对该 SubShader 使用批处理</font></td><td style="text-align:left"><font size=2>Tags { “DisableBatching” = “True” }</font></td></tr><tr><td style="text-align:left"><font size=2>ForceNoShadowCasting</font></td><td style="text-align:left"><font size=2>控制使用该 SubShader 的物体是否会投射阴影</font></td><td style="text-align:left"><font size=2>Tags { “ForceNoSdowCasting” = “True” }</font></td></tr><tr><td style="text-align:left"><font size=2>lgnoreProjector</font></td><td style="text-align:left"><font size=2>如果该标签值为 “True” 那么使用该 SubShader 的物体将不会受 Projector 的影响。通常用于半透明物体</font></td><td style="text-align:left"><font size=2>Tags { “lgnoreProjector” = “True” }</font></td></tr><tr><td style="text-align:left"><font size=2>CanUseSpriteAtlas</font></td><td style="text-align:left"><font size=2>当该 SubShader 是用于精灵 sprites 时，将该标签设为 “False”</font></td><td style="text-align:left"><font size=2>Tags { “CanUseSpriteAtlas” = “False” }</font></td></tr><tr><td style="text-align:left"><font size=2>PreviewType</font></td><td style="text-align:left"><font size=2>指明材质面板将如何预览该材质。默认情况下，材质将显示为一个球形，我们可以通过把该标签的值设为 “Plane” “SkyBox” 来改变预览类型</font></td><td style="text-align:left"><font size=2>Tags { “PreviewType” = “Plane” }</font></td></tr></tbody></table></div><p>注意：上述标签可以在 SubShader 中声明，而不可以在 Pass 块中声明，Pass 块虽然也可以定义标签，但这些标签是不同于 SubShader 的标签类型。</p><p><strong><em>Pass 语义块</em></strong><br>Pass 语义块包含的语义如下：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">  [Name]</span><br><span class="line">  [Tags]</span><br><span class="line">  [RenderSetup]</span><br><span class="line">  // Other Code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在 Pass 中定义该 Pass 的名称，例如：<code>Name &quot;MyPassName&quot;</code>。通过这个名称，我们可以使用 ShaderLab 的 UsePass 命令来直接使用其他 Unity Shader 中的 Pass，例如：<code>UsePass &quot;MyShader/MYPASSNAME&quot;</code>。由于 Unity 内部会把所以 Pass 的名称转换成大写字母表示，因此，在使用 UsePass 命令时必须使用大写形式的名字。</p><p>可以对 Pass 设置渲染状态， SubShader 的状态设置同样适用于 Pass，除此之外，还可以使用固定管线的着色器命令，见后面。Pass 同样可以设置标签，但它的标签不同于 SubShader 的标签。这些标签也是用于告诉渲染引擎我们希望怎么样来渲染该物体。</p><div class="table-container"><table><thead><tr><th style="text-align:left">标签类型</th><th style="text-align:left">说明</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">LightMode</td><td style="text-align:left">定义该 Pass 在 Unity 的渲染流水线中的角色</td><td style="text-align:left">Tags { “LightMode” = “ForwardBase” }</td></tr><tr><td style="text-align:left">RequireOptions</td><td style="text-align:left">用于指定当满足某些条件时才渲染该 Pass, 它的值是一个由空格分隔的字符串。目前， Unity 支待的选项有：SoftVegetation 。在后面的版本中，可能会增加更多的选项</td><td style="text-align:left">Tags { “RequireOptions” = “SoftVegetation” }</td></tr></tbody></table></div><p>Unity Shader 还支持一些特殊的 Pass：<br>UsePass：可以使用该命令来复用其他 Unity Shader 中的 Pass；<br>GrabPass：该 Pass 负责抓取屏幕并将结果储存在一张纹理中，以用于后续的 Pass 处理。</p><h3 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h3><p>Fallback 指令用于告诉 Unity：如果上面所有 SubShader 不能在该显卡上运行，那么就使用这个最低级的 Shader 吧。它的语义如下：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fallback &quot;name&quot;</span><br><span class="line">// 或者</span><br><span class="line">Fallback off</span><br></pre></td></tr></table></figure><p>事实上 Fallback 还会影响阴影的投射。在渲染阴影纹理时，Unity 会在每个 Unity Shader 中寻找一个阴影投射的 Pass。通常情况下，我们不需要自己专门实现一个 Pass，Fallback 使用的内置 Shader中包含一个通用的 Pass。因此，为每个 UnityShader 正确设置 Fallback 是非常重要的。</p><h3 id="其他语义"><a href="#其他语义" class="headerlink" title="其他语义"></a>其他语义</h3><p>除了上述语义，还有一些不常用的语义：比如，使用 CustomEditor 语义来扩展材质面板的编辑界面；使用 Category 语义来对 Unity Shader 中的命令进行分组。</p><h2 id="Unity-Shader-的形式"><a href="#Unity-Shader-的形式" class="headerlink" title="Unity Shader 的形式"></a>Unity Shader 的形式</h2><p>Unity Shader 最重要的任务还是指定各种着色器所需的代码。这些着色器代码可以写在 SubShader 语义块里（表面着色器的做法），也可以写在 Pass 语义块里（顶点/片元着色器和固定函数着色器的做法）。</p><h3 id="表面着色器-Surface-Shader"><a href="#表面着色器-Surface-Shader" class="headerlink" title="表面着色器 Surface Shader"></a>表面着色器 Surface Shader</h3><p>表面着色器是 Unity 自己创造的着色器类型，代码量很少，但是 Unity 在背后做了很多工作，渲染代价比较大。本质上与顶点/片元着色器相同，Unity 内部会将该着色器转换为对应顶点/片元着色器，表面着色器是对顶点/片元着色器更高一层的抽象，Unity 为我们处理了很多光照细节。一个非常简单的表面着色器示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Custom/Simple Surface Shader&quot; &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;</span><br><span class="line">        CGPROGRAM</span><br><span class="line">        #progma surface surf Lambert</span><br><span class="line">        struct Input&#123;</span><br><span class="line">            float color : COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line">        void surf (Input IN, inout SurfaceOutput o) &#123;</span><br><span class="line">            o.Albedo = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表面着色器被定义在 SubShader 语义块中的 CGPROGRAM 和 ENDCG 之间，表面着色器不需要关心使用多少个 Pass、每个 Pass 如何渲染等问题，Unity 会在背后做好这些事情，把表面着色器转换成一个包含多 Pass 的顶点/片元着色器。我们只需要告诉表面着色器使用哪些纹理填充颜色，使用哪个法线纹理去填充法线，使用 Lambert 光照模型等。</p><p><strong>CGPROGRAM 和 ENDCG 之间的代码使用的是 CG/HLSL 编写的，需要将 CG/HLSL 语言嵌入 ShaderLab 语言中。</strong>但是这里的 CG/HLSL 是 Unity 封装后的，它的语法和标准的 CG/HLSL 几乎一致，但是有细微差别，有些函数和用法 Unity 没有提供支持。</p><h3 id="顶点-片元着色器-Vertex-Fragment-Shader"><a href="#顶点-片元着色器-Vertex-Fragment-Shader" class="headerlink" title="顶点/片元着色器 Vertex/Fragment Shader"></a>顶点/片元着色器 Vertex/Fragment Shader</h3><p>在 Unity 中，我们可以使用 Cg/HLSL 语言来编写顶点/片元着色器。它们更加复杂，但灵活性也更高。一个非常简单的顶点/片元着色器示例代码如下：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Custom/Simple Surface Shader&quot; &#123;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123; </span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            float4 vert(float4 v : POSITION) : SV_POSITION &#123;</span><br><span class="line">                return mul (UNITY_MATRIX_MVP, v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag() : SV_Target &#123;</span><br><span class="line">                return fixed4(1.0, 0.0, 0.0, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和表面着色器类似，顶点/片元着色器的代码也需要定义在 CGPROFRAM 和 ENDCG 之间。但不同的是，顶点/片元着色器是写在 Pass 语义块中，而非 SubShader 内的。我们需要自己定义每个 Pass 需要使用的 Shader 代码。</p><h3 id="固定函数着色器-Fixed-Function-Shader"><a href="#固定函数着色器-Fixed-Function-Shader" class="headerlink" title="固定函数着色器 Fixed Function Shader"></a>固定函数着色器 Fixed Function Shader</h3><p>对于一些较旧的设备，不支持可编程管线着色器。因此，我们需要使用固定函数着色器来完成渲染。这些着色器往往只可以完成一些非常简单的效果。一个非常简单的固定函数着色器示例代码如下：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Tutorial/Basic&quot; &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (&quot;Main Color&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass &#123;</span><br><span class="line">            Material &#123;</span><br><span class="line">                Diffuse [_Color]</span><br><span class="line">            &#125;</span><br><span class="line">            Lighting On</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>固定函数着色器的代码被定义在 Pass 语义块内，相当于 Pass 的一些渲染设置。对于固定函数着色器，需要完全使用 ShaderLab 语法，而非 Cg/HLSL 。</p><p>由于绝大多数 GPU 都支持可编程的渲染管线，这种固定渲染管线的编程方式已经逐渐被抛弃了。实际上，在现在的 Unity 中，所有固定函数着色器都会在背后被 Unity 编译成对应的顶点/片元着色器，因此，真正意义上的固定函数着色器已经不存在了。</p><h3 id="选择哪种着色器"><a href="#选择哪种着色器" class="headerlink" title="选择哪种着色器"></a>选择哪种着色器</h3><p>①除非你有非常明确的需求必须要使用固定函数着色器，例如需要在非常旧的设备上运行你的游戏，否则请使用可编程管线的着色器，即表面着色器或顶点/片元着色器；<br>②如果你想和各种光源打交道，你可能更喜欢使用表面着色器，但需要小心它在移动平台的性能表现；<br>③如果你需要使用的光照数目非常少，例如只有一个平行光，那么使用顶点/片元着色器是一个更好的选择；<br>④如果你有很多自定义的渲染效果，那么请选择顶点/片元着色器。</p><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><h3 id="Unity-Shader-和真正的-Shader-的区别"><a href="#Unity-Shader-和真正的-Shader-的区别" class="headerlink" title="Unity Shader 和真正的 Shader 的区别"></a>Unity Shader 和真正的 Shader 的区别</h3><p>①在 Shader 中，我们仅可以编写特定类型的 Shader，例如顶点着色器、片元着色器等。而在 Unity Shader 中，我们可以在同一个文件里同时包含需要的顶点着色器和片元着色器代码；<br>②在 Shader 中，我们无法设置一些渲染设置，例如是否开启混合、深度测试等，这些是开发者在另外的代码中自行设置的。而在 Unity Shader 中，我们通过一行特定的指令就可以完成这些设置；<br>③在 Shader 中，我们需要编写冗长的代码来设置着色器的输入和输出，要小心地处理这些输入输出的位置对应关系等。而在 Unity Shader 中，我们只需要在特定语句块中声明一些属性，就可以依靠材质来方便地改变这些属性。而且对于模型自带的数据（如顶点位置、纹理坐标、法线等），Unity Shader 也提供了直接访问的方法，不需要开发者自行编码来传给着色器。</p><p>由于 Unity Shader 的高度封装性，可以编写的 Shade 类型和语法被限制了，对应一些特定类型的 Shader 如曲面细分着色器和几何着色器等相关功能就支持得差一点。作为开发者，我们绝大部分时候只需要和 Unity Shader 打交道，而不需要关心渲染引擎底层得实现细节。</p><h1 id="第三章-Shader-数学基础"><a href="#第三章-Shader-数学基础" class="headerlink" title="第三章 Shader 数学基础"></a>第三章 Shader 数学基础</h1><h2 id="笛卡儿坐标系"><a href="#笛卡儿坐标系" class="headerlink" title="笛卡儿坐标系"></a>笛卡儿坐标系</h2><p>我们平时使用的是<strong>笛卡儿坐标系 Cartesian Coordinate System</strong>。在三维笛卡儿坐标系中，需要定义三个坐标轴和一个原点。这三个坐标轴也就是该坐标系的<strong>基矢量 basis vector</strong>。若这三个坐标轴是相互垂直的，且长度为1，这样的基矢量被称为<strong>标准正交基 orthonormal basis</strong>，但这不是必须的。若这三个坐标轴仅仅相互垂直的，这样的基矢量被称为<strong>正交基 orthogonal basis</strong>。</p><p>三维笛卡儿坐标系并不都是等价的，具有<strong>旋向性 handedness</strong>，即分为<strong>左手坐标系 left-handed coordinate space</strong> 和<strong>右手坐标系 right-handed coordinate space</strong>。除了坐标轴朝向不同之外，左手坐标系和右手坐标系对于正向旋转的定义也不同，即<strong>左手法则 left-handed rule</strong>和<strong>右手法则 right-handed rule</strong>。</p><p>在 Unity 中使用的坐标系就是左手坐标系。但在观察空间使用右手坐标系，观察空间是以摄像头为原点的坐标系，摄像头的前方是 z 轴的负方向，z 轴坐标的减少意味着景深的增加。</p><h2 id="点和矢量"><a href="#点和矢量" class="headerlink" title="点和矢量"></a>点和矢量</h2><p><strong>矢量或向量 vector</strong> 与<strong>标量 scalar</strong> 区分。矢量指 n 维空间中一种包含了<strong>模 magnitude</strong> 和方向的有向线段。</p><p>矢量的运算此处不再摘录，见 <a href="https://ybniaobu.github.io/2023/07/09/2023-07-09-Unity%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9D%82%E8%AE%B0/#%E4%B8%89%E7%BB%B4%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80">Unity基础 - 三维数学基础</a>。</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>矩阵的运算此处也不再摘录，见 <a href="https://ybniaobu.github.io/2023/07/12/2023-07-12-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/">线性代数基础</a>。</p><p>在 Shader 的计算中，经常使用 4X4 的矩阵运算。</p><h3 id="特殊的矩阵"><a href="#特殊的矩阵" class="headerlink" title="特殊的矩阵"></a>特殊的矩阵</h3><p><strong><em>1. 方块矩阵 square matrix</em></strong><br>方块矩阵，简称<strong>方阵</strong>，即行列数相等的矩阵。矩阵的某些运算和性质只有方阵才有。</p><p>如果一个矩阵除了对角元素外的所有元素都为 0，那么该矩阵称为<strong>对角矩阵 diagonal matrix</strong>。</p><p><strong><em>2. 单位矩阵 identity matrix</em></strong><br>使用 I 来表示，MI = IM = M。</p><p><strong><em>3. 转置矩阵 transposed matrix</em></strong><br>写作 $M^T$ ，公式为 $M_{ij}^T = M_{ji}$。转置矩阵有如下性质：<br>①$(M^T)^T=M$<br>②$(AB)^T=B^TA^T$  </p><p><strong><em>4. 逆矩阵 inverse matrix</em></strong><br>给定一个方阵 M，$MM^{-1}=M^{-1}M=I$。但并非所有方阵都有对应的逆矩阵，若一个矩阵的<strong>行列式 determinant</strong> 不为 0，那么它就是可逆的。若一个矩阵有对应的逆矩阵，就可以说这个矩阵是<strong>可逆的 invertible</strong>或者说是<strong>非奇异的 nonsingular</strong>。若一个矩阵没有对应的逆矩阵，它就是<strong>不可逆的 noninvertible</strong> 或者说是<strong>奇异的 singular</strong>。</p><p>逆矩阵有如下性质：<br>①$(M^{-1})^{-1}=M$<br>②$I^{-1}=I$<br>③$(M^{T})^{-1}=(M^{-1})^{T}$<br>④$(AB)^{-1}=B^{-1}A^{-1}$  </p><p>在写 Shader 的过程中，矩阵运算可以调用第三方库（如 C++ 数学库 Eigen）。在 Unity 中也有内置的工具。</p><p><strong><em>5. 正交矩阵 orthogonal matrix</em></strong><br>如果一个方阵 M 和它的转置矩阵的乘积是单位矩阵的话，则这个矩阵是<strong>正交的 orthogonal</strong>。即 $MM^{T}=M^{T}M=I$ ，$M^{T}=M^{-1}$。</p><p>上述公式比较重要，因为逆矩阵的求解运算量很大，而转置矩阵只需要将矩阵翻转即可。</p><p>正交矩阵的特点：根据正交矩阵的定义，可以写成以下公式（其中 c 为向量）：  </p><script type="math/tex; mode=display">M^TM = \begin{bmatrix} - & c_1 & - \\ - & c_2 & - \\ - & c_3 & - \end{bmatrix} \begin{bmatrix} | & | & | \\ c_1 & c_2 & c_3 \\ | & | & | \end{bmatrix} = \begin{bmatrix} c_1 \cdot c_1 & c_1 \cdot c_2 & c_1 \cdot c_3 \\ c_2 \cdot c_1 & c_2 \cdot c_2 & c_2 \cdot c_3 \\ c_3 \cdot c_1 & c_3 \cdot c_2 & c_3 \cdot c_3 \end{bmatrix} = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} = I</script><p>可以得到9个等式：$c_1 \cdot c_1 = 1$，$c_1 \cdot c_2 = 0$，$c_1 \cdot c_3 = 0$，$c_2 \cdot c_1 = 0$，$c_2 \cdot c_2 = 1$，$c_2 \cdot c_3 = 0$，$c_3 \cdot c_1 = 0$，$c_3 \cdot c_2 = 0$，$c_3 \cdot c_3 = 1$。</p><p>根据以上等式，可以得出以下结论：<br>①矩阵的每一行，即 $c_1$，$c_2$，$c_3$ 都是单位矢量，因为只有这样它们与自己的点积才能是1；<br>②矩阵的每一行，即 $c_1$，$c_2$，$c_3$ 之间相互垂直，因为只有这样他们之间的点积才是0；<br>③上述两条结论对于矩阵的每一列都适用，所以正交矩阵的转置矩阵也是正交矩阵。<br>④<strong>一个正交矩阵的行和列分别构成了一组标准正交基</strong>。若使用一组正交基来构建一个矩阵，这个矩阵可能不是一个正交矩阵，因为基矢量的长度可能不为 1。</p><h3 id="行向量还是列向量"><a href="#行向量还是列向量" class="headerlink" title="行向量还是列向量"></a>行向量还是列向量</h3><p>行向量还是列向量与矩阵相乘会有一些差异：假设一个向量 v = (x, y, z)，和另一个矩阵 M：</p><script type="math/tex; mode=display">M = \begin{bmatrix} m_{11} & m_{12} & m_{13} \\ m_{21} & m_{22} & m_{23} \\ m_{31} & m_{32} & m_{33} \end{bmatrix}</script><p>①行向量乘法，向量在矩阵左边：  </p><script type="math/tex; mode=display">vM = \begin{bmatrix} xm_{11}+ym_{21}+zm_{31} & xm_{12}+ym_{22}+zm_{32} & xm_{13}+ym_{23}+zm_{33} \end{bmatrix}</script><p>②列向量乘法，矩阵在向量左边：  </p><script type="math/tex; mode=display">Mv = \begin{bmatrix} xm_{11}+ym_{12}+zm_{13} \\ xm_{21}+ym_{22}+zm_{23} \\ xm_{31}+ym_{32}+zm_{33} \end{bmatrix}</script><p>比较一下可以知道，列向量和行向量得到的结果不一样。这意味着在和矩阵相乘时，选择行向量还是列向量是非常重要的，会影响矩阵乘法的结果。DirectX 使用的是行向量，openGL 使用的也是列向量。</p><p>在 Unity 中使用的是列向量，之后的内容，如无特殊情况，都使用列矩阵。即 $ CBAv = (C(B(Av))) $。该公式等价于下面的行向量运算：$ vA^TB^TC^T = (((vA^T)B^T)C^T) $。若矩阵是对称矩阵，那么列向量和行向量不会对结果产生影响，因为对称矩阵的转置是其本身。</p><h2 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h2><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>变换指把一些数据，如点、方向甚至是颜色等，通过某种方式进行转换的过程。在计算机图形学中，变换举足轻重。</p><p><strong>线性变换 linear transform</strong> 指的是可以保留矢量加和标量乘的变换。<strong>缩放 scale</strong>、<strong>旋转 rotation</strong>、<strong>错切 shear</strong>、<strong>镜像 reflection</strong>、<strong>正交投影 orthographic projection</strong> 都是线性变换。</p><p>但是平移变换就不是线性变换。因此我们不能用一个 3 × 3 的矩阵来表示平移变换。由于平移变换是非常常见的一个变换，这样就有了<strong>仿射变换 affine transform</strong>，仿射变换就是合并线性变换和平移变换的变换类型。仿射变换可以使用一个 4 × 4 的矩阵来表示，即需要将矢量扩展到四维空间中，这就是<strong>齐次坐标空间 homogeneous space</strong>。</p><p>下表给出了图形学中常见变换矩阵的名称和它们的特性：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">变换名称</th><th style="text-align:center">是线性变换吗</th><th style="text-align:center">是仿射变换吗</th><th style="text-align:center">是可逆矩阵吗</th><th style="text-align:center">是正交矩阵吗</th></tr></thead><tbody><tr><td style="text-align:left">平移矩阵</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:left">绕坐标轴旋转的旋转矩阵</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:left">绕任意轴旋转的旋转矩阵</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:left">按坐标轴缩放的缩放矩阵</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:left">错切矩阵</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:left">镜像矩阵</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:left">正交投影矩阵</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:left">透视投影矩阵</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table></div><h3 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h3><p>由于 3 × 3 的矩阵不能表示平移操作，就把其扩展到 4 × 4 的矩阵。为此需要把三维矢量转换为四维矢量，即齐次坐标 homogeneous coordinate（书中所说的齐次坐标泛指四维齐次坐标）。齐次坐标可以理解为为了方便计算而使用的一个表达方式。</p><p>将三维坐标转换为齐次坐标：对于一个点，x，y，z 坐标不变，将 w 坐标设为 1，即 $[x , y , z , 1]$；对于一个方向矢量，x，y，z 坐标不变，将 w 坐标设为 0，即 $[x , y , z , 0]$。这样就会可以，当使用矩阵对点变换时，平移、旋转、缩放都可以施加于该点；若用于一个向量，平移效果会被忽略。</p><h3 id="分解基础变换矩阵"><a href="#分解基础变换矩阵" class="headerlink" title="分解基础变换矩阵"></a>分解基础变换矩阵</h3><p>纯平移、纯缩放、纯旋转的变换矩阵叫做基础变换矩阵。可以把一个基础变换矩阵分解为 4 个组成部分：</p><script type="math/tex; mode=display">\begin{bmatrix} M_{3 \times 3} & t_{3 \times 1} \\ 0_{1 \times 3} & 1 \end{bmatrix}</script><p>左上角的矩阵 $ M_{3\times3} $ 用于表示旋转和缩放，$t_{3\times1}$ 用于表示平移，$0_{1\times3}$ 表示零矩阵，右下角元素为标量1。</p><h3 id="平移矩阵"><a href="#平移矩阵" class="headerlink" title="平移矩阵"></a>平移矩阵</h3><p>使用矩阵乘法来表示对一个 <em>点</em> 的平移变换：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 0 & 0 & t_x \\ 0 & 1 & 0 & t_y \\ 0 & 0 & 1 & t_z \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} = \begin{bmatrix} x + t_x \\ y + t_y \\ z + t_z \\ 1 \end{bmatrix}</script><p>点的x、y、z分量分别增加一个位置偏移，可以看作点 $(x, y, z)$ 在坐标空间被平移了 $(t_x,t_y,t_z)$ 个单位。</p><p>若使用矩阵乘法来表示对一个 <em>向量</em> 的平移变换：  </p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 0 & 0 & t_x \\ 0 & 1 & 0 & t_y \\ 0 & 0 & 1 & t_z \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ z \\ 0 \end{bmatrix} = \begin{bmatrix} x \\ y \\ z \\ 0 \end{bmatrix}</script><p>可以发现，平移变换不会对向量产生任何影响。</p><p>平移矩阵的逆矩阵就是反向平移得到的矩阵（可以看出，平移矩阵不是一个正交矩阵）：  </p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 0 & 0 & -t_x \\ 0 & 1 & 0 & -t_y \\ 0 & 0 & 1 & -t_z \\ 0 & 0 & 0 & 1 \end{bmatrix}</script><h3 id="缩放矩阵"><a href="#缩放矩阵" class="headerlink" title="缩放矩阵"></a>缩放矩阵</h3><p>使用矩阵乘法来表示对一个 <em>点</em> 的缩放变换：  </p><script type="math/tex; mode=display">\begin{bmatrix} k_x & 0 & 0 & 0 \\ 0 & k_y & 0 & 0 \\ 0 & 0 & k_z & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} = \begin{bmatrix} k_xx \\ k_yy \\ k_zz \\ 1 \end{bmatrix}</script><p>使用矩阵乘法来表示对一个 <em>向量</em> 的缩放变换： </p><script type="math/tex; mode=display">\begin{bmatrix} k_x & 0 & 0 & 0 \\ 0 & k_y & 0 & 0 \\ 0 & 0 & k_z & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ z \\ 0 \end{bmatrix} = \begin{bmatrix} k_xx \\ k_yy \\ k_zz \\ 0 \end{bmatrix}</script><p>如果缩放系数 $k_x = k_y = k_z$ ，把这样的缩放叫做<strong>统一缩放 uniform scale</strong>，否则称为<strong>非统一缩放 ununiform scale</strong>。统一缩放是扩大整个模型，非统一缩放会拉伸或挤压模型。统一缩放不会改变角度和比例信息，而非统一缩放会改变与模型相关角度和比例。例如对法线进行变换时，如果存在非统一缩放，直接使用用于变换顶点的变换矩阵，会产生错误结果。</p><p>缩放矩阵的逆矩阵是使用原缩放系数的倒数来对点或向量进行缩放（缩放矩阵一般不是正交矩阵）：  </p><script type="math/tex; mode=display">\begin{bmatrix} \frac {1}{k_x} & 0 & 0 & 0 \\ 0 & \frac {1}{k_y} & 0 & 0 \\ 0 & 0 & \frac {1}{k_z} & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}</script><p>上面的矩阵只适用于沿坐标轴方向进行缩放。若需要在任意方向上进行缩放，就需要使用复合变换。其中一个方法的主要思想就是，先将缩放轴变换成标准坐标轴，然后进行沿坐标轴缩放，再使用逆变换得到原来的缩放轴朝向。</p><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p>①绕 x 轴旋转 θ 度：  </p><script type="math/tex; mode=display">R_x(θ) = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & \cos θ & - \sin θ & 0 \\ 0 & \sin θ & \cos θ & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}</script><p>②绕 y 轴旋转 θ 度： </p><script type="math/tex; mode=display">R_y(θ) = \begin{bmatrix} \cos θ & 0 & \sin θ & 0 \\ 0 & 1 & 0 & 0 \\ - \sin θ & 0 & \cos θ & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}</script><p>③绕 z 轴旋转 θ 度： </p><script type="math/tex; mode=display">R_z(θ) = \begin{bmatrix} \cos θ & - \sin θ & 0 & 0 \\ \sin θ & \cos θ & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}</script><p>旋转矩阵的逆矩阵是旋转相反角度得到的变换矩阵。旋转矩阵是正交矩阵，而且多个旋转矩阵串联同样是正交的。</p><h3 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h3><p>将平移，旋转，缩放组合起来，形成一个复杂的变换过程（假设 y 轴旋转）：</p><script type="math/tex; mode=display">P_{new} = M_{translation}M_{rotation}M_{scale}P_{old} = \begin{bmatrix} 1 & 0 & 0 & t_x \\ 0 & 1 & 0 & t_y \\ 0 & 0 & 1 & t_z \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} \cos θ & 0 & \sin θ & 0 \\ 0 & 1 & 0 & 0 \\ - \sin θ & 0 & \cos θ & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} k_x & 0 & 0 & 0 \\ 0 & k_y & 0 & 0 \\ 0 & 0 & k_z & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}</script><script type="math/tex; mode=display">= \begin{bmatrix} k_x\cos θ & 0 & k_z \sin θ & t_x \\ 0 & k_y & 0 & t_y \\ - k_x \sin θ & 0 & k_z \cos θ & t_z \\ 0 & 0 & 0 & 1 \end{bmatrix}</script><p>绝大多数情况下，我们约定变换的顺序即为<strong>先进行缩放，再进行旋转，最后进行平移</strong>。这样约定有原因的，比如初始位置为原点，先按 (0, 0, 5) 平移，再按坐标轴放大 2 倍，变为了 (0, 0, 10)，这不是我们想要的，应该先在原点缩放，再进行平移。</p><p>除了注意不同类型的变换顺序之外，也要注意<strong>旋转的变换顺序</strong>。不同的旋转顺序会导致不同结果，所以当给定旋转角度 $θ_x, θ_y, θ_z$ 时，需要定义一个旋转顺序。在 Unity 中，旋转顺序按照先绕 z 轴旋转，再绕 x 轴旋转，最后绕 y 轴旋转。</p><p>旋转顺序的定义可以有2种方式：<br>①绕坐标系 E 下的 z 轴旋转 $θ_z$，绕坐标系 E 下的 x 轴旋转 $θ_x$，绕坐标系 E 下的 y 轴旋转 $θ_y$，即：进行一次旋转时不一起旋转当前坐标系。（全局坐标旋转）<br>②绕坐标系 E 下的 z 轴旋转 $θ_z$，绕坐标系 E 的 z 轴旋转后的新坐标系 E’ 下的 x 轴旋转 $θ_x$，绕坐标系 E’ 下绕 x 轴旋转后的新坐标系 E’’ 下的 y 轴旋转 $θ_y$，即：在旋转时，把坐标系一起转动。（局部坐标旋转）</p><p>方式 1 按 zxy 顺序旋转，和方式 2 按 yxz 旋转的效果是完全一样的，而 Unity 中按 zxy 顺序旋转指的是在方式 1 情况下的旋转顺序，相当于对应方式 2 的 yxz 顺序，即组合旋转变换矩阵为 $M_{rotate_y}M_{rotate_x}M_{rotate_z}$</p><blockquote><p>上述说明符合：<strong>基于全局坐标系的旋转变换左乘旋转矩阵，基于自身坐标系的旋转变换右乘旋转矩阵</strong>。</p></blockquote><h2 id="坐标空间"><a href="#坐标空间" class="headerlink" title="坐标空间"></a>坐标空间</h2><p>在渲染管线中有提到坐标空间的变换，可以回去查阅。顶点着色器的基本功能就是把模型的顶点坐标从模型空间转换到齐次裁剪坐标空间中。</p><h3 id="坐标空间的变换"><a href="#坐标空间的变换" class="headerlink" title="坐标空间的变换"></a>坐标空间的变换</h3><p>坐标空间会形成层次结构，即每个坐标空间都是另一个坐标空间的子空间，每个空间都有一个父坐标空间。对坐标空间的变换本质上就是在父子空间之间变换。</p><p>假设，有父坐标空间 P 以及一个子坐标空间 C 。一般会有两种需求：一种需求是把子坐标空间下表示的点或向量 $A_c$ 转换到父坐标空间下的 $A_p$ 。另一个需求，即把父坐标空间下表示的点或向量 $B_p$ 转换到子坐标空间下的 $B_c$ 。公式表示如下：  </p><script type="math/tex; mode=display">A_p = M_{c \rightarrow p} A_c</script><script type="math/tex; mode=display">B_c = M_{p \rightarrow c} B_p</script><p>其中，$M_{p \rightarrow c}$ 是 $M_{c \rightarrow p}$ 的逆矩阵（反向变换）。只需要解出两者之一，另一个矩阵可以通过求解逆矩阵得到。</p><p>接下来说明如何求解从子坐标空间到父坐标空间的变换矩阵 $M_{c \rightarrow p}$ ：假设已知子坐标空间 C 的 3 个坐标轴在父坐标空间 P 下的表示为向量 $x_c$、$y_c$、$z_c$，以及子坐标原点位置 $O_c$。当给定一个子坐标空间中的一点 $A_c = (a, b, c)$，求其在父坐标空间下的位置 $A_p$ ，可以得到：  </p><script type="math/tex; mode=display">\begin{aligned} A_p &= O_c + ax_c + by_c + cz_c \\ &= (x_{O_c}, y_{O_c}, z_{O_c}) + a(x_{x_c}, y_{x_c}, z_{x_c}) + b(x_{y_c}, y_{y_c}, z_{y_c}) + c(x_{z_c}, y_{z_c}, z_{z_c}) \\ &= (x_{O_c}, y_{O_c}, z_{O_c}) + \begin{bmatrix} x_{x_c} & x_{y_c} & x_{z_c} \\ y_{x_c} & y_{y_c} & y_{z_c} \\ z_{x_c} & z_{y_c} & z_{z_c} \end{bmatrix} \begin{bmatrix} a \\ b \\ c \end{bmatrix} \\ &= (x_{O_c}, y_{O_c}, z_{O_c}) + \begin{bmatrix} | & | & | \\ x_c & y_c & z_c \\ | & | & | \end{bmatrix} \begin{bmatrix} a \\ b \\ c \end{bmatrix} \end{aligned}</script><p>再把上述公式的加法（平移变换）用齐次坐标表示：  </p><script type="math/tex; mode=display">\begin{aligned} A_p &= (x_{O_c}, y_{O_c}, z_{O_c}, 1) + \begin{bmatrix} | & | & | & 0 \\ x_c & y_c & z_c & 0 \\ | & | & | & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} a \\ b \\ c \\ 1 \end{bmatrix} \\ &= \begin{bmatrix} 1 & 0 & 0 & x_{O_c} \\ 0 & 1 & 0 & y_{O_c} \\ 0 & 0 & 1 & z_{O_c} \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} | & | & | & 0 \\ x_c & y_c & z_c & 0 \\ | & | & | & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} a \\ b \\ c \\ 1 \end{bmatrix} \\ &= \begin{bmatrix} | & | & | & x_{O_c} \\ x_c & y_c & z_c & y_{O_c} \\ | & | & | & z_{O_c} \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} a \\ b \\ c \\ 1 \end{bmatrix} \\ &= \begin{bmatrix} | & | & | & | \\ x_c & y_c & z_c & O_c \\ | & | & | & | \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} a \\ b \\ c \\ 1 \end{bmatrix} \end{aligned}</script><p>由此得到变换矩阵 $M_{c \rightarrow p}$ ，可以看出该变换矩阵实际上就是将坐标空间 C 在坐标空间 P 的三个坐标轴向量依次放入矩阵的前三列，再把原点坐标放入第四列即可（三个坐标轴向量不一定是单位向量）。</p><p>在 Shader 中，会经常看到截取变换矩阵的前三列来对法线方向、光照方向进行空间变换，因为方向没有位置，因此坐标空间的原点变换可以忽略。</p><p>如果 $M_{c \rightarrow p}$ 是一个正交矩阵（即三轴为标准正交基），那么 $M_{p \rightarrow c}$ 只需要求 $M_{c \rightarrow p}$ 的转置就可以得到，计算转置比求逆简单：</p><script type="math/tex; mode=display">M_{p \rightarrow c} = \begin{bmatrix} | & | & | \\ x_p & y_p & z_p \\ | & | & |  \end{bmatrix} = M_{c \rightarrow p}^{-1} = M_{c \rightarrow p}^{T} = \begin{bmatrix} - & x_c & - \\ - & y_c & - \\ - & z_c & - \end{bmatrix}</script><p>上述公式可以得出，若 $M_{A \rightarrow B}$ 是一个正交矩阵，那么可以提取它的第一列来得到坐标空间 A 的 x 轴在坐标空间 B 下的表示，还可以提取它的第一行来得到坐标空间 B 的 x 轴在坐标空间 A 下的表示。反过来，无论我们知道 B 空间的 x 轴、y 轴和 z 轴在坐标空间 A 下的表示，还是 A 空间在 B 空间下的表示，都可以得到坐标 A 到 B 的变换矩阵，只是一个按列排放，一个按行排放。</p><blockquote><p>若要得到 A 到 B 的变换矩阵，知道 A 在 B 的表示，按列排放；知道 B 在 A 的表示，按行排放。可以快速验证变换矩阵按行还是列摆放是否正确，即使用 $M_{A \rightarrow B}$ 来变换 $x_B$，其结果应该是 $(1, 0, 0)$。</p></blockquote><h3 id="顶点的坐标空间变换过程"><a href="#顶点的坐标空间变换过程" class="headerlink" title="顶点的坐标空间变换过程"></a>顶点的坐标空间变换过程</h3><p>在渲染管线中，一个顶点需要经过多个坐标空间变换才能最终画在屏幕上。一个顶点最开始是在模型空间中定义的，最后会变换到屏幕空间中，得到真正的屏幕像素坐标。</p><h3 id="模型空间-model-space"><a href="#模型空间-model-space" class="headerlink" title="模型空间 model space"></a>模型空间 model space</h3><p>模型空间也称为<strong>对象空间 object space</strong> 或者<strong>局部空间 local space</strong>。当模型移动或旋转时，模型空间也会跟随移动或旋转。在 Unity 中使用左手坐标系来定义模型空间。模型空间的原点和坐标轴通常由美术人员在建模软件里确定好，导入 Unity 后，在顶点着色器中访问到的顶点的坐标都是相对于模型空间的原点（通常为模型重心）定义的。</p><h3 id="世界空间-world-space"><a href="#世界空间-world-space" class="headerlink" title="世界空间 world space"></a>世界空间 world space</h3><p>世界空间即 Unity 的全局坐标系，在 Unity 中，世界空间同样使用左手坐标系，其 x 轴、y 轴、z 轴是固定不变的。在 Unity 中，可以通过调整 Transform 组件中的 Position 属性来改变模型的位置，这里的位置指相对于该模型父节点的原点定义的，即其父节点的模型空间中的位置。若该 Transform 没有任何父节点，那么这个位置就是在世界坐标系中的位置。Rotation 和 Scale 也是同理。</p><p>顶点变换的第一步，就是将顶点坐标从模型空间变换到世界空间，这个变换通常叫做<strong>模型变换 model transform</strong>。</p><p>假设 Unity 中一个模型的一个顶点的模型坐标为 (0, 2, 4)。该模型没有父节点，其 Transform 组件上的信息为 Position：(5, 0, 25)；Rotation：(0, 150, 0)；Scale：(2, 2, 2)。注意变换的顺序，先缩放，再旋转，最后平移。据此构建变换矩阵：</p><script type="math/tex; mode=display">\begin{aligned} M_{model} &= \begin{bmatrix} 1 & 0 & 0 & t_x \\ 0 & 1 & 0 & t_y \\ 0 & 0 & 1 & t_z \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} \cos θ & 0 & \sin θ & 0 \\ 0 & 1 & 0 & 0 \\ - \sin θ & 0 & \cos θ & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} k_x & 0 & 0 & 0 \\ 0 & k_y & 0 & 0 \\ 0 & 0 & k_z & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \\ &= \begin{bmatrix} 1 & 0 & 0 & 5 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 25 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} -0.866 & 0 & 0.5 & 0 \\ 0 & 1 & 0 & 0 \\ -0.5 & 0 & -0.866 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} 2 & 0 & 0 & 0 \\ 0 & 2 & 0 & 0 \\ 0 & 0 & 2 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \\ &= \begin{bmatrix} -1.732 & 0 & 1 & 5 \\ 0 & 2 & 0 & 0 \\ -1 & 0 & -1.732 & 25 \\ 0 & 0 & 0 & 1 \end{bmatrix} \end{aligned}</script><p>接下来对顶点进行模型变换：  </p><script type="math/tex; mode=display">P_{world} = M_{model}P_{model} = \begin{bmatrix} -1.732 & 0 & 1 & 5 \\ 0 & 2 & 0 & 0 \\ -1 & 0 & -1.732 & 25 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} 0 \\ 2 \\ 4 \\ 1 \end{bmatrix} = \begin{bmatrix} 9 \\ 4 \\ 18.072 \\ 1 \end{bmatrix}</script><p>故该顶点的世界坐标为 (9, 4, 18.072)。</p><h3 id="观察空间-view-space"><a href="#观察空间-view-space" class="headerlink" title="观察空间 view space"></a>观察空间 view space</h3><p>观察空间也称为<strong>摄像机空间 camera space</strong>。Unity 中观察空间的坐标轴是：+x 轴指向右方，+y 轴指向上方，而 +z 轴指向摄像机后方。模型空间和世界空间是左手坐标系，而观察空间是右手坐标系，这是为了符合 OpenGL 传统：在观察空间中，摄像机的前方指向 -z 轴方向。</p><p>注意，观察空间和屏幕空间是不同的，观察空间是一个三维空间，屏幕空间是一个二维空间。从观察空间到屏幕空间需要<strong>投影 projection</strong> 操作。在后面讲到。</p><p>顶点变换的第二步，即把顶点坐标从世界坐标变换到观察空间里，这个变换称为<strong>观察变换 view transform</strong>。观察空间的原点位于摄像机处。有两种方式可以得到顶点在观察空间的位置。方法①：计算观察空间的三个坐标轴在世界空间下的表示，构建从观察空间变换到是世界空间的变换矩阵，再求逆得到从世界空间到观察空间的变换矩阵。方法②：想象平移观察空间，让摄像机位于世界坐标原点，坐标轴与世界坐标中的坐标轴重合。这两种方式得到的变换矩阵应该是一样的。</p><blockquote><p>因为矩阵变换得到的是原坐标系下的坐标，顶点在世界坐标的位置是已知的，为了得到观察世界坐标，需要将观察空间变换到世界空间，这个矩阵变换乘以顶点在世界坐标的位置即顶点在观察世界的坐标。</p></blockquote><p>这里演示第二种方法：假设摄像机面板中的 Transform 组件的信息为 Position (0, 10, -10)；Rotation (30, 0, 0)；Scale (1, 1, 1)。由于摄像机在世界空间中的变换是先按 (30, 0, 0) 进行旋转，然后按 (0, 10, -10) 平移，所以为了将摄像机移回原位置，需要进行逆向变换，即先按 (0, -10, 10) 平移，再按 (-30, 0, 0) 进行旋转，以便让坐标轴重合：  </p><script type="math/tex; mode=display">\begin{aligned} M_{model} &= \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & \cos θ & - \sin θ & 0 \\ 0 & \sin θ & \cos θ & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} 1 & 0 & 0 & t_x \\ 0 & 1 & 0 & t_y \\ 0 & 0 & 1 & t_z \\ 0 & 0 & 0 & 1 \end{bmatrix} \\ &= \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 0.866 & 0.5 & 0 \\ 0 & -0.5 & 0.866 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & -10 \\ 0 & 0 & 1 & 10 \\ 0 & 0 & 0 & 1 \end{bmatrix} \\ &= \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 0.866 & 0.5 & -3.66 \\ 0 & -0.5 & 0.866 & 13.66 \\ 0 & 0 & 0 & 1 \end{bmatrix} \end{aligned}</script><p>但是由于观察空间使用右手坐标系，需要对 z 分量进行取反操作：  </p><script type="math/tex; mode=display">M_{view} = M_{negateZ}M_{view} = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & -1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 0.866 & 0.5 & -3.66 \\ 0 & -0.5 & 0.866 & 13.66 \\ 0 & 0 & 0 & 1 \end{bmatrix} = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 0.866 & 0.5 & -3.66 \\ 0 & 0.5 & -0.866 & -13.66 \\ 0 & 0 & 0 & 1 \end{bmatrix}</script><p>然后对模型变换后的顶点进行观察变换：</p><script type="math/tex; mode=display">P_{view} = M_{view}P_{world} = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 0.866 & 0.5 & -3.66 \\ 0 & 0.5 & -0.866 & -13.66 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} 9 \\ 4 \\ 18.072 \\ 1 \end{bmatrix} = \begin{bmatrix} 9 \\ 8.84 \\ -27.31 \\ 1 \end{bmatrix}</script><p>即观察空间中顶点坐标为 (9, 8.84 , -27.31)。</p><h3 id="裁剪空间-clip-space"><a href="#裁剪空间-clip-space" class="headerlink" title="裁剪空间 clip space"></a>裁剪空间 clip space</h3><p>顶点接下来要从观察空间转化到裁剪空间，也被称为<strong>齐次裁剪空间</strong>。用于变换的矩阵叫做<strong>裁剪矩阵 clip matrix</strong>，也被称作<strong>投影矩阵 projection matrix</strong>。</p><p>裁剪空间的目的是能够方便地对渲染图元进行裁剪：完全位于这块空间内部地图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间相交的图元就会被裁剪。这块空间由<strong>视锥体 view frustum</strong> 决定。</p><p>视锥体由六个平面包围而成，这些平面被称为<strong>裁剪平面 clip planes</strong>，有两种投影类型：一种是<strong>正交投影 orthographic projection</strong>，一种是<strong>透视投影 perspective projection</strong>。在视锥体的六块裁剪平面中，有两块比较特殊，分别被称为<strong>近裁剪平面 near clip plane</strong> 和<strong>远裁剪平面 far clip plane</strong>。它们决定了摄像机可以看到的深度范围。</p><div  align="center">  <img src="https://s2.loli.net/2023/10/07/BfKUZVNHdocsTX5.jpg" width = "60%" height = "60%" alt="图6- 视锥体和裁剪平面。左图显示了透视投影的视锥体，右图显示了正交投影的视锥体。"/></div><p>可以看到透视投影的视椎体是一个被砍掉尖角的四棱锥形状，而正交投影是一个长方体。为了方便对两者进行统一的裁剪处理，我们需要把顶点通过投影矩阵转换到裁剪空间中进行判断。投影矩阵有两个目的：<br>①为投影操作做准备。这是个迷惑点，投影矩阵并不是真正地做投影操作，而是为投影操作做准备工作。真正的投影发生在<strong>齐次除法 homogeneous division</strong> 过程中，真正的投影可以理解为降维，而投影矩阵不是降维。而经过投影矩阵的变换后，顶点的 w 分量将会具有特殊的意义。<br>②对 x、y、z 分量进行缩放，经过投影矩阵的缩放后，可以直接使用 w 分量作为一个范围值，如果 x、y、z 分量都位于这个范围内，就说明顶点位于裁剪空间内。</p><p><strong><em>1. 透视投影</em></strong><br>视锥体的六个平面，在 Unity 中，由 Camera 组件中的参数和 Game 视图的纵横比共同决定。</p><div  align="center">  <img src="https://s2.loli.net/2023/10/07/UwORdaTrMtKDlhJ.jpg" width = "40%" height = "40%" alt="图7- 透视摄像机的参数对透视投影视锥体的影响。"/></div><p>Camera 组件的 Field of View（FOV）属性改变视椎体竖直方向的张开角度；Clipping Planes 的 Near 和 Far 分别对应视椎体近裁剪平面和远裁剪平面距离摄像机的远近；已知这两个属性，可以得到视椎体近裁剪平面、远裁剪平面的高度：  </p><script type="math/tex; mode=display">nearClipPlaneHeight = 2 \times Near \times \tan \frac {FOV}{2}</script><script type="math/tex; mode=display">farClipPlaneHeight = 2 \times Far \times \tan \frac {FOV}{2}</script><p>接下来可根据摄像机的横纵比求得远近裁剪平面的宽度。在 Unity 中，一个摄像机的横纵比由 Game 视图的横纵比和 Viewport Rect 中的 W 和 H 属性共同决定（在脚本中可以通过 Camera.aspect 修改）。即摄像机的横纵比 Aspect 为：  </p><script type="math/tex; mode=display">Aspect = \frac {nearClipPlaneWidth}{nearClipPlaneHeight} = \frac {farClipPlaneWidth}{farClipPlaneHeight}</script><p>可以根据已知的 Near、Far、FOV 和 Aspect 的值来确定透视投影的投影矩阵（cot 为余切，即正切 tan 的倒数）：</p><script type="math/tex; mode=display">M_{frustum} = \begin{bmatrix} \cfrac {\cot \cfrac {FOV}{2}}{Aspect} & 0 & 0 & 0 \\ 0 & \cot \cfrac {FOV}{2} & 0 & 0 \\ 0 & 0 & - \cfrac {Far + Near}{Far - Near} & - \cfrac {2 \cdot Far \cdot Near}{Far - Near} \\ 0 & 0 & -1 & 0 \end{bmatrix}</script><blockquote><p>公式的推导有兴趣花时间去学习计算机图形学</p></blockquote><p>此公式仅针对观察空间为右手坐标系，即 Unity 对坐标系的假定，变换后 z 分量范围在 [-w, w] 之间。若在类似 DirectX 这样的图形接口中，变换后 z 分量范围在 [0, w] 之间，那么需要调整该公式。</p><p>一个顶点与上述投影矩阵相乘后，可以由观察空间变换到裁剪空间，结果如下：</p><script type="math/tex; mode=display">\begin{aligned} P_{clip} = M_{frustum}P_{view} &= \begin{bmatrix} \cfrac {\cot \cfrac {FOV}{2}}{Aspect} & 0 & 0 & 0 \\ 0 & \cot \cfrac {FOV}{2} & 0 & 0 \\ 0 & 0 & - \cfrac {Far + Near}{Far - Near} & - \cfrac {2 \cdot Far \cdot Near}{Far - Near} \\ 0 & 0 & -1 & 0 \end{bmatrix} \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} \\ &= \begin{bmatrix} x \cfrac {\cot \cfrac {FOV}{2}}{Aspect} \\ y \cot \cfrac {FOV}{2} \\ -z \cfrac {Far + Near}{Far - Near} - \cfrac {2 \cdot Far \cdot Near}{Far - Near} \\ -z \end{bmatrix} \end{aligned}</script><p>可以看出，投影矩阵本质上就是对 x、y、z 分量进行了不同程度的缩放，其目的是为了方便裁剪。而 w 分量也由 1 变成了 z 分量取反。若新的 x、y、z 分量满足大小在 [-w, w] 之间，则该点在视椎体内。任何不满足上述条件的图元都需要被剔除或者裁剪。视锥体变化如下图：  </p><div  align="center">  <img src="https://s2.loli.net/2023/10/07/1O2hYSysL6Pfupg.jpg" width = "70%" height = "70%" alt="图8- 在透视投影中，投影矩阵对顶点进行了缩放。图中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出 x、y、z 和 w 分量的范围发生的变化。"/></div><p>注意：裁剪矩阵会改变空间的旋向性，空间从观察空间的右手坐标系变换到了裁剪矩阵的左手坐标系。</p><p><strong><em>2. 正交投影</em></strong><br>同透视投影，正交投影的视锥体的六个平面，在 Unity 中，也是由 Camera 组件中的参数和 Game 视图的纵横比共同决定。</p><div  align="center">  <img src="https://s2.loli.net/2023/10/07/k86bRY4fqShvdnM.jpg" width = "40%" height = "40%" alt="图9- 正交摄像机的参数对正交投影视锥体的影响。"/></div><p>Camera 组件的 Size 属性表示视椎体竖直方向上高度的一半；Clipping Planes 的 Near 和 Far 控制视椎体的近裁剪平面、远裁剪平面距离摄像机的远近。即：</p><script type="math/tex; mode=display">nearClipPlaneHeight = 2 \cdot Size</script><script type="math/tex; mode=display">farClipPlaneHeight = nearClipPlaneHeight</script><p>假设摄像机的横纵比为 Aspect，则：  </p><script type="math/tex; mode=display">nearClipPlaneWidth = Aspect \cdot nearClipPlaneHeight</script><script type="math/tex; mode=display">farClipPlaneWidth = nearClipPlaneWidth</script><p>可以根据已知的 Near、Far、Size 和 Aspect 的值来确定正交投影的投影矩阵：  </p><script type="math/tex; mode=display">M_{ortho} = \begin{bmatrix} \cfrac {1}{Aspect \cdot Size} & 0 & 0 & 0 \\ 0 & \cfrac {1}{Size} & 0 & 0 \\ 0 & 0 & - \cfrac {2}{Far - Near} & - \cfrac {Far + Near}{Far - Near} \\ 0 & 0 & 0 & 1 \end{bmatrix}</script><p>一个顶点和上述投影矩阵相乘后的结果如下：  </p><script type="math/tex; mode=display">\begin{aligned} P_{clip} = M_{ortho}P_{view} &= \begin{bmatrix} \cfrac {1}{Aspect \cdot Size} & 0 & 0 & 0 \\ 0 & \cfrac {1}{Size} & 0 & 0 \\ 0 & 0 & - \cfrac {2}{Far - Near} & - \cfrac {Far + Near}{Far - Near} \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} \\ &= \begin{bmatrix} \cfrac {x}{Aspect \cdot Size} \\ \cfrac {y}{Size} \\ - \cfrac {2z}{Far - Near} - \cfrac {Far + Near}{Far - Near} \\ 1 \end{bmatrix} \end{aligned}</script><p>与透视投影矩阵不同的是，正交投影的投影矩阵对顶点变换后，w 分量仍然是 1 。本质是因为透视投影的投影矩阵的最后一行是 [0, 0, -1, 0]，而正交投影的投影矩阵的最后一行是 [0, 0, 0, 1]。这样选择的目的是为了给齐次除法做准备。</p><p>判断一个变换后的顶点是否位于视锥体内和透视投影方法一样。正交投影的视锥体变化如下图：  </p><div  align="center">  <img src="https://s2.loli.net/2023/10/12/qQ4lnaTFcP7ILsw.jpg" width = "70%" height = "70%" alt="图10- 在正交投影中，投影矩阵对顶点进行了缩放。图中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出 x、y、z 和 w 分量范围发生的变化。"/></div><p>同样，裁剪矩阵改变了空间的旋向性。</p><p><strong><em>3. 示例</em></strong><br>根据观察空间得到的顶点坐标 (9, 8.84 , -27.31)，假设透视投影的摄像机参数为 FOV 60°，Near 为 5，Far 为 40，Aspect 为 4/3。</p><script type="math/tex; mode=display">p_{clip} = M_{frustum}P_{view} = \begin{bmatrix} 1.299 & 0 & 0 & 0 \\ 0 & 1.732 & 0 & 0 \\ 0 & 0 & -1.286 & -11.429 \\ 0 & 0 & -1 & 0 \end{bmatrix} \begin{bmatrix} 9 \\ 8.84 \\ -27.31 \\ 1 \end{bmatrix} = \begin{bmatrix} 11.691 \\ 15.311 \\ 23.692 \\ 27.31 \end{bmatrix}</script><p>可以看到 x、y、z 都是在 -27.31 到 27.31 之间的。故该点在视锥体内，不需要被裁剪。</p><h3 id="屏幕空间-screen-space"><a href="#屏幕空间-screen-space" class="headerlink" title="屏幕空间 screen space"></a>屏幕空间 screen space</h3><p>完成裁剪操作后，就需要进行真正的投影了，即把视锥体投影到屏幕空间中，从而得到像素位置。将顶点从裁剪空间投影到屏幕空间中，来生成对应的 2D 坐标的过程需要两个步骤：</p><p>首先，需要进行标准<strong>齐次除法 homogeneous division</strong>，也被称为<strong>透视除法 perspective division</strong>。其实就是用齐次坐标的 w 分量去除 x、y、z 分量。在 OpenGL 中把这一步得到的坐标叫做<strong>归一化的设备坐标 Normalized Device Coordinates, NDC</strong>。裁剪空间经过齐次除法后会变换到一个立方体内。OpenGL 中（Unity 也是），这个立方体的 x、y、z 分量范围都是 [-1, 1]，而在 DirectX 中，z 的分量范围是 [0, 1]。</p><div  align="center">  <img src="https://s2.loli.net/2023/10/12/Z3qcg21n9sXWlm5.jpg" width = "70%" height = "70%" alt="图11- 经过齐次除法后，透视投影的裁剪空间会变换到一个立方体。"/></div><p>对于正交投影，因为裁剪空间已经是一个立方体了，w 分量为 1，所以齐次除法不产生影响。</p><p>第二步，根据变换后的 x 和 y 坐标来映射输出窗口的对应像素坐标。在 Unity 中，屏幕空间左下角的屏幕坐标是 (0, 0)，右上角的屏幕坐标是 (pixelWidth, pixelHeight)。由于当前 x 和 y 坐标都是 [-1, 1] ，因此这个映射的过程就是一个缩放的过程。</p><p>齐次除法和屏幕映射的过程可以使用下面的公式来总结：  </p><script type="math/tex; mode=display">screen_x = \frac {clip_x \cdot pixelWidth}{2 \cdot clip_w} + \frac {pixelWidth}{2}</script><script type="math/tex; mode=display">screen_y = \frac {clip_y \cdot pixelWidth}{2 \cdot clip_w} + \frac {pixelWidth}{2}</script><p>z 分量将被用于深度缓冲，也就是用来判断物体哪个离摄像机更近，更近的物体将遮挡更远的物体。$clip_w$ 在后续的一些工作中，比如透视校正插值，也会起到重要作用。</p><p>在 Unity 中，裁剪空间到屏幕空间的转换是底层帮我们实现的，我们只需要在顶点着色器中将顶点坐标转换到裁剪空间内即可。</p><p>从上一步中，裁剪空间的顶点的位置是 (11.691, 15.311, 23.692, 27.31)。假设屏幕的像素宽度为 400，高度为 300。过程如下：</p><script type="math/tex; mode=display">screen_x = \frac {11.691 \cdot 400}{2 \cdot 27.31} + \frac {400}{2} = 285.617</script><script type="math/tex; mode=display">screen_y = \frac {15.311 \cdot 300}{2 \cdot 27.31} + \frac {300}{2} = 234.096</script><p>故该顶点在屏幕上的位置为 (285.617, 234.096)。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>顶点着色器中最基本的任务是把顶点坐标从模型空间转换到裁剪空间，通常可以直接使用内置的 MVP 矩阵来实现。</p><p>下表总结了 Unity 中各个空间使用的坐标系旋向性：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">模型空间</th><th style="text-align:left">世界空间</th><th style="text-align:left">观察空间</th><th style="text-align:left">裁剪空间</th><th style="text-align:left">屏幕空间</th></tr></thead><tbody><tr><td style="text-align:left">左手坐标系</td><td style="text-align:left">左手坐标系</td><td style="text-align:left">右手坐标系</td><td style="text-align:left">左手坐标系</td><td style="text-align:left">左手坐标系</td></tr></tbody></table></div><p>还有一些空间在实际开发中也会遇到，例如<strong>切线空间 tangent space</strong>。切线空间通常用于法线映射，见后面。</p><h2 id="法线变换"><a href="#法线变换" class="headerlink" title="法线变换"></a>法线变换</h2><p><strong>法线 normal</strong>，也被称为<strong>法矢量 normal vector</strong>。模型的一个顶点往往会携带额外的信息，顶点法线就是其中一个信息，变换顶点时，也需要变换顶点法线，以便在片元着色器中计算光照。</p><p><strong>切线 tangent</strong>，也称<strong>切矢量 tangent vector</strong>，模型顶点携带的信息中也包含它，它通常和纹理空间对齐，并且与法线垂直。</p><p>一般来说，点和绝大部分方向矢量都可以使用同一个 4 × 4 或 3 × 3 的变换矩阵把其从坐标空间 A 变换到坐标空间 B 中，但在变换法线的时候，如果使用同一个变换矩阵，就无法确保维持法线的垂直性。如下图：  </p><div  align="center">  <img src="https://s2.loli.net/2023/10/13/uSbKMsQidHhEcyO.jpg" width = "60%" height = "60%" alt="图12- 进行非统一缩放时，如果使用和变换顶点相同的变换矩阵来变换法线，就会得到错误的结果，即变换后的法线方向与平面不再垂直。"/></div><p>由于切线是有两个顶点之间的差值计算得到的，因此我们可以直接使用用于顶点变换的矩阵来变换切线。假设，使用 3x3 的变换矩阵来变换顶点（法线不受平移影响，因此使用 3x3），可以由下面的式子直接得到变换后的切线：</p><script type="math/tex; mode=display">T_B = M_{A \to B}T_A</script><p>如果直接使用上述矩阵来变换法线，得到的新的法线方法可能不与表面垂直。为了得到正确的法线变换矩阵，我们使用由数学约束条件来推导，即切线 $T_A$ 和法线 $N_A$ 互相垂直：$T_A \cdot N_A = 0$。若给定切线变换矩阵 $M_{A \to B}$ ，要找到找到矩阵 G 来变换法线 $N_A$，使得变换后的法线仍然垂直于切线：</p><script type="math/tex; mode=display">T_B \cdot N_B = (M_{A \to B}T_A) \cdot (GN_A) = 0</script><p>对上面式子推导可得：  </p><script type="math/tex; mode=display">(M_{A \to B}T_A) \cdot (GN_A) = (M_{A \to B}T_A)^T(GN_A) = T_A^TM_{A \to B}^TGN_A = T_A^T(M_{A \to B}^TG)N_A = 0</script><p>由于 $T_A \cdot N_A = 0$，因此如果 $M_{A \to B}^TG = I$，那么上式成立。即，$G = (M_{A \to B}^T)^{-1} = (M_{A \to B}^{-1})^T$，即使用原变换矩阵的逆转置矩阵来变换法线就可以得到正确的结果。</p><p>如果变换矩阵 $M_{A \to B}$ 是正交矩阵，那么 $M_{A \to B}^{-1} = M_{A \to B}^T$，因此 $(M_{A \to B}^T)^{-1} = M_{A \to B}$，也就是说我们可以使用用于变换顶点的变换矩阵直接变换法线。</p><p>如果变换只包含旋转变换，那么这个矩阵变换就是正交矩阵。而如果变换只包含旋转和统一缩放，而不包含非统一缩放，我们可以利用统一缩放系数 k 来得到变换矩阵 $M_{A \to B}$ 的逆转置矩阵 $(M_{A \to B}^T)^{-1} = \cfrac {1}{k} M_{A \to B}$。如果变换中包含了非统一变换，那么我们就必须要求解逆矩阵来得到变换法线的矩阵。</p><h2 id="Unity-Shader-的内置变量（数学篇）"><a href="#Unity-Shader-的内置变量（数学篇）" class="headerlink" title="Unity Shader 的内置变量（数学篇）"></a>Unity Shader 的内置变量（数学篇）</h2><p>Unity 内置了很多参数来方便我们编写 Shader，让我们无需手动计算一些值，这些内置变量封装在 Unity 的内置文件 UnityShaderVariables.cginc 中。</p><h3 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h3><p>下表给出了 Unity 的内置变换矩阵，下面的矩阵都是 float4×4 类型的：</p><div class="table-container"><table><thead><tr><th style="text-align:left">变量名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">UNITY_MATRIX_MVP</td><td style="text-align:left">当前的的模型观察投影矩阵，用于将顶点/方向矢量从模型空间变换到裁剪空间</td></tr><tr><td style="text-align:left">UNITY_MATRIX_MV</td><td style="text-align:left">当前的模型观察矩阵，用于将顶点/方向矢量从模型空间变换到观察空间</td></tr><tr><td style="text-align:left">UNITY_MATRIX_V</td><td style="text-align:left">当前的观察矩阵，用于将顶点/方向矢量从世界空间变换到观察空间</td></tr><tr><td style="text-align:left">UNITY_MATRIX_P</td><td style="text-align:left">当前的投影矩阵，用于将顶点/方向矢量从观察空间变换到裁剪空间</td></tr><tr><td style="text-align:left">UNITY_MATRIX_VP</td><td style="text-align:left">当前的观察投影矩阵，用于将顶点/方向矢量从世界空间变换到裁剪空间</td></tr><tr><td style="text-align:left">UNITY_MATRIX_T_MV</td><td style="text-align:left">UNITY_MATRIX_MV 的转置</td></tr><tr><td style="text-align:left">UNITY_MATRIX_IT_MV</td><td style="text-align:left">UNITY_MATRIX_MV 的逆转置矩阵，用于将法线从模型空间变换到观察空间，也可以用于得到 UNITY_MATRIX_MV 的逆矩阵</td></tr><tr><td style="text-align:left">_Object2World</td><td style="text-align:left">当前的模型矩阵，用于将顶点/方向矢量从模型空间变换到世界空间</td></tr><tr><td style="text-align:left">_World2Object</td><td style="text-align:left">_Object2World 的逆矩阵，用于将顶点/方向矢量从世界空间变换到模型空间</td></tr></tbody></table></div><p>需要关注的特殊矩阵： </p><p>①UNITY_MATRIX_T_MV<br>如果 UNITY_MATRIX_MV 是一个正交矩阵，则 UNITY_MATRIX_T_MV 就是它的逆矩阵，可以使用 UNITY_MATRIX_T_MV 把顶点和方向矢量从观察空间变换到模型空间。<br>&emsp;&emsp; - 如果一个模型的变换只包含旋转，那么 UNITY_MATRIX_MV 就是一个正交矩阵。<br>&emsp;&emsp; - 如果一个模型的变换只包含旋转和统一缩放（假设缩放系数是 k ），那么 UNITY_MATRIX_MV 几乎是正交矩阵，为什么是几乎？因为统一缩放可能会导致每一行（或每一列）的矢量长度不为 1，而是 k，这不符合正交矩阵的特性，但我们可以通过除以 k 将其变成正交矩阵，这种情况下，UNITY_MATRIX_MV 的逆矩阵就是 $\cfrac {1}{k} $ UNITY_MATRIX_T_MV。<br>&emsp;&emsp; - 如果我们只对方向矢量进行变换，即不用考虑平移变换，可以截取 UNITY_MATRIX_T_MV 的前3行3列来把方向矢量从观察空间变换到模型空间，对于方向矢量可以提前进行归一化处理以消除统一缩放的影响。</p><p>②UNITY_MATRIX_IT_MV<br>法线的变换需要使用原变换矩阵的逆转置矩阵，因此 UNITY_MATRIX_IT_MV 可以把法线从模型空间变换到观察空间。此外我们也可以对其进行转置得到 UNITY_MATRIX_MV 的逆矩阵。</p><p>把顶点和方向矢量从观察空间变换到模型空间，可以使用类似以下的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 方法一：使用 transpose 函数对 UNITY_MATRIX_IT_MV 进行转置，</span><br><span class="line">// 得到 UNITY_MATRIX_MV 的逆矩阵，然后进行矩阵乘法</span><br><span class="line">// 把观察空间中的点或方向矢量变换到模型空间中</span><br><span class="line">float4 modelPos = mul(transpose(UNITY_MATRIX_IT_MV), viewPos);</span><br><span class="line"></span><br><span class="line">// 方法二：不直接使用转置函数 transpose，而是交换 mul 参数的位置，使用行矩阵乘法</span><br><span class="line">// 本质和方法一完全一样(原因见后面章节)</span><br><span class="line">float4 modelPos = mul(viewPos, UNITY_MATRIX_IT_MV);</span><br></pre></td></tr></table></figure><h3 id="摄像机和屏幕参数"><a href="#摄像机和屏幕参数" class="headerlink" title="摄像机和屏幕参数"></a>摄像机和屏幕参数</h3><p>Unity 内置的摄像机和屏幕参数</p><div class="table-container"><table><thead><tr><th style="text-align:left">变量名</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">_WorldSpaceCameraPos</td><td style="text-align:left">float3</td><td style="text-align:left">摄像机在世界空间的位置</td></tr><tr><td style="text-align:left">_ProjectionParams</td><td style="text-align:left">float4</td><td style="text-align:left">x = 1.0 (或 -1.0，如果正在使用一个翻转的投影矩阵进行渲染)，y = Near，z = Far，w = 1.0 + 1.0 / Far，其中 Near 和 Far 分别是近远裁剪平面和摄像机的距离</td></tr><tr><td style="text-align:left">_ScreenParams</td><td style="text-align:left">float4</td><td style="text-align:left">x = width，y = height，z = 1.0 + 1.0 / width，w = 1.0 + 1.0 / height，其中 width 和h eight 分别是该摄像机的渲染目标的像素宽度和高度</td></tr><tr><td style="text-align:left">_ZBufferParams</td><td style="text-align:left">float4</td><td style="text-align:left">x = 1 - Far / Near，y = Far / Near，z = x / Far，w = y / Far，该变量用于线性化 z 缓存中的深度值</td></tr><tr><td style="text-align:left">unity_OrthoParams</td><td style="text-align:left">float4</td><td style="text-align:left">x = width，y = height，z 没有定义，w = 1.0(正交摄像机)或 0.0(透视摄像机)，其中 width 和 height 是正交投影摄像机的宽度和高度</td></tr><tr><td style="text-align:left">unity_CameraProjection</td><td style="text-align:left">float4x4</td><td style="text-align:left">该摄像机的投影矩阵</td></tr><tr><td style="text-align:left">unity_CameraInvProjection</td><td style="text-align:left">float4x4</td><td style="text-align:left">该摄像机的投影矩阵的逆矩阵</td></tr><tr><td style="text-align:left">unity_CameraWorldClipPlanes[6]</td><td style="text-align:left">float4</td><td style="text-align:left">摄像机的 6 个裁剪平面在空间下的等式，按左右下上近远裁剪平面的顺序</td></tr></tbody></table></div><h2 id="Cg-中的矢量和矩阵类型"><a href="#Cg-中的矢量和矩阵类型" class="headerlink" title="Cg 中的矢量和矩阵类型"></a>Cg 中的矢量和矩阵类型</h2><p>通常在 Unity Shader 中使用 Cg 作为着色器编程语言。在 Cg 中，矩阵类型是由 float3×3 等关键词定义的。对于 float3、float4 等类型的变量，可以把它当作行向量或者列向量，这取决于运算的种类以及它们在运算中的位置。例如，向量点积：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float4 a = float4(1.0, 2.0, 3.0, 4.0);</span><br><span class="line">float4 a = float4(1.0, 2.0, 3.0, 4.0);</span><br><span class="line">float result = dot(a, b);   // 进行点积操作</span><br></pre></td></tr></table></figure><p>在矩阵乘法中，参数位置将决定按列矩阵还是行矩阵进行乘法。在 Cg 中，矩阵乘法是通过 <code>mul</code> 函数实现的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float4 v = float4(1.0, 2.0, 3.0, 4.0);</span><br><span class="line">float4x4 M = float4x4(1.0, 0.0, 0.0, 0.0</span><br><span class="line">      0.0, 1.0, 0.0, 0.0</span><br><span class="line">      0.0, 0.0, 1.0, 0.0</span><br><span class="line">      0.0, 0.0, 0.0, 1.0);</span><br><span class="line">// 列向量矩阵右乘</span><br><span class="line">float4 column_mul_result = mul(M, v); </span><br><span class="line">// 行向量矩阵左乘</span><br><span class="line">float4 row_mul_result = mul(v, M); </span><br><span class="line">// 注意：column_mul_result 不等于 row_mul_result，而是：</span><br><span class="line">// mul(M, v) == mul(v, transpose(M))</span><br><span class="line">// mul(v, M) == mul(transpose(M), v)</span><br></pre></td></tr></table></figure><p>一般使用右乘方式，因为 Unity 提供的内置矩阵都是按列存储的。有时使用左乘的方式是为了省去对矩阵转置的操作。在 Cg 中，对 float4×4 等类型的变量是按行优先的方式进行填充的，索引同理。但是 Unity 脚本提供的矩阵类型 Matrix4×4 是列优先的方式。</p><h2 id="Unity-中的屏幕坐标：ComputeScreenPos-VPOS-WPOS"><a href="#Unity-中的屏幕坐标：ComputeScreenPos-VPOS-WPOS" class="headerlink" title="Unity 中的屏幕坐标：ComputeScreenPos/VPOS/WPOS"></a>Unity 中的屏幕坐标：ComputeScreenPos/VPOS/WPOS</h2><p>之前讲了屏幕空间的转换。在写 Shader 中，有时希望获取片元在屏幕上的像素位置。在顶点/片元着色器中，有两种方式类获取片元的屏幕坐标。</p><p>①在片元着色器的输入中声明 VPOS 或 WPOS 语义<br><strong>VPOS</strong> 是 HLSL 对屏幕坐标的语义，<strong>WPOS</strong> 是 Cg 对屏幕坐标的语义（语义见后面一章节）。两者在 Unity Shader 中是等价的。可以在 HLSL/Cg 中通过语义的方式来定义顶点/片元着色器的默认输入，而不需要自己定义输入输出的数据结构。使用这种方法，可以在片元着色器中这样写：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 frag(float4 sp : VPOS) : SV_Target &#123;</span><br><span class="line">    // 用屏幕坐标除以屏幕分辨率 _ScreenParams.xy，得到视口空间中的坐标</span><br><span class="line">    return fixed4(sp.xy/_ScreenParams.xy, 0.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VPOS/WPOS 语义定义的输入是一个 float4 类型的变量。<br>xy 值代表了屏幕空间中的像素坐标。如果屏幕分辨率为 400 × 300，那么 x 的范围就是 [0.5, 400.5]，y 的范围是 [0.5, 300.5]。这里的像素坐标不是整数值是因为 OpenGL 和 DirectX 10 以后的版本认为像素中心对应的是浮点数中的 0.5。</p><p>在 Unity 中，VPOS/WPOS 的 z 分量范围是 [0, 1]，在摄像机的近裁剪平面处，z 为 0，在远裁剪平面处，z 为 1。</p><p>对于 w，若使用的是透视投影，那么 w 分量范围在 [1/Near, 1/Far]，若使用正交投影，w 分量为 1。这个值是对经过投影矩阵变换后的 w 分量取倒数后得到的。</p><p>在上述代码的最后，屏幕空间除以屏幕分辨率得到的是<strong>视口空间 viewport space</strong> 中的坐标。视口坐标即归一化的屏幕坐标，左下角为 (0, 0)，右上角为 (1, 1)。</p><p>②通过 Unity 提供的 <strong>ComputeScreenPos</strong> 函数<br>这个函数在 UnityCG.cginc 里被定义。通常有两个步骤，先在顶点着色器中将 ComputeScreenPos 的结果保存在输出结构体中，然后在片元着色器中进行一个齐次除法运算后得到视口空间中的坐标。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct vertOut &#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    float4 scrPos : TEXCOORD0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vertOut vert(appdata_base v) &#123;</span><br><span class="line">    vertOut o;</span><br><span class="line">    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">    // 第一步：把 ComputeScreenPos 结果保存到 scrPos 中</span><br><span class="line">    o.scrPos = ComputeScreenPos(o.pos);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(vertOut i) : SV_Target &#123;</span><br><span class="line">    // 第二步：用 scrPos.xy 除以 scrPos.w 得到视口空间中的坐标</span><br><span class="line">    float2 wcoord = (i.scrPos.xy/i.scrPos.w);</span><br><span class="line">    return fixed4(wcoord, 0.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码实现效果和第一种方式是一样的。之前说过如何将裁剪空间坐标映射到屏幕空间坐标，据此可以得到视口空间中的坐标，公式如下：  </p><script type="math/tex; mode=display">viewport_x = \frac {clip_x}{2 \cdot clip_w} + \frac {1}{2}</script><script type="math/tex; mode=display">viewport_y = \frac {clip_y}{2 \cdot clip_w} + \frac {1}{2}</script><p>上面的公式本质就是，先对裁剪空间下的坐标进行齐次除法，得到范围在 [-1, 1] 的 NDC ，然后再将其映射到范围在 [0, 1] 的视口空间下的坐标。在 UnityCG.cginc 文件中的 ComputeScreenPos 函数的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline float4 ComputeScreenPos(float4 pos) &#123;</span><br><span class="line">    float4 o = pos * 0.5f;</span><br><span class="line">    #if defined(UNITY_HALF_TEXEL_OFFSET)</span><br><span class="line">    o.xy = float2(o.x, o.y * _ProjectionParams.x) + o.w * _ScreenParams.zw;</span><br><span class="line">    #else</span><br><span class="line">    o.xy = float2(o.x, o.y * _ProjectionParams.x) + o.w;</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    o.zw = pos.zw;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ComputeScreenPos 的输入参数 pos 是经过 MVP 矩阵变换后在裁剪空间中的顶点坐标。UNITY_HALF_TEXEL_OFFSET 是 Unity 在某些 DirectX 平台上使用的宏，这里先忽略。先只关注 #else 的部分。_ProjectionParams.x 在默认情况下是 1（如果使用了一个翻转的投影矩阵就是 -1）。那么上述代码实际上输出了：  </p><script type="math/tex; mode=display">Output_x = \frac {clip_x}{2} + \frac {clip_w}{2}</script><script type="math/tex; mode=display">Output_y = \frac {clip_y}{2} + \frac {clip_w}{2}</script><script type="math/tex; mode=display">Output_z = clip_z</script><script type="math/tex; mode=display">Output_w = clip_w</script><p>显然，这里的 xy 不是真正的视口空间下的坐标。因此需要在片元着色器中进行一步处理，即除以裁剪坐标的 w 分量。所以，虽然 ComputeScreenPos 的函数名看起来意味着会直接得到屏幕空间中的位置，但并不是这样的。</p><blockquote><p>Unity 为什么不直接在 ComputeScreenPos 中进行除以 w 分量的操作？因为如果 Unity 在顶点着色器这么做会破坏插值的结果。从顶点着色器到片元着色器的过程有一个插值的过程。如果我们直接在顶点着色器中进行这个除法，就需要对 x/w 和 y/w 直接进行插值，这样插值的结果会不准确。因为不可以在投影空间中进行插值，因为投影空间不是线性空间，而插值往往是线性的。</p></blockquote><p>经过除法操作后，视口坐标的 xy 范围都在 [0, 1] 之间。视口坐标的 zw 值，可以从 ComputeScreenPos 函数以及在顶点着色器中直接把裁剪空间的 zw 值存进结构体中看出，片元着色器输入的就是这些插值后的裁剪空间中的 zw 值。即若使用的是透视投影，z 的范围为 [-Near, Far]，w 的范围是 [Near, Far]；如果是正交投影，z 的范围为 [-1, 1]，而 w 值恒为 1。</p>]]></content>
      
      
      <categories>
          
          <category> unity </category>
          
          <category> unity shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> unity </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国证券市场基础名词解释</title>
      <link href="/2023/07/12/2023-07-12-%E8%82%A1%E5%B8%82%E5%9F%BA%E7%A1%80%E5%90%8D%E8%AF%8D/"/>
      <url>/2023/07/12/2023-07-12-%E8%82%A1%E5%B8%82%E5%9F%BA%E7%A1%80%E5%90%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章记录炒股投资相关基础名词。本人会计和金融出身，对比较熟悉的内容，特别是基本面内容，不会再行描述。<br>在考证时，为他人而学，愿意花费上千小时学习；但是炒股，为自己而学，为自己财务自由，却从未花费大量时间学习。这是何其的讽刺。  </p></blockquote><h1 id="股票股市基础"><a href="#股票股市基础" class="headerlink" title="股票股市基础"></a>股票股市基础</h1><h2 id="金融法律相关应了解的名词"><a href="#金融法律相关应了解的名词" class="headerlink" title="金融法律相关应了解的名词"></a>金融法律相关应了解的名词</h2><h3 id="不复权、前复权、后复权"><a href="#不复权、前复权、后复权" class="headerlink" title="不复权、前复权、后复权"></a>不复权、前复权、后复权</h3><p><strong>复权</strong>：股票由于公司分红、送股、拆股、合股等行为会导致其股价异常变动，但对应公司资产实际价值并没有发生变化。复权就是对股价和成交量进行权息修复，按照股票的实际涨跌绘制股价走势图，并把成交量调整为相同的股本口径。</p><p><strong>不复权</strong>：当股票股价因为分红拆股等原因变化时，不填补股价走势图上的巨大空隙，仍然保持股票历史和当天的交易价格即为不复权。</p><p><strong>前复权</strong>：保持现有股价不变，以目前股价为基准调整股票历史价格，把因为分红拆股等行为导致的股价变化进行相应比例调整以保持股价走势的连续性即为前复权。以特斯拉拆股为例说明，拆股前每股约900美元，1股拆3股后，每股变成300美元，那前复权就是把拆股之前的股价都除以3即可。前复权当前价格是最新的实际交易价格，且K线均线的走势是连续的，比较符合投资者的交易习惯，适合人工交易方式。</p><p><strong>后复权</strong>：保持历史股价不变，以上市首日股价为基准调整股票后续价格，把因为分红拆股等行为导致的股价变化进行相应比例调整以保持股价走势的连续性即为后复权。通过后复权我们可以看出该股上市以来累计涨幅，即上市时买入且参与全部配送、分红一直持有到目前的股价涨幅。但这会导致当前股票价格显示的不是实际成交价，不太符合投资者的交易习惯，可能会影响短期投资行为。</p><h3 id="除权除息相关红利税"><a href="#除权除息相关红利税" class="headerlink" title="除权除息相关红利税"></a>除权除息相关红利税</h3><p><strong>沪市</strong>的股票在<em>除权除息日当天</em>股票名称前会冠以<strong>DR</strong>、<strong>XD</strong>或<strong>XR</strong>等标识；<strong>深市</strong>在除权除息日当天股票名称不会有任何标识。</p><p><strong>XD</strong>（ex dividend）：<strong>除息日</strong>；<br><strong>XR</strong>（ex right）：<strong>除权日</strong>；<br><strong>DR</strong>：<strong>除权除息日</strong>。</p><blockquote><p>除息报价 = 股息登记日收盘价 - 每股现金股利（股息）；<br>送股除权报价=股权登记日收盘价/（1+送股率）；<br>配股除权报价=（股权登记日收盘价+配股价*配股率）/（1+配股率）。</p></blockquote><p><strong>红利税</strong>：股市分红有派现、送股和转增股(转增股又分为资本公积转增和盈余公积转增)，派现、送股和盈余公积转增要收取红利税，送股部分每股按1元面额计算红利税，资本公积转增一般不收取税（具体是否扣税需查看公告）。</p><p>2015年9月8日起，个人从公开发行和转让市场取得的上市公司股票，持股期限超过1年的，股息红利所得暂免征收个人所得税。<strong>即持股超过1年的，税负为0%；持股1个月至1年的（含1年），税负为10%；持股1个月以内的（含1个月），税负为20%</strong>。投资者持股时间是从投资者买入该股当天计算的，在投资者卖出股票时从资产中扣取。</p><h3 id="国债逆回购"><a href="#国债逆回购" class="headerlink" title="国债逆回购"></a>国债逆回购</h3><p>国债逆回购的<strong>手续费</strong>是默认的：1 天手续费为国债回购成交金额的 0.001%、2 天手续费为国债回购成交金额的 0.002%、3 天手续费为国债回购成交金额的 0.003%、4 天手续费为国债回购成交金额的 0.004%、7 天手续费为国债回购成交金额的 0.005%、14 天手续费为国债回购成交金额的 0.010%、28 天手续费为国债回购成交金额的 0.020%、91 天手续费为国债回购成交金额的 0.030%、182 天手续费为国债回购成交金额的 0.030%。</p><p>国债逆回购的计息天数是指实际占款天数，即当次回购交易的首次交收日（包含）至到期交收日（不含）的实际日历天数。<strong>所以周四买入一天期的国债逆回购可以享受周五、周六和周日三天利息</strong>，但是假设投资者在周五进行逆回购，那么：1日国债逆回购：资金到期日为下周一，资金到期日为下周二，计息日为1日；2日国债逆回购：资金到期日为下周一，资金到期日为下周二，计息日为1天；3日国债逆回购：资金到期日为下周一，资金到期日为下周二，计息日为1天。然而3日国债逆回购的手续费仍然是三天，<strong>所以不要在周五选择2日国债逆回购和3日国债逆回购。</strong></p><p><strong>在季末、半年末、年末、法定节假日前购买国债逆回购，这时国债逆回购的利息较高。</strong></p><h2 id="技术面相关名词"><a href="#技术面相关名词" class="headerlink" title="技术面相关名词"></a>技术面相关名词</h2><blockquote><p>本人认为技术指标只是历史市场情绪的反应，具有滞后性，在震荡行情中指导意义不大。其本身具有良好的参考价值，但尽信不如不信。</p></blockquote><h3 id="MA"><a href="#MA" class="headerlink" title="MA"></a>MA</h3><p><strong>Moving Average，MA：移动平均线</strong>，将一定时期内的证券价格、指数或成交量等加以<strong>算术平均</strong>，并把不同时间的平均值连接起来，形成一根 MA。N日移动平均线 = N日收市价之和 / N。</p><h3 id="EMA"><a href="#EMA" class="headerlink" title="EMA"></a>EMA</h3><p><strong>Exponential Moving Average，EMA：指数平均数指标</strong>，是一种指数加权平均，当日 EMA = α * 当日指数值 + ( 1 - α ) * 昨日指数平均值。其中平滑系数 α 为周期单位 +1 的值的一半。一般取作 2 / ( N+1 ) 。在计算 MACD 指标时，EMA 计算中的 N 一般选取 12 和 26 天，因此 α 相应为 2/13 和 2/27。</p><p>其原理公式没了解地很清楚，只要知道在 EMA 指标中，EMA 是对每天股价的加权平均，时间越近，权重越大，而且是指数式的，所以叫做指数加权平均。<strong>EMA 函数对近期价格加强了权重比，更能及时地反应近期价格波动情况，相对于 MA</strong>。</p><h3 id="MACD"><a href="#MACD" class="headerlink" title="MACD"></a>MACD</h3><blockquote><p>MACD 的信号可以理解为市场情绪的转变达到了一定的程度（这个程度到底是多少，无法得知），具有滞后性。只作参考，尽信不如不信。</p></blockquote><p><strong>Moving Average Convergence and Divergence，MACD：异同移动平均线</strong>，由两线一柱组合起来形成，包括快速线 DIF 线、慢速线 DEA 线和柱状图 MACD 柱组成。DIF 线为快速移动平均线 EMA12 与慢速移动平均线 EMA26 之差，DEA 线为 DIF 线的 9 日平均值，MACD 柱为 2 ×（DIF - DEA）。</p><p><strong>DIF，离差值</strong>：DIF = 当日EMA（12）－当日EMA（26），DIF 值为两条指数均线的差值，反映的是两条指数均线聚合与分离的状况。<strong>DEA，离差平均值，即 DIF 的 9 日 EMA</strong>：今日 DEA = 前一日 DEA × 8/10 + 今日 DIF ×2/10。<strong>用（DIF-DEA）×2 即为 MACD 柱状图</strong>。</p><p>基本用法：<br>① MACD <strong>金叉</strong>：DIF 由下向上突破 DEA，为买入信号。本质为顺势操作，追涨杀跌。<br>② MACD <strong>死叉</strong>：DIF 由上向下突破 DEA，为卖出信号。本质为顺势操作，追涨杀跌。<br>③ MACD 绿转红：MACD 值由负变正，市场由空头转为多头。<br>④ MACD 红转绿：MACD 值由正变负，市场由多头转为空头。<br>⑤ DIFF 与 DEA 均为正值，即都在零轴线以上时，大势属多头市场，DIFF 向上突破 DEA，可作买入信号。<br>⑥ DIFF 与 DEA 均为负值，即都在零轴线以下时，大势属空头市场，DIFF 向下跌破 DEA，可作卖出信号。<br>⑦ 当 DEA 线与 K 线趋势发生背离时为反转信号。<br>⑨ DEA 在盘整局面时失误率较高，但如果配合 RSI 及 KDJ 指标可适当弥补缺点。</p><p>顶背离和底背离（背离用于抄底逃顶）：<br>① MACD 指标与股价<strong>底背离</strong>：<br>当股价创出新低时，而相关 MACD 的两线数值却未能同时创出新低，这就形成了底背离现象，是买入信号。在底背离出现时，激进的投资者可以分批建仓。而为了安全起见，稳健的投资者应耐心等待股价止跌回升后再买入。<br>② MACD 指标与股价<strong>顶背离</strong>：<br>当股价创出新高时，而相关 MACD 的两线数值却未能同时创出新高，这就形成了顶背离现象，是卖出信号。顶背离的卖点较难把握，这是因为有时出现一次顶背离后，股价就会下跌；而有时则在出现两三次顶背离后，股价才开始下跌。投资者可以在每次顶背离时分批减仓，待发现股价滞涨下跌时再清仓出局。  </p><h3 id="KDJ"><a href="#KDJ" class="headerlink" title="KDJ"></a>KDJ</h3><p>KDJ 随机指标</p><h3 id="RSI"><a href="#RSI" class="headerlink" title="RSI"></a>RSI</h3><p>Relative Strength Index，RSI：相对强弱指标</p><h2 id="其他炒股相关名词"><a href="#其他炒股相关名词" class="headerlink" title="其他炒股相关名词"></a>其他炒股相关名词</h2><p>做T<br>止盈止损<br>跳空</p><h1 id="基金理财相关"><a href="#基金理财相关" class="headerlink" title="基金理财相关"></a>基金理财相关</h1><blockquote><p>能买场内基金就买场内，手续费低，没必要买场外基金。</p></blockquote><h2 id="ETF"><a href="#ETF" class="headerlink" title="ETF"></a>ETF</h2><p><strong>ETF（Exchange Traded Fund，交易所交易基金）</strong>，一种在交易所上市交易的、基金份额可变的开放式基金。结合了封闭式基金和开放式基金的运作特点，投资者既可以向基金管理公司申购或赎回基金份额，同时，又可以像封闭式基金一样在二级市场上按市场价格买卖 ETF 份额。<strong>申购赎回</strong>必须以一篮子股票换取基金份额或者以基金份额换回一篮子股票。</p><p>由于同时存在二级市场交易和申购赎回机制，投资者可以在 ETF 市场价格与<strong>基金单位净值</strong>（IOPV，Indicative Optimized Portfolio Value）之间存在差价时进行套利交易。</p><p><strong>实物申购</strong>：当投资者选择通过实物申购方式购买 ETF 时，他们向基金管理公司支付一定金额的资金，并且获取与 ETF 相对应的实际标的资产。这些标的资产可以是股票、债券、商品等，与ETF的投资组合相匹配。实物申购通常适用于大额资金投资者，因为它要求购买者能够购买整个 ETF 所持有的标的资产。</p><p><strong>实物赎回</strong>：实物赎回是指投资者将持有的 ETF 份额向基金管理公司赎回，并以相应的标的资产作为换回的回报。投资者将 ETF 份额交还给基金，而基金则会将相应的实际标的资产交还给投资者。实物赎回通常适用于大额赎回或特定机构投资者，因为它要求持有者能够接收和处理赎回的标的资产。  </p><h1 id="债券投资相关"><a href="#债券投资相关" class="headerlink" title="债券投资相关"></a>债券投资相关</h1><blockquote><p>债券是逆周期的，但要注意经济下行期间债券的信用（兑付、违约）风险，所以买入国债、准国债较佳；<br>高息下开启降息通道的时候，投资债券是最佳的（即买入高利息债券，政策利率下降时可以同时赚取利息和价格上升）  </p></blockquote><h2 id="我国债券体系"><a href="#我国债券体系" class="headerlink" title="我国债券体系"></a>我国债券体系</h2><p>我国债券根据债券分类方式有不同的划分：<br>①按风险特征分类：<br>&emsp;&emsp;- <strong>利率债</strong>：国债、政金债（也称为政策性银行债或政策性金融债）、地方债、央行票据；<br>&emsp;&emsp;- <strong>准利率债</strong>：铁道债、中央汇金债；<br>&emsp;&emsp;- <strong>信用债</strong>：<em>金融债</em>：保险公司债、证券公司短期融资券、商业银行次级债券、商业银行债、 证券公司债、 其它金融机构债；<em>企业债</em>：集合企业债、一般企业债；<em>公司债</em>：一般公司债、 私募债；<em>中期票据</em> ：一般中期票据 ； <em>短期融资券</em> ：一般短期融资券 、 超短期融资债券 ；<em>定向工具</em> ；<em>资产支持证券</em>；<em>可转债</em>；<em>可交换债</em>；<br>&emsp;&emsp;- 其他：同业存单<br>②按发行主体分类<br>&emsp;&emsp;- 政府部门：国债；地方政府债券：一般债券、专项债券<br>&emsp;&emsp;- 央行：中央银行票据<br>&emsp;&emsp;- 金融机构：政策银行债、商业银行债、非银行金融债<br>&emsp;&emsp;- 非金融机构：企业债：产业债、城投债；公司债；短融；超短融；中期票据；定向工具<br>③按主管机构分类<br>&emsp;&emsp;- 证监会主管：公司债、私募债、企业ABS、转债等<br>&emsp;&emsp;- 人民银行主管：政金债、商业银行债、同业存单、银行资本债、保险次级债、信贷ABS 等<br>&emsp;&emsp;- 中国银行间市场交易商协会主管：超短融、短融、中票、PPN、ABN 等<br>&emsp;&emsp;- 发改委主管：企业债、铁道债<br>&emsp;&emsp;- 财政部主管：国债、地方债<br>④按照交易市场分类<br>部分债券在银行间市场与交易所市场均有交易如国债、地方政府债、金融债、企业债、资产支持债券等。而部分品种仅在银行间市场交易，如央票、中期票据、短期融资券、同业存单与定向工具。而公司债、可转债、可质押回购债券等品种只能在交易所市场交易。</p><p>中国债券市场主要包括<strong>银行间市场</strong>、<strong>交易所</strong>、商业银行<strong>柜台</strong>三个子市场。<br>①银行间债券市场：银行间市场是中国债券市场的主体，债券存量接近全市场的90％。中央结算公司为投资者开立债券账户，实行一级托管，并提供交易结算服务。<br>②交易所：交易所债券实行两级托管体制，其中中央结算公司为总托管人，负责为交易所开立代理总户，中证登为债券分托管人，记录交易所投资者明细账户，中央结算公司与交易所投资者没有直接的权责关系。交易所债券交易结算由中证登负责。<br>③商业银行柜台：柜台市场实行两级托管体制，其中中央结算公司为一级托管机构，负责为开办银行开立债券自营账户和代理总账户，开办银行为二级托管机构，负责为投资者开立二级托管账户。</p><p>银行间债券市场为场外市场，主要金融基础设施包括中国外汇交易中心暨全国银行间同业拆借中心（交易中心、CFETS）、中央国债登记结算有限责任公司（中债登、中央结算公司、CCDC）、中国银行间市场交易商协会（交易商协会、NAFMII）、银行间市场清算所股份有限公司（上海清算所、SHCH）、北京金融资产交易所有限公司（北金所）。</p><p>交易所债券市场为场内市场，既有集中撮合交易的零售交易，也有实行做市制度的固定收益平台，主要基础设施包括中国证券登记结算有限责任公司（中证登、中国结算、CS DC）、上海证券交易所固定收益证券综合电子平台和深圳证券交易所综合协议交易平台、全国中小企业股份转让系统（简称“全国股转系统”，俗称“新三板”）、中国金融期货交易所（中金所）、机构间私募产品报价与服务系统（报价系统）。</p><h2 id="国债"><a href="#国债" class="headerlink" title="国债"></a>国债</h2><p>我国发行的国债品种有普通国债及其他类型国债。目前我国发行的普通国债有<strong>记账式国债</strong>、<strong>储蓄国债（凭证式）</strong>和<strong>储蓄国债（电子式）</strong>。其他类型的国债主要有国家重点建设债券、国家建设债券、财政债券、特种债券、保值债券、基本建设债券、特别国债、长期建设国债。</p><p>①<strong>记账式国债</strong>又名无纸化国债，准确定义是由财政部通过无纸化方式发行的、以电脑记账方式记录债权，并可以上市交易的债券。<br>②<strong>储蓄国债</strong>是财政部面向个人投资者发行，不向机构投资者发行；采用实名制，不可流通转让。</p><blockquote><p>国债 ETF（511010）：国泰上证 <em>5年期</em> 国债交易型开放式指数证券投资基金<br>30年国债 ETF（511090）：鹏扬上证中债 <em>30年期</em> 国债交易型开放式指数证券投资基金<br>活跃国债 ETF（511020）：平安中证 <em>5-10年期</em> 国债活跃券交易型开放式指数证券投资基金<br>十年国债 ETF（511260）：国泰上证 <em>10年期</em> 国债交易型开放式指数证券投资基金</p></blockquote><h2 id="政金债（政策性金融债）"><a href="#政金债（政策性金融债）" class="headerlink" title="政金债（政策性金融债）"></a>政金债（政策性金融债）</h2><p>政策性银行金融债，又称政策性银行债。是我国政策性银行（国家开发银行、中国农业发展银行、中国进出口银行）为筹集信贷资金，经国务院批准由中国人民银行用计划派购的方式，向邮政储蓄银行、国有商业银行、区域性商业银行、城市商业银行（城市合作银行）、农村信用社等金融机构发行的金融债券。</p><blockquote><p>国开债 ETF（159649）：华安中债 <em>1-5年</em> 国开行债券交易型开放式指数证券投资基金<br>国开 ETF（159650）：博时中债 <em>0-3年</em> 国开行债券交易型开放式指数证券投资基金<br>国开0-3 ETF（159651）：平安中债 <em>0-3年</em> 国开行债券交易型开放式指数证券投资基金<br>政金债券 ETF（511520）：富国中债 <em>7-10年</em> 政策性金融债交易型开放式指数证券投资基金<br>政金债5年 ETF（511580）：招商中证 <em>3-5年</em> 政策性金融债交易型开放式指数证券投资基金  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 股票 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 股票 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity基础</title>
      <link href="/2023/07/09/2023-07-09-Unity%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9D%82%E8%AE%B0/"/>
      <url>/2023/07/09/2023-07-09-Unity%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章记录 Unity 建议了解的基础知识，主要内容包括脚本、三维数学基础、物理引擎、UGUI 以及 Unity 2D 相关基础知识，内容拓展详见其他文章。<br>本文章主要参考达内教育祁天暄的 Unity 教程以及 Unity 官方文档。</p></blockquote><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>为了连接到 Unity 的内部架构，脚本需要实现一个类，此类从称为 <strong>MonoBehaviour</strong> 的内置类派生而来。可以将类视为一种蓝图，用于创建可附加到游戏对象的新组件类型。每次将脚本组件附加到游戏对象时，都会创建该蓝图定义的对象的新实例。类的名称取自创建文件时提供的名称。类名和文件名必须相同才能使脚本组件附加到游戏对象。</p><blockquote><p>如果在 Unity 里更改了 C# 文件的名称，脚本的类名不会一起改变，此时需要在脚本里改类名  </p></blockquote><h2 id="脚本的生命周期"><a href="#脚本的生命周期" class="headerlink" title="脚本的生命周期"></a>脚本的生命周期</h2><p>摘自 Unity 官方文档，方便查阅，引用版本：<a href="https://docs.unity3d.com/2023.1/Documentation/Manual/ExecutionOrder.html">Unity 官方手册 ver. 2023.1</a></p><p><img src="/images/Unity_ScriptLifecycle.svg" alt="脚本生命周期流程图"></p><p>一、初始化阶段<br>场景开始时将调用以下函数（为场景中的每个对象调用一次）：<br>①<strong>Awake</strong>：当一个脚本实例被载入时 Awake 被调用，无论脚本是否可用，只要物体被加载就会调用，Awake 常用于在游戏开始之前初始化变量或游戏状态，可以判断当满足条件后执行此脚本。（<strong>只调用一次</strong>）<br>②<strong>OnEnable</strong>：（仅在对象处于可用或激活状态时调用）在启用对象后立即调用此函数。（<strong>可多次调用</strong>）<br>③<strong>Reset</strong>：在编辑模式时，当脚本被附上对象或用户点击检视面板的 Reset 按钮时，Reset 被调用。<br>④<strong>Start</strong>：当脚本实例处于可用或激活状态时，Start 在 Update 函数第一次被调用前（第一帧更新前）调用一次，且仅调用一次；Awake 总是在 Start 之前执行。（<strong>只调用一次</strong>）</p><p>二、物理阶段<br>①<strong>FixedUpdate</strong>（固定间隔执行）<br>FixedUpdate 基于一个可靠的定时器被调用，独立于渲染帧率之外，所以在 FixedUpdate 内应用运动计算时，无需将值乘以 Time.deltaTime 。默认频率大概为 0.02s ，可在 Edit —&gt; Project Setting —&gt; Time —&gt; Fixed Timestep 中修改。如果 Fixed Timestep 小于实际的帧更新时间，那么每帧的物理循环可能会发生不止一次。如果帧率很高，可能在帧之间完全不调用该函数。</p><p>处理物体的物理属性(Rigidbody、Force、Collider)或者输入事件时，需要用 FixedUpdate 代替 Update ，以使物体的物理表现更平滑。实际上，FixedUpdate 并不是真的按照现实时间间隔执行的，而是按照 Timer 时间间隔执行的，但 Timer 并不是真正意义上的现实时间，它的作用是在运行环境下创造一个与现实时间高度相近的变量来实现物理帧的逻辑稳定。因为 FixedUpdate 的这个特质，强烈建议在此环节只做物理相关的处理，不要把其他类型(如网络帧同步)的处理也放入此步骤。</p><p>②<strong>OnTriggerXXX</strong>：触发器被触发时调用。<br>③<strong>OnCollisionXXX</strong>：产生碰撞事件时调用。</p><p>三、输入事件阶段<br>鼠标、键盘、触屏、手柄等各类输入事件会在这个阶段触发，这个时间点物理更新已经执行（如果需要物理更新的话），而逻辑更新和渲染并未执行，要了解这个触发的时机，才能更好的掌握代码逻辑。</p><p>四、游戏逻辑阶段<br>①<strong>Update</strong>（执行间隔不固定）<br>Update 是真正的每个渲染帧调用的，由于系统性能以及游戏体量的区别，每一帧的刷新频率也是不同的。<br>②<strong>LateUpdate</strong><br>每帧 Update 方法调用之后会调用本方法，适用于跟随逻辑。因为游戏开发过程中经常会有一个二次计算的情况，比如主角移动，相机跟着移动。如果相机也在主角移动时跟随，当有物体跟玩家之间产生了相位，就可能会出现抽搐抖动等情况（因为并没有在这一帧逻辑完全结束后调用跟随）。所以 LateUpdate 的出现能够使程序更加顺畅。</p><p>五、渲染阶段<br>①<strong>OnWillRenderObject</strong>：当即将渲染物体时调用。<br>②<strong>OnPreCull</strong>：这个函数仅用于宿主为摄像机的脚本。当此摄像机剔除了某个渲染场景时候触发此消息。<br>③<strong>OnBecameVisable</strong>：当物体的 Mesh Renderer 在任何相机可见时调用。<br>④<strong>OnBecameInvisible</strong>：当物体的 Mesh Renderer 在任何相机不可见时调用。<br>⑤<strong>OnPreRender</strong>：这个函数仅用于宿主为摄像机的脚本。当此摄像机开始渲染某个场景时候触发此消息。<br>⑥<strong>OnRenderObject</strong>：这个函数仅用于宿主为摄像机的脚本。当使用 Graphics.DrawMeshNow 或者其他函数绘制自己建立的物体渲染完毕时触发。<br>⑦<strong>OnPostRender</strong>：这个函数仅用于宿主为摄像机的脚本。当此摄像机范围内所有渲染都完成时候触发此消息。<br>⑧<strong>OnRenderImage</strong>：当所有渲染完成 image 的 postprocessing effects（只有pro版支持）后触发。<br>⑨<strong>OnDrawGizmos</strong>（Gizmos 渲染）：Gizmos 一般是为开发者使用的，指的是开发时场景编辑器中所展示的那些相机、线框之类的物体。所以此方法里的内容一般不会需要发布到生产环境中。  </p><p>六、暂停阶段<br>①<strong>OnApplicationPause</strong>：应用暂停时会调用此方法，取消暂停后会从 FixedUpdate 开始重新执行。</p><p>七、退出阶段<br>①<strong>OnDisable</strong>：在对象变为不可用或附属游戏对象非激活状态时，调用此函数。<br>②<strong>OnDestroy</strong>：当物体被销毁时调用，一般用于清理内存。<br>③<strong>OnApplicationQuit</strong>：当应用退出时调用，但有时会失效，此方法为不稳定的方法，正常情况下可以用于保存退出前的信息，但最好使用更稳妥的方式，因为此方法有时不会被调用，比如 Android 环境。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>一、Unity调试器调试<br>在脚本代码中用 <code>Debug.Log();</code> 或 <code>print();</code> 进行打印调试</p><p>二、使用代码编辑器调试<br>在可能出错的行添加断点 —&gt; 启动调试 —&gt; 在 Unity 中 Play 场景 —&gt; 在编辑器中按 F11 逐条调试 —&gt; 调试完毕后退出调试</p><p>也可以在调试时右键 —&gt; 快速监视，在快速监视面板便捷的调试和查看数据。还可以在即时窗口输入代码进行调试。</p><p>因为 Update 和其他方法不同，它是逐帧运行的，所以在调试时需要单帧调试。步骤：启动调试 —&gt; 运行场景 —&gt; 暂停游戏 —&gt; 加断点 —&gt; 单帧执行 —&gt; 结束</p><h2 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h2><div  align="center">  <img src="https://s2.loli.net/2023/07/31/uzlm2T9Zax7qNIo.png" width = "90%" height = "90%" alt="核心类"/></div><p>API 常用方法和属性不做记录，直接查阅<a href="https://docs.unity3d.com/cn/2023.2/ScriptReference/index.html">官方文档 ver. 2023.2</a></p><p>①<strong>GameObject</strong>：提供了修改 GameObject 状态相关的属性，查找、创建和销毁 GameObject 的功能（有些功能继承自 Object 类）。所有 GameObject 都在 Inspector 顶部共享一组与场景中 GameObject 状态相关的控件，这些控件可以通过 GameObject 的脚本 API 进行控制。<br>②<strong>Component</strong>：提供了添加、获取和移除组件的方法。<br>③<strong>Transform</strong>：提供多种方式来通过脚本处理游戏对象的位置、旋转和缩放，以及与父和子游戏对象的层级关系（查找父、根、子变换组件）。<br>④<strong>Vector2</strong>、<strong>Vector3</strong> 和 <strong>Vector4</strong> ：用于表达和操作 2D、3D 和 4D 点、线和方向的类。<br>⑤<strong>Quaternion</strong>描述从一个方向到另一个方向的相对旋转。<br>⑥<strong>Time</strong>：用于测量和控制时间，并管理项目的帧率。<br>⑦<strong>Mathf</strong>（Math Function）：提供了一组常见的数学函数，包括三角函数、对数函数以及游戏和应用开发中常用的其他函数。  </p><h2 id="协程-coroutine"><a href="#协程-coroutine" class="headerlink" title="协程 coroutine"></a>协程 coroutine</h2><p>Unity 提供了一套协程的机制（不是多线程，协程在主线程上执行）。Unity 自己本身 UnityEngine API （即 Unity 脚本）是不能被多线程调用的，但是仍可使用多线程去执行其他需要大量计算的内容。Unity 2018 起开发了工作线程，可以使用 Job System 做一些耗时的事情，有需求额外了解。</p><p>Unity 协程是一个返回类型为 <code>IEnumerator</code> 的包含 <code>yield return</code> 语句的方法（即迭代器，详见<a href="https://ybniaobu.github.io/2023/02/03/2023-02-03-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B3/#%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterators">《C#图解教程》读书笔记（三）</a>）。若要启动一个协程任务，需要使用 <code>StartCoroutine()</code> 方法，并传递进创建的协程方法。<code>yield return</code> 语句所在的点是程序暂停并继续的位置，可以使用 <code>yield return new WaitForSeconds(1f);</code> 来等待一秒再执行。使用  <code>StopCoroutine()</code> 或 <code>StopAllCoroutines()</code> 停止协程任务。</p><h2 id="脚本序列化-script-serialization"><a href="#脚本序列化-script-serialization" class="headerlink" title="脚本序列化 script serialization"></a>脚本序列化 script serialization</h2><p><strong>序列化 Serialization</strong> 是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p><p>Unity 序列化是 Unity 将数据结构或对象转换为 Unity 存储的格式的一个自动化进程。Unity 的一些内置功能会使用序列化，比如保存和加载、Inspector 窗口、实例化和预制件等功能。</p><p>①脚本中声明为 public 的字段都支持字段序列化；<br>②若要同时支持字段序列化以及私有化这些数据不让外部可以直接访问，可以使用特性：<code>[SerializeField]</code>，并使用 private 声明对象；<br>③如果 public 字段不想在面板显示，可以使用特性：<code>[HideInInspector]</code>；<br>④<code>[Serializable]</code>特性用于自定义的，非 abstract 的类或结构体等 , 使这类型也能序列化。</p><h2 id="ScriptableObject"><a href="#ScriptableObject" class="headerlink" title="ScriptableObject"></a>ScriptableObject</h2><p><strong>ScriptableObject</strong> 是 Unity 提供的一个数据配置存储基类，它是一个可以用来保存大量数据的数据容器。ScriptableObject 的一个主要用途就是通过避免重复存储数据来减少项目的内存使用量。比如需要大量实例化的预制件，每个实例的数据脚本都会被拷贝，从而造成内存浪费。</p><p>在 Unity 外部可以使用像 excel，Json，xml 等<strong>持久化数据存储</strong>的方法，结合 Unity 对准备好的数据文件进行数据读写。在 Unity 内部可以使用 ScriptableObject 来存储数据，然后通过预制件脚本中的实例引用访问数据。在编辑模式下修改继承 ScriptableObject 对象的数据文件内容，这些修改会被保留，即在编辑模式下具有数据持久化特点，但是在游戏发布运行时，不具有持久化特点，修改数据不会被保存。因此 ScriptableObject 不适合存储在游戏打包发布后的运行期间会改变的数据。</p><h3 id="创建-ScriptableObject"><a href="#创建-ScriptableObject" class="headerlink" title="创建 ScriptableObject"></a>创建 ScriptableObject</h3><p>ScriptableObject 是一个基类，继承自 UnityEngine.Object 。要想创建它，需要我们写个脚本去继承 ScriptableObject 。继承自 SctiptableObject 的脚本无法挂载到游戏物体上，毕竟它不是继承自 MonoBehaviour。ScriptableObject 类的实例会被保存成资源文件（.asset文件），和预制体，材质球，音频文件等类似，都是一种资源文件，存放在 Assets 文件夹下，创建出来的实例也是唯一存在的。</p><p><strong><em>方法一：使用<code>[CreateAssetMenu]</code>特性，在编辑器的菜单中创建资源文件</em></strong><br>①创建一个脚本继承自 ScriptableObject 类；<br>②添加 CreateAssetMenu 特性，如下代码，其中 fileName 表示文件名；menuName 表示在 Assets/Create 下的名字；order 表示在 Assets/Create 下的位置顺序；<br>③在 Project 下创建 ScriptableObject 文件。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(fileName = <span class="string">&quot;XXManagerSO&quot;</span>, menuName = <span class="string">&quot;ScriptableObjects/XXManagerSO&quot;</span>, order = 0)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">XXManagerSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>方法二：利用 ScriptableObject 的静态方法创建数据对象，然后将数据对象保存在工程目录下</em></strong><br>可以新建一个脚本（可以不用继承自 MonoBehavoiur，不用挂载到游戏物体上）：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ScriptableObjectTool</span> </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;ScritableObject/CreateXXManagerSO&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateXXManagerSO</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建数据资源文件</span></span><br><span class="line">        <span class="comment">//泛型是继承自 ScriptableObject 的类</span></span><br><span class="line">        XXManagerSO asset = ScriptableObject.CreateInstance&lt;XXManagerSO&gt;();</span><br><span class="line">        <span class="comment">//前一步创建的资源只是存在内存中，现在要把它保存到本地</span></span><br><span class="line">        <span class="comment">//通过编辑器API，创建一个数据资源文件，第二个参数为资源文件在Assets目录下的路径</span></span><br><span class="line">        AssetDatabase.CreateAsset(asset, <span class="string">&quot;Assets/Resources/ScriptableObject/XXManagerSO.asset&quot;</span>);</span><br><span class="line">        <span class="comment">//保存创建的资源</span></span><br><span class="line">        AssetDatabase.SaveAssets();</span><br><span class="line">        <span class="comment">//刷新界面</span></span><br><span class="line">        AssetDatabase.Refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚创建的 ScriptableObjectTool 脚本需要放在 Assets 文件夹下任一位置的 Editor 文件夹下（这个文件夹放哪都行，看自己需求，只要在 Assets 文件夹或其子文件夹下就好）。因为我们引入了 UnityEditor 命名空间，这意味着这个脚本只在编辑模式下会用到，实际打包发布后是不会用到的。如果没放在 Editor 文件夹下，Unity 打包时会认为此脚本是会被一起打包，作用于游戏运行期间，与 Editor 命名空间的性质相矛盾，所以会报错。</p><h3 id="使用-ScriptableObject"><a href="#使用-ScriptableObject" class="headerlink" title="使用 ScriptableObject"></a>使用 ScriptableObject</h3><p><strong><em>方法一：通过 Inspector 面板中的 public 变量进行关联</em></strong><br>在继承自 MonoBehaviour 类中声明数据容器类型的成员，在 Inspector 面板中进行关联：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> XXManagerSO xxManagerSO;</span><br></pre></td></tr></table></figure><p><strong><em>方法二：直接加载数据资源文件</em></strong><br>可以用 Resources，AddressBundle，Addressables 等方式加载数据资源文件。比如，使用 <code>Resources.Load&lt;T&gt;</code> 传入创建的 .asset 文件。</p><h1 id="三维数学基础"><a href="#三维数学基础" class="headerlink" title="三维数学基础"></a>三维数学基础</h1><p>这里只记录简单的数学知识以及代码操作，复杂的详见线性代数、3D 数学基础等相关数学文章。</p><h2 id="向量基础"><a href="#向量基础" class="headerlink" title="向量基础"></a>向量基础</h2><p>一、向量相关API<br><code>Vector3.magnitude</code> 返回向量长度（模长）；<code>Vector3.normalized</code> 返回单位向量（即向量除以向量长度）。向向量方向移动，可以使用 <code>Transform.Translate</code> ，也可以直接向量相加。</p><p>二、向量<strong>点乘 dot product</strong><br>又称 <em>点积</em> 、 <em>内积</em> 或者 <em>数量积</em> ，点乘结果为<strong>标量 scalar</strong>，公式为：  </p><script type="math/tex; mode=display">\vec a \cdot \vec b = a_1 b_1 + a_2 b_2 + \cdots + a_n b_n</script><p>或者（θ 为向量 a 和向量 b 之间的夹角）：  </p><script type="math/tex; mode=display">\vec a \cdot \vec b = \left| a \right| \left| b \right| \cos( \theta )</script><p>三角形余弦定理：$c^2 = a^2 + b^2 - 2 \left| a \right| \left| b \right| \cos( \theta ) $，根据关系 $c = a - b$（a、b、c为三角形的三个边向量），可得：  </p><script type="math/tex; mode=display">(a-b) \cdot (a-b) = a^2 + b^2 - 2 a \cdot b = a^2 + b^2 - 2 \left| a \right| \left| b \right| \cos( \theta )</script><p>故若向量 a，b 已知，可以得到夹角 θ：  </p><script type="math/tex; mode=display">\theta = \arccos( \frac { \vec a \cdot \vec b } {\left| a \right| \left| b \right|} )</script><p>点乘的几何意义以及应用：<br>①向量 b 在 向量 a 上的投影的长度（模）和向量 a 的长度（模）的乘积；<br>②可以计算向量 a 和向量 b 之间的夹角，从而判断两个向量是否方向一致或者正交（垂直）：<br>&emsp;&emsp; - $a \cdot b \gt 0$：向量方向一致，夹角为 0° 到 90° 之间；<br>&emsp;&emsp; - $a \cdot b = 0$：向量正交，相互垂直；<br>&emsp;&emsp; - $a \cdot b \lt 0$：向量方向相反，夹角为 90° 到 180° 之间；  </p><p><strong>Unity API：<code>Vector3.Dot(a, b)</code></strong>，可以直接利用单位向量来获取夹角余弦值：<code>Vector3.Dot(Vector3.normalized, Vector3.normalized)</code></p><p>三、向量<strong>叉乘 cross product</strong><br>又称 <em>叉积</em> 、 <em>外积</em> 或者 <em>向量积</em> ，叉乘结果为<strong>向量 vector</strong>，并且结果向量（向量 c）与向量 a 和向量 b 组成的平面垂直，即<strong>法向量</strong>，在右手坐标系下方向遵守右手定则（四指从向量 a 旋转到向量 b，那么大拇指为向量 c 的方向）。由于 Unity 是左手坐标系，需要用左手确定方向。若 $\vec a = ( a_1, a_2, a_3 )$，$\vec b = ( b_1, b_2, b_3 )$，i、j、k 分别为X、Y、Z 轴方向的单位向量，公式为：  </p><script type="math/tex; mode=display">\vec a \times \vec b = det {\begin{vmatrix} \vec i & \vec j & \vec k \\ a_1 & a_2 & a_3 \\ b_1 & b_2 & b_3 \end{vmatrix}} = (a_2b_3 - a_3b_2)\vec i - (a_1b_3 - a_3b_1)\vec j + (a_1b_2 - a_2b_1)\vec k</script><p>即，向量 c 为：  </p><script type="math/tex; mode=display">\vec c = \vec a \times \vec b = (a_2b_3 - a_3b_2,\ -a_1b_3 + a_3b_1,\ a_1b_2 - a_2b_1)</script><p>向量 C 的模长可被定义为：  </p><script type="math/tex; mode=display">\left| \vec c \right| = \left| \vec a \times \vec b \right| = \left| a \right| \left| b \right| \sin( \theta )</script><p>向量 c 的模长也就是向量 a 和 向量 b 构成的平行四边形的面积。据此可以得出<strong>混合积</strong>（三重积）的几何意义，x、y、z 为空间中三个向量：$ [x\ y\ z] = x \cdot (y \times z) = y \cdot (z \times x) = z \cdot (x \times y)$，其结果为三个向量定义的平行六面体的体积。</p><p>叉乘的几何意义以及应用：<br>①求解向量 a 和向量 b 构成的平面的法线；<br>②计算点到线的距离，向量 a 的顶点到向量 b 的距离，即：  </p><script type="math/tex; mode=display">\left| a \right| * \sin( \theta ) = \frac {\left| a \times b \right|} {\left| b \right|}</script><p>③利用平面方程（即三元一次方程），计算点到面的距离，假设点 p 为 $( x_0, y_0, z_0 )$，则点 p 到向量 a 和向量 b 构成的平面的距离求解顺序如下：<br>&emsp;&emsp; - 先求解向量 a 和向量 b 构成平面的法向量：$ \vec n = (A,\ B,\ C)$ ；<br>&emsp;&emsp; - 再求解平面方程为 $Ax + By + Cz + D = 0$（D 由向量 a 和 b 代入可得）；<br>&emsp;&emsp; - 点 p 到 $Ax + By + Cz + D = 0$ 平面的距离：  </p><script type="math/tex; mode=display">d = \frac { \left| Ax_0 + By_0 + Cz_0 + D \right| } {\sqrt{A^2 + B^2 + C^2}}</script><p><strong>Unity API：<code>Vector3.Cross(a, b)</code></strong>，可以利用单位向量来获取夹角正弦值：<code>Vector3.Cross(Vector3.normalized, Vector3.normalized).magnitude</code>。根据叉乘方向可以判断，向量与向量的左右位置信息。</p><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p>一、角度与弧度的转换<br>PI 弧度 = 180° 即 1弧度 = 180/PI 角度，1° = PI/180 弧度<br>=&gt; 角度到弧度（degree to radian）：<code>角度 * Mathf.Deg2Rad</code> 等同于 <code>角度 * Mathf.PI/180</code><br>=&gt; 弧度到角度（radian to degree）：<code>弧度 * Mathf.Rad2Deg</code> 等同于 <code>弧度 * 180/Mathf.PI</code></p><p>二、正弦余弦正切<br><code>Mathf.Sin(float radian)</code>；<code>Mathf.Cos(float radian)</code>；<code>Mathf.Tan(float radian)</code><br><code>Mathf.ASin(float f)</code>；<code>Mathf.ACos(float f)</code>；<code>Mathf.ATan(float f)</code></p><blockquote><p>注意：反三角函数算出的是弧度，要在欧拉角或四元数里使用要转换为角度。</p></blockquote><h2 id="欧拉角-Euler-angle"><a href="#欧拉角-Euler-angle" class="headerlink" title="欧拉角 Euler angle"></a>欧拉角 Euler angle</h2><p>Unity 中的 Transform 面板里的 Rotaton 即表示<strong>欧拉角</strong>，即使用三个角度来描述物体在三维空间中的旋转。API 为<code>Vector3 eulerAngle = transform.eulerAngles</code>。注意，不是<code>transform.rotation</code>，rotation 是<strong>四元数 Quaternion</strong>。</p><p>旋转的顺序不同会导致不同的结果。但是在面板中，无论你按照 XYZ、ZXY、ZYX 等任何顺序输入，你会看到模型的结果都是一样的，这是因为 Unity 中的欧拉角采用的是 YXZ 的层次关系（或者说是按 ZXY 顺序旋转而得，即 Z 轴层级最低，Y 轴层级最高）。也就是说，Inspector 面板上显示的并不是物体绕自身局部坐标轴旋转的度数，也不是绕全局坐标轴旋转的度数，而是隐藏的<strong>万向节 gimbal</strong> 旋转轴旋转的度数，Z 在最底层，X 是 Z 的父项，Y 是 X 的父项。当我们旋转万向节中的三个轴时，会有以下现象：Z 轴旋转时，另外两个轴不旋转；X 轴旋转时，Z 轴随 X 轴旋转而旋转（Z 与 X 保持相对静止），Y 轴不动；Y 轴旋转时，X、Z 都随 Y 轴旋转而旋转（保持相对静止）。</p><blockquote><p>区分万向节旋转轴、局部坐标系、全局坐标系的 X、Y、Z。刚开始初始状态下(0, 0, 0)，物体的万向节系统的三个轴不仅是和物体的全局坐标轴重合，也是和物体的局部坐标轴重合的。区别在于，物体绕局部坐标轴某个轴旋转，局部坐标系的另外两个轴也会旋转。物体绕全局坐标系某个轴旋转，物体局部坐标系的轴会旋转，全局坐标系不会跟着旋转。而物体根据欧拉角即面板调节，旋转情况如上面所示，这就会导致3个坐标系不统一的现象。  </p><p>总结：欧拉角由三个旋转值组成，三个旋转值会根据万向节的规则确定。Unity 中 Inspector 面板上的 rotation 的三个值对应的是物体的欧拉角，即通过万向节规则确定的三个旋转值。当我们调节 Inspector 面板上的 rotation 的值时，Unity 根据万向节规则计算出物体当前的朝向。<strong>Unity 中的欧拉角采用 Y(Heading)—&gt; X(Pitch) —&gt; Z(Bank) 的欧拉角轴嵌套顺序</strong>。</p></blockquote><p>由于 Unity 是按照 ZXY 的顺序来旋转的，所以按照 Unity 的计算方式，总是最后再绕 Y 轴旋转。所以，当你滑动 Y ，连续改变欧拉角时，看来像是再绕着世界坐标系的 Y 轴旋转，而不是绕模型的局部坐标系的 Y 轴来旋转。所以你在 Unity 中，无论 XZ 的值时怎样的，只要你滑动 Y ，Unity 计算欧拉角的方式给你呈现的视觉效果就是像围绕世界坐标系的 Y 轴来旋转一样。</p><p>而当你滑动 Z 时，由于 Unity 总是先旋转绕 Z 轴旋转的，所以给你呈现的视觉效果是滑动 Z 时在场景中看到模型真的在绕模型的局部坐标系的 Z 轴旋转。而有时你滑动 X 呢，你会发现模型既不绕世界坐标系的 X 轴旋转，也不绕模型的局部坐标系的 X 轴旋转。</p><p><strong><em>欧拉角加深理解一：旋转1</em></strong><br><code>transform.Rotate(Vector3 eulers, Space relativeTo = Space.Self);</code>，Transform 的 Rotate 可以选择根据 Space.World，即世界坐标系，或根据 Space.Self，即自身局部坐标系，旋转：</p><p>代码1：<code>transform.Rotate(new Vector3(60, 45, 90), Space.Self);</code><br>代码2：<code>transform.Rotate(new Vector3(0, 0, 90), Space.Self);</code>，<code>transform.Rotate(new Vector3(45, 0, 0), Space.Self);</code>，<code>transform.Rotate(new Vector3(0, 60, 0), Space.Self);</code></p><p>这两者所得结果不同，在代码1中是按照物体的万向节轴向（Space.Self 可理解为万向节轴向和局部坐标系重合）先绕 Z 轴旋转 90°，再绕 X 轴旋转 45°，再绕 Y 轴旋转 60°。在代码2中，先按照物体的局部坐标系旋转 90°，此时物体的局部坐标系改变了；之后以改变了的局部坐标系再旋转，绕 X 轴旋转 45°，旋转后，物体的局部坐标系又改变了；最后，绕改变后的轴向的 Y 轴旋转 60°。</p><p>代码3：<code>transform.Rotate(new Vector3(60, 45, 90), Space.World);</code></p><p>代码3和代码1的结果是一致的，因为都是按照物体的万向节轴向先绕 Z 轴旋转 90°，再绕 X 轴旋转 45°，再绕 Y 轴旋转 60°，并且刚开始的局部坐标和全局坐标重合。可以尝试初始局部坐标和全局坐标不重合的情况下，使用代码3和代码1，结果不一致。</p><p>代码4：<code>transform.Rotate(new Vector3(0, 0, 90), Space.World);</code>，<code>transform.Rotate(new Vector3(45, 0, 0), Space.World);</code>，<code>transform.Rotate(new Vector3(0, 60, 0), Space.World);</code></p><p>代码3和代码4的结果一样，因为根据万向轴顺序，并且初始状态下万向节旋转轴、局部坐标系、全局坐标系相互重合，先 Z 轴另外两个轴不旋转等同于先绕全局坐标系 Z 轴旋转。此时，因为万向轴 Z 轴变动后，X、Y 仍然和全局坐标系重合，此时万向节 X 轴旋转等同于绕全局坐标系 X 轴旋转。Y 轴同理。</p><blockquote><p>注：代码4顺序变了，得到的结果也不一样的。旋转顺序不同会导致不同的结果，即使是跟着不变的全局坐标系旋转。这和矩阵变换没有交换律是一样的道理。</p></blockquote><p><strong><em>欧拉角加深理解二：万向节锁 gimbal lock</em></strong><br>万向节的特点是轴与轴之间存在父子关系，每个轴对另外两个轴的影响各不相同，也正是因为这个特点，导致出现了一些缺点。比如当我们将 X 轴旋转 90° 后，Z 轴和 Y 轴会变成平行状态，然后我们会发现旋转 Z 轴和 Y 轴的效果竟然是一模一样的。</p><p><strong><em>欧拉角加深理解三：旋转2</em></strong><br>当我们在 Inspector 面板上按照 Z、X、Y 的顺序调整 rotation 的值时会发现，此时场景中物体的旋转效果是绕着物体的全局坐标轴进行旋转的。这是因为初始状态下(0, 0, 0)，物体的万向节系统的三个轴是和物体的全局坐标轴重合的，旋转 Z 轴不影响 X、Y 轴的位置和角度，所以旋转完 Z 轴后，X、Y 轴依然与惯性坐标轴重合。 </p><p>当我们在 Inspector 面板上按照 Y、X、Z 的顺序调整 rotation 的值时会发现，此时场景中物体的旋转效果是绕着物体的局部坐标轴进行旋转的。这是因为初始状态下(0, 0, 0)，物体的万向节系统的三个轴不仅是和物体的全局坐标轴重合，也是和物体的局部坐标轴重合的。旋转 Y 轴时会带动 X 和 Z 轴旋转，三个轴保持相对静止，X、Z 轴和局部坐标轴重合。同理往下。</p><p><strong><em>欧拉角优缺点</em></strong><br>①仅使用三个数字表达方位，占用空间小；<br>②三个角度（沿坐标轴旋转的单位）组成，直观，容易理解；<br>③可以进行从一个方向到另一个方向旋转大于180度的角度；<br>④存在万向节死锁问题；<br>⑤对于一个方位，存在多个欧拉角描述，因此无法判断多个欧拉角代表的角位移是否相同。比如（250，0，0）与（290，180，180）为同一个欧拉角；<br>⑥因为 Unity 的底层是通过四元数记录物体旋转的，并通过矩阵和四元数实现物体的旋转及插值。为了避免无穷种表示，Unity 引擎限制了角度范围，即沿 X 轴旋转限制在 -90 到 90 之间，沿 Y 与 Z 轴旋转限制在 0 到 360 之间（Inspector 面板显示为 -180 到 180），用脚本时会有这个限制，并且在万向节死锁的情况下，Z 轴旋转为 0（Inspector 面板显示 Y 轴为 0）。但在 Inspector 面板中直接调节没有这个限制，transfrom.eulerAngles 获取到的值，和在 Inspector 窗口的 Transfrom 组件中看到的旋转数值是不一样的，Unity 编辑器又经过了额外的封装，允许超限角度的显示输出和设定。</p><h2 id="四元数-Quaternion"><a href="#四元数-Quaternion" class="headerlink" title="四元数 Quaternion"></a>四元数 Quaternion</h2><p>四元数可用于表示游戏对象的旋转，在 Unity 中表示为 x、y、z 和 w，(x、y、z) 代表一个三维向量，w 为一个标量，这些数字通常不需要直接访问它们。</p><p>假设我们的旋转轴是 V 轴，旋转弧度为 θ ，那这四个数字分别是：x = sin(θ/2)*V.x ; y = sin(θ/2)*V.y ; z = sin(θ/2)*V.z ; w = cos(θ/2)。所以 x ，y， z， w 的取值范围是 -1 到 1 。</p><p>API 为<code>Quaternion qt = transform.rotation</code></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Quaternion qt = <span class="keyword">new</span> Quaternion();</span><br><span class="line"><span class="comment">//假设旋转轴</span></span><br><span class="line">Vector3 axis = Vector3.up;</span><br><span class="line"><span class="comment">//假设旋转弧度</span></span><br><span class="line"><span class="built_in">float</span> rad = <span class="number">50</span> * Mathf.Deg2Rad;</span><br><span class="line"><span class="comment">//四元数的值：</span></span><br><span class="line">qt.x = Mathf.Sin(rad/<span class="number">2</span>) * axis.x;</span><br><span class="line">qt.y = Mathf.Sin(rad/<span class="number">2</span>) * axis.y;</span><br><span class="line">qt.z = Mathf.Sin(rad/<span class="number">2</span>) * axis.z;</span><br><span class="line">qt.w = Mathf.Cos(rad/<span class="number">2</span>);</span><br><span class="line"><span class="comment">//即沿y轴顺时针旋转50度</span></span><br><span class="line">transform.rotation = qt;</span><br></pre></td></tr></table></figure><blockquote><p>若对四元数的数学感兴趣，可额外了解。基本上只需要知道四元数表示三维空间中的旋转，大多数情况下，你只需要获取和使用现有的旋转，或者用四元数来构造新的旋转（例如，在两次旋转之间平滑插入）。</p></blockquote><p><strong><em>四元数优缺点</em></strong><br>①四元旋转不存在万向节锁问题；<br>②四元数的数字表示不直观。</p><p><strong><em>四元数的应用</em></strong><br>①欧拉角转换成四元数的 API ：<code>transform.rotation = Quaternion.Euler(0, 60, 0);</code><br>②两个四元数相乘可以组合旋转效果，如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rotation01和rotation02效果相同，都表示旋转50度。</span></span><br><span class="line">Quaternion rotation01 = Quaternion.Euler(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>) * Quaternion.Euler(<span class="number">0</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">Quaternion rotation02 = Quaternion.Euler(<span class="number">0</span>, <span class="number">50</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>③ <code>transform.Rotate</code> 的内部也是调用四元数实现的，以下代码作用相同：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">transform.rotation *= Quaternion.Euler(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">transform.Rotate(<span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>④四元数<strong>左乘</strong>向量，表示将该向量按照四元数表示的角度旋转。当角度为正值时，表示顺时针；为负值时，表示逆时针。如下所示：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Vector3 point = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// newPoint为将point点绕Y轴旋转30度，所得到的点</span></span><br><span class="line">Vector3 newPoint = Quaternion.Euler(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>) * point;</span><br></pre></td></tr></table></figure><p>⑤轴角：将当前物体沿 y 轴旋转 60 度<br><code>this.transform.rotation = Quaternion.AngleAxis( 60, Vector3.up );</code><br>等效于：<code>Quaternion.Euler( 0,60,0 )</code><br>⑥注视旋转：z 轴指向一个方向(即第一个参数)，物体的 position 不变：<br><code>Quaternion qt03 = Quaternion.LookRotation( Vector3.up );</code><br>等效于：<code>transform.LookAt( Vector3.zero, Vector3.up );</code><br>⑦使用 Lerp 来控制旋转的速度：<br><code>Quaternion.Lerp( this.transform.rotation, Quaternion.Euler(0, 6, 0), 0.1f );</code><br>⑧匀速旋转：<br><code>Quaternion.RotateTowards( this.transform.rotation, Quaternion.Euler(0, 60, 0), 0.1f );</code><br>⑨x 轴注视旋转,让物体 x 轴始终指向：物体位置到 v1 所在的向量：<br><code>this.transform.right = v1 - this.transform.position;</code><br>等效于：<code>Quaternion.FromToRotation( transform.right, v1 - this.transform.position )</code></p><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><p><strong>World Space</strong> 全局（世界）坐标系：场景的固定坐标；<br><strong>Local Space</strong> 物体（局部）坐标系：原点为模型轴心点，随物体移动或旋转而改变；<br><strong>Screen Space</strong> 屏幕坐标系：以像素为单位，屏幕左下角为原点，右上角为（Screen.width , Screen.height），Z 为到相机的距离；<br><strong>Viewport Space</strong> 视口（摄像机）坐标系：屏幕左下角为原点(0, 0)，右上角为(1, 1)，Z 为到相机的距离。</p><h3 id="坐标系转换"><a href="#坐标系转换" class="headerlink" title="坐标系转换"></a>坐标系转换</h3><p>1、Local Space -&gt; World Space<br>①<code>transform.forward</code>、<code>transform.right</code>、<code>transform.up</code> 在世界坐标系中表示物体正前、右、上方；<br>②<code>transform.TransformPoint(Vector3 position)</code>：转换点，受变换组件位置、旋转和缩放影响；<br>③<code>transform.TransformDirection(Vector3 direction)</code>：转换方向，受变换组件旋转影响；<br>④<code>transform.TransformVector(Vector3 vector)</code>：转换向量，受变换组件旋转和缩放影响；</p><p>2、World Space -&gt; Local Space<br>①<code>transform.InverseTransformPoint(Vector3 position)</code>：转换点，受变换组件位置、旋转和缩放影响；<br>②<code>transform.InverseTransformDirection(Vector3 direction)</code>：转换方向，受变换组件旋转影响；<br>③<code>transform.InverseTransformVector(Vector3 vector)</code>：转换向量，受变换组件旋转和缩放影响；</p><p>3、World Space &lt;-&gt; Screen Space<br>①<code>Camera.main.WorldToScreenPoint</code>：将点从世界坐标系转换到屏幕坐标系中；<br>②<code>Camera.main.ScreenToWorldPoint</code>：将点从屏幕坐标系转换到世界坐标系中；  </p><p>4、World Space &lt;-&gt; Viewport Space<br>①<code>Camera.main.WorldToViewportPoint</code>：将点从世界坐标系转换到视口坐标系中；<br>②<code>Camera.main.ViewportToWorldPoint</code>：将点从视口坐标系转换到世界坐标系中；  </p><h1 id="物理引擎"><a href="#物理引擎" class="headerlink" title="物理引擎"></a>物理引擎</h1><h2 id="刚体-Rigidbody"><a href="#刚体-Rigidbody" class="headerlink" title="刚体 Rigidbody"></a>刚体 Rigidbody</h2><p>在 Unity 中，若想要一个物体具有在现实世界中的物理效果，比如受重力影响，就要为其添加 Rigidbody 组件，该组件是让物体产生物理行为的组件。通过刚体组件可以给物体添加一些常见的物理属性，如质量、摩擦力、碰撞参数等。添加了刚体组件的游戏物体，可以在物体系统的控制下来运动，刚体可接受外力和扭矩力用来保证游戏对象像在真实世界中那样进行运动。</p><p>在物理学中，刚体是一个理想模型，通常把在外力作用下，物体的形状和大小保持不变，而且内部各部分相对位置保持恒定的理想模型称为刚体。</p><h3 id="刚体组件属性"><a href="#刚体组件属性" class="headerlink" title="刚体组件属性"></a>刚体组件属性</h3><p>①<strong>Mass</strong> 质量：质量单位是 KG ；<br>②<strong>Drag</strong> 阻力：默认为 0，则没有阻力。阻力的方向与物理运动方向相反，该参数数值越大，所受到的阻力也就越大，速度的衰减也就越快。阻力极大时物体将会立即停止运动；<br>③<strong>Angular Drag</strong> 角阻力：即角阻力（旋转阻力），与该物体的旋转方向相反。设置该值后，物体在任何方向上的旋转运动都将受到影响。若设置为 0，则物体一旦开始旋转就不会停止。该值越大，旋转衰减越快；<br>④<strong>Use Gravity</strong> 使用重力：设置该物体是否受重力影响；<br>⑤<strong>Is Kinematic</strong> 是否遵循动力学：勾选则表示该物体不受重力、速度、阻力、质量等物理模拟的影响，只受脚本和动画的影响而运动。勾选它能降低性能消耗，物理系统已经不会计算它了，其次它虽然不受物理模拟的影响，但是它依旧是可以影响其他物体的，比如移动通过脚本移动它的 transform，依旧可以撞击其他刚体；<br>⑥<strong>Interpolate</strong> 插值：该参数用于解决 Unity 中物理模拟和画面渲染不同步的问题，当不进行插值处理时，计算得到的物理数据是上一个物理模拟时间点的数据，而插值则是获取最近似当前渲染时间点数据的一种手段。当你发现刚体移动时会发生抖动，建议调整一下此选项。一共两个参数，Interpolate：根据前一帧来平滑变换；Extrapolate：根据下一帧来平滑变换。<br>⑦<strong>Collision Detection</strong> 碰撞检测：该属性用于控制避免高速运动的物体穿过其他对象而没有发生碰撞。一共四个参数，Discrete：离散碰撞检测（适用于大部分刚体，最省资源）；Continuous：连续碰撞检测；Continuous Dynamic：连续动态碰撞检测；Continuous Speculative：连续推测碰撞检测。<br>⑧<strong>Constraints</strong> 约束条件：约束物体在某一个方向上的运动和旋转，默认不约束。</p><h3 id="刚体的休眠"><a href="#刚体的休眠" class="headerlink" title="刚体的休眠"></a>刚体的休眠</h3><p>刚体碰撞体会被物理引擎一直计算物理状态，为了解决耗费资源问题，若一个刚体的移动速度和旋转慢于定义的阈值（可以在 Project Setting 里的 Physics 里的 Sleep Threshold 修改），Unity 会将物体进入<strong>休眠</strong>状态，休眠状态中的刚体会被物理系统视而不见，所以自然就节约了运算资源，直到它被重新唤醒为止。当刚体进入休眠状态，是无法和碰撞体发生碰撞的，因为刚体进入休眠状态，其物理系统就已经不再计算了，自然也无法产生碰撞信息和触发碰撞事件。</p><p>可以通过 <code>IsSleeping()</code> 函数来判断刚体是否正在休眠，或 <code>WakeUp()</code> 来强制唤醒一个刚体。</p><h2 id="碰撞器-Collider"><a href="#碰撞器-Collider" class="headerlink" title="碰撞器 Collider"></a>碰撞器 Collider</h2><p>碰撞体 (Collider) 组件定义对象的形状以便用于物理碰撞。可将碰撞体添加到没有刚体组件的对象，从而创建场景的地板、墙壁和其他静止元素。这些被称为<strong>静态碰撞体</strong>。通常情况下，不应通过更改变换位置来重新定位静态碰撞体，因为这会极大地影响物理引擎的性能。具有刚体的对象上的碰撞体称为<strong>动态碰撞体</strong>。静态碰撞体可与动态碰撞体相互作用，但由于没有刚体，因此不会通过移动来响应碰撞。</p><p>当满足碰撞条件时，会进入碰撞三阶段：<br>①当进入碰撞时执行：<code>void OnCollisionEnter(Collision other)</code>；<br>②当碰撞体与刚体接触时每帧执行：<code>void OnCollisionStay(Collision other)</code>；<br>③当停止碰撞时执行：<code>void OnCollisionExit(Collision other)</code></p><h3 id="碰撞器组件属性"><a href="#碰撞器组件属性" class="headerlink" title="碰撞器组件属性"></a>碰撞器组件属性</h3><p>1、<strong>Is Trigger 触发器</strong>：碰撞体会默认阻挡刚体的运动，但是有些时候需要检测两个物体发生重叠但又不想引起物理上的碰撞，就需要勾选此选项，将碰撞体变成一个触发器。当勾选此项后，该物体就不会再阻挡刚体运动了，但会进入触发三阶段：<br>①当 Collider 碰撞体进入触发器时执行：<code>OnTriggerEnter(Collider other)</code>；<br>②当碰撞体与触发器接触时每帧执行：<code>OnTriggerStay(Collider other)</code>；<br>③当停止触发时执行：<code>OnTriggerExit(Collider other)</code>  </p><p>2、<strong>Material 物理材质</strong>：即模拟物体表面的物理材质，对于地面而言，比如冰面、木板、水泥板这些。对于物体本身而言，比如物理自身的弹性，物理自身的平滑度之类的，都会直接影响到物理模拟的效果。</p><p>创建物理材质和创建普通材质的方法是一样的，在 Assets 里右键菜单里面找到 Physic Material，物理材质参数包括 Dynamic Friction 运动摩擦力；Static Friction 静止摩擦力；Bounciness 弹性；Friction Combine 摩擦力混合：发生碰撞的两个碰撞体对象的摩擦力的混合方式；Bounce Combine 弹性混合：发生碰撞的两个碰撞体对象的摩擦力的混合方式  </p><h2 id="发生碰撞或触发总结"><a href="#发生碰撞或触发总结" class="headerlink" title="发生碰撞或触发总结"></a>发生碰撞或触发总结</h2><h3 id="发生碰撞"><a href="#发生碰撞" class="headerlink" title="发生碰撞"></a>发生碰撞</h3><div class="table-container"><table><thead><tr><th style="text-align:left">&emsp;</th><th style="text-align:left">静态碰撞体</th><th style="text-align:left">动态碰撞体</th><th style="text-align:left">运动学刚体碰撞体</th></tr></thead><tbody><tr><td style="text-align:left">静态碰撞体</td><td style="text-align:left">&emsp;</td><td style="text-align:left">√</td><td style="text-align:left">&emsp;</td></tr><tr><td style="text-align:left">动态碰撞体</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td></tr><tr><td style="text-align:left">运动学刚体碰撞体</td><td style="text-align:left">&emsp;</td><td style="text-align:left">√</td><td style="text-align:left">&emsp;</td></tr></tbody></table></div><p>当发生碰撞，双方都会触发 <code>OnCollision()</code> 事件，当不发生碰撞，则双方都不会触发事件。</p><h3 id="触发-OnTrigger-的情形"><a href="#触发-OnTrigger-的情形" class="headerlink" title="触发 OnTrigger 的情形"></a>触发 OnTrigger 的情形</h3><p>当碰撞体勾选了 Is Trigger 之后才可能触发 <code>OnTrigger()</code> 事件，若不勾选，那只能触发 <code>OnCollision()</code> 事件。</p><div class="table-container"><table><thead><tr><th style="text-align:left">&emsp;</th><th style="text-align:left"><font size=2>静态碰撞体</font></th><th style="text-align:left"><font size=2>动态碰撞体</th><th style="text-align:left"><font size=2>运动学刚体碰撞体</th><th style="text-align:left"><font size=2>静态碰撞体 <br> Is Trigger</font></th><th style="text-align:left"><font size=2>动态碰撞体 <br> Is Trigger</font></th><th style="text-align:left"><font size=2>运动学刚体碰撞体 <br> Is Trigger</font></th></tr></thead><tbody><tr><td style="text-align:left"><font size=2>静态碰撞体</font></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">√</td><td style="text-align:left">√</td></tr><tr><td style="text-align:left"><font size=2>动态碰撞体</font></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td></tr><tr><td style="text-align:left"><font size=2>运动学刚体碰撞体</font></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td></tr><tr><td style="text-align:left"><font size=2>静态碰撞体 <br> Is Trigger</font></td><td style="text-align:left"></td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left"></td><td style="text-align:left">√</td><td style="text-align:left">√</td></tr><tr><td style="text-align:left"><font size=2>动态碰撞体 <br> Is Trigger</font></td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td></tr><tr><td style="text-align:left"><font size=2>运动学刚体碰撞体 <br> Is Trigger</font></td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td></tr></tbody></table></div><p>注意：如果在表格中打勾，这就说明，双方必定都会触发 OnTrigger 事件。上一个图也一样，若表格打勾，则双方必定都会触发 OnCollision 事件。除非给物体套上两个碰撞器，一个 Is Trigger，一个不是，这样即可以触发 OnTrigger 事件，也可以触发 OnCollision 事件。</p><h1 id="UGUI"><a href="#UGUI" class="headerlink" title="UGUI"></a>UGUI</h1><h2 id="Canvas-画布"><a href="#Canvas-画布" class="headerlink" title="Canvas 画布"></a>Canvas 画布</h2><p>Canvas 即画布，UI 界面所在的区域。Canvas 是一个带有 Canvas 组件的游戏对象，所有 UI 元素都必须是此类 Canvas 的子元素。UI 元素的绘制顺序依赖于层次面板中的顺序。和 Canvas 一同创建的还有一个 EventSystem ，其是一个基于 Input 的事件系统，可以对键盘、触摸、鼠标、自定义输入进行处理。</p><p>一创建 Canvas 画布，对象上就依附着 RectTransform、Canvas 组件、Canvas Scaler 以及 Graphic Raycaster 四个组件。</p><h3 id="Canvas-组件"><a href="#Canvas-组件" class="headerlink" title="Canvas 组件"></a>Canvas 组件</h3><p><strong>Render Mode</strong>：<br><strong>①Screen Space - Overlay</strong> 覆盖模式：让 UI 元素绘制在其他元素之前，且绘制过程独立于场景元素和摄像机设置，画布尺寸由屏幕大小和分辨率决定，不能调整 RectTransform 组件参数属性；<br>&emsp;&emsp; · Pixel Perfect 完美像素：开启可以锐化屏幕显示效果；<br>&emsp;&emsp; · Sort Order 渲染顺序：在多个 Canvas 中，值越大越渲染到最上层；<br><strong>②Screen Space - Camera</strong>：选择一个相机后，按照和相机的距离前后显示物体和 UI。相机移动或参数改变，画布也会跟着变化。不能调整 RectTransform 组件参数属性；<br>&emsp;&emsp; · Plane Distance：画布与摄像机的距离；<br>&emsp;&emsp; · Sorting Layer：通过 Tags &amp; Layers 调整画布的渲染顺序；<br><strong>③World Space</strong>：画布渲染于世界空间，与场景中其他 3D 物体一样。可以调整 RectTransform 组件参数属性。</p><h3 id="Rect-Transform"><a href="#Rect-Transform" class="headerlink" title="Rect Transform"></a>Rect Transform</h3><p>RectTransform 继承于 Transform，具有 Transform 的所有特征，通过 RectTransform 能够实现基本的布局和层次控制。</p><p>组件属性：<br>Pos X, Pos Y ：Pivot 与 Anchor 的距离<br>Width &amp; Height ：宽与高<br>Left, Top, Right, Bottom：当锚点分开时显示<br>Pivot ：UI 元素的轴心点<br>Anchor ：锚点（当分辨率发生改变，方便 UI 元素自适应变化）  </p><h3 id="Canvas-Scaler"><a href="#Canvas-Scaler" class="headerlink" title="Canvas Scaler"></a>Canvas Scaler</h3><p><strong>UI Scale Mode</strong>：<br><strong>①Constant Pixel Size</strong>：在该模式下的UI控件不会自适应，而是会永远保持 UI 像素大小<br>&emsp;&emsp; - Scale Factor：缩放系数，按此系数缩放画布中的所有 UI 元素，相当于是在控制画布的 RectTransform 中的 Scale 属性；<br>&emsp;&emsp; - Reference Pixels Per Unit：UI 大小 = 图片像素 Pixels / Pixels Per Unit * Reference Pixels Per Unit；<br><strong>②Scale With Screen Size</strong>：UI 尺寸会根据屏幕尺寸进行缩放，Screen Match Mode 分为三个模式：<br>&emsp;&emsp; - Expand：将 Canvas 大小进行相对于 ReferenceResolution 扩大，Canvas Size = Screen Size / Scale Factor，<code>Scale Factor = Mathf.Min(screenSize.x / m_ReferenceResolution.x, screenSize.y / m_ReferenceResolution.y);</code><br>&emsp;&emsp; - Shrink：将 Canvas 大小进行相对于 ReferenceResolution 收缩，Canvas Size = Screen Size / Scale Factor，<code>Scale Factor = Mathf.Max(screenSize.x / m_ReferenceResolution.x, screenSize.y / m_ReferenceResolution.y);</code><br>&emsp;&emsp; - Match Width or Height：根据 Width 或 Height 或者二者的对数平均进行混合缩放，计算公式不摘抄。当 Match == 0 时，适配宽度：将宽度设置为屏幕宽度，并保持默认尺寸比例不变。如果此时高度超过屏幕高度，超出部分将会被裁切掉。当 Match == 1 时，适配高度。将高度设置为屏幕高度，并保持默认尺寸比例不变。如果此时宽度超过屏幕宽度，超出部分将会被裁切掉。<br><strong>③Constant Physical Size</strong>：无论屏幕大小和分辨率如何，UI 元素都保持相同的物理大小<br>&emsp;&emsp; - Physical Unit：单位之间换算关系为  </p><div class="table-container"><table><thead><tr><th style="text-align:left">单位种类</th><th style="text-align:left">和 1 inch 的比例</th></tr></thead><tbody><tr><td style="text-align:left">Centimeters</td><td style="text-align:left">2.54</td></tr><tr><td style="text-align:left">Millimeters</td><td style="text-align:left">25.4</td></tr><tr><td style="text-align:left">Inches</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">Points</td><td style="text-align:left">72</td></tr><tr><td style="text-align:left">Picas 皮卡</td><td style="text-align:left">6</td></tr></tbody></table></div><p>&emsp;&emsp; - Fallback Screen DPI：备用 Dpi，当找不到设备 Dpi 时，使用此值；<br>&emsp;&emsp; - Default Sprite DPI：默认图片 DPI。<br>&emsp;&emsp; - 计算公式：Scale =  Screen DPI / 换算比例；新的 Reference Pixels Per Unit = Reference Pixels Per Unit * Physical Unit / Default Sprite DPI；UI 大小 = 原图大小 Pixels / Pixels Per Unit * 新的 Reference Pixels Per Unit<br><strong>④World</strong>：此模式不能手动调出，当我们将 Canvas 的渲染模式调为 World Space 时 CanvasScaler 会强制改为此模式<br>&emsp;&emsp; - Dynamic Pixels Per Unit：UI 中动态创建的位图中的像素密度，值越高 UI 就越清楚。</p><h3 id="Graphic-Raycaster"><a href="#Graphic-Raycaster" class="headerlink" title="Graphic Raycaster"></a>Graphic Raycaster</h3><p>图形射线投射器，它适用于检测 UI 输入事件的射线发射器，其主要责任是通过射线检测玩家和 UI 元素的交互，判断是否点击到了 UI 元素。<br>①Ignore Reversed Graphic：是否忽略反转图形，绕 X 和 Y 轴可以使得反面朝前；<br>②Blocking Objects：设定射线被哪些类型的碰撞器阻挡，在 UI 元素前创建一个 3D 物体或一个 2D 物体，物体会阻挡按钮对点击事件的响应。注意：此项在 overlay 渲染模式下无效；<br>③Blocking Mask：设定射线被哪些层级的碰撞器阻挡，注意：此项在 overlay 渲染模式下无效。</p><h2 id="EventSystem"><a href="#EventSystem" class="headerlink" title="EventSystem"></a>EventSystem</h2><p>Event System 默认挂载两个组件：Event System、Standalone Input Module</p><p>使用 UGUI 制作界面时，EventSystem 的作用就像是为 UGUI 设计好的消息中心，它管理着所有能参与消息处理的 UGUI 元素，比如 Panel、Image、Button等。EventSytem 组件，是消息机制的核心。StandaloneInputModule，是负责产生输入的组件。StandaloneInputModule 继承自 BaseInputModule 实现类，类似的实现类 Unity 中还有另外几个，用户也可以自定义一个实现类用于事件处理。</p><h3 id="Event-System-组件"><a href="#Event-System-组件" class="headerlink" title="Event System 组件"></a>Event System 组件</h3><p>Event System 组件中轮询查询检测并做出相应的执行，它类似于一个中转站，和许多模块一起共同协作。如果没有它，所有的点击、拖曳等等行为都不会被响应。<br>①First Selected：默认第一个被选中的 UI 对象，此项常与 UI 导航事件一同使用。例如：选择为 InputField (输入框) 后 ，按下 Play 后就会将游标 Force 在 InputField 上；<br>②Send Navigation Events：是否允许导航事件（移动/按下/取消）；<br>③Drag Threshold：拖曳操作的阈值（移动多少像素系统会判断现在正在拖曳）。</p><h3 id="Standalone-Input-Module"><a href="#Standalone-Input-Module" class="headerlink" title="Standalone Input Module"></a>Standalone Input Module</h3><p>Standalone Input Module 是 Unity 的独立输入模块，它主要针对处理鼠标/键盘/控制器/触屏的输入，输入的事件通过 Event System 进行分发，它依赖于 Event System 组件，他们两者缺一不可。<br>①Horizontal Axis：水平轴按键对应的热键名（该名字对应 InputManager ）；<br>②Vertical Axis：垂直轴按键对应的热键名（该名字对应 InputManager ）；<br>③Submit Button：提交按钮对应的热键名（该名字对应 InputManager ）；<br>④Cancel Button：取消按键对应的热键名（该名字对应 InputManager ）；<br>⑤Input Actions Per Second：每秒允许键盘/控制器输入的数量；<br>⑥Repeat Delay：每秒输入操作重复率生效前的延迟时间。</p><h1 id="Unity-2D"><a href="#Unity-2D" class="headerlink" title="Unity 2D"></a>Unity 2D</h1><h2 id="Sprite"><a href="#Sprite" class="headerlink" title="Sprite"></a>Sprite</h2><p>Sprite 是 Unity 的 2D 图形对象，本质上也是纹理。Sprite 的工具主要包括：Sprite Editor、Sprite Renderer、Sprite Atlas。</p><p>导入 Project 的图像资源可以通过 Inspector 来更改属性，即 Sprite Import Settings。如果项目模式设置为 2D，则导入的图像将自动设置为精灵 Sprite。但是，如果项目模式设置为 3D，则图像将设置为纹理，因此需要更改资源的纹理类型为 Sprite (2D and UI)。</p><h3 id="Sprite-Import-Settings"><a href="#Sprite-Import-Settings" class="headerlink" title="Sprite Import Settings"></a>Sprite Import Settings</h3><p><strong>①Texture Type</strong><br>&emsp;&emsp; - Default：通用纹理类型；<br>&emsp;&emsp; - Normal map：选择此选项可将颜色通道转换为适合实时法线贴图的格式；<br>&emsp;&emsp; - Editor GUI and Legacy GUI :如果要在任何 HUD 或 GUI 控件上使用纹理，请选择此选项；<br>&emsp;&emsp; - Sprite (2D and UI)：2D 游戏中使用该纹理作为精灵，开发 UI 界面的时候一般都是选择的这个选项；<br>&emsp;&emsp; - Cursor：将纹理用作自定义游标；<br>&emsp;&emsp; - Cookie：光源的 Cookie 可以理解为一层 Mask，在光源前放一个遮罩，可以使得射出的光线形成某种图案(像是对光线的一种”过滤”)，Unity 中 Light 的 Cookie 是用纹理表示的；<br>&emsp;&emsp; - Lightmap：光照贴图；<br>&emsp;&emsp; - Single Channel：适用于在纹理中只需要一个通道的情况。<br><strong>②Sprite Mode</strong><br>包括 Single 、Multiple、Polygon。选择 Multiple，可以通过 Sprite Editor 进行分割；选择 Polygon 可根据 Sprite Editor 的 Sprite Custom Outline 中定义的网格来剪辑精灵纹理。<br><strong>③Pixels Per Unit</strong><br>修改 Pixels Per Unit 的值后，只有选中图片产生变化，场景界面中的网格不会产生变化。如果一个图片的大小是 16*16 像素，将 Pixels Per Unit 调整为 16 后，那么这张图片就会正好覆盖一个单元格。同理，如果一个图片的大小是 64*64 像素，此时还是将 Pixels Per Unit 设置为 16 的话，该图片就会正好覆盖 4 格单元格。<br><strong>④Mesh Type</strong><br>包括 Full Rect 和 Tight 模式，Full Rect 模式把一个 Sprite 渲染为一个带有透明区域的完整四边形。弊端就是可能会有很大一部分透明区域被渲染而造成性能浪费。建议选择 Tight。<br><strong>⑤Advanced - Alpha Source</strong><br>&emsp;&emsp; - None：无论输入纹理是否有 Alpha 通道，导入的纹理都没有 Alpha 通道；<br>&emsp;&emsp; - Input Texture Alpha ：如果提供了纹理，则使用输入纹理中的 Alpha；<br>&emsp;&emsp; - From Gray Scale: 从输入纹理 RGB 值的平均值生成 Alpha。即 alpha = (R + G + B) / 3。<br><strong>⑥Alpha Is Transparency</strong><br>用于解决多图片叠加纹理混合，插值的出来的 RGBA 产生不期望的颜色的问题，达到减少纹理过滤瑕疵的目的。建议勾选。<br><strong>⑦Wrap Mode</strong><br>Repeat：在区块中重复纹理；Clamp：拉伸纹理的边缘；Mirror: 在每个整数边界上镜像纹理以创建重复图案；Mirror Once：镜像纹理一次，然后将其钳制到边缘像素；Per-axis：单独控制 Unity 如何在 U 轴和 V 轴上包裹纹理。<br><strong>⑧Filter Mode</strong><br>纹理过滤(平滑)方式。若要不影响像素风格，建议选择 Point。Bilinear 和 Trilinear 会让纹理显得相对模糊一点。有兴趣可以了解一下 Bilinear、Trilinear 以及 Anistropic Filtering。<br><strong>⑨纹理压缩</strong><br>有解决性能需求可以去了解，不在本篇文章阐述。</p><h3 id="Sprite-Editor"><a href="#Sprite-Editor" class="headerlink" title="Sprite Editor"></a>Sprite Editor</h3><p>Sprite Editor 可以对 Multiple 模式下的纹理进行裁切，对 polygon 进行改变形状操作。</p><p>Sprite Editor也有很多模式：<br>①Custom Outline：用于编辑网格形状。默认情况下，Unity 渲染精灵网格为一个矩形，可以在该模式下减少网格的透明部分，增加游戏性能；<br>②Custom Physics Shape：用于编辑精灵的物理碰撞形状；可以手动修改，也可以让 Unity 根据 Outline Tolerance 自动生成；<br>③Secondary Textures：用于结合额外的纹理；<br>④Skinning Editor：用于骨骼绑定。</p><h3 id="Sprite-Renderer"><a href="#Sprite-Renderer" class="headerlink" title="Sprite Renderer"></a>Sprite Renderer</h3><p>一个 Sprite 游戏对象，至少拥有两个组件，Transform 组件和 Sprite Renderer 组件。其中 Sprite Renderer 组件就是用来在 Scene 中渲染显示出图像。</p><p><strong>①Draw Mode</strong><br>&emsp;&emsp; - Simple：拉伸；<br>&emsp;&emsp; - Sliced：九宫格缩放，原理就是把图片分成九宫格那样的区域，四个边角不变，只改变中间的区域，中间的横和中间的竖。这样缩放之后，再把四个边角贴上去，整体形状就不会改变；<br>&emsp;&emsp; - Tiled：将九宫格图片中间部分像砖块一样平铺。包含 Continuous 和 Adaptive 模式，Continuous 就是均匀平铺不拉伸，Adaptive 自适应拉伸。<br><strong>②Mask Interaction</strong><br>遮罩交互，有三种模式，分别是 None 默认、Visible Inside Mask 面罩内可见 、Visible Outside Mask 面罩外可见，需搭配 Sprite Mask 组件使用。<br><strong>③Material</strong><br>可以选择 Sprite-Lit-Default 或 Sprite-Unlit-Default，前面的材质受到光源系统的影响，后面的不受影响。可以在通用渲染管线 URP 里的 2D Renderer Data 资源修改默认的材质类型。</p><h3 id="Sprite-Atlas-图集"><a href="#Sprite-Atlas-图集" class="headerlink" title="Sprite Atlas 图集"></a>Sprite Atlas 图集</h3><p>Unity 通常会为场景中的每个纹理发出一个绘制调用 DrawCall；但是，在具有许多纹理的项目中，过多的绘制调用会占用大量资源，并会对项目的性能产生负面影响。为了降低性能消耗，我们可以使用精灵图集 Sprite Atlas 技术，它能够将多个纹理合并成一个大纹理，当访问图集中的多个纹理时，也只需要调用一次 DrawCall。</p><p>创建图集在 Assets -&gt; Create -&gt; 2D -&gt; Sprite Atlas，图集属性如下： </p><p><strong>①Type</strong><br>包括 Master 和 Variant，变体图集是主图集的副本，变体图集的主要目的是创建与主图集不同分辨率的图集，主图集中 Sprite 的分辨率 * Scale 缩放因子得到的结果就是变体图集中 Sprite 的分辨率，它自身不包含 Objects for Packing 属性，因此变体图集中的内容都是主图集的副本。</p><p>当项目中既有主图集，又有该主图集的变体图集时，可以使用这两个图集中任意一个的 Sprite 。如果要自动从变体图集而不是主图集中加载 Sprite，那就仅在变体图集启用 Include in Build 选项，并关闭主图集的这个选项。<br><strong>②Include in Build</strong><br>Unity 在打包的项目中会包含图集，并且在运行时自动加载它们。如果禁用 Include in Build，Unity 仍会将图集打包到项目 Assets 文件夹中的 .spriteatlas 文件中，只是运行的时候不会加载到内存中。因此，当精灵引用已禁用的图集中的纹理，由于引用纹理 not available or loaded，该纹理将无法被找到，引用它的图片将显示为空白。此时要加载精灵图集，必须使用脚本通过后期绑定 Late Binding 执行此操作。<br><strong>③Allow rotation</strong><br>允许打包时旋转精灵，最大限度地提高 Sprite 的密度。若用于 UI 元素建议关闭，因为在图集中旋转过的精灵在场景中也会旋转。<br><strong>④Tight Packing</strong><br>根据精灵轮廓而非精灵外部矩形的轮廓来打包，提高 Sprite 的密度。<br><strong>⑤Padding</strong><br>定义图集里精灵的像素间距，默认为4；<br><strong>⑥Read/Write</strong><br>是否要读写，一般都设置为 false，否则 CPU 会多一份内存。当我们创建纹理的时候 Unity 会将纹理数据上传到 GPU 层，CPU 层的数据就没用了，就删掉了，但是如果我们要修改或者处理纹理数据的时候就需要再 CPU 层保留这部分数据。那么此时 CPU 和 GPU 层就有了2份数据。<br><strong>⑦Generate Mip Maps</strong><br>是否生成 mipmap,生成 mipmap 后会让纵深场景的纹理显示效果更加平滑，效果更好，但同时内存也会增加三分之一。Mipmap 是以空间换时间形式的性能优化，建议额外了解。<br><strong>⑧sRGB</strong><br>gamma0.45 色彩空间，建议额外了解。场景的 Abedo (Base Color) 贴图、特效贴图、UI 贴图建议勾选 sRGB；通道贴图、Alpha 贴图不勾选 sRGB；法线贴图、光照贴图、环境贴图不需要关注是否勾选 sRGB。<br><strong>⑨filter mode</strong><br>之前有提到。对于 2d 游戏和 UI，可以选择 point 提升采样效率。<br><strong>⑩Use Crunch Compression</strong><br>建议勾选，默认质量50，更少的磁盘占用。虽然会使打包变慢，但会使包体更小，不影响压缩。</p><h2 id="Tilemaps"><a href="#Tilemaps" class="headerlink" title="Tilemaps"></a>Tilemaps</h2><p>Tilemap 即瓦片地图，主要用于快速编辑 2D 游戏中的场景，通过复用资源的形式提升地图多样性。默认情况下，Tilemap package 不包括在编辑器里面，需要从 Package Manager 安装。创建 Tilemaps 资源并使用有以下四步：<br>①先在 Assets -&gt; Create -&gt; 2D -&gt; Tile Palette 里根据需要创建瓦片调色板 Tile Palette。这里创建的一个预制件文件；<br>②在 Window -&gt; 2D -&gt; Tile Palette 打开调色板窗口；<br>③将图片资源拖入到窗口中，然后选择要保存的路径，也就是精灵保存为瓦片；<br>④在 Hierarchy 窗口中右键选择 2D Project —&gt; Tilemap 创建，此时 Scene 窗口中将出现网格 Grid，用选取器选中调色板中的图片，直接在 Scene 窗口中单击创建即可。可以创建多个 Tilemap，将其层级排序；<br>⑤根据需求添加 Tilemap Collider 2D 组件。</p><h3 id="Grid-组件相关参数"><a href="#Grid-组件相关参数" class="headerlink" title="Grid 组件相关参数"></a>Grid 组件相关参数</h3><p>①Layout：瓦片的网格布局包括 Rectangle、Hexagon、Isometric 等距、Isometric Z as Y。Isometric 通常就是 2D 游戏中经常说的 2.5D 或者斜 45 度的游戏类型；Isometric Z as Y 就是在Tile Palette 窗口中，可以调节瓦片的 Z 轴高度（需要取消对 lock z position 的勾选），在 Isometric Z as Y 类型的 Tilemap 中 Z 轴会被转换为 Y 轴的位置，从而实现瓦片堆叠的视觉效果；<br>②Cell Size：根据选择的布局会自动产生网格大小的数据，比如 Isometric 是（1，0.5，1），表示网格的宽度为 1 个 Unity 单位，宽为 0.5 个 Unity 单位。如果你所用到图片资源的宽度、高度都是固定大小，比如 72*36 等，使用 Unity 单位长度便于理解和管理资源。比如将导入的 Sprite 的 Pixels Per Unit 属性统一设置为 72 ，则（1，0.5，1）表示宽 72 像素、高 72 * 0.5 = 36 个像素；<br>③Cell Swizzle：Unity 将根据此选择，将现有 XYZ 坐标转换为选择的坐标。</p><h3 id="Grid-下的-Tilemap-的-Tilemap-组件相关参数"><a href="#Grid-下的-Tilemap-的-Tilemap-组件相关参数" class="headerlink" title="Grid 下的 Tilemap 的 Tilemap 组件相关参数"></a>Grid 下的 Tilemap 的 Tilemap 组件相关参数</h3><p>Grid 下的 Tilemap 是我们实际要“画” Tile 的对象层。可以根据需要在 Grid 下创建多层 Tilemap 用来作为地面层、建筑层、空中层、碰撞层等等。<br>①Animation Frame Rate：播放瓦片动画的速率，相当于倍速；<br>②Tile Anchor：即后面需要用到的 Tile 的锚点。与之对应的是图片 Sprite 的 Pivot 属性；<br>③Orientation：瓦片地图上瓦片的方向，相当于 2D 平面使用的是 Unity 中的哪两个轴。</p><h3 id="Grid-下的-Tilemap-的-Tilemap-Renderer-组件相关参数"><a href="#Grid-下的-Tilemap-的-Tilemap-Renderer-组件相关参数" class="headerlink" title="Grid 下的 Tilemap 的 Tilemap Renderer 组件相关参数"></a>Grid 下的 Tilemap 的 Tilemap Renderer 组件相关参数</h3><p>①Sort Order：设置所选瓦片地图上的瓦片排序方向；<br>②Mode：渲染器的渲染模式<br>&emsp;&emsp; - Chunk：按位置对瓦片进行分组，并将瓦片精灵一起批处理进行渲染，性能较好；<br>&emsp;&emsp; - Individual：单独渲染每个瓦片，会考虑他们的位置和排序顺序。会让瓦片精灵和场景中其他渲染器或自定义排序轴进行交互。等距瓦片一般选择此项；<br>③Detect Chunk Culling：渲染器如何剔除瓦片地图的边界<br>&emsp;&emsp; - Auto：自动检测；<br>&emsp;&emsp; - Manual：手动设置拓展边界。<br>④Mask Interaction：遮罩交互<br>&emsp;&emsp; - None：不与场景中任何精灵遮罩交互；<br>&emsp;&emsp; - Visible Inside mask：精灵遮罩覆盖的地方可见，而遮罩外部不可见；<br>&emsp;&emsp; - Visible Outside mask：精灵遮罩外部的地方可见，而遮罩覆盖处不可见。 </p><h3 id="关于瓦片的其他需了解的"><a href="#关于瓦片的其他需了解的" class="headerlink" title="关于瓦片的其他需了解的"></a>关于瓦片的其他需了解的</h3><p>可创建的瓦片类型：<br>①规则瓦片 Rule Tile：定义不同方向是否存在连接图片的规则，让我们更加快捷的进行地图编辑；<br>②动画瓦片 Animated Tile：可以指定序列帧，产生可以播放序列帧动画的瓦片；  </p><p>上述瓦片类型可以帮助我们更加快捷、方便的编辑 2D 场景，建议额外了解。除了不同的瓦片类型，还可以自定义笔刷。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="持久化数据"><a href="#持久化数据" class="headerlink" title="持久化数据"></a>持久化数据</h2><p>游戏中持久化数据一般可分为两种：第一张是静态数据，例如 Excel 数据表，其特点是运行期间游戏程序只需要读取，不需要修改；另一种是游戏存档，其特点是运行期间游戏程序既需要读取，也需要修改。</p><p>可以使用 JSON、XML、YAML 进行序列化和反序列化。建议了解一下 C# Newtonsoft.Json。</p><h2 id="Prefab"><a href="#Prefab" class="headerlink" title="Prefab"></a>Prefab</h2><p>Unity 的<strong>预制件 Prefab</strong> 系统允许创建、配置和存储游戏对象及其所有组件、属性值和子游戏对象作为可重用资源。预制件资源充当模板，在此模板的基础之上可以在场景中创建新的预制件实例。</p><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>对项目的版本管理，通常将整个项目上传 SVN 或者 Git。然而资源在导入 Unity 时，会自动产生很多中间资源，这些资源是不需要上传的，只需将 Assets、ProjectSetting 文件夹下的所有文件以及 .meta 文件上传即可。</p><p><strong>.meta 文件</strong>是 Unity 自动生成的。每个游戏资源都会有一个对应的 .meta 文件，它会标记资源的一些设置信息，可以在资源视图面板中重新设置这些资源的参数。每个 .meta 文件都会记录 guid 这个重要信息，guid 就是用来关联资源与游戏对象的引用的。</p><h2 id="游戏打包"><a href="#游戏打包" class="headerlink" title="游戏打包"></a>游戏打包</h2><p>打包时，不是所有编辑模式下的资源都需要打包在发布的游戏包中的，Unity 会自动删除没有引用的资源，只会保留 Resources 目录以及 StreamingAssets 目录下的资源。</p><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p><strong>Resources 文件夹</strong>是 Unity 中标志性的目录，这个目录下的资源无论是否有引用关系，都会被强制打在游戏包中。Resources 文件夹可以是顶层目录，也可以是某个文件夹的子目录。Resources 目录下的资源尽量不要直接引用在场景中，不然这个资源会被场景和 Resources 打成两份。</p><h3 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h3><p>在网络游戏中，可能需要在运行时下载并更新资源，而 Unity 提供了 AssetBundle 组件，可以将指定的一部分资源构建成 AssetsBundle 文件，并将这些文件上传到 CDN 上以供下载。AssetBundle 可以理解为一种包文件，它可以将特定平台的非代码资源（模型、纹理、预制体、音频等）包含在内，并在运行时由 Unity 加载。通过 AssetBundle 技术，可以在游戏中实现资源的热更新。可以将文件保存在 StreamingAssets 目录下。</p>]]></content>
      
      
      <categories>
          
          <category> unity </category>
          
          <category> unity基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C#图解教程》读书笔记（五）</title>
      <link href="/2023/07/07/2023-07-07-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B5/"/>
      <url>/2023/07/07/2023-07-07-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇主要内容为：预处理指令，反射和特性，以及其他主题中的字符串、可空类型、Main方法、文档注释等等；<br>读书笔记仅为知识的记录，方便后续查找。<br>学习完成日期为2023年07月29日。 </p></blockquote><div  align="center">  <img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/></div><h1 id="第二十四章-预处理指令"><a href="#第二十四章-预处理指令" class="headerlink" title="第二十四章 预处理指令"></a>第二十四章 预处理指令</h1><h2 id="什么是预处理指令"><a href="#什么是预处理指令" class="headerlink" title="什么是预处理指令"></a>什么是预处理指令</h2><p>源代码指定了程序的定义，<strong>预处理指令 preprocessor directive</strong> 指示编译器如何处理源代码。例如，在某些情况下，我们可能希望编译器忽略一部分代码，而在其他情况下，我们可能希望代码被编译。预处理指令给了我们这样的选项。</p><p>在 C 和 C++ 中有实际的预处理阶段，此时预处理程序遍历源代码并且为之后的编译阶段准备文本输出流。在 C# 中没有实际的预处理程序。“预处理”指令由编译器来处理，而这个术语保留了下来。</p><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><p>下面是预处理指令最重要的一些语法规则：<br>①预处理指令必须和 C# 代码在不同的行；<br>②与 C# 语句不同，预处理指令不需要以分号结尾；<br>③包含预处理指令的每一行必须以#字符开始：<br>&emsp;&emsp;- 在#字符前可以有空格；<br>&emsp;&emsp;- 在#字符和指令之间可以有空格。<br>④允许行尾注释；<br>⑤在预处理指令所在的行不允许分隔符注释。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PremiumVersion     //没有分号，正确</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> BudgetVersion    //前面有空格，正确</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MediumVersion     //中间有空格，正确</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PremiumVersion     /* all bells &amp; whistles */ 不允许分隔符注释，错误</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BudgetVersion      // Stripped-down version 允许行尾注释，正确</span></span><br></pre></td></tr></table></figure><p>下表列出了预处理指令：</p><div class="table-container"><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">含义概要</th></tr></thead><tbody><tr><td style="text-align:left">#define identifier</td><td style="text-align:left">定义编译符号</td></tr><tr><td style="text-align:left">#undef identifier</td><td style="text-align:left">取消定义编译符号</td></tr><tr><td style="text-align:left">#if expression</td><td style="text-align:left">如果表达式是true，则编译器编译下面的片段</td></tr><tr><td style="text-align:left">#elif expression</td><td style="text-align:left">如果表达式是true，则编译器编译下面的片段</td></tr><tr><td style="text-align:left">#else</td><td style="text-align:left">如果之前的#if或#elif表达式是false，则编译器编译下面的片段</td></tr><tr><td style="text-align:left">#endif</td><td style="text-align:left">标记一个#if结构的结束</td></tr><tr><td style="text-align:left">#region name</td><td style="text-align:left">标记一段代码的开始，没有编译效果</td></tr><tr><td style="text-align:left">#endregion name</td><td style="text-align:left">标记一段代码的结束，没有编译效果</td></tr><tr><td style="text-align:left">#warning message</td><td style="text-align:left">显示编译时的警告消息</td></tr><tr><td style="text-align:left">#error message</td><td style="text-align:left">显示编译时的错误消息</td></tr><tr><td style="text-align:left">#line indicator</td><td style="text-align:left">修改在编译器消息中显示的行数</td></tr><tr><td style="text-align:left">#pragma warning</td><td style="text-align:left">提供修改编译器警告消息行为的选项</td></tr></tbody></table></div><h2 id="define-和-undef-指令"><a href="#define-和-undef-指令" class="headerlink" title="#define 和 #undef 指令"></a><code>#define</code> 和 <code>#undef</code> 指令</h2><p><strong>编译符号 compilation symbol</strong> 是只有两种可能状态的标识符，要么被定义，要么未被定义。编译符号有如下特性：<br>①它可以是除了 true 或 false 以外的任何标识符，包括 C# 关键字，以及在 C# 代码中声明的标识符，这两者都是可以的；<br>②它没有值。与 C 和 C++ 不同，它不表示字符串。</p><p><code>#define</code> 和 <code>#undef</code> 指令只能用在源文件的第一行，也就是任何 C# 代码之前。在 C# 代码开始后，<code>#define</code> 和 <code>#undef</code> 指令就不能再使用。编译符号的范围被限制于单个源文件。只要编译符号在任何 C# 代码之前，重复定义已存在的编译符号也是允许的。</p><p>定义一个标识符相当于将其值设置为 true。取消定义一个标识符相当于将其值设置为 false。尽管必须在 C# 代码之外定义标识符，但可以在 C# 代码中使用它，通常是在 <code>#if #else</code> 构造中使用，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> debug</span></span><br><span class="line">        <span class="comment">//开启详细日志</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">//性能优化</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>条件编译允许根据某个编译符号是否被定义标注一段代码被编译或跳过。</p><p>有4个指令可以用来指定条件编译：<code>#if</code>; <code>#else</code>; <code>#elif</code>; <code>#endif</code>。</p><p>在<code>#if</code>和<code>#elif</code>指令中使用的条件是一个返回 true 或 false 的简单表达式，如下表所总结的。条件可以由单个编译符号、符号表达式或操作符组成；子条件可以使用圆括号分组；文本 true 或 false 也可以在条件表达式中使用：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数类型</th><th style="text-align:left">意义</th><th style="text-align:left">运算结果</th></tr></thead><tbody><tr><td style="text-align:left">编译符号</td><td style="text-align:left">使用<code>#define</code>指令定义（或未被定义）的标识符</td><td style="text-align:left">true：如果符号已经使用<code>#define</code>指令定义 <br> false：其他</td></tr><tr><td style="text-align:left">表达式</td><td style="text-align:left">使用符号和操作符!、==、!=、&amp;&amp;、&#9474;&#9474;构建的</td><td style="text-align:left">true：如果表达式运算结果为true <br> false：其他</td></tr></tbody></table></div><p>条件编译示例如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !DemoVersion //表达式</span></span><br><span class="line">    …</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(LeftHanded &amp;&amp; OemVersion) //完整版</span></span><br><span class="line">    …</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> true //下面的代码片段总是会被编译</span></span><br><span class="line">    …</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="条件编译结构"><a href="#条件编译结构" class="headerlink" title="条件编译结构"></a>条件编译结构</h2><p><code>#if</code> 和 <code>#endif</code> 指令在条件编译结构中需要配对使用。</p><p>例如，如下的代码演示了简单的 <code>#if...#else</code> 结构。如果符号 RightHanded 被定义了，那么 <code>#if</code> 和 <code>#else</code> 之间的代码会被编译。否则，<code>#else</code> 和 <code>#endif</code> 之间的代码会被编译：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> RightHanded</span></span><br><span class="line">    <span class="comment">// Code implementing right-handed functionality</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// Code implementing left-handed functionality</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如下的代码演示了 <code>#if...#elif...#else</code> 结构。包含程序版本描述的字符串根据定义的编译符号被设置为不同的值：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DemoVersionWithoutTimeLimit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">int</span> intExpireLength = <span class="number">30</span>;</span><br><span class="line">        <span class="built_in">string</span> strVersionDesc = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">int</span> intExpireCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DemoVersionWithTimeLimit</span></span><br><span class="line">    intExpireCount = intExpireLength;</span><br><span class="line">    strVersionDesc = <span class="string">&quot;This version of Supergame Plus will expire in 30 days&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DemoVersionWithoutTimeLimit</span></span><br><span class="line">    strVersionDesc = <span class="string">&quot;Demo Version of Supergame Plus&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> OEMVersion</span></span><br><span class="line">    strVersionDesc = <span class="string">&quot;Supergame Plus, distributed under license&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    strVersionDesc = <span class="string">&quot;The original Supergame Plus!!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(strVersionDesc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Demo Version of Supergame Plus</span><br></pre></td></tr></table></figure><h2 id="诊断指令"><a href="#诊断指令" class="headerlink" title="诊断指令"></a>诊断指令</h2><p><strong>诊断指令 Diagnostic Directives</strong> 产生用户自定义的编译时警告及错误消息。</p><p>下面是诊断指令的语法。 Message 是字符串，但是需要注意，与普通的 C# 字符串不同，它们不需要被引号包围。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">warning</span> Message</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Message</span></span><br></pre></td></tr></table></figure><p>当编译器遇到诊断指令时，它会输出相关的消息。诊断指令的消息会和任何编译器产生的警告和错误消息列在一起。</p><h2 id="行号指令"><a href="#行号指令" class="headerlink" title="行号指令"></a>行号指令</h2><p><strong>行号指令 Line number directives</strong> 可以做很多事情，诸如：<br>①改变由编译器警告和错误消息报告的出现行数；<br>②改变被编译源文件的文件名；<br>③对交互式调试器隐藏一些行。</p><p><code>#line</code> 指令的语法如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">line</span> integer    //将下一行的行号设置为整数</span></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> &quot;filename&quot; //设置文件名</span></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> default    //重新保存实际的行号和文件名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> hidden     //对断点调试器隐藏以下代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">line</span>            //停止在调试器中隐藏代碼</span></span><br></pre></td></tr></table></figure><p>带一个整数参数的 <code>#line</code> 指令会使编译器将该值视为下一行代码的行号，之后的行号会在这个行号的基础上递增。<br>①要改变文件名，可以在双引号内使用文件名作为参数。双引号是必需的；<br>②要返回真实行号和真实文件名，可以使用 default 参数；<br>③要对交互式调试器的断点调试功能隐藏代码段，可以使用 hidden 作为参数。要停止隐藏，可以使用不带任何参数的指令。到目前为止，这个功能大多用于在 ASP.NET 和 WPF 中隐藏编译器生成的代码。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">line</span> 226</span></span><br><span class="line">    x = y + z; <span class="comment">//现在编译器认为这是第226行</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 330 &quot;SourceFile.cs&quot; //改变报告的行号和文件名</span></span><br><span class="line">    var1 = var2 + var3;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> default //重新保存行号和文件名</span></span><br></pre></td></tr></table></figure><h2 id="区域指令"><a href="#区域指令" class="headerlink" title="区域指令"></a>区域指令</h2><p><strong>区域指令 region directive</strong> 允许标注和有选择性地命名一段代码。区域由一个 region 指令和某下方某处的一个 <code>#endregion</code> 指令构成。通过仅显示当前要处理的代码区域，区域功能可以让你更轻松地浏览代码。它还允许你通过位置组织代码，例如所有的属性放在同一位置，所有方法放在另一个位置。<code>#region</code> 指令的特性如下：<br>①<code>#region</code> 指令被放置在你想要标注的代码段上，而 <code>#endregion</code> 指令被放置在区域中最后一行代码之后；<br>②<code>#region</code> 指令用其后的可选文本字符串作为区域的名称；<br>③区域可以内嵌在其他的区域内：<br>&emsp;&emsp;- 区域可以内嵌到任何级别，区域可以嵌套；<br>&emsp;&emsp;- <code>#endregion</code> 指令始终与其上方的第一个没匹配过的 <code>#region</code> 指令匹配。</p><p>尽管区域指令被编译器忽略，但它们可以被源代码工具所使用。例如，Visual Studio允许我们很简单地隐藏或显式区域。作为示例，下面的代码中有一个叫做 Constructors 的区域，它封闭了 MyClass 类的两个构造函数。在 Visual Studio 中，如果不想看到其中的代码，可以把这个区域折叠成一行，如果又想对它进行操作或增加另外一个构造函数，还可以扩展它：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">region</span> Constructors</span></span><br><span class="line">    MyClass()</span><br><span class="line">    &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    MyClass(<span class="built_in">string</span> s)</span><br><span class="line">    &#123; ... &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure><h2 id="pragma-warning-指令"><a href="#pragma-warning-指令" class="headerlink" title="#pragma warning 指令"></a><code>#pragma warning</code> 指令</h2><p>利用 <code>#pragma warning</code> 指令可以关闭及重新开启警告消息：<br>①要关闭警告消息，可以使用 disable 形式加上希望关闭的警告数的逗号分隔的形式列表；<br>②要重新开启警告消息，可以使用 restore 形式加上希望关闭的警告数的逗号分隔的形式列表。</p><p>例如，下面的代码关闭了两个警告消息：618和414。在后面的代码中又开启了618警告消息，但还是保持414消息为关闭状态：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> disable 618, 414 //要关闭的警告信息</span></span><br><span class="line">    ... <span class="comment">//列出的警告信息在这段代码中处于关闭状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> restore 618</span></span><br></pre></td></tr></table></figure><p>如果我们使用任意一种不带警告数字列表的形式，这个命令会应用于所有警告。例如，下面的代码关闭然后恢复所有警告消息：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> disable</span></span><br><span class="line">    ... <span class="comment">//所有警告信息在这段代码中处于关闭状态</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> restore</span></span><br><span class="line">    ... <span class="comment">//所有警告信息在这段代码中处于开启状态</span></span><br></pre></td></tr></table></figure><h1 id="第二十五章-反射和特性"><a href="#第二十五章-反射和特性" class="headerlink" title="第二十五章 反射和特性"></a>第二十五章 反射和特性</h1><h2 id="元数据和反射"><a href="#元数据和反射" class="headerlink" title="元数据和反射"></a>元数据和反射</h2><p>大多数程序都要处理数据，包括读、写、操作和显示数据。（图形也是数据的一种形式。）然而，对于某些程序来说，它们操作的数据不是数字、文本或图形，而是关于程序和程序类型的信息。<br>①有关程序及其类型的数据被称为<strong>元数据 metadata</strong>，它们保存在程序的程序集中；<br>②程序在运行时，可以查看其他程序集或其本身的元数据。运行中的程序査看本身的元数据或其他程序的元数据的行为叫做<strong>反射 reflection</strong>。</p><p>对象浏览器是显式元数据的程序的一个示例。它可以读取程序集，然后显示所包含的类型以及类型的所有特性和成员。</p><p>本章将介绍程序如何使用 <strong>Type 类</strong>来反射数据，以及程序员如何使用<strong>特性 attributes</strong> 来给类型添加元数据。</p><blockquote><p>要使用反射，我们必须使用 System.Reflection 命名空间。</p></blockquote><h2 id="Type-类"><a href="#Type-类" class="headerlink" title="Type 类"></a>Type 类</h2><p>BCL 声明了一个叫做 Type 的抽象类，它被设计用来包含类型的特性。使用这个类的对象能获取程序使用的类型的信息。</p><p>由于 Type 是抽象类，因此它不能有实例。在运行时，CLR 创建从 Type(RuntimeType) 派生的类的实例，Type 包含了类型信息。当访问这些实例时，CLR 不会返回派生类的引用而是返回 Type 基类的引用。但是，为了简单起见，在本章剩余的篇幅中，会把引用所指向的对象称为 Type 类型的对象（虽然从技术角度来说它是一个 BCL 内部的派生类型的对象）。</p><p>需要了解的有关 Type 的重要事项如下：<br>①对于程序中用到的每一个类型，CLR 都会创建一个包含这个类型信息的 Type 类型的对象；<br>②不管创建的类型有多少个实例，只有一个 Type 对象会关联到所有这些实例。</p><p>下图显示了一个运行的程序，它有两个 MyClass 对象和一个 OtherClass 对象。注意，尽管有两个 MyClass 的实例，只会有一个 Type 对象来表示它：</p><div  align="center">  <img src="https://s2.loli.net/2023/07/08/GSnWuZd9UPpOIfE.png" width = "60%" height = "60%" alt="图120 - 对于程序中使用的每一个类型，CLR都会实例化Type类型的对象"/></div><p>可以从 Type 对象中获取有关类型的几乎所有信息。下表列出了 System.Type 类的部分成员：</p><div class="table-container"><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">成员类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Name</td><td style="text-align:left">属性</td><td style="text-align:left">返回类型的名字</td></tr><tr><td style="text-align:left">Namespace</td><td style="text-align:left">属性</td><td style="text-align:left">返回包含类型声明的命名空间</td></tr><tr><td style="text-align:left">Assembly</td><td style="text-align:left">属性</td><td style="text-align:left">返回声明类型的程序集。如果类型是泛型的，返回定义这个类型的程序集</td></tr><tr><td style="text-align:left">GetFields</td><td style="text-align:left">方法</td><td style="text-align:left">返回类型的字段列表</td></tr><tr><td style="text-align:left">GetProperties</td><td style="text-align:left">方法</td><td style="text-align:left">返回类型的属性列表</td></tr><tr><td style="text-align:left">GetMethods</td><td style="text-align:left">方法</td><td style="text-align:left">返回类型的方法列表</td></tr></tbody></table></div><h2 id="获取-Type-对象"><a href="#获取-Type-对象" class="headerlink" title="获取 Type 对象"></a>获取 Type 对象</h2><p>本节学习，使用实例对象的 GetType 方法或者 typeof 运算符和类名来获取 Type 对象。object 类型包含了一个叫做 GetType 的方法，它返回对实例的 Type 对象的引用。由于每一个类型最终都是从 object 派生的，所以我们可以在任何类型的对象上使用 <strong>GetType 方法</strong>来获取它的 Type 对象，如下所示：<code>Type t = myInstance.GetType();</code></p><p>下面的代码演示了如何声明一个基类以及从它派生的子类。Main 方法创建了每一个类的实例并且把这些引用放在了一个叫做 bca 的数组中以方便使用。在外层的 foreach 循环中，代码得到了 Type 对象并且输出类的名字，然后获取类的字段并输出。代码后的图演示了内存中的对象：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection; <span class="comment">//必须使用该命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> BaseField = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> DerivedField = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> bc = <span class="keyword">new</span> BaseClass();</span><br><span class="line">        <span class="keyword">var</span> dc = <span class="keyword">new</span> DerivedClass();</span><br><span class="line"></span><br><span class="line">        BaseClass[] bca = <span class="keyword">new</span> BaseClass[] &#123; bc, dc &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> v <span class="keyword">in</span> bca)</span><br><span class="line">        &#123;</span><br><span class="line">            Type t = v.GetType(); <span class="comment">//获取类型</span></span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Object type : <span class="subst">&#123; t.Name &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            FieldInfo[] fi = t.GetFields(); <span class="comment">//获取字段信息</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> f <span class="keyword">in</span> fi)</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot; Field : <span class="subst">&#123; f.Name &#125;</span>&quot;</span>);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Object type : BaseClass</span><br><span class="line"> Field : BaseField</span><br><span class="line"></span><br><span class="line">Object type : DerivedClass</span><br><span class="line"> Field : DerivedField</span><br><span class="line"> Field : BaseField</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/07/08/IayVTBjoL7MAkeO.png" width = "60%" height = "60%" alt="图121 - 基类和派生类对象以及它们的 Type 对象"/></div><p>还可以使用 <strong>typeof 运算符</strong>来获取 Type 对象。只需要提供类型名作为操作数，它就会返回 Type 对象的引用，如下所示：<code>Type t = typeof( DerivedClass );</code></p><p>示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection; <span class="comment">//必须使用该命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleReflection</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> BaseField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> DerivedField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Type tbc = <span class="keyword">typeof</span>(DerivedClass); <span class="comment">//获取类型</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Object type : <span class="subst">&#123; tbc.Name &#125;</span>&quot;</span>);</span><br><span class="line">            FieldInfo[] fi = tbc.GetFields();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> f <span class="keyword">in</span> fi)</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot; Field : <span class="subst">&#123; f.Name &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Object type : DerivedClass</span><br><span class="line"> Field : DerivedField</span><br><span class="line"> Field : BaseField</span><br></pre></td></tr></table></figure><h2 id="什么是特性"><a href="#什么是特性" class="headerlink" title="什么是特性"></a>什么是特性</h2><p><strong>特性 attribute</strong> 是一种允许我们向程序的程序集增加元数据的语言结构。它是用于保存程序结构信息的某种特殊类型的类：<br>①将应用了特性的程序结构 program construct 叫做目标 target ；<br>②设计用来获取和使用元数据的程序（比如对象浏览器）叫做特性的消费者 consumer ；<br>③ .NET 预定了很多特性，我们也可以声明自定义特性。</p><p>下图是使用特性中相关组件的概览，并且演示了如下有关特性的要点：<br>①我们在源代码中将特性应用于程序结构；<br>②编译器获取源代码并且从特性产生元数据，然后把元数据放到程序集中；<br>③消费者程序可以获取特性的元数据以及程序中其他组件的元数据。注意，编译器同时生产和消费特性。</p><div  align="center">  <img src="https://s2.loli.net/2023/07/08/CFOw2pD6xrQIb5G.png" width = "60%" height = "60%" alt="图122 - 创建和使用特性的相关组件"/></div><p>根据惯例，特性名使用 Pascal 命名法并且以 Attribute 后缀结尾。当为目标应用特性时，可以不使用后缀。例如，对于 SerializableAttribute 和 MyAttributeAttribute 这两个特性，在把它们应用到结构时可以使用 Serializable 和 MyAttribute 短名称。</p><h2 id="应用特性"><a href="#应用特性" class="headerlink" title="应用特性"></a>应用特性</h2><p>特性的目的是告诉编译器把程序结构的某组元数据嵌入程序集。我们可以通过把特性应用到结构来实现：<br>①通过在结构前放置<strong>特性片段 attribute section</strong> 来应用特性；<br>②<strong>特性片段</strong>由方括号包围特性名和参数列表（可以没有）构成。</p><p>例如，下面的代码演示了两个类的开始部分。最初的几行代码演示了把一个叫做 Serializable 的特性应用到 MyClass 。注意，Serializable 没有参数列表。第二个类的声明有一个叫做 MyAttribute 的特性，它有一个带有两个 string 参数的参数列表：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[ Serializable ] <span class="comment">//特性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123; ...</span><br><span class="line"></span><br><span class="line">[ MyAttribute(<span class="string">&quot;Simple class&quot;</span>, <span class="string">&quot;Version 3.57&quot;</span>) ] <span class="comment">//带有参数的特性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyOtherClass</span></span><br><span class="line">&#123; ...</span><br></pre></td></tr></table></figure><p>有关特性需要了解的重要事项如下：<br>①大多数特性只应用于直接跟随在一个或多个特性片段后的结构；<br>②应用了特性的结构称为被特性装饰（ decorated 或 adorned ）。</p><h2 id="预定义的特性"><a href="#预定义的特性" class="headerlink" title="预定义的特性"></a>预定义的特性</h2><p>本节介绍几个 .NET 预定义特性</p><h3 id="Obsolete-特性"><a href="#Obsolete-特性" class="headerlink" title="Obsolete 特性"></a>Obsolete 特性</h3><p>一个程序可能在其生命周期中经历多次发布，而且很可能延续多年。在程序生命周期的后半部分，程序员经常需要编写类似功能的新方法替换老方法。出于多种原因，你可能不想再使用那些调用过时的旧方法的老代码，而只想用新编写的代码调用新方法。</p><p>如果出现这种情况，你肯定希望稍后操作代码的团队成员或程序员也只使用新代码。要警告他们不要使用旧方法，可以使用 Obsolete 特性将程序结构标注为过期的，并且在代码编译时显示有用的警告消息。以下代码给出了一个示例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Obsolete(<span class="string">&quot;Use method SuperPrintOut&quot;</span>)</span>] <span class="comment">//将特性应用到方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> str</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        PrintOut(<span class="string">&quot;Start of Main&quot;</span>); <span class="comment">//调用 obsolete 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，即使 PrintOut 被标注为过期，Main 方法还是调用了它。代码编译也运行得很好，并且产生了如下的输出：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Start of Main</span><br></pre></td></tr></table></figure><p>不过，在编译的过程中，编译器产生了下面的 CS0618 警告消息来通知我们正在使用一个过期的结构:<code>[CS0618] “Program.PrintOut(string)”已过时:“Use method SuperPrintOut”</code></p><p>Obsolete 特性的另外一个重载接受了 bool 类型的第二个参数。这个参数指定目标是否应该被标记为错误而不仅仅是瞥告。以下代码指定了它应被标记为错误：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[ Obsolete(<span class="string">&quot;Use method SuperPrintOut&quot;</span>, <span class="literal">true</span>) ] <span class="comment">//标记为错误，将特性应用到方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123; ...</span><br></pre></td></tr></table></figure><h3 id="Conditional-特性"><a href="#Conditional-特性" class="headerlink" title="Conditional 特性"></a>Conditional 特性</h3><p>Conditional 特性允许我们包括或排斥特定方法的所有调用。要使用 Conditional 特性，将其应用于方法声明并把编译符作为参数：<br>①如果定义了编译符号，那么编译器会包含所有调用这个方法的代码，这和普通方法没有什么区别；<br>②如果没有定义编译符号，那么编译器会忽略代码中这个方法的所有调用；<br>③定义方法的 CIL 代码本身总是会包含在程序集中。只是调用代码会被插入或忽略；<br>④除了在方法上使用 Conditional 特性之外，还可以在类上使用它，只要该类派生自 Attribute 类。这里不会介绍 Conditional 特性的这种用法。</p><p>在方法上使用 Conditional 特性的规则如下：<br>①该方法必须是类或结构体的方法；<br>②该方法必须是 void 类型；<br>③该方法不能被声明为 override，但可以标记为 virtual；<br>④该方法不能是接口方法的实现。</p><p>例如，在如下的代码中，Conditional 特性被应用到一个叫作 TraceMessage 的方法的声明上。特性只有一个参数，在这里是字符串 DoTrace 。<br>①当编译器编译这段代码时，它会检査是否定义了一个名为 DoTrace 的编译符号；<br>②如果定义了 DoTrace ，编译器就会像往常一样在代码中包含所有对 TraceMessage 方法的调用；<br>③如果没有定义 DoTrace 编译符号，编译器就不会输出任何对 TraceMessage 的任何调用代码。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Conditional( <span class="string">&quot;DoTrace&quot;</span> )</span>] <span class="comment">//编译符号</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TraceMessage</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>Conditional 特性的示例</em></strong><br>以下代码演示了一个使用 Conditional 特性的完整示例：<br>①Main 方法包含了两个对 TraceMessage 方法的调用；<br>②TraceMessage 方法的声明被用 Conditional 特性装饰，它带有 DoTrace 编译符号作为参数。因此，如果 DoTrace 被定义，那么编译器就会包含对 TraceMessage 所有调用的代码；<br>③由于代码的第一行定义了叫做 DoTrace 的编译符，编译器会包含两个 TraceMessage 的调用代码。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DoTrace</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AttributesConditional</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Conditional( <span class="string">&quot;DoTrace&quot;</span> )</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TraceMessage</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123; Console.WriteLine(str); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            TraceMessage(<span class="string">&quot;Start of Main&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Doing work in Main.&quot;</span>);</span><br><span class="line">            TraceMessage(<span class="string">&quot;End of Main&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：  </p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Start of Main</span><br><span class="line">Doing work in Main.</span><br><span class="line">End of Main</span><br></pre></td></tr></table></figure><p>如果注释掉第一行来取消 DoTrace 的定义，编译器就不再会插人两次对 TraceMessage 的调用代码。这次，如果我们运行程序，就会产生如下输出：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Doing work in Main.</span><br></pre></td></tr></table></figure><h3 id="调用者信息特性"><a href="#调用者信息特性" class="headerlink" title="调用者信息特性"></a>调用者信息特性</h3><p>利用调用者信息特性可以访问文件路径、代码行数、调用成员的名称等源代码信息。<br>①这三个特性名称为 CallerFilePath 、CallerLineNumber 和 CallerMemberName；<br>②这些特性只能用于方法中的可选参数。</p><p>下面的代码声明了一个名为 MyTrace 的方法，它在三个可选参数上使用了这三个调用者信息特性。如果调用方法时显式指定了这些参数，则会使用真正的参数值。但在下面所示的 Main 方法中调用时，没有显式提供这些值，因此系统将会提供源代码的文件路径、调用该方法的代码行数和调用该方法的成员名称。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyTrace</span>(<span class="params"> <span class="built_in">string</span> message,</span></span></span><br><span class="line"><span class="params"><span class="function">                                [CallerFilePath] <span class="built_in">string</span> fileName = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                [CallerLineNumber] <span class="built_in">int</span> lineNumber = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                [CallerMemberName] <span class="built_in">string</span> callingMember = <span class="string">&quot;&quot;</span> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;File: <span class="subst">&#123; fileName &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Line: <span class="subst">&#123; lineNumber &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Called From: <span class="subst">&#123; callingMember &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Message: <span class="subst">&#123; message &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyTrace( <span class="string">&quot;Simple message&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">File: C:\Users\XXXX\XXXX\XXXX\Program.cs</span><br><span class="line">Line: 19</span><br><span class="line">Called From: Main</span><br><span class="line">Message: Simple message</span><br></pre></td></tr></table></figure><h3 id="DebuggerStepThrough-特性"><a href="#DebuggerStepThrough-特性" class="headerlink" title="DebuggerStepThrough 特性"></a>DebuggerStepThrough 特性</h3><p>我们在单步调试代码时，常常希望调试器不要进入某些方法。我们只想执行该方法，然后继续调试下一行。DebuggerStepThrough 特性告诉调试器在执行目标代码时不要进入该方法调试。</p><p>在我自己的代码中，这是最有用的特性。有些方法很小并且毫无疑问是正确的，在调试时对其反复单步调试只能徒增烦恼。但使用该特性时要十分小心，因为你并不想排除那些可能含有 bug 的代码。</p><p>关于 DebuggerStepThrough 要注意以下两点：<br>①该特性位于 System.Diagnostics 命名空间；<br>②该特性可用于类、结构、构造函数、方法或访问器。</p><p>下面这段编造的代码在一个访问器和一个方法上使用了该特性。你会发现，调试器调试这段代码时不会进入 IncrementFields 方法或 X 属性的 set 访问器。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics; <span class="comment">//DebuggerStepThrough特性所需的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> X</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">        [<span class="meta">DebuggerStepThrough</span>] <span class="comment">//不进入set访问器</span></span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            x = x * <span class="number">2</span>;</span><br><span class="line">            x += <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Program p = <span class="keyword">new</span> Program();</span><br><span class="line">        p.IncrementFields();</span><br><span class="line">        p.X = <span class="number">5</span>;</span><br><span class="line">        Console.WriteLine( <span class="string">$&quot;X = <span class="subst">&#123; p.X &#125;</span>, Y = <span class="subst">&#123; p.Y &#125;</span>&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DebuggerStepThrough</span>] <span class="comment">//不进入这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IncrementFields</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        X++; Y++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他预定义特性"><a href="#其他预定义特性" class="headerlink" title="其他预定义特性"></a>其他预定义特性</h3><p>.NET 框架预定义了很多编译器和 CLR 能理解和解释的特性，下表列出了一些。在表中使用了不带 Attribute 后缀的短名称。例如，CLSCompliant 的全名是 CLSCompliantAttribute 。</p><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">CLSCompliant</td><td style="text-align:left">声明公开暴露的成员应该被编译器检测其是否符号CLS。兼容的程序集可以被任何兼容.NET的语言使用</td></tr><tr><td style="text-align:left">Serializable</td><td style="text-align:left">声明结构可以被序列化</td></tr><tr><td style="text-align:left">NonSerialized</td><td style="text-align:left">声明结构不能被序列化</td></tr><tr><td style="text-align:left">DLLImport</td><td style="text-align:left">声明是非托管代码实现的</td></tr><tr><td style="text-align:left">WebMethod</td><td style="text-align:left">声明方法应该被作为 XML Web 服务的一部分暴露</td></tr><tr><td style="text-align:left">AttributeUsage</td><td style="text-align:left">声明特性能应用于什么类型的程序结构。将这个特性应用到特性声明上</td></tr></tbody></table></div><h2 id="关于应用特性的更多内容"><a href="#关于应用特性的更多内容" class="headerlink" title="关于应用特性的更多内容"></a>关于应用特性的更多内容</h2><p>本节介绍特性的一些其他使用方式。</p><h3 id="多个特性"><a href="#多个特性" class="headerlink" title="多个特性"></a>多个特性</h3><p>可以为单个结构应用多个特性：<br>①多个特性可以使用下面任何一种格式列出：<br>&emsp;&emsp;- 独立的特性片段一个接一个。通常，它们彼此叠加，位于不同的行中；<br>&emsp;&emsp;- 单个特性片段，特性之间使用逗号分隔。<br>②可以以任何次序列出特性。</p><p>例如，下面的两个代码片段显示了应用多个特性的两种方式。两个片段的代码是等价的。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[ Serializable ] <span class="comment">//多层结构</span></span><br><span class="line">[ MyAttribute(<span class="string">&quot;Simple class&quot;</span>, <span class="string">&quot;Version 3.57&quot;</span>) ]</span><br><span class="line"></span><br><span class="line">[ MyAttribute(<span class="string">&quot;Simple class&quot;</span>, <span class="string">&quot;Version 3.57&quot;</span>), Serializable ] <span class="comment">//逗号分隔</span></span><br></pre></td></tr></table></figure><h3 id="其他类型的目标"><a href="#其他类型的目标" class="headerlink" title="其他类型的目标"></a>其他类型的目标</h3><p>除了类，还可以将特性应用到诸如字段和属性等其他程序结构。以下的声明显示了字段上的特性以及方法上的多个特性：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">MyAttribute(<span class="string">&quot;Holds a value&quot;</span>, <span class="string">&quot;Version 3.2&quot;</span>)</span>] <span class="comment">//字段上的特性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> MyField;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Obsolete</span>] <span class="comment">//方法上的特性</span></span><br><span class="line">[<span class="meta">MyAttribute(<span class="string">&quot;Prints out a message.&quot;</span>, <span class="string">&quot;Version 3.6&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOut</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>还可以显式地标注特性，从而将它应用到特殊的目标结构。要使用<strong>显式目标说明符</strong>，在特性片段的开始处放置目标类型，后面跟冒号。例如，如下的代码用特性装饰方法，并且还把特性应用到返回值上：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">method: MyAttribute(<span class="string">&quot;Prints out a message.&quot;</span>, <span class="string">&quot;Version 3.6&quot;</span>)</span>] <span class="comment">//显式目标说明符</span></span><br><span class="line">[<span class="meta">return: MyAttribute(<span class="string">&quot;This value represents ...&quot;</span>, <span class="string">&quot;Version 2.3&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">ReturnSetting</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>C# 语言定义了10个标准的特性目标：event； field； method； param； property； return； type； typevar； assembly； module。大多数目标名可以自解释的，而 type 覆盖了类、结构、委托、枚举和接口。 typevar 目标名称为使用泛型的结构指定类型参数。</p><h3 id="全局特性"><a href="#全局特性" class="headerlink" title="全局特性"></a>全局特性</h3><p>还可以通过使用 assembly 和 module 目标名称来使用显式目标说明符把特性设置在程序集或模块级別。有关程序集级别的特性的要点如下：<br>①程序集级别的特性必须放置在任何命名空间之外，并且通常放置在 AssemblyInfo.cs 文件中；<br>②AssemblyInfo.cs 文件通常包含有关公司、产品以及版权信息的元数据。</p><p>如下的代码行摘自 AssemblyInfo.cs 文件：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">assembly: AssemblyTitle(<span class="string">&quot;SuperWidget&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyDescription(<span class="string">&quot;Implements the SuperWidget product.&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyConfiguration(<span class="string">&quot;&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyCompany(<span class="string">&quot;McArthur Widgets, Inc.&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyProduct(<span class="string">&quot;Super Widget Deluxe&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyCopyright(<span class="string">&quot;Copyright © McArthur Widgets 2012&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyTrademark(<span class="string">&quot;&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyCulture(<span class="string">&quot;&quot;</span>)</span>]</span><br></pre></td></tr></table></figure><h2 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h2><p>特性是一种特殊的类：<br>①用户自定义的特性类叫做自定义特性；<br>②所有特性类都派生自 System.Attribute 。</p><h3 id="声明自定义特性"><a href="#声明自定义特性" class="headerlink" title="声明自定义特性"></a>声明自定义特性</h3><p>总体来说，声明一个特性类和声明其他类一样。然而，有一些事项值得注意，如下所示：<br>①要声明一个自定义特性，需要做如下工作：<br>&emsp;&emsp;- 声明一个派生自 System.Attribute 的类；<br>&emsp;&emsp;- 给它起一个以后缀 Attribute 结尾的名字。<br>②安全起见，通常建议你声明一个 sealed 的特性类（密封类，不能被继承）。</p><p>例如，下面的代码显示了 MyAttributeAttribute 特性的声明的开始部分：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MyAttributeAttribute</span> : <span class="title">System.Attribute</span> <span class="comment">//特性名MyAttributeAttribute带后缀Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>由于特性持有目标的信息，所有特性类的公共成员只能是：①字段；②属性；③构造函数</p><h3 id="使用特性的构造函数"><a href="#使用特性的构造函数" class="headerlink" title="使用特性的构造函数"></a>使用特性的构造函数</h3><p>特性和其他类一样，有构造函数。每一个特性必须至少有一个公共构造函数：<br>①和其他类一样，如果你不声明构造函数，编译器会为你产生一个隐式、公共且无参的构造函数；<br>②特性的构造函数和其他构造函数一样，可以被重载；<br>③声明构造函数时必须使用类全名，包括<strong>后缀</strong>。我们只可以在应用特性时使用短名称。</p><p>如下，如果下面的构造函数名字没有后缀，编译器会产生一个错误消息：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyAttributeAttribute</span>(<span class="params"><span class="built_in">string</span> desc, <span class="built_in">string</span> ver</span>) <span class="comment">//包含后缀 Suffix</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Description = desc;</span><br><span class="line">    VersionNumber = ver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指定构造函数"><a href="#指定构造函数" class="headerlink" title="指定构造函数"></a>指定构造函数</h3><p>当我们为目标应用特性时，其实是在指定应该使用哪个构造函数来创建特性的实例。列在特性应用中的参数其实就是构造函数的参数。</p><p>例如，在下面的代码中，MyAttribute 被应用到一个字段和一个方法上。对于字段，声明指定了使用单个字符串参数的构造函数。对于方法，声明指定了使用两个字符串参数的构造函数。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">MyAttribute(<span class="string">&quot;Holds a value&quot;</span>)</span>] <span class="comment">//使用一个字符串的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> MyField;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MyAttribute(<span class="string">&quot;Version 1.3&quot;</span>, <span class="string">&quot;Galen Daniel&quot;</span>)</span>] <span class="comment">//使用两个字符串的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyMethod</span>()</span></span><br><span class="line">&#123; ...</span><br></pre></td></tr></table></figure><p>特性构造函数的其他要点如下：<br>①在应用特性时，构造函数的实参必须是在编译时能确定值的常量表达式；<br>②如果应用的特性构造函数没有参数，可以省略圆括号。例如，如下代码的两个类都使用 MyAttr 特性的无参构造函数。两种形式的意义是相同的。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">MyAttr</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span> ...</span><br><span class="line"></span><br><span class="line">[<span class="title">MyAttr</span>()]</span><br><span class="line"><span class="keyword">class</span> <span class="title">OtherClass</span> ...</span><br></pre></td></tr></table></figure><h3 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h3><p>和其他类一样，我们不能显式调用构造函数。特性的实例创建后，只有特性的消费者访问特性时才能调用构造函数。这一点与其他类的实例很不相同，这些实例都创建在使用对象创建表达式的位置。应用一个特性是一条声明语句，它不会决定什么时候构造特性类的对象。</p><p>下图比较了普通类构造函数的使用和特性的构造函数的使用：<br>①命令语句 imperative statement 的实际意义是：”在这里创建新的类”<br>②声明语句 declarative statement 的意义是：”这个特性和这个目标相关联，如果需要构造特性，使用这个构造函数”。</p><div  align="center">  <img src="https://s2.loli.net/2023/07/09/AFYQLha2wR4PEgG.png" width = "70%" height = "70%" alt="图123 - 比较构造函数的使用"/></div><h3 id="构造函数中的位置参数和命名参数"><a href="#构造函数中的位置参数和命名参数" class="headerlink" title="构造函数中的位置参数和命名参数"></a>构造函数中的位置参数和命名参数</h3><p>和普通类的方法与构造方法相似，特性的构造函数同样可以使用位置参数和命名参数。如下代码显示了使用一个位置参数和两个命名参数来应用一个特性：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个为位置参数，第二、三个为命名参数</span></span><br><span class="line">[<span class="meta">MyAttribute(<span class="string">&quot;An excellent class&quot;</span>,Reviewer=<span class="string">&quot;Amy McArthur&quot;</span>，Ver=<span class="string">&quot;0.7.15.33&quot;</span>)</span>]</span><br></pre></td></tr></table></figure><p>下面的代码演示了特性类的声明以及为 MyClass 类应用特性。注意，构造函数的声明只列出了一个形参，但我们可通过命名参数给构造函数3个实参。两个命名参数设置了字段 Ver 和 Reviewer 的值：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MyAttributeAttribute</span> : <span class="title">System.Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Ver;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Reviewer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAttributeAttribute</span>(<span class="params"><span class="built_in">string</span> desc</span>) <span class="comment">//一个形参</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Description = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MyAttribute(<span class="string">&quot;An excellent class&quot;</span>, Reviewer=<span class="string">&quot;Amy McArthur&quot;</span>, Ver=<span class="string">&quot;7.15.33&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和方法一样，构造函教需要的任何位置参数都必须放在命名参数之前。</p></blockquote><h3 id="限制特性的使用"><a href="#限制特性的使用" class="headerlink" title="限制特性的使用"></a>限制特性的使用</h3><p>我们已经看到了可以为类应用特性。而特性本身就是类，有一个很重要的预定义特性可以应用到自定义特性上，那就是 AttributeUsage 特性。我们可以使用它来限制将特性使用在某个目标类型上。</p><p>例如，如果我们希望自定义特性 MyAttribute 只能应用到方法上，那么可以以如下形式使用 AttributeUsage ：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[ AttributeUsage( AttributeTargets.Method ) ] <span class="comment">//只针对方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MyAttributeAttribute</span> : <span class="title">System.Attribute</span></span><br><span class="line">&#123; ...</span><br></pre></td></tr></table></figure><p>AttributeUsage 有3个重要的公共属性，如下表所示。表中显示了属性名和属性的含义。对于后两个属性，还显示了它们的默认值：  </p><div class="table-container"><table><thead><tr><th style="text-align:left">名字</th><th style="text-align:left">意义</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">ValidOn</td><td style="text-align:left">保存能应用特性的目标类型的列表。构造函数的第一个参数必须是 AttributeTargets 类型的枚举值</td><td style="text-align:left">N/A</td></tr><tr><td style="text-align:left">Inherited</td><td style="text-align:left">一个布尔值，它指示特性是否可被装饰类型的派生类所继承</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">AllowMultiple</td><td style="text-align:left">一个布尔值，指示目标上是否可应用特性的多个实例的</td><td style="text-align:left">false</td></tr></tbody></table></div><p><strong><em>AttributeUsage 的构造函数</em></strong><br>AttributeUsage 的构造函数接受单个位置参数，该参数指定了可使用特性的目标类型。它用这个参数来设置 ValidOn 属性，可接受的目标类型是 AttributeTargets 枚举的成员。AttributeTargets 枚举的完整成员：All； Assembly； Class； Constructor； Delegate； Enum； Event； Field； GenericParameter； Interface； Method； Module； Parameter； Property； ReturnValue； Struct。</p><p>可以通过使用按位或运算符来组合使用类型。例如，在下面的代码中，被装饰的特性只能应用到方法和构造函数上：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[ AttributeUsage( AttributeTargets.Method | AttributeTargets.Constructor ) ]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MyAttributeAttribute</span> : <span class="title">System.Attribute</span></span><br><span class="line">&#123; ...</span><br></pre></td></tr></table></figure><p>当为特性声明应用 AttributeUsage 时，构造函数至少需要一个必需的参数，参数包含的目标类型会保存在 ValidOn 中。还可以通过使用命名参数有选择性地设置 Inherited 和 AllowMultiple 属性。如果不设置，它们会保持如之前所示的默认值。</p><p>作为示例，下面一段代码指定了 MyAttribute 的如下方面：<br>①MyAttribute 能且只能应用到类上；<br>②MyAttribute 不会被应用它的派生类所继承；<br>③不能在同一个目标上应用 MyAttribute 的多个实例。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[ AttributeUsage( AttributeTargets.Class, <span class="comment">//必需的位置参数</span></span><br><span class="line">                    Inherited = <span class="literal">false</span>, <span class="comment">//可选的命名参数</span></span><br><span class="line">                    AllowMultiple = <span class="literal">false</span> ) ] <span class="comment">//可选的命名参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MyAttributeAttribute</span> : <span class="title">System.Attribute</span></span><br><span class="line">&#123; ...</span><br></pre></td></tr></table></figure><h3 id="自定义特性的最佳实践"><a href="#自定义特性的最佳实践" class="headerlink" title="自定义特性的最佳实践"></a>自定义特性的最佳实践</h3><p>强烈推荐编写自定义特性时参考如下实践：<br>①特性类应该表示目标结构的某些状态；<br>②如果特性需要某些字段，可以通过包含具有位置参数的构造函数来收集数据，可选字段可以采用命名参数按需初始化；<br>③除了属性之外，不要实现公共方法或其他函数成员；<br>④为了更安全，把特性类声明为 sealed ；<br>⑤在特性声明中使用 AttributeUsage 来显式指定特性目标组。</p><p>如下代码演示了这些准则：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage( AttributeTargets.Class )</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ReviewCommentAttribute</span> : <span class="title">System.Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> VersionNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ReviewerID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReviewCommentAttribute</span>(<span class="params"><span class="built_in">string</span> desc, <span class="built_in">string</span> ver</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Description = desc;</span><br><span class="line">        VersionNumber = ver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问特性"><a href="#访问特性" class="headerlink" title="访问特性"></a>访问特性</h2><p>可以使用 Type 对象来访问自定义特性。Type 的两个方法（IsDefined 和 GetCustomAttributes）在这里非常有用。</p><h3 id="使用-IsDefined-方法"><a href="#使用-IsDefined-方法" class="headerlink" title="使用 IsDefined 方法"></a>使用 IsDefined 方法</h3><p>可以使用 Type 对象的 IsDefined 方法来检测某个特性是否应用到了某个类上。</p><p>例如，以下的代码声明了一个特性类 MyClass ，并且作为自己的特性消费者在程序中访问被声明和应用的特性。代码的开始处是 MyAttribute 特性和应用特性的 MyClass 类的声明。这段代码做了下面的事情：<br>①首先，Main 创建了类的一个对象。然后通过使用从 object 基类继承的 GetType 方法获取了 Type 对象的一个引用；<br>②有了 Type 对象的引用，就可以调用 IsDefined 方法来判断 ReviewComment 特性是否应用到了这个类：<br>&emsp;&emsp;- 第一个参数接受需要检査的特性的 Type 对象；<br>&emsp;&emsp;- 第二个参数是 bool 类型的，它指示是否搜索 MyClass 的继承树来查找这个特性。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ReviewCommentAttribute</span> : <span class="title">System.Attribute</span></span><br><span class="line">&#123;... &#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ReviewComment(<span class="string">&quot;Check it out&quot;</span>, <span class="string">&quot;2.4&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass(); <span class="comment">//创建类实例</span></span><br><span class="line">        Type t = mc.GetType(); <span class="comment">//从实例中获取类型对象</span></span><br><span class="line">        <span class="built_in">bool</span> isDefined = <span class="comment">//创建特性的类型</span></span><br><span class="line">            t.IsDefined(<span class="keyword">typeof</span>(ReviewCommentAttribute), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( isDefined )</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;ReviewComment is applied to type <span class="subst">&#123; t.Name &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">ReviewComment is applied to type MyClass</span><br></pre></td></tr></table></figure><h3 id="使用-GetCustomAttributes-方法"><a href="#使用-GetCustomAttributes-方法" class="headerlink" title="使用 GetCustomAttributes 方法"></a>使用 GetCustomAttributes 方法</h3><p>Type 类的 GetCustomAttributes 方法返回应用到结构上的特性的数组：<br>①实际返冋的对象是 object 的数组，因此我们必须将它强制转换为相应的特性类型；<br>②布尔参数指定是否搜索继承树来査找特性：<code>object[] AttArr = t.GetCustomAttributes(false);</code><br>③调用 GetCustomAttributes 方法后，每一个与目标相关联的特性的实例就会被创建。</p><p>下面的代码使用了前面的示例中相同的特性和类声明。但是，本例中，它不检测特性是否应用到了类上，而是获取应用到类的特性的数组，然后遍历它们，输出它们的成员的值。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">[<span class="meta">AttributeUsage( AttributeTargets.Class )</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MyAttributeAttribute</span> : <span class="title">System.Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> VersionNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ReviewerID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAttributeAttribute</span>(<span class="params"> <span class="built_in">string</span> desc, <span class="built_in">string</span> ver </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Description = desc;</span><br><span class="line">        VersionNumber = ver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MyAttribute( <span class="string">&quot;Check it out&quot;</span>, <span class="string">&quot;2.4&quot;</span> )</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type t = <span class="keyword">typeof</span>( MyClass );</span><br><span class="line">        <span class="built_in">object</span>[] AttArr = t.GetCustomAttributes( <span class="literal">false</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ( Attribute a <span class="keyword">in</span> AttArr )</span><br><span class="line">        &#123;</span><br><span class="line">            MyAttributeAttribute attr = a <span class="keyword">as</span> MyAttributeAttribute;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="literal">null</span> != attr )</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Description : <span class="subst">&#123; attr.Description &#125;</span>&quot;</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Version Number : <span class="subst">&#123; attr.VersionNumber &#125;</span>&quot;</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Reviewer ID : <span class="subst">&#123; attr.ReviewerID &#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Description : Check it out</span><br><span class="line">Version Number : 2.4</span><br><span class="line">Reviewer ID :</span><br></pre></td></tr></table></figure><h1 id="第二十六章-C-6-0-和-C-7-0-新增的内容"><a href="#第二十六章-C-6-0-和-C-7-0-新增的内容" class="headerlink" title="第二十六章 C# 6.0 和 C# 7.0 新增的内容"></a>第二十六章 C# 6.0 和 C# 7.0 新增的内容</h1><h2 id="字符串插值-C-6-0"><a href="#字符串插值-C-6-0" class="headerlink" title="字符串插值 C#6.0"></a>字符串插值 C#6.0</h2><p>字符串插值主要在第三章。</p><p>C#6.0使用了字符串插值简化了格式字符串。字符串插值不仅可以用在 Console.WriteLine 中，还可以使用在 String.Format，如下代码所示：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;Aiden&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> technology = <span class="string">&quot;Cold Fusion&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">s = String.Format(<span class="string">&quot;&#123;0&#125; is working on &#123;1&#125;.&quot;</span>, name, technology); <span class="comment">//格式字符串</span></span><br><span class="line">Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line">s = String.Format(<span class="string">$&quot;<span class="subst">&#123; name &#125;</span> is working on <span class="subst">&#123; technology &#125;</span>.&quot;</span>); <span class="comment">//字符串插值</span></span><br><span class="line">Console.WriteLine(s);</span><br></pre></td></tr></table></figure><h2 id="自动属性初始化语句"><a href="#自动属性初始化语句" class="headerlink" title="自动属性初始化语句"></a>自动属性初始化语句</h2><p>详见第七章，自动属性是属性声明的一种简写形式，由编译器生成或管理一个不可见的、关联到这个属性的后备字段。之前，自动属性只能在构造函数或者方法中初始化，现在也可以像普通的属性一样在声明的时候初始化：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">double</span> Length &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">42.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以对以 internal、protected、internal protected 或者 private 修饰的 setter 使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">double</span> Length &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; = <span class="number">42.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以适用于只读自动属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">double</span> Length &#123; <span class="keyword">get</span>; &#125; = <span class="number">42.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用任何可以被解析为字面量的表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> myConstant = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">double</span> Length &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = myConstant + <span class="number">.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是初始化语句不能引用非静态的属性、字段或者方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">double</span> myField = <span class="number">42.5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">double</span> Length &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = myField; <span class="comment">//编译错误</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">double</span> myProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">42.5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">double</span> Length &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = myProperty; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>集合 List 是自动属性初始化的最佳例子：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="built_in">double</span>&gt; Areas &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> List&lt;<span class="built_in">double</span>&gt;();</span><br></pre></td></tr></table></figure><p>结构体中的静态属性也可以使用自动属性初始化语句：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">double</span> Length &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">42.5</span>;</span><br><span class="line">    <span class="built_in">double</span> Length2 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">42.5</span>; <span class="comment">//编译错误，非静态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只读自动属性-C-6-0"><a href="#只读自动属性-C-6-0" class="headerlink" title="只读自动属性 C#6.0"></a>只读自动属性 C#6.0</h2><p>只读自动属性详见第七章。</p><p>之前，想要声明一个只读属性，需要私有化 setter。虽然阻止了类的使用者改变属性值，但是仍然可以在类内部的其他地方改变它：<code>public string CompanyName &#123; get; private set; &#125;</code></p><p>现在可以去掉整个 setter。在这种情况下，属性必须在声明时或者在构造函数中初始化：<code>public string CompanyName &#123; get; &#125;</code></p><p>在类和结构体中都可以使用只读自动属性。</p><h2 id="表达式函数体成员-C-6-0和C-7-0"><a href="#表达式函数体成员-C-6-0和C-7-0" class="headerlink" title="表达式函数体成员 C#6.0和C#7.0"></a>表达式函数体成员 C#6.0和C#7.0</h2><p>之前，所有方法和 get 属性的主体部分都是由包含在大括号内的代码组成的，并且必须有大括号。但是现在，如果函数体是由单个表达式构成的，我们可以使用称为表达式函数体的短格式语法。表达式函数体成员有如下重要特征：<br>①代码必须是由一个表达式组成的，以分号结束；<br>&emsp;&emsp;- 对于有返回值的成员类型，表达式的值就是返回值。对于没有返回值的成员，不返回任何东西。<br>②不能有开始和结束大括号；<br>③在参数列表和构成函数体的表达式之间使用 Lambda 运算符（=&gt;）；<br>④在 C#6.0 中，这个功能可以用在方法和属性的 get 访问器中。C#7.0 将这个功能扩展到了构造函数、终结函数 finalizer、属性 set 访问器和索引器。</p><p>例如，下面的方法声明使用了之前的方法体语法，而没有使用表达式函数体语法。它由包含在大括号内的一个语句组成：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetWineGrowingRegion</span>(<span class="params"><span class="built_in">string</span> countryName, <span class="built_in">string</span> regionName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> countryName + <span class="string">&quot;:&quot;</span> + regionName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用表达式函数体格式，可以使用 Lambda 运算符重写为<code>public string GetWineGrowingRegion(string countryName, string regionName) =&gt; countryName + &quot;:&quot; + regionName;</code></p><p>下面演示一个只读属性的例子：<code>public string MyFavoriteWineGrowingRegion =&gt; &quot;Sonoma County&quot;;</code></p><p>你不能对自动实现了读写操作的属性成员使用表达式函数体。在这种情况下，不能同时使用访问器列表和表达式函数体：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> AreaCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">408</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> CentralOfficeCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">428</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> LineNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">4208</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> PhoneNumber &#123; <span class="keyword">get</span>; &#125; <span class="comment">//访问器列表</span></span><br><span class="line">                    =&gt; <span class="string">$&quot;(<span class="subst">&#123;AreaCode&#125;</span>) <span class="subst">&#123;CentralOfficeCode&#125;</span>-<span class="subst">&#123;LineNumber&#125;</span>&quot;</span>; <span class="comment">//编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> PhoneNumber <span class="comment">//没有访问器列表</span></span><br><span class="line">                    =&gt; <span class="string">$&quot;(<span class="subst">&#123;AreaCode&#125;</span>) <span class="subst">&#123;CentralOfficeCode&#125;</span>-<span class="subst">&#123;LineNumber&#125;</span>&quot;</span>; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h2 id="using-static-C-6-0"><a href="#using-static-C-6-0" class="headerlink" title="using static C#6.0"></a>using static C#6.0</h2><p>using static 主要在第7章和第22章。</p><p>在C#6.0之前，使用类或结构体的静态成员，必须包含类或结构体的名称。之后，可以使用 using static 语句，关键字后面包含静态成员的类或者结构体的全名，这样就可以在使用静态成员时不用在前面加上类型名称。</p><h2 id="空条件运算符-C-6-0"><a href="#空条件运算符-C-6-0" class="headerlink" title="空条件运算符 C#6.0"></a>空条件运算符 C#6.0</h2><p>主要在下一章，第27章，讨论。</p><p>空条件运算符主要是为了阻止试图访问一个空对象的成员时抛出的空引用异常。如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Student[] students = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span> studentCount = students.Length; <span class="comment">//产生异常</span></span><br><span class="line">Student firstStudent = students[<span class="number">0</span>]; <span class="comment">//产生异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用空条件运算符来避免空引用异常</span></span><br><span class="line"><span class="built_in">int</span>? studentCount = students?.Length;</span><br><span class="line">Student firstStudent = students?[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h2 id="在-catch-和-finally-块中使用-await-C-6-0"><a href="#在-catch-和-finally-块中使用-await-C-6-0" class="headerlink" title="在 catch 和 finally 块中使用 await C#6.0"></a>在 catch 和 finally 块中使用 await C#6.0</h2><p>在 C#5.0 引入 async/await 时，不能把 await 子句放在 catch 或 finally 块中。现在这个限制被解除了。</p><h2 id="nameof-运算符-C-6-0"><a href="#nameof-运算符-C-6-0" class="headerlink" title="nameof 运算符 C#6.0"></a>nameof 运算符 C#6.0</h2><p>nameof 运算符主要在第9章讨论。</p><p>nameof 是一个新的运算符，它接受一个参数，可以是变量名、类型名或者成员名。运算符返回代表参数名称的字符串。</p><h2 id="异常过滤器-C-6-0"><a href="#异常过滤器-C-6-0" class="headerlink" title="异常过滤器 C#6.0"></a>异常过滤器 C#6.0</h2><p>异常过滤器主要在第23章讨论。</p><h2 id="索引初始化语句"><a href="#索引初始化语句" class="headerlink" title="索引初始化语句"></a>索引初始化语句</h2><p>本节是唯一讨论索引初始化语句的地方。</p><p>C#6.0 引入了新的语法来初始化带索引器的数据结构，比如字典 Dictionary 对象。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统语法，集合初始化</span></span><br><span class="line"><span class="keyword">var</span> favoriteCities = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="string">&quot;Oxford&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="string">&quot;Paris&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="string">&quot;Barcelona&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上段代码和下面等效，使用Add方法：</span></span><br><span class="line"><span class="keyword">var</span> favoriteCities = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line">favoriteCities.Add(<span class="number">0</span>, <span class="string">&quot;Oxford&quot;</span>);</span><br><span class="line">favoriteCities.Add(<span class="number">1</span>, <span class="string">&quot;Paris&quot;</span>);</span><br><span class="line">favoriteCities.Add(<span class="number">2</span>, <span class="string">&quot;Barcelona&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为字典对象有索引器，可以使用新的索引初始化语法：</span></span><br><span class="line"><span class="keyword">var</span> favoriteCities = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">0</span>] = <span class="string">&quot;Oxford&quot;</span>,</span><br><span class="line">    [<span class="meta">1</span>] = <span class="string">&quot;Paris&quot;</span>,</span><br><span class="line">    [<span class="meta">2</span>] = <span class="string">&quot;Barcelona&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种形式与下面等价：</span></span><br><span class="line"><span class="keyword">var</span> favoriteCities = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line">favoriteCities[<span class="number">0</span>] = <span class="string">&quot;Oxford&quot;</span>;</span><br><span class="line">favoriteCities[<span class="number">1</span>] = <span class="string">&quot;Paris&quot;</span>;</span><br><span class="line">favoriteCities[<span class="number">2</span>] = <span class="string">&quot;Barcelona&quot;</span>;</span><br></pre></td></tr></table></figure><p>集合初始化隐式地调用集合的 Add 方法，但索引初始化没有调用 Add 方法，而是给索引指定的元素赋值。这两种不同的差别如下：首先，集合初始化需要一个实现了 IEnumerable 接口的集合，还需要一个公有的 Add 方法。索引初始化则两个都不需要，它仅仅需要类或者结构体包含索引器，不需要实现 IEnumerable 接口或者可以没有 Add 方法。</p><p>Dictionary 既能使用集合初始化又能使用索引初始化，不能在一个语句中同时使用这两种语法。</p><h2 id="集合初始化语句的扩展方法-C-6-0"><a href="#集合初始化语句的扩展方法-C-6-0" class="headerlink" title="集合初始化语句的扩展方法 C#6.0"></a>集合初始化语句的扩展方法 C#6.0</h2><p>本节是唯一讨论集合初始化扩展方法的地方。扩展方法详见第8章。</p><p>使用集合初始化创建集合：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> customer1 = <span class="keyword">new</span> Customer(Name = <span class="string">&quot;Willem&quot;</span>, Age = <span class="number">35</span>);</span><br><span class="line"><span class="keyword">var</span> customer2 = <span class="keyword">new</span> Customer(Name = <span class="string">&quot;Sandra&quot;</span>, Age = <span class="number">32</span>);</span><br><span class="line"><span class="comment">//集合初始化</span></span><br><span class="line"><span class="keyword">var</span> customers = <span class="keyword">new</span> List&lt;Customer&gt;() &#123; customer1, customer2 &#125;;</span><br></pre></td></tr></table></figure><p>集合初始化能够工作，是因为编译器在调用构造函数之后，又加入了调用 Add 方法的代码。其他 .NET 集合也都有 Add 函数，可以使用集合初始化。</p><p>假设定义一个自己的集合，在集合内部使用名称不同于 Add 的调用 Add 方法的方法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriptions</span> : <span class="title">IEnumerable</span>&lt;<span class="title">Customer</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Customer&gt; _subscribers = <span class="keyword">new</span> List&lt;Customer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">Customer c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _subscribers.Add(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码因为 Subscription 类没有 Add 方法，所以下面的代码会失败：<code>var customers = new Subscription() &#123; customer1, customer2 &#125;;</code></p><p>但是从 C# 6.0 开始，可以通过实现一个名为 Add 的扩展方法来调用 Subscription 类中的 Subscribe 方法，来实现集合初始化语句。但是注意，集合仍然需要支持 IEnumerable 接口：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SubscriptionExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"> <span class="keyword">this</span> Subscriptions s, Customer c </span>) <span class="comment">// Extension method</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        s.Subscribe( c );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123; <span class="keyword">public</span> <span class="built_in">string</span> Name&#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="function"><span class="keyword">public</span> <span class="title">Customer</span>(<span class="params"> <span class="built_in">string</span> name </span>)</span> &#123; Name = name; &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriptions</span> : <span class="title">IEnumerable</span>&lt;<span class="title">Customer</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Customer&gt; mSubscribers = <span class="keyword">new</span> List&lt;Customer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;Customer&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> mSubscribers.GetEnumerator(); &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123; <span class="keyword">throw</span> <span class="keyword">new</span> System.NotImplementedException(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params"> Customer c </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mSubscribers.Add( c );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> customer1 = <span class="keyword">new</span> Customer( <span class="string">&quot;Willem&quot;</span> );</span><br><span class="line">        <span class="keyword">var</span> customer2 = <span class="keyword">new</span> Customer( <span class="string">&quot;Sandra&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//集合初始化</span></span><br><span class="line">        <span class="keyword">var</span> customers = <span class="keyword">new</span> Subscriptions() &#123; customer1, customer2 &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ( Customer c <span class="keyword">in</span> customers )</span><br><span class="line">            WriteLine( <span class="string">$&quot;Name: <span class="subst">&#123;c.Name&#125;</span>&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="值元组"><a href="#值元组" class="headerlink" title="值元组"></a>值元组</h2><p><strong>值元组 ValueTuple</strong> 主要在下一章介绍。</p><p><strong>元组 tuple</strong> 是一个有序的元素集合，其中元素可以是相同或不同的数据类型。元组仅仅是通过使用圆括号包裹和逗号分隔的方式提供了引用和操作一组元素的方便方法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">string</span>, <span class="built_in">int</span>) CreateSampleTuple()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;Paul&quot;</span>, <span class="number">39</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myTuple = CreateSampleTuple();</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123; myTuple.Item1 &#125;</span> Age: <span class="subst">&#123;myTuple.Item2&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p>元组易于创造但是调用相对麻烦，因为元组的元素只能靠没有描述性的名称 Item1、Item2 等调用。另外，因为元组是类、引用类型，需要在堆上创建，并不在引用时候被垃圾机制回收。</p><p>C# 7.0 引入了 ValueTuple 的结构体，可以获得比元组更好的性能。此外，可以给属于 ValueTuple 的元素命名。</p><h2 id="is-模式匹配-C-7-0"><a href="#is-模式匹配-C-7-0" class="headerlink" title="is 模式匹配 C#7.0"></a>is 模式匹配 C#7.0</h2><p><strong>is 运算符</strong>用来检测一个对象是不是某些类型。C#支持继承和接口实现，虽然不支持多继承，但是类可以实现任意多个接口。在这种复杂性下，is 运算符不仅能检测当前类的类型，还能检测任意层次的基类，以及是否支持任意指定的接口。示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IOne</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> SampleIntProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ITwo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> SampleIntProperty2 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> SampleStringProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span>, <span class="title">IOne</span>, <span class="title">ITwo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> SampleIntProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> SampleIntProperty2 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> dc = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">        <span class="keyword">if</span> (dc <span class="keyword">is</span> DerivedClass)</span><br><span class="line">        &#123; Console.WriteLine(<span class="string">&quot;Derived Class found&quot;</span>); &#125;</span><br><span class="line">        <span class="keyword">if</span> (dc <span class="keyword">is</span> BaseClass)</span><br><span class="line">        &#123; Console.WriteLine(<span class="string">&quot;Base Class found&quot;</span>); &#125;</span><br><span class="line">        <span class="keyword">if</span> (dc <span class="keyword">is</span> IOne)</span><br><span class="line">        &#123; Console.WriteLine(<span class="string">&quot;Interface One found&quot;</span>); &#125;</span><br><span class="line">        <span class="keyword">if</span> (dc <span class="keyword">is</span> ITwo)</span><br><span class="line">        &#123; Console.WriteLine(<span class="string">&quot;Interface Two found&quot;</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Derived Class found</span><br><span class="line">Base Class found</span><br><span class="line">Interface One found</span><br><span class="line">Interface Two found</span><br></pre></td></tr></table></figure><p>若检测了一个给定对象是不是某种类型后，如果想要引用这种类型，就必须先转换成这种类型：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(myEmployee <span class="keyword">is</span> Supervisor)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> mySupervisor = (Supervisor)myEmployee;</span><br><span class="line">    <span class="comment">//继续调用父类成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用 as 运算符来实现转换：</span></span><br><span class="line"><span class="keyword">var</span> mySupervisor = myEmployee <span class="keyword">as</span> Supervisor;</span><br><span class="line"><span class="keyword">if</span> (mySupervisor != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//继续调用父类成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C# 7.0中，is 运算符的类型语法已经简化，可以直接给检测类后的变量赋值。增强的 is 运算符不仅检测变量类型，如果变量通过了测试，还可以同时将其赋值给指定的新变量。这个新变量叫作<strong>匹配变量 match variable</strong>。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (myEmployee <span class="keyword">is</span> Supervisor mySupervisor)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果检测通过了，mySupervisor变量立即可以使用</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;My supervisor’s name is <span class="subst">&#123; mySupervisor.Name &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-模式匹配-C-7-0"><a href="#switch-模式匹配-C-7-0" class="headerlink" title="switch 模式匹配 C#7.0"></a>switch 模式匹配 C#7.0</h2><p>C#7.0 对 switch 语句做了很多重要的改进。switch 语句之前受限于编译时常量，包括 char、string、bool、integer等。现在可以使用任何类型进行检测，包括用户自定义的类型：class、struct、array、enum、delegate和interface。示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Investment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> MinPurchaseAmt &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Stock</span> : <span class="title">Investment</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bond</span> : <span class="title">Investment</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BankAccount</span> : <span class="title">Investment</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RealEstate</span> : <span class="title">Investment</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> myStock = <span class="keyword">new</span> Stock() &#123; Name = <span class="string">&quot;Tesla&quot;</span>, MinPurchaseAmt = <span class="number">1000</span> &#125;;</span><br><span class="line">        <span class="keyword">var</span> myBond = <span class="keyword">new</span> Bond() &#123; Name = <span class="string">&quot;California Municipal&quot;</span>, MinPurchaseAmt = <span class="number">500</span> &#125;;</span><br><span class="line">        <span class="keyword">var</span> myBankAccount = <span class="keyword">new</span> BankAccount() &#123; Name = <span class="string">&quot;ABC Bank&quot;</span>, MinPurchaseAmt = <span class="number">10</span> &#125;;</span><br><span class="line">        <span class="keyword">var</span> myBankAccount2 = <span class="keyword">new</span> BankAccount() &#123; Name = <span class="string">&quot;XYZ Bank&quot;</span>, MinPurchaseAmt = <span class="number">20</span> &#125;;</span><br><span class="line">        <span class="keyword">var</span> myRealEstate =</span><br><span class="line">                <span class="keyword">new</span> RealEstate() &#123; Name = <span class="string">&quot;My Vacation Home&quot;</span>, MinPurchaseAmt = <span class="number">100</span>_000 &#125;;</span><br><span class="line"></span><br><span class="line">        CheckInvestmentType(myStock);</span><br><span class="line">        CheckInvestmentType(myBond);</span><br><span class="line">        CheckInvestmentType(myBankAccount);</span><br><span class="line">        CheckInvestmentType(myBankAccount2);</span><br><span class="line">        myBankAccount2 = <span class="literal">null</span>;</span><br><span class="line">        CheckInvestmentType(myBankAccount2);</span><br><span class="line">        CheckInvestmentType(myRealEstate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckInvestmentType</span> (<span class="params">Investment investment</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (investment)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> Stock stock:</span><br><span class="line">            WriteLine(<span class="string">$&quot;This investment is a stock named <span class="subst">&#123;stock.Name&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Bond bond:</span><br><span class="line">            WriteLine(<span class="string">$&quot;This investment is a bond named <span class="subst">&#123;bond.Name&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BankAccount bankAccount <span class="keyword">when</span> bankAccount.Name.Contains(<span class="string">&quot;ABC&quot;</span>) :</span><br><span class="line">            WriteLine(<span class="string">$&quot;This investment is my ABC Bank account&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BankAccount bankAccount:</span><br><span class="line">            WriteLine(<span class="string">$&quot;This investment is any bank account other than ABC Bank&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">null</span>:</span><br><span class="line">            WriteLine(<span class="string">&quot;For whatever reason, this investment is null. &quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">            WriteLine(<span class="string">&quot;The default case will always be evaluated last. &quot;</span>);</span><br><span class="line">            WriteLine(<span class="string">&quot;Even if its position is not last.&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">This investment is a stock named Tesla</span><br><span class="line">This investment is a bond named California Municipal</span><br><span class="line">This investment is my ABC Bank account</span><br><span class="line">This investment is any bank account other than ABC Bank</span><br><span class="line">For whatever reason, this investment is null.</span><br><span class="line">The default case will always be evaluated last.</span><br><span class="line">Even if its position is not last.</span><br></pre></td></tr></table></figure><p>所有类型模式都有一个隐含的 when 子句条件，即当类型不为 null 时。这可以防止 switch 语句中的第一个类型匹配空值，从而触发其 switch 块中的语句，产生意外结果。可以添加特殊的 case 语句来处理 null 的情况，也可以在默认块中处理。</p><p>与之前不同，case 语句的顺序现在很重要。现在必须将列表中所有特殊的情况放在普通情况之前，之前因为是常量，值总是互斥的，所以不重要。</p><h2 id="表达式函数体成员的扩展-C-7-0"><a href="#表达式函数体成员的扩展-C-7-0" class="headerlink" title="表达式函数体成员的扩展 C#7.0"></a>表达式函数体成员的扩展 C#7.0</h2><p>表达式函数体成员是指一种使用 Lambda 符号（=&gt;）引入单行语句，而不是将其放在一组大括号中的语法。C#7.0使其允许在构造函数、析构函数以及属性和索引器的 get 和 set 访问器使用表达式函数体成员。示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyClass</span> (<span class="params"><span class="built_in">string</span> var1</span>)</span> =&gt; <span class="keyword">this</span>.Var1 = var1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~MyClass() =&gt; Console.WriteLine( <span class="string">&quot;Unmanaged resources have been released &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Area</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> =&gt; mArea;</span><br><span class="line">    <span class="keyword">set</span> =&gt; mArea = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throw-表达式-C-7-0"><a href="#throw-表达式-C-7-0" class="headerlink" title="throw 表达式 C#7.0"></a>throw 表达式 C#7.0</h2><p>在C#7.0之前，throw 关键字只能在语句中使用，现在可以在一些需要表达式的场景下使用，包括条件表达式、空接合表达式和一些 Lambda 表达式。</p><p>throw 表达式最常用的例子是空接合运算符，空接合运算符详见下一章节，它有两个操作数，第一个操作数是可空的，当它解析为空时，就使用第二个非空的表达式：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span>? success = LoadResource(); <span class="comment">//可空类型</span></span><br><span class="line"><span class="keyword">var</span> resourceLoadResult =</span><br><span class="line">        success ?? <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;Resource load failed&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="第二十七章-其他主题"><a href="#第二十七章-其他主题" class="headerlink" title="第二十七章 其他主题"></a>第二十七章 其他主题</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>BCL 提供了很多能让字符串操作变得更简单的类。C# 预定义的 string 类型代表了 .NET 的 System.String 类。关于字符串的重要事项如下：<br>①字符串是 Unicode 字符数组；<br>②字符串是<strong>不可变的 immutable</strong>，它们不能被修改。</p><p>string 类型有很多有用的字符串操作成员，下表列出了其中一些最有用的成员：</p><div class="table-container"><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">类型</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">Length</td><td style="text-align:left">属性</td><td style="text-align:left">返回字符串长度</td></tr><tr><td style="text-align:left">Concat</td><td style="text-align:left">静态方法</td><td style="text-align:left">返回连接参数字符串后的字符串</td></tr><tr><td style="text-align:left">Contains</td><td style="text-align:left">方法</td><td style="text-align:left">返回指示参数是否是对象字符串的子字符串的bool值</td></tr><tr><td style="text-align:left">Format</td><td style="text-align:left">静态方法</td><td style="text-align:left">返回格式化后的字符串</td></tr><tr><td style="text-align:left">Insert</td><td style="text-align:left">方法</td><td style="text-align:left">接受一个字符串和一个位置作为参数，创建并返回一个在指定位置插入了参数字符串的新的字符串对象副本</td></tr><tr><td style="text-align:left">Remove</td><td style="text-align:left">方法</td><td style="text-align:left">返回对象字符串的副本，其中移除了一个子字符串</td></tr><tr><td style="text-align:left">Replace</td><td style="text-align:left">方法</td><td style="text-align:left">返回对象字符串的副本，其中替换了一个子字符串</td></tr><tr><td style="text-align:left">Spilt</td><td style="text-align:left">方法</td><td style="text-align:left">返回一个包含原始字符串的子字符串的字符串数组。对于每个输入参数，为方法提供一组分隔符来分隔目标子字符串</td></tr><tr><td style="text-align:left">Substring</td><td style="text-align:left">方法</td><td style="text-align:left">获取对象字符串的子字符串</td></tr><tr><td style="text-align:left">ToLower</td><td style="text-align:left">方法</td><td style="text-align:left">返回对象字符串的副本，其中所有字母字符都为小写</td></tr><tr><td style="text-align:left">ToUpper</td><td style="text-align:left">方法</td><td style="text-align:left">返回对象字符串的副本，其中所有字母字符都为大写</td></tr></tbody></table></div><p>从上表中的大多数方法的名字来看，好像它们都会改变字符串对象。其实，它们不会改变字符串而是返回了新的副本。对于一个 string ，任何“改变”都会分配一个新的不可变字符串。</p><h2 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h2><p><strong>StringBuilder 类</strong>可以帮助你动态、有效地产生字符串，并且避免创建许多副本：<br>①StringBuilder 类是 BCL 的成员，位于 System.Text 命名空间中；<br>②StringBuilder 对象是 Unicode 字符的可变数组。</p><p>例如，下面的代码声明并初始化了一个 StringBuilder 类型的字符串，然后输出了它的值。第四行代码通过替换初始字符串的一部分改变了实际对象：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder( <span class="string">&quot;Hi there.&quot;</span> );</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; sb.ToString() &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        sb.Replace( <span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Hello&quot;</span> ); </span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; sb.ToString() &#125;</span>&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Hi there.</span><br><span class="line">Hello there.</span><br></pre></td></tr></table></figure><p>当依据给定的字符串创建了 StringBuilder 对象之后，类分配了一个比当前字符串长度更长的缓冲区。只要缓冲区能容纳对字符串的改变就不会分配新的内存。如果对字符串的改变需要的空间比缓冲区中的可用空间多，就会分配更大的缓冲区，并把字符串复制到其中。和原来的缓冲区一样，新的缓冲区也有额外的空间。</p><p>要获取 StringBuilder 对应的字符串内容，只需要调用它的 ToString 方法即可。</p><h2 id="把字符串解析为数据值"><a href="#把字符串解析为数据值" class="headerlink" title="把字符串解析为数据值"></a>把字符串解析为数据值</h2><p>①<strong>解析 Parse</strong> 允许我们接受表示值的字符串，并且把它转换为实际的类型值；<br>②所有预定义的简单类型都有一个叫做 Parse 的静态方法，它接受一个表示值的字符串，并且把它转换为类型的实际值；<br>③如果字符串无法解析，系统会抛出异常。</p><p>以下语句给出了一个使用 Parse 方法语法的示例。注意，Parse 是静态的，所以需要通过目标类型名来调用它：<code>double d1 = double.Parse(&quot;25.873&quot;);</code></p><p>Parse 方法的缺点是如果不能把 string 成功转换为目标类型就抛出一个异常。<strong>TryParse 方法</strong>可以避免这个问题。有关 TryParse 需要知道的亟要事项如下：<br>①每一个具有 Parse 方法的内置类型同样都有一个 TryParse 方法；<br>②TryParse 方法接受两个参数并且返回一个 bool 值：<br>&emsp;&emsp;- 第一个参数是你希望转换的字符串；<br>&emsp;&emsp;- 第二个是指向目标类型变量的引用的 out 参数；<br>&emsp;&emsp;- 如果 TryParse 成功，解析值被赋给 out 参数，它返回 true，否则返回 false。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> parseResultSummary;</span><br><span class="line">        <span class="built_in">string</span> stringFirst = <span class="string">&quot;28&quot;</span>;</span><br><span class="line">        <span class="built_in">int</span> intFirst;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> success = <span class="built_in">int</span>.TryParse( stringFirst, <span class="keyword">out</span> intFirst );</span><br><span class="line"></span><br><span class="line">        parseResultSummary = success</span><br><span class="line">                                ? <span class="string">&quot;was successfully parsed&quot;</span></span><br><span class="line">                                : <span class="string">&quot;was not successfully parsed&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;String <span class="subst">&#123; stringFirst &#125;</span> <span class="subst">&#123; parseResultSummary &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> stringSecond = <span class="string">&quot;vt750&quot;</span>;</span><br><span class="line">        <span class="built_in">int</span> intSecond;</span><br><span class="line"></span><br><span class="line">        success = <span class="built_in">int</span>.TryParse( stringSecond, <span class="keyword">out</span> intSecond );</span><br><span class="line"></span><br><span class="line">        parseResultSummary = success</span><br><span class="line">                                ? <span class="string">&quot;was successfully parsed&quot;</span></span><br><span class="line">                                : <span class="string">&quot;was not successfully parsed&quot;</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;String <span class="subst">&#123; stringSecond &#125;</span> <span class="subst">&#123; parseResultSummary &#125;</span>&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">String 28 was successfully parsed</span><br><span class="line">String vt750 was not successfully parsed</span><br></pre></td></tr></table></figure><h2 id="关于可空类型的更多内容"><a href="#关于可空类型的更多内容" class="headerlink" title="关于可空类型的更多内容"></a>关于可空类型的更多内容</h2><p><strong>可空类型 nullable type</strong> 允许我们创建一个值类型变量并且可以标记为有效或无效，这样我们就可以有效地把值类型设置为 null 。可空类型总是基于另外一个已经被声明的类型。<br>①可以从任何值类型创建可空类型，包括预定义的简单类型；<br>②不能从引用类型或其他可空类型创建可空类型；<br>③不能在代码中显式声明可空类型，只能声明可空类型的变量。之后我们会看到，编译器会隐式地创建可空类型。</p><p>要创建可空类型的变量，只需要在变量声明中的基础类型的名字后面加一个问号：<code>int? myInt=28;</code></p><p>可空类型包含以下重要的只读属性：<br>①HasValue 属性是 bool 类型，并且指示值是否有效；<br>②Value 属性是和基础类型相同的类型并且返回变量的值，如果变量有效的话。</p><p>使用可空类型基本与使用其他类型的变量一样。读取可空类型的变量会返回其值。但是必须确保变量不是 null ，尝试读取一个 null 的变量会产生异常。<br>①跟任何变量一样，要获取可空类型变量的值，使用名字即可；<br>②要检测可空类型是否具有值，可以将它和 null 比较或者检查它的 HasValue 属性。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? myInt1 = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( myInt1 != <span class="literal">null</span> )</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, myInt1);</span><br></pre></td></tr></table></figure><p>可空类型和相应的非可空类型之间可轻松实现转换。有关可空类型转换的重要事项如下：<br>①非可空类型和相应的可空版本之间的转换是隐式的，也就是说，不需要强制转换；<br>②可空类型和相应的非可空版本之间的转换是显式的。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? myInt1 = <span class="number">15</span>; <span class="comment">//隐式转换</span></span><br><span class="line"><span class="built_in">int</span> regInt = (<span class="built_in">int</span>) myInt1; <span class="comment">//显式转换</span></span><br></pre></td></tr></table></figure><h3 id="空接合运算符"><a href="#空接合运算符" class="headerlink" title="空接合运算符"></a>空接合运算符</h3><p>标准算术运算符和比较运算符同样也能处理可空类型。还有一个特别的运算符叫做<strong>空接合运算符 null coalescing operator</strong> ，它允许我们在可空类型变量为 null 时返回一个值给表达式。</p><p>空接合运算符由两个连续的问号组成，它有两个操作数：<br>①第一个操作数是可空类型的变量；<br>②第二个是相同基础类型的不可空值；<br>③在运行时，如果第一个操作数运算后为 null ，那么第二个操作数就会被返回作为运算结果。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? myI4 = <span class="literal">null</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;myI4: &#123;0&#125;&quot;</span>, myI4 ?? <span class="number">-1</span>);</span><br><span class="line">myI4 = <span class="number">10</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;myI4: &#123;0&#125;&quot;</span>, myI4 ?? <span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">myI4: -1</span><br><span class="line">myI4: 10</span><br></pre></td></tr></table></figure><h3 id="空条件运算符"><a href="#空条件运算符" class="headerlink" title="空条件运算符"></a>空条件运算符</h3><p>如果有一个引用变量，它的值为空，并且尝试通过该空引用访问它的成员，那么程序会抛出 NullReferenceException 。避免这个问题可以使用<strong>空条件运算符 null conditional operator</strong>，空条件运算符为<code>?.</code>组成，它检查引用变量为空还是包含一个对象引用。如果为空，那么运算符返回空；如果不为空，那么访问成员。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Student[] students = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span>? studentCount = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( students != <span class="literal">null</span> )</span><br><span class="line">    studentCount = students.Length;</span><br><span class="line">Console.WriteLine( <span class="string">$&quot;studentCount: <span class="subst">&#123; studentCount &#125;</span>&quot;</span> );</span><br><span class="line"></span><br><span class="line">studentCount = students?.Length; <span class="comment">//使用空条件运算符</span></span><br><span class="line">Console.WriteLine( <span class="string">$&quot;studentCount: <span class="subst">&#123; studentCount &#125;</span>&quot;</span> );</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">studentCount: 5</span><br><span class="line">studentCount:</span><br></pre></td></tr></table></figure><p>空条件运算符的第二种形式用于数组或索引。在这种情况下，需要省略句点字符，并在问号后面紧跟索引指示器的左括号。下面一行代码演示了这种形式：<code>Student student = students?[7];</code>。该代码，若数组 students 不为空，则返回数组的第八个元素。如果数组 students 不为空，但是没有元素，则抛出 ArgumentOutOfRangeException。</p><p>由于空条件运算符的目的是检查是否为空，因此它只能应用于可以有空引用的对象。下面的代码将不会被编译。相反，将收到警告消息：运算符?不能用于 int 类型的操作数。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> length = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">int</span> strLength = length?.ToString()</span><br></pre></td></tr></table></figure><p>空条件运算符可以进行链式调用，意味着只要任何空条件运算检测到空值，该过程就会短路并且不会计算下游调用，同时表达式返回 null。例如：<code>var supervisorPhoneNumber = Employees?[0].Supervisors?[0].PhoneNumbers?[0].ToString();</code></p><p>当空条件运算符作用于返回值类型的成员时，它总是返回该类型的可空版本：<code>var studentCount = students?.Count;</code>：这个例子 studentCount 是 int? 类型。<code>int studentCount = students?.Count;</code>：因为 int? 不能隐式转换为 int ，该代码不会被编译。</p><p>如第14章所述，空条件运算符最常用的用法之一就是用于委托调用，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(handler != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    handler(<span class="keyword">this</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述三行代码可以修改为下面一行代码：</span></span><br><span class="line">handler?.Invoke(<span class="keyword">this</span>, args);</span><br></pre></td></tr></table></figure><p>将空条件运算符与空接合运算符结合使用也很有用：<code>int studentCount = Students?.Count ?? 0;</code></p><h3 id="使用可空用户自定义类型"><a href="#使用可空用户自定义类型" class="headerlink" title="使用可空用户自定义类型"></a>使用可空用户自定义类型</h3><p>至此，我们已经看到了预定义的简单类型的可空形式。我们还可以创建用户自定义值类型的可空形式。这就引出了在使用简单类型时没有遇到的其他问题。</p><p>主要问题是访问封装的基础类型的成员。一个可空类型不直接暴露基础类型的任何成员。例如，来看看下面的代码和下图中它的表示形式。代码声明了一个叫做 MyStruct 的结构（值类型），它有两个公共字段。<br>①由于结构的字段是公有的，所以它可以被结构的任何实例所访问到，如下图左部分所示；<br>②然而，结构的可空形式只通过 <strong>Value 属性</strong>暴露基础类型，它不直接暴露它的任何成员。尽管这些成员对结构来说是公有的，但是它们对可空类型来说不是公有的，如下图右部分所示。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> MyStruct <span class="comment">//声明结构</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X; <span class="comment">//字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y; <span class="comment">//字段</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStruct</span>(<span class="params"><span class="built_in">int</span> xVal, <span class="built_in">int</span> yVal</span>) <span class="comment">//构造函数</span></span></span><br><span class="line">    &#123; X = xVal; Y = yVal; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyStruct? mSNull = <span class="keyword">new</span> MyStruct(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/07/29/8cO7ExBpiYJVFQ9.png" width = "70%" height = "70%" alt="图124 - 结构成员的可访问性不同于可空类型"/></div><p>例如，以下代码使用之前声明的结构并创建了结构和它对应的可空类型的变量。在代码的第三行和第四行中，我们直接读取结构变量的值。在第五行和第六行中，就必须从可空类型的 Value 属性返回的值中进行读取：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyStruct mSStruct = <span class="keyword">new</span> MyStruct(<span class="number">6</span>, <span class="number">11</span>); <span class="comment">//结构变量</span></span><br><span class="line">MyStruct? mSNull = <span class="keyword">new</span> MyStruct(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">//可空类型的变量</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;mSStruct.X: &#123;0&#125;&quot;</span>, mSStruct.X); <span class="comment">//结构访问</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;mSStruct.Y: &#123;0&#125;&quot;</span>, mSStruct.Y);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;mSNull.X: &#123;0&#125;&quot;</span>, mSNull.Value.X); <span class="comment">//可空类型访问</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;mSNull.Y: &#123;0&#125;&quot;</span>, mSNull.Value.Y);</span><br></pre></td></tr></table></figure><p>可空类型通过一个叫作 <code>System.Nullable&lt;T&gt;</code> 的 .NET 类型来实现，它使用了 C# 的泛型特性。C# 可空类型的问号语法是创建 Nullable&lt;T&gt; 类型变量的快捷语法，其中 T 是基础类型。 Nullable&lt;T&gt; 接受了基础类型并把它嵌入结构中，同时给结构提供可空类型的属性、方法和构造函数。</p><p>可以使用 Nullable&lt;T&gt; 这种泛型语法，也可以使用 C# 的快捷语法。以下代码使用Nullable&lt;T&gt; 语法为之前示例中声明的 MyStruct 结构创建一个叫做 mSNull 的Nullable&lt;MyStruct&gt; 类型的变量：<code>Nullable&lt;MyStruct&gt; mSNull = new Nullable&lt;MyStruct&gt;();</code>，下面的代码使用了问号语法，语义上完全等同于 Nullable&lt;T&gt; 语法：<code>MyStruc? mSNull = new MyStruct();</code></p><h2 id="Main-方法"><a href="#Main-方法" class="headerlink" title="Main 方法"></a>Main 方法</h2><p>每一个 C# 程序都必须有一个入口点，一个必须叫做 Main 的方法。</p><p>在贯穿本书的示例代码中，都使用了一个不接受参数并且也不返回值的 Main 方法。然而，一共有4种形式的 Main 可以作为程序的入口点。这些形式如下：<br>①<code>static void Main &#123;…&#125;</code><br>②<code>static void Main(string[] args) &#123;…&#125;</code><br>③<code>static int Main() &#123;…&#125;</code><br>④<code>static int Main(string[] args) &#123;…&#125;</code></p><p>前面两种形式在程序终止后都不返回值给执行环境。后面两种形式则返回 int 值。如果使用返回值，通常用于报告程序的成功或失败，0通常用于表示成功。</p><p>第二种和第四种形式允许我们在程序启动时从命令行向程序传入实参。命令行参数的一些重要特性如下：<br>①可以有0个或多个命令行参数。即使没有参数，args参数也不会是 null ，而是一个没有元素的数组；<br>②参数由空格或制表符隔开；<br>③每一个参数都被程序解释为字符串，但是你无须在命令行中为参数加上引号。</p><p>例如，下面叫做 CommandLineArgs 的程序接受了命令行参数并打印了每一个提供的参数：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> s <span class="keyword">in</span> args)</span><br><span class="line">            Console.WriteLine(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从 Windows 命令提示符中运行这个程序。如下命令行使用5个参数执行 CommandLineArgs 程序：<code>CommandLineArgs Jon Peter Beth Julia Tammi</code></p><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Jon</span><br><span class="line">Peter</span><br><span class="line">Beth</span><br><span class="line">Julia</span><br><span class="line">Tammi</span><br></pre></td></tr></table></figure><p>其他需要了解的有关 Main 的重要事项如下：<br>①Main 必须总是声明为 static ；<br>②Main 可以在类或结构中声明。</p><p>一个程序只可以包含 Main 的4种可用入口点形式中的一种声明。当然，如果你声明其他方法的名称为Main，只要它们不是4种入口点形式中的一种就是合法，但是，这样做是非常容易混淆的。</p><h3 id="Main-的可访问性"><a href="#Main-的可访问性" class="headerlink" title="Main 的可访问性"></a>Main 的可访问性</h3><p>Main 可以被声明为 public 或 private。<br>①如果 Main 被声明为 private ，其他程序集就不能访问它，只有执行环境才能启动程序；<br>②如果 Main 被声明为 public ，其他程序集就可以调用它。</p><p>然而，无论 Main 声明的访问级或所属类或结构的访问级別是什么，操作系统总是能访问 Main 。</p><p>默认情况下，当 Visual Studio 创建了一个项目时，它就创建了一个程序框，其中的 Main 是隐式 private 。如果需要，你随时可以添加 public 修饰符。</p><h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><p>文档注释特性允许我们以 XML 元素的形式在程序中包含文档（第20章介绍过 XML ）。Visual Studio会帮助我们插入元素，以及从源文件中读取它们并复制到独立的 XML 文件中。</p><p>XML 注释的使用，包括如下步骤：<br>①可以使用 Visual Studio 来产生嵌入了 XML 的源文件。Visual Studio 会自动插入大多数重要的 XML 元素；<br>②Visual Studio 从源文件中读取 XML 并且复制 XML 代码到新的文件；<br>③另外一个叫做文档编译器的程序可以获取 XML 文件并且从它产生各种类型的文档文件。</p><p>之前的 Visual Studio 版本包含了基本的文档编译器，但是它在 Visual Studio 2005 发布之前被删除了。微软公司开发了一个叫做 Sandcastle 的新文档编译器，它已经被用来生成 .NET 框架的文档。</p><h3 id="插入文档注释"><a href="#插入文档注释" class="headerlink" title="插入文档注释"></a>插入文档注释</h3><p>文档注释以3个连续的正斜杠开头。</p><p>例如，以下代码中前4行就是有关类声明的文档注释。这里使用&lt;summary&gt; XML 标签。在字段声明之上有3行来说明这个字段，还是使用&lt;summary&gt;标签。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span> 类的开始 XML 标签</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This is class MyClass, which does the following wonderful things, using</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> the following algorithm. ... Besides those, it does these additional</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> amazing things.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span> 关闭 XML 标签</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span> 字段的开始 XML 标签</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Field1 is used to hold the value of ...</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span> 关闭 XML 标签</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Field1 = <span class="number">10</span>; </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>每一个 XML 元素都是当我们在语言特性（比如类或类成员）的声明上输入3条斜杠时，Visual Studio 自动增加的。</p><h3 id="使用其他-XML-标签"><a href="#使用其他-XML-标签" class="headerlink" title="使用其他 XML 标签"></a>使用其他 XML 标签</h3><p>在之前的示例中，我们看到了summay XML 标签的使用。C# 可识别的标签还有很多，如下表列出了最重要的一些：</p><div class="table-container"><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">&lt;code&gt;</td><td style="text-align:left">用看上去像代码的字体格式化内部的行</td></tr><tr><td style="text-align:left">&lt;example&gt;</td><td style="text-align:left">将内部的行标注为一个示例</td></tr><tr><td style="text-align:left">&lt;param&gt;</td><td style="text-align:left">为方法或构造函数标注参数，并允许描述</td></tr><tr><td style="text-align:left">&lt;remarks&gt;</td><td style="text-align:left">描述类型的声明</td></tr><tr><td style="text-align:left">&lt;returns&gt;</td><td style="text-align:left">描述返回值</td></tr><tr><td style="text-align:left">&lt;seealso&gt;</td><td style="text-align:left">在输出文档中创建 See Also 一项</td></tr><tr><td style="text-align:left">&lt;summary&gt;</td><td style="text-align:left">描述类型或类型成员</td></tr><tr><td style="text-align:left">&lt;value&gt;</td><td style="text-align:left">描述属性</td></tr></tbody></table></div><h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>通常直接在命名空间中声明类型。然而，还可以在类或结构中声明类型。<br>①在另一个类型声明中声明的类型叫做嵌套类型。和所有类型声明一样，嵌套类型是类型实例的模板；<br>②嵌套类型像<strong>封闭类型 enclosing type</strong> 的成员一样声明：<br>&emsp;&emsp;- 嵌套类型可以是任意类型；<br>&emsp;&emsp;- 嵌套类型可以是类或结构。</p><h3 id="嵌套类的示例"><a href="#嵌套类的示例" class="headerlink" title="嵌套类的示例"></a>嵌套类的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">MyCounter</span> <span class="comment">//嵌套类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> MyCounter <span class="keyword">operator</span> ++( MyCounter current )</span><br><span class="line">        &#123;</span><br><span class="line">            current.Count++;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyCounter counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>()</span> &#123; counter = <span class="keyword">new</span> MyCounter(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Incr</span>()</span> &#123; <span class="keyword">return</span> ( counter++ ).Count; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetValue</span>()</span> &#123; <span class="keyword">return</span> counter.Count; &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">        mc.Incr(); mc.Incr(); mc.Incr();</span><br><span class="line">        mc.Incr(); mc.Incr(); mc.Incr();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Total: <span class="subst">&#123; mc.GetValue() &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Total: 6</span><br></pre></td></tr></table></figure><h3 id="可见性和嵌套类型"><a href="#可见性和嵌套类型" class="headerlink" title="可见性和嵌套类型"></a>可见性和嵌套类型</h3><p>在第9章中，我们已经了解到类和类型通常有 public 或 internal 的访问级别。然而，嵌套类型的不同之处在于，它们有<em>成员访问级别</em>而不是<em>类型访问级别</em>。因此，下面的命题是成立的：<br>①在类内部声明的嵌套类型可以有5种类成员访问级别中的任何一种：public、protected、private、internal 或 protected internal；<br>②在结构内部声明的嵌套类型可以有3种结构成员访问级別中的任何一种：public、internal或 private。</p><p>在这两种情况下，嵌套类型的默认访问级别都是 private ，也就是说不能被封闭类型以外的对象所见。不管封闭类型的成员声明了怎样的访问级別，包括 private 和 protected ，嵌套类型都能访问这些成员。然而，它们之间的关系不是对称的。尽管封闭类型的成员总是能看见嵌套类型的声明并且能创建它的变量及实例，但是它们不能完全访问嵌套类型的成员。相反，这种访问权限受限于嵌套类成员声明的访问级别，就好像嵌套类型是一个独立的类型一样。也就是说，它们可以访问 public 或 internal 的成员，但是不能访问嵌套类型的 private 或 protected 成员。</p><p>嵌套类型中的 this 引用指的是嵌套类型的对象，而不是封闭类型的对象。如果嵌套类型的对象需要访问封闭类型，它必须持有封闭类型的引用。</p><h2 id="析构函数和-dispose-模式"><a href="#析构函数和-dispose-模式" class="headerlink" title="析构函数和 dispose 模式"></a>析构函数和 dispose 模式</h2><p>第7章介绍了创建类对象的构造函数。类还可以拥有<strong>析构函数 destructor</strong> ，它可以在一个类的实例不再被引用的时候执行一些操作，以清除或释放非托管资源。非托管资源是指用 Win32 API 或非托管内存块获取的文件句柄这样的资源。使用 .NET 资源是无法获取它们的，因此如果我们只用 .NET 类，是不需要编写太多析构函数的。</p><p>关于析构函数要注意以下几点：<br>①每个类只能有一个析构函数；<br>②析构函数不能有参数；<br>③析构函数不能有访问修饰符；<br>④析构函数名称与类名相同，但要在前面加一个波浪符；<br>⑤析构函数只能作用于类的实例。因此没有静态析构函数；<br>⑥<em>不能在代码中显式调用析构函教</em>。相反，当垃圾同收器分析代码并认为代码中不存在指向该对象的可能路径时，系统会在垃圾回收过程中调用析构函数。</p><p>例如，下面的代码通过类 Class1 演示了析构函数的语法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Class1</span><br><span class="line">&#123;</span><br><span class="line">    ~Class1() <span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        CleanupCode</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用析构函数时一些重要的原则如下：<br>①不要在不需要时实现析构函数，这会严重影响性能；<br>②析构函数应该只释放对象拥有的外部资源；<br>③析构函数不应该访问其他对象，因为无法假定这些对象是否已经被销毁。</p><h3 id="标准-dispose-模式"><a href="#标准-dispose-模式" class="headerlink" title="标准 dispose 模式"></a>标准 dispose 模式</h3><p>与 C++ 析构函数不同，C# 析构函数不会在实例超出作用域时立即调用。事实上，你无法知道何时会调用析构函数。此外，如前所述，你也不能显式调用析构函数。你知道的只是系统会在对象从托管堆上移除之前的某个时刻调用析构函数。</p><p>如果你的代码中包含的非托管资源越早释放越好，就不能将这个任务留给析构函数，因为无法保证它会何时执行。相反，你应该采用<strong>标准 dispose 模式</strong>。</p><p>标准 dispose 模式包含以下特点：<br>①包含非托管资源的类应该实现 IDisposable 接口，后者包含单一方法 Dispose 。Dispose 包含释放资源的清除代码；<br>②如果代码使用完了这些资源并且希望将它们释放，应该在程序代码中调用 Dispose 方法；<br>③你的类还应该实现一个析构函数来调用 Dispose 方法，以防止之前没有调用该方法。</p><p>总结一下：你需要将所有清除代码放到 Dispose 方法中，并在使用完资源时调用它。万一 Dispose 没被调用，类的析构函数应该调用 Dispose 。如果调用了 Dispose ，你需要告诉垃圾回收器不要再调用析构函数，因为 Dispose 已经执行了清除操作。</p><p>析构函数和 Dispose 代码应该遵循以下原则：<br>①析构函数和 Dispose 方法的逻辑应该是，如果由于某种原因代码没有调用 Dispose ，那么析构函数应该调用它，并释放资源；<br>②在 Dispose 方法的最后应该调用 GC.SuppressFinalize 方法，通知 CLR 不要调用该对象的析构函数，因为清除工作已经完成；<br>③最好在 Dispose 中实现多次调用该方法也是安全的代码。也就是说代码要这样写：如果该方法已经被调用，那么任何后续调用都不会执行额外的工作，也不会抛出任何异常。</p><p>下面的代码展示了标准的 dispose 模式，代码后面的图对其进行了阐释。这段代码的要点如下：<br>①Dispose 方法有两个重载：一个是 public 的，一个是 protected 的。protected 的重载包含实际的清除代码；<br>②public 版本可以在代码中显式调用以执行清除工作。它会调用 protected 版本；<br>③析构函数调用 protected 版本；<br>④protected 版本的 bool 参数通知方法是它被析构函数或是其他代码调用的。这一点很重要，因为两种情况下执行的操作略有不同。细节如下面的代码所示：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> disposed = <span class="literal">false</span>; <span class="comment">//释放状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>() <span class="comment">//公有 Dispose 方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Dispose( <span class="literal">true</span> );</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MyClass() <span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>) <span class="comment">//分解释放</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (disposed == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (disposing == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//释放托管资源</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">//释放非托管资源</span></span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">        disposed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/07/29/G6qIsWLxXHS4fjn.png" width = "80%" height = "80%" alt="图125 - 标准 dispose 模式"/></div><h2 id="Tuple-和-ValueTuple"><a href="#Tuple-和-ValueTuple" class="headerlink" title="Tuple 和 ValueTuple"></a>Tuple 和 ValueTuple</h2><p><strong>元组 tuple</strong> 数据类型是一种保存有序列表的数据结构，列表中最多有7个元素，元素的数据类型可以不同。元组常用于从方法返回多个值，或者临时存放数据。</p><p>元组是在C#4.0引入的在基类库中预定义的类，C#7.0引入<strong>值元组 ValueTuple</strong> 类型，它们的重要特征如下：<br>①元组数据类型是类。值元组是结构体，可以提升性能；<br>②元组是不可变的。值元组的成员是可变的；<br>③元组的成员是属性，值元组的成员是字段；<br>④可以使用默认的构造函数或者元组类提供的 Create 辅助函数来创建元组实例；<br>⑤元组拥有7个元素，但是只要第8个元素也是元组，就可以创建和访问第8个元素的元组；<br>⑥为了访问元组的元素，可以使用8个属性名称之一：Item1，…，Item8。注意没有 Item0，只能这样访问，不能 foreach 遍历，也不能方括号索引访问。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GlobalTemp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span>&lt;<span class="title">double</span>, <span class="title">double</span>, <span class="title">double</span>, <span class="title">double</span>, <span class="title">double</span>, <span class="title">double</span>&gt;</span></span><br><span class="line"><span class="function">    <span class="title">TempDifferenceConst</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用构造函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple&lt;<span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>&gt;</span><br><span class="line">                        ( <span class="number">0.03</span>, <span class="number">0.00</span>, <span class="number">0.20</span>, <span class="number">0.34</span>, <span class="number">0.52</span>, <span class="number">0.63</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tuple&lt;<span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>&gt;</span></span><br><span class="line"><span class="function">    <span class="title">TempDifferenceCreate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用Create方法更简洁</span></span><br><span class="line">        <span class="keyword">return</span> Tuple.Create( <span class="number">0.03</span>, <span class="number">0.00</span>, <span class="number">0.20</span>, <span class="number">0.34</span>, <span class="number">0.52</span>, <span class="number">0.63</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GlobalTemp gt = <span class="keyword">new</span> GlobalTemp();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> tdTuple = gt.TempDifferenceCreate();</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Temp increase 1950&#x27;s to 2000: &#123;0&#125;C.&quot;</span>, tdTuple.Item5);</span><br><span class="line"></span><br><span class="line">        tdTuple = gt.TempDifferenceConst();</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Temp increase 1950&#x27;s to 2010: &#123;0&#125;C.&quot;</span>, tdTuple.Item6 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Temp increase 1950&#x27;s to 2000: 0.52C.</span><br><span class="line">Temp increase 1950&#x27;s to 2010: 0.63C.</span><br></pre></td></tr></table></figure><p>从C#7.0和.NET Framework 4.7开始，新的 ValueTuple 类解决了元素命名问题。</p><p>下面的代码使用 ValueTuple 代替 Tuple 重新了上面的示例，注意以下几点：<br>①ValueTuple 的创建是隐式的，只需要传递正确数量和正确数据类型的元素即可；<br>②ValueTuple 的返回数据类型是由圆括号括起的、以逗号分隔的元素列表；<br>③方法的返回类型中包括了 ValueTuple 元素的名称。在调用域中可以使用这些名称来引用各个元素。如果未在返回类型列表中指定元素的名称，则 Item1 等旧的默认名称仍然适用。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GlobalTemp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> (<span class="built_in">double</span> d1960, <span class="built_in">double</span> d1970, <span class="built_in">double</span> d1980,</span><br><span class="line">            <span class="built_in">double</span> d1990, <span class="built_in">double</span> d2000, <span class="built_in">double</span> d2010)</span><br><span class="line">    TempDifferenceUsingValueTupleCtor()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用构造函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueTuple&lt;<span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>,</span><br><span class="line">                <span class="built_in">double</span>, <span class="built_in">double</span>, <span class="built_in">double</span>&gt;(<span class="number">0.03</span>, <span class="number">0.00</span>, <span class="number">0.20</span>, <span class="number">0.34</span>, <span class="number">0.52</span>, <span class="number">0.63</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> (<span class="built_in">double</span> d1960, <span class="built_in">double</span> d1970, <span class="built_in">double</span> d1980,</span><br><span class="line">            <span class="built_in">double</span> d1990, <span class="built_in">double</span> d2000, <span class="built_in">double</span> d2010)</span><br><span class="line">    TempDifferenceUsingValueTuple()</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">//隐式创建</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0.03</span>, <span class="number">0.00</span>, <span class="number">0.20</span>, <span class="number">0.34</span>, <span class="number">0.52</span>, <span class="number">0.63</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GlobalTemp gt = <span class="keyword">new</span> GlobalTemp();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> tdVTuple = gt.TempDifferenceUsingValueTupleCtor();</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Temp increase 1950&#x27;s to 2000: &#123;0&#125;C.&quot;</span>, tdVTuple.d2000 ); <span class="comment">//参数名可见</span></span><br><span class="line"></span><br><span class="line">        tdVTuple = gt.TempDifferenceUsingValueTuple();</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Temp increase 1950&#x27;s to 2010: &#123;0&#125;C.&quot;</span>, tdVTuple.d2010); <span class="comment">//参数名可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果同上。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> C#读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> .net </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C#图解教程》读书笔记（四）</title>
      <link href="/2023/03/24/2023-03-24-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B4/"/>
      <url>/2023/03/24/2023-03-24-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇主要内容为：异步；命名空间与程序集；异常。<br>读书笔记仅为知识的记录，方便后续查找。<br>学习完成日期为2023年07月29日。</p></blockquote><div  align="center">  <img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/></div><h1 id="第二十一章-异步编程"><a href="#第二十一章-异步编程" class="headerlink" title="第二十一章 异步编程"></a>第二十一章 异步编程</h1><h2 id="什么是异步-Asynchrony"><a href="#什么是异步-Asynchrony" class="headerlink" title="什么是异步 Asynchrony"></a>什么是异步 Asynchrony</h2><p>启动程序时，系统会在内存中创建一个新的<strong>进程 process</strong>。进程是构成运行程序的资源的集合，这些资源包括虚地址空间、文件句柄等等。</p><p>在进程内部，系统创建了一个<strong>内核 kernal 对象</strong>，叫做<strong>线程 thread</strong>，代表了真正执行的程序。一旦进程建立，系统会在 Main 方法的第一行语句处开始线程的执行。</p><p>关于线程的有关知识点：<br>①默认情况下，一个进程只包含一个线程，从程序的开始一直执行到结束；<br>②线程可以派生其他线程，因此在任意时刻，一个进程都可能包含不同状态的多个线程，它们执行程序的不同部分；<br>③如果一个进程拥有多个线程，它们共享进程的资源；<br>④系统为处理器执行所调度的单元是线程，不是进程。</p><p>本章将学习<strong>异步编程</strong>。在异步程序中，程序代码不需要按照编写的顺序严格执行。有时需要在一个新的线程中运行一部分代码，有时无需创建新的线程，但为了更好地利用单个线程的能力，需要改变代码的执行顺序。</p><p>我们先来看看 C#5.0 引入的一个用来构建异步方法的新特性 <strong>async/await</strong> 。接下来学习一些可实现其他形式的异步编程的特性，这些特性是 .NET 框架的一部分，但没有嵌入 C# 语言。相关主题包括 BackgroundWorker 类和 .NET 任务并行库。两者均通过新建线程来实现异步。本章最后会介绍编写异步程序的其他方式。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>为了演示和比较，先看一个不使用异步的示例。然后再看一个实现类似功能的异步程序。</p><p>在下面的代码示例中，MyDownloadString 类的方法 DoRun 执行以下任务：<br>①创建 Stopwatch 类（位于 System.Diagnostics 命名空间）的一个实例并启动。该 Stopwatch 计时器用来测量代码中不同任务的执行时间；<br>②然后两次调用 CountCharacters 方法，下载某网站的内容，并返问该网站包含的字符数。网站由 URL 字符串指定，作为第二个参数传入；<br>③接着四次调用 CountToALargeNumber 方法。该方法仅执行一个消耗一定时间的任务，并循环指定次数<br>④最后，打印两个网站的字符数。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDownloadString</span> &#123;</span><br><span class="line">    Stopwatch sw = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoRun</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">int</span> LargeNumber = <span class="number">6</span>_000_000;</span><br><span class="line">        sw.Start();</span><br><span class="line">        <span class="built_in">int</span> t1 = CountCharacters( <span class="number">1</span>, <span class="string">&quot;http://www.google.com&quot;</span> );</span><br><span class="line">        <span class="built_in">int</span> t2 = CountCharacters( <span class="number">2</span>, <span class="string">&quot;http://www.illustratedcsharp.com&quot;</span> );</span><br><span class="line">        CountToALargeNumber( <span class="number">1</span>, LargeNumber );</span><br><span class="line">        CountToALargeNumber( <span class="number">2</span>, LargeNumber );</span><br><span class="line">        CountToALargeNumber( <span class="number">3</span>, LargeNumber );</span><br><span class="line">        CountToALargeNumber( <span class="number">4</span>, LargeNumber );</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Chars in http://www.google.com : <span class="subst">&#123; t1 &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Chars in http://www.illustratedcsharp.com: <span class="subst">&#123; t2 &#125;</span>&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">CountCharacters</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> uriString </span>)</span> &#123;</span><br><span class="line">        WebClient wc1 = <span class="keyword">new</span> WebClient();</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Starting call &#123;0&#125; : &#123;1, 4:N0&#125; ms&quot;</span>,</span><br><span class="line">                          id, sw.Elapsed.TotalMilliseconds );</span><br><span class="line">        <span class="built_in">string</span> result = wc1.DownloadString( <span class="keyword">new</span> Uri( uriString ) );</span><br><span class="line">        Console.WriteLine( <span class="string">&quot; Call &#123;0&#125; completed: &#123;1, 4:N0&#125; ms&quot;</span>,</span><br><span class="line">                          id, sw.Elapsed.TotalMilliseconds );</span><br><span class="line">        <span class="keyword">return</span> result.Length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CountToALargeNumber</span>(<span class="params"> <span class="built_in">int</span> id, <span class="built_in">int</span> <span class="keyword">value</span> </span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">long</span> i=<span class="number">0</span>; i &lt; <span class="keyword">value</span>; i++ )</span><br><span class="line">            ;</span><br><span class="line">        Console.WriteLine( <span class="string">&quot; End counting &#123;0&#125; : &#123;1, 4:N0&#125; ms&quot;</span>,</span><br><span class="line">                          id, sw.Elapsed.TotalMilliseconds );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        MyDownloadString ds = <span class="keyword">new</span> MyDownloadString();</span><br><span class="line">        ds.DoRun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Starting call 1 :    6 ms</span><br><span class="line"> Call 1 completed:  205 ms</span><br><span class="line">Starting call 2 :  205 ms</span><br><span class="line"> Call 2 completed:  695 ms</span><br><span class="line"> End counting 1 :  713 ms</span><br><span class="line"> End counting 2 :  733 ms</span><br><span class="line"> End counting 3 :  751 ms</span><br><span class="line"> End counting 4 :  767 ms</span><br><span class="line">Chars in http://www.google.com : 49672</span><br><span class="line">Chars in http://www.illustratedcsharp.com: 5164</span><br></pre></td></tr></table></figure><p>如同结果所示，Call 1 和 Call 2 占用了大部分时间，不管哪次调用，大部分时间都浪费在了等待网站的响应上。</p><p>如果先发起两个 CountCharacter 调用，不先等待结果，同时执行4个 CountToALargeNumber 调用，然后在两个 CountCharacter 方法调用结束之后再获取结果就可以提升性能。</p><p>C# 最新的 async/await 特性就允许我们这么做。可以重写代码以运用该特性，如下所示：<br>①当 DoRun 调用 CountCharactersAsync 时，CountCharactersAsync 将立即返回，然后才真正开始下载字符。它向调用方法返回的是一个 Task&lt;int&gt; 类型的占位符对象，表示它计划进行的工作。这个占位符最终将“返回”一个 int ；<br>②这使得 DoRun 不用等待实际工作完成就可继续执行。下一条语句是再次调用 CountCharactersAsync ，同样会返回一个 Task&lt;int&gt; 对象；<br>③接着，DoRun 可以继续执行，调用4次 CountToALargeNumber，同时 CountCharactersAsync 的两次调用继续它们的工作，基本上是等待（网站的响应）；<br>④ DoRun 的最后两行从 CountCharactersAsync 调用返回的 Tasks 中获取结果。如果还没有结果，将阻塞并等待。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDownloadString</span></span><br><span class="line">&#123;</span><br><span class="line">    Stopwatch sw = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoRun</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">int</span> LargeNumber = <span class="number">6</span>_000_000;</span><br><span class="line">        sw.Start();</span><br><span class="line"></span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; t1 = CountCharactersAsync( <span class="number">1</span>, <span class="string">&quot;http://www.google.com&quot;</span> ); <span class="comment">//保存结果的对象</span></span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; t2 = CountCharactersAsync( <span class="number">2</span>, <span class="string">&quot;http://www.illustratedcsharp.com&quot;</span> );</span><br><span class="line">        CountToALargeNumber( <span class="number">1</span>, LargeNumber );</span><br><span class="line">        CountToALargeNumber( <span class="number">2</span>, LargeNumber );</span><br><span class="line">        CountToALargeNumber( <span class="number">3</span>, LargeNumber );</span><br><span class="line">        CountToALargeNumber( <span class="number">4</span>, LargeNumber );</span><br><span class="line"></span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Chars in http://www.google.com : &#123;0&#125;&quot;</span>, t1.Result ); <span class="comment">//获取结果</span></span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Chars in http://www.illustratedcsharp.com: &#123;0&#125;&quot;</span>, t2.Result );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">CountCharactersAsync</span>(<span class="params"> <span class="built_in">int</span> id, <span class="built_in">string</span> site </span>)</span> &#123; <span class="comment">//上下文关键字async，Task&lt;int&gt;表示正在执行的工作，最终将返回int</span></span><br><span class="line">        WebClient wc = <span class="keyword">new</span> WebClient();</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Starting call &#123;0&#125; : &#123;1, 4:N0&#125; ms&quot;</span>,</span><br><span class="line">                            id, sw.Elapsed.TotalMilliseconds );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> result = <span class="keyword">await</span> wc.DownloadStringTaskAsync( <span class="keyword">new</span> Uri( site ) ); <span class="comment">//上下文关键字await</span></span><br><span class="line">        Console.WriteLine( <span class="string">&quot; Call &#123;0&#125; completed: &#123;1, 4:N0&#125; ms&quot;</span>,</span><br><span class="line">                            id, sw.Elapsed.TotalMilliseconds );</span><br><span class="line">        <span class="keyword">return</span> result.Length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CountToALargeNumber</span>(<span class="params"> <span class="built_in">int</span> id, <span class="built_in">int</span> <span class="keyword">value</span> </span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">long</span> i=<span class="number">0</span>; i &lt; <span class="keyword">value</span>; i++ ) ;</span><br><span class="line">        Console.WriteLine( <span class="string">&quot; End counting &#123;0&#125; : &#123;1, 4:N0&#125; ms&quot;</span>,</span><br><span class="line">                            id, sw.Elapsed.TotalMilliseconds );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        MyDownloadString ds = <span class="keyword">new</span> MyDownloadString();</span><br><span class="line">        ds.DoRun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Starting call 1 :    6 ms</span><br><span class="line">Starting call 2 :  111 ms</span><br><span class="line"> End counting 1 :  128 ms</span><br><span class="line"> End counting 2 :  143 ms</span><br><span class="line"> End counting 3 :  163 ms</span><br><span class="line"> End counting 4 :  181 ms</span><br><span class="line"> Call 1 completed:  244 ms</span><br><span class="line">Chars in http://www.google.com : 49657</span><br><span class="line"> Call 2 completed:  642 ms</span><br><span class="line">Chars in http://www.illustratedcsharp.com: 5164</span><br></pre></td></tr></table></figure><p>修改后的程序比原来快，因为 CountToALargeNumber 的4次调用是在 CountCharactersAsync 方法调用等待网络响应的时候进行的。所有这些工作都是在主线程完成的，没有创建任何额外的线程。</p><h2 id="async-await-特性的结构"><a href="#async-await-特性的结构" class="headerlink" title="async/await 特性的结构"></a>async/await 特性的结构</h2><p>如果一个程序调用某个方法，并在等待方法执行所有处理后才继续执行，我们称这种方法是<strong>同步的 synchronous</strong>。相反，<strong>异步 asynchronous</strong> 的方法在完成其所有工作之前就返回到调用方法。利用 C# 的 async/await 可以创建并使用异步方法。该特性由3个部分组成：<br>①调用方法，该方法调用异步方法，然后在异步方法执行其任务的时候继续执行（可能在相同的线程上，也可能在不同的线程上）；<br>②异步 async 方法，该方法异步执行其工作，然后立即返回到调用方法；<br>③ await 表达式，用于异步方法内部，指明需要异步执行的任务。一个异步方法可以包含任意多个 await 表达式，不过如果一个都不包含，编译器会发出警告。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>() <span class="comment">//调用方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; <span class="keyword">value</span> = DoAsyncStuff.CalculateSumAsync(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DoAsyncStuff</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">CalculateSumAsync</span>(<span class="params"> <span class="built_in">int</span> i1, <span class="built_in">int</span> i2</span>) <span class="comment">//异步方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="keyword">await</span> TaskEx.Run( () =&gt; GetSum( i1, i2 ) ); <span class="comment">//await表达式</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是异步方法"><a href="#什么是异步方法" class="headerlink" title="什么是异步方法"></a>什么是异步方法</h2><p>异步方法在完成其工作之前即返回到调用方法，然后在调用方法继续执行的时候完成其工作。</p><p>在语法上，异步方法具有以下特点：<br>①方法头中包含 async 方法修饰符；<br>②包含一个或多个 await 表达式，表示可以异步完成的任务；<br>③必须具备以下几种返回类型之一：void 、Task 、Task&lt;T&gt; 、ValueTask&lt;T&gt; 。第二种 Task 和第三种 Task&lt;T&gt; 的返回对象表示将在未来完成的工作，调用方法和异步方法可以继续执行；<br>④任何具有公开可访问的 GetAwaiter 方法的类型；<br>⑤异步方法的形参可以为任意类型、任意数量，但不能为 out 或 ref 参数；<br>⑥按照约定，异步方法的名称应该以 Async 为后缀；<br>⑦除了方法外，Lambda 表达式和匿名方法也可以作为异步对象。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">CountCharacterAsync</span>(<span class="params"> <span class="built_in">int</span> id, <span class="built_in">string</span> site </span>) <span class="comment">//关键字async和返回类型Task&lt;int&gt;</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine( <span class="string">&quot;Starting CountCharacters&quot;</span> );</span><br><span class="line">    WebClient wc = <span class="keyword">new</span> WebClient();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> result = <span class="keyword">await</span> wc.DowloadStringTaskAsync( <span class="keyword">new</span> Uri( site ) ); <span class="comment">//await表达式</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine( <span class="string">&quot;CountCharacters Completed&quot;</span> );</span><br><span class="line">    <span class="keyword">return</span> result.Length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>1. async 关键字</em></strong><br>①异步方法在方法头中必须包含 async 关键字，且必须位于返回类型之前；<br>②该修饰符只是标识该方法包含一个或多个 await 表达式。也就是说，它本身并不能创建任何异步操作；<br>③ async 关键字是一个上下文关键字，也就是说除了作为方法修饰符（或 Lambda 表达式修饰符、匿名方法修饰符）之外，async 还可用作标识符。</p><p><strong><em>2. 返回类型必须是以下类型之一</em></strong><br>① Task：如果调用方法不需要从异步方法中返回某个值，但需要检测异步方法的状态，那么异步方法可以返回一个 Task 类型的对象。在这种情况下，如果异步方法中包含任何 return 语句，则它们不能返回任何东西。下面的代码来自一个调用方法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Task someTask = DoStuff.CalculateSumAsync(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">...</span><br><span class="line">someTask.Wait();</span><br></pre></td></tr></table></figure><p>② Task&lt;T&gt;：如果调用方法要从调用中获取一个 T 类型的值，异步方法的返回类型就必须是Task&lt;T&gt;。调用方法将通过读取 Task 的 Result 属性来获取这个 T 类型的值。下面的代码来自一个调用方法，阐明了这一点：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Task&lt;<span class="built_in">int</span>&gt; <span class="keyword">value</span> = DoStuff.CalculateSumAsync( <span class="number">5</span>, <span class="number">6</span> );</span><br><span class="line">...</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Value: <span class="subst">&#123; <span class="keyword">value</span>.Result &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p>③ ValueTask&lt;T&gt;：这是一个值类型对象，它与 Task&lt;T&gt; 类似，但用于任务结果可能已经可用的情况。因为它是一个值类型，所以它可以放在栈上，而无须像 Task&lt;T&gt; 对象那样在堆上分配空间。因此在某些情况下可以提供性能。  </p><p>④ void：如果调用方法仅仅想执行异步方法，而不需要与它做任何进一步的交互时[这称为调用并忘记(fire and forget)]，异步方法可以返回 void 类型。这时，与上一种情况类似，即使异步方法中包含任何 return 语句，也不会返回任何东西。</p><p>⑤任何具有可访问的 GetAwaiter 方法的类型。</p><p>如本小节开头的代码，异步方法的返回类型为 Task&lt;int&gt; ，但方法体中不包含任何返回 Task&lt;int&gt; 类型对象的 return 语句。相反，方法最后的 return 语句返回了一个 int 类型的值。任何返回了 Task&lt;T&gt; 类型的异步方法，其返回值必须为 T 类型或可以隐式转换为 T 的类型。</p><p><strong><em>3. 以下代码，阐明了调用方法和异步方法在使用以上返回类型进行交互时所需的体系结构：</em></strong> </p><p>①使用返回 Task&lt;int&gt; 对象的异步方法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; <span class="keyword">value</span> = DoAsyncStuff.CalculateSumAsync( <span class="number">5</span>,<span class="number">6</span> );</span><br><span class="line">        <span class="comment">//处理其他事情</span></span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Value: &#123;0&#125;&quot;</span>,<span class="keyword">value</span>.Result );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DoAsyncStuff</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">CalculateSumAsync</span>(<span class="params"> <span class="built_in">int</span> i1,<span class="built_in">int</span> i2 </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="keyword">await</span> Task.Run( () =&gt; GetSum( i1, i2 ) );</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetSum</span>(<span class="params"> <span class="built_in">int</span> i1,<span class="built_in">int</span> i2 </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i1 + i2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②使用返回 Task 对象的异步方法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task someTask = DoAsyncStuff.CalculateSumAsync( <span class="number">5</span>, <span class="number">6</span> );</span><br><span class="line">        <span class="comment">//处理其他事情</span></span><br><span class="line">        someTask.Wait();</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Async stuff is done&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DoAsyncStuff</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">CalculateSumAsync</span>(<span class="params"> <span class="built_in">int</span> i1, <span class="built_in">int</span> i2 </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = <span class="keyword">await</span> Task.Run( () =&gt; GetSum( i1, i2 ) );</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Value: &#123;0&#125;&quot;</span>, <span class="keyword">value</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetSum</span>(<span class="params"> <span class="built_in">int</span> i1, <span class="built_in">int</span> i2 </span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i1 + i2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③使用“调用并忘记”的异步方法，并且使用了 Thread.Sleep 方法来暂停主线程，这样它就不会在异步方法完成之前退出：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        DoAsyncStuff.CalculateSumAsync( <span class="number">5</span>, <span class="number">6</span> );</span><br><span class="line">        <span class="comment">//处理其他事情</span></span><br><span class="line">        Thread.Sleep( <span class="number">200</span> );</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Program Exiting&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DoAsyncStuff</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">CalculateSumAsync</span>(<span class="params"> <span class="built_in">int</span> i1, <span class="built_in">int</span> i2 </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = <span class="keyword">await</span> Task.Run( () =&gt; GetSum( i1, i2 ) );</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Value: &#123;0&#125;&quot;</span>,<span class="keyword">value</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetSum</span>(<span class="params"> <span class="built_in">int</span> i1, <span class="built_in">int</span> i2 </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i1 + i2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④使用返回 ValueTask&lt;int&gt; 对象的异步方法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ValueTask&lt;<span class="built_in">int</span>&gt; <span class="keyword">value</span> = <span class="keyword">value</span> = DoAsyncStuff.CalculateSumAsync( <span class="number">0</span>, <span class="number">6</span> );</span><br><span class="line">        <span class="comment">//处理其他事情</span></span><br><span class="line">        Console.WriteLine( <span class="string">$&quot;Value: <span class="subst">&#123; <span class="keyword">value</span>.Result &#125;</span>&quot;</span> );</span><br><span class="line">        <span class="keyword">value</span> = DoAsyncStuff.CalculateSumAsync( <span class="number">5</span>, <span class="number">6</span> );</span><br><span class="line">        <span class="comment">//处理其他事情</span></span><br><span class="line">        Console.WriteLine( <span class="string">$&quot;Value: <span class="subst">&#123; <span class="keyword">value</span>.Result &#125;</span>&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DoAsyncStuff</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> ValueTask&lt;<span class="built_in">int</span>&gt; <span class="title">CalculateSumAsync</span>(<span class="params"> <span class="built_in">int</span> i1, <span class="built_in">int</span> i2 </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 == <span class="number">0</span>) <span class="comment">//如果i1 == 0，则可以避免长时间运行任务</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> sum = <span class="keyword">await</span> Task&lt;<span class="built_in">int</span>&gt;.Run( () =&gt; GetSum( i1, i2 ) );</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetSum</span>(<span class="params"> <span class="built_in">int</span> i1, <span class="built_in">int</span> i2 </span>)</span> &#123; <span class="keyword">return</span> i1 + i2; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步方法的控制流"><a href="#异步方法的控制流" class="headerlink" title="异步方法的控制流"></a>异步方法的控制流</h3><p>异步方法的结构包含三个不同的区域：<br>①第一个 await 表达式之前的部分：从方法开头到第一个 await 表达式之前的所有代码。这一部分应该只包含少量无须长时间处理的代码；<br>② await 表达式：表示被异步执行的代码；<br>③后续部分：await 表达式之后的方法中的其余代码。包括其执行环境，如所在线程信息、目前作用域内的变量值，以及当 await 表达式完成后重新执行时所需的其他信息。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">CountCharactersAsync</span>(<span class="params"> <span class="built_in">int</span> id, <span class="built_in">string</span> site </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一个 await 表达式之前的部分</span></span><br><span class="line">    Console.WriteLine( <span class="string">&quot;Starting CountCharacters&quot;</span> );</span><br><span class="line">    WebCline wc = <span class="keyword">new</span> WebCline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//await 表达式</span></span><br><span class="line">    <span class="built_in">string</span> result = <span class="keyword">await</span> wc.DownloadStringTaskAsync( <span class="keyword">new</span> Uri( site ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后续部分</span></span><br><span class="line">    Console.WriteLine( <span class="string">&quot;CountCharacters Completed&quot;</span> );</span><br><span class="line">    <span class="keyword">return</span> result.Length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/04/02/Ag7VSjdKPB6srCG.png" width = "75%" height = "75%" alt="图99 - 贯穿一个异步方法的控制流"/></div><p>上图阐明了一个异步方法的控制流。它从第一个 await 表达式之前的代码开始，正常 (同步地）执行直到遇见第一个 await 。这一区域实际上在第一个 await 表达式处结束，此时 await 任务还没有完成（大多数情况下如此)。当 await 的任务完成时，方法将继续同步执行。如果还有其他 await ，就重复上述过程。当达到 await 表达式时，异步方法将控制返回到调用方法。如果方法的返回类型为 Task 或 Task&lt;T&gt; 类型，将创建一个 Task 对象，表示需异步完成的任务和后续，然后将该 Task 返回到调用方法。</p><p>目前有两个控制流：一个异步方法内的和一个调用方法内的。异步方法内的代码完成以下工作：<br>①异步执行 await 表达式的<strong>等候任务 awaitable task</strong> ；<br>②当 await 表达式完成后，执行后续部分。后续部分本身也可能包含其他 await 表达式，这些表达式也将按照相同的方式处理，即异步执行 await 表达式，然后执行后续部分；<br>③当后续部分遇到 return 语句或到达方法末尾时：如果方法返回类型为 void ，控制流将退出；如果方法返冋类型为 Task ，则后续部分设置 Task 的状态属性并退出。如果返回类型为 Task&lt;T&gt; 或 ValueTask&lt;T&gt; ，后续部分还将设置 Task 对象的 Result 属性。</p><p>同时，调用方法中的代码将继续其进程，从异步方法获取 Task&lt;T&gt; 或 ValueTask&lt;T&gt; 对象。当需要实际值时，就引用 Task 或 ValueTask 对象的 Result 属性。届时，如果异步方法设置了该属性，调用方法就能获得该值并继续。否则，它将暂停并等待该属性被设置，然后再继续执行。</p><p>异步方法第一次遇到 await 时所返回对象的类型，就是异步方法头中的返回类型，它与 await 表达式的返回值类型一点关系也没有。例如下面的代码，await 表达式返回一个 string 。但在方法的执行过程中，当到达 await 表达式时，异步方法返回到调用方法的是一个 Task&lt;int&gt; 对象，这正是该方法的返回类型：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">CountCharactersAsync</span>(<span class="params"> <span class="built_in">string</span> site </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    WebClient wc = <span class="keyword">new</span> WebClient();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> result = <span class="keyword">await</span> wc.DownloadStringTaskAsync( <span class="keyword">new</span> Uri( site ) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.Length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步方法的 return 语句也是如此，它并没有真正地返回某个值，它只是退出了。</p><p><strong><em>await 表达式</em></strong><br>await 表达式指定了一个异步执行的任务，语法：<code>await task</code>，由 await 关键字和一个<strong>等候对象 awaitable object</strong>（称为任务 task ）组成。这个任务可能是一个 Task 类型的对象，也可能不是。默认情况下，这个任务在当前线程异步运行。</p><p>一个<strong>等候对象 awaitable object</strong> 即是一个<strong>等候类型 awaitable type</strong> 的实例。awaitable 类型是指包含 GetAwaiter 方法的类型，该方法没有参数，返回一个 awaiter 类型的对象。</p><p>awaiter 类型包含以下成员：<br>①<code>bool IsCompleted &#123; get; &#125;</code><br>②<code>void OnCompleted(Action);</code><br>③<code>void GetResult();</code><br>④<code>T GetResult();</code> T 为任意类型。</p><p>然而实除上，很少需要构建自己的 awaitable 。相反，应该使用 Task 或 ValueTask 类，它们可能是大多数程序员唯一需要使用的 awaitable 类型。</p><p>在 .NET 4.5 中，微软发布了大量新的和修订的异步方法（在 BCL 中），它们可返回 Task&lt;T&gt; 类型的对象。将这些放到 await 表达式中，它们将在当前线程中异步执行。比如在之前的很多示例中的 WebClient.DownloadStringTaskAsync 方法，它也是这些异步方法中的一个。以下代码阐明了其用法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Uri site = <span class="keyword">new</span> Uri(<span class="string">&quot;http://www.illustratedcsharp.com&quot;</span> );</span><br><span class="line">WebClient wc = <span class="keyword">new</span> WebClient();</span><br><span class="line"><span class="built_in">string</span> result = <span class="keyword">await</span> wc.DownloadStringTaskAsync( site );</span><br></pre></td></tr></table></figure><p>尽管目前 BCL 中存在很多返回 Task&lt;T&gt; 类型对象的方法，可能仍然需要编写自己的方法，作为 await 表达式的任务。最简单的方式是在方法中使用 Task.Run 方法来创建一个 Task 。关于 Task.Run ，有一点非常重要，即它是在不同的线程上运行你的方法。</p><p>Task.Run 的一个签名如下，以 Func&lt;TReturn&gt; 委托为参数。如第20章所述，Func&lt;TReturn&gt; 是一个预定义的委托，它不包含任何参数，返回值的类型为 TReturn ：<code>Task Run( Func&lt;TReturn&gt; func )</code></p><p>因此，要将你的方法传递给 Task.Run 方法，需要基于该方法创建一个委托。下面的代码展示了三种实现方式。其中，Get10 与 Func&lt;int&gt; 委托兼容，因为它没有参数并且返回 int ：<br>①第一个实例（ DoWorkAsync 方法的前两行）使用 Get10 创建名为 ten 的 Func&lt;int&gt; 委托。然后在下一行将该委托用于 Task.Run 方法；<br>②第二个实例在 Task.Run 方法的参数列表中创建 Func&lt;int&gt; 委托；<br>③第三个实例没有使用 Get10 方法。而是使用了组成 Get10 方法体的 return 语句，将其用于与 Func&lt;int&gt; 委托兼容的 Lambda 表达式。该 Lambda 表达式将隐式转换为该委托。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Get10</span>() <span class="comment">//与Func&lt;int&gt;兼容</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">DoWorkAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Func&lt;<span class="built_in">int</span>&gt; ten = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>&gt;(Get10);</span><br><span class="line">        <span class="built_in">int</span> a = <span class="keyword">await</span> Task.Run(ten);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> b = <span class="keyword">await</span> Task.Run(<span class="keyword">new</span> Func&lt;<span class="built_in">int</span>&gt;(Get10));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> c = <span class="keyword">await</span> Task.Run(()=&gt;&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; a &#125;</span> <span class="subst">&#123; b &#125;</span> <span class="subst">&#123; c &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task t = (<span class="keyword">new</span> MyClass()).DoWorkAsync();</span><br><span class="line">        t.Wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">10 10 10</span><br></pre></td></tr></table></figure><p>在上面的示例中，使用的 Task.Run 的签名以 Func&lt;TResult&gt; 为参数。该方法共有8个重载，如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">返回类型</th><th style="text-align:left">签名</th></tr></thead><tbody><tr><td style="text-align:left">Task</td><td style="text-align:left">Run( Action action )</td></tr><tr><td style="text-align:left">Task</td><td style="text-align:left">Run( Action action, CancellationToken token )</td></tr><tr><td style="text-align:left">Task&lt;TResult&gt;</td><td style="text-align:left">Run( Func&lt;TResult&gt; function )</td></tr><tr><td style="text-align:left">Task&lt;TResult&gt;</td><td style="text-align:left">Run( Func&lt;TResult&gt; function, CancellationToken token )</td></tr><tr><td style="text-align:left">Task</td><td style="text-align:left">Run( Func&lt;Task&gt; function )</td></tr><tr><td style="text-align:left">Task</td><td style="text-align:left">Run( Func&lt;Task&gt; function, CancellationToken token )</td></tr><tr><td style="text-align:left">Task&lt;TResult&gt;</td><td style="text-align:left">Run( Func&lt;Task&lt;TResult&gt;&gt; function )</td></tr><tr><td style="text-align:left">Task&lt;TResult&gt;</td><td style="text-align:left">Run( Func&lt;Task&lt;TResult&gt;&gt; function, CancellationToken token )</td></tr></tbody></table></div><p>下表展示了可作为 Task.Run 方法第一个参数的4个委托类型的签名:</p><div class="table-container"><table><thead><tr><th style="text-align:left">委托类型</th><th style="text-align:left">签名</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">Action</td><td style="text-align:left">void Action( )</td><td style="text-align:left">不需要参数且无返回值的方法</td></tr><tr><td style="text-align:left">Func&lt;TResult&gt;</td><td style="text-align:left">TResult Func( )</td><td style="text-align:left">不需要参数，但返回TResult类型对象的方法</td></tr><tr><td style="text-align:left">Func&lt;Task&gt;</td><td style="text-align:left">Task Func( )</td><td style="text-align:left">不需要参数，但返回简单Task对象的方法</td></tr><tr><td style="text-align:left">Func&lt;Task&lt;TResult&gt;&gt;</td><td style="text-align:left">Task&lt;TResult&gt; Func( )</td><td style="text-align:left">不需要参数，但返回Task&lt;T&gt;类型对象的方法</td></tr></tbody></table></div><p>下面的代码展示了4个 await 语句，使用 Task.Run 方法来运行4种不同的委托类型所表示的方法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DoWorkAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Run(() =&gt; Console.WriteLine(<span class="number">5.</span>ToString())); <span class="comment">//Action</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine((<span class="keyword">await</span> Task.Run(() =&gt; <span class="number">6</span>)).ToString()); <span class="comment">//TResult Func()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Task.Run(() =&gt; Task.Run(() =&gt; Console.WriteLine(<span class="number">7.</span>ToString()))); <span class="comment">//Task Func()</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = <span class="keyword">await</span> Task.Run(() =&gt; Task.Run(() =&gt; <span class="number">8</span>)); <span class="comment">//Task&lt;TResult&gt; Func()</span></span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task t = MyClass.DoWorkAsync();</span><br><span class="line">        t.Wait();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Press Enter key to exit&quot;</span>);</span><br><span class="line">        Console.Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">Press Enter key to exit</span><br></pre></td></tr></table></figure><p>在能使用任何其他表达式的地方，都可以使用 await 表达式（只要位于异步方法内）。在上面的代码中，4个await表达式用在了3个不同的位置：①第一个和第三个实例将 await 表达式用作语句；②第二个实例将 await 表达式用作 WriteLine 方法的参数；③第四个实例将 await 表达式用作赋值语句的右端。</p><p>假设我们的某个方法不符合这4种委托形式。例如，假设有一个 GetSum 方法以两个 int 值作为输入，并返回这两个值的和。这与上述4个可接受的委托都不兼容，因为该方法有参数，而上面4个可接受的委托都不需要参数。要解决这个问题，可以用可接受的 Func 委托的形式创建一个 Lambda 函数，其唯一的行为就是运行 GetSum 方法，如该代码所示：<code>int value = await Task.Run(() =&gt; GetSum(5, 6));</code>。Lambda 函数 ( )=&gt;GetSum(5, 6) 满足 Func&lt;TResult&gt; 委托，因为它没有参数，且返回单一的值。完整的示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetSum</span>(<span class="params"><span class="built_in">int</span> i1, <span class="built_in">int</span> i2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i1 + i2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DoWorkAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = <span class="keyword">await</span> Task.Run( ()=&gt;GetSum(<span class="number">5</span>, <span class="number">6</span>) ); <span class="comment">//TResult Func()</span></span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task t = MyClass.DoWorkAsync();</span><br><span class="line">        t.Wait();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Press Enter key to exit&quot;</span>); </span><br><span class="line">        Console.Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">Press Enter key to exit</span><br></pre></td></tr></table></figure><h3 id="取消一个异步操作"><a href="#取消一个异步操作" class="headerlink" title="取消一个异步操作"></a>取消一个异步操作</h3><p>一些 .NET 异步方法允许你请求终止执行。你同样也可以在自己的异步方法中加入这个特性。System.Threading.Tasks 命名空间中有两个类是为此目的而设计的：CancellationToken 和 CancellationTokenSource ：<br>① CancellationToken 对象包含一个任务是否应被取消的信息；<br>② 拥有 CancellationToken 对象的任务需要定期检查其令牌（token）状态。如果 CancellationToken 对象的 IsCancellationRequested 属性为 true ，任务需停止其操作并返回；<br>③ CancellationToken 是不可逆的，并且只能使用一次。也就是说，一旦 IsCancellationRequested 属性被设置为 true ，就不能更改了；<br>④ CancellationTokenSource 对象创建可分配给不同任务的 CancellationToken 对象。任何持有 CancellationTokenSource 的对象都可以调用其 Cancel 方法，这会将 CancellationToken 的 IsCancellationRequested 属性设置为 true 。</p><p>下面的代码展示了如何使用 CancellationTokenSource 和 CancellationToken 来实现取消操作。注意，该过程是协同 cooperative 的，即调用 CancellationTokenSource 的 Cancel 时，它本身并不会执行取消操作，而是会将 CancellationToken 的 IsCancellationRequested 属性设置为 true 。包含 CancellationToken 的代码负责检查该属性，并判断是否需要停止执行并返回。</p><p>下面的代码展示了如何使用这两个取消类。如下所示代码并没有取消异步方法，而是在 Main 方法中间包含两行被注释的代码，它们触发了取消行为：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        CancellationToken token = cts.Token;</span><br><span class="line"></span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">        Task t = mc.RunAsync( token );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread.Sleep( 3000 ); //等待3秒</span></span><br><span class="line">        <span class="comment">//cts.Cancel(); //取消操作</span></span><br><span class="line"></span><br><span class="line">        t.Wait();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Was Cancelled: <span class="subst">&#123; token.IsCancellationRequested &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">RunAsync</span>(<span class="params"> CancellationToken ct </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ct.IsCancellationRequested )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">await</span> Task.Run( () =&gt; CycleMethod( ct ), ct );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CycleMethod</span>(<span class="params"> CancellationToken ct </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Starting CycleMethod&quot;</span> );</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">int</span> max = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; max; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ct.IsCancellationRequested ) <span class="comment">//监控CancellationToken.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            Thread.Sleep( <span class="number">1000</span> );</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot; <span class="subst">&#123; i+<span class="number">1</span> &#125;</span> of <span class="subst">&#123; max &#125;</span> iterations completed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次运行时保留注释的代码，不会取消任务，产生的结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Starting CycleMethod</span><br><span class="line"> 1 of 5 iterations completed</span><br><span class="line"> 2 of 5 iterations completed</span><br><span class="line"> 3 of 5 iterations completed</span><br><span class="line"> 4 of 5 iterations completed</span><br><span class="line"> 5 of 5 iterations completed</span><br><span class="line">Was Cancelled: False</span><br></pre></td></tr></table></figure><p>如果运行 Main 方法中 Thread.Sleep 和 Cancel 语句，任务将在3秒后取消，产生的结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Starting CycleMethod</span><br><span class="line"> 1 of 5 iterations completed</span><br><span class="line"> 2 of 5 iterations completed</span><br><span class="line"> 3 of 5 iterations completed</span><br><span class="line">Was Cancelled: True</span><br></pre></td></tr></table></figure><p><strong><em>异常处理和 await 表达式</em></strong><br>将 await 表达式放在 try 语句内，使用 try…catch…finally 结构：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task t = BadAsync();</span><br><span class="line">        t.Wait();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Task Status : <span class="subst">&#123; t.Status &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Task IsFaulted: <span class="subst">&#123; t.IsFaulted &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">BadAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> Task.Run(() =&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Exception(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Exception in BadAsync&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Exception in BadAsync</span><br><span class="line">Task Status : RanToCompletion</span><br><span class="line">Task IsFaulted: False</span><br></pre></td></tr></table></figure><p>注意，尽管 Task 抛出了一个 Exception ，但在 Main 的最后，Task 的状态仍然 RanToCompletion 。这会让人感到很意外，因为异步方法抛出了异常。原因是以下两个条件成立：①Task 没有被取消，②没有未处理的异常。类似地，IsFaulted 属性为 False ，因为没有未处理的异常。</p><h3 id="在调用方法中同步地等待任务"><a href="#在调用方法中同步地等待任务" class="headerlink" title="在调用方法中同步地等待任务"></a>在调用方法中同步地等待任务</h3><p>调用方法可以调用任意多个异步方法并接收它们返回的 Task 对象。然后你的代码会继续执行其他任务，但在某个点上可能会需要等待某个特殊 Task 对象完成，然后再继续。为此，Task 类提供了一个实例方法 <strong>Wait</strong> ，可以在 Task 对象上调用该方法。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyDownloadString</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoRun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; t = CountCharactersAsync( <span class="string">&quot;http://www.illustratedcsharp.com&quot;</span> );</span><br><span class="line"></span><br><span class="line">        t.Wait(); <span class="comment">//等待任务t结束</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;The task has finished, returning value <span class="subst">&#123; t.Result &#125;</span>.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">CountCharactersAsync</span>(<span class="params"> <span class="built_in">string</span> site </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="keyword">await</span> <span class="keyword">new</span> WebClient().DownloadStringTaskAsync( <span class="keyword">new</span> Uri( site ) );</span><br><span class="line">        <span class="keyword">return</span> result.Length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDownloadString.DoRun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">The task has finished, returning value 5164.</span><br></pre></td></tr></table></figure><p>Wait 方法既可用于单一 Task 对象，也可以等待一组 Task 对象。对于一组 Task，有两种静态方法：① <strong>WaitAll</strong>：等待所有任务都结束；② <strong>WaitAny</strong>：等待某一个任务结束。这两个方法是同步方法且没有返回值。</p><p>比如以下这个简单的程序，它包含一个 DoRun 方法，该方法两次调用一个异步方法并获取其返回的两个 Task&lt;int&gt; 对象。然后，方法继续执行，检査任务是否完成并打印。方法最后会等待调用 Console.Read，该方法等待并接受键盘输入的字符。把它放在这里是因为不然的话，main 方法会异步任务完成前退出：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDownloadString</span></span><br><span class="line">&#123;</span><br><span class="line">    Stopwatch sw = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoRun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sw.Start();</span><br><span class="line"></span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; t1 = CountCharactersAsync( <span class="number">1</span>, <span class="string">&quot;http://www.google.com&quot;</span> );</span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; t2 = CountCharactersAsync( <span class="number">2</span>, <span class="string">&quot;http://www.illustratedcsharp.com&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Task.WaitAll( t1, t2 );</span></span><br><span class="line">        <span class="comment">//Task.WaitAny( t1, t2 );</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Task 1: &#123;0&#125;Finished&quot;</span>, t1.IsCompleted ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;Not &quot;</span> );</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Task 2: &#123;0&#125;Finished&quot;</span>, t2.IsCompleted ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;Not &quot;</span> );</span><br><span class="line">        Console.Read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">CountCharactersAsync</span>(<span class="params"> <span class="built_in">int</span> id, <span class="built_in">string</span> site </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WebClient wc = <span class="keyword">new</span> WebClient();</span><br><span class="line">        <span class="built_in">string</span> result = <span class="keyword">await</span> wc.DownloadStringTaskAsync( <span class="keyword">new</span> Uri( site ) );</span><br><span class="line">        Console.WriteLine( <span class="string">&quot; Call &#123;0&#125; completed: &#123;1, 4:N0&#125; ms&quot;</span>,</span><br><span class="line">                                        id, sw.Elapsed.TotalMilliseconds );</span><br><span class="line">        <span class="keyword">return</span> result.Length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDownloadString ds = <span class="keyword">new</span> MyDownloadString();</span><br><span class="line">        ds.DoRun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码产生的结果如下。注意，在检査这两个 Task 的 IsCompleted 方法时，没有一个是完成的：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Task 1: Not Finished</span><br><span class="line">Task 2: Not Finished</span><br><span class="line"> Call 1 completed:  222 ms</span><br><span class="line"> Call 2 completed:  627 ms</span><br></pre></td></tr></table></figure><p>如果取消 DoRun 中那两行代码中第一个的注释，代码会停止并等待任务全部完成，然后继续执行：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line"> Call 1 completed:  226 ms</span><br><span class="line"> Call 2 completed:  601 ms</span><br><span class="line">Task 1: Finished</span><br><span class="line">Task 2: Finished</span><br></pre></td></tr></table></figure><p>如果注释掉 WaitAll 方法，取消 WaitAny 方法调用的注释，代码结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line"> Call 1 completed:  227 ms</span><br><span class="line">Task 1: Finished</span><br><span class="line">Task 2: Not Finished</span><br><span class="line"> Call 2 completed:  651 ms</span><br></pre></td></tr></table></figure><p>WaitAll 和 WaitAny 分别还包含4个重载，除了完成任务之外，还允许以不同的方式继续执行，比如设置超时时间或使用 CancellationToken 来强制执行处理的后续部分。下表展示了这些重载方法：</p><div class="table-container"><table><thead><tr><th style="text-align:left">签名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">void WaitAll(params Task[ ] tasks )</td><td style="text-align:left">等待所有任务完成</td></tr><tr><td style="text-align:left">bool WaitAll(Task[ ] tasks, int millisecondsTimeout )</td><td style="text-align:left">等待所有任务完成。如果在超时时限内没有全部完成，则返回false并继续执行</td></tr><tr><td style="text-align:left">void WaitAll(Task[ ] tasks, CancellationToken token )</td><td style="text-align:left">等待所有任务完成，或等待CancellationToke发出取消信号</td></tr><tr><td style="text-align:left">bool WaitAll(Task[ ] tasks, TimeSpan span )</td><td style="text-align:left">等待所有任务完成。如果在超时时限内没有全部完成，则返回false并继续执行</td></tr><tr><td style="text-align:left">bool WaitAll(Task[ ] tasks, int millisecondsTimeout, CancellationToken token )</td><td style="text-align:left">等待所有任务完成，或等待CancellationToke发出取消信号。如果在超时时限内没有发生上述情况，则返回false并继续执行</td></tr><tr><td style="text-align:left">void WaitAny(params Task[ ] tasks )</td><td style="text-align:left">等待任意一个任务完成</td></tr><tr><td style="text-align:left">bool WaitAny (Task[ ] tasks, int millisecondsTimeout )</td><td style="text-align:left">等待任意一个任务完成。如果在超时时限内没有全部完成，则返回false并继续执行</td></tr><tr><td style="text-align:left">void WaitAny (Task[ ] tasks, CancellationToken token )</td><td style="text-align:left">等待任意一个任务完成，或等待CancellationToke发出取消信号</td></tr><tr><td style="text-align:left">bool WaitAny (Task[ ] tasks, TimeSpan span )</td><td style="text-align:left">等待任意一个任务完成。如果在超时时限内没有全部完成，则返回false并继续执行</td></tr><tr><td style="text-align:left">bool WaitAny (Task[ ] tasks, int millisecondsTimeout, CancellationToken token )</td><td style="text-align:left">等待任意一个任务完成，或等待CancellationToke发出取消信号。如果在超时时限内没有发生上述情况，则返回false并继续执行</td></tr></tbody></table></div><h3 id="在异步方法中异步地等待任务"><a href="#在异步方法中异步地等待任务" class="headerlink" title="在异步方法中异步地等待任务"></a>在异步方法中异步地等待任务</h3><p>有时在异步方法中，会希望用 await 表达式来等待 Task 。这时异步方法会返回到调用方法，但该异步方法会等待一个或所有任务完成。可以通过 <strong>Task.WhenAll</strong> 和 <strong>Task.WhenAny</strong> 方法来实现。这两个方法称为<strong>组合子 combinator</strong>。</p><p>下面的代码展示了一个使用 Task.WhenAll 方法的示例。该方法异步地等待所有与之相关的 Task 完成，不会占用主线程的时间。注意，await 表达式的任务就是调用 Task.WhenAll ：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDownloadString</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoRun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; t = CountCharactersAsync( <span class="string">&quot;http://www.google.com&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;http://www.illustratedcsharp.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine( <span class="string">&quot;DoRun: Task &#123;0&#125;Finished&quot;</span>, t.IsCompleted ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;Not &quot;</span> );</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;DoRun: Result = &#123;0&#125;&quot;</span>, t.Result );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">CountCharactersAsync</span>(<span class="params"><span class="built_in">string</span> site1, <span class="built_in">string</span> site2 </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WebClient wc1 = <span class="keyword">new</span> WebClient();</span><br><span class="line">        WebClient wc2 = <span class="keyword">new</span> WebClient();</span><br><span class="line">        Task&lt;<span class="built_in">string</span>&gt; t1 = wc1.DownloadStringTaskAsync( <span class="keyword">new</span> Uri( site1 ) );</span><br><span class="line">        Task&lt;<span class="built_in">string</span>&gt; t2 = wc2.DownloadStringTaskAsync( <span class="keyword">new</span> Uri( site2 ) );</span><br><span class="line"></span><br><span class="line">        List&lt;Task&lt;<span class="built_in">string</span>&gt;&gt; tasks = <span class="keyword">new</span> List&lt;Task&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line">        tasks.Add( t1 );</span><br><span class="line">        tasks.Add( t2 );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Task.WhenAll( tasks );</span><br><span class="line"></span><br><span class="line">        Console.WriteLine( <span class="string">&quot; CCA: T1 &#123;0&#125;Finished&quot;</span>, t1.IsCompleted ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;Not &quot;</span> );</span><br><span class="line">        Console.WriteLine( <span class="string">&quot; CCA: T2 &#123;0&#125;Finished&quot;</span>, t2.IsCompleted ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;Not &quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t1.IsCompleted ? t1.Result.Length : t2.Result.Length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDownloadString ds = <span class="keyword">new</span> MyDownloadString();</span><br><span class="line">        ds.DoRun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">DoRun: Task Not Finished</span><br><span class="line"> CCA: T1 Finished</span><br><span class="line"> CCA: T2 Finished</span><br><span class="line">DoRun: Result = 49830</span><br></pre></td></tr></table></figure><p>Task.WhenAny 组合子会异步地等待与之相关的某个 Task 完成。如果将上面的 await 表达式由调用 Task.WhenAll 改为调用 Task.WhenAny，并返回到程序，将产生以下输出结果：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">DoRun: Task Not Finished</span><br><span class="line"> CCA: T1 Finished</span><br><span class="line"> CCA: T2 Not Finished</span><br><span class="line">DoRun: Result = 49858</span><br></pre></td></tr></table></figure><h3 id="Task-Delay-方法"><a href="#Task-Delay-方法" class="headerlink" title="Task.Delay 方法"></a>Task.Delay 方法</h3><p>Task.Delay 方法创建一个 Task 对象，该对象将暂停其在线程中的处理，并在一定时间之后完成。然而与 Thread.Sleep 阻塞线程不同的是，Task.Delay 不会阻塞线程，线程可以继续处理其他工作。代码如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Simple</span></span><br><span class="line">&#123;</span><br><span class="line">    Stopwatch sw = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoRun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Caller: Before call&quot;</span> );</span><br><span class="line">        ShowDelayAsync();</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Caller: After call&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">ShowDelayAsync</span> (<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sw.Start();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot; Before Delay: <span class="subst">&#123; sw.ElapsedMilliseconds &#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> Task.Delay( <span class="number">1000</span> );</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot; After Delay : <span class="subst">&#123; sw.ElapsedMilliseconds &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Simple ds = <span class="keyword">new</span> Simple ();</span><br><span class="line">        ds.DoRun();</span><br><span class="line">        Console.Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Caller: Before call</span><br><span class="line"> Before Delay: 0</span><br><span class="line">Caller: After call</span><br><span class="line"> After Delay : 991</span><br></pre></td></tr></table></figure><p>Delay 方法包含4个重载，允许以不同方式来指定时间周期，同时还允许使用 CancellationToken 对象，如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">签名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Task Delay(int millisecondsDelay)</td><td style="text-align:left">在以毫秒表示的延迟时间到期后，返回完成的Task对象</td></tr><tr><td style="text-align:left">Task Delay(TimeSpan delay)</td><td style="text-align:left">在以.NET TimeSpan 对象表示的延迟时间到期后，返回完成的Task对象</td></tr><tr><td style="text-align:left">Task Delay(int millisecondsDelay, CancellationToken token)</td><td style="text-align:left">在以毫秒表示的延迟时间到期后，返回完成的Task对象。可通过取消令牌来取消该操作</td></tr><tr><td style="text-align:left">Task Delay(TimeSpan delay, CancellationToken token)</td><td style="text-align:left">在以.NET TimeSpan 对象表示的延迟时间到期后，返回完成的Task对象。可通过取消令牌来取消该操作</td></tr></tbody></table></div><h2 id="GUI-程序中的异步操作"><a href="#GUI-程序中的异步操作" class="headerlink" title="GUI 程序中的异步操作"></a>GUI 程序中的异步操作</h2><p>尽管本章目前的所有代码均为控制台应用程序，但实际上异步方法在 GUI 程序中尤为有用。</p><p>原因是 GUI 程序在设计上就要求所有的显示变化都必须在主 GUI 线程中完成，如点击按钮、展示标签、移动窗体等。Windows 程序是通过消息来实现这一点的，消息被放入由<strong>消息泵 message pump</strong> 管理的消息队列中。消息泵从队列中取出一条消息，并调用它的处理程序 handler 代码。当处理程序代码完成时，消息泵获取下一条消息并循环这个过程。</p><p>由于这种架构，处理程序代码就必须快捷，这样才不至于挂起并阻碍其他 GUI 行为的处理。如果某个消息的处理程序代码耗时过长，消息队列中的消息会产生积压，程序将失去响应，因为在那个长时间运行的处理程序完成之前，无法处理任何消息。</p><blockquote><p>书中展示的是一个 WPF 程序，WPF 是微软替代 Windows Form 的 GUI 编程框架，需要使用 Visual Studio 来创建 WPF 程序，故暂不抄录。需要学习桌面应用程序时，再学习即可。目前主流为基于 Web 技术的桌面应用开发，而不是传统的 GUI 程序。</p></blockquote><h3 id="Task-Yield-方法"><a href="#Task-Yield-方法" class="headerlink" title="Task.Yield 方法"></a>Task.Yield 方法</h3><p>Task.Yield 方法创建一个立即返回的 awaitable 。等待一个 Yield 可以让异步方法在执行后续部分的同时返回到调用方法。可以将其理解成离开当前的消息队列，回到队列末尾，让处理器有时间处理其他任务。</p><p>下面的示例代码展示了一个异步方法，程序每执行某个循环1000次就移交一次控制权。每次执行 Yield 方法，都会允许线程中的其他任务得以执行：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DoStuff</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">FindSeriesSum</span>(<span class="params"> <span class="built_in">int</span> i1 </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; i1; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="keyword">if</span> ( i % <span class="number">1000</span> == <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">await</span> Task.Yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task&lt;<span class="built_in">int</span>&gt; <span class="keyword">value</span> = DoStuff.FindSeriesSum( <span class="number">1</span>_000_000 );</span><br><span class="line">        CountBig( <span class="number">100</span>_000 ); CountBig( <span class="number">100</span>_000 );</span><br><span class="line">        CountBig( <span class="number">100</span>_000 ); CountBig( <span class="number">100</span>_000 );</span><br><span class="line">        Console.WriteLine( <span class="string">$&quot;Sum: <span class="subst">&#123; <span class="keyword">value</span>.Result &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountBig</span>(<span class="params"> <span class="built_in">int</span> p </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; p; i++ )</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Sum: 1783293664</span><br></pre></td></tr></table></figure><p>Yield 方法在 GUI 程序中非常有用，可以中断大量工作，让其他任务使用处理器。</p><h2 id="使用异步-Lambda-表达式"><a href="#使用异步-Lambda-表达式" class="headerlink" title="使用异步 Lambda 表达式"></a>使用异步 Lambda 表达式</h2><p>到目前为止，本章只介绍了异步方法。但还可以使用异步匿名方法和异步 Lambda 表达式。这种构造尤其适合那些只有很少工作的事件处理程序。下面的代码片段将一个 Lambda 表达式注册为一个按钮点击事件的事件处理程序：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">startWorkButton.Click += <span class="keyword">async</span> (sender,e )=&gt; <span class="comment">// Async lambda 表达式</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//处理点击处理程序工作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>未摘抄书中展示的简短的 WPF 程序示例。</p></blockquote><h2 id="一个完整的-GUI-示例"><a href="#一个完整的-GUI-示例" class="headerlink" title="一个完整的 GUI 示例"></a>一个完整的 GUI 示例</h2><p>以下为一个完整的 WPF GUI 程序，包含一个状态条和取消操作。</p><p>下图左侧为示例程序的截图。点击按钮，程序将开始处理并更新进度条。处理过程完成将显示右上角的消息框。如果在处理完成前点击 Cancel 按钮，程序将显示右下角的消息框。</p><div  align="center">  <img src="https://s2.loli.net/2023/04/15/87YA3bfkg5QytC4.png" width = "60%" height = "60%" alt="图100 - 实现了状态条和取消操作的简单WPF程序的截图"/></div><p>我们首先创建一个名为 WpfAwait 的 WPF 应用程序。按如下的代码修改 MainWindow.xaml 中的 XAML 标记：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Window x:Class=&quot;WpfAwait.MainWindow&quot;</span><br><span class="line">        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        Title=&quot;Process and Cancel&quot; Height=&quot;150 &quot; Width=&quot;250&quot;&gt;</span><br><span class="line">    &lt;StackPanel&gt;</span><br><span class="line">        &lt;Button Name=&quot;btnProcess&quot; Width=&quot;100&quot; Click=&quot;btnProcess_Click&quot;</span><br><span class="line">            HorizontalAlignment=&quot;Right&quot; Margin=&quot;10,15,10,10&quot;&gt;Process&lt;/Button&gt;</span><br><span class="line">        &lt;Button Name=&quot;btnCancel&quot; Width=&quot;100&quot; Click=&quot;btnCancel_Click&quot;</span><br><span class="line">            HorizontalAlignment=&quot;Right&quot; Margin=&quot;10,0&quot;&gt;Cancel&lt;/Button&gt;</span><br><span class="line">        &lt;ProgressBar Name=&quot;progressBar&quot; Height=&quot;20&quot; Width=&quot;200&quot; Margin=&quot;10&quot;</span><br><span class="line">            HorizontalAlignment=&quot;Right&quot;/&gt;</span><br><span class="line">    &lt;/StackPanel&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><p>按如下的代码修改后台代码文件 MainWindow.xaml.cs ：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Windows;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WpfAwait</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        CancellationTokenSource cancellationTokenSource;</span><br><span class="line">        CancellationToken cancellationToken;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">        &#123; InitializeComponent(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">btnProcess_Click</span>(<span class="params"> <span class="built_in">object</span> sender, RoutedEventArgs e </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        btnProcess.IsEnabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        cancellationTokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        cancellationToken = cancellationTokenSource.Token;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> completedPercent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( cancellationToken.IsCancellationRequested )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> Task.Delay( <span class="number">500</span>, cancellationToken );</span><br><span class="line">                completedPercent = ( i + <span class="number">1</span> ) * <span class="number">10</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">catch</span> ( TaskCanceledException ex )</span><br><span class="line">            &#123; completedPercent = i * <span class="number">10</span>; &#125;</span><br><span class="line">            progressBar.Value = completedPercent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> message = cancellationToken.IsCancellationRequested</span><br><span class="line">                ? <span class="built_in">string</span>.Format( <span class="string">$&quot;Process was cancelled at <span class="subst">&#123; completedPercent &#125;</span>%.&quot;</span> )</span><br><span class="line">                : <span class="string">&quot;Process completed normally.&quot;</span>;</span><br><span class="line">        MessageBox.Show( message, <span class="string">&quot;Completion Status&quot;</span> );</span><br><span class="line"></span><br><span class="line">        progressBar.Value = <span class="number">0</span>;</span><br><span class="line">        btnProcess.IsEnabled = <span class="literal">true</span>;</span><br><span class="line">        btnCancel.IsEnabled = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnCancel_Click</span>(<span class="params"> <span class="built_in">object</span> sender, RoutedEventArgs e </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !btnProcess.IsEnabled )</span><br><span class="line">            &#123;</span><br><span class="line">                btnCancel.IsEnabled = <span class="literal">false</span>;</span><br><span class="line">                cancellationTokenSource.Cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BackgroundWorker-类"><a href="#BackgroundWorker-类" class="headerlink" title="BackgroundWorker 类"></a>BackgroundWorker 类</h2><p>前面几节介绍了如何使用 async/await 特性来异步地处理任务。本节将学习另一种实现异步工作的方式，即<strong>后台线程</strong>。async/await 特性更适合那些需要在后台完成的不相关的小任务。</p><p>但有时候可能需要另建一个线程，在后台持续运行以完成某项工作，并不时地与主线程进行通信。 BackgroundWorker 类就是为此而生的。下图展示了此类的主要成员：</p><div  align="center">  <img src="https://s2.loli.net/2023/04/15/OjNhbVsfpX5SZo1.png" width = "70%" height = "70%" alt="图101 - BackgroundWorker 类的主要成员"/></div><p>①图中的前两个属性用于设置后台任务是否可以把它的进度汇报给主线程以及是否支持从主线程取消。可以用第三个属性来检査后台任务是否正在运行；<br>②类有三个事件，用于发送不同的程序事件和状态。需要写这些事件的事件处理方法来执行适合程序的行为：<br>&emsp;&emsp;- 在后台线程开始的时候触发 DoWork ；<br>&emsp;&emsp;- 在后台任务汇报状态的时候触发 ProgressChanged 事件；<br>&emsp;&emsp;- 后台工作线程退出的时候触发 RunWorkerCompleted 事件；<br>③三个方法用于初始化行为或改变状态：<br>&emsp;&emsp;- 调用 RunWorkerAsync 方法获取后台线程并且执行 DoWork 事件处理程序；<br>&emsp;&emsp;- 调用 CancelAsync 方法把 CancellationPending 属性设置为 true 。DoWork 事件处理程序需要检查这个属性来决定是否应该停止处理；<br>&emsp;&emsp;- DoWork 事件处理程序（在后台线程）在希望向主线程汇报进度的时候，调用 ReportProgress 方法；  </p><div  align="center">  <img src="https://s2.loli.net/2023/07/03/epraFydsWv5m9Ow.png" width = "80%" height = "80%" alt="图102 - 控制任务执行流程的事件处理程序"/></div><p>如上图，要使用 BackgroundWorker 类对象，需要写如上图所示的事件处理程序。第一个事件是必需的，因为它包含你希望在后台线程执行的代码，另外两个是可选的，是否使用取决于程序需要：<br>①附加到 DoWork 事件的处理程序包含你希望在后台独立线程上执行的代码：<br>&emsp;&emsp;- DoTheWork 的处理程序用渐变的方块表示，表明它在后台线程中执行；<br>&emsp;&emsp;- 主线程调用 RunWorkerAsync 方法的时候触发 DoWork 事件；<br>②这个后台线程通过调用 ReportProgress 方法与主线程通信。届时将触发 ProgressChanged 事件，主线程可以用附加到 ProgressChanged 事件上的处理程序处理事件；<br>③附加到 RunWorkerCompleted 事件的处理程序应该包含后台线程完成 DoWork 事件处理程序的执行之后需要执行的代码。  </p><p>这些事件处理程序的委托如下，每一个任务都接受一个 object 对象的引用作为第一个参数，以及 EventArgs 类的特定子类作为第二个参数：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoWorkEventHandler</span> (<span class="params"> <span class="built_in">object</span> sender, DoWorkEventArgs e </span>)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProgressChangedEventHandler</span> (<span class="params"> <span class="built_in">object</span> sender, ProgressChangedEventArgs e </span>)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunWorkerCompletedEventHandler</span> (<span class="params"> <span class="built_in">object</span> sender, RunWorkerCompletedEventArgs e</span>)</span></span><br></pre></td></tr></table></figure><p>下图演示了这些事件处理程序的 EventArgs 类的结构：</p><div  align="center">  <img src="https://s2.loli.net/2023/07/03/vjdTMipSPUBcCLZ.png" width = "80%" height = "80%" alt="图103 - BackgroundWorker事件处理程序使用的EventArgs类"/></div><p>如果你编写了这些事件处理程序并将其附加到相应的事件，就可以这样使用这个类：<br>①从创建 BackgroundWorker 类的对象并且对它进行配置开始：<br>&emsp;&emsp;- 如果希望工作线程为主线程汇报进度，需要把 WorkerReportsProgress 属性设置为true；<br>&emsp;&emsp;- 如果希望从主线程取消工作线程，就把 WorkerSupportsCancellation 属性设置为true；<br>&emsp;&emsp;- 如果已经启用了 WorkerSupportsCancellation 属性，就可以调用对象的 CancelAsync 方法。该方法也不会取消后台线程，而是将对象的 CancellationPending 属性设置为 true 。运行在后台线程中的 DoWork 事件处理程序代码需要定期检査 CancellationPending 属性，来判断是否需要退出；<br>②既然对象已经配置好了，我们就可以通过调用 RunWorkerAsync 方法来启动它。它会开一个后台线程并且发起 DoWork 事件并在后台执行事件处理程序。</p><p>同时，后台线程继续执行其计算任务，并且做以下几件事情：<br>①如果 WorkerReportsProgress 属性是 true 并且后台线程需要为主线程汇报进度的话，它必须调用 BackgroundWorker 对象的 ReportProgress 方法。这会触发主线程的 ProgressChanged 事件，从而运行相应的事件处理程序；<br>②如果 WorkerSupportsCancellation 属性启用的话，DoWork 事件处理程序代码应该定期检测 CancellationPending 属性来确定是否已经取消了；<br>③如果后台线程没有取消，而是完成了其进程的话，可以通过设置 DoWorkEventArgs 参数的 Result 字段来返回结果给主线程；<br>④在后台线程退出的时候会触发 RunWorkerCompleted 事件，其事件处理程序在主线程上执行。RunWorkerCompletedEventArgs 参数可以包含已完成后台线程的一些信息，比如返回值以及线程是否被取消了。</p><h3 id="在-WPF-程序中使用-BackgroundWorker-类的示例代码"><a href="#在-WPF-程序中使用-BackgroundWorker-类的示例代码" class="headerlink" title="在 WPF 程序中使用 BackgroundWorker 类的示例代码"></a>在 WPF 程序中使用 BackgroundWorker 类的示例代码</h3><p>BackgroundWorker 类主要用于 GUI 程序，下面的程序展示了一个简单的 WPF 程序。该程序会生成下图中左图所示的窗体。点击 Process 按钮将开启后台线程，每半秒向主线程报告一次，并使进度条增长10%。最终，将展示右图所示的对话框。要创建这个 WPF 程序，需要在 Visual Studio 中创建名为 SimpleWorker 的 WPF 应用程序。将 MainWindow.xaml 文件中的代码修改为：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Window</span> <span class="attr">x:Class</span>=<span class="string">&quot;SimpleWorker.MainMindow&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:x</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Title</span>=<span class="string">&quot;MainWindow&quot;</span> <span class="attr">Height</span>=<span class="string">&quot;l50&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;250&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">StackPanel</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ProgressBar</span> <span class="attr">Name</span>=<span class="string">&quot;progressBar&quot;</span> <span class="attr">Height</span>=<span class="string">&quot;20&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Name</span>=<span class="string">&quot;btnProcess&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;l00&quot;</span> <span class="attr">Click</span>=<span class="string">&quot;btnProcess_Click&quot;</span>  <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>&gt;</span>Process<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Name</span>=<span class="string">&quot;btnCancel&quot;</span> <span class="attr">Width</span>=<span class="string">&quot;l00&quot;</span> <span class="attr">Click</span>=<span class="string">&quot;btnCancel_Click&quot;</span> <span class="attr">Margin</span>=<span class="string">&quot;5&quot;</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Window</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将 MainWindow.xaml.cs 文件中的代码修改为：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Windows;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleWorker</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        BackgroundWorker bgWorker = <span class="keyword">new</span> BackgroundWorker();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置BackgroundWorker属性</span></span><br><span class="line">            bgWorker.WorkerReportsProgress = <span class="literal">true</span>;</span><br><span class="line">            bgWorker.WorkerSupportsCancellation = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//连接BackgroundWorker对象的处理程序</span></span><br><span class="line">            bgWorker.DoWork +=  DoWork_Handler;</span><br><span class="line">            bgWorker.ProgressChanged += ProgressChanged_Handler;</span><br><span class="line">            bgWorker.RunWorkerCompleted += RunWorkerCompleted_Handler;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnProcess_Click</span>(<span class="params"> <span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !bgWorker.IsBusy )</span><br><span class="line">                bgWorker.RunWorkerAsync();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ProgressChanged_Handler</span>(<span class="params"> <span class="built_in">object</span> sender,ProgressChangedEventArgs args </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            progressBar.Value = args.ProgressPercentage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoWork_Handler</span>(<span class="params"> <span class="built_in">object</span> sender, DoWorkEventArgs args </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            BackgroundWorker worker = sender <span class="keyword">as</span> BackgroundWorker;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( worker.CancellationPending )</span><br><span class="line">                &#123;</span><br><span class="line">                    args.Cancel = <span class="literal">true</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    worker.ReportProgress( i * <span class="number">10</span> );</span><br><span class="line">                    Thread.Sleep( <span class="number">500</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RunWorkerCompleted_Handler</span>(<span class="params"> <span class="built_in">object</span> sender,RunWorkerCompletedEventArgs args </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            progressBar.Value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( args.Cancelled )</span><br><span class="line">                MessageBox.Show( <span class="string">&quot;Process was cancelled.&quot;</span>, <span class="string">&quot;Process Cancelled&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                MessageBox.Show( <span class="string">&quot;Process completed normally.&quot;</span>, <span class="string">&quot;Process Completed&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnCancel_Click</span>(<span class="params"> <span class="built_in">object</span> sender, RoutedEventArgs e </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            bgWorker.CancelAsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并行循环"><a href="#并行循环" class="headerlink" title="并行循环"></a>并行循环</h2><p>本节将简要介绍任务并行库（ Task Parellel Library )。它是 BCL 中的一个类库，极大地简化了并行编程。其细节比本章要介绍的多得多，这里只介绍其中的两个简单的结构：<strong>Parallel.For</strong> 循环和 <strong>Parallel.ForEach</strong> 循环。这两个结构位于 System.Threading.Tasks 命名空间中。</p><p>标准的 for 和 foreach 循环结构，每次迭代都依赖于上次迭代。如果迭代之间彼此独立，并且程序运行在多核处理器的机器上，若能将不同的迭代放在不同的处理器上并行处理的话，可以节省不少时间。Parallel.For 循环和 Parallel.ForEach 循环结构可以这么做。</p><p>这两个结构的形式是包含输入参数的方法。Parallel.For 方法有12个重载，最简单的签名如下：<code>void Parallel.For( int fromInclusive, int toExclusive, Action&lt;int&gt; body );</code><br>①fromInclusive 参数是迭代系列的第一个整数；<br>②toExclusive 参数是比迭代系列最后一个索引号大1的整数。也就是说，和表达式 index&lt;ToExclusive&gt; 一样；<br>③body 是接受单个输入参数的委托，body 的代码在每一次迭代中执行一次。</p><p>如下代码：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks; <span class="comment">//必须使用该命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ExampleParallelFor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Parallel.For( <span class="number">0</span>, <span class="number">15</span>, i =&gt;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;The square of <span class="subst">&#123; i &#125;</span> is <span class="subst">&#123; i * i &#125;</span>&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，注意，不能确保迭代的执行次序：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">The square of 2 is 4</span><br><span class="line">The square of 0 is 0</span><br><span class="line">The square of 9 is 81</span><br><span class="line">The square of 10 is 100</span><br><span class="line">The square of 11 is 121</span><br><span class="line">The square of 12 is 144</span><br><span class="line">The square of 13 is 169</span><br><span class="line">The square of 14 is 196</span><br><span class="line">The square of 8 is 64</span><br><span class="line">The square of 1 is 1</span><br><span class="line">The square of 3 is 9</span><br><span class="line">The square of 4 is 16</span><br><span class="line">The square of 5 is 25</span><br><span class="line">The square of 7 is 49</span><br><span class="line">The square of 6 is 36</span><br></pre></td></tr></table></figure><p>另一个示例如下，以并行方式填充一个整数数组，把值设置为迭代索引号的平方。在本例中，即使迭代在执行时可能为并行并且为任意顺序，但是最后结果始终是一个包含前50个平方数的数组，并且按顺序排列：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">int</span> maxValues=<span class="number">50</span>;</span><br><span class="line">        <span class="built_in">int</span>[] squares = <span class="keyword">new</span> <span class="built_in">int</span>[maxValues];</span><br><span class="line"></span><br><span class="line">        Parallel.For( <span class="number">0</span>, maxValues, i =&gt; squares[i]=i*i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个并行循环结构是 Parallel.ForEach 方法。该方法有相当多的重载，其中最简单的如下：<code>static ParallelLoopResult ForEach&lt;TSource&gt;( IEnumerable&lt;TSource&gt; source,Action&lt;TSource&gt; body)</code><br>①TSource 是集合中对象的类型；<br>②source 是一组 TSource 对象的集合；<br>③body 是要应用到集合中每一个元素的 Lambda 表达式。</p><p>代码示例如下，TSource 是 string ，source 是 string[ ] ：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ParallelForeach1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[] squares=<span class="keyword">new</span> <span class="built_in">string</span>[] </span><br><span class="line">                    &#123;<span class="string">&quot;We&quot;</span>, <span class="string">&quot;hold&quot;</span>, <span class="string">&quot;these&quot;</span>, <span class="string">&quot;truths&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;be&quot;</span>, <span class="string">&quot;self-evident&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;that&quot;</span>, <span class="string">&quot;all&quot;</span>, <span class="string">&quot;men&quot;</span>, <span class="string">&quot;are&quot;</span>, <span class="string">&quot;created&quot;</span>, <span class="string">&quot;equal&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">            Parallel.ForEach(squares,</span><br><span class="line">                s =&gt; Console.WriteLine</span><br><span class="line">                        ( <span class="built_in">string</span>.Format(<span class="string">$&quot;\&quot;<span class="subst">&#123; s &#125;</span>\&quot; has <span class="subst">&#123; s.Length &#125;</span> letters&quot;</span>) ));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他异步编程模式"><a href="#其他异步编程模式" class="headerlink" title="其他异步编程模式"></a>其他异步编程模式</h2><p>除了上面介绍的 async/await 特性和 BackgroundWorker 类，或者任务并行库。还可以使用旧模式来产生异步代码。</p><p>当委托对象调用时，它调用了其调用列表中包含的方法。就像程序调用方法一样，这是同步完成的。如果委托对象在调用列表中只有一个方法（之后会叫做<strong>引用方法 referenced method</strong>），它就可以异步执行这个方法。委托类有两个方法，叫做 <strong>BeginInvoke</strong> 和 <strong>EndInvoke</strong> ，它们就是用来实现这个目的的。这两个方法以如下方式使用：<br>①调用委托的 BeginInvoke 方法时，它开始在一个独立线程上执行引用方法，并且立即返回到原始线程。原始线程可以继续，而引用方法会在线程池的线程中并行执行；<br>②当程序希望获取已完成的异步方法的结果时，可以检查 BeginInvoke 返回的 IAsyncResult 的 IsCompleted 属性，或调用委托的 EndInvoke 方法来等待委托完成。</p><div  align="center">  <img src="https://s2.loli.net/2023/07/03/cTU3vd4wHlOWGSj.png" width = "80%" height = "80%" alt="图104 - 异步方法调用的标准模式"/></div><p>上图展示了使用上述过程的三种标准模式，这些模式的区别在于原始线程如何知道发起的线程已经完成：<br>①在<strong>等待直到完成 wait-until-done</strong> 模式中，在发起了异步方法以及做了一些其他处理之后，原始线程就中断并且等异步方法完成之后再继续；<br>②在<strong>轮询 polling</strong> 模式中，原始线程定期检查发起的线程是否完成，如果没有则可以继续做一些其他的事情；<br>③在<strong>回调 callback</strong> 模式中，原始线程一直执行，无需等待或检査发起的线程是否完成。在发起的线程中的引用方法完成之后，发起的线程就会调用回调方法，由回调方法在调用 EndInvoke 之前处理异步方法的结果。</p><h2 id="BeginInvoke-和-EndInvoke"><a href="#BeginInvoke-和-EndInvoke" class="headerlink" title="BeginInvoke 和 EndInvoke"></a>BeginInvoke 和 EndInvoke</h2><p>有关 BeginInvoke 的重要事项如下：<br>①在调用 BeginInvoke 时，参数列表中的实际参数组成如下：<br>&emsp;&emsp;- 引用方法需要的参数；<br>&emsp;&emsp;- 两个额外的参数 —— callback 参数和 state 参数；<br>②BeginInvoke 从线程池中获取一个线程并且让引用方法在新的线程中开始运行；<br>③BeginInvoke 返回给调用线程一个实现 IAsyncResult 接口的对象的引用。这个接口引用包含了在线程池线程中运行的异步方法的当前状态，原始线程然后可以继续执行。</p><p>如下代码所示，它从线程池中获取一个线程并且在新的线程上开始运行 Sum 方法，将3和5作为实参；它收集新线程的状态信息并且把 IAsyncResult 接口的引用返回给调用线程来提供这些信息。调用线程把它保存在一个叫做iar的变量中：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">long</span> <span class="title">MyDel</span>(<span class="params"> <span class="built_in">int</span> first, <span class="built_in">int</span> second </span>)</span>; <span class="comment">//委托声明</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">long</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>&#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">//方法匹配委托</span></span><br><span class="line">...</span><br><span class="line">MyDel del = <span class="keyword">new</span> MyDel(Sum); <span class="comment">//创建委托对象</span></span><br><span class="line">IAsyncResult iar = del.BeginInvoke( <span class="number">3</span>, <span class="number">5</span>, <span class="literal">null</span>, <span class="literal">null</span> ); <span class="comment">//调用了委托对象的BeginInvoke方法并且提供了两个委托参数3和5，以及两个BeginInvoke的参数callback和state，在本例中都设为null</span></span><br></pre></td></tr></table></figure><p>EndInvoke 方法用来获取由异步方法调用返回的值，并且释放线程使用的资源。EndInvoke 有如下的特性：<br>①它接受一个由 BeginInvoke 方法返回的 IAsyncResult 对象的引用作为参数，并找到它关联的线程；<br>②如果线程池的线程已经退出，则 EndInvoke 做如下的事情：<br>&emsp;&emsp;- 清理退出线程的状态并释放资源；<br>&emsp;&emsp;- 找到引用方法返回的值并且把它作为返回值返回。<br>③如果当 EndInvoke 被调用时线程池的线程仍然在运行，调用线程就会停止并等待它完成，然后再清理并返回值。因为 EndInvoke 是为开启的线程进行清理，所以必须确保对每一个 BeginInvoke 都调用EndInvoke ；<br>④如果异步方法触发了异常，在调用 EndInvoke 时会抛出异常。</p><p>如下的代码行给出了一个调用 EndInvoke 并从异步方法获取值的示例。我们必须把 IAsyncResult 对象的引用作为参数：<code>long result = del.EndInvoke( iar );</code></p><p>EndInvoke 提供了从异步方法调用的所有输出，包括 ref 和 out 参数。如果委托的引用方法有 ref 或 out 参数，它们必须包含在 EndInvoke 的参数列表中，并且在 IAsyncResult 对象引用之前，如下所示：<code>long result = del.EndInvoke(out someInt, iar);</code></p><h3 id="等待直到完成模式"><a href="#等待直到完成模式" class="headerlink" title="等待直到完成模式"></a>等待直到完成模式</h3><p>如下是一个使用该模式的示例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;  <span class="comment">//For Thread.Sleep()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">long</span> <span class="title">MyDel</span>(<span class="params"> <span class="built_in">int</span> first, <span class="built_in">int</span> second </span>)</span>;   <span class="comment">//声明委托类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">long</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>) <span class="comment">//声明异步方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console. WriteLine(<span class="string">&quot;                Inside Sum&quot;</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDel del = <span class="keyword">new</span> MyDel(Sum);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Before BeginInvoke&quot;</span>);</span><br><span class="line">        IAsyncResult iar = del.BeginInvoke(<span class="number">3</span>, <span class="number">5</span>, <span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">//开抬异步调用</span></span><br><span class="line">        Console.WriteLine( <span class="string">&quot;After BeginInvoke&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Doing stuff&quot;</span> ); </span><br><span class="line"></span><br><span class="line">        <span class="built_in">long</span> result = del.EndInvoke( iar ); <span class="comment">//等待结果并获取结果</span></span><br><span class="line">        Console.WriteLine( <span class="string">&quot;After EndInvoke: &#123;0&#125;&quot;</span>, result );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Before BeginInvoke</span><br><span class="line">After BeginInvoke</span><br><span class="line">Doing stuff</span><br><span class="line">                Inside Sum</span><br><span class="line">After EndInvoke: 8</span><br></pre></td></tr></table></figure><blockquote><p>.NET Core 不支持 BeginInvoke 和 EndInvoke ，需要使用 .NET Framework</p></blockquote><h3 id="AsyncResult-类"><a href="#AsyncResult-类" class="headerlink" title="AsyncResult 类"></a>AsyncResult 类</h3><p>BeginInvoke 返回一个 IASyncResult 接口的引用（该接口由一个 AsyncResult 类型的类实现）。AsyncResult 类代表了异步方法的状态。下图演示了该类中的一些重要部分：</p><div  align="center">  <img src="https://s2.loli.net/2023/07/03/f5eAkrGPEM7ZFI1.png" width = "60%" height = "60%" alt="图105 - AsyncResult 类对象"/></div><p>有关该类的重要事项如下：<br>①当调用委托对象的 BeginInvoke 方法时，系统创建了一个 AsyncResult 类的对象。然而，它不返回类对象的引用，而是返回对象中包含的 IAsyncResult 接口的引用；<br>②AsyncResult 对象包含一个叫做 AsyncDelegate 的属性，它返回一个指向被调用来启动异步方法的委托的引用。但是，这个属性是类对象的一部分而不是接口的一部分；<br>③IsCompleted 属性返回一个布尔值，表示异步方法是否完成；<br>④AsyncState 属性返回对象的一个引用，作为 BeginInvoke 方法调用时的 state 参数。它返回 object 类型的引用，在回调模式一节中解释这部分内容。</p><h3 id="轮询模式"><a href="#轮询模式" class="headerlink" title="轮询模式"></a>轮询模式</h3><p>在轮询模式中，原始线程发起了异步方法的调用，做一些其他处理，然后使用 IAsyncResult 对象的 IsComplete 属性来定期检査开启的线程是否完成。如果异步方法已经完成，原始线程就调用 EndInvoke 并继续。否则，它做一些其他处理，然后过一会儿再检査。在下面的示例中，“处理” 仅仅是由0数到10 000 000：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">long</span> <span class="title">MyDel</span>(<span class="params"><span class="built_in">int</span> first, <span class="built_in">int</span> second</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">long</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;               Inside Sum&quot;</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDel del = <span class="keyword">new</span> MyDel(Sum);</span><br><span class="line">        </span><br><span class="line">        IAsyncResult iar = del.BeginInvoke(<span class="number">3</span>, <span class="number">5</span>, <span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">//开始异步调用</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;After BeginInvoke&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ( !iar.IsCompleted ) <span class="comment">//检查异步方法是否完成</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Not Done&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//继续处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">                ; <span class="comment">//空语句</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">long</span> result = del.EndInvoke(iar); <span class="comment">//调用EndInvoke来获取接口并进行清理</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Result: &#123;0&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">After BeginInvoke</span><br><span class="line">Not Done</span><br><span class="line">               Inside Sum</span><br><span class="line">Not Done</span><br><span class="line">Not Done</span><br><span class="line">Done</span><br><span class="line">Result: 8</span><br></pre></td></tr></table></figure><h3 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h3><p>在之前的等待直到完成 wait-until-done 模式以及轮询 polling 模式中，初始线程仅在知道开启的线程已经完成之后才继续它的控制流程。然后，它获取结果并继续。</p><p>回调 callback 模式的不同之处在于，一旦初始线程发起了异步方法，它就自己管自己了，不再考虑同步。当异步方法调用结束之后，系统调用一个用户自定义的方法来处理结果，并且调用委托的 EndInvoke 方法。这个用户自定义的方法叫做<strong>回调方法 callback method</strong> 或回调。</p><p>BeginInvoke 参数列表中最后的两个额外参数由回调方法使用：<br>①第一个参数 callback 是回调方法的名字；<br>②第二个参数 state 可以是 null 或要传入回调方法的一个对象的引用。可以通过使用 IAsyncResult 参数的 AsyncState 属性来获取这个对象，参数的类型是 object 。</p><p><strong><em>1.回调方法</em></strong><br>回调方法的签名和返回类型必须和 AsyncCallback 委托类型所描述的形式一致。这需要方法接受一个 IAsyncResult 类型的参数并且返回类型是 void ，如下所示：<code>void AsyncCallback( IAsyncResult iar )</code></p><p>有多种方式可以为 BeginInvoke 方法提供回调方法。由于 BeginInvoke 中的 callback 参数是 AsyncCallback 类型的委托，可以以委托形式提供；或者也可以只提供回调方法名称，让编译器创建委托，两种形式是完全等价的：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">IAsyncResult iar1 = del.BeginInvoke(<span class="number">3</span>, <span class="number">5</span>, <span class="keyword">new</span> AsyncCallback(CallWhenDone), <span class="literal">null</span>); <span class="comment">//使用回调方法创建委托</span></span><br><span class="line"></span><br><span class="line">IAsyncResult iar2 = del.BeginInvoke(<span class="number">3</span>, <span class="number">5</span>, CallWhenDone, <span class="literal">null</span>); <span class="comment">//只需要用回调方法的名字</span></span><br></pre></td></tr></table></figure><p>BeginInvoke 的另一个额外参数用来向回调方法发送对象。它可以是任何类型的对象，因为参数类型是 object ，所以在回调方法中，必须将其转换成正确的类型。</p><p><strong><em>2.在回调方法内调用 EndInvoke</em></strong><br>在回调方法内，代码应该调用委托的 EndInvoke 方法来处理异步方法执行后的输出值。要调用委托的 EndInvoke 方法，肯定需要委托对象的引用，而它在初始线程中，不在开启的线程中。</p><p>如果不将 BeginInvoke 的 state 参数作其他目的，可以使用它给回调方法发生委托的引用，如下所示：<code>IAsyncResult iar = del.BeginInvoke(3, 5, CallWhenDone, del); //把委托对象作为状态参数发送</code>。否则，可以从作为参数发送给方法的 IAsyncResult 对象中提取出委托的引用，如下代码和图所示：</p><div  align="center">  <img src="https://s2.loli.net/2023/07/04/AawS7OGcDJs4l8L.png" width = "70%" height = "70%" alt="图106 - 从回调方法内部提取出委托的引用"/></div><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.Remoting.Messaging;  <span class="comment">//包含AsyncResult类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallWhenDone</span>(<span class="params"> IAsyncResult iar </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AsyncResult ar = (AsyncResult) iar; <span class="comment">//获取类对象的引用</span></span><br><span class="line">    MyDel del = (MyDel) ar.AsyncDelegate; <span class="comment">//获取委托的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">long</span> Sum = del.EndInvoke( iar );      <span class="comment">//调用 EndInvoke</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的说明：<br>①给回调方法的参数只有一个，就是刚结束的异步方法的 IAsyncResult 接口的引用。请记住，IAsyncResult 接口对象在 AsyncResult 类对象内部；<br>②尽管 IAsyncResult 接口没有委托对象的引用，封装它的 AsyncResult 类对象却有委托对象的引用。所以，示例代码方法体的第一行就通过转换接口引用为类类型来获取类对象的引用。变量 ar 现在就有类对象的引用；<br>③有了类对象的引用，就可以使用类对象的 AsyncDelegate 属性并且把它转化为合适的委托类型。这样就得到了委托引用，我们可以用它来调用 EndInvoke 。</p><p>把上面知识点汇总的使用回调模式的示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Remoting.Messaging; <span class="comment">//调用AsyncResult类型</span></span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">long</span> <span class="title">MyDel</span>(<span class="params"><span class="built_in">int</span> first, <span class="built_in">int</span> second</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">long</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;              Inside Sum&quot;</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallWhenDone</span>(<span class="params">IAsyncResult iar</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;              Inside CallWhenDone.&quot;</span>);</span><br><span class="line">        AsyncResult ar = (AsyncResult) iar;</span><br><span class="line">        MyDel del = (MyDel)ar.AsyncDelegate;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">long</span> result = del.EndInvoke(iar);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;              The result is: &#123;0&#125;.&quot;</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDel del = <span class="keyword">new</span> MyDel(Sum);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Before BeginInvoke&quot;</span>);</span><br><span class="line">        IAsyncResult iar =</span><br><span class="line">            del.BeginInvoke(<span class="number">3</span>, <span class="number">5</span>, <span class="keyword">new</span> AsyncCallback(CallWhenDone), <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Doing more work in Main.&quot;</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Done with Main. Exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Before BeginInvoke</span><br><span class="line">Doing more work in Main.</span><br><span class="line">              Inside Sum</span><br><span class="line">              Inside CallWhenDone.</span><br><span class="line">              The result is: 8.</span><br><span class="line">Done with Main. Exiting.</span><br></pre></td></tr></table></figure><h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><p>计时器提供了另外一种定期地重复运行异步方法的方式。尽管在 .NET BCL 中有好几个可用的 Timer 类，但在这里只会介绍 System.Threading 命名空间中的那个。</p><p>有关计时器类需要了解的重要事项如下：<br>①计时器在每次到期之后调用回调方法。回调方法必须是 TimerCallback 委托形式的，结构为<code>void TimerCallback( object state )</code>。它接受一个 object 类型作为参数，并且返回类型是 void ；<br>②当计时器到期之后，系统会从线程池中的一个线程上设置回调方法，提供 state 对象作为其参数，并且开始运行；<br>③可以设置的计时器的一些特性如下：<br>&emsp;&emsp;- dueTime 是回调方法首次被调用之前的时间。如果 dueTime 被设为特殊的值 Timeout.Infinite ，则计时器不会开始。如果被设置为0，则回调函数会被立即调用；<br>&emsp;&emsp;- period 是两次成功调用回调函数之间的时间间隔。如果它的值设置为 Timeout.Infinite ，则回调在首次被调用之后不会再被调用；<br>&emsp;&emsp;- state 可以是 null 或在每次回调方法执行时要传入的对象的引用。</p><p>Timer 类的构造函数接受回调方法名称、dueTime 、period 以及 state 作为参数。Timer 有很多构造函数，最为常用的形式为：<code>Timer( TimerCallback callback, object state, uint dueTime, uint period )</code></p><p>一旦 Timer 对象被创建，可以使用 Change 方法来改变它的 dueTime 或 period 方法。示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Timers</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> TimesCalled = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Display</span>(<span class="params"><span class="built_in">object</span> state</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, (<span class="built_in">string</span>)state, ++TimesCalled);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Program p = <span class="keyword">new</span> Program();</span><br><span class="line"></span><br><span class="line">            Timer myTimer = <span class="keyword">new</span> Timer     <span class="comment">//2s后第一次调用，每1s重复一次</span></span><br><span class="line">                (p.Display, <span class="string">&quot;Processing timer event&quot;</span>, <span class="number">2000</span>, <span class="number">1000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Timer started.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Timer started.</span><br><span class="line">Processing timer event 1</span><br><span class="line">Processing timer event 2</span><br><span class="line">Processing timer event 3</span><br><span class="line">Processing timer event 4</span><br><span class="line">Processing timer event 5</span><br></pre></td></tr></table></figure><h1 id="第二十二章-命名空间和程序集"><a href="#第二十二章-命名空间和程序集" class="headerlink" title="第二十二章 命名空间和程序集"></a>第二十二章 命名空间和程序集</h1><h2 id="引用其他程序集"><a href="#引用其他程序集" class="headerlink" title="引用其他程序集"></a>引用其他程序集</h2><p>之前讲过，编译器接受源代码文件并生成一个名为<strong>程序集 assembly</strong> 的输出文件。这一章将详细阐述程序集以及它们是如何生成和部署的，还会看到命名空间是如何帮助组织类型的。</p><p>在项目中，可能会使用来自其他程序集的类或类型。这些程序集可能来自 BCL 或第三方供应商，或是自己创建的（编译器可以把 .cs 编译为 .dll）。这些程序集称为<strong>类库 class libraries</strong> ，而且它们的程序集文件的名称通常以 <strong>.dll 扩展名</strong>而不是 .exe 扩展名结尾。</p><p>如果要使用定义在其他程序集中的类，需要给编译器一个到该程序集的引用，给出它的名称和位置。在 Visual Studio 中，可以用下面的方法把引用添加到项目：<br>①选择 Solution Explorer ，并在该项目名下找到 References 目录。References 目录包含项目使用的程序集的列表；<br>②右键单击 References 目录并选择 Add Reference 。有5个标签页，可以以不同的方法找到类库；<br>③可以选择 Browse 标签，选择需要的 DLL 文件，点击 OK 按钮，引用就被加入到项目了。</p><h3 id="mscorlib-库"><a href="#mscorlib-库" class="headerlink" title="mscorlib 库"></a>mscorlib 库</h3><p>Console 类被定义在名称为 mscorlib 的程序集中的 mscorlib.dll 的文件里。然而，你不会看到这个程序集被列在 References 目录中。程序集 mscorlib.dll 含有 C# 类型以及大部分 .NET 语言的基本类型的定义。在编译 C# 程序时，它必须总是被引用，所以 Visual Studio 不把它显示在 References 目录中。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>如果使用了多个不同的程序集，可能会遇到类名重复的问题，从而导致类名冲突。这就带来了命名空间名和<strong>命名空间 namespaces</strong> 的定义：<br>①可以把命名空间名视为一个字符串（在字符串中可以使用点），它加在类名或类型名的前面并且通过点进行分隔；<br>②包括命名空间名、分隔点，以及类名的完整字符串叫做类的<strong>完全限定名 fully qualified name</strong>；<br>③命名空间是共享命名空间名的一组类和类型。</p><div  align="center">  <img src="https://s2.loli.net/2023/07/04/kYGBqH6dn8lcDos.png" width = "75%" height = "75%" alt="图107 - 命名空间是共享同一命名空间名的一组类型定义"/></div><p>可以通过在包含类型声明的源文件中声明命名空间来创建命名空间。如下代码演示了声明命名空间的语法，然后在命名空间声明的大括号中声明你的所有类和其他类型，那么这些类型就是这个命名空间的成员了：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">NamespaceName</span> <span class="comment">//关键字和命名空间名</span></span><br><span class="line">&#123;</span><br><span class="line">    TypeDeclarations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本章稍后会阐述 using 别名指令，以解决不得不在完全限定名称中重复输入的麻烦。</p><h3 id="命名空间名称"><a href="#命名空间名称" class="headerlink" title="命名空间名称"></a>命名空间名称</h3><p>命名空间名称的一些要点如下：<br>①命名空间名称可以是任何有效标识符，并且区分大小写；<br>②另外，<em>命名空间名称可以包括句点符号</em>，用于把类型组织成层次。</p><p>这里列出了一些在 .NET BCL 中的命名空间的名称：System ；System.Data ；System.Drawing ；System.IO ； Microsoft.CSharp ； Microsoft.VisualBasic 。</p><p>下面是命名空间命名指南：①以公司名称开头；②在公司名之后跟着技术名称；③不要与类或类型名相同。例如，Acme Widget 公司的软件开发部门在下面3个命名空间中开发软件，如下面的代码所示：AcmeWidgets.SuperWidget 、 AcmeWidgets.Media 、AcmeWidgets.Games</p><h3 id="命名空间补充"><a href="#命名空间补充" class="headerlink" title="命名空间补充"></a>命名空间补充</h3><p>关于命名空间的一些其他要点如下：<br>①在命名空间内，每个类型名必须有别于所有其他类型；<br>②命名空间内的类型称为命名空间的成员，不同命名空间内的类型可以重名；<br>③一个源文件可以包含任意数目的命名空间声明，可以顺序也可以嵌套。</p><p>.NET 框架 BCL 提供了数千个已定义的类和类型以供生成程序时选择。为了帮助组织这组有用的功能，相关功能的类型被声明在相同的命名空间里。BCL 使用超过100个命名空间来组织它的类型。</p><h3 id="命名空间跨文件伸展"><a href="#命名空间跨文件伸展" class="headerlink" title="命名空间跨文件伸展"></a>命名空间跨文件伸展</h3><p>命名空间不是封闭的。这意味着可以在该源文件的后面或另一个源文件中再次声明它，以对它增加更多的类型声明。可以将类在不同的源文件中声明在相同的命名空间中，而且多个该源文件可以被编译成单个程序集，当然也可以各自编译为独立的程序集。</p><h3 id="嵌套命名空间"><a href="#嵌套命名空间" class="headerlink" title="嵌套命名空间"></a>嵌套命名空间</h3><p>命名空间可以嵌套，从而产生嵌套的命名空间。嵌套命名空间允许你创建类型的概念层次。有两种方法声明一个嵌套的命名空间，如下所示：<br>①文本嵌套：可以把命名空间的声明放在一个封装的命名空间声明体内部，从而创建一个嵌套的命名空间。下图的左边阐明了这种方法。在这个示例中，命名空间 OtherNs 嵌套在命名空间 MyNamespace 中；<br>②分离的声明：也可以为嵌套命名空间创建单独的声明，但必须在声明中使用它的完全限定名称。下图的右边阐明了这种方法。注意在嵌套命名空间 OtherNs 的声明中，使用完全限定名 MyNamespace.OtherNs。</p><div  align="center">  <img src="https://s2.loli.net/2023/07/04/uFgZph2cGRW9zkY.png" width = "75%" height = "75%" alt="图108 - 声明嵌套命名空间的两种形式是等价的"/></div><p>虽然嵌套命名空间位于父命名空间内部，但是其成员并不是父命名空间的成员。一个常见的误解是，既然嵌套的命名空间位于父命名空间内部，其成员也是父命名空间的子集，这是不正确的，命名空间之间是相互独立的。</p><h2 id="using-指令"><a href="#using-指令" class="headerlink" title="using 指令"></a>using 指令</h2><p>完全限定名可能相当长，在代码中通篇使用它们十分繁琐。然而，有两个编译器指令，可以避免使用完全限定名：<strong>using 命名空间指令 the using namespace directive</strong>和 <strong>using 别名指令 the using alias directive</strong>。</p><p>关于 using 指令的两个要点如下：<br>①它们必须放在源文件的顶端，在任何类型声明之前；<br>②它们应用于当前源文件中的所有命名空间。</p><h3 id="using-命名空间指令"><a href="#using-命名空间指令" class="headerlink" title="using 命名空间指令"></a>using 命名空间指令</h3><p>using 命名空间指令通知编译器你将要使用来自某个指定命名空间的类型。然后你可以使用简单类名而不必完全限定。</p><p>当编译器遇到一个不在当前命名空间的名称时，它检査在 using 命名空间指令中给出的命名空间列表，并把该未知名称加到列表中的第一个命名空间后面。如果结果完全限定名匹配了这个程序集或引用程序集中的一个类，编译器将使用那个类。如果不匹配，那么它试验列表中下一个命名空间。</p><p>using 命名空间指令由关键字 using 跟着一个命名空间标识符组成：<code>using System;</code>。</p><p>WriteLine 方法，就是类 Console 的成员，在 System 命名空间中。如下代码所示：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;  <span class="comment">//using命名空间指令</span></span><br><span class="line">…</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;This is text 1&quot;</span>);  <span class="comment">//使用完全限定名</span></span><br><span class="line">COnsole.WriteLine(<span class="string">&quot;This is text 2&quot;</span>);  <span class="comment">//使用指令</span></span><br></pre></td></tr></table></figure><h3 id="using-别名指令"><a href="#using-别名指令" class="headerlink" title="using 别名指令"></a>using 别名指令</h3><p>using 别名指令允许起一个別名给命名空间或者命名空间内的一个类型。</p><p>例如，下面的代码展示了两个 using 别名指令的使用。第一个指令告诉编译器标识符 Syst 是命名空间 System 的别名。第二个指令表明标识符 SC 是类 System.Console 的别名：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Syst = System;</span><br><span class="line"><span class="keyword">using</span> SC = System.Console;</span><br></pre></td></tr></table></figure><p>下面的代码使用这些别名。在 Main 中3行代码都调用 System.Console.WriteLine 方法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Syst = System;  <span class="comment">//using别名指令</span></span><br><span class="line"><span class="keyword">using</span> SC = System.Console;  <span class="comment">//using别名指令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyNamespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">SomeClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Syst.Console.WriteLine(<span class="string">&quot;Using the namespace alias.&quot;</span>);  <span class="comment">//命名空间System的别名</span></span><br><span class="line">            System.Console.WriteLine(<span class="string">&quot;Using fully qualified name.&quot;</span>);  <span class="comment">//方法的完全限定名</span></span><br><span class="line">            SC.WriteLine(<span class="string">&quot;Using the type alias&quot;</span>); <span class="comment">//类Console的别名</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="using-static-指令"><a href="#using-static-指令" class="headerlink" title="using static 指令"></a>using static 指令</h3><p>如第6章和第7章所诉，可以使用 using static 指令引用命名空间中的特定类、结构体或枚举，这样就可以不带任何前缀地访问该类、结构体或枚举的静态成员。</p><p>using static 指令的示例：<code>using static System.Math;</code></p><p>using static 指令指定的类本身可以不是静态的。任何此种类型都可以包含实例成员，但这些实例成员不会由 using static 指令导入。虽然包含了指定类型中声明的嵌套类型，但是被继承的成员不会被导入。using static 指令的主要优点是排除了属于同一命名空间的其他类、结构体或枚举的成员。using static 指令仅仅包含指定类、结构体或枚举的静态成员，给定类型是静态的并不意味着它所有的成员也都是静态的。</p><h2 id="程序集的结构"><a href="#程序集的结构" class="headerlink" title="程序集的结构"></a>程序集的结构</h2><p>程序集不包含本地机器代码，而是包含公共中间语言代码 Common Intermediate Language (CIL)。它还包含实时编译器（JIT）在运行时将 CIL 转换为本机代码所需的一切，包括对它所引用的其他程序集的引用。程序集的文件扩展名通常为 .exe 或 .dll 。</p><p>大部分程序集由一个单独的文件构成：<br>①程序集的清单 manifest ，包含以下：<br>&emsp;&emsp;- 程序集标识符；<br>&emsp;&emsp;- 组成程序集的文件列表；<br>&emsp;&emsp;- 一个指示程序集中内容在哪里的地图；<br>&emsp;&emsp;- 关于引用的其他程序集的信息。<br>②类型元数据部分包含该程序集中定义的所有类型的信息。这些信息包含关于每个类型的所有事情；<br>③CIL 部分包含程序集的所有中间代码；<br>④资源部分是可选的，但可以包含图形或语言资源。</p><div  align="center">  <img src="https://s2.loli.net/2023/07/05/hVxTMY5ZWzruDml.png" width = "75%" height = "75%" alt="图109 - 单文件程序集的结构"/></div><p>程序集代码文件称为<strong>模块 module</strong>。尽管大部分程序集由单文件组成，但有些也有多个文件。对于有多个模块的程序集，一个文件是主模块 primary module ，而其他的是次要模块 secondary modules ：<br>①主模块含有程序集的清单和到次要模块的引用；<br>②次要模块的文件名以扩展名 .netmodule 结尾；<br>③多文件程序集被视为一个单元。它们一起部署并一起定版。</p><p>下图阐明了一个带次要模块的多文件程序集：</p><div  align="center">  <img src="https://s2.loli.net/2023/07/05/LYJvBqbP3tfVoUW.png" width = "50%" height = "50%" alt="图110 - 多文件程序集"/></div><h2 id="程序集标识符"><a href="#程序集标识符" class="headerlink" title="程序集标识符"></a>程序集标识符</h2><p>在 .NET 框架中，程序集的文件名不像在其他操作系统和环境中那么重要，更重要的是程序集的标识符 identity 。</p><p>程序集的标识符有4个组成部分，它们一起唯一标识了该程序集：<br>①简单名称：这只是不带文件扩展名的文件名。每个程序集都有一个简单名称。它也被称为程序集名或友好名称 friendly name；<br>②版本号：它由4个用句点分隔的整数组成，形式为 MajorVersion.MinorVersion.Build.Revision，例如 2.0.35.9 ；<br>③文化信息：它是一个字符串，由2~5个字符组成，代表一种语言，或代表一种语言和一个国家或地区。例如，在美国使用英语的文化名是 en-US 。在中国使用中文，它是 zh-CN ；<br>④公钥：这个128字节字符串应该是生产该程序集的公司唯一的。</p><p>公钥是<strong>公钥/私钥对 public/private key pair</strong> 的一部分，它们是两个非常大的、特别选择的数字，可以用于创建安全的数字签名。公钥，顾名思义，可以被公开。私钥必须被拥有者保护起来。公钥是程序集标识符的一部分。稍后会在本章看到私钥的使用。</p><p>程序集的完全限定名称是由简单名称、版本、文化和表示为16字节公钥凭据的公钥组成的文本列表。</p><h2 id="强命名程序集"><a href="#强命名程序集" class="headerlink" title="强命名程序集"></a>强命名程序集</h2><p><strong>强命名 strongly named</strong> 程序集有一个唯一的数字签名。强命名程序集比没有强名称的程序集更加安全，原因有以下两点：<br>①强名称唯一标识了程序集。其他人无法创建一个与之有相同名称的程序集，所以用户可以确信该程序集来自于其声称的来源；<br>②如果没有 CLR 安全组件来捕获更改，带强名称的程序集的内容就不能被改变。</p><p><strong>弱命名 weakly named</strong> 程序集是没有被强命名的程序集。由于弱命名程序集没有数字签名，它天生是不安全的。因为一根链的强度只和它最弱的一环相同，所以强命名程序集默认只能访问其他强命名程序集（还存在一种方法允许“部分授信的调用者”，但这里不做阐述）。</p><p>程序员不产生强名称。编译器通过接受关于程序集的信息，并散列化这些信息以创建一个唯一的数据签名依附到该程序集来产生强名称。它在散列处理中使用的信息如下：组成程序集的字节序列；简单名称；版本号；文化信息；公钥/私钥对。</p><h3 id="创建强命名程序集"><a href="#创建强命名程序集" class="headerlink" title="创建强命名程序集"></a>创建强命名程序集</h3><p>这里不摘抄。日后有需求了解即可。</p><h2 id="私有程序集的部署"><a href="#私有程序集的部署" class="headerlink" title="私有程序集的部署"></a>私有程序集的部署</h2><p>要在目标机器上部署一个程序，只需在该机器上创建一个目录并把应用程序复制过去。如果应用程序不需要其他程序集（比如 DLL），或如果所需的 DLL 在同一目录下，那么程序应该会就在它所在的地方良好工作。这种方法部署的程序集称为<strong>私有程序集</strong>，而且这种部署方法称为<strong>复制文件</strong> XCopy 部署。</p><p>私有程序集几乎可以被放在任何目录中，而且只要它们依赖的文件都在同一目录或子目录下就足够了。事实上，可以在文件系统的不同部分有多个目录，每个目录都有同样的一组程序集，并且它们都会在它们各自不同的位置良好工作。</p><p>关于私有程序集部署的一些重要事情如下：<br>①私有程序集所在的目录被称为应用程序目录；<br>②私有程序集可以是强命名的也可以是弱命名的；<br>③没有必要在注册表中注册组件；<br>④要卸载一个私有程序集，只要从文件系统中删除它即可。</p><h2 id="共享程序集和-GAC"><a href="#共享程序集和-GAC" class="headerlink" title="共享程序集和 GAC"></a>共享程序集和 GAC</h2><p>私有程序集是非常有用的，但有时你会想把一个 DLL 放在一个中心位置，这样一个副本就能被系统中其他的程序集共享。.NET 有这样的贮藏库，称为<strong>全局程序集缓存 GAC (global assembly cache)</strong>。放进 GAC 的程序集称为<strong>共享程序集</strong>。关于 GAC 的一些重要内容如下：<br>①只有强命名程序集能被添加到 GAC ；<br>②GAC 的早期版本只接受带 .dll 扩展名的文件，现在也可以添加带 .exe 扩展名的程序集了；<br>③GAC 位于 Windows 系统目录的子目录中。从 .NET 4.0 开始位于 \Windows\Microsoft.NET\assembly 中。</p><h3 id="把程序集安装到-GAC"><a href="#把程序集安装到-GAC" class="headerlink" title="把程序集安装到 GAC"></a>把程序集安装到 GAC</h3><p>当试图安装一个程序集到 GAC 时，CLR 的安全组件首先必须检验程序集上的数字签名是否有效。如果没有数字签名，或数字签名无效，系统将不会把它安装到 GAC 。</p><p>然而，这是个一次性检査。在程序集已经在 GAC 内之后，当它被一个正在运行的程序引用时，不再需要进一步的检査。</p><p>gacutil.exe 命令行工具允许从 GAC 添加或删除程序集，并列出 GAC 包含的程序集。它的3个最有用的参数标记如下所示：/i: 把一个程序集插人 GAC ；/u: 从 GAC 卸载一个程序集；/l: 列出 GAC 中的程序集。</p><h3 id="GAC-内的并肩执行"><a href="#GAC-内的并肩执行" class="headerlink" title="GAC 内的并肩执行"></a>GAC 内的并肩执行</h3><p>在程序集部署到 GAC 之后，它就能被系统中其他程序集使用了。然而，请记住程序集的标识符由完全限定名称的全部4个部分组成。所以，如果一个库的版本号改变了，或如果它有一个不同的公钥，则这些区别会导致指定不同的程序集。</p><p>结果就是在 GAC 中可以有许多不同的程序集，它们有相同的文件名。虽然它们有相同的文件名，但它们是不同的程序集而且在 GAC 中完美地共存。这使不同的应用程序在同一时间很容易使用不同版本的同一 DLL ，因为它们是带不同标识符的不同程序集。这被称为<strong>并肩执行 side-by-side Execution</strong>。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置文件含有关于应用程序的信息，供 CLR 在运行时使用。它们可以指示 CLR 去做这样的事情，比如使用一个不同版本的 DLL ，或搜索程序引用的 DLL 时在附加目录中查找。</p><p><strong>配置文件 Configuration files</strong> 由 XML 代码组成，并不包含 C# 代码。它们的一种用途是<em>更新一个应用程序集以使用新版本的 DLL</em> 。</p><p>例如，假设有一个应用程序引用了 GAC 中的一个 DLL 。在应用程序的清单中，该引用的标识符必须完全匹配 GAC 中程序集的标识符。如果一个新版本的 DLL 发布了，它可以被添加到 GAC 中，在那里它可以和老版本共存。然而，应用程序仍然在它的清单中包括老版本 DLL 的标识符。除非重新编译应用程序并使它引用新版本的 DLL ，否则它会继续使用老版本。如果你不想重新编译程序但又希望它使用新的 DLL ，那么你可以更新配置文件中的信息，告诉 CLR 去使用新的版本而不是旧版本。配置文件被放在应用程序目录中。注意配置文件的名称由执行文件的全名（包括扩展名）加上附加扩展名 .config 组成。</p><h2 id="延迟签名"><a href="#延迟签名" class="headerlink" title="延迟签名"></a>延迟签名</h2><p>公司小心地保护它们官方的公钥/私钥对是非常重要的，否则，如果不可靠的人得到了它，就可以发布伪装成该公司的代码。为了避免这种情况，公司显然不能允许自由访问含有它们的公钥/私钥对的文件。在大公司中，最终程序集的强命名经常在开发过程的结尾由有密钥访问权限的特殊小组执行。</p><p>可是，由于一些原因，这会在开发和测试过程中导致问题。首先，由于公钥是程序集标识符的4个部分之一，所以直到提供了公钥才能设置标识符。其次，弱命名的程序集不能被部署到 GAC 。开发人员和测试人员都需要能够按照发布时部署的方式编译和测试代码，包括它的标识符和在 GAC 中的位置。  </p><p>为此，有一种修改了的分配强命名的形式，称为<strong>延迟签名 delayed signing</strong> 或<strong>部分签名 partial signing</strong>，它克服了这些问题，而且没有释放对私钥的访问。</p><p>在延迟签名中，编译器只使用公钥/私钥对中的公钥。然后可以将公钥放入清单，以完成程序集的标识符。延迟签名还使用一个为0的块保留数字签名的位置。</p><p>要创建一个延迟签名的程序集，必须做两件事情。第一，创建一个密钥文件的一个副本，它只有公钥而不是公钥/私钥对。第二，为程序集范围内的源代码添加一个名称为 DelaySignAttribute 的附加特性，并把它的值设为 true 。</p><p>下图展示了生成一个延迟签名程序集的输人和输出，注意图中下面的内容：<br>①在输人中，DelaySignAttribute 位于源文件中，而且密钥文件只含有公钥；<br>②在输出中，在程序集的底部有一个数字签名的保留空间。</p><div  align="center">  <img src="https://s2.loli.net/2023/07/05/V8lagNcvBKTJQLR.png" width = "70%" height = "70%" alt="图111 - 创建延迟签名程序集"/></div><p>如果你试图部署延迟签名的程序集到 GAC ，CLR 不会允许，因为它不是强命名的。要在一台机器上部署它，必须首先使用命令行指令取消在这台机器上该程序集的 GAC 签名验证，并允许它被装在 GAC 中。要做到这点，从 Visual Studio 命令提示中执行下面的命令：<code>sn -vr MyAssembly.dll</code></p><p>现在，你已经看到弱命名程序集、延迟签名程序集和强签名程序集。下图总结了它们的结构区别：</p><div  align="center">  <img src="https://s2.loli.net/2023/07/05/TH5R4QIEAdgWtPX.png" width = "70%" height = "70%" alt="图112 - 不同程序集签名阶段的结构"/></div><h1 id="第二十三章-异常"><a href="#第二十三章-异常" class="headerlink" title="第二十三章 异常"></a>第二十三章 异常</h1><h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p><strong>异常 exception</strong> 是程序中的运行时错误。例如，程序试图将一个数除以0或试图写入一个只读文件。当这些发生时，系统捕获错误并<strong>抛出 raise</strong> 一个异常。如果程序没有提供处理该异常的代码，系统会挂起这个程序。</p><h2 id="try-语句"><a href="#try-语句" class="headerlink" title="try 语句"></a>try 语句</h2><p>try 语句用来指明为避免出现异常而被保护的代码段，并在发生异常时提供代码处理异常。try 语句由3个部分组成，如下图所示：<br>① try 块包含为避免出现异常而被保护的代码；<br>② catch 子句部分含有一个或多个 catch 子句。这些是处理异常的代码段，它们也称为是异常处理程序；<br>③ finally 块含有在所有情况下都要被执行的代码，无论有没有异常发生。</p><div  align="center">  <img src="https://s2.loli.net/2023/07/05/sLWlR4K1MqYGD53.png" width = "80%" height = "80%" alt="图113 - try 语句的结构"/></div><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>用 catch 子句处理异常的实例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">10</span>；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> y = <span class="number">0</span>;</span><br><span class="line">        x /= y; <span class="comment">//抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...  <span class="comment">//异常处理代码</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Handling all exceptions - keep on Running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Handling all exceptions - Keep on Running</span><br></pre></td></tr></table></figure><h2 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h2><p>BCL定义了许多异常类，每一个类代表一种指定的异常类型。当一个异常发生时，CLR 创建该类型的异常对象并寻找合适的 catch 子句以处理它。</p><p>所有异常类都派生自 System.Exception 类，而 System.Exception 类派生自 System.Object 。异常继承层次的一部分如下图所示：</p><div  align="center">  <img src="https://s2.loli.net/2023/07/05/kmCFAZLRIywvMrW.png" width = "60%" height = "60%" alt="图114 - 异常层次的结构"/></div><p>异常对象含有只读属性，带有导致该异常的异常信息。这些信息有助于调试应用程序，这些属性的其中一些如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Message</td><td style="text-align:left">string</td><td style="text-align:left">这个属性含有解释异常原因的错误消息</td></tr><tr><td style="text-align:left">StackTrace</td><td style="text-align:left">string</td><td style="text-align:left">这个属性含有描述异常发生在何处的信息</td></tr><tr><td style="text-align:left">InnerException</td><td style="text-align:left">Exception</td><td style="text-align:left">如果当前异常是由另一个异常引起的，则这个属性包含前一个异常的引用</td></tr><tr><td style="text-align:left">Source</td><td style="text-align:left">string</td><td style="text-align:left">如果没有被应用程序定义的异常设定，那么这个属性含有异常所在的程序集的名称</td></tr></tbody></table></div><h2 id="catch-子句"><a href="#catch-子句" class="headerlink" title="catch 子句"></a>catch 子句</h2><p>catch 子句处理异常。它有4种形式，允许不同级別的处理。这些形式如下图所示：</p><div  align="center">  <img src="https://s2.loli.net/2023/07/05/RV9G3UaqxoIYpE7.png" width = "80%" height = "80%" alt="图115 - catch子句的4种形式"/></div><p>如上图，这里先介绍前三种形式：<br>①<em>一般 catch 子句</em>能接受任何异常，但不能确定引发异常的异常类型。这只能对任何可能发生的异常进行普通处理和清理；<br>②<em>特定 catch 子句</em>形式把一个异常类的名称作为参数。它匹配该指定类或派生自它的异常类的异常；<br>③<em>带对象的特定 catch 子句</em>提供的关于异常的信息最多。它匹配该指定类的异常，或派生自它的异常类的异常。它还给出一个对 CLR 创建的异常对象的引用（通过将其赋给异常变量）。可以在 catch 子句块内部访问异常变量的属性，以获取关于抛出异常的详细信息。</p><p>例如，下面的代码处理 IndexOutOfRangeException 类型的异常。当异常发生时，一个实际异常对象的引用被参数名 e 传入代码。3个 WriteLine 语句都从异常对象中读取一个字符串字段：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>( DivideByZeroException e ) <span class="comment">//异常类型以及异常变量</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Message: &#123;0&#125;&quot;</span>, e.Message); <span class="comment">//访问异常变量</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Source:  &#123;0&#125;&quot;</span>, e.Source);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Stack:   &#123;0&#125;&quot;</span>, e.StackTrace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用特定-catch-子句的示例"><a href="#使用特定-catch-子句的示例" class="headerlink" title="使用特定 catch 子句的示例"></a>使用特定 catch 子句的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> y = <span class="number">0</span>;</span><br><span class="line">    x /= y;  <span class="comment">//抛出一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特定 catch 子句</span></span><br><span class="line"><span class="keyword">catch</span>( DivideByZeroException )</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Handling an exception.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用带对象的特定 catch 子句</span></span><br><span class="line"><span class="keyword">catch</span>( DivideByZeroException e )</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Message: &#123;0&#125;&quot;</span>, e.Message);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Source:  &#123;0&#125;&quot;</span>, e.Source);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Stack:   &#123;0&#125;&quot;</span>, e.StackTrace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用带对象的特定 catch 子句的运行结果如下：  </p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Message: Attempted to divide by zero.</span><br><span class="line">Source:  Exceptions 1</span><br><span class="line">Stack:      at Program.Main() in C:\Users\XXXX\Desktop\Exceptions 1\Program.cs:line 9</span><br></pre></td></tr></table></figure><h2 id="异常过滤器"><a href="#异常过滤器" class="headerlink" title="异常过滤器"></a>异常过滤器</h2><p>第四种形式的 catch 子句，跟第三种形式一样，异常对象被传递给处理程序，但在这种情况下，对象还必须满足特定条件，这个条件被称为<strong>过滤器 filter</strong>。因此，对于一个异常类型可以有多个处理程序，而不必由一个处理程序处理这个异常类型的所有可能异常。如下示例，注意如果 Message 字段同时包含301和307，则只调用第一个 catch 子句，因为无论可能匹配多少个子句，都只执行第一个匹配成功的子句：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ... 执行某个Web请求</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( HttpRequestException e ) <span class="keyword">when</span> ( e.Message.Contains(<span class="string">&quot;307&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    ... 采取某种行动</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( HttpRequestException e ) <span class="keyword">when</span> ( e.Message.Contains(<span class="string">&quot;301&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    ... 采取其他行动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器的 when 子句的重要特性如下：<br>①它必须包含<strong>谓语 predicate 表达式</strong>，该表达式返回布尔值；<br>②它不能是异步的；<br>③不应使用任何需要长时间运行的操作；<br>④谓语表达式中发生的任何异常都会被忽略。这使得调试谓词表达式变得更加困难，但它保留了调试原始应用程序错误所需的信息。</p><h2 id="catch-子句段"><a href="#catch-子句段" class="headerlink" title="catch 子句段"></a>catch 子句段</h2><p>如果 catch 子句接受一个参数，那么系统会把这个异常变量设置为对异常对象的引用，这样就可以检査它并确定异常的原因。如果异常是前一个异常引起的，可以通过异常变量的 InnerException 属性来获得对前一个异常对象的引用。catch 子句段可以包含多个 catch 子句。下图显示了 catch 子句段：</p><div  align="center">  <img src="https://s2.loli.net/2023/07/06/sLaDeFqpE2RhW6M.png" width = "70%" height = "70%" alt="图116 - try语句的catch子句段结构"/></div><p>当异常发生时，系统按顺序搜索 catch 子句的列表，第一个匹配该异常对象类型的 catch 子句被执行。因此，catch 子句的排序有两个重要的规则。具体如下：<br>①特定 catch 子句必须以一种顺序排列，即最特定的异常类型第一，最普通的类型排最后；<br>②如果有一个一般 catch 子句，它必须是最后一个，并且在所有特定 catch 子句之后。不鼓励使用一般 catch 子句，因为当代码应该以特定方式处理错误的时候，它允许程序继续执行从而隐藏了错误，让程序处于一种未知的状态。应尽可能使用特定 catch 子句。</p><h2 id="finally-块"><a href="#finally-块" class="headerlink" title="finally 块"></a>finally 块</h2><p>如果程序的控制流进人了一个带 finally 块的 try 语句，那么 finally 始终会被执行：<br>①如果在 try 块内部没有异常发生，那么在 try 块的结尾，控制流跳过任何 catch 子句并到 finally 块；<br>②如果在 try 块内部发生了异常，那么在 catch 子句段中适当的 catch 子句被执行，接着就是 finally 块的执行。</p><p>即使 try 块中有 return 语句或在 catch 块中抛出一个异常，finally 块也总是会在返回到调用代码之前执行。例如，在下面的代码中，在 try 块的中间有一条 return 语句，它在某条件下被执行。<br>这不会使它绕过 finally 语句：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (inVal &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;First Branch - &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Console.Write(<span class="string">&quot;Second Branch - &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;In finally statement&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在 inVal 值为5时产生以下输出：  </p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">First Branch - In finally statement</span><br></pre></td></tr></table></figure><h2 id="为异常寻找处理程序"><a href="#为异常寻找处理程序" class="headerlink" title="为异常寻找处理程序"></a>为异常寻找处理程序</h2><p>当程序抛出异常时，系统查看该程序是否为它提供了处理程序：<br>①如果在 try 块内发生了异常，系统会査看是否有任何一个 catch 子句能处理该异常；<br>②如果找到了适当的 catch 子句，以下会发生：<br>&emsp;&emsp;- 该 catch 子句被执行；<br>&emsp;&emsp;- 如果有 finally 块，那么它被执行；<br>&emsp;&emsp;- 执行在 try 语句的尾部之后继续（也就是说，在 finally 块之后，或如果没有 finally 块，就在最后一个 catch 子句之后）。</p><h2 id="进一步搜索"><a href="#进一步搜索" class="headerlink" title="进一步搜索"></a>进一步搜索</h2><p>如果异常在一个没有被 try 语句保护的代码段中产生，或如果 try 语句没有匹配的异常处理程序，系统将不得不更进一步寻找匹配的处理代码。为此它会按顺序搜索调用栈，查看是否存在带匹配的处理程序的封装 try 块。</p><div  align="center">  <img src="https://s2.loli.net/2023/07/07/UIG7bkzAwtLn8ic.png" width = "75%" height = "75%" alt="图117 - 搜索调用栈"/></div><p>上图阐明了这个搜索过程。图左边是代码的调用结构，右边是调用栈。该图显示 Method2 被从 Method1 的 try 块内部调用。如果异常发生在 Method2 内的 try 块内部，系统会执行以下操作：<br>①首先査看 Method2 是否有能处理该异常的异常处理程序；<br>&emsp;&emsp;- 如果有，Method2 处理它，程序继续执行；<br>&emsp;&emsp;- 如果没有，系统再沿着调用栈找到 Method1 ，搜寻适当的处理程序；<br>②如果 Method1 有一个适当的 catch 子句，那么系统将：<br>&emsp;&emsp;- 回到栈顶，那里是 Method2 ；<br>&emsp;&emsp;- 执行 Method2 的 finally 块，并把 Method2 弹出栈；<br>&emsp;&emsp;- 执行 Method1 的 catch 子句和它的 finally 块。<br>③如果 Method1 没有适当的 catch 子句，系统会继续搜索调用栈。</p><h3 id="一般法则"><a href="#一般法则" class="headerlink" title="一般法则"></a>一般法则</h3><div  align="center">  <img src="https://s2.loli.net/2023/07/07/8K7DOxj4LaANBSP.png" width = "70%" height = "70%" alt="图118 - 处理异常的一般法则"/></div><h3 id="搜索调用栈的示例"><a href="#搜索调用栈的示例" class="headerlink" title="搜索调用栈的示例"></a>搜索调用栈的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass MCls = <span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">            &#123; MCls.A(); &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( DivideByZeroException )</span><br><span class="line">            &#123; Console.WriteLine(<span class="string">&quot;catch clause in Main()&quot;</span>); &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">            &#123; Console.WriteLine(<span class="string">&quot;finally clause in Main()&quot;</span>); &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;After try statement in Main.&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot; -- Keep running.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">            &#123; B(); &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( NullReferenceException )</span><br><span class="line">            &#123; Console.WriteLine(<span class="string">&quot;catch clause in A()&quot;</span>); &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">            &#123; Console.WriteLine(<span class="string">&quot;finally clause in A()&quot;</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">B</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">10</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">            &#123; x /= y; &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( IndexOutOfRangeException )</span><br><span class="line">            &#123; Console.WriteLine(<span class="string">&quot;catch clause in B()&quot;</span>); &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">            &#123; Console.WriteLine(<span class="string">&quot;finally clause in B()&quot;</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">finally clause in B()</span><br><span class="line">finally clause in A()</span><br><span class="line">catch clause in Main()</span><br><span class="line">finally clause in Main()</span><br><span class="line">After try statement in Main.</span><br><span class="line"> -- Keep running.</span><br></pre></td></tr></table></figure><p>①Main 调用 A ，A 调用 B ，B 遇到一个 DivideByZeroException 异常；<br>②系统检查 B 的 catch 段寻找匹配的 catch 子句。虽然它有一个 IndexOutOfRangeException 的 catch 子句，但没有 DivideByZeroException 的子句；<br>③系统然后沿着调用栈向下移动并检査 A 的 catch 段，在那里它发现 A 也没有匹配的 catch 子句；<br>④系统继续沿调用栈向下，并检查 Main 的 catch 子句部分，在那里它发现 Main 确实有一个 DivideByZeroException 的 catch 子句；<br>⑤尽管匹配的 catch 子句现在被定位了，但并不执行。相反，系统回到栈的顶端，执行 B 的 finally 子句，并把 B 从调用栈中弹出；<br>⑥系统移动到 A ，执行它的 finally 子句，并把 A 从调用栈中弹出；<br>⑦最后，Main 的匹配 catch 子句被执行，接着是它的 finally 子句。然后执行在 Main 的 try 语句结尾之后继续。</p><div  align="center">  <img src="https://s2.loli.net/2023/07/07/AQbCZocEhkzsw1n.png" width = "70%" height = "70%" alt="图119 - 搜索栈以寻找一个异常处理程序"/></div><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>可以使用 <strong>throw 语句</strong>使代码显式地抛出异常。throw 语句的语法为：<code>throw ExceptionObject;</code></p><p>示例如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintArg</span>(<span class="params"><span class="built_in">string</span> arg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arg == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ArgumentNullException myEx = <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;arg&quot;</span>); <span class="comment">//提供null参数</span></span><br><span class="line">                <span class="keyword">throw</span> myEx;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ArgumentNullException e)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Message: <span class="subst">&#123; e.Message &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="literal">null</span>;</span><br><span class="line">        MyClass.PrintArg(s);</span><br><span class="line">        MyClass.PrintArg(<span class="string">&quot;Hi there!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：  </p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Message: Value cannot be null. (Parameter &#x27;arg&#x27;)</span><br><span class="line">Hi there!</span><br></pre></td></tr></table></figure><h2 id="不带异常对象的抛出"><a href="#不带异常对象的抛出" class="headerlink" title="不带异常对象的抛出"></a>不带异常对象的抛出</h2><p>throw 语句还可以在 catch 块内部不带异常对象使用：<br>①这种形式重新抛出当前异常，系统继续搜索，为该异常寻找另外的处理程序；<br>②这种形式只能用在 catch 语句内部。</p><p>例如，下面的代码从第一个 catch 子句内部重新抛出异常：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintArg</span>(<span class="params"><span class="built_in">string</span> arg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (arg == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ArgumentNullException myEx = <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;arg&quot;</span>);  <span class="comment">//提供null参数</span></span><br><span class="line">                    <span class="keyword">throw</span> myEx;</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(arg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ArgumentNullException e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Inner Catch: <span class="subst">&#123; e.Message &#125;</span>&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span>;  <span class="comment">//重新抛出异常，没有附加参数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Outer Catch: Handling an Exception.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="literal">null</span>;</span><br><span class="line">        MyClass.PrintArg(s);</span><br><span class="line">        MyClass.PrintArg(<span class="string">&quot;Hi there!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Inner Catch: Value cannot be null. (Parameter &#x27;arg&#x27;)</span><br><span class="line">Outer Catch: Handling an Exception.</span><br><span class="line">Hi there!</span><br></pre></td></tr></table></figure><h2 id="throw-表达式"><a href="#throw-表达式" class="headerlink" title="throw 表达式"></a>throw 表达式</h2><p>C# 包含语句和表达式。代码中有些地方不允许使用语句，只能使用表达式，反之亦然。本章的前几节都是在语句中使用 throw 。从 C# 7.0 开始，可以在只能使用表达式的地方使用 throw 了。</p><p>throw 语句和 throw 表达式的语法相同。例如，可以把 throw 语句作为空接合运算符的第二个操作数。<strong>空接合运算符</strong>是由两个以 ?? 分隔的操作数组成。第一个操作数必须是可空的，并且经过测试以确定它是否为空。如果第一个操作数不为空，则使用其值。但是如果第一个操作数为空，则使用第二个操作数：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> mSecurityCode;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> SecurityCode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> =&gt; mSecurityCode;</span><br><span class="line">    <span class="keyword">set</span> =&gt; mSecurityCode = <span class="keyword">value</span> ??</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;Security Code may not be null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C# 中，另一个需要使用表达式的构造是条件运算符。throw 表达式可在条件运算符中用作第二个或第三个操作数，如下代码所示：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">string</span> SecretCode &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Roses are red&quot;</span>; &#125; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> safe = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> secretCode = safe</span><br><span class="line">                ? SecretCode</span><br><span class="line">                : <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Not safe to get code.&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Code is: <span class="subst">&#123;secretCode&#125;</span>.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; e.Message &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：  </p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Not safe to get code.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> C#读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> .net </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C#图解教程》读书笔记（三）</title>
      <link href="/2023/02/03/2023-02-03-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B3/"/>
      <url>/2023/02/03/2023-02-03-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇主要内容为：接口；转换；泛型；枚举器和迭代器；LINQ 。<br>读书笔记仅为知识的记录，方便后续查找。<br>学习完成日期为2023年07月29日。  </p></blockquote><div  align="center">  <img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/></div><h1 id="第十六章-接口"><a href="#第十六章-接口" class="headerlink" title="第十六章 接口"></a>第十六章 接口</h1><h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p><strong>接口 interface</strong>是指定一组函数成员但不实现它们的引用类型，所以只能用类和结构来实现接口。</p><p>接口的用途可以通过下面2个例子介绍，第一个例子不使用接口：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">CB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> First;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Last;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> PersonsAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintInfo</span>(<span class="params"> CA item </span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123; item.Name &#125;</span>, Age: <span class="subst">&#123; item.Age &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        CA a = <span class="keyword">new</span> CA() &#123; Name = <span class="string">&quot;John Doe&quot;</span>, Age = <span class="number">35</span> &#125;;</span><br><span class="line">        PrintInfo( a );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码只要传入 CA 类型对象，PrintInfo 方法就能工作正常。但传入 CB 类型对象就不行，而且 CB 的结构、字段名称和类型都可能与 CA 不一样。而接口可以使不管传入 PrintInfo 的类的结构是什么样的，都能正常处理：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetName</span>()</span>; <span class="comment">//返回string的方法</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetAge</span>()</span>; <span class="comment">//返回string的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">CA</span> : <span class="title">IInfo</span> <span class="comment">//声明实现接口的CA类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123; <span class="keyword">return</span> Name; &#125; <span class="comment">//实现两个接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetAge</span>()</span> &#123; <span class="keyword">return</span> Age.ToString( ); &#125; <span class="comment">//实现两个接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">CB</span> : <span class="title">IInfo</span> <span class="comment">//声明实现接口的CB类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> First;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Last;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> PersonsAge;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span> &#123; <span class="keyword">return</span> First + <span class="string">&quot; &quot;</span> + Last; &#125; <span class="comment">//实现两个接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetAge</span>()</span> &#123; <span class="keyword">return</span> PersonsAge.ToString(); &#125; <span class="comment">//实现两个接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintInfo</span>(<span class="params"> IInfo item </span>) <span class="comment">//传入接口的引用</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Name:&#123;0&#125;, Age &#123;1&#125;&quot;</span>, item.GetName(), item.GetAge() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CA a = <span class="keyword">new</span> CA() &#123; Name = <span class="string">&quot;John Doe&quot;</span>, Age = <span class="number">35</span> &#125;;</span><br><span class="line">        CB b = <span class="keyword">new</span> CB() &#123; First = <span class="string">&quot;Jane&quot;</span>, Last = <span class="string">&quot;Doe&quot;</span>, PersonsAge = <span class="number">33</span> &#125;;</span><br><span class="line"></span><br><span class="line">        PrintInfo(a); <span class="comment">//对象的引用能自动转换为它们实现的接口的引用</span></span><br><span class="line">        PrintInfo(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Name:John Doe, Age 35</span><br><span class="line">Name:Jane Doe, Age 33</span><br></pre></td></tr></table></figure><h3 id="使用-IComparable-接口的示例"><a href="#使用-IComparable-接口的示例" class="headerlink" title="使用 IComparable 接口的示例"></a>使用 IComparable 接口的示例</h3><p>通过以下示例来更好地了解接口：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myInt = <span class="keyword">new</span> [] &#123; <span class="number">20</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">2</span> &#125;; <span class="comment">//创建int数组</span></span><br><span class="line"></span><br><span class="line">Array.Sort(myInt); <span class="comment">//按大小排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> i <span class="keyword">in</span> myInt) <span class="comment">//输出</span></span><br><span class="line">    Console.Write(<span class="string">$&quot;<span class="subst">&#123; i &#125;</span> &quot;</span>);</span><br></pre></td></tr></table></figure><p>Array 类的 Sort 方法可以运行在 int 数组上，但是在类数组上无法运行，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TheValue;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">MyClass[] mc = <span class="keyword">new</span> MyClass[<span class="number">5</span>]; <span class="comment">//创建有5个元素的数组</span></span><br><span class="line">    ...</span><br><span class="line">Array.Sort(mc); <span class="comment">//尝试使用Sort时抛出异常</span></span><br></pre></td></tr></table></figure><p>Array 类的 Sort 方法实际上依赖一个叫做 <strong>IComparable</strong> 的接口，它声明在 BCL 中，包含唯一的方法 CompareTo 。下面代码展示了 IComparable 接口的声明，包含 CompareTo 方法的声明，该方法接受一个 object 类型的参数，并且没有实现，即实现用分号表示：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IComparable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params"> <span class="built_in">object</span> obj </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管在接口声明中没有为 CompareTo 方法提供实现，但 IComparable 接口的 .NET 文档描述了该方法应该做的事情。在调用 CompareTo 方法时，它应该返回以下几个值之一：<br>①负数值，如果当前对象小于参数对象；<br>②正数值，如果当前对象大于参数对象；<br>③零，如果两个对象在比较时相等。</p><p>Sort 使用的算法依赖于使用元素的 CompareTo 方法来决定两个元素的次序，int 类型实现了 IComparable，但是 MyClass 没有。我们可以通过让类实现 IComparable，让 Sort 方法可以用于 MyClass 类型的对象。要实现这一接口，类或结构要①在基类列表中列出接口名称，②为接口的每一个成员提供实现。如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IComparable</span> <span class="comment">//基类列表中的接口名称</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TheValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params"><span class="built_in">object</span> obj</span>) <span class="comment">//实现CompareTo方法以遵循接口文档的定义，参数类型和返回类型与接口成员一致</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = (MyClass)obj;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.TheValue &lt; mc.TheValue) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.TheValue &gt; mc.TheValue) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图，展示了更新后的类，从有阴影的接口方法指向类方法的箭头表示接口方法不包含代码，而是在类级别的方法实现：</p><div  align="center">  <img src="https://s2.loli.net/2023/02/04/jeamyQVskX6HzAR.png" width = "60%" height = "60%" alt="图71 - 在MyClass中实现IComparable"/></div><p>既然 MyClass 实现了 IComparable 接口，就可以使用 Sort 了，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IComparable</span> <span class="comment">//类实现接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TheValue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params"><span class="built_in">object</span> obj</span>) <span class="comment">//实现方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = (MyClass)obj;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.TheValue &lt; mc.TheValue) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.TheValue &gt; mc.TheValue) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s, MyClass[] mc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(s);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> m <span class="keyword">in</span> mc)</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; m.TheValue &#125;</span> &quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> myInt = <span class="keyword">new</span> [] &#123; <span class="number">20</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">        MyClass[] mcArr = <span class="keyword">new</span> MyClass[<span class="number">5</span>]; <span class="comment">//创建MyClass对象的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) <span class="comment">//初始化数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            mcArr[i] = <span class="keyword">new</span> MyClass();</span><br><span class="line">            mcArr[i].TheValue = myInt[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PrintOut(<span class="string">&quot;Initial Order: &quot;</span>, mcArr);</span><br><span class="line">        Array.Sort(mcArr);</span><br><span class="line">        PrintOut(<span class="string">&quot;Sorted Order: &quot;</span>, mcArr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Initial Order: 20 4 16 9 2 </span><br><span class="line">Sorted Order: 2 4 9 16 20 </span><br></pre></td></tr></table></figure><h2 id="声明接口"><a href="#声明接口" class="headerlink" title="声明接口"></a>声明接口</h2><p>声明接口的重要事项：<br>①接口声明不能包括数据成员和静态成员；<br>②接口声明只能包含方法、属性、事件和索引器这几个非静态成员函数；<br>③上述函数成员的声明不能包含任何实现代码，必须使用分号代替主体；<br>④按照惯例，接口名称必须从大写的 I 开始，比如 ISaveable ；<br>⑤与类和结构一样，接口的声明可以分隔成分部接口声明。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IMyInterface1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">DoStuff</span> (<span class="params"> <span class="built_in">int</span> nVar1, <span class="built_in">long</span> lVar2 </span>)</span>; <span class="comment">//分号代替了主体</span></span><br><span class="line">    <span class="function"><span class="built_in">double</span> <span class="title">DoOtherStuff</span>(<span class="params"> <span class="built_in">string</span> s, <span class="built_in">long</span> x </span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口的访问性</strong>和接口成员的访问性之间的区别：<br>①接口声明可以有任何的访问修饰符：public、protected、internal 或 private；<br>②然而接口成员是隐式 public 的，不允许有任何访问修饰符，包括 public。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMyInterface2</span> <span class="comment">//接口可以有访问修饰符</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">Method1</span>(<span class="params"> <span class="built_in">int</span> nVar1, <span class="built_in">long</span> lVar2 </span>)</span>; <span class="comment">//错误，接口成员不能有访问修饰符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>只有类和结构能实现接口，要实现接口，类或结构必须：<br>①在基类列表中包含接口名称；<br>②为每一个接口成员提供实现。</p><p>关于实现接口的其他重要事项：<br>①如果类实现了接口，它必须实现接口的<strong>所有成员</strong>；<br>②如果类派生自基类并且实现了接口，基类列表中的基类名称必须放在所有接口之前，如下（只能有一个基类，所有其他类型必须为接口）：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">MyBaseClass</span>, <span class="title">IIfc1</span>, <span class="title">IEnumerable</span>, <span class="title">IComparable</span> <span class="comment">//基类必须放在最前面</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单接口的示例"><a href="#简单接口的示例" class="headerlink" title="简单接口的示例"></a>简单接口的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span> <span class="comment">//声明接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; <span class="comment">//分号代替主体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IIfc1</span> <span class="comment">//声明类，实现接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>) <span class="comment">//实现接口成员</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Calling through: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass(); <span class="comment">//创建实例</span></span><br><span class="line">        mc.PrintOut(<span class="string">&quot;object&quot;</span>); <span class="comment">//调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Calling through: object</span><br></pre></td></tr></table></figure><h2 id="接口是引用类型"><a href="#接口是引用类型" class="headerlink" title="接口是引用类型"></a>接口是引用类型</h2><p>接口是引用类型。不能直接通过类对象的成员来访问接口，可以通过把类对象引用强制转换为接口类型来获取指向接口的引用。一旦有了接口的引用，就可以使用点语法来调用接口的成员。示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IIfc1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Calling through: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">        mc.PrintOut(<span class="string">&quot;object&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IIfc1 ifc = (IIfc1)mc; <span class="comment">//将对象的引用转换为接口类型的引用</span></span><br><span class="line">        ifc.PrintOut(<span class="string">&quot;interface&quot;</span>); <span class="comment">//调用接口方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Calling through: object</span><br><span class="line">Calling through: interface</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/02/07/3BXYFrgSocITWPf.png" width = "50%" height = "50%" alt="图72 - 类对象的引用以及接口的引用"/></div><h2 id="接口和-as-运算符"><a href="#接口和-as-运算符" class="headerlink" title="接口和 as 运算符"></a>接口和 as 运算符</h2><p>可以使用 <strong>as 运算符</strong>来代替使用强制转换运算符来获取对象接口的引用。as 运算符与接口配合使用更好，详见第17章。如果尝试将类对象引用强制转换为类未实现的接口的引用，强制转换操作会抛出一个异常。使用 as 运算符可以避免这个问题，若类实现了接口，表达式返回指向接口的引用，若类没有实现接口，表达式返回 null 而不是抛出异常。如下：</p><p><code>ILiveBirth b = a as ILiveBirth;</code><br>b 是接口引用，a 是类对象引用，跟 <code>cast: (ILiveBirth)a</code> 一样。</p><h2 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h2><p>①类或结构可以实现任意数量的接口；<br>②所有实现的接口必须列在基类列表中并以逗号分隔（若有基类，在其之后）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IDataRetrieve</span> &#123; <span class="function"><span class="built_in">int</span> <span class="title">GetData</span>()</span>; &#125; <span class="comment">//声明接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IDataStore</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">SetData</span>(<span class="params"> <span class="built_in">int</span> x </span>)</span>; &#125; <span class="comment">//声明接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyData</span>: <span class="title">IDataRetrieve</span>, <span class="title">IDataStore</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Mem1;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetData</span>()</span> &#123; <span class="keyword">return</span> Mem1; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetData</span>(<span class="params"> <span class="built_in">int</span> x </span>)</span> &#123; Mem1 = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        data.SetData( <span class="number">5</span> );</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Value = <span class="subst">&#123; data.GetData() &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现具有重复成员的接口"><a href="#实现具有重复成员的接口" class="headerlink" title="实现具有重复成员的接口"></a>实现具有重复成员的接口</h2><p>如果一个类实现了多个接口，并且其中一些接口成员具有相同的签名和返回类型，那么类可以实现单个成员来满足所有包含重复成员的接口。示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IIfc2</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> t</span>)</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IIfc1</span>, <span class="title">IIfc2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Calling through: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">        mc.PrintOut(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Calling through: object</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/02/07/ax513qpkCXBcyiv.png" width = "60%" height = "60%" alt="图73 - 由同一个类成员实现多个接口"/></div><h2 id="多个接口的引用"><a href="#多个接口的引用" class="headerlink" title="多个接口的引用"></a>多个接口的引用</h2><p>如果类实现了多个接口，可以获取每一个接口的独立引用。如下，可以以三种方式调用 PrintOut，通过类对象，通过指向 IIfc1 接口的引用，通过指向 IIfc2 接口的引用：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IIfc2</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IIfc1</span>, <span class="title">IIfc2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Calling through: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        IIfc1 ifc1 = (IIfc1) mc; <span class="comment">//获取IIfc1的引用</span></span><br><span class="line">        IIfc2 ifc2 = (IIfc2) mc; <span class="comment">//获取IIfc2的引用</span></span><br><span class="line"></span><br><span class="line">        mc.PrintOut(<span class="string">&quot;object&quot;</span>); <span class="comment">//从类对象调用</span></span><br><span class="line"></span><br><span class="line">        ifc1.PrintOut(<span class="string">&quot;interface 1&quot;</span>); <span class="comment">//从IIfc1调用</span></span><br><span class="line">        ifc2.PrintOut(<span class="string">&quot;interface 2&quot;</span>); <span class="comment">//从IIfc2调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="派生成员作为实现"><a href="#派生成员作为实现" class="headerlink" title="派生成员作为实现"></a>派生成员作为实现</h2><p>实现接口的类可以从它的基类继承实现代码，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Calling through: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">MyBaseClass</span>, <span class="title">IIfc1</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Derived d = <span class="keyword">new</span> Derived();</span><br><span class="line">        d.PrintOut(<span class="string">&quot;object.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IIfc1 接口指向基类的 PrintOut 方法。</p><h2 id="显式接口成员实现"><a href="#显式接口成员实现" class="headerlink" title="显式接口成员实现"></a>显式接口成员实现</h2><p>单个类可以实现多个接口，若要让接口分开实现，可以创建<strong>显式接口成员 explicit interface member implementations</strong>，它使用限定接口名称来声明，由接口名称和成员名称以及中间的点构成：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IIfc1</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; &#125; </span><br><span class="line"><span class="keyword">interface</span> <span class="title">IIfc2</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">PrintOut</span>(<span class="params"><span class="built_in">string</span> t</span>)</span>; &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IIfc1</span>, <span class="title">IIfc2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IIfc1.PrintOut(<span class="built_in">string</span> s) <span class="comment">//显式接口成员实现</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;IIfc1: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> IIfc2.PrintOut(<span class="built_in">string</span> s) <span class="comment">//显式接口成员实现</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;IIfc2: <span class="subst">&#123; s &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        IIfc1 ifc1 = (IIfc1) mc;</span><br><span class="line">        ifc1.PrintOut(<span class="string">&quot;interface 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IIfc2 ifc2 = (IIfc2) mc;</span><br><span class="line">        ifc2.PrintOut(<span class="string">&quot;interface 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上述代码，不能使用 mc 引用来调用 PrintOut 方法，因为不存在类级别的 PrintOut 方法。当然可以添加类级别的实现。</p><h3 id="访问显式接口成员实现"><a href="#访问显式接口成员实现" class="headerlink" title="访问显式接口成员实现"></a>访问显式接口成员实现</h3><p>显式接口成员实现只能通过指向接口的引用来访问，如前例，类的其他成员也不能直接访问他们，会产生编译错误，需要强制转换当前对象的引用（用 this ）：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IIfc1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IIfc1.PrintOut(<span class="built_in">string</span> s) <span class="comment">//显式接口实现</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;IIfc1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PrintOut(<span class="string">&quot;...&quot;</span>); <span class="comment">//编译错误</span></span><br><span class="line">        <span class="keyword">this</span>.PrintOut(<span class="string">&quot;...&quot;</span>); <span class="comment">//编译错误</span></span><br><span class="line"></span><br><span class="line">        ((IIfc1)<span class="keyword">this</span>).PrintOut(<span class="string">&quot;...&quot;</span>); <span class="comment">//转换为接口引用，并调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个限制对继承产生了重要影响。由于其他类成员不能直接访问显式接口成员实现，派生类的成员也不能直接访问它们。它们必须总是通过接口的引用来访问。</p><h2 id="接口可以继承接口"><a href="#接口可以继承接口" class="headerlink" title="接口可以继承接口"></a>接口可以继承接口</h2><p>接口本身可以从一个或多个接口继承而来，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IDataRetrieve</span> &#123; <span class="function"><span class="built_in">int</span> <span class="title">GetData</span>()</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IDataStore</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">SetData</span>(<span class="params"> <span class="built_in">int</span> x </span>)</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从前两个接口继承而来</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IDataIO</span>: <span class="title">IDataRetrieve</span>, <span class="title">IDataStore</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyData</span>: <span class="title">IDataIO</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> nPrivateData;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetData</span>()</span></span><br><span class="line">        &#123; <span class="keyword">return</span> nPrivateData; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetData</span>(<span class="params"> <span class="built_in">int</span> x </span>)</span></span><br><span class="line">        &#123; nPrivateData = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line">        data.SetData( <span class="number">5</span> );</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, data.GetData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同类实现一个接口的示例"><a href="#不同类实现一个接口的示例" class="headerlink" title="不同类实现一个接口的示例"></a>不同类实现一个接口的示例</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">ILiveBirth</span> &#123; <span class="function"><span class="built_in">string</span> <span class="title">BabyCalled</span>()</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; &#125; <span class="comment">//基类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span>, <span class="title">ILiveBirth</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> ILiveBirth.BabyCalled()</span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="string">&quot;kitten&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span>, <span class="title">ILiveBirth</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> ILiveBirth.BabyCalled()</span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="string">&quot;puppy&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Bird</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Animal[] animalArray = <span class="keyword">new</span> Animal[<span class="number">3</span>];</span><br><span class="line">        animalArray[<span class="number">0</span>] = <span class="keyword">new</span> Cat();</span><br><span class="line">        animalArray[<span class="number">1</span>] = <span class="keyword">new</span> Bird();</span><br><span class="line">        animalArray[<span class="number">2</span>] = <span class="keyword">new</span> Dog();</span><br><span class="line">        <span class="keyword">foreach</span>( Animal a <span class="keyword">in</span> animalArray )</span><br><span class="line">        &#123;</span><br><span class="line">            ILiveBirth b = a <span class="keyword">as</span> ILiveBirth;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span>)</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Baby is called: <span class="subst">&#123; b.BabyCalled() &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Baby is called: kitten</span><br><span class="line">Baby is called: puppy</span><br></pre></td></tr></table></figure><h1 id="第十七章-转换"><a href="#第十七章-转换" class="headerlink" title="第十七章 转换"></a>第十七章 转换</h1><h2 id="什么是转换"><a href="#什么是转换" class="headerlink" title="什么是转换"></a>什么是转换</h2><p>若要把一个变量（源）的值，赋值给另外一个变量（目标），在赋值之前，源的值必须转换为目标类型的值。转换后的值应和源值一致，但其类型为目标类型。</p><div  align="center">  <img src="https://s2.loli.net/2023/02/07/24nuRkv5XPVSfoH.png" width = "70%" height = "70%" alt="图74 - 从short转换为sbyte"/></div><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>有些类型的转换不会丢失数据和精度，比如8位的值转换为16位：<br>①语言会自动做这些转换，这叫做<strong>隐式转换</strong>；<br>②从位数更少的源类型转换为位数更多的目标类型时，多出来的位用0或1填充；<br>③当从更小的无符号类型转换为更大的无符号类型时，目标类型多出来的最高位都以0进行填充，称为<strong>零扩展 zero extension</strong>。<br>④对于有符号类型的转换，额外的最高位用源表达式的符号位填充，这样可以维持被转换值的正确符号和大小，叫做<strong>符号扩展 sign extension</strong>，如下图：</p><div  align="center">  <img src="https://s2.loli.net/2023/02/07/RYw6FQchEmBj35q.png" width = "60%" height = "60%" alt="图75 - 有符号转换中的符号扩展"/></div><h2 id="显式转换和强制转换"><a href="#显式转换和强制转换" class="headerlink" title="显式转换和强制转换"></a>显式转换和强制转换</h2><p>若将长类型转换为短类型，不是源值的所有最高位都适合目标类型，会导致<strong>溢出 overflow</strong> 或<strong>数据丢失</strong>。如下图：</p><div  align="center">  <img src="https://s2.loli.net/2023/02/07/76z9FslyoKeRCAi.png" width = "60%" height = "60%" alt="图76 - 尝试把ushort转换为byte"/></div><h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>对于预定义类型，C# 会自动将一个数据类型转换为另一个数据类型，前提是从源类型转换为目标类型不会发生数据丢失。即 C# 不会提供会丢失值情形的自动转换，这时候必须使用显式转换，即<strong>强制转换表达式 cast expression</strong> 。如果使用强制转换表达式，意味着要承担操作后引起的数据丢失的后果，如下图：</p><div  align="center">  <img src="https://s2.loli.net/2023/02/07/PR4sMQimxULHn2G.png" width = "80%" height = "80%" alt="图77 - 强制把ushort转换为byte"/></div><h2 id="转换的类型"><a href="#转换的类型" class="headerlink" title="转换的类型"></a>转换的类型</h2><p>①除了标准转换，还可以为用户自定义类型定义隐式类型和显式类型；<br>②还有一个预定义的转换类型，叫<strong>装箱 boxing</strong>，它可以将任何值类型转换为 object 类型或 System.ValueType 类型；<br>③<strong>拆箱 unboxing</strong> 可以将一个装箱的值转换为原始类型。</p><div  align="center">  <img src="https://s2.loli.net/2023/02/07/9HB1i2WA7ZLVNgx.png" width = "50%" height = "50%" alt="图78 - 转换的类型"/></div><h2 id="数字的转换"><a href="#数字的转换" class="headerlink" title="数字的转换"></a>数字的转换</h2><p>任何数字类型都可以转换为其他数字类型，一些转换是隐式的，另外一些转换必须是显式的。</p><h3 id="隐式数字转换"><a href="#隐式数字转换" class="headerlink" title="隐式数字转换"></a>隐式数字转换</h3><p>如下图，若存在箭头，则存在从源类型到目标类型的隐式转换；若不存在，则需要使用显式转换：</p><div  align="center">  <img src="https://s2.loli.net/2023/02/07/TU3OPZ8YMIkptVy.png" width = "45%" height = "45%" alt="图79 - 隐式数字转换"/></div><h3 id="溢出检测上下文"><a href="#溢出检测上下文" class="headerlink" title="溢出检测上下文"></a>溢出检测上下文</h3><p>对于整数类型（包括sbyte、byte、short、ushort、int、uint、long、ulong），C# 允许选择运行时是否应该在进行类型转换时检测溢出，可以通过 <strong>checked 运算符</strong>和 <strong>checked 语句</strong>来实现。</p><p>代码片段无论是否被检测都称为<strong>溢出检测上下文 overflow checking context</strong> 。默认的溢出检测上下文是不检查。<br>①如果我们指定一个表达式或一段代码为 checked ，CLR 会在转换产生溢出时抛出一个 OverflowException 异常；<br>②如果代码不是 checked ，转换会继续而不管是否溢出。</p><p><strong><em>1、checked 和 unchecked 运算符</em></strong><br>checked 和 unchecked 运算符控制表达式的溢出检测上下文，表达式放置在一对圆括号内，并且不能是一个方法：<code>checked ( Expression )</code> 或 <code>unchecked ( Expression )</code>。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ushort</span> sh = <span class="number">2000</span>;</span><br><span class="line"><span class="built_in">byte</span> sb;</span><br><span class="line"></span><br><span class="line">sb = <span class="keyword">unchecked</span> ( (<span class="built_in">byte</span>) sh ); <span class="comment">//忽略溢出</span></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;sb: <span class="subst">&#123; sb &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">sb = checked ( (<span class="built_in">byte</span>) sh ); <span class="comment">//抛出 OverflowException 异常</span></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;sb: <span class="subst">&#123; sb &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">sb: 208</span><br><span class="line">Unhandled exception. System.OverflowException: Arithmetic operation resulted in an overflow.</span><br></pre></td></tr></table></figure><p><strong><em>2、checked 语句和 unchecked 语句</em></strong><br>checked 语句和 unchecked 语句控制的是一块代码中的所有转换，而不是单个表达式。它们可以被嵌套在任意层次，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">byte</span> sb;</span><br><span class="line"><span class="built_in">ushort</span> sh = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">checked</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unchecked</span></span><br><span class="line">    &#123;</span><br><span class="line">        sb = (<span class="built_in">byte</span>) sh;</span><br><span class="line">        Console.WriteLine( <span class="string">$&quot;sb: <span class="subst">&#123; sb &#125;</span>&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sb = checked((<span class="built_in">byte</span>) sh);</span><br><span class="line">    Console.WriteLine( <span class="string">$&quot;sb: <span class="subst">&#123; sb &#125;</span>&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果与上面相同，只不过这里影响的是一段代码而不是一个表达式。</p><h3 id="显式数字转换"><a href="#显式数字转换" class="headerlink" title="显式数字转换"></a>显式数字转换</h3><p><strong><em>1、整数类型到整数类型</em></strong><br>如果转换会丢失数据，checked ：OverflowException 异常；unchecked ：丢失的位不会发出警告。</p><p><strong><em>2、float 或 double 转到整数类型</em></strong><br>当把浮点类型转换为整数类型时，值会舍掉小数点，截断为最接近的整数。如果截断后的值不在目标类型的范围内：checked ：OverflowException 异常；unchecked ：C# 将不定义它的值应该是什么。</p><p><strong><em>3、decimal 到整数类型</em></strong><br>如果结果值不在目标类型的范围内，CLR 会抛出 OverflowException 异常。</p><p><strong><em>4、double 到 float</em></strong><br>float 类型的值占32位，而 double 类型的值占64位。double 类型的值被舍入到最接近的 float 类型的值。①如果值太小而不能用 float 表示，那么值会被设置为正或负0；②如果值太大而不能用 float 表示，那么值会被设置为正无穷大或负无穷大。</p><p><strong><em>5、float 或 double 到 decimal</em></strong><br>如果值太小而不能用 decimal 类型表示，那么值会被设置为0；如果值太大，那么 CLR 会抛出 OverflowException 异常。</p><p><strong><em>6、decimal 到 float 或 double</em></strong><br>从 decimal 类型转换到浮点数类型总会成功，然而可能会损失精度，即截断值到最接近的 float 或 double 值。</p><h2 id="引用转换"><a href="#引用转换" class="headerlink" title="引用转换"></a>引用转换</h2><p>引用转换接受源引用并返回一个指向堆中同一位置的引用，只是把引用“标记”为其他类型。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field1; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field2; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        B myVar1 = <span class="keyword">new</span> B();</span><br><span class="line">        A myVar2 = (A) myVar1; <span class="comment">//返回指向myVar1的引用作为A类的引用</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; myVar2.Field1 &#125;</span>&quot;</span>); <span class="comment">//正确</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; myVar2.Field2 &#125;</span>&quot;</span>); <span class="comment">//编译错误，Field2对myVar2不可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/02/08/doaBWsuXMOmgbS3.png" width = "70%" height = "70%" alt="图80 - 引用转换返回与对象关联的不同类型"/></div><p>对于 myVar2 ，它实际上指向 B 类型的对象，但它看不到 B 扩展 A 部分，因此看不到 Field2 。</p><h3 id="隐式引用转换"><a href="#隐式引用转换" class="headerlink" title="隐式引用转换"></a>隐式引用转换</h3><p>①所有引用类型可以被隐式转换为 object 类型；<br>②任何接口可以隐式转换为它继承的接口；<br>③类可以隐式转换为它继承链中任何的类以及它实现的任何接口。<br>④委托可以隐式转换成如下图所示的 .NET BCL 类和接口：<br>⑤ Array 数组，比如下图的 ArrayS 数组（S for source，其中元素为 Ts 类型），可以隐式转换为如下图所示的 .NET BCL 类和接口，或者另一个数组，比如下图的 ArrayT 数组（T for target，其中元素为 Tt 类型）， ArrayT 数组必须满足：两个数组维度一样；Ts 和 Tt 都是引用类型；Ts 和 Tt 之间存在隐式转换。</p><div  align="center">  <img src="https://s2.loli.net/2023/02/08/CZ1hvJaREHfVLxq.png" width = "70%" height = "70%" alt="图81 - 委托和数组的隐式转换"/></div><h3 id="显式引用转换"><a href="#显式引用转换" class="headerlink" title="显式引用转换"></a>显式引用转换</h3><p>上面所述隐式转换的相反转换，需要显式引用转换，比如从 object 到任何引用类型的转换或从基类到派生自它的类的转换。</p><p>但是如果转换的类型没有限制，可能会导致尝试去引用内存中实际不存在的类成员，虽然编译器允许这样的转换，但如果运行时遇到它们，会抛出异常，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field1; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field2; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        A myVar1 = <span class="keyword">new</span> A();</span><br><span class="line">        B myVar2 = (B) myVar1; <span class="comment">//在运行时抛出InvalidCastException异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①若 myVar2 尝试访问 Field2，它会尝试访问对象中“ B 部分”（不在内存中），这会导致内存错误；<br>②运行时会捕获这种错误的强制转换并抛出 InvalidCastException 异常，它不会导致编译错误。</p><div  align="center">  <img src="https://s2.loli.net/2023/02/08/o2MAUtmqbWfQEVK.png" width = "40%" height = "40%" alt="图82 - 无效的转换抛出运行时异常"/></div><h3 id="有效显式引用转换"><a href="#有效显式引用转换" class="headerlink" title="有效显式引用转换"></a>有效显式引用转换</h3><p>在运行时能够成功进行的显式转换有以下3种情况：</p><p>第一种情况：显式转换没有必要，即可以隐式转换的情况，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field1; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field2; &#125;</span><br><span class="line">...</span><br><span class="line">B myVar1 = <span class="keyword">new</span> B();</span><br><span class="line">A myVar2 = (A) myVar1; <span class="comment">//不必转换，因为A是B的基类</span></span><br></pre></td></tr></table></figure><p>第二种情况：源引用是 null 。即使转换基类的引用到派生类的引用通常是不安全的，但是由于源引用是 null ，这种转换是允许的，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field1; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field2; &#125;</span><br><span class="line">...</span><br><span class="line">A myVar1 = <span class="literal">null</span>;</span><br><span class="line">B myVar2 = (B) myVar1; <span class="comment">//允许转换，因为myVar1为空</span></span><br></pre></td></tr></table></figure><p>第三种情况：源引用指向的实际数据安全地进行隐式转换后，可以转回原类型：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field1; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Field2; &#125;</span><br><span class="line">...</span><br><span class="line">B myVar1 = <span class="keyword">new</span> B();</span><br><span class="line">A myVar2 = myVar1; <span class="comment">//将myVar1隐式转换为A类型</span></span><br><span class="line">B myVar3 = (B) myVar2; <span class="comment">//该转换是允许的，因为数据是B类型的</span></span><br></pre></td></tr></table></figure><p>①第二行隐式转换，看似使 myVar2 指向 A 类型的数据，实际上指向的是 B 类型的数据；<br>②第三行中的显式转换把基类引用强制转换为它的派生类的引用，这通常会产生异常，但这里由于指向的对象实际就是 B 类型的数据项，所以允许转换。</p><div  align="center">  <img src="https://s2.loli.net/2023/02/08/PWS8RLs9tgQHX4K.png" width = "70%" height = "70%" alt="图83 - 强制转换到安全类型"/></div><h2 id="装箱变换-Boxing-Conversions"><a href="#装箱变换-Boxing-Conversions" class="headerlink" title="装箱变换 Boxing Conversions"></a>装箱变换 Boxing Conversions</h2><p>所有 C# 类型都派生自 object 类型，包括值类型，虽然 object 本身是引用类型。值类型在默认情况下在堆上不包括它们的对象组件，可以使用<strong>装箱 boxing</strong>（一种隐式转换），接受值类型，根据这个值在堆上创建一个完整的引用类型对象并返回对象引用，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">object</span> oi = <span class="literal">null</span>;</span><br><span class="line">oi = i;</span><br></pre></td></tr></table></figure><p>系统将 i 的值装箱如下：<br>①在堆上创建了 int 类型的对象；<br>②将 i 的值复制到 int 对象；<br>③返回 int 对象的引用，让 oi 作为引用保存。</p><div  align="center">  <img src="https://s2.loli.net/2023/02/10/tIpGFHRgKxdLfVZ.png" width = "30%" height = "30%" alt="图84 - 装箱从值类型创建了完整的引用类型"/></div><h3 id="装箱是创建副本"><a href="#装箱是创建副本" class="headerlink" title="装箱是创建副本"></a>装箱是创建副本</h3><p>装箱后返回的是值的引用类型副本。原始值类型和引用类型副本都可以独立操作，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">object</span> oi = i;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;i: <span class="subst">&#123; i &#125;</span>, io: <span class="subst">&#123; oi &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">i = <span class="number">12</span>;</span><br><span class="line">oi = <span class="number">15</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;i: <span class="subst">&#123; i&#125;</span>, io: <span class="subst">&#123;oi &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">i: 10, io: 10</span><br><span class="line">i: 12, io: 15</span><br></pre></td></tr></table></figure><h3 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h3><p>任何值类型 ValueTypeS 都可以被隐式转换为 object、System.ValueType 或 InterfaceT 类型（如果 ValueTypeS 实现了 InterfaceT ）。</p><h2 id="拆箱转换-Unboxing-Conversions"><a href="#拆箱转换-Unboxing-Conversions" class="headerlink" title="拆箱转换 Unboxing Conversions"></a>拆箱转换 Unboxing Conversions</h2><p><strong>拆箱 unboxing</strong> 是把装箱后的对象转换回值类型的过程：<br>①拆箱是显式转换；<br>②系统在把值拆箱成 ValueTypeT 时执行了如下的步骤：<br>&ensp;&ensp;&ensp;&ensp;- 它检测到要拆箱的对象实际是 ValueTypeT 的装箱值；<br>&ensp;&ensp;&ensp;&ensp;- 它把对象的值复制到变量。  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">object</span> oi = i; <span class="comment">//对i装箱并把引用赋值给oi</span></span><br><span class="line">    <span class="built_in">int</span> j = (<span class="built_in">int</span>) oi; <span class="comment">//对oi拆箱并把值赋值给j</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;i: <span class="subst">&#123; i &#125;</span>, oi: <span class="subst">&#123; oi &#125;</span>, j: <span class="subst">&#123; j &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">i: 10, oi: 10, j: 10</span><br></pre></td></tr></table></figure><p>尝试将一个值拆箱为非原始类型时，会抛出 InvalidCastException 异常。</p><h2 id="用户自定义转换"><a href="#用户自定义转换" class="headerlink" title="用户自定义转换"></a>用户自定义转换</h2><p>除了标准转换外，可以为类或结构定义隐式和显式转换。</p><p>用户自定义转换的语法如下：<br>①除了 <strong>implicit</strong> 或 <strong>explicit 关键字</strong>外，隐式转换和显式转换的声明语法是一样的；<br>②需要 <strong>public</strong> 和 <strong>static 修饰符</strong>。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">TargetType</span> (<span class="params"> SourceType Identifier </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ObjectOfTargetType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户自定义转换的约束"><a href="#用户自定义转换的约束" class="headerlink" title="用户自定义转换的约束"></a>用户自定义转换的约束</h3><p>①只可以为类或结构定义用户自定义转换；<br>②不能重定义标准隐式或显式转换；<br>③对于源类型 S 和目标类型 T：S 和 T 必须是不同类型。S 和 T 不能通过继承关联，即 S 不能派生自 T，而 T 也不能派生自 S 。S 和 T 都不能是接口类型或者 object 类型。转换运算符必须是 S 或 T 的成员；<br>④不能同时对同一源和目标类型声明两种转换，即不能同时声明隐式和显式转换。</p><h3 id="用户自定义转换的示例"><a href="#用户自定义转换的示例" class="headerlink" title="用户自定义转换的示例"></a>用户自定义转换的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">Person p</span>) <span class="comment">//将Person转换为int</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p.Age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> i</span>) <span class="comment">//将int转换为Person</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;Nemo&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person bill = <span class="keyword">new</span> Person( <span class="string">&quot;bill&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> age = bill; <span class="comment">//把Person对象转换为int</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Person Info: <span class="subst">&#123; bill.Name &#125;</span>, <span class="subst">&#123; age &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Person anon = <span class="number">35</span>; <span class="comment">//把int转换为Person对象</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Person Info: <span class="subst">&#123; anon.Name &#125;</span>, <span class="subst">&#123; anon.Age &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Person Info: bill, 25</span><br><span class="line">Person Info: Nemo, 35</span><br></pre></td></tr></table></figure><p>如果使用 explicit 运算符来定义相同转换，需要使用强制转换表达式来进行转换：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params"> Person p </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p.Age;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">int</span> age = (<span class="built_in">int</span>) bill;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多步用户自定义转换"><a href="#多步用户自定义转换" class="headerlink" title="多步用户自定义转换"></a>多步用户自定义转换</h3><p>上面讨论的用户自定义转换都是单步内直接把源类型转换为目标类型对象。但是，用户自定义转换在完整转换中最多可以有3个步骤：①预备标准转换；②用户自定义转换；③后续标准转换。这个链不可能有一个以上的用户自定义转换。</p><div  align="center">  <img src="https://s2.loli.net/2023/02/10/WF45ydOzgBiUC1s.png" width = "70%" height = "70%" alt="图85 - 多步用户自定义转换"/></div><h3 id="多步用户自定义转换的示例"><a href="#多步用户自定义转换的示例" class="headerlink" title="多步用户自定义转换的示例"></a>多步用户自定义转换的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span> : <span class="title">Person</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Person对象转换为int</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">Person p</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p.Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Employee bill = <span class="keyword">new</span> Employee();</span><br><span class="line">        bill.Name = <span class="string">&quot;William&quot;</span>;</span><br><span class="line">        bill.Age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> fVar = bill; <span class="comment">//把Employee转换为float</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Person Info: <span class="subst">&#123; bill.Name &#125;</span>, <span class="subst">&#123; fVar &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Person Info: William, 25</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/02/10/9CGMNEyoaBWYen7.png" width = "70%" height = "70%" alt="图86 - 从Employee转换为float"/></div><p>①上述代码声明了一个从 Person 类到 int 的用户自定义转换。由于从 Employee 到 Person 以及从 int 到 float 有标准转换，所以可以直接从 Employee 转换到 float ：<br>&ensp;&ensp;&ensp;&ensp;- 由于 Employee 继承自 Person，从Employee 到 Person 有标准转换；<br>&ensp;&ensp;&ensp;&ensp;- 从 int 到 float 有隐式数字转换，也是标准转换。<br>②由于链中的3个部分都存在，所以可以从 Employee 转换到 float 。</p><h2 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h2><p>可以使用 <strong>is 运算符</strong>来检查转换是否会成功完成。is 运算符的语法如下，其中 Expr 是源表达式：<code>Expr is TargetType</code>，该表达式返回 bool 类型。</p><p>如果 Expr 可以通过以下方式成功转换为目标类型，则运算符返回 true ：①引用转换；②装箱转换；③拆箱转换。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span> : <span class="title">Person</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name = <span class="string">&quot;Anonymous&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Employee bill = <span class="keyword">new</span> Employee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检测变量bill是否能转换为Person类型</span></span><br><span class="line">        <span class="keyword">if</span>( bill <span class="keyword">is</span> Person )</span><br><span class="line">        &#123;</span><br><span class="line">            Person p = bill;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Person Info: <span class="subst">&#123; p.Name &#125;</span>, <span class="subst">&#123; p.Age &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>is 运算符只可以用于引用转换以及装箱和拆箱转换，不能用于用户自定义转换。</p><h2 id="as-运算符"><a href="#as-运算符" class="headerlink" title="as 运算符"></a>as 运算符</h2><p><strong>as 运算符</strong>和强制转换运算符类似，只是不抛出异常，如果转换失败，它返回 null 。as 运算符的语法如下，其中 Expr 是源表达式，TargetType 是目标类型，它必须是引用类型：<code>Expr as TargetType</code>。</p><p>由于 as 运算符返回引用表达式，它可以用作赋值操作中的源，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span> : <span class="title">Person</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name = <span class="string">&quot;Anonymous&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    Employee bill = <span class="keyword">new</span> Employee();</span><br><span class="line">    Person p;</span><br><span class="line"></span><br><span class="line">    p = bill <span class="keyword">as</span> Person;</span><br><span class="line">    <span class="keyword">if</span>( p != <span class="literal">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Person Info: <span class="subst">&#123; p.Name &#125;</span>, <span class="subst">&#123; p.Age &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>as 运算符只可以用于引用转换以及装箱转换，不能用于用户自定义转换或到值类型的转换。</p><h1 id="第十八章-泛型"><a href="#第十八章-泛型" class="headerlink" title="第十八章 泛型"></a>第十八章 泛型</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>到现在为止，所有在类声明中用到的类型都是特定的类型，要么是程序员定义的，要么是语言或 BCL 定义的。然而，很多时候，我们需要把类的行为提取或重构出来，使之不仅能用到它们编码的数据类型上，还能应用到其他类型上。<strong>泛型 generics</strong>可以做到这一点，我们可以重构代码并额外增加一个抽象层，数据类型就不用硬编码了。这是专门为多段代码在不同的数据类型上执行相同指令的情况专门设计的。</p><h3 id="一个栈的示例"><a href="#一个栈的示例" class="headerlink" title="一个栈的示例"></a>一个栈的示例</h3><p>如下，声明了 MyIntStack 的类，实现了一个 int 类型的栈，允许我们把 int 压入栈中，或弹出：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyIntStack</span> <span class="comment">//int类型的栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> StackPointer = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span>[] StackArray; <span class="comment">//int类型的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"> <span class="built_in">int</span> x </span>)</span> &#123; ... &#125; <span class="comment">//输入类型：int</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Pop</span>()</span> &#123; ... &#125; <span class="comment">//返回类型：int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果希望相同的功能应用于 float 类型的值，其中一种方式是剪切并粘贴 MyIntStack 类的代码，把类名改为 MyFloatStack ，把整个类声明中相应的 int 声明改为 float 声明。</p><p>这个方法可行，但是有很多缺点：需要仔细检查类的每一个部分来看哪些类型的声明需要修改，哪些需要保留；每次需要新类型的栈类时，需要重复这个过程，这就意味着具有很多相同代码的副本，占据了额外空间；并且很难调试和维护，修复问题需要一个个修改，很麻烦。</p><h2 id="C-中的泛型"><a href="#C-中的泛型" class="headerlink" title="C# 中的泛型"></a>C# 中的泛型</h2><p><strong>泛型 generics</strong>可以让多个类型共享一组代码。泛型允许声明<strong>类型参数化 type-parameterized</strong> 的代码，用不同类型进行实例化。即可以使用<strong>类型占位符 placeholders for types</strong> 来写代码，然后在创建类的实例时指明真实的类型。</p><p><strong><em>类型不是对象，而是对象或者实例的模板；而泛型类型不是类型，而是类型的模板。</em></strong></p><p>C# 提供了5种泛型：类、结构、接口、委托和方法。</p><div  align="center">  <img src="https://s2.loli.net/2023/02/11/k1o2XvBEa9MnHPs.png" width = "50%" height = "50%" alt="图87 - 泛型和用户定义类型"/></div><h3 id="继续栈的示例"><a href="#继续栈的示例" class="headerlink" title="继续栈的示例"></a>继续栈的示例</h3><p>通过以下步骤可以从 MyIntStack 创建一个泛型类，T 为标识符：<br>①使用类型占位符 T 而不是 int 或 float 等；<br>②修改类名称为 Mystack ；<br>③在类名后放置 <code>&lt;T&gt;</code>。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> StackPointer = <span class="number">0</span>;</span><br><span class="line">    T [] StackArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params">T x </span>)</span> &#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Pop</span>()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>创建和使用非泛型的类有2个步骤：声明类和创建类的实例。但是泛型类是类的模板，所以要先从泛型类构建实际的类类型，然后创建这个类类型的引用和实例。步骤如下：<br>①使用占位符声明泛型类型；<br>②为占位符提供真实类型，通过提供真实类型创建<strong>构造类型 constructed type</strong> ;<br>③创建构造类型的实例。</p><h3 id="声明泛型类"><a href="#声明泛型类" class="headerlink" title="声明泛型类"></a>声明泛型类</h3><p>声明一个泛型类和声明普通类差不多，区别如下：<br>①在类名后放置一组尖括号，在尖括号中用逗号分隔的占位符字符串表示需要提供的类型，叫做<strong>类型参数 type parameters</strong> 。<br>②在泛型类声明的主体中使用参数类型来表示替代的类型。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span> &lt; <span class="title">T1</span>, <span class="title">T2</span> &gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T1 SomeVar;</span><br><span class="line">    <span class="keyword">public</span> T2 OtherVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建构造类型"><a href="#创建构造类型" class="headerlink" title="创建构造类型"></a>创建构造类型</h3><p>一旦声明了泛型类型，我们需要告诉编译器能使用哪些真实类型来替代占位符（类型参数）。编译器获取真实类型并创建构建类型（用来创建真实类对象的模板）。</p><p>创建构建类型语法：<code>SomeClass&lt; short, int &gt;</code>，替代类型参数的真实类型叫做<strong>类型实参 type argument</strong> 。编译器接受了类型实参并且替代泛型类主体中的相应类型参数，产生了构造类型，然后通过构造类型创建真实类型的实例。</p><h3 id="创建变量和实例"><a href="#创建变量和实例" class="headerlink" title="创建变量和实例"></a>创建变量和实例</h3><p>在创建引用和实例方面，构造类类型和常规类型差不多，如下：<br>①第一行显示了普通非泛型类型对象的创建；<br>②第二行显示了泛型类型的创建；<br>③第三行用 var 关键字让编译器使用类型引用。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyNonGenClass         myNGC = <span class="keyword">new</span> MyNonGenClass        ();</span><br><span class="line">SomeClass&lt;<span class="built_in">short</span>, <span class="built_in">int</span>&gt; mySc1 = <span class="keyword">new</span> SomeClass&lt;<span class="built_in">short</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="keyword">var</span>                   mySc2 = <span class="keyword">new</span> SomeClass&lt;<span class="built_in">short</span>, <span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><p>和非泛型类一样，引用和实例可以分开创建，如下：<br>①泛型类声明下面的第一行在栈上为 myInst 分配了一个引用，值为 null ；<br>②第二行在堆上分配实例，并且把引用赋值给变量。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span> &lt; <span class="title">T1</span>, <span class="title">T2</span> &gt; <span class="comment">//泛型类声明</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T1 SomeVar;</span><br><span class="line">    <span class="keyword">public</span> T2 OtherVar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SomeClass&lt;<span class="built_in">short</span>, <span class="built_in">int</span>&gt; myInst; <span class="comment">//分配类变量</span></span><br><span class="line">myInst = <span class="keyword">new</span> SomeClass&lt;<span class="built_in">short</span>, <span class="built_in">int</span>&gt;(); <span class="comment">//分配实例</span></span><br></pre></td></tr></table></figure><p>可以从同一个泛型类构建出很多不同的类类型，每一个都是独立的类类型。</p><h3 id="使用泛型的栈的示例"><a href="#使用泛型的栈的示例" class="headerlink" title="使用泛型的栈的示例"></a>使用泛型的栈的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T[] StackArray;</span><br><span class="line">    <span class="built_in">int</span> StackPointer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params">T x</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !IsStackFull )</span><br><span class="line">            StackArray[StackPointer++] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Pop</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ( !IsStackEmpty )</span><br><span class="line">            ? StackArray[--StackPointer]</span><br><span class="line">            : StackArray[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MaxStack = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">bool</span> IsStackFull &#123; <span class="keyword">get</span>&#123; <span class="keyword">return</span> StackPointer &gt;= MaxStack; &#125; &#125;</span><br><span class="line">    <span class="built_in">bool</span> IsStackEmpty &#123; <span class="keyword">get</span>&#123; <span class="keyword">return</span> StackPointer &lt;= <span class="number">0</span>; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StackArray = <span class="keyword">new</span> T[MaxStack];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = StackPointer<span class="number">-1</span>; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot; Value: <span class="subst">&#123; StackArray[i] &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyStack&lt;<span class="built_in">int</span>&gt; StackInt = <span class="keyword">new</span> MyStack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        MyStack&lt;<span class="built_in">string</span>&gt; StackString = <span class="keyword">new</span> MyStack&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">        StackInt.Push(<span class="number">3</span>);</span><br><span class="line">        StackInt.Push(<span class="number">5</span>);</span><br><span class="line">        StackInt.Push(<span class="number">7</span>);</span><br><span class="line">        StackInt.Push(<span class="number">9</span>);</span><br><span class="line">        StackInt.Print();</span><br><span class="line"></span><br><span class="line">        StackString.Push(<span class="string">&quot;This is fun&quot;</span>);</span><br><span class="line">        StackString.Push(<span class="string">&quot;Hi there! &quot;</span>);</span><br><span class="line">        StackString.Print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Value: 9</span><br><span class="line">Value: 7</span><br><span class="line">Value: 5</span><br><span class="line">Value: 3</span><br><span class="line">Value: Hi there!</span><br><span class="line">Value: This is fun</span><br></pre></td></tr></table></figure><h2 id="类型参数的约束"><a href="#类型参数的约束" class="headerlink" title="类型参数的约束"></a>类型参数的约束</h2><p>上述泛型栈的示例，没有做其他需要用到项本身的运算符的事情，因为泛型栈不知道它们保存的项的类型是什么，也就不知道这些项实现的成员。然而，由于 C# 对象都是从 object 继承，所以这些保存的项实现了 object 类的成员，包括 ToString、Equals 以及 GetType 方法，除此之外，它不知道还有哪些成员可用。</p><p>只要代码不访问它处理的一些类型的对象，泛型类就可以处理任意类型。符合这种约束的类型参数称为<strong>未绑定的类型参数 unbounded type parameters</strong> 。但是如果代码尝试访问其他成员，编译器会产生一个错误消息，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Simple</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">LessThan</span>(<span class="params">T i1, T i2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i1 &lt; i2; <span class="comment">//错误，因为不是所有类型都实现了小于运算符</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要让泛型变得更有用，需要提供额外的信息让编译器知道参数可以接受哪些类型，这种额外信息叫做<strong>约束 constraint</strong> 。只有符合约束的类型才能替代给定的类型参数来产生构造类型。</p><h3 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h3><p>约束使用 <strong>where 子句</strong>列出：<br>①每一个有约束的类型参数都有自己的 where 子句；<br>②如果参数有多个约束，它们在 where 子句中使用逗号分隔。</p><p>语法：<code>where TypeParam : constraint, constraint, ...</code></p><p>关于 where 子句的事项如下：<br>①它们在类型参数列表的关闭尖括号之后列出；<br>②不使用分隔符；<br>③可以以任意次序列出；<br>④ where 是上下文关键字，所以可以在其他上下文中使用。</p><p>如下泛型类有3个类型参数，T1 是未绑定的类型参数。对于 T2 ，只有 Customer 类型的类或从 Customer 派生的类才能用作类型实参。对于 T3 ，只有实现 IComparable 接口的类才能用作类型实参：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &lt; <span class="title">T1</span>, <span class="title">T2</span>, <span class="title">T3</span> &gt;</span><br><span class="line">                <span class="keyword">where</span> <span class="title">T2</span>: <span class="title">Customer</span> <span class="comment">//T2的约束</span></span><br><span class="line">                <span class="keyword">where</span> <span class="title">T3</span>: <span class="title">IComparable</span> <span class="comment">//T3的约束</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约束类型和次序"><a href="#约束类型和次序" class="headerlink" title="约束类型和次序"></a>约束类型和次序</h3><p>共有5种约束类型，如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">约束类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">类名 ClassName</td><td style="text-align:left">只有这个类型的类或从它派生的类才能用作类型实参</td></tr><tr><td style="text-align:left">class</td><td style="text-align:left">任何引用类型，包括类、数组、委托和接口都可以用作类型实参</td></tr><tr><td style="text-align:left">struct</td><td style="text-align:left">任何值类型都可以用作类型实参</td></tr><tr><td style="text-align:left">接口名 InterfaceName</td><td style="text-align:left">只有这个接口或实现这个接口的类型才能用作类型实参，约束接口也可以是泛型的</td></tr><tr><td style="text-align:left">new( )</td><td style="text-align:left">任何带有无参公共构造函数的类型都可以用作类型实参。这叫构造函数约束</td></tr></tbody></table></div><p>where 子句可以以任意次序列出。然而，where 子句中的约束必须有特定的顺序：<br>①最多只能有一个主约束，而且放在第一位；<br>②可以有任意多的接口名称约束；<br>③如果存在构造函数约束，则必须放在后面。</p><div  align="center">  <img src="https://s2.loli.net/2023/02/14/hKjGeR4WStPpiqY.png" width = "50%" height = "50%" alt="图88 - 如果类型参数有多个约束，必须遵循这个顺序"/></div><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SortedList</span>&lt;<span class="title">S</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="title">S</span>: <span class="title">IComparable</span>&lt;<span class="title">S</span>&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">M</span>,<span class="title">N</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="title">M</span> : <span class="title">IComparable</span>&lt;<span class="title">M</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="title">N</span> : <span class="title">ICloneable</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDictionary</span>&lt;<span class="title">KeyType</span>, <span class="title">ValueType</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="title">KeyType</span> : <span class="title">IEnumerable</span>,</span><br><span class="line">    <span class="title">new</span>()               &#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>与其他泛型不同，方法是成员，不是类型。<strong>泛型方法</strong>可以在泛型类和非泛型类以及结构和接口中声明。</p><h3 id="声明泛型方法"><a href="#声明泛型方法" class="headerlink" title="声明泛型方法"></a>声明泛型方法</h3><p>泛型方法有两个参数列表和可选的约束，包括封闭在圆括号里的方法参数列表和封闭在尖括号的类型参数列表。要声明泛型方法，在方法名和方法参数列表中间放置类型参数列表，方法参数列表后放置可选的约束子句。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintData</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; (<span class="params"> S p, T t </span>) <span class="keyword">where</span> S: Person</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用泛型方法"><a href="#调用泛型方法" class="headerlink" title="调用泛型方法"></a>调用泛型方法</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoStuff</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt;(<span class="params"> T1 t1, T2 t2 </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    T1 someVar = t1;</span><br><span class="line">    T2 otherVar = t2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DoStuff&lt;<span class="built_in">short</span>, <span class="built_in">int</span>&gt;( sVal, iVal ); <span class="comment">//调用泛型方法</span></span><br><span class="line">DoStuff&lt;<span class="built_in">int</span>, <span class="built_in">long</span>&gt;( iVal, lVal ); <span class="comment">//调用泛型方法</span></span><br></pre></td></tr></table></figure><p>如果我们为方法传入参数，编译器有时可以从方法参数的类型中推断出类型参数的类型。如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyMethod</span> &lt;T&gt; (<span class="params">T myVal</span>)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> myInt = <span class="number">5</span>;</span><br><span class="line">MyMethod &lt;<span class="built_in">int</span>&gt; (myInt); <span class="comment">//两个都是int，类型参数的信息就多余了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于编译器可以从方法参数中推断出类型参数，可以省略类型参数和调用中的尖括号</span></span><br><span class="line">MyMethod(myInt);</span><br></pre></td></tr></table></figure><h3 id="泛型方法的示例"><a href="#泛型方法的示例" class="headerlink" title="泛型方法的示例"></a>泛型方法的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Simple</span> <span class="comment">//非泛型类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReverseAndPrint</span>&lt;<span class="title">T</span>&gt;(<span class="params">T[] arr</span>) <span class="comment">//泛型方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Array.Reverse(arr);</span><br><span class="line">        <span class="keyword">foreach</span> (T item <span class="keyword">in</span> arr) <span class="comment">//使用类型参数T</span></span><br><span class="line">            Console.Write( <span class="string">$&quot;<span class="subst">&#123;item.ToString()&#125;</span>, &quot;</span> );</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建各种类型的数组</span></span><br><span class="line">        <span class="keyword">var</span> intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span> &#125;;</span><br><span class="line">        <span class="keyword">var</span> stringArray = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;first&quot;</span>, <span class="string">&quot;second&quot;</span>, <span class="string">&quot;third&quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">var</span> doubleArray = <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">3.567</span>, <span class="number">7.891</span>, <span class="number">2.345</span> &#125;;</span><br><span class="line"></span><br><span class="line">        Simple.ReverseAndPrint&lt;<span class="built_in">int</span>&gt;(intArray);</span><br><span class="line">        Simple.ReverseAndPrint(intArray);</span><br><span class="line"></span><br><span class="line">        Simple.ReverseAndPrint&lt;<span class="built_in">string</span>&gt;(stringArray);</span><br><span class="line">        Simple.ReverseAndPrint(stringArray);</span><br><span class="line"></span><br><span class="line">        Simple.ReverseAndPrint&lt;<span class="built_in">double</span>&gt;(doubleArray);</span><br><span class="line">        Simple.ReverseAndPrint(doubleArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">11, 9, 7, 5, 3, </span><br><span class="line">3, 5, 7, 9, 11,</span><br><span class="line">third, second, first,</span><br><span class="line">first, second, third,</span><br><span class="line">2.345, 7.891, 3.567, </span><br><span class="line">3.567, 7.891, 2.345,</span><br></pre></td></tr></table></figure><h2 id="扩展方法和泛型类"><a href="#扩展方法和泛型类" class="headerlink" title="扩展方法和泛型类"></a>扩展方法和泛型类</h2><p>第8章介绍了扩展方法，它也可以与泛型类结合使用。它允许将类中的静态方法关联到不同的泛型类上，还允许像调用类实例方法来调用方法。和非泛型类一样，泛型类的扩展方法必须声明为 static ，必须是静态类的成员，第一个参数类型中必须有关键字 this ，后面是扩展的泛型类名字。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ExtendHolder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> Holder&lt;T&gt; h</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        T[] vals = h.GetValues();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; vals[<span class="number">0</span>] &#125;</span>,\t<span class="subst">&#123; vals[<span class="number">1</span>] &#125;</span>,\t<span class="subst">&#123; vals[<span class="number">2</span>] &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T[] Vals = <span class="keyword">new</span> T[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span>(<span class="params">T v0, T v1, T v2</span>)</span></span><br><span class="line">    &#123; Vals[<span class="number">0</span>] = v0; Vals[<span class="number">1</span>] = v1; Vals[<span class="number">2</span>] = v2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T[] <span class="title">GetValues</span>()</span> &#123; <span class="keyword">return</span> Vals; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> intHolder = <span class="keyword">new</span> Holder&lt;<span class="built_in">int</span>&gt;(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">var</span> stringHolder = <span class="keyword">new</span> Holder&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;c3&quot;</span>);</span><br><span class="line">        intHolder.Print();</span><br><span class="line">        stringHolder.Print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">3,      5,      7</span><br><span class="line">a1,     b2,     c3</span><br></pre></td></tr></table></figure><h2 id="泛型结构"><a href="#泛型结构" class="headerlink" title="泛型结构"></a>泛型结构</h2><p>泛型结构的规则与泛型类一样。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> PieceOfData&lt;T&gt; <span class="comment">//泛型结构</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PieceOfData</span>(<span class="params">T <span class="keyword">value</span></span>)</span> &#123; _data = <span class="keyword">value</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> T _data;</span><br><span class="line">    <span class="keyword">public</span> T Data</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _data; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _data = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> intData = <span class="keyword">new</span> PieceOfData&lt;<span class="built_in">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">var</span> stringData = <span class="keyword">new</span> PieceOfData&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Hi there.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;intData = <span class="subst">&#123; intData.Data &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;stringData = <span class="subst">&#123; stringData.Data &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">intData = 10</span><br><span class="line">stringData = Hi there.</span><br></pre></td></tr></table></figure><h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><p>声明泛型委托的语法：<code>delegate R MyDelegate&lt;T, R&gt;( T value );</code>，其中 R 为返回类型，<code>&lt;T, R&gt;</code>为类型参数，<code>( T value )</code>为委托形参。T 与 R 都为类型占位符。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span>;  <span class="comment">//泛型委托</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Simple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintString</span>(<span class="params"><span class="built_in">string</span> s</span>) <span class="comment">//方法匹配委托</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( s );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintUpperString</span>(<span class="params"><span class="built_in">string</span> s</span>) <span class="comment">//方法匹配委托</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; s.ToUpper() &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> myDel = <span class="keyword">new</span> MyDelegate&lt;<span class="built_in">string</span>&gt;(Simple.PrintString); <span class="comment">//创建委托的实例</span></span><br><span class="line">        myDel += Simple.PrintUpperString; <span class="comment">//添加方法</span></span><br><span class="line">        myDel(<span class="string">&quot;Hi There.&quot;</span>); <span class="comment">//调用委托</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Hi There.</span><br><span class="line">HI THERE.</span><br></pre></td></tr></table></figure><h3 id="另一个泛型委托示例"><a href="#另一个泛型委托示例" class="headerlink" title="另一个泛型委托示例"></a>另一个泛型委托示例</h3><p>C# 的 LINQ 特性大量使用了泛型委托，在介绍之前，有必要给出以下示例。第20章详细介绍 LINQ 。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TR <span class="title">Func</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, <span class="title">TR</span>&gt;(<span class="params">T1 p1, T2 p2</span>)</span>; <span class="comment">//泛型委托</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Simple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">string</span> <span class="title">PrintString</span>(<span class="params"><span class="built_in">int</span> p1, <span class="built_in">int</span> p2</span>) <span class="comment">//方法匹配委托</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> total = p1 + p2;</span><br><span class="line">        <span class="keyword">return</span> total.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> myDel = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">string</span>&gt;(Simple.PrintString); <span class="comment">//创建委托实例</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Total: <span class="subst">&#123; myDel(<span class="number">15</span>, <span class="number">13</span>) &#125;</span>&quot;</span>); <span class="comment">//调用委托</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Total: 28</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口声明需要在接口名称之后的尖括号中放置类型参数：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IMyIfc</span>&lt;<span class="title">T</span>&gt; <span class="comment">//泛型接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">ReturnIt</span>(<span class="params">T inValue</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Simple</span>&lt;<span class="title">S</span>&gt; : <span class="title">IMyIfc</span>&lt;<span class="title">S</span>&gt; <span class="comment">//泛型类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">ReturnIt</span>(<span class="params">S inValue</span>) <span class="comment">//实现泛型接口</span></span></span><br><span class="line">    &#123; <span class="keyword">return</span> inValue; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> trivInt = <span class="keyword">new</span> Simple&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">var</span> trivString = <span class="keyword">new</span> Simple&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; trivInt.ReturnIt(<span class="number">5</span>) &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; trivString.ReturnIt(<span class="string">&quot;Hi there.&quot;</span>) &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">Hi there.</span><br></pre></td></tr></table></figure><h3 id="使用泛型接口的示例"><a href="#使用泛型接口的示例" class="headerlink" title="使用泛型接口的示例"></a>使用泛型接口的示例</h3><p>以下示例展示了泛型接口的另外两个能力：<br>①与其他泛型相似，用不同类型参数实例化的泛型接口的实例是不同的接口；<br>②可以在非泛型类型中实现泛型接口。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IMyIfc</span>&lt;<span class="title">T</span>&gt; <span class="comment">//泛型接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">ReturnIt</span>(<span class="params">T inValue</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Simple</span> : <span class="title">IMyIfc</span>&lt;<span class="title">int</span>&gt;, <span class="title">IMyIfc</span>&lt;<span class="title">string</span>&gt; <span class="comment">//非泛型类，实现源于同一泛型接口的两个不同接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ReturnIt</span>(<span class="params"><span class="built_in">int</span> inValue</span>) <span class="comment">//实现int类型接口</span></span></span><br><span class="line">    &#123; <span class="keyword">return</span> inValue; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ReturnIt</span>(<span class="params"><span class="built_in">string</span> inValue</span>) <span class="comment">//实现string类型接口</span></span></span><br><span class="line">    &#123; <span class="keyword">return</span> inValue; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Simple trivial = <span class="keyword">new</span> Simple();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; trivial.ReturnIt(<span class="number">5</span>) &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; trivial.ReturnIt(<span class="string">&quot;Hi there.&quot;</span>) &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口的实现必须唯一"><a href="#泛型接口的实现必须唯一" class="headerlink" title="泛型接口的实现必须唯一"></a>泛型接口的实现必须唯一</h3><p>实现泛型类型接口时，必须保证类型实参的组合不会在类型中产生两个重复的接口。</p><p>如下示例，会产生编译时错误，因为 Simple 有可能会有两个相同类型的接口，这是不允许的：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IMyIfc</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">ReturnIt</span>(<span class="params">T inValue</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Simple</span>&lt;<span class="title">S</span>&gt; : <span class="title">IMyIfc</span>&lt;<span class="title">int</span>&gt;, <span class="title">IMyIfc</span>&lt;<span class="title">S</span>&gt; <span class="comment">//错误</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ReturnIt</span>(<span class="params"><span class="built_in">int</span> inValue</span>) <span class="comment">//实现第一个接口</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> inValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">ReturnIt</span>(<span class="params">S inValue</span>) <span class="comment">//实现第二个接口</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> inValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>泛型接口的名字不会和非泛型冲突。例如，上面的代码可以再声明一个名为 ImyIfc 的非泛型接口。</p></blockquote><h2 id="协变和逆变-Covariance-and-Contravariance"><a href="#协变和逆变-Covariance-and-Contravariance" class="headerlink" title="协变和逆变 Covariance and Contravariance"></a>协变和逆变 Covariance and Contravariance</h2><p>这个主题叫做<strong>可变性 variance</strong>，分为<strong>协变 covariance</strong> 、<strong>逆变 contravariance</strong> 、<strong>不变 invariance</strong> ：<br>①在 C# 中，协变和逆变能够实现数组类型、委托类型和泛型类型参数的隐式引用转换。<br>②如果泛型接口或委托的泛型参数被声明为协变或逆变，该泛型接口或委托则被称为<strong>变体</strong>。<br>③协变和逆变都是术语，前者指能够使用比原始指定的派生类型的派生程度更大（更具体的）的类型，后者指能够使用比原始指定的派生类型的派生程度更小（不太具体的）的类型。<br>④想要深入了解协变、逆变、不变，详见官方 .NET 文档。</p><h3 id="协变-Covariance"><a href="#协变-Covariance" class="headerlink" title="协变 Covariance"></a>协变 Covariance</h3><p>每一个变量都有一种类型，可以将派生类型的对象赋值给基类型的变量，这叫做<strong>赋值兼容性 assignment compatibility</strong> 。如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123; <span class="keyword">public</span> <span class="built_in">int</span> NumberOfLegs = <span class="number">4</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Animal( );</span><br><span class="line">        Animal a2 = <span class="keyword">new</span> Dog( );</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Number of dog legs: <span class="subst">&#123; a2.NumberOfLegs &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Number of dog legs: 4</span><br></pre></td></tr></table></figure><p>下面的例子为上面进行了扩展，但 Main 的第二行代码会产生一条编译错误，不能隐式得把右边的类型转换为左边的类型：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Legs = <span class="number">4</span>; &#125; <span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; &#125; <span class="comment">//派生类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">Factory</span>&lt;<span class="title">T</span>&gt;(<span class="params"> </span>)</span>; <span class="comment">//委托</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Dog <span class="title">MakeDog</span>(<span class="params"> </span>) <span class="comment">//匹配委托的方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog( );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Factory&lt;Dog&gt; dogMaker = MakeDog; <span class="comment">//创建委托对象，并保存方法的引用</span></span><br><span class="line">        Factory&lt;Animal&gt; animalMaker = dogMaker; <span class="comment">//尝试赋值委托对象</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine( animalMaker( ).Legs.ToString( ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码产生编译错误的原因是尽管 Dog 是 Animal 的派生类，但是委托 Factory&lt;Dog&gt; 没有从委托 Factory&lt;Animal&gt; 派生。这两个委托对象是同级的，都从 delegate 类型派生，又派生于 object 类型。两者之间没有派生关系，因此赋值兼容性不适用。</p><p>在上面示例的代码中，执行 animalMaker 委托是希望返回一个 Animal 对象的引用，所以如果返回 Dog 对象的引用也是可以的，因为赋值兼容性，但是委托类型不匹配，所以无法赋值。</p><p>可以启用委托之间的隐式转换，以便在具有泛型类型参数所指定的不同类型按变体的要求继承自对方时，可以将这些类型的泛型委托分配给对方。若要启用隐式转换，必须使用 in 或 out 关键字将委托中的泛型参数显式声明为协变或逆变。</p><p>如果通过增加 <strong>out 关键字</strong> 改变上面例子中的委托声明，代码就可以通过编译了：<code>delegate T Factory&lt;out T&gt;( );</code>，out 关键字指定了类型参数的协变。</p><h3 id="逆变-Contravariance"><a href="#逆变-Contravariance" class="headerlink" title="逆变 Contravariance"></a>逆变 Contravariance</h3><p>逆变关键字为 <strong>in</strong> ，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> NumberOfLegs = <span class="number">4</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action1</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params"> T a </span>)</span>; <span class="comment">//in关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ActOnAnimal</span>(<span class="params"> Animal a </span>)</span> &#123; Console.WriteLine( a.NumberOfLegs ); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Action1&lt;Animal&gt; act1 = ActOnAnimal;</span><br><span class="line">        Action1&lt;Dog&gt; dog1 = act1;</span><br><span class="line">        dog1( <span class="keyword">new</span> Dog() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然委托 dog1 的方法接受 Animal 类对象，但是由于 Dog 类对象（派生程度更高）是 Animal 类派生的对象（派生程度更低），所以可以接受。</p><p>可以使用 <strong>in 关键字</strong>将泛型类型参数声明为逆变，来启用委托之间的隐式转换。</p><h3 id="接口的协变和逆变"><a href="#接口的协变和逆变" class="headerlink" title="接口的协变和逆变"></a>接口的协变和逆变</h3><p>示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; <span class="keyword">public</span> <span class="built_in">string</span> Name; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IMyIfc</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">GetFirst</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SimpleReturn</span>&lt;<span class="title">T</span>&gt;: <span class="title">IMyIfc</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T[] items = <span class="keyword">new</span> T[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetFirst</span>()</span> &#123; <span class="keyword">return</span> items[<span class="number">0</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params">IMyIfc&lt;Animal&gt; returner</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( returner.GetFirst().Name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SimpleReturn&lt;Dog&gt; dogReturner = <span class="keyword">new</span> SimpleReturn&lt;Dog&gt;();</span><br><span class="line">        dogReturner.items[<span class="number">0</span>] = <span class="keyword">new</span> Dog() &#123; Name = <span class="string">&quot;Avonlea&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        IMyIfc&lt;Animal&gt; animalReturner = dogReturner;</span><br><span class="line"></span><br><span class="line">        DoSomething(dogReturner);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Avonlea</span><br></pre></td></tr></table></figure><h3 id="关于可变性的其他内容"><a href="#关于可变性的其他内容" class="headerlink" title="关于可变性的其他内容"></a>关于可变性的其他内容</h3><p>可以将具有匹配签名的方法分配给委托，还可以将返回派生程度较大的派生类型的方法分配给委托（协变），或者如果方法所接受参数的派生类型所具有的派生程度小于委托类型指定的程度（逆变），也可将其分配给委托。方法签名与委托类型之间存在隐式转换，无需 out 或 in 关键字。如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Legs = <span class="number">4</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> T <span class="title">Factory</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Dog <span class="title">MakeDog</span>()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> Dog(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Factory&lt;Animal&gt; animalMaker1 = MakeDog; <span class="comment">//隐式转换</span></span><br><span class="line">        Factory&lt;Dog&gt; dogMaker = MakeDog;</span><br><span class="line"></span><br><span class="line">        Factory&lt;Animal&gt; animalMaker2 = dogMaker; <span class="comment">//需要out关键字</span></span><br><span class="line">        Factory&lt;Animal&gt; animalMaker3 = <span class="keyword">new</span> Factory&lt;Dog&gt;(MakeDog); <span class="comment">//需要out关键字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他有关可变性的重要事项：<br>①可变性只适用于引用类型，不能从值类型派生其他类型。<br>②使用 in 和 out 关键字的显式变化只适用于接口和委托，不适用于类、结构和方法；<br>③不包括 in 和 out 关键字的委托和接口类型参数是<strong>不变</strong>的，这些参数不能用于协变或逆变。</p><h1 id="第十九章-枚举器和迭代器"><a href="#第十九章-枚举器和迭代器" class="headerlink" title="第十九章 枚举器和迭代器"></a>第十九章 枚举器和迭代器</h1><h2 id="枚举器和可枚举类型-Enumerators-and-Enumerable-Types"><a href="#枚举器和可枚举类型-Enumerators-and-Enumerable-Types" class="headerlink" title="枚举器和可枚举类型 Enumerators and Enumerable Types"></a>枚举器和可枚举类型 Enumerators and Enumerable Types</h2><p>当为数组使用 foreach 语句：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> [] arr1 = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> arr1)  <span class="comment">//枚举元素</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Item value: <span class="subst">&#123; item &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p>之所以可以循环打印这些值，是因为数组可以按需提供一个叫做<strong>枚举器 enumerator</strong> 的对象。枚举器可以依次返回请求的数组中的元素。获取对象枚举器的方法是调用对象的 <strong>GetEnumerator 方法</strong>。实现 GetEnumerator 方法的类型叫做<strong>可枚举类型 enumerable</strong>。枚举器和可枚举类型的关系如下图：  </p><div  align="center">  <img src="https://s2.loli.net/2023/03/04/Z5iezdoncO7XARU.png" width = "55%" height = "55%" alt="图89 - 枚举器和可枚举类型"/></div><p>foreach 结构被设计与可枚举类型一起使用，只有给它的遍历对象是可枚举类型，比如数组，它就会执行如下行为：<br>①通过调用 GetEnumerator 方法获取对象的枚举器；<br>②从枚举器中请求每一项并且把它作为<strong>迭代变量 iteration variable</strong>，代码可以读取该变量但不可以改变。</p><h2 id="IEnumerator-接口"><a href="#IEnumerator-接口" class="headerlink" title="IEnumerator 接口"></a>IEnumerator 接口</h2><p>实现 <strong>IEnumerator 接口</strong>的枚举器包含3个函数成员：Current、MoveNext 以及 Reset。<br>① Current 是返回序列中当前位置项的属性；<br>&emsp;&emsp;- 它是只读属性，返回 object 类型的引用，可能返回任意类型的对象。<br>② MoveNext 是把迭代器位置前进到集合中下一项的方法。它也返回布尔值，指示新的位置是有效位置还是已经超过了序列的尾部。<br>&emsp;&emsp;- 如果新位置有效，方法返回 true 。无效则返回 false 。枚举器的原始位置在序列中的第一项之前，因此 MoveNext 必须在第一次使用 Current 之前调用。<br>③ Reset 是把位置重置为原始状态的方法。</p><p>下图显示了3个项的集合，右边显示了枚举器。在下图中，枚举器是一个叫作 ArrEnumerator 类的实例：  </p><div  align="center">  <img src="https://s2.loli.net/2023/03/04/U5nE3NTkyDal2Xj.png" width = "70%" height = "70%" alt="图90 - 小集合的枚举器"/></div><p>有了集合的枚举器，可以使用上述成员来模仿 foreach 循环遍历集合中的项。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] arr1 = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line">    IEnumerator ie = arr1.GetEnumerator(); <span class="comment">//获取并存储枚举器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( ie.MoveNext() ) <span class="comment">//移到下一项</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> item = (<span class="built_in">int</span>) ie.Current; <span class="comment">//获取当前项</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Item value: <span class="subst">&#123; item &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果和内嵌的 foreach 语句一样：  </p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Item value: 10</span><br><span class="line">Item value: 11</span><br><span class="line">Item value: 12</span><br><span class="line">Item value: 13</span><br></pre></td></tr></table></figure><h2 id="IEnumerable-接口"><a href="#IEnumerable-接口" class="headerlink" title="IEnumerable 接口"></a>IEnumerable 接口</h2><p>可枚举类是指实现了 <strong>IEnumerable 接口</strong>的类。IEnumerable 接口只有一个成员： GetEnumerator 方法，它返回对象的枚举器。</p><div  align="center">  <img src="https://s2.loli.net/2023/03/04/TsJoLhBuP23SEY4.png" width = "50%" height = "50%" alt="图91 - GetEnumerator 方法返回类的一个枚举器对象"/></div><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyColors</span>: <span class="title">IEnumerable</span> <span class="comment">//实现 IEnumerable 接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] Colors = &#123; <span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Yellow&quot;</span>, <span class="string">&quot;Blue&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>() <span class="comment">//返回 IEnumerator 类型的对象</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ColorEnumerator(Colors); <span class="comment">//枚举器类的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-IEnumerable-和-IEnumerator-的示例"><a href="#使用-IEnumerable-和-IEnumerator-的示例" class="headerlink" title="使用 IEnumerable 和 IEnumerator 的示例"></a>使用 IEnumerable 和 IEnumerator 的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ColorEnumerator</span> : <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] Colors;</span><br><span class="line">    <span class="built_in">int</span> Position = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorEnumerator</span>(<span class="params"> <span class="built_in">string</span>[] theColors </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Colors = <span class="keyword">new</span> <span class="built_in">string</span>[theColors.Length];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; theColors.Length; i++ )</span><br><span class="line">            Colors[i] = theColors[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( Position == <span class="number">-1</span> )</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException();</span><br><span class="line">            <span class="keyword">if</span> ( Position &gt;= Colors.Length )</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException();</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> Colors[Position];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( Position &lt; Colors.Length - <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Position++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Position = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Spectrum</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] Colors = &#123; <span class="string">&quot;violet&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;cyan&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;red&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ColorEnumerator( Colors );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Spectrum spectrum = <span class="keyword">new</span> Spectrum();</span><br><span class="line">        <span class="keyword">foreach</span> ( <span class="built_in">string</span> color <span class="keyword">in</span> spectrum )</span><br><span class="line">            Console.WriteLine( color );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">violet</span><br><span class="line">blue</span><br><span class="line">cyan</span><br><span class="line">green</span><br><span class="line">yellow</span><br><span class="line">orange</span><br><span class="line">red</span><br></pre></td></tr></table></figure><h2 id="泛型枚举接口"><a href="#泛型枚举接口" class="headerlink" title="泛型枚举接口"></a>泛型枚举接口</h2><p>上述提到的都是非泛型版本，大多数情况应该使用泛型版本 <strong>IEnumerable&lt;T&gt;</strong> and <strong>IEnumerator&lt;T&gt;</strong>。两者之间的差别如下：<br>①对于非泛型接口形式：<br>&emsp;&emsp;- IEnumerable 接口的 GetEnumerator 方法返回实现 IEnumerator 的枚举器类的实例；<br>&emsp;&emsp;- 实现 IEnumerator 的类实现了 Current 属性，它返回了 object 类型的引用，然后必须把它转换为对象的实际类型。<br>②泛型接口继承自非泛型接口。对于泛型接口形式：<br>&emsp;&emsp;- IEnumerable&lt;T&gt;接口的 GetEnumerator 方法返回实现 IEnumerator&lt;T&gt; 的枚举器类的实例；<br>&emsp;&emsp;- 实现 IEnumerator&lt;T&gt; 的类实现了 Current 属性，它返回实际类型的实例，而不是 object 基类的引用。<br>&emsp;&emsp;- 这些是协变接口，所以他们的实际声明是 IEnumerable&lt;out T&gt; 和 IEnumerator&lt;out T&gt; 。</p><p>非泛型接口的实现不是类型安全的，它们返回 object 类型的引用，然后必须转换为实际类型。而泛型接口的枚举器是类型安全的，它返回实际类型的引用。如果要创建自己的可枚举类，应该实现这些泛型接口。</p><div  align="center">  <img src="https://s2.loli.net/2023/03/04/WljoyYb3ftNrUua.png" width = "70%" height = "70%" alt="图92 - 实现 IEnumerator<T> 接口的类的结构"/></div><div  align="center">  <img src="https://s2.loli.net/2023/03/04/imKBweqSZFPdzNU.png" width = "60%" height = "60%" alt="图93 - 实现 IEnumerable<T> 接口的类的结构"/></div><h2 id="迭代器-Iterators"><a href="#迭代器-Iterators" class="headerlink" title="迭代器 Iterators"></a>迭代器 Iterators</h2><p><strong>迭代器 Iterators</strong> 这种结构可以让编译器把手动编码的可枚举类型和枚举器替换为由迭代器生成的可枚举类型和枚举器。示例如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">BlackAndWhite</span>() <span class="comment">//版本1，返回泛型枚举器，它返回的是字符串对象</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;gray&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;white&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另外一个版本，输出同样的结果：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">BlackAndWhite</span>() <span class="comment">//版本2，返回泛型枚举器，它返回的是字符串对象</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] theColors = &#123; <span class="string">&quot;black&quot;</span>, <span class="string">&quot;gray&quot;</span>, <span class="string">&quot;white&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; theColors.Length; i++)</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> theColors[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器块"><a href="#迭代器块" class="headerlink" title="迭代器块"></a>迭代器块</h3><p><strong>迭代器块</strong>是有一个或多个 <strong>yield 语句</strong>的代码块。方法、访问器和运算符都可以是迭代器块。</p><p>迭代器块与其他代码块不同。其他块包含的语句是命令式的，即先执行代码块的第一个语句，然后执行后面的语句，最后控制离开块。迭代器块不是需要在同一时间执行的一串命令式命令，而是声明性的，描述了如何枚举元素：<br>① <strong>yield return</strong> 语句指定了序列中要返回的下一项；<br>② <strong>yield break</strong> 语句指定了在序列中没有更多的其他项。<br>编译器得到有关如何枚举项的描述后，使用它来构建包含所有需要的方法和属性实现的枚举器类。产生的类被嵌套包含在声明迭代器的类中。根据迭代器的返回类型，可以让迭代器产生枚举器或可枚举类型。</p><h3 id="使用迭代器来创建枚举器"><a href="#使用迭代器来创建枚举器" class="headerlink" title="使用迭代器来创建枚举器"></a>使用迭代器来创建枚举器</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> BlackAndWhite(); &#125; <span class="comment">//返回枚举器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">BlackAndWhite</span>() <span class="comment">//返回枚举器的迭代器</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;gray&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;white&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> shade <span class="keyword">in</span> mc)</span><br><span class="line">            Console.WriteLine(shade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">black</span><br><span class="line">gray</span><br><span class="line">white</span><br></pre></td></tr></table></figure><h3 id="使用迭代器来创建可枚举类型"><a href="#使用迭代器来创建可枚举类型" class="headerlink" title="使用迭代器来创建可枚举类型"></a>使用迭代器来创建可枚举类型</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IEnumerable&lt;<span class="built_in">string</span>&gt; myEnumerable = BlackAndWhite(); <span class="comment">//获取可枚举类型</span></span><br><span class="line">        <span class="keyword">return</span> myEnumerable.GetEnumerator(); <span class="comment">//获取枚举器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">BlackAndWhite</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;gray&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;white&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> shade <span class="keyword">in</span> mc)</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; shade &#125;</span> &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> shade <span class="keyword">in</span> mc.BlackAndWhite()) <span class="comment">//使用类枚举器方法</span></span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; shade &#125;</span> &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">black gray white black gray white </span><br></pre></td></tr></table></figure><h2 id="常见迭代器模式"><a href="#常见迭代器模式" class="headerlink" title="常见迭代器模式"></a>常见迭代器模式</h2><p>总结上述的创建迭代器来返回可枚举类型或者枚举器：<br>①当实现返回枚举器的迭代器时，必须通过实现 GetEnumerator 来让类可枚举，它返回由迭代器返回的枚举器；<br>②在类中实现返回可枚举类型的迭代器时，可以让类实现 GetEnumerator 来让类本身可枚举，也可以不实现 GetEnumerator 。<br>&emsp;&emsp;- 如果实现 GetEnumerator ，让它调用迭代器方法以获取自动生成的实现 IEnumerable 的类示例。然后，从 IEnumerable 对象返回由 GetEnumerator 创建的枚举器；<br>&emsp;&emsp;- 如果不实现 GetEnumerator ，仍然可以使用由迭代器返回的可枚举类，只需直接调用迭代器方法。</p><h2 id="产生多个可枚举类型"><a href="#产生多个可枚举类型" class="headerlink" title="产生多个可枚举类型"></a>产生多个可枚举类型</h2><p>如下示例，尽管有两个方法返回可枚举类型，但类本身不是可枚举类型，因为它没有实现 GetEnumerator ：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Spectrum</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] colors = &#123; <span class="string">&quot;violet&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;cyan&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;red&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">UVtoIR</span>() <span class="comment">//返回一个可枚举类型</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; colors.Length; i++ )</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> colors[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">IRtoUV</span>() <span class="comment">//返回一个可枚举类型</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i=colors.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- )</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> colors[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Spectrum spectrum = <span class="keyword">new</span> Spectrum();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ( <span class="built_in">string</span> color <span class="keyword">in</span> spectrum.UVtoIR() )</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; color &#125;</span> &quot;</span> );</span><br><span class="line">        Console.WriteLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ( <span class="built_in">string</span> color <span class="keyword">in</span> spectrum.IRtoUV() )</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; color &#125;</span> &quot;</span> );</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">violet blue cyan green yellow orange red </span><br><span class="line">red orange yellow green cyan blue violet</span><br></pre></td></tr></table></figure><h2 id="将迭代器作为属性"><a href="#将迭代器作为属性" class="headerlink" title="将迭代器作为属性"></a>将迭代器作为属性</h2><p>将迭代器实现为属性而不是方法，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Spectrum</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> _listFromUVtoIR;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span>[] colors = &#123; <span class="string">&quot;violet&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;cyan&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;red&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spectrum</span>(<span class="params"> <span class="built_in">bool</span> listFromUVtoIR </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _listFromUVtoIR = listFromUVtoIR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _listFromUVtoIR</span><br><span class="line">                    ? UVtoIR</span><br><span class="line">                    : IRtoUV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; UVtoIR</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; colors.Length; i++ )</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> colors[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; IRtoUV</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="built_in">int</span> i=colors.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- )</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> colors[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Spectrum startUV = <span class="keyword">new</span> Spectrum( <span class="literal">true</span> );</span><br><span class="line">        Spectrum startIR = <span class="keyword">new</span> Spectrum( <span class="literal">false</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ( <span class="built_in">string</span> color <span class="keyword">in</span> startUV )</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; color &#125;</span> &quot;</span> );</span><br><span class="line">        Console.WriteLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> ( <span class="built_in">string</span> color <span class="keyword">in</span> startIR )</span><br><span class="line">            Console.Write(<span class="string">$&quot;<span class="subst">&#123; color &#125;</span> &quot;</span> );</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">violet blue cyan green yellow orange red </span><br><span class="line">red orange yellow green cyan blue violet</span><br></pre></td></tr></table></figure><h2 id="迭代器的实质"><a href="#迭代器的实质" class="headerlink" title="迭代器的实质"></a>迭代器的实质</h2><p>①迭代器需要 System.Collections.Generic 命名空间，需要 using 指令；<br>②在编译器生成的枚举器中，不支持 Reset 方法。当它被接口需要时会实现但是会抛出 System.NotSupportedException 异常。</p><p>在后台，由编译器生成的枚举器类是包含4个状态的状态机：<br>① Before，首次调用 MoveNext 之前的初始状态；<br>② Runing，调用 MoveNext 之后进入这个状态。在这个状态中，枚举器检测并设置下一项的位置。在遇到 yield return、yield break 或在迭代器体结束时，退出状态；<br>③ Suspended，状态机等待下次调用 MoveNext 的状态；<br>④ After，没有更多项可以枚举的状态。<br>如果状态机在 Before 或 Suspended 状态时调用了 MoveNext 方法，就转到 Running 状态。在 Running 状态中，它检测集合的下一项并设置位置。如果有更多项，状态机会转入 Suspended 状态；如果没有更多项，它转入并保持在 After 状态。</p><h1 id="第二十章-LINQ"><a href="#第二十章-LINQ" class="headerlink" title="第二十章 LINQ"></a>第二十章 LINQ</h1><h2 id="什么是-LINQ"><a href="#什么是-LINQ" class="headerlink" title="什么是 LINQ"></a>什么是 LINQ</h2><p>在关系型数据库中，数据被放入规范化的表里，通过 SQL 来进行访问。然后，和数据库相反，在程序中，数据被保存在差异很大的类对象或结构中。因此，使用 LINQ 可以轻松地查询对象集合。<br>① LINQ 代表<strong>语言集成查询 Language Integrated Query</strong> ；<br>② LINQ 是 .NET 框架的扩展，允许使用像 SQL 查询数据库的类似方式来查询数据集合；<br>③ 使用 LINQ，可以从数据库、对象集合以及 XML 文档等查询数据。</p><p>一个简单的示例如下，该例中，被查询的数据源是 int 数组。查询的定义就是带有 from 和 select 关键字的语句。尽管查询在语句中定义，直到最后的 foreach 语句请求其结果时才会执行：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] numbers = &#123; <span class="number">2</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">15</span> &#125;;</span><br><span class="line"></span><br><span class="line">    IEnumerable&lt;<span class="built_in">int</span>&gt; lowNums = <span class="comment">//定义并存储查询</span></span><br><span class="line">                        <span class="keyword">from</span> n <span class="keyword">in</span> numbers</span><br><span class="line">                        <span class="keyword">where</span> n &lt; <span class="number">10</span></span><br><span class="line">                        <span class="keyword">select</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> lowNums) <span class="comment">//执行查询</span></span><br><span class="line">        Console. Write(<span class="string">$&quot;<span class="subst">&#123; x &#125;</span>, &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">2, 5, </span><br></pre></td></tr></table></figure><h2 id="LINQ-提供程序"><a href="#LINQ-提供程序" class="headerlink" title="LINQ 提供程序"></a>LINQ 提供程序</h2><p>LINQ 除了可以查询程序在内存中的对象，还可以查询 SQL 数据库、XML 文档等等。对于每一个数据源类型，一定有根据该数据源类型实现 LINQ 查询的代码模块。这些模块叫做 <strong>LINQ 提供程序 provider</strong> 。微软为一些常见的数据源类型提供了 LINQ 提供程序；可以使用任何支持 LINQ 的语言，比如 C# ，来查询有 LINQ 提供程序的数据源类型。</p><div  align="center">  <img src="https://s2.loli.net/2023/03/05/JyGjXQL4bot537p.png" width = "60%" height = "60%" alt="图94 - LINQ 的体系结构"/></div><p>本章主要介绍 LINQ to object 和 XML 。</p><h3 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h3><p><strong>匿名类型 anonymous type</strong> 经常用于 LINQ 查询的结果之中。创建匿名类型的变量与对象初始化语句相同，但是没有类名和构造函数，语法如下：<code>new &#123; FieldProp = InitExpr, FieldProp = InitExpr, ...&#125;</code></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> student = <span class="keyword">new</span> &#123;Name=<span class="string">&quot;Mary Jones&quot;</span>, Age=<span class="number">19</span>, Major=<span class="string">&quot;History&quot;</span>&#125;; <span class="comment">//必须使用var</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; student.Name &#125;</span>, Age <span class="subst">&#123; student.Age &#125;</span>, Major: <span class="subst">&#123;student.Major&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Mary Jones, Age 19, Major: History</span><br></pre></td></tr></table></figure><p>关于匿名类型的重要事项如下：<br>①匿名类型只能用于局部变量，不能用于类成员；<br>②由于匿名函数没有名字，必须使用 var 关键字作为变量类型；<br>③不能设置匿名类型对象的属性。编译器为匿名类型创建的属性是只读的；<br>④对于每一个成员初始化语句（即 FieldProp = InitExpr ），编译器推断其类型并创建一个只读属性来访问它的值。</p><p>除了对象初始化语句的赋值形式，匿名类型的对象初始化语句还有两个形式：简单标识符和成员访问表达式。这两种形式叫做<strong>投影初始化语句 projection initializers</strong> 。如下，展示了3种形式，第一个成员初始化语句是赋值形式，第二个是成员访问表达式，第三个是标识符形式：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Other</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">string</span> Name = <span class="string">&quot;Mary Jones&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> Major = <span class="string">&quot;History&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> student = <span class="keyword">new</span> &#123; Age = <span class="number">19</span>, Other.Name, Major&#125;; <span class="comment">//分别为赋值、成员访问、标识符</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;student.Name &#125;</span>, Age <span class="subst">&#123;student.Age &#125;</span>, Major: <span class="subst">&#123;student.Major&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Mary Jones, Age 19, Major: History</span><br></pre></td></tr></table></figure><p>如果编译器遇到另一个具有相同的参数名、相同的推断类型和相同顺序的匿名类型对象初始化语句，它会重用这个类型并直接创建新的实例，不会创建新的匿名类型。</p><h2 id="方法语法和查询语法"><a href="#方法语法和查询语法" class="headerlink" title="方法语法和查询语法"></a>方法语法和查询语法</h2><p>使用 LINQ 查询时可以使用两种形式的语法：查询语法和方法语法。<br>①<strong>方法语法 method syntax</strong>：使用标准的方法调用，这些方法是一组叫作标准查询运算符的方法，见后面；方法语法是<strong>命令式的 imperative</strong> 的，它指明了查询方法调用的顺序。<br>②<strong>查询语法 query syntax</strong>：与 SQL 语句类似，使用查询表达式形式书写；查询语法是<strong>声明式 declarative</strong> 的，即查询描述的是想返回的但并没指明如何执行查询。<br>在一个查询中可以组合两种形式。编译器会将查询语法翻译为方法调用的形式，这两种形式在运行上没有性能差异。</p><p>微软推荐使用查询语法，因为易读清晰，但一些表达式必须用方法语法来书写。</p><p>示例如下，注意方法语法的 Where 方法的参数使用了 Lambda 表达式：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] numbers = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">42</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> numsQuery = <span class="keyword">from</span> n <span class="keyword">in</span> numbers <span class="comment">//查询语法</span></span><br><span class="line">                    <span class="keyword">where</span> n &lt; <span class="number">20</span></span><br><span class="line">                    <span class="keyword">select</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> numsMethod = numbers.Where(N =&gt; N &lt; <span class="number">20</span>); <span class="comment">//方法语法</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numsCount = (<span class="keyword">from</span> n <span class="keyword">in</span> numbers <span class="comment">//两种形式的合并</span></span><br><span class="line">                    <span class="keyword">where</span> n &lt; <span class="number">20</span></span><br><span class="line">                    <span class="keyword">select</span> n).Count();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> numsQuery)</span><br><span class="line">        Console.Write(<span class="string">$&quot;<span class="subst">&#123; x &#125;</span>, &quot;</span>);</span><br><span class="line">    Console.WriteLine();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> numsMethod)</span><br><span class="line">        Console.Write(<span class="string">$&quot;<span class="subst">&#123; x &#125;</span>, &quot;</span>);</span><br><span class="line">    Console.WriteLine();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(numsCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">2, 5, 17, 16, </span><br><span class="line">2, 5, 17, 16,</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="查询变量"><a href="#查询变量" class="headerlink" title="查询变量"></a>查询变量</h2><p>LINQ 查询返回两种类型的结果：枚举 enumeration （不是枚举类型），即满足查询参数的项列表；标量 scalar ，单一值，满足查询条件的结果的某种形式。</p><p>示例如下，第二个语句指定了一个 LINQ 查询，它可以用来枚举查询的结果；第三个语句调用 LINQ 方法，即 Count ，来返回从查询返回的项的总数：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">28</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; lowNums = <span class="keyword">from</span> n <span class="keyword">in</span> numbers <span class="comment">//返回一个枚举</span></span><br><span class="line">                            <span class="keyword">where</span> n &lt; <span class="number">20</span></span><br><span class="line">                            <span class="keyword">select</span> n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> numsCount = (<span class="keyword">from</span> n <span class="keyword">in</span> numbers <span class="comment">//返回一个整数</span></span><br><span class="line">                            <span class="keyword">where</span> n &lt; <span class="number">20</span></span><br><span class="line">                            <span class="keyword">select</span> n).Count();</span><br></pre></td></tr></table></figure><p>第二条和第三条语句等号左边的变量叫做<strong>查询变量 query variable</strong> 。虽然示例显示定义了查询变量类型，还是可以使用 var 关键字让编译器自行推断。</p><p>在执行前面的代码后，查询变量 lowNums 不会包含查询的结果，编译器会创建能够执行这个查询的代码；查询变量 numCount 包含真实的整数值。差异总结如下：<br>①如果查询表达式返回枚举，则查询一直到处理枚举时才会执行；<br>②如果枚举被处理多次，查询就会执行多次；<br>③如果在枚举返回之后、查询执行之前数据有改动，则查询会使用新的数据；<br>④如果查询表达式返回标量，查询立即执行，并且把结果保存在查询变量中。</p><h2 id="查询表达式的结构"><a href="#查询表达式的结构" class="headerlink" title="查询表达式的结构"></a>查询表达式的结构</h2><p><strong>查询表达式 Query Expressions</strong> 由 from 子句和查询主体组成。重要事项如下：<br>①子句必须按照一定顺序出现；<br>② from 子句和 select…group 子句这两部分是必需的；<br>③其他子句是可选的；<br>④在 LINQ 查询表达式中，select 子句在表达式最后。这与 SQL 的 SELECT 语句在查询的开始处不一样；<br>⑤可以有任意多的 from…let…where 子句，如下图：</p><div  align="center">  <img src="https://s2.loli.net/2023/03/07/ybF7U8GiZxmXHeR.png" width = "65%" height = "65%" alt="图95 - 查询语句的结构"/></div><h3 id="from-子句"><a href="#from-子句" class="headerlink" title="from 子句"></a>from 子句</h3><p>from 子句的语法：<code>from Type Item in Items</code><br>① Type 是集合中元素的类型，这是可选的，因为编译器可以从集合中判断类型；<br>② Item 是迭代变量的名称，迭代变量逐个表示数据源的每一个元素；<br>③ Items 是要查询的集合的名字，集合必须是可枚举的。</p><p>示例如下，这段代码没有指明迭代变量的可选类型 int ：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr1 = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> item <span class="keyword">in</span> arr1</span><br><span class="line">            <span class="keyword">where</span> item &lt; <span class="number">13</span></span><br><span class="line">            <span class="keyword">select</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>( <span class="keyword">var</span> item <span class="keyword">in</span> query )</span><br><span class="line">Console.Write( <span class="string">$&quot;<span class="subst">&#123;item &#125;</span>,&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">10,11,12,</span><br></pre></td></tr></table></figure><p>from 子句可以有任意多个可选 join 子句：<code>from Type Identifier in Expression JoinClause</code> , join 子句见下一小节。</p><p>LINQ 的 from 子句和 foreach 语句很像，但不同点如下：<br>① foreach 语句命令式地指定了要从第一个到最后一个按顺序访问集合中的项；而 from 子句声明式地规定集合中的每一项都要被访问，但是没有假定顺序。<br>② foreach 语句在遇到代码时就执行其主体，而 from 子句什么也不执行。from 子句创建可执行查询的后台代码对象。只有在程序的控制流遇到访问查询变量的语句时，才会执行查询。</p><h3 id="join-子句"><a href="#join-子句" class="headerlink" title="join 子句"></a>join 子句</h3><p>LINQ 中的 join 子句和 SQL 中的 JOIN 子句很相似，不同的是不但可以在数据库的表上执行<strong>联结 join</strong> ，还可以在集合对象上进行这个操作。可以使用联结来结合两个或更多集合中的数据，联结操作接受两个集合，然后创建一个临时的对象集合，其中每一个对象包含两个原始集合对象中的所有字段。</p><p>联结的语法如下，它指定了第二个集合要和之前子句中的集合进行联结，注意必须使用上下文关键字 equals 来比较字段，不能用 == 运算符：<code>join Identifier in Collection2 on Field1 equals Field2</code>。</p><p>一个 join 子句的示例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line">            <span class="keyword">join</span> c <span class="keyword">in</span> studentsInCourses <span class="keyword">on</span> s.StID <span class="keyword">equals</span> c.StID</span><br></pre></td></tr></table></figure><h3 id="什么是联结"><a href="#什么是联结" class="headerlink" title="什么是联结"></a>什么是联结</h3><p>联结就是基于集合之间的共同字段连接集合方便查询，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> StID;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> LastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CourseStudent</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> CourseName;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> StID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Student[] students = <span class="keyword">new</span> Student[] &#123;</span><br><span class="line">        <span class="keyword">new</span> Student &#123; StID = <span class="number">1</span>, LastName = <span class="string">&quot;Carson&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> Student &#123; StID = <span class="number">2</span>, LastName = <span class="string">&quot;Klassen&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> Student &#123; StID = <span class="number">3</span>, LastName = <span class="string">&quot;Fleming&quot;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> CourseStudent[] studentsInCourses = <span class="keyword">new</span> CourseStudent[] &#123;</span><br><span class="line">        <span class="keyword">new</span> CourseStudent &#123; CourseName = <span class="string">&quot;Art&quot;</span>, StID = <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> CourseStudent &#123; CourseName = <span class="string">&quot;Art&quot;</span>, StID = <span class="number">2</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> CourseStudent &#123; CourseName = <span class="string">&quot;History&quot;</span>, StID = <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> CourseStudent &#123; CourseName = <span class="string">&quot;History&quot;</span>, StID = <span class="number">3</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> CourseStudent &#123; CourseName = <span class="string">&quot;Physics&quot;</span>, StID = <span class="number">3</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//查找所有选择了历史课的学生的姓氏</span></span><br><span class="line">        <span class="keyword">var</span> query = <span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line">                    <span class="keyword">join</span> c <span class="keyword">in</span> studentsInCourses <span class="keyword">on</span> s.StID <span class="keyword">equals</span> c.StID</span><br><span class="line">                    <span class="keyword">where</span> c.CourseName == <span class="string">&quot;History&quot;</span></span><br><span class="line">                    <span class="keyword">select</span> s.LastName;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//显示所有选择了历史课的学生的名字</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> q <span class="keyword">in</span> query)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Student taking History: <span class="subst">&#123; q &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Student taking History: Carson</span><br><span class="line">Student taking History: Fleming</span><br></pre></td></tr></table></figure><h3 id="查找主体中的-from…let…where-片段"><a href="#查找主体中的-from…let…where-片段" class="headerlink" title="查找主体中的 from…let…where 片段"></a>查找主体中的 from…let…where 片段</h3><p>可选的 from…let…where 部分是查询主体的第一部分，可以由任意数量的3种子句构成：from 子句、let 子句和 where 子句。</p><p><strong>1、 from 子句</strong><br>查询表达式从必需的 from 子句开始，后面跟着查询主体。主体本身可以从任何数量的其他 from 子句开始，每一个子句都指定了一个额外的源数据集合并引入了在之后运算的迭代变量。</p><p>示例如下，第一个 from 子句是查询表达式必需的子句，第二个 from 子句是第一个子句的查询主体，select 子句创建了一个匿名类型的对象：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> groupA = <span class="keyword">new</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> groupB = <span class="keyword">new</span>[] &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> someInts = <span class="keyword">from</span> a <span class="keyword">in</span> groupA <span class="comment">//必需的第一个 from 子句</span></span><br><span class="line">                    <span class="keyword">from</span> b <span class="keyword">in</span> groupB <span class="comment">//查询主体的第一个子句</span></span><br><span class="line">                    <span class="keyword">where</span> a &gt; <span class="number">4</span> &amp;&amp; b &lt;= <span class="number">8</span></span><br><span class="line">                    <span class="keyword">select</span> <span class="keyword">new</span> &#123;a, b, sum = a + b&#125;; <span class="comment">//匿名类型对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> someInts)</span><br><span class="line">        Console.WriteLine(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&#123; a = 5, b = 6, sum = 11 &#125;</span><br><span class="line">&#123; a = 5, b = 7, sum = 12 &#125;</span><br><span class="line">&#123; a = 5, b = 8, sum = 13 &#125;</span><br><span class="line">&#123; a = 6, b = 6, sum = 12 &#125;</span><br><span class="line">&#123; a = 6, b = 7, sum = 13 &#125;</span><br><span class="line">&#123; a = 6, b = 8, sum = 14 &#125;</span><br></pre></td></tr></table></figure><p><strong>2、let 子句</strong><br>let 子句接受一个表达式的运算并且把它赋值给一个需要在其他运算中使用的标识符。let 子句的语法如下：<code>let Identifier = Expression</code>。示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> groupA = <span class="keyword">new</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> groupB = <span class="keyword">new</span>[] &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> someInts = <span class="keyword">from</span> a <span class="keyword">in</span> groupA</span><br><span class="line">                    <span class="keyword">from</span> b <span class="keyword">in</span> groupB</span><br><span class="line">                    <span class="keyword">let</span> sum = a + b <span class="comment">//在新的变量中保存结果</span></span><br><span class="line">                    <span class="keyword">where</span> sum == <span class="number">12</span></span><br><span class="line">                    <span class="keyword">select</span> <span class="keyword">new</span> &#123;a, b, sum&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> someInts)</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&#123; a = 3, b = 9, sum = 12 &#125;</span><br><span class="line">&#123; a = 4, b = 8, sum = 12 &#125;</span><br><span class="line">&#123; a = 5, b = 7, sum = 12 &#125;</span><br><span class="line">&#123; a = 6, b = 6, sum = 12 &#125;</span><br></pre></td></tr></table></figure><p><strong>3、where 子句</strong><br>where 子句根据之后的运算来去除不符合指定条件的项，语法如下：<code>where BooleanExpression</code>。只要是在 from…let…where 部分中，查询表达式可以有任意多个 where 子句，一个项必须满足所有 where 子句才能避免在之后被去除。示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> groupA = <span class="keyword">new</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> groupB = <span class="keyword">new</span>[] &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> someInts = <span class="keyword">from</span> <span class="built_in">int</span> a <span class="keyword">in</span> groupA</span><br><span class="line">                    <span class="keyword">from</span> <span class="built_in">int</span> b <span class="keyword">in</span> groupB</span><br><span class="line">                    <span class="keyword">let</span> sum = a + b</span><br><span class="line">                    <span class="keyword">where</span> sum &gt;= <span class="number">11</span> <span class="comment">//条件1</span></span><br><span class="line">                    <span class="keyword">where</span> a == <span class="number">4</span> <span class="comment">//条件2</span></span><br><span class="line">                    <span class="keyword">select</span> <span class="keyword">new</span> &#123;a, b, sum&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> a <span class="keyword">in</span> someInts)</span><br><span class="line">        Console.WriteLine(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&#123; a = 4, b = 7, sum = 11 &#125;</span><br><span class="line">&#123; a = 4, b = 8, sum = 12 &#125;</span><br><span class="line">&#123; a = 4, b = 9, sum = 13 &#125;</span><br></pre></td></tr></table></figure><h3 id="orderby-子句"><a href="#orderby-子句" class="headerlink" title="orderby 子句"></a>orderby 子句</h3><p>orderby 子句接受一个表达式并根据表达式按顺序返回结果项。语法为：<code>orderby Expression ascending/descending ,</code>。其中表达式通常是项的一个字段，可以是数值字段，也可以是字符串。orderby 子句的默认排序是升序，可选的 ascending 和 descending 关键字显式地设置元素的排序为升序或降序。可以有任意的 orderby 子句，它们必须用逗号分隔。示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> students = <span class="keyword">new</span> [] <span class="comment">//匿名类型的对象数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Jones&quot;</span>, FName=<span class="string">&quot;Mary&quot;</span>, Age=<span class="number">19</span>, Major=<span class="string">&quot;History&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Smith&quot;</span>, FName=<span class="string">&quot;Bob&quot;</span>, Age=<span class="number">20</span>, Major=<span class="string">&quot;CompSci&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Fleming&quot;</span>, FName=<span class="string">&quot;Carol&quot;</span>, Age=<span class="number">21</span>, Major=<span class="string">&quot;History&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> query = <span class="keyword">from</span> student <span class="keyword">in</span> students</span><br><span class="line">                <span class="keyword">orderby</span> student.Age</span><br><span class="line">                <span class="keyword">select</span> student;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> s <span class="keyword">in</span> query) &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; s.LName &#125;</span>, <span class="subst">&#123; s.FName &#125;</span>: <span class="subst">&#123; s.Age &#125;</span>, <span class="subst">&#123; s.Major &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Jones, Mary: 19, History</span><br><span class="line">Smith, Bob: 20, CompSci</span><br><span class="line">Fleming, Carol: 21, History</span><br></pre></td></tr></table></figure><h3 id="select…group-子句"><a href="#select…group-子句" class="headerlink" title="select…group 子句"></a>select…group 子句</h3><p>select…group 由两种类型的子句组成：select 子句和 group…by 子句。<br>① select 子句指定应该选择所选对象的哪些部分，可以指定整个数据项、数据项的一个字段或者数据项中几个字段组成的新对象（见下面查询中的匿名类型）。<br>② group…by 子句是可选的，用来指定选择的项如何被分组，见后面。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> students = <span class="keyword">new</span>[] <span class="comment">//匿名类型的对象数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Jones&quot;</span>, FName=<span class="string">&quot;Mary&quot;</span>, Age=<span class="number">19</span>, Major=<span class="string">&quot;History&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Smith&quot;</span>, FName=<span class="string">&quot;Bob&quot;</span>, Age=<span class="number">20</span>, Major=<span class="string">&quot;CompSci&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Fleming&quot;</span>, FName=<span class="string">&quot;Carol&quot;</span>, Age=<span class="number">21</span>, Major=<span class="string">&quot;History&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> query1 = <span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line">                    <span class="keyword">select</span> s; <span class="comment">//选择整个数据项</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> q <span class="keyword">in</span> query1)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; q.LName &#125;</span>, <span class="subst">&#123; q.FName &#125;</span>: <span class="subst">&#123; q.Age &#125;</span>, <span class="subst">&#123; q.Major &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> query2 = <span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line">                    <span class="keyword">select</span> s.LName; <span class="comment">//选择对象的某些字段</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> q <span class="keyword">in</span> query2)</span><br><span class="line">            Console.WriteLine(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Jones, Mary: 19, History</span><br><span class="line">Smith, Bob: 20, CompSci</span><br><span class="line">Fleming, Carol: 21, History</span><br><span class="line">Jones</span><br><span class="line">Smith</span><br><span class="line">Fleming</span><br></pre></td></tr></table></figure><h3 id="查询中的匿名类型"><a href="#查询中的匿名类型" class="headerlink" title="查询中的匿名类型"></a>查询中的匿名类型</h3><p>查询结果可以由原始集合的项、原始集合中项的字段或匿名类型组成。可以通过在 select 子句中把希望在类型中包括的字段以逗号分隔，并以大括号包围来创建匿名类型，语法如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> students = <span class="keyword">new</span>[] <span class="comment">//匿名类型的对象数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Jones&quot;</span>, FName=<span class="string">&quot;Mary&quot;</span>, Age=<span class="number">19</span>, Major=<span class="string">&quot;History&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Smith&quot;</span>, FName=<span class="string">&quot;Bob&quot;</span>, Age=<span class="number">20</span>, Major=<span class="string">&quot;CompSci&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Fleming&quot;</span>, FName=<span class="string">&quot;Carol&quot;</span>, Age=<span class="number">21</span>, Major=<span class="string">&quot;History&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> query = <span class="keyword">from</span> s <span class="keyword">in</span> students</span><br><span class="line">                    <span class="keyword">select</span> <span class="keyword">new</span> &#123; s.LName, s.FName, s.Major &#125;; <span class="comment">//创建匿名类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> q <span class="keyword">in</span> query)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; q.FName &#125;</span> <span class="subst">&#123; q.LName &#125;</span> -- <span class="subst">&#123; q.Major&#125;</span>&quot;</span>); <span class="comment">//匿名类型的访问字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Mary Jones -- History</span><br><span class="line">Bob Smith -- CompSci</span><br><span class="line">Carol Fleming -- History</span><br></pre></td></tr></table></figure><h3 id="group-子句"><a href="#group-子句" class="headerlink" title="group 子句"></a>group 子句</h3><p>group 子句根据指定的标准对选择的对象进行分组。<br>①如果项包含在查询的结果中，它们就可以根据某个字段的值进行分组，作为分组依据的数据叫做<strong>键 key</strong> ；<br>② group 子句返回的不是原始数据源中项的枚举，而是返回可以枚举的已经形成的项的分组可枚举类型；<br>③分组本身是可枚举类型，它们可以枚举实际的项。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> students = <span class="keyword">new</span>[] <span class="comment">//匿名类型的对象数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Jones&quot;</span>, FName=<span class="string">&quot;Mary&quot;</span>, Age=<span class="number">19</span>, Major=<span class="string">&quot;History&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Smith&quot;</span>, FName=<span class="string">&quot;Bob&quot;</span>, Age=<span class="number">20</span>, Major=<span class="string">&quot;CompSci&quot;</span> &#125;,</span><br><span class="line">        <span class="keyword">new</span> &#123; LName=<span class="string">&quot;Fleming&quot;</span>, FName=<span class="string">&quot;Carol&quot;</span>, Age=<span class="number">21</span>, Major=<span class="string">&quot;History&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> query = <span class="keyword">from</span> student <span class="keyword">in</span> students</span><br><span class="line">                <span class="keyword">group</span> student <span class="keyword">by</span> student.Major;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> g <span class="keyword">in</span> query) <span class="comment">//枚举分组</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, g.Key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> s <span class="keyword">in</span> g) <span class="comment">//枚举分组中的项</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot; <span class="subst">&#123; s.LName &#125;</span>, <span class="subst">&#123; s.FName &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">History</span><br><span class="line"> Jones, Mary</span><br><span class="line"> Fleming, Carol</span><br><span class="line">CompSci</span><br><span class="line"> Smith, Bob</span><br></pre></td></tr></table></figure><p>下图演示了从查询表达式返回并保存于查询变量中的对象：<br>①从查询表达式返回的对象是从查询中枚举分组结果的可枚举类型；<br>②每一个分组由一个叫做键的字段区分；<br>③每一个分组本身是可枚举类型并且可以枚举它的项。</p><div  align="center">  <img src="https://s2.loli.net/2023/03/11/qVzFHNBl5svUwky.png" width = "65%" height = "65%" alt="图96 - group子句返回对象集合的集合"/></div><h3 id="查询延续：into-子句"><a href="#查询延续：into-子句" class="headerlink" title="查询延续：into 子句"></a>查询延续：into 子句</h3><p>查询延续子句可以接受查询的一部分的结果并赋予一个名字，从而可以在查询的另一部分中使用，示例如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> groupA = <span class="keyword">new</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> groupB = <span class="keyword">new</span>[] &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> someInts = <span class="keyword">from</span> a <span class="keyword">in</span> groupA</span><br><span class="line">                    <span class="keyword">join</span> b <span class="keyword">in</span> groupB <span class="keyword">on</span> a <span class="keyword">equals</span> b</span><br><span class="line">                    <span class="keyword">into</span> groupAandB <span class="comment">//查询延续</span></span><br><span class="line">                    <span class="keyword">from</span> c <span class="keyword">in</span> groupAandB</span><br><span class="line">                    <span class="keyword">select</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> v <span class="keyword">in</span> someInts)</span><br><span class="line">        Console.Write(<span class="string">$&quot;<span class="subst">&#123; v &#125;</span> &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">4 5 6</span><br></pre></td></tr></table></figure><h2 id="标准查询运算符"><a href="#标准查询运算符" class="headerlink" title="标准查询运算符"></a>标准查询运算符</h2><p>标准查询运算符由一系列 API 方法组成，可以查询任何 .NET 数组或集合。标准查询运算符的重要特性如下：<br>①标准查询运算符使用方法语法；<br>②一些运算符返回 IEnumerable 对象，而其他运算符返回标量。返回标量的运算符立即执行查询，并返回一个值，而不是一个可枚举类型对象。ToArray( )、ToList( )等 ToCollection 运算符也会立即执行；<br>③很多操作都是以一个谓词作为参数。<strong>谓词 predicate</strong> 是一个方法，它以对象为参数，根据对象是否满足某个条件而返回 true 或 false 。<br>④被查询的集合对象叫作<strong>序列 sequence</strong> ，它必须实现 IEnumerable&lt;T&gt;接口。</p><p>示例如下，用作方法的运算符直接作用于序列对象，在这里就是 numbers 数组，返回类型是 int ：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span>[] numbers = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> total = numbers.Sum();</span><br><span class="line">        <span class="built_in">int</span> howMany = numbers.Count();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Total: <span class="subst">&#123; total &#125;</span>, Count: <span class="subst">&#123; howMany &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Total: 12, Count: 3</span><br></pre></td></tr></table></figure><p>有大量标准查询运算符，可用来操作一个或多个序列。序列指实现了 IEnumerable&lt; &gt;接口的类，包括 List&lt; &gt;、Dictionary&lt; &gt;、Stack&lt; &gt;、Array 等。如下表，列出了这些运算符：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Where</td><td style="text-align:left">根据给定的谓词对序列进行过滤</td></tr><tr><td style="text-align:left">Select</td><td style="text-align:left">指定要包含一个对象或对象的一部分</td></tr><tr><td style="text-align:left">SelectMany</td><td style="text-align:left">一种查询类型，返回集合的集合。该方法将这些结果合并为一个单独的集合</td></tr><tr><td style="text-align:left">Take</td><td style="text-align:left">接受一个输出参数count，返回序列中的前count个对象</td></tr><tr><td style="text-align:left">Skip</td><td style="text-align:left">接受一个输出参数count，跳过序列中的前count个对象，返回剩余对象</td></tr><tr><td style="text-align:left">TakeWhile</td><td style="text-align:left">接受一个谓词，开始迭代序列，只要谓词对当前项的计算结果为true，就选择该项。在谓词返回第一个false时，该项和其余项都被丢弃</td></tr><tr><td style="text-align:left">SkipWhile</td><td style="text-align:left">接受一个谓词，开始迭代序列，只要谓词对当前项的计算结果为true，就跳过该项。在谓词返回第一个false时，该项和其余项都被选择</td></tr><tr><td style="text-align:left">Join</td><td style="text-align:left">对两个序列执行内联结</td></tr><tr><td style="text-align:left">GroupJoin</td><td style="text-align:left">可以产生层次结果的联结，第一个序列中的各个元素都与第二个序列中的元素集合相关联</td></tr><tr><td style="text-align:left">Concat</td><td style="text-align:left">连接两个序列</td></tr><tr><td style="text-align:left">OrderBy/ThenBy</td><td style="text-align:left">根据一个或多个键对序列中的元素按升序排序</td></tr><tr><td style="text-align:left">Reverse</td><td style="text-align:left">反转序列中的元素</td></tr><tr><td style="text-align:left">GroupBy</td><td style="text-align:left">分组序列中的元素</td></tr><tr><td style="text-align:left">Distinct</td><td style="text-align:left">去除序列中的重复项</td></tr><tr><td style="text-align:left">Union</td><td style="text-align:left">返回两个序列的并集</td></tr><tr><td style="text-align:left">Intersect</td><td style="text-align:left">返回两个序列的交集</td></tr><tr><td style="text-align:left">Except</td><td style="text-align:left">操作两个序列。返回的是第一个序列中不重复的元素减去同样位于第二个序列中的元素</td></tr><tr><td style="text-align:left">AsEnumerable</td><td style="text-align:left">将序列作为IEnumerable&lt;TSource&gt;返回</td></tr><tr><td style="text-align:left">AsQueryable</td><td style="text-align:left">将IEnumerable转换为IQueryable</td></tr><tr><td style="text-align:left">ToArray</td><td style="text-align:left">将序列作为数组返回</td></tr><tr><td style="text-align:left">ToList</td><td style="text-align:left">将序列作为List&lt;T&gt;返回</td></tr><tr><td style="text-align:left">ToDictionary</td><td style="text-align:left">将序列作为Dictionary&lt;TKey, TElement&gt;返回</td></tr><tr><td style="text-align:left">ToLookup</td><td style="text-align:left">将序列作为LookUp&lt;TKey, TElement&gt;返回</td></tr><tr><td style="text-align:left">OfType</td><td style="text-align:left">返回的序列中的元素是指定的类型</td></tr><tr><td style="text-align:left">Cast</td><td style="text-align:left">将序列中所有元素强制转换为给定的类型</td></tr><tr><td style="text-align:left">SequenceEqual</td><td style="text-align:left">返回一个布尔值，指定两个序列是否相等</td></tr><tr><td style="text-align:left">First</td><td style="text-align:left">返回序列中第一个与谓词匹配的元素。如果没有元素与谓词匹配，就抛出InvalidOperationException</td></tr><tr><td style="text-align:left">FirstOrDefault</td><td style="text-align:left">返回序列中第一个与谓词匹配的元素。如果没有给出谓词，方法返回序列的第一个元素。如果没有元素与谓词匹配，就使用该类型的默认值</td></tr><tr><td style="text-align:left">Last</td><td style="text-align:left">返回序列中最后一个与谓词匹配的元素。如果没有元素与谓词匹配，就抛出InvalidOperationException</td></tr><tr><td style="text-align:left">LastOrDefault</td><td style="text-align:left">返回序列中最后一个与谓词匹配的元素。如果没有元素与谓词匹配，就使用该类型的默认值</td></tr><tr><td style="text-align:left">Single</td><td style="text-align:left">返回序列中与谓词匹配的单个元素。如果没有元素匹配，或多于一个元素匹配，就抛出异常</td></tr><tr><td style="text-align:left">SingleOrDefault</td><td style="text-align:left">返回序列中与谓词匹配的单个元素。如果没有元素匹配，或多于一个元素匹配，就返回默认值</td></tr><tr><td style="text-align:left">ElementAt</td><td style="text-align:left">给定一个参数n，返回序列中第n+1个元素</td></tr><tr><td style="text-align:left">ElementAtOrDefault</td><td style="text-align:left">给定一个参数n，返回序列中第n+1个元素。如果索引超出范围，就返回默认值</td></tr><tr><td style="text-align:left">DefaultIfEmpty</td><td style="text-align:left">提供一个在序列为空时的默认值</td></tr><tr><td style="text-align:left">Range</td><td style="text-align:left">给定一个start整形和count整形，该方法返回的序列包含count个整形，其中第一个元素的值为start，每个后续元素都比前一个大1</td></tr><tr><td style="text-align:left">Repeat</td><td style="text-align:left">给定一个T类型的element和一个count整数，该方法返回的序列具有count个element副本</td></tr><tr><td style="text-align:left">Empty</td><td style="text-align:left">返回给定类型T的空序列</td></tr><tr><td style="text-align:left">Any</td><td style="text-align:left">返回一个布尔值，指明序列中是否存在满足谓词的元素</td></tr><tr><td style="text-align:left">All</td><td style="text-align:left">返回一个布尔值，指明序列中的全部元素是否都满足谓词</td></tr><tr><td style="text-align:left">Contains</td><td style="text-align:left">返回一个布尔值，指明序列中是否包含给定的元素</td></tr><tr><td style="text-align:left">Count</td><td style="text-align:left">返回序列中元素的个数（int）。它的重载可以接受一个谓词，并返回序列中满足谓词的元素个数</td></tr><tr><td style="text-align:left">Sum</td><td style="text-align:left">返回序列中值的总数</td></tr><tr><td style="text-align:left">Min</td><td style="text-align:left">返回序列中最小的值</td></tr><tr><td style="text-align:left">Max</td><td style="text-align:left">返回序列中最大的值</td></tr><tr><td style="text-align:left">Average</td><td style="text-align:left">返回序列中的平均值</td></tr><tr><td style="text-align:left">Aggregate</td><td style="text-align:left">连续对序列中的各个元素应用给定的函数</td></tr></tbody></table></div><h3 id="标准查询运算符的签名"><a href="#标准查询运算符的签名" class="headerlink" title="标准查询运算符的签名"></a>标准查询运算符的签名</h3><p>System.Linq.Enumerable 类声明了标准查询运算符方法。然而，这些方法不仅仅是普通方法，它们是扩展了 IEnumerable&lt;T&gt;泛型类的扩展方法。第8章和第18章中介绍了扩展方法，但本节更为详细。</p><p>扩展方法是公有的静态方法，尽管定义在一个类中，但目的是为另一个类（第一个形参）增加功能，该参数前必须有关键字 this 。</p><p>有关签名的重要事项：<br>①由于运算符是泛型方法，因此每个方法名都具有相关的泛型参数（T）；<br>②由于运算符是扩展 IEnumerable 类的扩展方法，必须声明为 public 和 static ，在第一个参数前有 this 扩展指示器，把 IEnumerable&lt;T&gt;作为第一个参数类型。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>      <span class="built_in">int</span>       <span class="title">Count</span>&lt;<span class="title">T</span>&gt;(<span class="params"> <span class="keyword">this</span> IEnumerable&lt;T&gt; source </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>       T        <span class="title">First</span>&lt;<span class="title">T</span>&gt;(<span class="params"> <span class="keyword">this</span> IEnumerable&lt;T&gt; source </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IEnumerable</span>&lt;<span class="title">T</span>&gt; <span class="title">Where</span>&lt;<span class="title">T</span>&gt;(<span class="params"> <span class="keyword">this</span> IEnumerable&lt;T&gt; source, ... </span>)</span>;</span><br></pre></td></tr></table></figure><p>如下代码，演示了直接调用扩展方法和将其作为扩展进行调用的区别。前两次的直接调用和普通方法类似，传入数组名字作为第一个参数。方法语法调用和扩展语法调用在语义上完全相等，只是语法不同：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> count1 = Enumerable.Count(intArray); <span class="comment">//方法语法</span></span><br><span class="line">    <span class="keyword">var</span> firstNum1 = Enumerable.First(intArray); <span class="comment">//方法语法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> count2 = intArray.Count(); <span class="comment">//扩展语法</span></span><br><span class="line">    <span class="keyword">var</span> firstNum2 = intArray.First(); <span class="comment">//扩展语法</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Count: <span class="subst">&#123; count1 &#125;</span>, FirstNumber: <span class="subst">&#123; firstNum1 &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Count: <span class="subst">&#123; count2 &#125;</span>, FirstNumber: <span class="subst">&#123; firstNum2 &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Count: 6, FirstNumber: 3</span><br><span class="line">Count: 6, FirstNumber: 3</span><br></pre></td></tr></table></figure><h3 id="查询表达式和标准查询运算符"><a href="#查询表达式和标准查询运算符" class="headerlink" title="查询表达式和标准查询运算符"></a>查询表达式和标准查询运算符</h3><p>每一个查询表达式都可以使用带有标准查询运算符的方法语法来编写。编译器把每一个查询表达式翻译成标准查询运算符的形式。由于所有查询表达式都被翻译成标准查询运算符，因此运算符可以执行由查询表达式完成的任何操作，而且运算符还有查询表达式形式所不能提供的附加功能。例如，在之前示例中使用的 Sum 和 Count 运算符，可以只用方法语法来表示。</p><p>查询表达式和方法语法这两种表达式也可以组合，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> numbers = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> howMany = (<span class="keyword">from</span> n <span class="keyword">in</span> numbers</span><br><span class="line">                   <span class="keyword">where</span> n &lt; <span class="number">7</span></span><br><span class="line">                   <span class="keyword">select</span> n).Count();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Count: <span class="subst">&#123; howMany &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Count: 3</span><br></pre></td></tr></table></figure><h3 id="将委托作为参数"><a href="#将委托作为参数" class="headerlink" title="将委托作为参数"></a>将委托作为参数</h3><p>每一个运算符的第一个参数是 IEnumerable&lt;T&gt; 对象的引用，之后的参数可以是任何类型。很多运算符接受泛型委托作为参数，泛型委托用于给运算符提供用户定义的代码，解释如下：</p><p>比如 Count 运算符被重载且有两种形式。第一种形式，即之前的示例，它有一个参数，返回集合中元素的个数，签名如下：<code>public static int Count&lt;T&gt;(this IEnumerable&lt;T&gt; source);</code></p><p>但若希望计算数组中奇数元素的总数，需为 Count 方法提供检测整数是否为奇数的代码，为此要使用 Count 方法的第二种形式，它接受一个泛型委托作为其第二个参数。调用时，必须提供一个接受单个 T 类型的输入参数并返回布尔值的委托对象，委托代码的返回值必须指定元素是否应包含在总数中：<code>public static int Count&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate );</code></p><p>示例如下，对于集合的每次遍历，Count 调用 Lambda 表达式表示的方法并把当前值作为输入，如果输入的是奇数，方法返回 true，Count 会把这个元素包含在总数中：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> countOdd = intArray.Count(n =&gt; n % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Count of odd numbers: <span class="subst">&#123; countOdd &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Count of odd numbers: 4</span><br></pre></td></tr></table></figure><h3 id="LINQ-预定义的委托类型"><a href="#LINQ-预定义的委托类型" class="headerlink" title="LINQ 预定义的委托类型"></a>LINQ 预定义的委托类型</h3><p>和前面的 Count 运算符类似，很多 LINQ 运算符需要提供代码来指示运算符如何执行它的操作，通过把委托对象作为参数来实现。.NET 框架定义了两套泛型委托来用于标准查询运算符，即 <strong>Func 委托</strong>和 <strong>Action 委托</strong>，各有19个成员。用作运算符实参的委托对象必须是这些形式之一。</p><p>下面列出了前4个泛型 Func 委托。TR 表示返回值，总是类型参数列表中的最后一个。&lt; &gt; 里的为类型参数，( ) 里的为方法参数：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TR <span class="title">Func</span>&lt;<span class="keyword">out</span> <span class="title">TR</span>&gt;                     (<span class="params"> </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TR <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">out</span> <span class="title">TR</span> &gt;             (<span class="params"> T1 a1 </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TR <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>, <span class="keyword">out</span> <span class="title">TR</span> &gt;      (<span class="params"> T1 a1, T2 a2 </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TR <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>, <span class="keyword">in</span> <span class="title">T3</span>, <span class="keyword">out</span> <span class="title">TR</span>&gt;(<span class="params"> T1 a1, T2 a2, T3 a3 </span>)</span>;</span><br></pre></td></tr></table></figure><p>注意返回类型参数有一个 out 关键字，使之可以协变。输入参数有个 in 关键字，使之可以逆变。</p><p>Count 的声明（第二种形式）里，第二个参数必须是上面说的委托对象，它接受单个 T 类型的值作为方法参数并且返回一个 bool 类型的值。如之前所说，这种形式的委托称为<strong>谓词</strong>。</p><p>以下是前4个 Action 委托，与 Func 委托类似，但没有返回值：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>                     (<span class="params"> </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>&gt;              (<span class="params"> T1 a1 </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>&gt;       (<span class="params"> T1 a1, T2 a2 </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>, <span class="keyword">in</span> <span class="title">T3</span>&gt;(<span class="params"> T1 a1, T2 a2, T3 a3 </span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="使用委托参数的示例"><a href="#使用委托参数的示例" class="headerlink" title="使用委托参数的示例"></a>使用委托参数的示例</h3><p>以下代码先声明了 IsOdd 方法，接受单个 int 类型的参数，并且返回表示输入参数是否为奇数的 bool 值，并且使用该方法来初始化名称为 MyDel 的委托对象。不需要声明 Func 委托类型，因为 .NET 框架已经预定义了：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsOdd</span>(<span class="params"><span class="built_in">int</span> x</span>) <span class="comment">//委托对象使用的方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span>; <span class="comment">//如果x是奇数，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; myDel = <span class="keyword">new</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;(IsOdd); <span class="comment">//委托对象</span></span><br><span class="line">        <span class="keyword">var</span> countOdd = intArray.Count(myDel); <span class="comment">//使用委托</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Count of odd numbers: <span class="subst">&#123; countOdd &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Count of odd numbers: 4</span><br></pre></td></tr></table></figure><h3 id="使用-Lambda-表达式参数的示例"><a href="#使用-Lambda-表达式参数的示例" class="headerlink" title="使用 Lambda 表达式参数的示例"></a>使用 Lambda 表达式参数的示例</h3><p>之前的示例使用独立的方法和委托来把代码附加到运算符上，这需要声明方法和委托对象，然后把委托对象传递给运算符。也可以使用 Lambda 表达式来给运算符提供代码，使用 Lambda 表达式修改之前的示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> countOdd = intArray.Count( x =&gt; x % <span class="number">2</span> == <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Count of odd numbers: <span class="subst">&#123; countOdd &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Count of odd numbers: 4</span><br></pre></td></tr></table></figure><p>也可以使用匿名方法，见第14章委托，来代替 Lambda 表达式，但是不如 Lambda 表达式简洁：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; myDel = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">                                &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> countOdd = intArray.Count(myDel);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Count of odd numbers: <span class="subst">&#123; countOdd &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LINQ-to-XML"><a href="#LINQ-to-XML" class="headerlink" title="LINQ to XML"></a>LINQ to XML</h2><p><strong>可扩展标记语言 Extensible Markup Language ( XML )</strong> 是存储和交换数据的重要方法。LINQ 为该语言增加了一些特性，简化了 XML 的创建、查询和操作：<br>①可以使用单一语句自顶而下创建 XML 树；<br>②可以在不使用包含树的 XML 文档在内存中创建并操作 XML ；<br>③可以不使用 Text 子节点来创建和操作字符串节点；<br>④搜索 XML 树时，不需要遍历它。只需要查询树并让它返回想要的结果。</p><h3 id="标记语言"><a href="#标记语言" class="headerlink" title="标记语言"></a>标记语言</h3><p><strong>标记语言 markup language</strong> 是文档中的一组标签，它提供有关文档的信息并组织其内容。即标记语言不是文档的数据，它们包含关于数据的数据(元数据)。标记语言是定义的一组标签，旨在传递有关文档内容的特定类型的元数据，比如 HTML 的标签中的元数据包含了 Web 页面如何在浏览器中呈现以及如何使用超链接在页面中导航的信息。</p><p>大部分标记语言包含一组预定义的标签，而 XML 只包含少量预定义的标签，其他由程序员定义，用来表示特定文档类型需要的任何元数据。</p><h3 id="XML-基础"><a href="#XML-基础" class="headerlink" title="XML 基础"></a>XML 基础</h3><p>XML 文档中的数据包含在一个 XML 数中，XML 树主要由嵌套元素组成。<strong>元素</strong>是 XML 树的基本要素。每个元素都有名字且包含数据，一些元素还包含其他被嵌套元素。元素由开始和关闭标签进行划分。任何元素包含的数据都必须介于开始和关闭标签之间：<br>①开始标签：<code>&lt;PhoneNumber&gt;</code>；<br>②关闭标签：<code>&lt;/PhoneNumber&gt;</code>；<br>③没有内容的元素可以直接由单个标签表示：<code>&lt;PhoneNumber /&gt;</code></p><p>有关 XML 的重要事项：<br>① XML 文档必须有一个根元素来包含所有其他元素；<br>② XML 标签必须合理嵌套；<br>③与 HTML 标签不同，XML 标签是区分大小写的；<br>④ XML 特性是名字/值的配对，它包含了元素的额外元数据。特性的值部分必须包含在引号内，单引号双引号皆可；<br>⑤ XML 文档中的空格是有效的。这与把空格作为单个空格输出的 HTML 不同。</p><p>如下示例，包含了一个 Employees 类型的根节点，它包含了两个 Employee 类型的子节点：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Employees</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Employee</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Bob Smith<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PhoneNumber</span>&gt;</span>408-555-1000<span class="tag">&lt;/<span class="name">PhoneNumber</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CellPhone</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Employee</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Employee</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Sally Jones<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PhoneNumber</span>&gt;</span>415-555-2000<span class="tag">&lt;/<span class="name">PhoneNumber</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PhoneNumber</span>&gt;</span>415-555-2001<span class="tag">&lt;/<span class="name">PhoneNumber</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Employee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Employees</span>&gt;</span></span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/03/18/PHKWjBJ2Qukweh8.png" width = "65%" height = "65%" alt="图97 - 示例的 XML 树的层次结构"/></div><h3 id="XML-类"><a href="#XML-类" class="headerlink" title="XML 类"></a>XML 类</h3><p>LINQ to XML 可以用两种方式用于 XML 。第一种是简化的 XML API 操作(LINQ to XML API)，第二种为之前的 LINQ 查询工具。</p><p>LINQ to XML API 由很多表示 XML 树组件的类组成。我们会使用 3 个最重要的类包括 XElement、XAttribute 和 XDocument。</p><p>下图演示了用于构造 XML 树的类以及它们如何被嵌套：  </p><div  align="center">  <img src="https://s2.loli.net/2023/03/18/NTrSxoJGkaPtO4U.png" width = "75%" height = "75%" alt="图98 - XML 节点的容器结构"/></div><p>① XDocument 节点中 XDeclaration 节点、XDocumentType 节点以及 XElement 节点的每一个节点类型最多有一个，XProcessingInstruction 节点可以为任意数量；<br>②如果在 XDocument 下有最高级别的 XElement 节点，那么它就是 XML 树中其他元素的根；<br>③根元素可以包含任意数量的嵌套 XElement、XComment 或 XProcessingInstruction 节点，并且可以在任何级别上嵌套。</p><p>除了 XAttribute 类，大多数用于创建 XML 树的类都从一个叫做 XNode 的类继承，或叫做 XNodes 。上图中，白色背景的为 XNode 类，灰色背景的为 XAttribute 类。</p><p><strong><em>1. 创建、保存、加载和显示 XML 文档</em></strong><br>示例如下，创建了一个简单的包含一个 Employees 节点的 XML 树：<br>①树使用一条语句来创建，并同时在适当的位置创建所有的嵌套元素，叫做<strong>函数式构造 functional construction</strong> ；<br>②每一个元素由对象创建表达式在适当的位置创建，使用了节点类型的构造函数。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq; <span class="comment">//需要的命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">        XDocument employees1 =</span><br><span class="line">            <span class="keyword">new</span> XDocument( <span class="comment">//创建 XML 文档</span></span><br><span class="line">                <span class="keyword">new</span> XElement(<span class="string">&quot;Employees&quot;</span>, <span class="comment">//创建根元素</span></span><br><span class="line">                    <span class="keyword">new</span> XElement(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Bob Smith&quot;</span>), <span class="comment">//创建元素</span></span><br><span class="line">                    <span class="keyword">new</span> XElement(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Sally Jones&quot;</span>) <span class="comment">//创建元素</span></span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        employees1.Save(<span class="string">&quot;EmployeesFile.xml&quot;</span>); <span class="comment">//保存到文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将保存的文档加载到新变量中</span></span><br><span class="line">        XDocument employees2 = XDocument.Load(<span class="string">&quot;EmployeesFile.xml&quot;</span>); <span class="comment">//静态方法</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(employees2); <span class="comment">//显示文档</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;Employees&gt;</span><br><span class="line">  &lt;Name&gt;Bob Smith&lt;/Name&gt;</span><br><span class="line">  &lt;Name&gt;Sally Jones&lt;/Name&gt;</span><br><span class="line">&lt;/Employees&gt;</span><br></pre></td></tr></table></figure><p><strong><em>2. 创建 XML 树</em></strong><br>对于 XDocument 和 XElement 的构造函数：<br>①第一个参数都是对象名；<br>②第二个参数以及之后的参数包含了 XML 树的节点。构造函数的第二个参数是一个 params 参数，即任意多的参数。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq; <span class="comment">//此命名空间是必需的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">        XDocument employeeDoc =</span><br><span class="line">            <span class="keyword">new</span> XDocument( <span class="comment">//创建文档</span></span><br><span class="line">                <span class="keyword">new</span> XElement(<span class="string">&quot;Employees&quot;</span>, <span class="comment">//创建根元素</span></span><br><span class="line">                    <span class="keyword">new</span> XElement(<span class="string">&quot;Employee&quot;</span>, <span class="comment">//第一个employee元素</span></span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Bob Smith&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;PhoneNumber&quot;</span>, <span class="string">&quot;408-555-1000&quot;</span>) ),</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">new</span> XElement(<span class="string">&quot;Employee&quot;</span>, <span class="comment">//第二个employee元素</span></span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Sally Jones&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;PhoneNumber&quot;</span>, <span class="string">&quot;415-555-2000&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;PhoneNumber&quot;</span>, <span class="string">&quot;415-555-2001&quot;</span>) )</span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line">        Console.WriteLine(employeeDoc); <span class="comment">//显示文档</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;Employees&gt;</span><br><span class="line">  &lt;Employee&gt;</span><br><span class="line">    &lt;Name&gt;Bob Smith&lt;/Name&gt;</span><br><span class="line">    &lt;PhoneNumber&gt;408-555-1000&lt;/PhoneNumber&gt;</span><br><span class="line">  &lt;/Employee&gt;</span><br><span class="line">  &lt;Employee&gt;</span><br><span class="line">    &lt;Name&gt;Sally Jones&lt;/Name&gt;</span><br><span class="line">    &lt;PhoneNumber&gt;415-555-2000&lt;/PhoneNumber&gt;</span><br><span class="line">    &lt;PhoneNumber&gt;415-555-2001&lt;/PhoneNumber&gt;</span><br><span class="line">  &lt;/Employee&gt;</span><br><span class="line">&lt;/Employees&gt;</span><br></pre></td></tr></table></figure><p><strong><em>3. 使用 XML 树的值</em></strong><br>可以遍历 XML 树来获取或修改值，下表列出了用于获取数据的主要方法：</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">类</th><th style="text-align:left">返回类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Nodes</td><td style="text-align:left">XDocument、XElement</td><td style="text-align:left">IEnumerable&lt;object&gt;</td><td style="text-align:left">返回当前节点的所有子节点</td></tr><tr><td style="text-align:left">Elements</td><td style="text-align:left">XDocument、XElement</td><td style="text-align:left">IEnumerable&lt;XElement&gt;</td><td style="text-align:left">返回当前节点的 XElement 子节点，或所有具有某个名字的子节点</td></tr><tr><td style="text-align:left">Element</td><td style="text-align:left">XDocument、XElement</td><td style="text-align:left">XElement</td><td style="text-align:left">返回当前节点的第一个 XElement 子节点，或具有某个名字的子节点</td></tr><tr><td style="text-align:left">Descendants</td><td style="text-align:left">XElement</td><td style="text-align:left">IEnumerable&lt;XElement&gt;</td><td style="text-align:left">返回所有的 XElement 子代节点，或所有具有某名字的 XElement 子代节点，不管它们处于当前节点下什么嵌套级别</td></tr><tr><td style="text-align:left">DescendantsAndSelf</td><td style="text-align:left">XElement</td><td style="text-align:left">IEnumerable&lt;XElement&gt;</td><td style="text-align:left">和 Descendents 一样，但是包括当前节点</td></tr><tr><td style="text-align:left">Ancestors</td><td style="text-align:left">XElement</td><td style="text-align:left">IEnumerable&lt;XElement&gt;</td><td style="text-align:left">返回所有上级 XElement 节点，或者所有具有某个名字的上级 XElement 节点</td></tr><tr><td style="text-align:left">AncestorsAndSelf</td><td style="text-align:left">XElement</td><td style="text-align:left">IEnumerable&lt;XElement&gt;</td><td style="text-align:left">和 Ancestors 一样，但是包含当前节点</td></tr><tr><td style="text-align:left">Parent</td><td style="text-align:left">XElement</td><td style="text-align:left">XElement</td><td style="text-align:left">返回当前节点的父节点</td></tr></tbody></table></div><p>① Nodes：Nodes 方法返回 IEnumerable&lt;object&gt; 类型的对象，因为返回的节点可能是不同的类型，比如 XElement、XComment 等。我们可以使用以类型作为参数的方法 OfType(type) 来指定返回某类型的节点。例如，如下代码只能获取 XComment 节点：<code>IEnumerable&lt;XComment&gt; comments = xd.Nodes().OfType&lt;XComment&gt;();</code><br>② Elements：由于获取 XElements 是非常普遍的需求，就出现了 Nodes.OfType(XElement)() 表达式的简短形式，即 Elements 方法：<br>&emsp;&emsp;- 无参数的 Elements 方法返回所有子 XElements；<br>&emsp;&emsp;- 单个 name 参数的 Elements 方法只返回具有这个名字的子 XElements 。例如，如下代码返回具有名字 PhoneNumber 的子 XElement 节点：<code>IEnumerable&lt;XElement&gt; empPhones = emp.Elements(&quot;PhoneNumber&quot;);</code><br>③ Element：这个方法只获取当前节点的第一个子 XElement 。如果无参数，获取第一个子 XElement 节点，如果带一个名字参数，获取第一个具有该名字的子 XElement；<br>④ Descendants 和 Ancestors：这些方法和 Elements 以及 Parent 方法差不多，只不过它们不返回直接的子元素和父元素，而是忽略嵌套级别，包括所有当前节点之下或者之上的节点。</p><p>如下代码演示了 Element 和 Elements 方法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">        XDocument employeeDoc =</span><br><span class="line">            <span class="keyword">new</span> XDocument(</span><br><span class="line">                <span class="keyword">new</span> XElement(<span class="string">&quot;Employees&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> XElement(<span class="string">&quot;Employee&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Bob Smith&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;PhoneNumber&quot;</span>, <span class="string">&quot;408-555-1000&quot;</span>)),</span><br><span class="line">                    <span class="keyword">new</span> XElement(<span class="string">&quot;Employee&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Sally Jones&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;PhoneNumber&quot;</span>, <span class="string">&quot;415-555-2000&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> XElement(<span class="string">&quot;PhoneNumber&quot;</span>, <span class="string">&quot;415-555-2001&quot;</span>))</span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        XElement root = employeeDoc.Element(<span class="string">&quot;Employees&quot;</span>);</span><br><span class="line">        IEnumerable&lt;XElement&gt; employees = root.Elements();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (XElement emp <span class="keyword">in</span> employees)</span><br><span class="line">        &#123;</span><br><span class="line">            XElement empNameNode = emp.Element(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">            Console.WriteLine(empNameNode.Value);</span><br><span class="line"></span><br><span class="line">            IEnumerable&lt;XElement&gt; empPhones = emp.Elements(<span class="string">&quot;PhoneNumber&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (XElement phone <span class="keyword">in</span> empPhones)</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot; <span class="subst">&#123; phone.Value &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Bob Smith</span><br><span class="line"> 408-555-1000</span><br><span class="line">Sally Jones</span><br><span class="line"> 415-555-2000</span><br><span class="line"> 415-555-2001</span><br></pre></td></tr></table></figure><p><strong><em>4. 增加节点以及操作 XML</em></strong><br>可以使用 Add 方法在一次方法调用中增加任意多个元素，不管增加的节点类型是什么，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        XDocument xd = <span class="keyword">new</span> XDocument( <span class="comment">//创建XML树</span></span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;root&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>)</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Original tree&quot;</span>);</span><br><span class="line">        Console.WriteLine(xd); Console.WriteLine(); <span class="comment">//显示树</span></span><br><span class="line"></span><br><span class="line">        XElement rt = xd.Element(<span class="string">&quot;root&quot;</span>); <span class="comment">//获取第一个元素</span></span><br><span class="line"></span><br><span class="line">        rt.Add( <span class="keyword">new</span> XElement(<span class="string">&quot;second&quot;</span>)); <span class="comment">//添加子元素</span></span><br><span class="line"></span><br><span class="line">        rt.Add( <span class="keyword">new</span> XElement(<span class="string">&quot;third&quot;</span>), <span class="comment">//再添加3个子元素</span></span><br><span class="line">                <span class="keyword">new</span> XComment(<span class="string">&quot;Important Comment&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> XElement(<span class="string">&quot;fourth&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Modified tree&quot;</span>);</span><br><span class="line">        Console.WriteLine(xd); <span class="comment">//显示modified树.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Original tree</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line">Modified tree</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">  &lt;second /&gt;</span><br><span class="line">  &lt;third /&gt;</span><br><span class="line">  &lt;!--Important Comment--&gt;</span><br><span class="line">  &lt;fourth /&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>Add 方法把新的子节点放在既有子节点之后，也可以使用 AddFirst、AddBeforeSelf 和 AddAfterSelf 方法放在其他位置。下表列出了一些常见的操作 XML 的方法：</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">从哪里调用</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Add</td><td style="text-align:left">父节点</td><td style="text-align:left">在当前节点的既有子节点后增加新的子节点</td></tr><tr><td style="text-align:left">AddFirst</td><td style="text-align:left">父节点</td><td style="text-align:left">在当前节点的既有子节点前增加新的子节点</td></tr><tr><td style="text-align:left">AddBeforeSelf</td><td style="text-align:left">节点</td><td style="text-align:left">在同级别的当前节点之前增加新的节点</td></tr><tr><td style="text-align:left">AddAfterSelf</td><td style="text-align:left">节点</td><td style="text-align:left">在同级别的当前节点之后增加新的节点</td></tr><tr><td style="text-align:left">Remove</td><td style="text-align:left">节点</td><td style="text-align:left">删除当前所选的节点及其内容</td></tr><tr><td style="text-align:left">RemoveNodes</td><td style="text-align:left">节点</td><td style="text-align:left">删除当前所选的 XElement 及其内容</td></tr><tr><td style="text-align:left">SetElement</td><td style="text-align:left">父节点</td><td style="text-align:left">设置节点的内容</td></tr></tbody></table></div><h3 id="使用-XML-特性"><a href="#使用-XML-特性" class="headerlink" title="使用 XML 特性"></a>使用 XML 特性</h3><p><strong>特性 Attribute</strong> 提供了有关 XElement 节点的额外信息，它放在 XML 元素的开始标签中。当以函数方法构造 XML 树时，在 XElement 构造函数中包含 XAttribute 构造函数就可以增加特性。XAttribute 构造函数有两种形式：一种接受 name 和 value，另一种接受现有 XAttribute 的引用。</p><p>如下代码为 root 增加了两个特性：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">XDocument xd = <span class="keyword">new</span> XDocument(</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> XElement(<span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>), <span class="comment">//特性构造函数，参数为名称和值</span></span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;large&quot;</span>), <span class="comment">//特性构造函数，参数为名称和值</span></span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;second&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(xd);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;root color=&quot;red&quot; size=&quot;large&quot;&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">  &lt;second /&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>要从一个 XElement 节点获取特性可以使用 Attribute 方法，提供特性名称作为参数即可，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XDocument xd = <span class="keyword">new</span> XDocument( <span class="comment">//创建XML树</span></span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;large&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(xd); Console.WriteLine(); <span class="comment">//显示XML树</span></span><br><span class="line"></span><br><span class="line">    XElement rt = xd.Element(<span class="string">&quot;root&quot;</span>); <span class="comment">//获取元素</span></span><br><span class="line"></span><br><span class="line">    XAttribute color = rt.Attribute(<span class="string">&quot;color&quot;</span>); <span class="comment">//获取特性</span></span><br><span class="line">    XAttribute size = rt.Attribute(<span class="string">&quot;size&quot;</span>); <span class="comment">//获取特性</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;color is <span class="subst">&#123; color.Value &#125;</span>&quot;</span>); <span class="comment">//显示特性值</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;size is <span class="subst">&#123; size.Value &#125;</span>&quot;</span>); <span class="comment">//显示特性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;root color=&quot;red&quot; size=&quot;large&quot;&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line">color is red</span><br><span class="line">size is large</span><br></pre></td></tr></table></figure><p>要移除特性，可以选择一个特性使用 Remove 方法，或者在父节点使用 SetAttributeValue 方法把特性值设置为 null，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">    XDocument xd = <span class="keyword">new</span> XDocument(</span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;large&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    XElement rt = xd.Element(<span class="string">&quot;root&quot;</span>); <span class="comment">//获取元素</span></span><br><span class="line"></span><br><span class="line">    rt.Attribute(<span class="string">&quot;color&quot;</span>).Remove(); <span class="comment">//移除color特性</span></span><br><span class="line">    rt.SetAttributeValue(<span class="string">&quot;size&quot;</span>, <span class="literal">null</span>); <span class="comment">//移除size特性</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(xd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>要向 XML 树增加一个特性或改变特性的值，也可以使用 SetAttributeValue 方法，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">    XDocument xd = <span class="keyword">new</span> XDocument(</span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;large&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    XElement rt = xd.Element(<span class="string">&quot;root&quot;</span>); <span class="comment">//获取元素</span></span><br><span class="line"></span><br><span class="line">    rt.SetAttributeValue(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;medium&quot;</span>); <span class="comment">//改变特性值</span></span><br><span class="line">    rt.SetAttributeValue(<span class="string">&quot;width&quot;</span>, <span class="string">&quot;narrow&quot;</span>); <span class="comment">//添加特性</span></span><br><span class="line"></span><br><span class="line">    Console.WriteLine(xd); Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;root color=&quot;red&quot; size=&quot;medium&quot; width=&quot;narrow&quot;&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><h3 id="其他类型的节点"><a href="#其他类型的节点" class="headerlink" title="其他类型的节点"></a>其他类型的节点</h3><p><strong><em>1. XComment</em></strong><br>XML 注释由 &lt;!— 和 —&gt; 记号之间的文本组成。记号之间的文本会被 XML 解析器忽略。也可以使用 XComment 类向一个 XML 文档插入文本，比如：<code>new XComment(&quot;This is a comment&quot;)</code>，产生如下的 XML 文档行：<code>&lt;!--This is a comment--&gt;</code>。</p><p><strong><em>2. XDeclaration</em></strong><br>XML 文档从包含 XML 使用的版本号、字符编码类型以及文档是否依赖外部引用的一行开始。这是有关 XML 的信息，因此它其实是有关数据的元数据。这叫做 XML 声明，可以使用 XDeclaration 类来插入，示例如下：<code>new XDeclaration(&quot;1.0&quot;, &quot;utf-8&quot;, &quot;yes&quot;)</code>，产生如下的 XML 文档行：<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;</code>。</p><p><strong><em>3. XProcessingInstruction</em></strong><br>XML 处理指令用于提供关于 XML 文档的使用和解释方式的额外数据。处理指令最常用于关联 XML 文档和样式表。  </p><p>可以使用 XProecssingInstruction 构造函数来包含处理指令。它接受两个字符串参数：目标和数据串。如果处理指令接受多个数据参数，这些参数必须包含在 XProecssingInstruction 构造函数的第二个字符串参数中，如下的构造函数代码所示。注意，第二个参数是一个逐字字符串，在字符串中的双引号文本使用两个连续的双引号来表现：<code>new XProcessingInstruction( &quot;xml-stylesheet&quot;, @&quot;href=&quot;&quot;stories&quot;&quot;, type=&quot;&quot;text/css&quot;&quot;&quot;)</code>，产生如下的 XML 文档行：<code>&lt;?xml-stylesheet href=&quot;stories.css&quot; type=&quot;text/css&quot;?&gt;</code>。</p><p>结合上述3个构造函数的代码如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XDocument xd = <span class="keyword">new</span> XDocument(</span><br><span class="line">        <span class="keyword">new</span> XDeclaration(<span class="string">&quot;1.0&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="string">&quot;yes&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> XComment(<span class="string">&quot;This is a comment&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> XProcessingInstruction(<span class="string">&quot;xml-stylesheet&quot;</span>,</span><br><span class="line">                                    <span class="string">@&quot;href=&quot;&quot;stories.css&quot;&quot; type=&quot;&quot;text/css&quot;&quot;&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;root&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;second&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码产生如下的输入文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;yes&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--This is a comment--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet href=<span class="string">&quot;stories.css&quot;</span> type=<span class="string">&quot;text/css&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">first</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">second</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用 xd 的 WriteLine，即使声明语句包含在文档文件中也不会显示，输出如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;!--This is a comment--&gt;</span><br><span class="line">&lt;?xml-stylesheet href=&quot;stories.css&quot; type=&quot;text/css&quot;?&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;first /&gt;</span><br><span class="line">  &lt;second /&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-LINQ-to-XML-的-LINQ-查询"><a href="#使用-LINQ-to-XML-的-LINQ-查询" class="headerlink" title="使用 LINQ to XML 的 LINQ 查询"></a>使用 LINQ to XML 的 LINQ 查询</h3><p>把 LINQ XML API 和 LINQ 查询表达式组合起来使用。</p><p>先创建一个简单的 XML 树：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XDocument xd = <span class="keyword">new</span> XDocument(</span><br><span class="line">        <span class="keyword">new</span> XElement(<span class="string">&quot;MyElements&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;first&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;small&quot;</span>)),</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;second&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;red&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;medium&quot;</span>)),</span><br><span class="line">            <span class="keyword">new</span> XElement(<span class="string">&quot;third&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> XAttribute(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;blue&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> XAttribute(<span class="string">&quot;size&quot;</span>, <span class="string">&quot;large&quot;</span>))));</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(xd); <span class="comment">//显示XML树</span></span><br><span class="line">    xd.Save(<span class="string">&quot;SimpleSample.xml&quot;</span>); <span class="comment">//保存XML树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&lt;MyElements&gt;</span><br><span class="line">  &lt;first color=&quot;red&quot; size=&quot;small&quot; /&gt;</span><br><span class="line">  &lt;second color=&quot;red&quot; size=&quot;medium&quot; /&gt;</span><br><span class="line">  &lt;third color=&quot;blue&quot; size=&quot;large&quot; /&gt;</span><br><span class="line">&lt;/MyElements&gt;</span><br></pre></td></tr></table></figure><p>以下代码使用了 LINQ 查询来从 XML 树中选择节点的子集，然后以各种方式显示：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XDocument xd = XDocument.Load(<span class="string">&quot;SimpleSample.xml&quot;</span>); <span class="comment">//加载文档</span></span><br><span class="line">    XElement rt = xd.Element(<span class="string">&quot;MyElements&quot;</span>); <span class="comment">//获取根元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xyz = <span class="keyword">from</span> e <span class="keyword">in</span> rt.Elements() <span class="comment">//选择元素</span></span><br><span class="line">                <span class="keyword">where</span> e.Name.ToString().Length == <span class="number">5</span> <span class="comment">//5个字符长度的元素</span></span><br><span class="line">                <span class="keyword">select</span> e;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (XElement x <span class="keyword">in</span> xyz)</span><br><span class="line">        Console.WriteLine(x.Name.ToString());</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    <span class="keyword">foreach</span> (XElement x <span class="keyword">in</span> xyz)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Name: &#123;0&#125;, color: &#123;1&#125;, size: &#123;2&#125;&quot;</span>,</span><br><span class="line">                            x.Name,</span><br><span class="line">                            x.Attribute(<span class="string">&quot;color&quot;</span>).Value, <span class="comment">//获取特性的值</span></span><br><span class="line">                            x.Attribute(<span class="string">&quot;size&quot;</span>) .Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">first</span><br><span class="line">third</span><br><span class="line"></span><br><span class="line">Name: first, color: red, size: small</span><br><span class="line">Name: third, color: blue, size: large</span><br></pre></td></tr></table></figure><p>如下代码使用了一个简单的查询来获取 XML 树的所有顶层元素，并为每一个元素创建了一个匿名类型的对象：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Linq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XDocument xd = XDocument.Load(<span class="string">&quot;SimpleSample.xml&quot;</span>); <span class="comment">//加载文档</span></span><br><span class="line">    XElement rt = xd.Element(<span class="string">&quot;MyElements&quot;</span>); <span class="comment">//获取根元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xyz = <span class="keyword">from</span> e <span class="keyword">in</span> rt.Elements()</span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">new</span> &#123; e.Name, color = e.Attribute(<span class="string">&quot;color&quot;</span>) &#125;; <span class="comment">//创建匿名类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> xyz)</span><br><span class="line">        Console.WriteLine(x);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> xyz)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0,-6&#125;, color: &#123;1, -7&#125;&quot;</span>, x.Name, x.color.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&#123; Name = first, color = color=&quot;red&quot; &#125;</span><br><span class="line">&#123; Name = second, color = color=&quot;red&quot; &#125;</span><br><span class="line">&#123; Name = third, color = color=&quot;blue&quot; &#125;</span><br><span class="line"></span><br><span class="line">first , color: red</span><br><span class="line">second, color: red</span><br><span class="line">third , color: blue</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> C#读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> .net </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C#图解教程》读书笔记（二）</title>
      <link href="/2022/12/06/2022-12-06-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B2/"/>
      <url>/2022/12/06/2022-12-06-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇主要内容为：表达式与运算符；语句；结构；枚举；数组；委托；事件。<br>读书笔记仅为知识的记录，方便后续查找。<br>学习完成日期为2023年07月29日。  </p></blockquote><div  align="center">  <img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/></div><h1 id="第九章-表达式和运算符"><a href="#第九章-表达式和运算符" class="headerlink" title="第九章 表达式和运算符"></a>第九章 表达式和运算符</h1><h2 id="表达式-Expressions"><a href="#表达式-Expressions" class="headerlink" title="表达式 Expressions"></a>表达式 Expressions</h2><p><strong>运算符 operator</strong> 是一个符号，表示返回单个结果的操作。<strong>操作数 operand</strong> 指作为运算符输入的数据元素。<strong>表达式 expression</strong> 是运算符和操作数的字符串。比如 <code>a + b + c + d</code> 有3个运算符和4个操作数。</p><p><strong>表达式求值 Evaluating an expression</strong> 是将每个运算符以适当的顺序应用到它的操作数以产生一个值的过程。值被返回到表达式求值的位置。除了返回值，一些表达式可能还会在内存中设置一个值。</p><h2 id="字面量-Literals"><a href="#字面量-Literals" class="headerlink" title="字面量 Literals"></a>字面量 Literals</h2><p><strong>字面量</strong>是源代码中键入的数字或字符串。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="number">1024</span>); <span class="comment">//整数字面量</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="number">3.1416</span>); <span class="comment">//双精度型字面量</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="number">3.1416F</span>); <span class="comment">//浮点型字面量</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="literal">true</span>); <span class="comment">//布尔型字面量</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">//字符型字面量</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="string">&quot;Hi there&quot;</span>); <span class="comment">//字符串字面量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① bool 有两个字面量：true 和 false ，注意和所有 C# 关键字一样，它们都是小写。<br>② 对于引用类型变量，字面量 null 表示变量没有指向内存中的数据。</p><h3 id="整数字面量-Integer-Literals"><a href="#整数字面量-Integer-Literals" class="headerlink" title="整数字面量 Integer Literals"></a>整数字面量 Integer Literals</h3><p>整数字面量被书写为十进制数字序列，没有小数点，带有可选的后缀，指明整数的类型。</p><p>比如以下四个字面量：<br><code>236 //整数</code><br><code>236L //长整数</code><br><code>236U //无符号整数</code><br><code>236UL //无符号长整数</code>  </p><p>整数类型字面量还可以写成十六进制 hex 形式，以 0x 或 0X 为前缀，实际数据类型用后缀指定。也可以写成二进制记法，以 0b 或 0B 为前缀，实际数据类型用后缀指定。</p><p>若没有后缀，编译器会把数字字符串解释为能表示该值而不丢失数据的相应类型的最小类型，比如236和5000000000都没有后缀，236会被解释为一个 int ，5000000000会被解释为一个 long 。</p><p>可以在数字字面量插入分隔符：<code>5_000_000_000</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:left">后缀</th><th style="text-align:left">整数类型</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">无</td><td style="text-align:left">int, uint, long, ulong</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">U, u</td><td style="text-align:left">uint, ulong</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">L, l</td><td style="text-align:left">long, ulong</td><td style="text-align:left">不推荐使用小写字母l，会和数字1混淆</td></tr><tr><td style="text-align:left">ul, uL, Ul, UL, lu, Lu, lU, LU</td><td style="text-align:left">ulong</td><td style="text-align:left">不推荐使用小写字母l，会和数字1混淆</td></tr></tbody></table></div><h3 id="实数字面量-Real-Literals"><a href="#实数字面量-Real-Literals" class="headerlink" title="实数字面量 Real Literals"></a>实数字面量 Real Literals</h3><p>C# 有三种实数数据类型：float、double 和 decimal ，分别对应32位、64位和128位精度，都是浮点数据类型，实际使用中，double 最常用。</p><p>实数字面量包括十进制数字；一个可选的小数点；一个可选的指数部分 E 或 e ；一个可选的后缀：<br><code>float f1 = 236F;</code><br><code>double d1 = 236.714;</code><br><code>double d2 = .35192;</code><br><code>double d3 = 6.338e-26;</code></p><div class="table-container"><table><thead><tr><th style="text-align:left">后缀</th><th style="text-align:left">实数类型</th></tr></thead><tbody><tr><td style="text-align:left">无</td><td style="text-align:left">double</td></tr><tr><td style="text-align:left">F, f</td><td style="text-align:left">float</td></tr><tr><td style="text-align:left">D, d</td><td style="text-align:left">double</td></tr><tr><td style="text-align:left">M, m</td><td style="text-align:left">decimal</td></tr></tbody></table></div><blockquote><p>注意：无后缀的实数字面量是 double 类型，而不是 float 类型！！！</p></blockquote><h3 id="字符字面量-Character-Literals"><a href="#字符字面量-Character-Literals" class="headerlink" title="字符字面量 Character Literals"></a>字符字面量 Character Literals</h3><p><strong>字符字面量</strong>由<strong>两个单引号</strong>内的字符组成，用于表示单个字符(a)、非打印字符(\n换行符)或者执行特殊任务的字符，比如转义 escape (\)。</p><p>尽管可能需要多个字符来表示一个字符字面量，但是每个字符字面量只表示一个字符，要引入多个字符，必须使用字符串字面量。</p><p>字符字面量可以是以下任意一种：<br><code>char c1 = &#39;d&#39;; //单个字符</code><br><code>char c2 = &#39;\n&#39;; //简单转义序列</code><br><code>char c3 = &#39;\x0061&#39;; //十六进制转义序列</code><br><code>char c4 = &#39;\u005a&#39;; //Unicode转义序列</code>  </p><p>①字符字面量的类型是 <strong>char</strong> ；<br>②简单转义序列是一个反斜杠后面跟着单个字符；<br>③十六进制转义序列是一个反斜杠后面跟着 X 或 x，后面4个十六进制数字；<br>④Unicode 转义序列是一个反斜杠后面跟着 U 或 u，后面4个十六进制数字。</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">转义序列</th><th style="text-align:left">十六进制编码</th></tr></thead><tbody><tr><td style="text-align:left">空字符 Null</td><td style="text-align:left">\0</td><td style="text-align:left">0x0000</td></tr><tr><td style="text-align:left">警告 Alert</td><td style="text-align:left">\a</td><td style="text-align:left">0x0007</td></tr><tr><td style="text-align:left">退格符 Backspace</td><td style="text-align:left">\b</td><td style="text-align:left">0x0008</td></tr><tr><td style="text-align:left">水平制表符 Horizontal tab</td><td style="text-align:left">\t</td><td style="text-align:left">0x0009</td></tr><tr><td style="text-align:left">换行符 New line</td><td style="text-align:left">\n</td><td style="text-align:left">0x000A</td></tr><tr><td style="text-align:left">垂直制表符 Vertical tab</td><td style="text-align:left">\v</td><td style="text-align:left">0x000B</td></tr><tr><td style="text-align:left">换页符 Form feed</td><td style="text-align:left">\f</td><td style="text-align:left">0x000C</td></tr><tr><td style="text-align:left">回车符 Carriage return</td><td style="text-align:left">\r</td><td style="text-align:left">0x000D</td></tr><tr><td style="text-align:left">双引号 Double quote</td><td style="text-align:left">\”</td><td style="text-align:left">0x0022</td></tr><tr><td style="text-align:left">单引号 Single quote</td><td style="text-align:left">\’</td><td style="text-align:left">0x0027</td></tr><tr><td style="text-align:left">反斜杠 Backslash</td><td style="text-align:left">\\</td><td style="text-align:left">0x005C</td></tr></tbody></table></div><h3 id="字符串字面量-String-Literals"><a href="#字符串字面量-String-Literals" class="headerlink" title="字符串字面量 String Literals"></a>字符串字面量 String Literals</h3><p><strong>字符串字面量</strong>使用<strong>双引号</strong>标记，不同于字符字面量使用单引号。</p><p>字符串字面量有两种类型：①<strong>常规字符串字面量 Regular string literals</strong>；②<strong>逐字字符串字面量 Verbatim string literals</strong>。</p><p>常规字符串字面量可以包含：字符、简单转义序列、十六进制转义序列和Unicode转义序列。例如：<br><code>string st1 = &quot;Hi there!&quot;;</code><br><code>string st2 = &quot;Val1\t5, Val2\t10&quot;;</code><br><code>string st3 = &quot;Add\x000ASome\u0007Interest&quot;;</code></p><p>逐字字符串字面量是以 @ 字符为前缀的常规字符串字面量，逐字字符串字面量中字符串不会被转义。逐字字符串字面量的唯一例外就是相邻的双引号组，被解释为单个双引号字符。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> rst1 = <span class="string">&quot;Hi there!&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> vst1 = <span class="string">@&quot;Hi there!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> rst2 = <span class="string">&quot;It started, \&quot;Four score and seven...\&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> vst2 = <span class="string">@&quot;It started, &quot;&quot;Four score and seven...&quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> rst3 = <span class="string">&quot;Value 1 \t 5, Val2 \t 10&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> vst3 = <span class="string">@&quot;Value 1 \t 5, Val2 \t 10&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> rst4 = <span class="string">&quot;C:\\Program Files\\Microsoft\\&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> vst4 = <span class="string">@&quot;C:\Program Files\Microsoft\&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> rst5 = <span class="string">&quot; Print \x000A Multiple \u000A Lines&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> vst5 = <span class="string">@&quot; Print</span></span><br><span class="line"><span class="string">Multiple</span></span><br><span class="line"><span class="string">Lines&quot;</span>;</span><br></pre></td></tr></table></figure><p>打印这些字符串会产生以下输出：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Hi there!</span><br><span class="line">Hi there!</span><br><span class="line"></span><br><span class="line">It started, &quot;Four score and seven...&quot;</span><br><span class="line">It started, &quot;Four score and seven...&quot;</span><br><span class="line"></span><br><span class="line">Value 1 5, Val2 10</span><br><span class="line">Value 1 \t 5, Val2 \t 10</span><br><span class="line"></span><br><span class="line">C:\Program Files\Microsoft\</span><br><span class="line">C:\Program Files\Microsoft\</span><br><span class="line"></span><br><span class="line">Print</span><br><span class="line">Multiple</span><br><span class="line">Lines</span><br><span class="line"></span><br><span class="line">Print</span><br><span class="line">Multiple</span><br><span class="line">Lines</span><br></pre></td></tr></table></figure><blockquote><p>编译器让相同的字符串字面量共享堆中同一内存位置以节约内存。</p></blockquote><h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>表达式可以有很多嵌套的子表达式构成，求值顺序可以是表达式最终值发生变化。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>优先级从高到低如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">运算符</th></tr></thead><tbody><tr><td style="text-align:left">初级运算符 <font face= "Arial"> Primary </font></td><td style="text-align:left"><font face= "Arial"> a.x, f(x), a[x], x + +, x - -, new, typeof, checked, unchecked </font></td></tr><tr><td style="text-align:left">一元运算符 <font face= "Arial">Unary</font></td><td style="text-align:left"><font face= "Arial">+, -, !, ~, + + x, - - x, (T)x</font></td></tr><tr><td style="text-align:left">乘法 <font face= "Arial">Multiplicative</font></td><td style="text-align:left"><font face= "Arial"> *, /, % </font></td></tr><tr><td style="text-align:left">加法 <font face= "Arial">Additive</font></td><td style="text-align:left"><font face= "Arial">+, -</font></td></tr><tr><td style="text-align:left">移位 <font face= "Arial">Shift</font></td><td style="text-align:left"><font face= "Arial">&lt;&lt;, &gt;&gt;</font></td></tr><tr><td style="text-align:left">关系和类型 <font face= "Arial">Relational and type</font></td><td style="text-align:left"><font face= "Arial">&lt;, &gt;, &lt;=, &gt;=, is, as</font></td></tr><tr><td style="text-align:left">相等 <font face= "Arial">Equality</font></td><td style="text-align:left"><font face= "Arial">==, !=</font></td></tr><tr><td style="text-align:left">位与 <font face= "Arial">Logical AND</font></td><td style="text-align:left"><font face= "Arial">&amp;</font></td></tr><tr><td style="text-align:left">位异或 <font face= "Arial">Logical XOR</font></td><td style="text-align:left"><font face= "Arial">^</font></td></tr><tr><td style="text-align:left">位或 <font face= "Arial">Logical OR</font></td><td style="text-align:left"><font face= "Arial">&#124;</font></td></tr><tr><td style="text-align:left">条件与 <font face= "Arial">Conditional AND</font></td><td style="text-align:left"><font face= "Arial">&amp;&amp;</font></td></tr><tr><td style="text-align:left">条件或 <font face= "Arial">Conditional OR</font></td><td style="text-align:left"><font face= "Arial">&#124;&#124;</font></td></tr><tr><td style="text-align:left">条件选择 <font face= "Arial">Conditional</font></td><td style="text-align:left"><font face= "Arial">?:</font></td></tr><tr><td style="text-align:left">赋值运算符 <font face= "Arial">Assignment</font></td><td style="text-align:left"><font face= "Arial">=, *=, /=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=, &#124;=</font></td></tr></tbody></table></div><h3 id="结合性-Associativity"><a href="#结合性-Associativity" class="headerlink" title="结合性 Associativity"></a>结合性 Associativity</h3><p>如果有连续的运算符有相同的优先级别，求值顺序由<strong>操作结合性 operator associativity</strong> 决定，比如 <code>2/6*4</code> 求值顺序有2种。</p><p>运算符结合性重要特征：①左结合运算符从左至右求值；②右结合运算符从右至左求值；  </p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符类型</th><th style="text-align:left">结合性</th></tr></thead><tbody><tr><td style="text-align:left">赋值运算符</td><td style="text-align:left">右结合</td></tr><tr><td style="text-align:left">其他二元运算符</td><td style="text-align:left">左结合</td></tr><tr><td style="text-align:left">条件运算符</td><td style="text-align:left">右结合</td></tr></tbody></table></div><p>所以 <code>2/6*4</code> 应该是从左到右，得到 4/3 。</p><p>可以直接使用<strong>圆括号</strong>来显式地设定子表达式求值顺序，并覆盖优先级和结合性规则。</p><h2 id="简单算术运算符"><a href="#简单算术运算符" class="headerlink" title="简单算术运算符"></a>简单算术运算符</h2><p>简单算术运算符包括 <code>+</code> 、<code>-</code> 、<code>*</code> 、<code>/</code> 。这些运算符都是二元左结合运算符。对于除法，要注意整数除法，直接截取整数部分。</p><h2 id="求余运算符-The-Remainder-Operator"><a href="#求余运算符-The-Remainder-Operator" class="headerlink" title="求余运算符 The Remainder Operator"></a>求余运算符 The Remainder Operator</h2><p>求余运算符 <code>%</code> ，返回余数。</p><p>求余运算符还可以用于实数以得到实余数 real remainders。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;0.0f % 1.5f is &#123;0&#125;&quot;</span> , <span class="number">0.0f</span> % <span class="number">1.5f</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;0.5f % 1.5f is &#123;0&#125;&quot;</span> , <span class="number">0.5f</span> % <span class="number">1.5f</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;1.0f % 1.5f is &#123;0&#125;&quot;</span> , <span class="number">1.0f</span> % <span class="number">1.5f</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;1.5f % 1.5f is &#123;0&#125;&quot;</span> , <span class="number">1.5f</span> % <span class="number">1.5f</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;2.0f % 1.5f is &#123;0&#125;&quot;</span> , <span class="number">2.0f</span> % <span class="number">1.5f</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;2.5f % 1.5f is &#123;0&#125;&quot;</span> , <span class="number">2.5f</span> % <span class="number">1.5f</span>);</span><br></pre></td></tr></table></figure><p>得到：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">0.0f % 1.5f is 0 </span><br><span class="line">0.5f % 1.5f is 0.5 </span><br><span class="line">1.0f % 1.5f is 1 </span><br><span class="line">1.5f % 1.5f is 0 </span><br><span class="line">2.0f % 1.5f is 0.5 </span><br><span class="line">2.5f % 1.5f is 1 </span><br></pre></td></tr></table></figure><h2 id="关系比较运算符和相等比较运算符"><a href="#关系比较运算符和相等比较运算符" class="headerlink" title="关系比较运算符和相等比较运算符"></a>关系比较运算符和相等比较运算符</h2><p>关系比较运算符和相等比较运算符是二元运算符，比较它们的操作数并返回 bool 型值，它们都是左结合运算符。包括 <code>&lt;</code> , <code>&gt;</code> , <code>&lt;=</code> , <code>&gt;=</code> , <code>==</code> , <code>!=</code> 。</p><blockquote><p>与 C 和 C++ 不同，<strong>在 C# 中数字不具有布尔意义</strong>。</p></blockquote><h3 id="比较操作和相等性操作"><a href="#比较操作和相等性操作" class="headerlink" title="比较操作和相等性操作"></a>比较操作和相等性操作</h3><p>对于大多数引用类型来说，比较它们的相等性时，只比较它们的引用。<br>①如果引用相等，即指向内存中相同的对象，那么相等性比较为 true，否则为 false 。这称为<strong>浅比较 shallow comparison</strong> 。<br>② string 类型对象也是引用类型，但是比较字符串的相等性时，若两个字符串有相同的长度和内容（区分大小写），则返回 true ，即使它们占有不同的内存区域。这称为<strong>深比较 deep comparison</strong> 。</p><p>委托也是深比较，见第14章，若两个委托都是 null ，或两者的调用列表中有相同数目的成员，并且调用列表相匹配，则比较返回 true 。</p><p>比较数值表达式时，比较类型和值；比较 enum 类型，比较操作数的实际值，枚举见第12章。</p><h2 id="递增运算符和递减运算符-Increment-and-Decrement-Operators"><a href="#递增运算符和递减运算符-Increment-and-Decrement-Operators" class="headerlink" title="递增运算符和递减运算符 Increment and Decrement Operators"></a>递增运算符和递减运算符 Increment and Decrement Operators</h2><p>递增运算符和递减运算符是一元的，有2种形式，<strong>前置</strong>形式和<strong>后置</strong>形式，产生不同效果：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><font face= "Arial">++</font></td><td style="text-align:left">前置递增 <font face= "Arial">++var</font></td><td style="text-align:left">变量的值加1并保存，返回变量的新值</td></tr><tr><td style="text-align:left"><font face= "Arial">++</font></td><td style="text-align:left">后置递增 <font face= "Arial">var++</font></td><td style="text-align:left">变量的值加1并保存，返回变量递增之前的旧值</td></tr><tr><td style="text-align:left"><font face= "Arial">--</font></td><td style="text-align:left">前置递减 <font face= "Arial">--var</font></td><td style="text-align:left">变量的值减1并保存，返回变量的新值</td></tr><tr><td style="text-align:left"><font face= "Arial">--</font></td><td style="text-align:left">后置递减 <font face= "Arial">var--</font></td><td style="text-align:left">变量的值减1并保存，返回变量递增之前的旧值</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">表达式：x=10</th><th style="text-align:left">返回给表达式的值</th><th style="text-align:left">计算后变量的值</th></tr></thead><tbody><tr><td style="text-align:left">前置递增</td><td style="text-align:left"><font face= "Arial">++x</font></td><td style="text-align:left">11</td><td style="text-align:left">11</td></tr><tr><td style="text-align:left">后置递增</td><td style="text-align:left"><font face= "Arial">x++</font></td><td style="text-align:left">10</td><td style="text-align:left">11</td></tr><tr><td style="text-align:left">前置递减</td><td style="text-align:left"><font face= "Arial">--x</font></td><td style="text-align:left">9</td><td style="text-align:left">9</td></tr><tr><td style="text-align:left">后置递减</td><td style="text-align:left"><font face= "Arial">x--</font></td><td style="text-align:left">10</td><td style="text-align:left">9</td></tr></tbody></table></div><h2 id="条件逻辑运算符-Conditional-Logical-Operators"><a href="#条件逻辑运算符-Conditional-Logical-Operators" class="headerlink" title="条件逻辑运算符 Conditional Logical Operators"></a>条件逻辑运算符 Conditional Logical Operators</h2><p>逻辑运算符包括逻辑与 AND 、逻辑或 OR 、逻辑非 NOT 。逻辑与和逻辑或运算符是二元左结合运算符。逻辑非是一元运算符。</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">&amp;&amp;</td><td style="text-align:left">与</td><td style="text-align:left">如果两个操作数都是true，结果为true；否则为false</td></tr><tr><td style="text-align:left">&#124;&#124;</td><td style="text-align:left">或</td><td style="text-align:left">如果至少一个操作数是true，结果为true；否则为false</td></tr><tr><td style="text-align:left">!</td><td style="text-align:left">非</td><td style="text-align:left">如果操作数是false，结果为true；否则为false</td></tr></tbody></table></div><p>条件逻辑运算符使用 <strong>“短路” short-circuit</strong> 模式操作，即若计算第一个操作数之后就能确定值，就会跳过第二个操作数的计算。比如下面代码，变量 iVal 的后置递增不会被执行，因为执行了第一个子表达式后，可以确定返回值是 false 。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> bVal; <span class="built_in">int</span> iVal = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    bVal = (<span class="number">1</span> == <span class="number">2</span>) &amp;&amp; (<span class="number">9</span> == iVal++); <span class="comment">//结果：bVal = False, iVal = 10</span></span><br></pre></td></tr></table></figure><h2 id="逻辑运算符-Logical-Operators"><a href="#逻辑运算符-Logical-Operators" class="headerlink" title="逻辑运算符 Logical Operators"></a>逻辑运算符 Logical Operators</h2><p>按位逻辑运算符如下表，除按位非运算符以外，这些运算符都是二元左结合运算符，按位非运算符是一元运算符：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">位与 Bitwise AND</td><td style="text-align:left">仅当两个操作数都为1时，位的结果为1</td></tr><tr><td style="text-align:left">&#124;</td><td style="text-align:left">位或 Bitwise OR</td><td style="text-align:left">只要任意一个操作数为1时，位的结果为1</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">位异或 Bitwise XOR</td><td style="text-align:left">仅当一个而不是两个操作数为1时，位的结果为1</td></tr><tr><td style="text-align:left">~</td><td style="text-align:left">位非 Bitwise negation</td><td style="text-align:left">得到操作数的二进制反码</td></tr></tbody></table></div><div  align="center">  <img src="https://s2.loli.net/2023/01/05/I7cKHLZrNB9sbn4.png" width = "60%" height = "60%" alt="图46 - 按位逻辑操作示例"/></div><h2 id="移位运算符-Shift-Operators"><a href="#移位运算符-Shift-Operators" class="headerlink" title="移位运算符 Shift Operators"></a>移位运算符 Shift Operators</h2><p>移位运算符是二元左结合运算符：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">左移</td><td style="text-align:left">将位组向左移动给定数目个位置。位从左边移出并丢失，右边的位位置用0填充</td></tr><tr><td style="text-align:left">&gt;&gt;</td><td style="text-align:left">右移</td><td style="text-align:left">将位组向右移动给定数目个位置。位从右边移出并丢失</td></tr></tbody></table></div><p>底层硬件使用二进制补码 two’s complement 的形式表示有符号二进制数。在二进制补码表示法中，负数最左侧的位位置是1，正数的补码和原码一致，负数的补码是原码的基础上对各个位取反后加1。所以要把一个正数转换成负数，要把这个数按位取反再加1，反之亦然。</p><p>位移有符号的数字，左移一位的结果与把它乘以2的结果相同，右移一位的结果和除以2相同。然而如果右移一个负数，最左边位用0填充，会让数字变成正数，为了应对这种情形，当操作数是有符号的整数时，如果操作数最左边的位是1，在左边移开的位位置用1而不是0填充，这保持了正确的二进制补码表示法。</p><div  align="center">  <img src="https://s2.loli.net/2023/01/05/Gf4H6V7msDu5pvt.png" width = "65%" height = "65%" alt="图47 - 移位"/></div><h2 id="赋值运算符-Assignment-Operators"><a href="#赋值运算符-Assignment-Operators" class="headerlink" title="赋值运算符 Assignment Operators"></a>赋值运算符 Assignment Operators</h2><p>赋值运算符先将运算符右侧的表达式求值，并用该值设置运算符左边的变量的值，故赋值运算符是二元右结合运算符：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">简单赋值; 计算右边表达式的值，并把返回值赋给左边的变量或表达式</td></tr><tr><td style="text-align:left">*=</td><td style="text-align:left">复合赋值; var *= expr 等价于 var = var * (expr)</td></tr><tr><td style="text-align:left">/=</td><td style="text-align:left">复合赋值; var /= expr 等价于 var = var / (expr)</td></tr><tr><td style="text-align:left">%=</td><td style="text-align:left">复合赋值; var %= expr 等价于 var= var % (expr)</td></tr><tr><td style="text-align:left">+=</td><td style="text-align:left">复合赋值; var += expr 等价于 var = var + (expr)</td></tr><tr><td style="text-align:left">-=</td><td style="text-align:left">复合赋值; var -= expr 等价于 var = var- (expr)</td></tr><tr><td style="text-align:left">&lt;&lt;=</td><td style="text-align:left">复合赋值; var &lt;&lt;= expr 等价于 var = var &lt;&lt; (expr)</td></tr><tr><td style="text-align:left">&gt;&gt;=</td><td style="text-align:left">复合赋值; var &gt;&gt;= expr 等价于 var = var &gt;&gt; (expr)</td></tr><tr><td style="text-align:left">&amp;=</td><td style="text-align:left">复合赋值; var &amp;= expr 等价于 var = var &amp; (expr)</td></tr><tr><td style="text-align:left">^=</td><td style="text-align:left">复合赋值; var ^= expr 等价于 var = var ^ (expr)</td></tr><tr><td style="text-align:left">&#124;=</td><td style="text-align:left">复合赋值; var &#124;= expr 等价于 var = var &#124; (expr)</td></tr></tbody></table></div><p>对于复合赋值：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">x += y – z; <span class="comment">//等价于 x = x + (y – z);</span></span><br><span class="line">x *= y – z; <span class="comment">//等价于 x = x * (y – z);</span></span><br><span class="line">x /= y – z; <span class="comment">//等价于 x = x / (y – z);</span></span><br></pre></td></tr></table></figure><h2 id="条件运算符-The-Conditional-Operator"><a href="#条件运算符-The-Conditional-Operator" class="headerlink" title="条件运算符 The Conditional Operator"></a>条件运算符 The Conditional Operator</h2><p>条件运算符是三元运算符，语法如下：<code>Condition ? Expression1 : Expression2</code>，包含一个测试表达式和两个结果表达式：<br>① Condition 必须返回一个 bool 类型的值；<br>② 如果 Condition 求值为 true ，那么对 Expression1 求值并返回，否则，对 Expression2 求值并返回；</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( x &lt; y )</span><br><span class="line">    intVar = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    intVar = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>上述代码等价于 <code>intVar = x &lt; y ? 5 : 10;</code>，或者如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">intVar = x &lt; y</span><br><span class="line">        ? <span class="number">5</span></span><br><span class="line">        : <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="一元算术运算符-Unary-Arithmetic-Operators"><a href="#一元算术运算符-Unary-Arithmetic-Operators" class="headerlink" title="一元算术运算符 Unary Arithmetic Operators"></a>一元算术运算符 Unary Arithmetic Operators</h2><p>就是数学的正负号，比如 <code>int x = +10;</code> <code>int y = -x;</code></p><h2 id="用户定义的类型转换"><a href="#用户定义的类型转换" class="headerlink" title="用户定义的类型转换"></a>用户定义的类型转换</h2><p>用户定义的类型转换详见第17章，这里提一下是因为它们是运算符：</p><p>可以为自己的类和结构定义隐式转换和显式转换：<br>①对于隐式转换，编译器会根据特定上下文决定使用特定的类型，并进行自动转换；<br>②对于显式转换，编译器只在使用显式转换运算符时才执行转换。</p><p>声明隐式转换的语法如下，public 和 static 修饰符是必需的，TargetType 为目标类型，SourceType Identifier 为源数据：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">TargetType</span> (<span class="params"> SourceType Identifier </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ObjectOfTargetType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式转换语法相同，但用 explicit 替换 implicit 。</p><p>隐式转换示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">LimitedInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MaxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MinValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">int</span> (<span class="params">LimitedInt li</span>) <span class="comment">//将LimitedInt转换为int</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> li.TheValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">LimitedInt</span> (<span class="params"><span class="built_in">int</span> x</span>) <span class="comment">//将int转换为LimitedInt</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        LimitedInt li = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        li.TheValue = x;</span><br><span class="line">        <span class="keyword">return</span> li;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> mTheValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TheValue &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> mTheValue; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &lt; MinValue)</span><br><span class="line">                mTheValue = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mTheValue = <span class="keyword">value</span> &gt; MaxValue</span><br><span class="line">                                ? MaxValue</span><br><span class="line">                                : <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LimitedInt li = <span class="number">500</span>; <span class="comment">//将500转换为LimitedInt</span></span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = li; <span class="comment">//将LimitedInt转换为int</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;li: <span class="subst">&#123; li.TheValue &#125;</span>, value: <span class="subst">&#123; <span class="keyword">value</span> &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">li: 100, value: 100</span><br></pre></td></tr></table></figure><h3 id="显式转换和转换运算符-Explicit-Conversion-and-the-Cast-Operator"><a href="#显式转换和转换运算符-Explicit-Conversion-and-the-Cast-Operator" class="headerlink" title="显式转换和转换运算符 Explicit Conversion and the Cast Operator"></a>显式转换和转换运算符 Explicit Conversion and the Cast Operator</h3><p>将上述代码改为 explicit ，并且在实现转换时显式使用转换运算符。<strong>转换运算符 cast operator</strong> 由想要把表达式转换成的目标类型的名称组成，放在一对圆括号内：<code>LimitedInt li = (LimitedInt) 500;</code>。改变的部分代码如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">LimitedInt li</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> li.TheValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">LimitedInt</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LimitedInt li = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">    li.TheValue = x;</span><br><span class="line">    <span class="keyword">return</span> li;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    LimitedInt li = (LimitedInt) <span class="number">500</span>;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">value</span> = (<span class="built_in">int</span>) li;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;li: <span class="subst">&#123; li.TheValue &#125;</span>, value: <span class="subst">&#123; <span class="keyword">value</span> &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">li: 100, value: 100</span><br></pre></td></tr></table></figure><blockquote><p>is 和 as 运算符接受一种类型的值，并返回另一种不同的、指定类型的值。详见第17章。</p></blockquote><h2 id="运算符重载-Operator-Overloading"><a href="#运算符重载-Operator-Overloading" class="headerlink" title="运算符重载 Operator Overloading"></a>运算符重载 Operator Overloading</h2><p>C# 运算符被定义为使用预定义类型作为操作数，而<strong>运算符重载</strong>允许定义 C# 运算符应该如何操作自定义类型的操作数。<br>①运算符重载只能用于类和结构；<br>②为类或结构重载一个运算符 x ，可以声明一个名称为 operate x 的方法并实现它的行为：<br>&emsp;&emsp;- 一元运算符的重载方法带有一个单独的 class 或 struct 类型的参数；<br>&emsp;&emsp;- 二元运算符的重载方法带两个参数，其中至少有一个必须是class 或 struct 类型。<br>③运算符重载的方法声明必须同时使用 static 和 public 的修饰符，且运算符必须是要操作的类或结构的成员。  </p><h3 id="运算符重载的示例"><a href="#运算符重载的示例" class="headerlink" title="运算符重载的示例"></a>运算符重载的示例</h3><p>以下代码展示了3个运算符的重载：负数、减法和加法。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">LimitedInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MaxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MinValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LimitedInt <span class="keyword">operator</span> -(LimitedInt x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取一个值的负数等于0</span></span><br><span class="line">        LimitedInt li = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        li.TheValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> li;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LimitedInt <span class="keyword">operator</span> -(LimitedInt x, LimitedInt y)</span><br><span class="line">    &#123;</span><br><span class="line">        LimitedInt li = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        li.TheValue = x.TheValue - y.TheValue;</span><br><span class="line">        <span class="keyword">return</span> li;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LimitedInt <span class="keyword">operator</span> +(LimitedInt x, <span class="built_in">double</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        LimitedInt li = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        li.TheValue = x.TheValue + (<span class="built_in">int</span>)y;</span><br><span class="line">        <span class="keyword">return</span> li;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _theValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TheValue</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _theValue; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &lt; MinValue)</span><br><span class="line">                _theValue = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                _theValue = <span class="keyword">value</span> &gt; MaxValue</span><br><span class="line">                                ? MaxValue</span><br><span class="line">                                : <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        LimitedInt li1 = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        LimitedInt li2 = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        LimitedInt li3 = <span class="keyword">new</span> LimitedInt();</span><br><span class="line">        li1.TheValue = <span class="number">10</span>; li2.TheValue = <span class="number">26</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot; li1: <span class="subst">&#123; li1.TheValue &#125;</span>, li2: <span class="subst">&#123; li2.TheValue &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        li3 = -li1;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;-<span class="subst">&#123; li1.TheValue &#125;</span> = <span class="subst">&#123; li3.TheValue &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        li3 = li2 - li1;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot; <span class="subst">&#123; li2.TheValue &#125;</span> - <span class="subst">&#123; li1.TheValue &#125;</span> = <span class="subst">&#123; li3.TheValue &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        li3 = li1 - li2;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot; <span class="subst">&#123; li1.TheValue &#125;</span> - <span class="subst">&#123; li2.TheValue &#125;</span> = <span class="subst">&#123; li3.TheValue &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line"> li1: 10, li2: 26</span><br><span class="line">-10 = 0</span><br><span class="line"> 26 - 10 = 16</span><br><span class="line"> 10 - 26 = 0</span><br></pre></td></tr></table></figure><h3 id="运算符重载的限制"><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h3><p>不是所有的运算符都能被重载：<br>①可重载的一元运算符：+ , - , ! , ~ , ++ , -- , true , false<br>②可重载的二元运算符：+ , - , * , / , % , &amp; , | , ^ , &lt;&lt; , &gt;&gt; , == , != , &gt; , &lt; , &gt;= , &lt;=</p><p>运算符重载不能创建新运算符；不能改变运算符语法；不能重新定义如何处理预定义类型；不能改变运算符的优先级和结合性。</p><p>递增运算符和递减运算符也可以重载：<br>①在运行时，代码对对象执行前置操作（递增或递减）时，会发生以下行为：<br>&emsp;&emsp;- 在对象上执行递增或递减代码；<br>&emsp;&emsp;- 返回对象。<br>②在运行时，代码对对象执行后置操作（递增或递减）时，会发生以下行为：<br>&emsp;&emsp;- 如果对象是值对象，则系统会复制该对象；如果对象是引用类型，则引用会被复制；<br>&emsp;&emsp;- 在对象上执行递增或递减代码；<br>&emsp;&emsp;- 返回保存的操作数。</p><p>对于引用类型的对象，前置操作没问题。但是对于后置操作，因为保存的副本是引用的副本，即指向同一对象，当执行到第二步操作时，递增或递减代码影响了对象，会导致保存的引用指向的对象不是起始状态。</p><p>示例如下，可以运行以下代码2次，第二次将 MyType 的类型改为类，会得到不同结果：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyType <span class="comment">//运行两次，一个是结构体，一次是类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyType</span>(<span class="params"> <span class="built_in">int</span> x </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyType <span class="keyword">operator</span> ++( MyType m )</span><br><span class="line">    &#123;</span><br><span class="line">        m.X++;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"> <span class="built_in">string</span> message, MyType tv </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WriteLine( <span class="string">$&quot;<span class="subst">&#123;message&#125;</span> <span class="subst">&#123;tv.X&#125;</span>&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyType tv = <span class="keyword">new</span> MyType( <span class="number">10</span> );</span><br><span class="line">        WriteLine( <span class="string">&quot;Pre-increment&quot;</span> );</span><br><span class="line">        Show( <span class="string">&quot;Before &quot;</span>, tv );</span><br><span class="line">        Show( <span class="string">&quot;Returned &quot;</span>, ++tv );</span><br><span class="line">        Show( <span class="string">&quot;After &quot;</span>, tv );</span><br><span class="line">        WriteLine();</span><br><span class="line"></span><br><span class="line">        tv = <span class="keyword">new</span> MyType( <span class="number">10</span> );</span><br><span class="line">        WriteLine( <span class="string">&quot;Post-increment&quot;</span> );</span><br><span class="line">        Show( <span class="string">&quot;Before &quot;</span>, tv );</span><br><span class="line">        Show( <span class="string">&quot;Returned &quot;</span>, tv++ );</span><br><span class="line">        Show( <span class="string">&quot;After &quot;</span>, tv );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Pre-increment</span><br><span class="line">Before  10</span><br><span class="line">Returned  11</span><br><span class="line">After  11</span><br><span class="line"></span><br><span class="line">Post-increment</span><br><span class="line">Before  10</span><br><span class="line">Returned  10</span><br><span class="line">After  11</span><br></pre></td></tr></table></figure><p>如果将 MyType 改为类，运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Pre-increment</span><br><span class="line">Before  10</span><br><span class="line">Returned  11</span><br><span class="line">After  11</span><br><span class="line"></span><br><span class="line">Post-increment</span><br><span class="line">Before  10</span><br><span class="line">Returned  11</span><br><span class="line">After  11</span><br></pre></td></tr></table></figure><h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><p><strong>typeof 运算符</strong>返回作为其参数的任何类型的 System.Type 对象。通过这个对象可以了解类型的特征。typeof 运算符是一元运算符。</p><p>下面是 typeof 运算符语法的示例，Type 是 System 命名空间中的一个类，代码使用了 typeof 运算符以获取 SomeClass 类的信息，并打印出公有字段和方法的名称：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Reflection; <span class="comment">//使用反射命名空间来全面利用检测类型信息的功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Field1;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Field2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Method2</span>()</span> &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type t = <span class="keyword">typeof</span>(SomeClass);</span><br><span class="line">        FieldInfo[] fi = t.GetFields();</span><br><span class="line">        MethodInfo[] mi = t.GetMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (FieldInfo f <span class="keyword">in</span> fi)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Field : <span class="subst">&#123; f.Name &#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (MethodInfo m <span class="keyword">in</span> mi)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Method: <span class="subst">&#123; m.Name &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Field : Field1</span><br><span class="line">Field : Field2</span><br><span class="line">Method: Method1</span><br><span class="line">Method: Method2</span><br><span class="line">Method: GetType</span><br><span class="line">Method: ToString</span><br><span class="line">Method: Equals</span><br><span class="line">Method: GetHashCode</span><br></pre></td></tr></table></figure><p><strong>GetType</strong> 方法也会调用 typeof 运算符，该方法对每个类型的每个对象都有效，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SomeClass s = <span class="keyword">new</span> SomeClass();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Type s: <span class="subst">&#123; s.GetType().Name &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Type s: SomeClass</span><br></pre></td></tr></table></figure><h2 id="nameof-运算符"><a href="#nameof-运算符" class="headerlink" title="nameof 运算符"></a>nameof 运算符</h2><p><strong>nameof 运算符</strong>返回一个表示传入参数的字符串，以下示例展示了可以作为参数传递给 nameof 运算符的不同项，注释的括号里是每个语句的输出：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> var1 = <span class="string">&quot;Local Variable&quot;</span>;</span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (var1)); <span class="comment">//局部变量(&quot;var1&quot;)</span></span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (MyClass)); <span class="comment">//类(&quot;MyClass&quot;)</span></span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (MyClass.Method1)); <span class="comment">//公有方法(&quot;Method1&quot;)</span></span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (parameter1)); <span class="comment">//方法参数(&quot;parameter1&quot;)</span></span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (MyClass.Property1)); <span class="comment">//公有属性(&quot;Property1&quot;)</span></span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (MyClass.Field1)); <span class="comment">//公有字段(&quot;Field1&quot;)</span></span><br><span class="line">Console.WriteLine (<span class="keyword">nameof</span> (MyStruct)); <span class="comment">//结构体(&quot;MyStruct &quot;)</span></span><br></pre></td></tr></table></figure><p>即使参数使用完全限定名，nameof 运算符也只返回其参数的非限定名称。</p><p>nameof 运算符主要用于代码名称会变更的时候。</p><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p>以上介绍的运算符都是内置类型的标准运算符，后面还有一些特殊用法的运算符。</p><h1 id="第十章-语句"><a href="#第十章-语句" class="headerlink" title="第十章 语句"></a>第十章 语句</h1><h2 id="什么是语句"><a href="#什么是语句" class="headerlink" title="什么是语句"></a>什么是语句</h2><p><strong>语句 statement</strong> 是描述某个类型或让程序执行某个动作的源代码指令。语句主要有3种类型：<br>①<strong>声明语句 Declaration statements</strong> ：声明类型或变量；<br>②<strong>嵌入语句 Embedded statements</strong> ：执行动作或管理控制流；<br>③<strong>标签语句 Labeled statements</strong> ：控制跳转。</p><p><strong>块</strong>是由一对大括号括起来的语句序列，括起来的语句可以包括：声明语句、嵌入语句、标签语句和嵌套块。块在语法上算作一个单条嵌入语句。任何语法上需要一个嵌入语句的地方，都可以使用块。</p><p><strong>简单语句</strong>由一个表达式和后面跟着的分号组成。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">10</span>; <span class="comment">//简单声明</span></span><br><span class="line"><span class="built_in">int</span> z; <span class="comment">//简单声明</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">//块</span></span><br><span class="line">    <span class="built_in">int</span> y = <span class="number">20</span>; <span class="comment">//简单声明</span></span><br><span class="line">    z = x + y; <span class="comment">//嵌入语句</span></span><br><span class="line">top: y = <span class="number">30</span>; <span class="comment">//标签语句</span></span><br><span class="line">        ...</span><br><span class="line">    &#123; <span class="comment">//嵌套块</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="comment">//结束嵌套块</span></span><br><span class="line">&#125; <span class="comment">//结束外部块</span></span><br></pre></td></tr></table></figure><p><strong>空语句</strong>仅由一个分号组成，一般用在语法需要一条嵌入语句，但又不需要它有任何动作，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( x &lt; y )</span><br><span class="line">    ; <span class="comment">//空语句</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    z = a + b; <span class="comment">//简单语句</span></span><br></pre></td></tr></table></figure><h2 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h2><p>可以在表达式后面放置语句终结符（分号）来从一个表达式创建一条语句，表达式返回的任何值都会被丢弃。比如：<code>x = 10;</code> 该表达式把运算符右边的值赋给变量 x 引用的内存位置，设置了 x 的值后，表达式返回 x 的新值，然后因为没有东西接受该值，该值被忽略。</p><h2 id="控制流语句-Flow-of-Control-Statements"><a href="#控制流语句-Flow-of-Control-Statements" class="headerlink" title="控制流语句 Flow-of-Control Statements"></a>控制流语句 Flow-of-Control Statements</h2><p><strong>条件执行语句 Conditional execution statements</strong> 包括：<code>if</code> , <code>if...else</code> , <code>switch</code> ;<br><strong>循环语句 Looping statements</strong> 包括：<code>while</code> , <code>do</code> , <code>for</code> , <code>foreach</code> ;<br><strong>跳转语句 Jump statements</strong> 包括：<code>break</code> , <code>continue</code> , <code>return</code> , <code>goto</code> , <code>throw</code> ;</p><blockquote><p>与 C 和 C++ 不同，数字在 C# 没有布尔意义。</p></blockquote><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p><strong>if 语句</strong>实现按条件执行：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( TestExpr )</span><br><span class="line">    Statement</span><br></pre></td></tr></table></figure><p>①TestExpr 必须计算成 bool 型值；<br>②如果 TestExpr 求值为 true ，执行 Statement ；<br>③如果求值为 false ，则跳过 Statement 。</p><p>示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单语句</span></span><br><span class="line"><span class="keyword">if</span>( x &lt;= <span class="number">10</span> )</span><br><span class="line">    z = x – <span class="number">1</span>; <span class="comment">//简单语句不需要大括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//块</span></span><br><span class="line"><span class="keyword">if</span>( x &gt;= <span class="number">20</span> )</span><br><span class="line">&#123;</span><br><span class="line">    x = x – <span class="number">5</span>; <span class="comment">//块需要大括号</span></span><br><span class="line">    y = x + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>( x ) <span class="comment">//错误：表达式必须是bool型，而不是int型</span></span><br><span class="line">&#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a>if…else 语句</h2><p><strong>if…else 语句</strong>实现双路分支：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( TestExpr )</span><br><span class="line">    Statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Statement2</span><br></pre></td></tr></table></figure><p>①如果 TestExpr 求值为 true，执行 Statement1 。<br>②如果求值为 false，执行 Statement2 .</p><p>示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( x &lt;= <span class="number">10</span> )</span><br><span class="line">    z = x – <span class="number">1</span>; <span class="comment">//简单语句</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    x = x – <span class="number">5</span>; <span class="comment">//多条语句组成的语句块</span></span><br><span class="line">    y = x + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Statement1 和 Statement2 可以嵌套 if 或 if…else 语句。当 Statement2 是 if 或 if…else 语句，常常会格式化为下面的形式：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( TestExpr1 )</span><br><span class="line">    <span class="function">Statement1</span></span><br><span class="line"><span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params"> TestExpr2 </span>)</span></span><br><span class="line"><span class="function">    Statement2</span></span><br><span class="line"><span class="function"><span class="keyword">else</span></span></span><br><span class="line"><span class="function">    Statement3</span></span><br></pre></td></tr></table></figure><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p><strong>while 循环</strong>是一种简单循环结构，其测试表达式在循环顶部执行：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( TestExpr )</span><br><span class="line">    Statement</span><br></pre></td></tr></table></figure><p>①若 TestExpr 求值为 true 时，执行 Statement，并且再次对 TestExpr 求值，直到 TestExpr 求值为 false ；<br>②若 TestExpr 求值为 false，执行在 while 循环结尾之后的语句。</p><p>示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;x: <span class="subst">&#123; x &#125;</span>&quot;</span>);</span><br><span class="line">    x--;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Out of loop&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="do-循环"><a href="#do-循环" class="headerlink" title="do 循环"></a>do 循环</h2><p><strong>do 循环</strong>是一种简单循环结构，其测试表达式在循环底部执行：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">    Statement</span></span><br><span class="line"><span class="function"><span class="title">while</span>(<span class="params"> TestExpr </span>)</span>; <span class="comment">//结束do循环，别忘了分号</span></span><br></pre></td></tr></table></figure><p>①首先执行 Statement ；<br>②然后，对 TestExpr 求值。若为 true，再次执行 Statement，再重复，直到返回 false ，控制传递到循环结构结尾之后的语句。</p><p>示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;x is <span class="subst">&#123;x++ &#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (x&lt;<span class="number">3</span>); <span class="comment">//分号是必需的，别忘了</span></span><br></pre></td></tr></table></figure><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>只要测试表达式在循环体顶端计算时返回 true，for循环结构就会执行循环体：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( Initializer ; TestExpr ; IterationExpr )</span><br><span class="line">    Statement</span><br></pre></td></tr></table></figure><p>①在 for 循环开始时，执行一次 Initializer 。Initializer 只执行一次，常用于声明和初始化循环中使用的局部变量；<br>②然后对 TestExpr 求值，若为 true ，执行 Statement ，接着执行 IterationExpr 。接着控制回到循环顶端，再次对 TestExpr 求值，重复步骤，直到返回 false ，执行循环之后的语句；<br>③ Initializer 、TestExpr 和 IterationExpr 都是可选的。若 TestExpr 为空，测试返回 true ，会进入无限循环，需要有退出该语句的方法。作为字段分隔符，两个分号是必须的，即使省略了上述部分。</p><p>示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行3次for循环体</span></span><br><span class="line"><span class="keyword">for</span>( <span class="built_in">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">3</span> ; i++ )</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Inside loop. i: <span class="subst">&#123; i &#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Out of Loop&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="for-语句中变量的作用域"><a href="#for-语句中变量的作用域" class="headerlink" title="for 语句中变量的作用域"></a>for 语句中变量的作用域</h3><p>任何声明在 initializer 中的变量只在该 for 语句的内部可见，和 C 和 C++ 不同。</p><blockquote><p>循环变量常常使用标识符 i、j、k 。</p></blockquote><h3 id="初始化和迭代表达式中的多表达式"><a href="#初始化和迭代表达式中的多表达式" class="headerlink" title="初始化和迭代表达式中的多表达式"></a>初始化和迭代表达式中的多表达式</h3><p>初始化表达式和迭代表达式都可以包含多个表达式，只需要用逗号隔开，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> MaxI = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, j = <span class="number">10</span>; i &lt; MaxI; i++, j += <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; i &#125;</span>, <span class="subst">&#123; j &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><p>switch 语句实现多路分支：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>( TestExpr )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> Expr1:</span><br><span class="line">        StatementList</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ···</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> ExprN:</span><br><span class="line">        StatementList</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">        StatementList</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①switch 语句有一个被称为<strong>测试表达式</strong>或<strong>匹配表达式</strong>的参数，C# 7.0 后允许测试表达式为任何类型；<br>②switch 语句包含0个或多个<strong>分支块 switch sections</strong> ；<br>③每个分支块都以一个或多个<strong>分支标签 switch labels</strong>开头，switch 标签形式：<code>case PatternExpression:</code> ，case 为关键字，冒号为分支标签结束符。每个分支标签后面跟着一个模式表达式，该模式表达式与测试表达式比较。如果模式表达式和测试表达式都是整数类型，使用 C# 的相对运算符 == 进行比较。在所有其他情况下，则使用静态方法 Object.Equals(test, pattern) 进行比较，即对于非整数类型，C# 使用深度比较。在 C# 7.0 之前，case 后面的表达式必须是常量表达式ConstantExpression，必须在编译时被编译器计算，现在这个约束不适用。<br>④每个分支块遵循“不穿过规则”，即表达语句不能到达终点并且进入下一个分支，一般使用<strong>跳转语句</strong>来结束表达语句列表，包括 break 、return 、continue 、goto 和 throw 。goto 跳转语句不能与非常量 switch 表达式一起使用。<br>⑤分支块会按顺序执行。如果其中一个分支块与测试表达式的值匹配，则执行这个分支块，然后控制流会跳转到该分支块中使用的跳转语句指定的位置。由于 break 语句是最常用的跳转语句，所以通常控制流会跳转到 switch 语句结束后的代码。<br>⑥一个switch 语句可以有任意数目的分支，也可以没有分支。default 分支是可选的，若包括了，也要以一条跳转语句结束。拥有 default 是好习惯，因为它可以捕获潜在错误。</p><h3 id="分支示例"><a href="#分支示例" class="headerlink" title="分支示例"></a>分支示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="built_in">int</span> x=<span class="number">1</span>; x&lt;<span class="number">6</span>; x++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>( x ) <span class="comment">//计算变量x的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//如果x=2</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;x is <span class="subst">&#123; x &#125;</span> -- In Case 2&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//结束switch语句</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">//如果x=5</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;x is <span class="subst">&#123; x &#125;</span> -- In Case 5&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//结束switch语句</span></span><br><span class="line">        </span><br><span class="line">        <span class="literal">default</span>: <span class="comment">//如果x既不等于2也不等于5</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;x is <span class="subst">&#123; x &#125;</span> -- In Default case&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//结束switch语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他类型的模式表达式"><a href="#其他类型的模式表达式" class="headerlink" title="其他类型的模式表达式"></a>其他类型的模式表达式</h3><p><strong>case 标签</strong>由<strong>关键字 case</strong> 和其后面的模式构成，模式可以是简单的值，或者表达式，也可以是一个类型。模式也可以使用<strong>关键字 when</strong> 来包含一个过滤器。</p><p>示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Square</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Side &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Radius &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Triangle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Height &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> shapes = <span class="keyword">new</span> List&lt;Shape&gt;();</span><br><span class="line">        shapes.Add(<span class="keyword">new</span> Circle() &#123; Radius = <span class="number">7</span> &#125;);</span><br><span class="line">        shapes.Add(<span class="keyword">new</span> Square() &#123; Side = <span class="number">5</span> &#125;);</span><br><span class="line">        shapes.Add(<span class="keyword">new</span> Triangle() &#123; Height = <span class="number">4</span> &#125;);</span><br><span class="line">        <span class="keyword">var</span> nullSquare = (Square)<span class="literal">null</span>;</span><br><span class="line">        shapes.Add(nullSquare);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> shape <span class="keyword">in</span> shapes )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>( shape ) <span class="comment">//判断类型或者shape变量的值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> Circle circle: <span class="comment">//等价于 if(shape is Circle)</span></span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;This shape is a circle of radius <span class="subst">&#123; circle.Radius &#125;</span>&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Square square <span class="keyword">when</span> square.Side &gt; <span class="number">10</span>: <span class="comment">//仅仅匹配一部分Square</span></span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;This shape is a large square of side <span class="subst">&#123; square.Side &#125;</span>&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Square square:</span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;This shape is a square of side <span class="subst">&#123; square.Side &#125;</span>&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Triangle triangle: <span class="comment">//等价于 if(shape is Triangle)</span></span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;This shape is a triangle of side <span class="subst">&#123; triangle.Height &#125;</span>&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//case Triangle triangle when triangle.Height &lt; 5: //编译错误</span></span><br><span class="line">                    <span class="comment">//Console.WriteLine($&quot;This shape is a triangle of side &#123; triangle.Height &#125;&quot;);</span></span><br><span class="line">                    <span class="comment">//break;</span></span><br><span class="line">                <span class="keyword">case</span> <span class="literal">null</span>:</span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;This shape could be a Square, Circle or a Triangle&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(</span><br><span class="line">                        message: <span class="string">&quot;shape is not a recognized shape&quot;</span>,</span><br><span class="line">                        paramName: <span class="keyword">nameof</span>(shape));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">This shape is a circle of radius 7</span><br><span class="line">This shape is a square of side 5</span><br><span class="line">This shape is a triangle of side 4</span><br><span class="line">This shape could be a Square, Circle or a Triangle</span><br></pre></td></tr></table></figure><p>上面注释掉的代码会导致编译错误，因为永远到达不了这个case，它是前一个一般 case 的受限的 case 。</p><h3 id="switch-语句的补充"><a href="#switch-语句的补充" class="headerlink" title="switch 语句的补充"></a>switch 语句的补充</h3><p>C# 允许把多个分支标签附加到任意分支，只要这些分支标签之间没有插入可执行语句。示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>( x )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//可接受的</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//如果x等于1、2、3，则执行该代码</span></span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        y = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//因为没有break，所以不可以接受</span></span><br><span class="line">        ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果在同一分支存在多个模式，因为无法确定匹配的是哪个模式，所以不能在构成该块的语句中使用这些变量，可能会导致空引用异常，比如：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> Square s:</span><br><span class="line"><span class="keyword">case</span> Circle c:</span><br><span class="line">    Console.WriteLine($“Square has dimensions: &#123; s.Side &#125; x &#123; s.Side &#125;”);</span><br><span class="line">    Console.WriteLine($“Found a Circle of radius &#123; c.Radius &#125;”);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>还有就是虽然结束分支块的最常用方法是使用5个跳转语句中的一个，但是也可以不用，当某个结构可以使语句列表满足“不穿过规则”时，即不直接进入下一个分支块，编译器是可以检测到的。</p><h2 id="跳转语句-Jump-Statements"><a href="#跳转语句-Jump-Statements" class="headerlink" title="跳转语句 Jump Statements"></a>跳转语句 Jump Statements</h2><p>当控制流到达<strong>跳转语句</strong>时，程序执行被无条件地转移至程序的另一部分，包括：<code>break</code> , <code>continue</code> , <code>return</code> , <code>goto</code> , <code>throw</code> 。throw 语句详见第23章。</p><h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><p><strong>break 语句</strong>可以被用在 switch 、for 、foreach 、while 、do 语句中。在这些语句体中，break 会导致执行跳出<strong>最内层封装语句 the innermost enclosing loop</strong> 。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( <span class="literal">true</span> )</span><br><span class="line">&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">if</span>( x &gt;= <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h2><p><strong>continue 语句</strong>可以被用在 for 、foreach 、while 、do 语句中。在这些语句体中，continue 会导致执行转到<strong>最内层封装语句 the innermost enclosing loop</strong> 的顶端。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="built_in">int</span> x=<span class="number">0</span>; x&lt;<span class="number">5</span>; x++ ) <span class="comment">//执行循环5次</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( x &lt; <span class="number">3</span> ) <span class="comment">//先执行3次</span></span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">//直接回到循环开始处</span></span><br><span class="line">    <span class="comment">//当x&gt;=3时执行下面语句</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Value of x is <span class="subst">&#123; x &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标签语句-Labeled-Statements"><a href="#标签语句-Labeled-Statements" class="headerlink" title="标签语句 Labeled Statements"></a>标签语句 Labeled Statements</h2><p><strong>标签语句</strong>由一个标识符后面跟着一个冒号和语句组成：<code>Identifier: Statement</code> 。</p><p>标签语句的执行如同标签不存在一样，仅执行 Statement 部分：<br>①给语句增加一个标签允许控制从代码的其他部分转移到该语句；<br>②标签语句只允许用在块内部。</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>标签有自己的命名空间，标签语句的标识符可以是任何有效的标识符，包括局部变量或参数名。但标识符不能是关键字，也不能在重叠范围内和另一个标签标识符相同。</p><p>下面代码展示了标签的有效使用，该标签和一个局部变量有相同的标识符：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> xyz = <span class="number">0</span>; <span class="comment">//变量xyz</span></span><br><span class="line">        ...</span><br><span class="line">    xyz: Console.WriteLine(<span class="string">&quot;No problem.&quot;</span>); <span class="comment">//标签xyz</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标签语句的作用域"><a href="#标签语句的作用域" class="headerlink" title="标签语句的作用域"></a>标签语句的作用域</h3><p>标签语句的作用域为：它声明所在的块；任何嵌套在该块内部的块。标签语句在其声明所在块的外部不可见或不可访问。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123; <span class="comment">//作用域A</span></span><br><span class="line">    &#123; <span class="comment">//作用域B</span></span><br><span class="line">        increment: x++;</span><br><span class="line">        &#123; <span class="comment">//作用域C</span></span><br><span class="line"></span><br><span class="line">            &#123; <span class="comment">//作用域D</span></span><br><span class="line">                ···</span><br><span class="line">            &#125;</span><br><span class="line">            &#123; <span class="comment">//作用域E</span></span><br><span class="line">                ···</span><br><span class="line">            &#125;</span><br><span class="line">            ···</span><br><span class="line">        &#125;</span><br><span class="line">        end: Console.WriteLine(<span class="string">&quot;Exiting&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①2个标签语句的有效代码区域为作用域B及以内；<br>②作用域B和所有嵌套块中的代码都能看到并访问标签语句；<br>③从作用域内部的任何位置，代码都能跳出到标签语句；<br>④作用域A的代码不能跳入到标签语句的块中。</p><h2 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h2><p><strong>goto 语句</strong>无条件地将控制转移到一个<strong>标签语句</strong>，一般形式：<code>goto Identifier ;</code> ，其中 Identifier 是标签语句的标识符。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> thingsAreFine;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    thingsAreFine = GetNuclearReactorCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( thingsAreFine )</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Things are fine.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> NotSoGood;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NotSoGood: Console.WriteLine(<span class="string">&quot;We have a problem.&quot;</span>);</span><br></pre></td></tr></table></figure><p>goto 语句必须在标签语句的作用域之内：<br>①goto 语句可以跳到它所在块内的任何标签语句，或跳出到任何嵌套它的块内的标签语句；<br>②goto 语句不能跳入嵌套在其所在块内部的任何块。</p><blockquote><p>尽量不使用 goto 语句，它会导致弱结构化、难以调试和维护的代码。</p></blockquote><h3 id="switch-语句内部的-goto-语句"><a href="#switch-语句内部的-goto-语句" class="headerlink" title="switch 语句内部的 goto 语句"></a>switch 语句内部的 goto 语句</h3><p>goto 语句也可以把控制转到 switch 语句内部的分支标签，但是 goto 标签只能引用编译时常量，如同 C# 7.0 之前的 switch 语句一样。形式如下：</p><p><code>goto case ConstantExpression;</code><br><code>goto default;</code><br><code>goto case PatternExpression; //编译错误</code></p><h2 id="using-语句"><a href="#using-语句" class="headerlink" title="using 语句"></a>using 语句</h2><p>某些类型的非托管对象有数量限制或很耗费系统资源，在代码适用完它们后，尽快释放它们很重要。<strong>using 语句</strong>有助于简化该过程并确保这些资源被适当地处置。</p><p><strong>资源</strong>是指实现了 System.IDisposable 接口的类或结构，接口详见第16章，简单来说，接口就是未实现的函数成员的集合，类和结构可以选择去实现它们。IDisposable 接口含有单独一个名称为 Dispose 的方法。</p><p>使用资源的阶段如下图，包括分配资源；使用资源；处置资源：</p><div  align="center">  <img src="https://s2.loli.net/2023/01/07/Vb2FD1TpHiBUE9G.png" width = "55%" height = "55%" alt="图48 - 使用资源的阶段"/></div><blockquote><p>区分 using 语句和 using 指令（比如使用 System.Math;），using 指令见第22章。</p></blockquote><h3 id="包装资源的使用"><a href="#包装资源的使用" class="headerlink" title="包装资源的使用"></a>包装资源的使用</h3><p>using 语句帮助减少意外的运行时错误（即异常，见第23章）带来的潜在问题，整洁地包装了资源的使用。有两种形式的 using 语句。</p><p>第一种形式：<code>using ( ResourceType Identifier = Expression ) Statement</code><br>①圆括号内的代码分配资源；<br>②Statement 是使用资源的代码；<br>③using 语句隐式地产生处置资源的代码。</p><p>处理可能的异常的标准方法是把可能导致异常的代码放入一个 try 块里，并把任何无论有没有异常都执行的代码放进一个 finally 块中。这种形式的 using 语句就是这么做的，先分配资源，再把 Statement 放进 try 块，最后创建资源的 Dispose 方法的调用，并放进 finally 块，见下图：</p><div  align="center">  <img src="https://s2.loli.net/2023/01/07/DXOR5fV387KYo2W.png" width = "70%" height = "70%" alt="图49 - using语句的效果"/></div><h3 id="using-语句的示例"><a href="#using-语句的示例" class="headerlink" title="using 语句的示例"></a>using 语句的示例</h3><p>TextWriter 和 TextReader 的类，来自 System.IO 命名空间，都实现了 IDisposable 接口，这是 using 语句的要求：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System; <span class="comment">//using指令，不是using语句</span></span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UsingStatement</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (TextWriter tw = File.CreateText(<span class="string">&quot;Lincoln.txt&quot;</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">            tw.WriteLine(<span class="string">&quot;Four score and seven years ago, ...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (TextReader tr = File.OpenText(<span class="string">&quot;Lincoln.txt&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> InputString;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">null</span> != (InputString = tr.ReadLine()))</span><br><span class="line">                Console.WriteLine(InputString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Four score and seven years ago, ...</span><br></pre></td></tr></table></figure><h3 id="多个资源和嵌套"><a href="#多个资源和嵌套" class="headerlink" title="多个资源和嵌套"></a>多个资源和嵌套</h3><p>using 语句可以使用相同类型的多个资源，资源声明用逗号隔开：<code>using ( ResourceType Id1 = Expr1, Id2 = Expr2, ... ) EmbeddedStatement</code></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (TextWriter tw1 = File.CreateText(<span class="string">&quot;Lincoln.txt&quot;</span>),</span><br><span class="line">                      tw2 = File.CreateText(<span class="string">&quot;Franklin.txt&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        tw1.WriteLine(<span class="string">&quot;Four score and seven years ago, ...&quot;</span>);</span><br><span class="line">        tw2.WriteLine(<span class="string">&quot;Early to bed; Early to rise ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (TextReader tr1 = File.OpenText(<span class="string">&quot;Lincoln.txt&quot;</span>),</span><br><span class="line">                      tr2 = File.OpenText(<span class="string">&quot;Franklin.txt&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> InputString;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">null</span> != (InputString = tr1.ReadLine()))</span><br><span class="line">            Console.WriteLine(InputString);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">null</span> != (InputString = tr2.ReadLine()))</span><br><span class="line">            Console.WriteLine(InputString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>using 语句还可以嵌套：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ( TextWriter tw1 = File.CreateText(<span class="string">&quot;Lincoln.txt&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    tw1.WriteLine(<span class="string">&quot;Four score and seven years ago, ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ( TextWriter tw2 = File.CreateText(<span class="string">&quot;Franklin.txt&quot;</span>) ) <span class="comment">//嵌套语句</span></span><br><span class="line">        tw2.WriteLine(<span class="string">&quot;Early to bed; Early to rise ...&quot;</span>); <span class="comment">//简单语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="using-语句的另外一种形式"><a href="#using-语句的另外一种形式" class="headerlink" title="using 语句的另外一种形式"></a>using 语句的另外一种形式</h3><p>语法：<code>using ( Expression ) EmbeddedStatement</code>，在这种形式中，资源在 using 语句之前声明。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">TextWriter tw = File.CreateText(<span class="string">&quot;Lincoln.txt&quot;</span>); <span class="comment">//声明资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ( tw )</span><br><span class="line">    tw.WriteLine(<span class="string">&quot;Four score and seven years ago, ...&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种形式不推荐，见下图：</p><div  align="center">  <img src="https://s2.loli.net/2023/01/07/xXTcoYRzK7fOi9d.png" width = "70%" height = "70%" alt="图50 - 资源声明在using语句之前"/></div><h2 id="其他语句"><a href="#其他语句" class="headerlink" title="其他语句"></a>其他语句</h2><div class="table-container"><table><thead><tr><th style="text-align:left">语句</th><th style="text-align:left">描述</th><th style="text-align:left">相关章节</th></tr></thead><tbody><tr><td style="text-align:left">checked, unchecked</td><td style="text-align:left">控制溢出检查上下文</td><td style="text-align:left">第17章</td></tr><tr><td style="text-align:left">foreach</td><td style="text-align:left">遍历一个集合的每个成员</td><td style="text-align:left">第13和19章</td></tr><tr><td style="text-align:left">try, throw, finally</td><td style="text-align:left">处理异常</td><td style="text-align:left">第23章</td></tr><tr><td style="text-align:left">return</td><td style="text-align:left">将控制返回到调用函数的成员，而且还能返回一个值</td><td style="text-align:left">第6章</td></tr><tr><td style="text-align:left">yield</td><td style="text-align:left">用于迭代</td><td style="text-align:left">第19章</td></tr></tbody></table></div><h1 id="第十一章-结构"><a href="#第十一章-结构" class="headerlink" title="第十一章 结构"></a>第十一章 结构</h1><h2 id="什么是结构"><a href="#什么是结构" class="headerlink" title="什么是结构"></a>什么是结构</h2><p><strong>结构 struct</strong> 是用户定义的数据类型，跟类类似，也有数据成员和函数成员，与类的最重要区别包括：<br>①类是引用类型，而结构是值类型；<br>②结构是隐式密封的，即不能从它们派生其他结构。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Point first, second, third;</span><br><span class="line"></span><br><span class="line">        first.X = <span class="number">10</span>; first.Y = <span class="number">10</span>;</span><br><span class="line">        second.X = <span class="number">20</span>; second.Y = <span class="number">20</span>;</span><br><span class="line">        third.X = first.X + second.X;</span><br><span class="line">        third.Y = first.Y + second.Y;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;first: <span class="subst">&#123; first.X &#125;</span>, <span class="subst">&#123; first.Y &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;second: <span class="subst">&#123; second.X &#125;</span>, <span class="subst">&#123; second.Y &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;third: <span class="subst">&#123; third.X &#125;</span>, <span class="subst">&#123; third.Y &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构是值类型"><a href="#结构是值类型" class="headerlink" title="结构是值类型"></a>结构是值类型</h2><p>因为结构是值类型，因此：<br>①结构类型的变量不能为 null ；<br>②两个结构变量不能引用同一对象。</p><p>以下示例和图展示了类变量和结构变量的内存安排：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CSimple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Simple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CSimple cs = <span class="keyword">new</span> CSimple();</span><br><span class="line">        Simple ss = <span class="keyword">new</span> Simple();</span><br><span class="line">            ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/01/09/aVAIuwlSvWsLTYi.png" width = "50%" height = "50%" alt="图51 - 类与结构的内存安排"/></div><h2 id="对结构赋值"><a href="#对结构赋值" class="headerlink" title="对结构赋值"></a>对结构赋值</h2><p>把一个结构赋值给另一个结构，就是将一个结构的值复制给另一个结构。这和复制类变量不同，复制类变量时只复制引用。示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CSimple</span></span><br><span class="line">&#123; <span class="keyword">public</span> <span class="built_in">int</span> X; <span class="keyword">public</span> <span class="built_in">int</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Simple</span><br><span class="line">&#123; <span class="keyword">public</span> <span class="built_in">int</span> X; <span class="keyword">public</span> <span class="built_in">int</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CSimple cs1 = <span class="keyword">new</span> CSimple(), cs2 = <span class="literal">null</span>; <span class="comment">//类实例</span></span><br><span class="line">        Simple ss1 = <span class="keyword">new</span> Simple(), ss2 = <span class="keyword">new</span> Simple(); <span class="comment">//结构实例</span></span><br><span class="line"></span><br><span class="line">        cs1.X = ss1.X = <span class="number">5</span>; <span class="comment">//将5赋值ss1.X和cs1.X</span></span><br><span class="line">        cs1.Y = ss1.Y = <span class="number">10</span>; <span class="comment">//将10赋值ss1.Y和cs1.Y</span></span><br><span class="line"></span><br><span class="line">        cs2 = cs1; <span class="comment">//赋值类实例</span></span><br><span class="line">        ss2 = ss1; <span class="comment">//赋值结构实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/01/09/ybqUXVh7xHSclgw.png" width = "70%" height = "70%" alt="图52 - 类变量和结构变量赋值"/></div><h2 id="构造函数和析构函数-Constructors-and-Destructors"><a href="#构造函数和析构函数-Constructors-and-Destructors" class="headerlink" title="构造函数和析构函数 Constructors and Destructors"></a>构造函数和析构函数 Constructors and Destructors</h2><p>结构可以有实例构造函数和静态构造函数，但不允许有析构函数。</p><h3 id="实例构造函数-Instance-Constructors"><a href="#实例构造函数-Instance-Constructors" class="headerlink" title="实例构造函数 Instance Constructors"></a>实例构造函数 Instance Constructors</h3><p>语言隐式地为每个结构提供一个无参数的结构函数，这个构造函数把结构的每个成员设置为该类型的默认值，即值成员设置为它们的默认值，引用成员设置为 null 。</p><p>对于每个结构，都存在预定义的无参数构造函数，可以创建另外的构造函数，只要有参数。这和类不同，对于类，编译器只在没有声明其他构造函数时提供隐式的无参数构造函数。</p><p>调用构造函数，包括隐式无参数构造函数，要使用 new 运算符，即使不从堆中分配内存。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Simple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Simple</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>) <span class="comment">//带有参数的构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        X = a;</span><br><span class="line">        Y = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Simple s1 = <span class="keyword">new</span> Simple(); <span class="comment">//调用隐式构造函数</span></span><br><span class="line">        Simple s2 = <span class="keyword">new</span> Simple(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">//调用构造函数</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; s1.X &#125;</span>,<span class="subst">&#123; s1.Y &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; s2.X &#125;</span>,<span class="subst">&#123; s2.Y &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">0,0</span><br><span class="line">5,10</span><br></pre></td></tr></table></figure><p>也可以不使用 new 运算符创建结构的实例，但是：<br>①在显示地设置数据成员后，才能使用它们的值；<br>②在对所有数据成员赋值之后，才能调用结构的函数成员。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Simple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Simple s1, s2; <span class="comment">//没有调用构造函数</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>, s1.X, s1.Y); <span class="comment">//因为没有赋值，所以编译错误</span></span><br><span class="line"></span><br><span class="line">        s2.X = <span class="number">5</span>;</span><br><span class="line">        s2.Y = <span class="number">10</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; s2.X &#125;</span>,<span class="subst">&#123; s2.Y &#125;</span>&quot;</span>); <span class="comment">//没问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态构造函数-Static-Constructors"><a href="#静态构造函数-Static-Constructors" class="headerlink" title="静态构造函数 Static Constructors"></a>静态构造函数 Static Constructors</h3><p>与类相似，结构的静态构造函数创建并初始化静态数据成员，而且不能引用实例成员。结构的静态构造函数与类类似，但允许有不带参数的静态构造函数。</p><p>以下行为，任意一种发生前，会调用静态构造函数：<br>①调用显式声明的构造函数；<br>②引用结构的静态成员。</p><h3 id="构造函数和析构函数小结"><a href="#构造函数和析构函数小结" class="headerlink" title="构造函数和析构函数小结"></a>构造函数和析构函数小结</h3><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">实例构造函数（无参数）</td><td style="text-align:left">不能在程序中声明。系统为所有结构提供一个隐式的构造函数，不能被程序删除或重定义</td></tr><tr><td style="text-align:left">实例构造函数（有参数）</td><td style="text-align:left">可以在程序中声明</td></tr><tr><td style="text-align:left">静态构造函数</td><td style="text-align:left">可以在程序中声明</td></tr><tr><td style="text-align:left">析构函数</td><td style="text-align:left">不能在程序中声明。不允许声明析构函数</td></tr></tbody></table></div><h2 id="属性和字段初始化语句"><a href="#属性和字段初始化语句" class="headerlink" title="属性和字段初始化语句"></a>属性和字段初始化语句</h2><p>在声明结构体时，不允许使用实例属性和字段初始化语句。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Simple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x = <span class="number">0</span>; <span class="comment">//不允许，编译错误</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> y = <span class="number">10</span>; <span class="comment">//不允许，编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> prop1 &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125; = <span class="number">5</span>; <span class="comment">//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是结构体的静态属性和静态字段都可以在声明结构体时进行初始化，即使结构体本身不是静态的。</p><h2 id="结构是密封的"><a href="#结构是密封的" class="headerlink" title="结构是密封的"></a>结构是密封的</h2><p>结构总是隐式密封的，不能从它们派生其他结构。</p><p>不能用于结构的修饰符：protected 、protected internal 、abstract 、virtual 、sealed 。</p><p>结构本身派生自 System.ValueType ，而 System.ValueType 派生自 object 。</p><h2 id="装箱和拆箱-Boxing-and-Unboxing"><a href="#装箱和拆箱-Boxing-and-Unboxing" class="headerlink" title="装箱和拆箱 Boxing and Unboxing"></a>装箱和拆箱 Boxing and Unboxing</h2><p>装箱和拆箱详见第17章。因为结构实例是值类型数据，要作为引用类型对象，必须创建装箱的副本。装箱的过程就是制作值类型变量的引用类型副本。</p><h2 id="结构作为返回值和参数"><a href="#结构作为返回值和参数" class="headerlink" title="结构作为返回值和参数"></a>结构作为返回值和参数</h2><p>①当结构作为返回值，将创建它的副本并从函数成员返回；<br>②当结构被用作值参数，将创建实参结构的副本，用于方法的执行中；<br>③如果把一个结构用作 ref 和 out 参数，传入方法的是该结构的一个引用，这样就可以修改其数据成员。</p><h2 id="关于结构的更多内容"><a href="#关于结构的更多内容" class="headerlink" title="关于结构的更多内容"></a>关于结构的更多内容</h2><p>对结构进行分配的开销比创建类实例小，但要注意装箱和拆箱的高昂代价。</p><p>其他事项：<br>①预定义类型（比如 int 、short 、long 等等），尽管是原始类型，但实际上在 .NET 都实现为结构；<br>②可以使用与声明分部类相同的方法声明分结构，见第7章；<br>③结构和类一样，都能实现接口，见第16章。</p><h1 id="第十二章-枚举"><a href="#第十二章-枚举" class="headerlink" title="第十二章 枚举"></a>第十二章 枚举</h1><h2 id="枚举-Enumerations"><a href="#枚举-Enumerations" class="headerlink" title="枚举 Enumerations"></a>枚举 Enumerations</h2><p><strong>枚举 enumeration</strong> 也是用户定义的类型。枚举是值类型，只有一种类型的成员：命名的整数值常量。</p><p>示例如下，注意成员声明列表是逗号分隔的，在枚举声明中没有分号：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> TrafficLight</span><br><span class="line">&#123;</span><br><span class="line">    Green,</span><br><span class="line">    Yellow,</span><br><span class="line">    Red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个枚举类型都有一个底层整数类型，默认为 int ：每个枚举成员都被赋予一个底层类型的常量值，默认情况下，第一个成员赋值为0，第二个为1，以此类推。</p><p>即在上面示例的 TrafficLight 类型中，编译器把 int 值0、1、2分别赋值给了 Green 、Yellow 和 Red 。<em>在代码输出中，需要把他们转换为类型 int ，才能看到底层的成员值，否则成员名被当作字符串打印。</em></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">TrafficLight t1 = TrafficLight.Green;</span><br><span class="line">TrafficLight t2 = TrafficLight.Yellow;</span><br><span class="line">TrafficLight t3 = TrafficLight.Red;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; t1 &#125;</span>,\t<span class="subst">&#123;(<span class="built_in">int</span>) t1 &#125;</span>&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; t2 &#125;</span>,\t<span class="subst">&#123;(<span class="built_in">int</span>) t2 &#125;</span>&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; t3 &#125;</span>,\t<span class="subst">&#123;(<span class="built_in">int</span>) t3 &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Green,  0</span><br><span class="line">Yellow, 1</span><br><span class="line">Red,    2</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/01/10/7ydJ1cPGXUWwR9H.png" width = "65%" height = "65%" alt="图53 - 枚举的成员常量表示为底层整数值"/></div><h3 id="设置底层类型和显式值"><a href="#设置底层类型和显式值" class="headerlink" title="设置底层类型和显式值"></a>设置底层类型和显式值</h3><p>可以把冒号和类型名放在枚举名之后，把枚举设置为任何整数类型，所有枚举成员常量都为该类型：<code>enum TrafficLight : ulong</code></p><p>可以显式地设置一个成员常量的值，即在枚举声明中的变量名之后使用初始化表达式。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> TrafficLight : <span class="built_in">long</span></span><br><span class="line">&#123;</span><br><span class="line">    Green = <span class="number">10L</span>,</span><br><span class="line">    Yellow = <span class="number">15L</span>,</span><br><span class="line">    Red = <span class="number">15L</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐式成员编号"><a href="#隐式成员编号" class="headerlink" title="隐式成员编号"></a>隐式成员编号</h3><p>如果不初始化成员常量，编译器会隐式地给它赋值，并且比前一个成员常量大1：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> CardSuit &#123;</span><br><span class="line">    Hearts, <span class="comment">//0</span></span><br><span class="line">    Clubs, <span class="comment">//1</span></span><br><span class="line">    Diamonds, <span class="comment">//2</span></span><br><span class="line">    Spades, <span class="comment">//3</span></span><br><span class="line">    MaxSuits <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> FaceCards &#123;</span><br><span class="line">    Jack = <span class="number">11</span>, <span class="comment">//11，显式设置</span></span><br><span class="line">    Queen, <span class="comment">//12，比之前大1</span></span><br><span class="line">    King, <span class="comment">//13</span></span><br><span class="line">    Ace, <span class="comment">//14</span></span><br><span class="line">    NumberOfFaceCards = <span class="number">4</span>, <span class="comment">//4，显式设置</span></span><br><span class="line">    SomeOtherValue, <span class="comment">//5</span></span><br><span class="line">    HighestFaceCard = Ace <span class="comment">//14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位标志-Bit-Flags"><a href="#位标志-Bit-Flags" class="headerlink" title="位标志 Bit Flags"></a>位标志 Bit Flags</h2><p>程序员长期使用单个字的不同位作为表示一组开关标志的方法，即<strong>标志字 flag word</strong> 。枚举可以实现它，一般步骤如下：<br>①确定需要多少个位标志，选择一种足够多位的无符号类型来保存它；<br>②确定每个位位置代表什么，并给它们名称。声明一个选中的整数类型的枚举，每个成员由一个位位置表示；<br>③使用按位或 OR 运算符在持有该位标志的字中设置适当的位；<br>④使用按位与 AND 运算符或 HasFlag 方法检查是否设置了特定位标志。</p><p>步骤2示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="built_in">enum</span> CardDeckSettings : <span class="built_in">uint</span></span><br><span class="line">&#123;</span><br><span class="line">    SingleDeck = <span class="number">0x01</span>, <span class="comment">//位0</span></span><br><span class="line">    LargePictures = <span class="number">0x02</span>, <span class="comment">//位1</span></span><br><span class="line">    FancyNumbers = <span class="number">0x04</span>, <span class="comment">//位2</span></span><br><span class="line">    Animation = <span class="number">0x08</span> <span class="comment">//位3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Flags 特性 attribute 装饰枚举不是必需的，但是可以带来额外的便利，详见第25章。</p><div  align="center">  <img src="https://s2.loli.net/2023/01/10/mrRg62fGHvcVzux.png" width = "70%" height = "70%" alt="图54 - 标志位的定义（左）和它们各自代表的值（右）"/></div><p>步骤3：要创建一个带有适当的位标志的字，需要声明一个该枚举类型的变量，并使用按位或运算符设置需要的位，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">CardDeckSettings ops = CardDeckSettings.SingleDeck</span><br><span class="line">                    | CardDeckSettings.FancyNumbers</span><br><span class="line">                    | CardDeckSettings.Animation ;</span><br></pre></td></tr></table></figure><p>步骤4：要判断标志字是否包含特定的位标志集，可以使用枚举类型的 HasFlag 布尔方法。在标志字上调用 HasFlag 方法，并将要检查的位标志作为参数，如果设置了指定的位标志，HasFlag 返回 true，否则返回 false 。如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> useFancyNumbers = ops.HasFlag(CardDeckSettings.FancyNumbers);</span><br></pre></td></tr></table></figure><p>HasFlag 方法还可以检测多个位标志，可以创建一个测试字，并用 HasFlag 检测是否测试字中的所有标志都在 ops 标志字中进行了设置。如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">CardDeckSettings testFlags = CardDeckSettings.Animation | CardDeckSettings.FancyNumbers; </span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> useAnimationAndFancyNumbers = ops.HasFlag( testFlags );</span><br></pre></td></tr></table></figure><p>另一种判断是否设置了一个或多个指定位的方法是使用按位与运算符：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> useFancyNumbers = (ops &amp; CardDeckSettings.FancyNumbers) == CardDeckSettings.FancyNumbers;</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/01/11/BSh8D37ApQc5Lyr.png" width = "50%" height = "50%" alt="图55 - 生成一个标志字并检查一个特定的位标志"/></div><h3 id="Flags-特性"><a href="#Flags-特性" class="headerlink" title="Flags 特性"></a>Flags 特性</h3><p>Flags 特性通知编译器，该枚举的成员不仅可以用作单独的值，还可以组合成位标志。其次，它允许枚举的 ToString 方法为位标志的值提供更多的格式化信息。ToString 方法以一个枚举值为参数，将其与枚举的常量成员相比较，若匹配，ToString 返回该成员的字符串名称。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> CardDeckSettings : <span class="built_in">uint</span></span><br><span class="line">&#123;</span><br><span class="line">    SingleDeck = <span class="number">0x01</span>, <span class="comment">//位0</span></span><br><span class="line">    LargePictures = <span class="number">0x02</span>, <span class="comment">//位1</span></span><br><span class="line">    FancyNumbers = <span class="number">0x04</span>, <span class="comment">//位2</span></span><br><span class="line">    Animation = <span class="number">0x08</span> <span class="comment">//位3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">        CardDeckSettings ops;</span><br><span class="line">        ops = CardDeckSettings.FancyNumbers; <span class="comment">//设置一个标志</span></span><br><span class="line">        Console.WriteLine( ops.ToString() );</span><br><span class="line">                                             <span class="comment">//设置两个标志</span></span><br><span class="line">        ops = CardDeckSettings.FancyNumbers | CardDeckSettings.Animation;</span><br><span class="line">        Console.WriteLine( ops.ToString() ); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">FancyNumbers</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>该枚举没有 Flags 特性，第二次赋值的结果是12，是因为 ToString 方法会查找哪个枚举成员具有12，由于没找到，返回了12。然而，如果在枚举声明前加上 Flags 特性，ToString 方法就可以发现12对应两个分开的位标志成员，即 FancyNumbers 和 Animation 。运行包含 Flags 特性的代码，结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">FancyNumbers</span><br><span class="line">FancyNumbers, Animation</span><br></pre></td></tr></table></figure><h3 id="使用位标志的示例"><a href="#使用位标志的示例" class="headerlink" title="使用位标志的示例"></a>使用位标志的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="built_in">enum</span> CardDeckSettings : <span class="built_in">uint</span></span><br><span class="line">&#123;</span><br><span class="line">    SingleDeck = <span class="number">0x01</span>, <span class="comment">//位0</span></span><br><span class="line">    LargePictures = <span class="number">0x02</span>, <span class="comment">//位1</span></span><br><span class="line">    FancyNumbers = <span class="number">0x04</span>, <span class="comment">//位2</span></span><br><span class="line">    Animation = <span class="number">0x08</span> <span class="comment">//位3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> UseSingleDeck = <span class="literal">false</span>,</span><br><span class="line">         UseBigPics = <span class="literal">false</span>,</span><br><span class="line">         UseFancyNumbers = <span class="literal">false</span>,</span><br><span class="line">         UseAnimation = <span class="literal">false</span>,</span><br><span class="line">         UseAnimationAndFancyNumbers = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetOptions</span>(<span class="params"> CardDeckSettings ops </span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        UseSingleDeck = ops.HasFlag( CardDeckSettings.SingleDeck );</span><br><span class="line">        UseBigPics = ops.HasFlag( CardDeckSettings.LargePictures );</span><br><span class="line">        UseFancyNumbers = ops.HasFlag( CardDeckSettings.FancyNumbers );</span><br><span class="line">        UseAnimation = ops.HasFlag( CardDeckSettings.Animation );</span><br><span class="line"></span><br><span class="line">        CardDeckSettings testFlags =</span><br><span class="line">                        CardDeckSettings.Animation | CardDeckSettings.FancyNumbers;</span><br><span class="line">        UseAnimationAndFancyNumbers = ops.HasFlag( testFlags );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintOptions</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine( <span class="string">&quot;Option settings:&quot;</span> );</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot; Use Single Deck - <span class="subst">&#123; UseSingleDeck &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot; Use Large Pictures - <span class="subst">&#123; UseBigPics &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot; Use Fancy Numbers - <span class="subst">&#123; UseFancyNumbers &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot; Show Animation - <span class="subst">&#123; UseAnimation &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine( <span class="string">&quot; Show Animation and FancyNumbers – &#123;0&#125;&quot;</span>,</span><br><span class="line">                    UseAnimationAndFancyNumbers );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass( );</span><br><span class="line">        CardDeckSettings ops = CardDeckSettings.SingleDeck</span><br><span class="line">                            | CardDeckSettings.FancyNumbers</span><br><span class="line">                            | CardDeckSettings.Animation;</span><br><span class="line">        mc.SetOptions( ops );</span><br><span class="line">        mc.PrintOptions( );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Option settings:</span><br><span class="line"> Use Single Deck - True</span><br><span class="line"> Use Large Pictures - False</span><br><span class="line"> Use Fancy Numbers - True</span><br><span class="line"> Show Animation - True</span><br><span class="line"> Show Animation and FancyNumbers – True</span><br></pre></td></tr></table></figure><h2 id="关于枚举的更多内容"><a href="#关于枚举的更多内容" class="headerlink" title="关于枚举的更多内容"></a>关于枚举的更多内容</h2><p>枚举只有单一的成员类型：声明的成员常量<br>①不能对成员使用修饰符，它们都隐式地具有和枚举相同的可访问性；<br>②由于成员是静态的，即使没有枚举变量也可以访问它们；<br>③比较不同枚举类型的成员会导致编译时错误，即使两个枚举具有完全相同的结构和成员名。同一枚举不同成员可以比较；  </p><p>.NET Enum 类型（enum 就是基于该类型的）还包含一些有用的静态方法：<br>①GetName 方法以一个枚举类型对象和一个整数为参数，返回相应的枚举成员名称；<br>②GetNames 方法以一个枚举类型对象为参数，返回该枚举中所有成员的名称。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> TrafficLight</span><br><span class="line">&#123;</span><br><span class="line">    Green,</span><br><span class="line">    Yellow,</span><br><span class="line">    Red</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( <span class="string">&quot;Second member of TrafficLight is &#123;0&#125;\n&quot;</span>,</span><br><span class="line">                            Enum.GetName( <span class="keyword">typeof</span>( TrafficLight ), <span class="number">1</span> ) );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span> ( <span class="keyword">var</span> name <span class="keyword">in</span> Enum.GetNames( <span class="keyword">typeof</span>( TrafficLight ) ) )</span><br><span class="line">            Console.WriteLine( name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Second member of TrafficLight is Yellow</span><br><span class="line"></span><br><span class="line">Green</span><br><span class="line">Yellow</span><br><span class="line">Red</span><br></pre></td></tr></table></figure><h1 id="第十三章-数组"><a href="#第十三章-数组" class="headerlink" title="第十三章 数组"></a>第十三章 数组</h1><h2 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组 Arrays"></a>数组 Arrays</h2><p>数组是由一个变量名称表示的一组同类型的数据元素。每个元素通过变量名称和方括号中的一个或多个索引来访问：<code>MyArray[4]</code> 。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>①<strong>元素 Elements</strong>：数组的独立数据项称为元素，所有元素必须是相同类型或者继承自相同的类型；<br>②<strong>秩/维度 Rank/dimensions</strong>：数组的维度数可以为任何正数，数组的维度数称作秩；<br>③<strong>维度长度 Dimension length</strong>：数组的每一个维度有长度，就是这个方向的位置个数；<br>④<strong>数组长度 Array length</strong>：数组的所有维度中的元素总数称为数组的长度。</p><h3 id="重要细节"><a href="#重要细节" class="headerlink" title="重要细节"></a>重要细节</h3><p>①数组一旦被创建，大小就固定了，C# 不支持动态数组；<br>②数组索引号是从0开始。</p><p>一维数组：<code>int[5]</code>，秩=1，数组长度=5；二维数组：<code>int[3,6]</code>，秩=2，数组长度=18。</p><div  align="center">  <img src="https://s2.loli.net/2023/01/11/6QH7RTnq19eDaIp.png" width = "60%" height = "60%" alt="图56 - 维度和大小"/></div><h2 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h2><p>①<strong>一维数组</strong>可以认为是单行元素或元素向量；<br>②<strong>多维数组</strong>是由主向量中的位置组成的，每个位置本身又是一个数组，称为子数组 subarray 。子数组向量中的位置本身又是一个子数组。</p><p>有两种类型的多维数组：<strong>矩形数组 rectangular array</strong> 和<strong>交错数组 jagged array</strong> ：<br>①矩阵数组的某个维度的所有子数组具有相同长度，只有一组方括号：<code>myArray2[4, 6, 1]</code> ；<br>②交错数组的每一个子数组都是独立数组，子数组可以不同长度，每个维度都使用一组方括号：<code>jagArray1[2][7][4]</code> 。</p><h2 id="数组是对象"><a href="#数组是对象" class="headerlink" title="数组是对象"></a>数组是对象</h2><p>数据实例是从 System.Array 继承类型的对象。数组从 BCL 基类派生而来，它们也继承了 BCL 基类很多的成员，比如 Rank 返回数组维度数，Length 返回数组长度，如下图：</p><div  align="center">  <img src="https://s2.loli.net/2023/01/12/ALG15WS2PdqjZTu.png" width = "70%" height = "70%" alt="图57 - 数组的结构"/></div><p>数组是引用类型，引用在栈或堆上，而数组对象本身总是在堆上。尽管数组是引用类型，数组的元素可以是值类型或者引用类型。若存储的元素是值类型，数组被称作<strong>值类型数组 value type array</strong> ；若存储的元素是引用类型，数组被称作<strong>引用类型数组 reference type array</strong> 。</p><h2 id="一维数组和矩形数组"><a href="#一维数组和矩形数组" class="headerlink" title="一维数组和矩形数组"></a>一维数组和矩形数组</h2><p>要声明一维数组和矩形数组，要在类型和变量名之间使用一组方括号。</p><p>方括号内的<strong>逗号</strong>就是<strong>秩说明符 rank specifiers</strong>，指明了数组的维度数，没有逗号代表一维数组，一个逗号代表二维数组。</p><p>基类型和秩说明符构成了数组类型：<br>①可以使用多个秩说明符；<br>②不能在数组类型区域中放数组维度长度。秩是数组类型的一部分，而维度长度不是；<br>③数组声明后，维度数就是固定的，维度长度要等实例化时才确定。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[,,] firstArray; <span class="comment">//数组类型：三维整数数组  </span></span><br><span class="line"><span class="built_in">int</span>[,] arr1; <span class="comment">//数组类型：二维整数数组</span></span><br><span class="line"><span class="built_in">long</span>[,,] arr3; <span class="comment">//数组类型：三维long数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">long</span>[<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>] SecondArray; <span class="comment">//不允许添加维度长度，编译错误</span></span><br></pre></td></tr></table></figure><blockquote><p>与 C 和 C++ 不同，方括号在基类型之后，而不是变量名称后。</p></blockquote><h2 id="实例化一维数组或矩形数组"><a href="#实例化一维数组或矩形数组" class="headerlink" title="实例化一维数组或矩形数组"></a>实例化一维数组或矩形数组</h2><p><strong>数组创建表达式 array-creation expression</strong>由 new 运算符构成，后面是基类名称和一组方括号。方括号中以逗号分隔每一个维度长度。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>]; <span class="comment">//包含4个int的一维数组</span></span><br><span class="line">MyClass[] mcArr = <span class="keyword">new</span> MyClass[<span class="number">4</span>]; <span class="comment">//包含4个MyClass引用的一维数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[,,] arr3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>]; <span class="comment">//三维数组，数组长度3*6*2=36</span></span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/01/12/KFJ4MufzRmohBNw.png" width = "65%" height = "65%" alt="图58 - 声明和实例化数组"/></div><blockquote><p>与对象创建表达式不同，数组创建表达式不包含圆括号。</p></blockquote><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>在数组中使用整数值作为索引来访问数组元素。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] intArr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">15</span>]; <span class="comment">//声明一维数组</span></span><br><span class="line">intArr1[<span class="number">2</span>] = <span class="number">10</span>; <span class="comment">//向第3个元素写入值</span></span><br><span class="line"><span class="built_in">int</span> var1 = intArr1[<span class="number">2</span>]; <span class="comment">//从第3个元素读取值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[,] intArr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>,<span class="number">10</span>]; <span class="comment">//声明二维数组</span></span><br><span class="line">intArr2[<span class="number">2</span>,<span class="number">3</span>] = <span class="number">7</span>; <span class="comment">//向数组写入值</span></span><br><span class="line"><span class="built_in">int</span> var2 = intArr2[<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">//从数组读取值</span></span><br></pre></td></tr></table></figure><h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><p>当数组被创建之后，每一个元素被自动初始化为类型的默认值。整数默认值为0，浮点型的默认值为0.0，布尔型的默认值为 false ，而引用类型的默认值为 null 。</p><h3 id="显式初始化一维数组"><a href="#显式初始化一维数组" class="headerlink" title="显式初始化一维数组"></a>显式初始化一维数组</h3><p>对于一维数组，若要设置显式初始值，可以在数组实例化的数组创建表达式之后加上一个<strong>初始化列表 initialization list</strong> ：<code>int[] intArr = new int[] &#123; 10, 20, 30, 40 &#125;;</code>，大括号及以内即初始化列表，初始值必须以逗号分隔。</p><p><em>注意：显式初始化可以不输入维度长度，因为编译器可以通过初始化值的个数来推断长度。</em></p><h3 id="显式初始化矩形数组"><a href="#显式初始化矩形数组" class="headerlink" title="显式初始化矩形数组"></a>显式初始化矩形数组</h3><p><code>int[,] intArray2 = new int[,] &#123; &#123;10, 1&#125;, &#123;2, 10&#125;, &#123;11, 9&#125; &#125;;</code></p><div  align="center">  <img src="https://s2.loli.net/2023/01/12/kgSJKUNMA1wRxFQ.png" width = "45%" height = "45%" alt="图59 - 初始化矩形数组"/></div><h3 id="初始化矩形数组的语法点"><a href="#初始化矩形数组的语法点" class="headerlink" title="初始化矩形数组的语法点"></a>初始化矩形数组的语法点</h3><p>矩形数组使用嵌套的、逗号分隔的初始化列表进行初始化：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[,,] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>] &#123;</span><br><span class="line">                                    &#123; &#123;<span class="number">8</span>, <span class="number">6</span>&#125;, &#123;<span class="number">5</span>, <span class="number">2</span>&#125;, &#123;<span class="number">12</span>, <span class="number">9</span>&#125; &#125;,</span><br><span class="line">                                    &#123; &#123;<span class="number">6</span>, <span class="number">4</span>&#125;, &#123;<span class="number">13</span>, <span class="number">9</span>&#125;, &#123;<span class="number">18</span>, <span class="number">4</span>&#125; &#125;,</span><br><span class="line">                                    &#123; &#123;<span class="number">7</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">13</span>&#125;, &#123;<span class="number">9</span>, <span class="number">3</span>&#125; &#125;,</span><br><span class="line">                                    &#123; &#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">23</span>, <span class="number">8</span>&#125; &#125;</span><br><span class="line">                                  &#125;;</span><br></pre></td></tr></table></figure><h3 id="快捷语法"><a href="#快捷语法" class="headerlink" title="快捷语法"></a>快捷语法</h3><p>在一条语句中使用声明、数组创建表达式和初始化列表时，可以省略语法的数组创建表达式部分：</p><p>比如，下面2个语句等价：<br><code>int[] arr1 = new int[3] &#123;10, 20, 30&#125;;</code><br><code>int[] arr1 =            &#123;10, 20, 30&#125;;</code><br>又比如：<br><code>int[,] arr = new int[2,3] &#123;&#123;0, 1, 2&#125;,&#123;10, 11, 12&#125;&#125;;</code><br><code>int[,] arr =              &#123;&#123;0, 1, 2&#125;,&#123;10, 11, 12&#125;&#125;;</code>  </p><h3 id="隐式类型数组"><a href="#隐式类型数组" class="headerlink" title="隐式类型数组"></a>隐式类型数组</h3><p>当初始化数组时，可以使用 var 关键字让编译器根据初始化语句的类型来推断数组类型。只有所有初始化语句能隐式转换为单个类型，才能这么做。如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> [] intArr1 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"><span class="keyword">var</span>    intArr2 = <span class="keyword">new</span>    [] &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;; <span class="comment">//第二个int可以省略也可以不省略</span></span><br><span class="line"><span class="keyword">var</span>    intArr2 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[,] intArr3 = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">10</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">10</span> &#125;, &#123; <span class="number">11</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span>    intArr4 = <span class="keyword">new</span>    [,] &#123; &#123; <span class="number">10</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">10</span> &#125;, &#123; <span class="number">11</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span>    intArr4 = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">10</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">10</span> &#125;, &#123; <span class="number">11</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>[] sArr1 = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;life&quot;</span>, <span class="string">&quot;liberty&quot;</span>, <span class="string">&quot;pursuit of happiness&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span>      sArr2 = <span class="keyword">new</span>       [] &#123; <span class="string">&quot;life&quot;</span>, <span class="string">&quot;liberty&quot;</span>, <span class="string">&quot;pursuit of happiness&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span>      sArr2 = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;life&quot;</span>, <span class="string">&quot;liberty&quot;</span>, <span class="string">&quot;pursuit of happiness&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="综合内容"><a href="#综合内容" class="headerlink" title="综合内容"></a>综合内容</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="built_in">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++ )</span><br><span class="line">    <span class="keyword">for</span>( <span class="built_in">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++ )</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Element [<span class="subst">&#123; i &#125;</span>,<span class="subst">&#123; j &#125;</span>] is <span class="subst">&#123; arr[i,j] &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Element [0,0] is 0</span><br><span class="line">Element [0,1] is 1</span><br><span class="line">Element [0,2] is 2</span><br><span class="line">Element [1,0] is 10</span><br><span class="line">Element [1,1] is 11</span><br><span class="line">Element [1,2] is 12</span><br></pre></td></tr></table></figure><h2 id="交错数组-Jagged-Arrays"><a href="#交错数组-Jagged-Arrays" class="headerlink" title="交错数组 Jagged Arrays"></a>交错数组 Jagged Arrays</h2><p>交错数组是数组的数组，交错数组的子数组的元素个数可以不同。</p><p>例如，如下代码声明了一个二维交错数组：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] jagArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][]; <span class="comment">//声明并创建顶层数组</span></span><br><span class="line">    ···                        <span class="comment">//声明并创建子数组</span></span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/01/12/GN9bHxc1KhkVP4B.png" width = "45%" height = "45%" alt="图60 - 交错数组是数组的数组"/></div><h3 id="声明交错数组"><a href="#声明交错数组" class="headerlink" title="声明交错数组"></a>声明交错数组</h3><p>交错数组的声明语法要求每一个维度都有独立的方括号，方括号的数量即数组的秩。和矩形数组一样，维度长度不能包含在数组类型声明部分。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] SomeArr;  <span class="comment">//秩=2</span></span><br><span class="line"><span class="built_in">int</span>[][][] OtherArr;  <span class="comment">//秩=3</span></span><br></pre></td></tr></table></figure><h3 id="实例化顶层数组"><a href="#实例化顶层数组" class="headerlink" title="实例化顶层数组"></a>实例化顶层数组</h3><p>可以使用数组创建表达式创建顶层数组，但是不能在声明语句中初始化顶层数组以外的数组：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] jagArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][]; <span class="comment">//3个子数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[][] jagArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">//不允许，编译错误</span></span><br></pre></td></tr></table></figure><h3 id="实例化交错数组"><a href="#实例化交错数组" class="headerlink" title="实例化交错数组"></a>实例化交错数组</h3><p>交错数组的初始化不能在一个步骤里完成，每个数组必须独立创建，步骤包括：<br>①实例化顶层数组；<br>②分别实例化每一个子数组，把新建数组的引用赋给它们所属数组的合适元素。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[][] Arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][]; <span class="comment">//实例化顶层数组</span></span><br><span class="line"></span><br><span class="line">Arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">//实例化子数组</span></span><br><span class="line">Arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>&#125;; <span class="comment">//实例化子数组</span></span><br><span class="line">Arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">110</span>, <span class="number">120</span>&#125;; <span class="comment">//实例化子数组</span></span><br></pre></td></tr></table></figure><h3 id="交错数组中的子数组"><a href="#交错数组中的子数组" class="headerlink" title="交错数组中的子数组"></a>交错数组中的子数组</h3><p>由于交错数组中的子数组本身就是数组，因此子数组也可能是矩形数组。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[][,] Arr; <span class="comment">//带有二维数组的交错数组</span></span><br><span class="line">Arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][,]; <span class="comment">//实例化带有3个二维数组的交错数组</span></span><br><span class="line"></span><br><span class="line">Arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">10</span>,  <span class="number">20</span>  &#125;,</span><br><span class="line">                      &#123; <span class="number">100</span>, <span class="number">200</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">Arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">30</span>,  <span class="number">40</span>,  <span class="number">50</span>  &#125;,</span><br><span class="line">                      &#123; <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">Arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123; <span class="number">60</span>,  <span class="number">70</span>,  <span class="number">80</span>,  <span class="number">90</span>  &#125;,</span><br><span class="line">                      &#123; <span class="number">600</span>, <span class="number">700</span>, <span class="number">800</span>, <span class="number">900</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Arr.GetLength(<span class="number">0</span>); i++) <span class="comment">//GetLength获取Arr维度0的长度</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; Arr[i].GetLength(<span class="number">0</span>); j++) <span class="comment">//GetLength获取Arr[i]维度0的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; Arr[i].GetLength(<span class="number">1</span>); k++) <span class="comment">//GetLength获取Arr[i]维度1的长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;[<span class="subst">&#123; i &#125;</span>][<span class="subst">&#123; j &#125;</span>,<span class="subst">&#123; k &#125;</span>] = <span class="subst">&#123; Arr[i][j,k] &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：  </p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[0][0,0] = 10</span><br><span class="line">[0][0,1] = 20</span><br><span class="line"></span><br><span class="line">[0][1,0] = 100</span><br><span class="line">[0][1,1] = 200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[1][0,0] = 30</span><br><span class="line">[1][0,1] = 40</span><br><span class="line">[1][0,2] = 50</span><br><span class="line"></span><br><span class="line">[1][1,0] = 300</span><br><span class="line">[1][1,1] = 400</span><br><span class="line">[1][1,2] = 500</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[2][0,0] = 60</span><br><span class="line">[2][0,1] = 70</span><br><span class="line">[2][0,2] = 80</span><br><span class="line">[2][0,3] = 90</span><br><span class="line"></span><br><span class="line">[2][1,0] = 600</span><br><span class="line">[2][1,1] = 700</span><br><span class="line">[2][1,2] = 800</span><br><span class="line">[2][1,3] = 900</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="比较矩形数组和交错数组"><a href="#比较矩形数组和交错数组" class="headerlink" title="比较矩形数组和交错数组"></a>比较矩形数组和交错数组</h2><p>矩形数组和交错数组的结构区别很大，一个3×3的矩形数组，和一个由3个长度为3的一维数组组成的交错数组，都保存了9个数据，但矩形数组只有单个数组对象，而交错数组有4个数组对象。</p><p>在 CIL 中，一维数组有特定的性能优化指令。因此有时一维数组的交错数组比矩形数组更加高效。另一方面，矩形数组的编程复杂度低，因为是一个单元而不是数组的数组。</p><h2 id="foreach-语句"><a href="#foreach-语句" class="headerlink" title="foreach 语句"></a>foreach 语句</h2><p><strong>foreach 语句</strong>允许我们连续访问数组中的每一个元素。也可以和其他集合类型一起使用，见第19章。</p><p>foreach 语句语法如下：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>( Type Identifier <span class="keyword">in</span> ArrayName ) <span class="comment">//显式类型迭代变量声明</span></span><br><span class="line">    <span class="function">Statement</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">foreach</span>(<span class="params"> <span class="keyword">var</span> Identifier <span class="keyword">in</span> ArrayName </span>) <span class="comment">//隐式类型迭代变量声明</span></span></span><br><span class="line"><span class="function">    Statement</span></span><br></pre></td></tr></table></figure><p>①<strong>迭代变量 iteration variable</strong>是临时的，并且和数组中的元素类型相同。foreach 语句使用迭代变量来相继表示数组中的每个元素；<br>②Type 是数组中元素的类型。可以显式提供它的类型，也可以使用 var 让编译器来推断，因为编译器知道数组的类型；<br>③Identifier 是迭代变量的名字；<br>④ArrayName 是要处理的数组的名字；<br>⑤Statement 是为数组每个元素执行一次的语句或语句块。</p><p>示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr1 = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>( <span class="built_in">int</span> item <span class="keyword">in</span> arr1 )</span><br><span class="line">    Console.WriteLine( <span class="string">$&quot;Item Value: <span class="subst">&#123; item &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="迭代变量是只读的"><a href="#迭代变量是只读的" class="headerlink" title="迭代变量是只读的"></a>迭代变量是只读的</h3><p>由于迭代变量是只读的，它不能被改变，但是对于值类型数组和引用类型数组的效果不一样。</p><p>对于值类型数组，在用迭代变量来表示数组元素时，不能改变它们，如下，尝试改变迭代变量的数据会产生编译时错误：  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr1 = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>( <span class="built_in">int</span> item <span class="keyword">in</span> arr1 )</span><br><span class="line">    item++; <span class="comment">//编译错误，不得改变变量值</span></span><br></pre></td></tr></table></figure><p>对于引用类型数组，虽然不能改变迭代变量，但是迭代变量只是数据的引用，所以可以改变数据：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MyField = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        MyClass[] mcArray = <span class="keyword">new</span> MyClass[<span class="number">4</span>]; <span class="comment">//创建数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mcArray[i] = <span class="keyword">new</span> MyClass(); <span class="comment">//创建类对象</span></span><br><span class="line">            mcArray[i].MyField = i; <span class="comment">//设置字段</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> (MyClass item <span class="keyword">in</span> mcArray)</span><br><span class="line">            item.MyField += <span class="number">10</span>; <span class="comment">//改变数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (MyClass item <span class="keyword">in</span> mcArray)</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; item.MyField &#125;</span>&quot;</span>); <span class="comment">//读取改变的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td></tr></table></figure><h3 id="foreach-语句和多维数组"><a href="#foreach-语句和多维数组" class="headerlink" title="foreach 语句和多维数组"></a>foreach 语句和多维数组</h3><p>矩形数组的示例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span>[,] arr1 = &#123; &#123;<span class="number">10</span>, <span class="number">11</span>&#125;, &#123;<span class="number">12</span>, <span class="number">13</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>( <span class="keyword">var</span> element <span class="keyword">in</span> arr1 )</span><br><span class="line">        &#123;</span><br><span class="line">            total += element;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Element: <span class="subst">&#123; element &#125;</span>, Current Total: <span class="subst">&#123; total &#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Element: 10, Current Total: 10</span><br><span class="line">Element: 11, Current Total: 21</span><br><span class="line">Element: 12, Current Total: 33</span><br><span class="line">Element: 13, Current Total: 46</span><br></pre></td></tr></table></figure><p>交错数组的示例，由于交错数组是数组的数组，所以需要为每个维度都使用独立的 foreach 语句，foreach 语句必须嵌套以确保每一个嵌套数组都被正确处理：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span>[][] arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>][];</span><br><span class="line">        arr1[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">11</span> &#125;;</span><br><span class="line">        arr1[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span>[] array <span class="keyword">in</span> arr1) <span class="comment">//处理顶层数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Starting new array&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> array) <span class="comment">//处理第二层数组</span></span><br><span class="line">            &#123;</span><br><span class="line">                total += item;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot; Item: <span class="subst">&#123; item &#125;</span>, Current Total: <span class="subst">&#123; total &#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Starting new array</span><br><span class="line"> Item: 10, Current Total: 10</span><br><span class="line"> Item: 11, Current Total: 21</span><br><span class="line">Starting new array</span><br><span class="line"> Item: 12, Current Total: 33</span><br><span class="line"> Item: 13, Current Total: 46</span><br><span class="line"> Item: 14, Current Total: 60</span><br></pre></td></tr></table></figure><h2 id="数组协变-Array-Covariance"><a href="#数组协变-Array-Covariance" class="headerlink" title="数组协变 Array Covariance"></a>数组协变 Array Covariance</h2><p>在某些情况下，即使某个对象不是数组的基类型，也可以把它赋值给数组元素，即<strong>数组协变</strong>。在下列情况下可以使用数组协变：<br>①数组是引用类型数组；<br>②在赋值的对象类型和数组的基类型之间有隐式或显式转换。</p><p>由于在派生类和基类之间总是有隐式转换，因此总是可以将一个派生类的对象赋值给为基类声明的数组：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="comment">//两个A[]类型的数组</span></span><br><span class="line">        A[] AArray1 = <span class="keyword">new</span> A[<span class="number">3</span>]; </span><br><span class="line">        A[] AArray2 = <span class="keyword">new</span> A[<span class="number">3</span>]; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通：将A类型的对象赋值给A类型的数组</span></span><br><span class="line">        AArray1[<span class="number">0</span>] = <span class="keyword">new</span> A(); AArray1[<span class="number">1</span>] = <span class="keyword">new</span> A(); AArray1[<span class="number">2</span>] = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协变：将B类型的对象赋值给A类型的数组</span></span><br><span class="line">        AArray2[<span class="number">0</span>] = <span class="keyword">new</span> B(); AArray2[<span class="number">1</span>] = <span class="keyword">new</span> B(); AArray2[<span class="number">2</span>] = <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>值类型数组没有协变。</p></blockquote><h2 id="数组继承的有用成员"><a href="#数组继承的有用成员" class="headerlink" title="数组继承的有用成员"></a>数组继承的有用成员</h2><p>C# 数组派生自 System.Array 类，继承了很多有用的属性和方法：</p><div class="table-container"><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">类型</th><th style="text-align:left">生存期</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">Rank</td><td style="text-align:left">属性</td><td style="text-align:left">实例</td><td style="text-align:left">获取数组的维度数</td></tr><tr><td style="text-align:left">Length</td><td style="text-align:left">属性</td><td style="text-align:left">实例</td><td style="text-align:left">获取数组中所有维度的元素总数</td></tr><tr><td style="text-align:left">GetLength</td><td style="text-align:left">方法</td><td style="text-align:left">实例</td><td style="text-align:left">返回数组的指定维度的长度</td></tr><tr><td style="text-align:left">Clear</td><td style="text-align:left">方法</td><td style="text-align:left">静态</td><td style="text-align:left">将某一范围内的元素设置为0或null</td></tr><tr><td style="text-align:left">Sort</td><td style="text-align:left">方法</td><td style="text-align:left">静态</td><td style="text-align:left">在一维数组中对元素进行排序</td></tr><tr><td style="text-align:left">BinarySearch</td><td style="text-align:left">方法</td><td style="text-align:left">静态</td><td style="text-align:left">使用二进制搜索，搜索一维数组中的值</td></tr><tr><td style="text-align:left">Clone</td><td style="text-align:left">方法</td><td style="text-align:left">实例</td><td style="text-align:left">进行数组的浅复制 —— 对于值类型数组和引用类型数组，都只复制元素</td></tr><tr><td style="text-align:left">IndexOf</td><td style="text-align:left">方法</td><td style="text-align:left">静态</td><td style="text-align:left">返回一维数组中遇到的第一个值</td></tr><tr><td style="text-align:left">Reverse</td><td style="text-align:left">方法</td><td style="text-align:left">静态</td><td style="text-align:left">反转一维数组中某个范围内的元素</td></tr><tr><td style="text-align:left">GetUpperBound</td><td style="text-align:left">方法</td><td style="text-align:left">实例</td><td style="text-align:left">获取指定维度的上限</td></tr></tbody></table></div><p>部分示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintArray</span>(<span class="params"><span class="built_in">int</span>[] a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> a)</span><br><span class="line">        Console.Write(<span class="string">$&quot;<span class="subst">&#123; x &#125;</span> &quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">15</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    PrintArray(arr);</span><br><span class="line"></span><br><span class="line">    Array.Sort(arr);</span><br><span class="line">    PrintArray(arr);</span><br><span class="line"></span><br><span class="line">    Array.Reverse(arr);</span><br><span class="line">    PrintArray(arr);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Rank = <span class="subst">&#123; arr.Rank &#125;</span>, Length = <span class="subst">&#123; arr.Length &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;GetLength(0) = <span class="subst">&#123; arr.GetLength(<span class="number">0</span>) &#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;GetType() = <span class="subst">&#123; arr.GetType() &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">15 20 5 25 10 </span><br><span class="line">5 10 15 20 25</span><br><span class="line">25 20 15 10 5</span><br><span class="line"></span><br><span class="line">Rank = 1, Length = 5</span><br><span class="line">GetLength(0) = 5</span><br><span class="line">GetType() = System.Int32[]</span><br></pre></td></tr></table></figure><h3 id="Clone-方法"><a href="#Clone-方法" class="headerlink" title="Clone 方法"></a>Clone 方法</h3><p>Clone 方法为数组进行浅复制，即只创建了数组本身的克隆：<br>①克隆值类型数组会产生两个独立的数组；<br>②克隆引用类型数组会产生指向相同对象的两个数组；<br>③Clone 方法返回 object 类型的引用，它必须被强制转换为数组类型。</p><p>克隆值类型数组的示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] intArr1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="built_in">int</span>[] intArr2 = (<span class="built_in">int</span>[]) intArr1.Clone(); <span class="comment">//因为返回object，所以要转换为数组</span></span><br><span class="line"></span><br><span class="line">    intArr2[<span class="number">0</span>] = <span class="number">100</span>; intArr2[<span class="number">1</span>] = <span class="number">200</span>; intArr2[<span class="number">2</span>] = <span class="number">300</span>; <span class="comment">//intArr1为&#123;1,2,3&#125;，intArr2为&#123;100,200,300&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>克隆引用类型的示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        A[] AArray1 = <span class="keyword">new</span> A[<span class="number">3</span>] &#123; <span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A() &#125;;</span><br><span class="line">        A[] AArray2 = (A[]) AArray1.Clone();</span><br><span class="line"></span><br><span class="line">        AArray2[<span class="number">0</span>].Value = <span class="number">100</span>;</span><br><span class="line">        AArray2[<span class="number">1</span>].Value = <span class="number">200</span>;</span><br><span class="line">        AArray2[<span class="number">2</span>].Value = <span class="number">300</span>;</span><br><span class="line">        <span class="comment">//AArray1和AArray2都引用&#123;100,200,300&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组与-ref-返回和-ref-局部变量"><a href="#数组与-ref-返回和-ref-局部变量" class="headerlink" title="数组与 ref 返回和 ref 局部变量"></a>数组与 ref 返回和 ref 局部变量</h2><p>第6章介绍了 ref 返回和 ref 局部变量，利用 ref 返回功能，可以把一个引用作为返回值传到方法体之外，而利用 ref 局部变量，可以在调用域内使用这个引用</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">ref</span> <span class="built_in">int</span> <span class="title">PointerToHighestPositive</span>(<span class="params"><span class="built_in">int</span>[] numbers</span>) <span class="comment">//接受一个数组为参数，并且返回对该数组元素的引用</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> highest = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> indexOfHighest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numbers.Length; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i] &gt; highest)</span><br><span class="line">                &#123;</span><br><span class="line">                    indexOfHighest = i;</span><br><span class="line">                    highest = numbers[indexOfHighest];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">ref</span> numbers[indexOfHighest];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] scores = &#123; <span class="number">5</span>, <span class="number">80</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Before: <span class="subst">&#123;scores[<span class="number">0</span>]&#125;</span>, <span class="subst">&#123;scores[<span class="number">1</span>]&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">ref</span> <span class="built_in">int</span> locationOfHigher = <span class="function"><span class="keyword">ref</span> <span class="title">PointerToHighestPositive</span>(<span class="params">scores</span>)</span>;</span><br><span class="line"></span><br><span class="line">        locationOfHigher = <span class="number">0</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After : <span class="subst">&#123;scores[<span class="number">0</span>]&#125;</span>, <span class="subst">&#123;scores[<span class="number">1</span>]&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Before: 5, 80</span><br><span class="line">After : 5, 0</span><br></pre></td></tr></table></figure><h1 id="第十四章-委托"><a href="#第十四章-委托" class="headerlink" title="第十四章 委托"></a>第十四章 委托</h1><h2 id="什么是委托"><a href="#什么是委托" class="headerlink" title="什么是委托"></a>什么是委托</h2><p><strong>委托 delegate</strong> 是持有一个或多个方法的对象。示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span>; <span class="comment">//声明委托类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintLow</span>(<span class="params"> <span class="built_in">int</span> <span class="keyword">value</span> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; <span class="keyword">value</span> &#125;</span> - Low Value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintHigh</span>(<span class="params"> <span class="built_in">int</span> <span class="keyword">value</span> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; <span class="keyword">value</span> &#125;</span> - High Value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line"></span><br><span class="line">        MyDel del; <span class="comment">//声明委托变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建随机整数生成器对象，并得到0到99之间的一个随机数</span></span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="built_in">int</span> randomValue = rand.Next( <span class="number">99</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个包含PrintLow或PrintHigh的委托对象并将其复制给del变量</span></span><br><span class="line">        del = randomValue &lt; <span class="number">50</span></span><br><span class="line">                ? <span class="keyword">new</span> MyDel( program.PrintLow )</span><br><span class="line">                : <span class="keyword">new</span> MyDel( program.PrintHigh );</span><br><span class="line"></span><br><span class="line">        del( randomValue ); <span class="comment">//执行委托</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="委托概述"><a href="#委托概述" class="headerlink" title="委托概述"></a>委托概述</h2><p>委托和类一样是一种用户定义类型。类表示是数据和方法的集合，委托则持有一个或多个方法，以及一系列预定义操作。可以通过以下步骤来使用委托：<br>①声明一个委托类型，委托类型没有实现主体（块）；<br>②使用该委托类型声明一个委托变量；<br>③创建一个委托类型的对象，并赋值给委托变量。新的委托对象包含指向某个方法的引用，这个方法的签名和返回类型必须和第一步定义的委托类型一致；<br>④可以选择为委托对象添加其他方法。这些方法的签名和返回类型要与第一步定义的委托类型相同；<br>⑤调用委托时，其包含的每一个方法都会被执行。</p><p>可以把 delegate 看作一个包含有序方法的列表，这些方法拥有相同的签名和返回类型：<br>①方法的列表被称为<strong>调用列表 invocation list</strong> ；<br>②委托持有的方法可以来自任何类和结构，只有能与委托的返回类型和签名匹配；<br>③调用列表的方法可以是实例方法也可以是静态方法；<br>④调用委托时，会执行其调用列表中的所有方法。</p><h2 id="声明委托类型"><a href="#声明委托类型" class="headerlink" title="声明委托类型"></a>声明委托类型</h2><p>声明语法：<code>delegate void MyDel( int x );</code> ，委托类型的声明看上去和方法的声明类似，有返回类型和签名。返回类型和签名指定了委托接受的方法的形式，比如该 MyDel 委托，只接受无返回值的并且有单个 int 参数的方法。</p><p>委托类型声明没有方法主体。</p><div  align="center">  <img src="https://s2.loli.net/2023/01/16/pTVtcDSKRi2f38M.png" width = "70%" height = "70%" alt="图61 - 委托类型和对象"/></div><h2 id="创建委托对象"><a href="#创建委托对象" class="headerlink" title="创建委托对象"></a>创建委托对象</h2><p>委托是引用类型，在类型声明后，要声明变量并创建类型的对象。</p><p><strong>委托类型变量的声明</strong>语法：<code>MyDel delVar;</code></p><p>有两种<strong>创建委托对象</strong>的方法，第一种是使用带 new 运算符的对象创建表达式，包括委托类型名，和圆括号内的作为调用列表的第一个成员的方法的名称，该方法可以是实例方法或静态方法，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">delVar = <span class="keyword">new</span> MyDel( myInstObj.MyM1 ); <span class="comment">//创建委托并保持引用，实例方法</span></span><br><span class="line">dVar = <span class="keyword">new</span> MyDel( SClass.OtherM2 ); <span class="comment">//创建委托并保持引用，静态方法</span></span><br></pre></td></tr></table></figure><p>第二种创建委托对象的方式为快捷语法，仅由方法说明符构成。这种快捷语法可以工作是因为方法名称和相应的委托类型之间存在隐式转换，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">delVar = myInstObj.MyM1; <span class="comment">//创建委托并保持引用，实例方法</span></span><br><span class="line">dVar = SClass.OtherM2; <span class="comment">//创建委托并保持引用，静态方法</span></span><br></pre></td></tr></table></figure><p>将声明委托类型、声明委托变量、创建委托对象合并的示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>; <span class="comment">//声明委托类型</span></span><br><span class="line">MyDel delVar, dVar; <span class="comment">//创建两个委托变量</span></span><br><span class="line"></span><br><span class="line">delVar = <span class="keyword">new</span> MyDel( myInstObj.MyM1 ); <span class="comment">//创建委托并保存引用</span></span><br><span class="line">dVar = <span class="keyword">new</span> MyDel( SClass.OtherM2 ); <span class="comment">//创建委托并保存引用</span></span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/01/29/ZE3i2n5mRuGjQcr.png" width = "60%" height = "60%" alt="图62 - 初始化委托"/></div><p>除了为委托分配内存，创建委托对象还会把第一个方法放入委托的调用列表。</p><h2 id="给委托赋值"><a href="#给委托赋值" class="headerlink" title="给委托赋值"></a>给委托赋值</h2><p>由于委托是引用类型，可以通过给它赋值来改变包含在委托变量中的引用。旧委托对象会被垃圾回收器回收。</p><p>委托是恒定的，委托对象被创建后不能被改变，但是可以改变变量的引用。</p><h2 id="组合委托-Combining-Delegates"><a href="#组合委托-Combining-Delegates" class="headerlink" title="组合委托 Combining Delegates"></a>组合委托 Combining Delegates</h2><p>委托可以使用额外的运算符来组合，这个运算会创建一个新的委托，其调用列表连接了作为操作数的两个委托的调用列表副本，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDel delA = myInstObj.MyM1;</span><br><span class="line">MyDel delB = SClass.OtherM2;</span><br><span class="line"></span><br><span class="line">MyDel delC = delA + delB; <span class="comment">//组合调用列表</span></span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/01/29/G5M46l2Be31rTP9.png" width = "65%" height = "65%" alt="图63 - 组合委托"/></div><h2 id="为委托添加方法"><a href="#为委托添加方法" class="headerlink" title="为委托添加方法"></a>为委托添加方法</h2><p>使用 <strong>+=</strong> 运算符，可以为委托“添加”方法，方法加在了调用列表的底部。使用 += 运算符，实际上是创建了一个新的委托，然后将这个委托赋值给了原名称，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDel delVar = inst.MyM1; <span class="comment">//创建并初始化</span></span><br><span class="line">delVar += SCl.m3; <span class="comment">//增加方法</span></span><br><span class="line">delVar += X.Act; <span class="comment">//增加方法</span></span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/01/29/Ve93Cgcd5xFBuRm.png" width = "50%" height = "50%" alt="图64 - 由于委托是不可变的，所以为委托的调用列表添加3个方法后的结果其实是变量指向的一个全新的委托"/></div><h2 id="从委托移除方法"><a href="#从委托移除方法" class="headerlink" title="从委托移除方法"></a>从委托移除方法</h2><p>使用 <strong>-=</strong> 运算符，可以为委托“移除”方法。与为委托添加方法一样，其实是创建了一个新的委托，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">delVar -= SCl.m3; <span class="comment">//从委托移除方法</span></span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/01/29/4Tadl6vA8C5yZzx.png" width = "50%" height = "50%" alt="图65 - 从委托移除方法"/></div><p>其他注意事项：<br>①如果在调用列表中的有多个同名方法，-= 运算符从列表底部开始搜索，并且移除第一个与方法匹配的实例；<br>②试图删除委托中不存在的方法将无效；<br>③试图调用空委托会抛出异常。可以通过将委托和 null 进行比较来判断委托的调用列表是否为空。如果调用列表为空，则委托是 null 。</p><h2 id="调用委托-Invoking-a-Delegate"><a href="#调用委托-Invoking-a-Delegate" class="headerlink" title="调用委托 Invoking a Delegate"></a>调用委托 Invoking a Delegate</h2><p>①可以通过两种方式调用委托，一种是像调用方法一样调用委托，另一种是使用委托的 Invoke 方法；<br>②可以将参数放在调用的圆括号之内。用于调用委托的参数作用于调用列表中的每个方法，除非其中一个参数是输出参数，见后面；<br>③如果一个方法在调用列表中多次出现，则在调用委托时，每次在列表中遇到该方法时都会调用它；<br>④调用时委托不能为空 null ，否则会引发异常。可以使用 if 语句或者使用<strong>空条件运算符</strong>和 Invoke 方法去检查。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDel delVar = inst.MyM1;</span><br><span class="line">delVar += SCl.m3;</span><br><span class="line">delVar += X.Act;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (delVar != <span class="literal">null</span>)</span><br><span class="line">    &#123; delVar(<span class="number">55</span>); &#125; <span class="comment">//调用委托</span></span><br><span class="line">delVar?.Invoke(<span class="number">65</span>); <span class="comment">//使用Invoke和空条件运算符</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2023/01/29/4RD9hkBjc7Oysnl.png" width = "60%" height = "60%" alt="图66 - 在调用委托时，它使用相同的参数来执行调用列表中的每一个方法"/></div><h2 id="委托的示例"><a href="#委托的示例" class="headerlink" title="委托的示例"></a>委托的示例</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个没有返回值和参数的委托类型</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">PrintFunction</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print1</span>()</span></span><br><span class="line">    &#123; Console.WriteLine(<span class="string">&quot;Print1 -- instance&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print2</span>()</span></span><br><span class="line">    &#123; Console.WriteLine(<span class="string">&quot;Print2 -- static&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test(); <span class="comment">//创建类示例</span></span><br><span class="line">        PrintFunction pf; <span class="comment">//创建一个空委托</span></span><br><span class="line"></span><br><span class="line">        pf = t.Print1; <span class="comment">//实例化并初始化该委托</span></span><br><span class="line"></span><br><span class="line">        pf += Test.Print2;</span><br><span class="line">        pf += t.Print1;</span><br><span class="line">        pf += Test.Print2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">null</span> != pf) <span class="comment">//确认委托有方法</span></span><br><span class="line">            pf(); <span class="comment">//调用委托</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Delegate is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Print1 -- instance</span><br><span class="line">Print2 -- static</span><br><span class="line">Print1 -- instance</span><br><span class="line">Print2 -- static</span><br></pre></td></tr></table></figure><h2 id="调用带返回值的委托"><a href="#调用带返回值的委托" class="headerlink" title="调用带返回值的委托"></a>调用带返回值的委托</h2><p>如果委托有返回值并且在调用列表中有一个以上的方法，则：<br>①调用列表中最后一个方法返回的值就是委托调用返回的值；<br>②调用列表中其他方法的返回值就会被忽略。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDel</span>(<span class="params"> </span>)</span>; <span class="comment">//声明有返回值的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> IntValue = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add2</span>()</span> &#123; IntValue += <span class="number">2</span>; <span class="keyword">return</span> IntValue;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add3</span>()</span> &#123; IntValue += <span class="number">3</span>; <span class="keyword">return</span> IntValue;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span>&#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass(); </span><br><span class="line">        MyDel mDel = mc.Add2; <span class="comment">//创建并初始化委托</span></span><br><span class="line">        mDel += mc.Add3; <span class="comment">//增加方法</span></span><br><span class="line">        mDel += mc.Add2; <span class="comment">//增加方法</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Value: <span class="subst">&#123; mDel() &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Value: 12</span><br></pre></td></tr></table></figure><h2 id="调用带引用参数的委托"><a href="#调用带引用参数的委托" class="headerlink" title="调用带引用参数的委托"></a>调用带引用参数的委托</h2><p>如果委托有引用参数，参数值会根据调用列表中的一个或多个方法而改变。在调用委托列表中的下一个方法时，参数的新值会传给下一个方法。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"> <span class="keyword">ref</span> <span class="built_in">int</span> X </span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add2</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x</span>)</span> &#123; x += <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add3</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> x</span>)</span> &#123; x += <span class="number">3</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        MyDel mDel = mc.Add2;</span><br><span class="line">        mDel += mc.Add3;</span><br><span class="line">        mDel += mc.Add2;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">5</span>;</span><br><span class="line">        mDel(<span class="keyword">ref</span> x);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Value: <span class="subst">&#123; x &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Value: 12</span><br></pre></td></tr></table></figure><p>如果没有 ref 关键字，则每个方法的参数都为5，所以上述案例的输出也为5。</p><h2 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h2><p><strong>匿名方法 anonymous method</strong>是在实例化委托时内联(inline)声明的方法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具名方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add20</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">OtherDel</span>(<span class="params"><span class="built_in">int</span> InParam</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OtherDel del = Add20;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, del(<span class="number">5</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, del(<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">OtherDel</span>(<span class="params"><span class="built_in">int</span> InParam</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OtherDel del = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">return</span> x + <span class="number">20</span>;</span><br><span class="line">                        &#125;;</span><br><span class="line">        </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, del(<span class="number">5</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, del(<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两组代码输入都是：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">25</span><br><span class="line">26</span><br></pre></td></tr></table></figure><h3 id="使用匿名方法"><a href="#使用匿名方法" class="headerlink" title="使用匿名方法"></a>使用匿名方法</h3><p>我们可以在以下地方使用匿名方法：<br>①声明委托变量时作为初始化表达式；<br>②组合委托时在赋值语句的右边；<br>③为委托增加事件时，在赋值语句的右边。见第15章。</p><h3 id="匿名方法的语法"><a href="#匿名方法的语法" class="headerlink" title="匿名方法的语法"></a>匿名方法的语法</h3><p>匿名方法表达式的语法包含如下组成部分：<br>① delegate 类型关键字；<br>②参数列表，若语句块没有使用任何参数可以省略；<br>③语句块，包含匿名方法的代码。</p><p>格式：<code>delegate ( Parameters ) &#123; ImplementationCode &#125;</code></p><p><strong><em>1、返回类型</em></strong><br>匿名方法不会显式声明返回值，但是必须返回一个与委托的返回值类型相同的值。如果委托是 void 类型的返回值，则匿名方法不能返回值。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">OtherDel</span>(<span class="params"><span class="built_in">int</span> InParam</span>)</span>; <span class="comment">//委托类型的返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    OtherDel del = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> x + <span class="number">20</span> ; <span class="comment">//返回一个整数型</span></span><br><span class="line">                &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>2、参数</em></strong><br>除了数组参数，匿名方法的参数列表必须在这几个方面与委托匹配：参数数量；参数的类型以及位置；修饰符。</p><p>可以使用空括号或者省略括号，但是需要满足2个条件：①委托的参数列表不包含任何 out 参数；②匿名方法不使用任何参数。如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">SomeDel</span> (<span class="params"> <span class="built_in">int</span> X </span>)</span>; <span class="comment">//声明委托类型</span></span><br><span class="line"></span><br><span class="line">SomeDel SDel = <span class="built_in">delegate</span> <span class="comment">//省略参数列表，因为不使用参数</span></span><br><span class="line">            &#123;</span><br><span class="line">                PrintMessage();</span><br><span class="line">                Cleanup();</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p><strong><em>3、params 参数</em></strong><br>如果委托声明的参数列表包含了 params 参数，那么匿名方法的参数列表将忽略 params 关键字。如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">SomeDel</span>(<span class="params"> <span class="built_in">int</span> X, <span class="keyword">params</span> <span class="built_in">int</span>[] Y</span>)</span>; <span class="comment">//委托类型声明中使用params关键字</span></span><br><span class="line"></span><br><span class="line">SomeDel mDel = <span class="built_in">delegate</span> (<span class="built_in">int</span> X, <span class="built_in">int</span>[] Y) <span class="comment">//在匹配的匿名方法中省略关键字</span></span><br><span class="line">            &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><h3 id="变量和参数的作用域"><a href="#变量和参数的作用域" class="headerlink" title="变量和参数的作用域"></a>变量和参数的作用域</h3><p>参数以及声明在匿名方法内部的局部变量的作用域限制在实现代码的主体中。</p><p>如下，匿名方法定义的参数 y 和局部变量 z 。在匿名方法主体结束之后，y 和 z 就不在作用域之内。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"> <span class="built_in">int</span> x</span>)</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">MyDel mDel = <span class="built_in">delegate</span> (<span class="built_in">int</span> y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> z = <span class="number">10</span>;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>, y, z);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>, y, z); <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p><strong><em>1、外部变量</em></strong><br>匿名方法可以访问它们外围作用域的局部变量和环境。外围作用域的变量叫做<strong>外部变量 outer variable</strong>。用在匿名方法实现代码中的外部变量称为被方法<strong>捕获</strong>。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x = <span class="number">5</span>; <span class="comment">//变量x定义在匿名方法作用域的前面</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">MyDel mDel = <span class="built_in">delegate</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, x); <span class="comment">//变量x可以在匿名方法作用域内使用</span></span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p><strong><em>2、捕获变量的生命周期的扩展</em></strong><br>如下，局部变量x在块中声明并初始化，然后委托 mDel 用匿名方法初始化，该匿名方法捕获了外部变量x。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"> </span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyDel mDel;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">5</span>; <span class="comment">//变量x定义在外部块里，在匿名方法之外</span></span><br><span class="line"></span><br><span class="line">        mDel = <span class="built_in">delegate</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;Value of x: &#123;0&#125;&quot;</span>, x); <span class="comment">//变量x被匿名方法捕获</span></span><br><span class="line">                &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Console.WriteLine(&quot;Value of x: &#123;0&#125;&quot;, x); 变量x离开了作用域并且会导致编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != mDel)</span><br><span class="line">        mDel(); <span class="comment">//而这里在匿名方法内部使用了x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Value of x: 5</span><br></pre></td></tr></table></figure><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p><strong>Lambda 表达式</strong>简化了匿名方法的语法。在匿名方法中，delegate 有点多余，我们可以通过①删除 delegate 关键字，和②在参数列表和匿名方法主体之间放置 <strong>Lambda 运算符 =&gt;</strong> 来把匿名方法转换为 Lambda 表达式。Lambda 运算符读做“goes to”。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDel del = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)    &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125; ; <span class="comment">//匿名方法</span></span><br><span class="line">MyDel le1 =         (<span class="built_in">int</span> x) =&gt; &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125; ; <span class="comment">//Lambda表达式</span></span><br></pre></td></tr></table></figure><p>①因为编译器还可以从委托的声明中知道委托参数的类型，因此 Lambda 表达式允许省略类型参数；<br>②如果只有一个隐式类型参数，可以省略括号；<br>③Lambda 表达式允许表达式的主体是语句块或表达式。如果语句块包含了一个返回语句，可以将语句块替换为 return 关键字后的表达式。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDel le1 =         (<span class="built_in">int</span> x) =&gt; &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125; ; <span class="comment">//Lambda表达式</span></span><br><span class="line">MyDel le2 =             (x) =&gt; &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125; ; <span class="comment">//Lambda表达式</span></span><br><span class="line">MyDel le3 =              x  =&gt; &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125; ; <span class="comment">//Lambda表达式</span></span><br><span class="line">MyDel le4 =              x  =&gt;          x + <span class="number">1</span>    ; <span class="comment">//Lambda表达式</span></span><br></pre></td></tr></table></figure><p>Lambda 表达式的参数列表的要点如下：<br>①Lambda 表达式参数列表中的参数必须在参数数量、类型和位置上与委托相匹配；<br>②表达式的参数列表中的参数不一定需要包含类型（隐式类型），除非委托有 ref 和 out 参数，则必须注明类型（显式类型）；<br>③如果只有一个参数，并且是隐式类型，则括号可以省略；<br>④如果没有参数必须使用一组空的圆括号。</p><h1 id="第十五章-事件"><a href="#第十五章-事件" class="headerlink" title="第十五章 事件"></a>第十五章 事件</h1><h2 id="发布者和订阅者"><a href="#发布者和订阅者" class="headerlink" title="发布者和订阅者"></a>发布者和订阅者</h2><p>很多程序需要当某一特定的程序事件发生时，程序的其他部分可以得到该事件已经发生的通知。<strong>发布者/订阅者模式 publisher / subscriber pattern</strong> 可以满足这个需求。在这种模式下，<strong>发布者类</strong>定义了一系列事件成员。其他类可以“注册”，以便这些事件发生时收到通知。这些<strong>订阅者类</strong>通过向发布者提供一个方法来“注册”以获取通知。当事件发生时，发布者“触发事件”，然后执行订阅者提交的所有事件。由订阅者提供的方法称为<strong>回调方法 callback methods</strong>，因为发布者通过执行订阅者的方法“calls the subscribers back”。也可以称为<strong>事件处理程序 event handlers</strong>。</p><div  align="center">  <img src="https://s2.loli.net/2023/02/03/GvWbIk84gY7MpsT.png" width = "80%" height = "80%" alt="图67 - 发布者和订阅者"/></div><p>①<strong>发布者 publisher</strong> ：发布某个事件的类或结构；<br>②<strong>订阅者 subscriber</strong> ：注册并在事件发生时得到通知的类或结构；<br>③<strong>事件处理程序 event handler</strong> ：订阅者注册到事件的方法，在发布者触发事件时执行。事件处理程序方法可以定义在事件所在的类或结构里，也可以定义在不同的类或结构里；<br>④<strong>触发事件 Raising an event</strong> ：当调用 invoke 或触发 fire 事件，所有注册到它的方法都会被依次调用。</p><p><strong>事件</strong>和委托类似，实际上事件包含了一个私有委托，如下图：</p><div  align="center">  <img src="https://s2.loli.net/2023/02/03/hGtlFfVYb8DjeB5.png" width = "50%" height = "50%" alt="图68 - 事件有被封装的委托"/></div><p>事件的私有委托的重要事项如下：<br>①事件提供了对它私有控制的委托的结构化方法，即无法直接访问委托；<br>②事件中可用的操作比委托少，对于事件只可以添加、删除或调用事件处理程序；<br>③事件被触发时，它调用委托来依次调用调用列表中的方法。</p><p>下图演示了一个叫做 Incrementer 的类：</p><div  align="center">  <img src="https://s2.loli.net/2023/02/03/qHBh6jzQoIwYAnR.png" width = "70%" height = "70%" alt="图69 - 具有一个事件的类的结构和术语"/></div><h2 id="源代码组件概览"><a href="#源代码组件概览" class="headerlink" title="源代码组件概览"></a>源代码组件概览</h2><p>需要在事件中使用的代码有5部分：<br>①<strong>委托类型声明</strong>：事件和事件处理程序必须有共同的签名和返回类型；<br>②<strong>事件处理程序声明</strong>：订阅者类中会在事件触发时执行的方法的声明，可以是匿名方法或者是 Lambda 表达式；<br>③<strong>事件声明</strong>：发布者类必须声明一个订阅者类可以注册的事件成员。当类声明的事件为 public 时，称为发布了事件；<br>④<strong>事件注册</strong>：订阅者必须注册事件才能在事件被触发时得到通知，这是将事件处理程序与事件相连的代码；<br>⑤<strong>触发事件的代码</strong>：发布者类中触发事件并导致调用注册的所有事件处理程序的代码。</p><div  align="center">  <img src="https://s2.loli.net/2023/02/03/IsnQ2Wdi8bY4Tt1.png" width = "50%" height = "50%" alt="图70 - 使用事件时的5个源代码组件"/></div><h2 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h2><p>发布者类必须提供<strong>事件对象</strong>。事件声明在一个类中，它需要委托类型的名称，任何附加在事件（如注册）的处理程序都必须与委托类型的签名和返回类型匹配。事件需声明为 public ，这样其他的类和结构可以在它上面注册事件处理程序。不能使用对象创建表达式，即 new，来创建事件对象。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Incrementer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CountedADozen; <span class="comment">//EventHandler为委托类型，CountedADozen为事件名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent1, MyEvent2, OtherEvent; <span class="comment">//可以通过逗号分隔来声明一个以上的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> EventHandler CountedADozen; <span class="comment">//可以使用 static 关键字让事件变成静态的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>事件是成员</strong>，和方法、属性一样，是类或结构的成员：<br>①由于事件是成员，不能在一段可执行代码中声明事件，它必须声明在类或结构中；<br>②事件成员被隐式自动初始化为 null。</p><p>BCL 声明了一个叫作 EventHandler 的委托，专门用于系统事件，见后面。</p><h2 id="订阅事件"><a href="#订阅事件" class="headerlink" title="订阅事件"></a>订阅事件</h2><p>订阅者向事件添加事件处理程序，其必须具有与事件委托相同的返回类型和签名。使用 += 运算符为事件添加事件处理程序，可以是实例方法、静态方法、匿名方法和 Lambda 表达式。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//incrementer为类，CountedADozen为类的事件成员</span></span><br><span class="line">incrementer.CountedADozen += IncrementDozensCount; <span class="comment">//实例方法</span></span><br><span class="line">incrementer.CountedADozen += ClassB.CounterHandlerB; <span class="comment">//静态方法</span></span><br><span class="line"></span><br><span class="line">mc.CountedADozen += <span class="keyword">new</span> EventHandler(cc.CounterHandlerC); <span class="comment">//委托形式的实例方法</span></span><br><span class="line"></span><br><span class="line">incrementer.CountedADozen += () =&gt; DozensCount++; <span class="comment">//Lambda表达式</span></span><br><span class="line"></span><br><span class="line">incrementer.CountedADozen += <span class="built_in">delegate</span> &#123; DozensCount++; &#125;; <span class="comment">//匿名方法</span></span><br></pre></td></tr></table></figure><h2 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h2><p>事件成员本身只保存了需要被调用的事件处理程序，需要在合适的时候触发事件，代码如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CountedADozen != <span class="literal">null</span>) <span class="comment">//确定有方法可以执行</span></span><br><span class="line">    CountedADozen (source, args); <span class="comment">//触发事件，包括事件名称和参数列表，参数列表必须与事件的委托类型相匹配</span></span><br></pre></td></tr></table></figure><p>把事件声明和触发事件的代码合并，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Incrementer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CountedADozen; <span class="comment">//声明事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoCount</span>(<span class="params"><span class="built_in">object</span> source, EventArgs args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="built_in">int</span> i=<span class="number">1</span>; i &lt; <span class="number">100</span>; i++ )</span><br><span class="line">            <span class="keyword">if</span>( i % <span class="number">12</span> == <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">if</span> (CountedADozen != <span class="literal">null</span>)</span><br><span class="line">                    CountedADozen(source, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下展示了整个程序，包含发布者类 Incrementer 和订阅者类 Dozens：<br>①在构造函数内，Dozens 类订阅事件，将 IncrementDozensCount 作为事件处理程序；<br>②在 Incrementer 类的 DoCount 方法中，每增加12个计数就触发 CountedADozen 事件。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Handler</span>()</span>; <span class="comment">//声明委托</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发布者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Incrementer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Handler CountedADozen; <span class="comment">//创建事件并发布</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoCount</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++ )</span><br><span class="line">            <span class="keyword">if</span> ( i % <span class="number">12</span> == <span class="number">0</span> &amp;&amp; CountedADozen != <span class="literal">null</span> )</span><br><span class="line">                CountedADozen(); <span class="comment">//每增加12个计数触发事件一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dozens</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> DozensCount &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dozens</span>(<span class="params"> Incrementer incrementer </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DozensCount = <span class="number">0</span>;</span><br><span class="line">        incrementer.CountedADozen += IncrementDozensCount; <span class="comment">//订阅事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IncrementDozensCount</span>() <span class="comment">//声明事件处理程序</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        DozensCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Incrementer incrementer = <span class="keyword">new</span> Incrementer();</span><br><span class="line">        Dozens dozensCounter = <span class="keyword">new</span> Dozens( incrementer );</span><br><span class="line"></span><br><span class="line">        incrementer.DoCount();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Number of dozens = &#123;0&#125;&quot;</span>, dozensCounter.DozensCount );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Number of dozens = 8</span><br></pre></td></tr></table></figure><h2 id="标准事件的用法"><a href="#标准事件的用法" class="headerlink" title="标准事件的用法"></a>标准事件的用法</h2><p>GUI 编程是事件驱动的，即程序运行时可以被事件打断，比如按钮点击或系统定时器。程序事件的异步 asynchronous 处理是使用 C# 事件的绝佳场景。.NET 框架提供一个标准模式，其基础就是 System 命名空间中声明的 <strong>EventHandler 委托类型</strong>。</p><p>EventHandler 委托类型的声明代码：<code>public delegate void EventHandler(object sender, EventArgs e);</code><br>①第一个参数用来保存触发事件的对象的引用，由于是 object 类型，可以匹配任何类型的实例；<br>②第二个参数用来保存状态信息，指明什么类型适用于该应用程序；<br>③返回类型为 void 。</p><p>EventHandler 委托类型的第二个参数是 <strong>EventArgs 类</strong>的对象，它声明在 System 命名空间中：<br>① EventArgs 不能传递任何数据，它用于不需要传递数据的事件处理程序；<br>②如果要传递数据，必须声明一个派生自 EventArgs 的类，并使用合适的字段来保存需要传递的数据。</p><p>EventArgs 类是使用 EventHandler 委托模式的重要部分。不管参数的实际类型是什么，object 和 EventArgs 类型的参数总是基类。这样 EventHandler 就能提供一个对所有事件和事件处理器都通用的签名，让所有事件都正好有两个参数。</p><p>以下代码修改了之前的 Incrementer，让它使用 EventHandler 委托，触发事件的代码在调用事件时必须使用适当的参数类型的对象：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发布者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Incrementer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CountedADozen; <span class="comment">//使用系统定义的EventHandler委托</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoCount</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++ )</span><br><span class="line">            <span class="keyword">if</span> ( i % <span class="number">12</span> == <span class="number">0</span> &amp;&amp; CountedADozen != <span class="literal">null</span> )</span><br><span class="line">                CountedADozen(<span class="keyword">this</span>, <span class="literal">null</span>); <span class="comment">//触发事件时使用EventHandler的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dozens</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> DozensCount &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dozens</span>(<span class="params"> Incrementer incrementer </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DozensCount = <span class="number">0</span>;</span><br><span class="line">        incrementer.CountedADozen += IncrementDozensCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IncrementDozensCount</span>(<span class="params"><span class="built_in">object</span> source, EventArgs e</span>) <span class="comment">//签名与委托的签名匹配</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        DozensCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Incrementer incrementer = <span class="keyword">new</span> Incrementer();</span><br><span class="line">        Dozens dozensCounter = <span class="keyword">new</span> Dozens( incrementer );</span><br><span class="line"></span><br><span class="line">        incrementer.DoCount();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Number of dozens = &#123;0&#125;&quot;</span>, dozensCounter.DozensCount );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过扩展-EventArgs-来传递数据"><a href="#通过扩展-EventArgs-来传递数据" class="headerlink" title="通过扩展 EventArgs 来传递数据"></a>通过扩展 EventArgs 来传递数据</h3><p>为了向自己的事件处理程序的第二个参数传入数据，需要声明一个派生自 EventArgs 的自定义类，用于保存我们需要传入的数据。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IncrementerEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> IterationCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//存储一个整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了一个自定义类，可以向事件处理程序的第二个参数传递数据，但需要一个使用新自定义类的委托类型，可以使用<strong>泛型版本的委托 generic version of delegate</strong>：EventHandler&lt;&gt;。详见第18章。要使用泛型委托，要将自定义类的名称放在尖括号内：<code>public event EventHandler&lt;IncrementerEventArgs&gt; CountedADozen;</code></p><p>以下代码更新了 Incrementer，使用了自定义类和泛型委托：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IncrementerEventArgs</span> : <span class="title">EventArgs</span> <span class="comment">//自定义类派生自EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> IterationCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">//存储一个整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Incrementer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;IncrementerEventArgs&gt; CountedADozen;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoCount</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IncrementerEventArgs args = <span class="keyword">new</span> IncrementerEventArgs(); <span class="comment">//创建自定义类实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++ )</span><br><span class="line">            <span class="keyword">if</span> ( i % <span class="number">12</span> == <span class="number">0</span> &amp;&amp; CountedADozen != <span class="literal">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                args.IterationCount = i;</span><br><span class="line">                CountedADozen( <span class="keyword">this</span>, args ); <span class="comment">//在触发事件时传递参数</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dozens</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> DozensCount &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dozens</span>(<span class="params"> Incrementer incrementer </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DozensCount = <span class="number">0</span>;</span><br><span class="line">        incrementer.CountedADozen += IncrementDozensCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">IncrementDozensCount</span>(<span class="params"> <span class="built_in">object</span> source, IncrementerEventArgs e </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Incremented at iteration: <span class="subst">&#123; e.IterationCount &#125;</span> in <span class="subst">&#123; source.ToString() &#125;</span>&quot;</span>);</span><br><span class="line">        DozensCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Incrementer incrementer = <span class="keyword">new</span> Incrementer();</span><br><span class="line">        Dozens dozensCounter = <span class="keyword">new</span> Dozens( incrementer );</span><br><span class="line"></span><br><span class="line">        incrementer.DoCount();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Number of dozens = <span class="subst">&#123; dozensCounter.DozensCount &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，Counter.Incrementer 的 Counter 是命名空间的名称：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Incremented at iteration: 12 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 24 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 36 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 48 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 60 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 72 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 84 in Counter.Incrementer</span><br><span class="line">Incremented at iteration: 96 in Counter.Incrementer</span><br><span class="line">Number of dozens = 8</span><br></pre></td></tr></table></figure><h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><p>可以利用 -= 运算符把事件处理程序从事件移除：<code>p.SimpleEvent -= s.MethodB;</code></p><p>实例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler SimpleEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseTheEvent</span>()</span> &#123; SimpleEvent( <span class="keyword">this</span>, <span class="literal">null</span> ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodA</span>(<span class="params"> <span class="built_in">object</span> o, EventArgs e </span>)</span> &#123; Console.WriteLine( <span class="string">&quot;AAA&quot;</span> ); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodB</span>(<span class="params"> <span class="built_in">object</span> o, EventArgs e </span>)</span> &#123; Console.WriteLine( <span class="string">&quot;BBB&quot;</span> ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Publisher p = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Subscriber s = <span class="keyword">new</span> Subscriber();</span><br><span class="line"></span><br><span class="line">        p.SimpleEvent += s.MethodA;</span><br><span class="line">        p.SimpleEvent += s.MethodB;</span><br><span class="line">        p.RaiseTheEvent();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine( <span class="string">&quot;\r\nRemove MethodB&quot;</span> );</span><br><span class="line">        p.SimpleEvent -= s.MethodB;</span><br><span class="line">        p.RaiseTheEvent();</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">AAA</span><br><span class="line">BBB</span><br><span class="line"></span><br><span class="line">Remove MethodB</span><br><span class="line">AAA</span><br></pre></td></tr></table></figure><h2 id="事件访问器-Event-Accessors"><a href="#事件访问器-Event-Accessors" class="headerlink" title="事件访问器 Event Accessors"></a>事件访问器 Event Accessors</h2><p>事件只允许 += 和 -= 运算符，但是我们可以修改这两个运算符的行为，让事件执行自定义的代码。由于是高级主题，这里只简单介绍。</p><p>要改变这两个运算符的操作，必须为事件定义<strong>事件访问器</strong>：<br>①有两个访问器：add 和 remove；<br>②声明事件的访问器看上去和声明属性差不多；</p><p>示例如下，两个访问器都有叫做 value 的隐式值参数，接受实例或静态方法的引用：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler CountedADozen</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">add</span></span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">//执行+=运算符的代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">remove</span></span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">//执行-=运算符的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明了事件访问器之后，事件不包含任何内嵌委托对象。必须实现自己的机制来存储和移除事件注册的方法。事件访问器表现为 void 方法，不能使用 return 语句返回值。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> C#读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> .net </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C#图解教程》读书笔记（一）</title>
      <link href="/2022/11/24/2022-11-24-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B1/"/>
      <url>/2022/11/24/2022-11-24-Csharp%E5%9B%BE%E8%A7%A3%E6%95%99%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇主要内容为：.NET 框架的简单介绍；C# 程序的基本构成；类型和变量基础；类和方法的基础；类的各种成员（深入理解类）；类的继承等等。<br>读书笔记仅为知识的记录，方便后续查找。<br>学习完成日期为2023年07月29日。  </p></blockquote><div  align="center">  <img src="https://s2.loli.net/2022/10/31/VLR94de6aqA3WPw.jpg" width = "80%" height = "80%" alt="C#图解教程"/></div><h1 id="第一章-C-和-NET框架"><a href="#第一章-C-和-NET框架" class="headerlink" title="第一章 C#和.NET框架"></a>第一章 C#和.NET框架</h1><h2 id="NET框架的组成"><a href="#NET框架的组成" class="headerlink" title=".NET框架的组成"></a>.NET框架的组成</h2><p>.NET框架（.NET Framework）由三个部分组成：</p><div  align="center">  <img src="https://s2.loli.net/2022/10/31/sjP4eQIFqxNv65C.png" width = "30%" height = "30%" alt="图1 - .NET框架的组成"/></div><p>执行环境称为<strong>CLR</strong>（Common Language Runtime 公共语言运行库）；CLR管理程序的执行，包括内存管理和垃圾收集（GC garbage collector 垃圾收集器）；代码安全验证；代码执行、线程管理及异常处理。</p><p>严格来说，.NET框架由<strong>CLR</strong>和<strong>FCL</strong>（Framework Class Library 框架类库）组成，FCL是BCL的超集。</p><p><strong>BCL</strong>（Base Class Library 基类库）是.NET框架使用的一个大的类库。包括通用基础类：比如文件操作、字符串操作、安全和加密；集合类：实现了列表、字典、散列表（hash tables）以及位数组（bit arrays）；线程和同步类：用于创建多线程程序；XML类：用于创建、读取及操作XML文档。</p><blockquote><p>以下内容摘《C#播放器指南》一书。  </p><p>BCL包含所有的内置类型、数组、异常、数学库、基本文件I/O、安全性、集合、反射、联网、字符串操作、线程等等。一般规则是任何以System开头的名称空间都是BCL的一部分。</p><p>除了BCL之外，微软还随.NET框架提供了更多的类。通常，这些附加内容涵盖了广泛的功能领域，例如数据库访问或图形用户界面(Windows窗体或WPF)。包括BCL在内的整个集合被称为框架类库FCL。</p></blockquote><h2 id="编译为CIL"><a href="#编译为CIL" class="headerlink" title="编译为CIL"></a>编译为CIL</h2><p>.NET语言的解释器接受源代码文件，并生成名为<strong>程序集Assembly</strong>的输出文件：</p><div  align="center">  <img src="https://s2.loli.net/2022/10/31/Q9dpN3izqSuKmGD.png" width = "45%" height = "45%" alt="图2 - 编译过程"/></div><p><strong>程序集</strong>中的代码不是本机代码，而是<strong>CIL</strong>（Common Intermediate Language 公共中间语言）</p><p>程序集的信息中包括：程序的CIL；程序中使用的类型的元数据（Metadata）；对其他程序集引用的元数据。</p><h2 id="编译成本机代码（Native-Code）并执行"><a href="#编译成本机代码（Native-Code）并执行" class="headerlink" title="编译成本机代码（Native Code）并执行"></a>编译成本机代码（Native Code）并执行</h2><p>程序的CIL直到被调用运行时才会被编译成本机代码。在运行时，CLR执行以下步骤：<br>（1）检查程序集的安全特性；<br>（2）在内存中分配空间；<br>（3）把程序集中的可执行代码发给即时编译器（just-in-time JIT compiler），把其中一部分编译成本机代码。</p><div  align="center">  <img src="https://s2.loli.net/2022/10/31/AtdGz26FTm4voMn.png" width = "40%" height = "40%" alt="图3 - 运行时被编译成本机代码"/></div><p>程序集中的可执行代码只有在被需要时由JIT编译器编译，然后就被缓存cache起来以备在后来的程序中执行。这意味着不被调用的代码不会被编译成本机代码，而且被调用到的代码只被编译一次。</p><p>一旦CIL被编译成本机代码，CLR就在运行时管理它，执行如释放无主内存、检查参数类型、管理异常等任务。在CLR控制之下的代码称为托管代码（managed code）；而不在CLR控制之下运行的代码为非托管代码。</p><h2 id="CLR"><a href="#CLR" class="headerlink" title="CLR"></a>CLR</h2><p>.NET框架的核心组件是<strong>CLR</strong>，它在操作系统顶层，负责管理程序的执行：</p><div  align="center">  <img src="https://s2.loli.net/2022/11/01/iltGr4vmNuyMsA1.png" width = "50%" height = "50%" alt="图4 - CLR概览"/></div><p>CLR还通过访问BCL得到广泛的编程功能，包括如Web服务和数据服务之类的功能。</p><h2 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h2><p>每种编程语言都有一组内置的类型，包括整数、浮点数和字符等对象。但是这些类型因为编程语言和平台的不同而不同，这种缺乏统一性需要一组标准促进有序协作。</p><p><strong>CLI</strong>（Common Language Infrastructure 公共语言基础结构）就是一组标准，它把.NET框架的所有组件连结成了一个系统。</p><div  align="center">  <img src="https://s2.loli.net/2022/11/01/Qq9xHIoUvszDgZh.png" width = "55%" height = "55%" alt="图5 - CLI组成"/></div><ol><li><p>公共类型系统<br><strong>CTS</strong>（Common Type System 公共类型系统），它定义了一组内置类型；.NET兼容编程语言提供的类型通常映射到CTS已定义的内置类型集的某个特殊子集；<strong><em>CTS让所有类型都继承自公共的基类——object</em></strong>；CTS确保用户定义的类型和系统类型能够被任何.NET兼容的语言使用。</p></li><li><p>公共语言规范<br><strong>CLS</strong>（Common Language Specification 公共语言规范）详细说明了.NET兼容编程语言的规则、属性和行为，包括数据类型、类结构和参数传递）。</p></li></ol><h1 id="第二章-C-和-NET-Core"><a href="#第二章-C-和-NET-Core" class="headerlink" title="第二章 C#和.NET Core"></a>第二章 C#和.NET Core</h1><h2 id="NET-Core的由来"><a href="#NET-Core的由来" class="headerlink" title=".NET Core的由来"></a>.NET Core的由来</h2><p>为了更好地解决Web开发以及Linux或macOS的开发，微软用.NET框架搭建了一个基于云的、跨平台的、开源衍生产品，这个新框架即 <strong>.NET Core</strong>。微软也收购了Xamarin以解决Android和IOS等移动平台的开发问题。</p><div  align="center">  <img src="https://s2.loli.net/2022/11/01/UBiFr2XZNK4nJuE.png" width = "70%" height = "70%" alt="图6 - .NET生态系统"/></div><p>.NET Core主要目标为多平台支持；快速开发和升级；更小的应用程序占用空间；更简单的部署；更少的版本问题；开源社区的支持；改进的应用程序性能。</p><h1 id="第三章-C-编程概述"><a href="#第三章-C-编程概述" class="headerlink" title="第三章 C#编程概述"></a>第三章 C#编程概述</h1><h2 id="一个简单的C-程序"><a href="#一个简单的C-程序" class="headerlink" title="一个简单的C#程序"></a>一个简单的C#程序</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Simple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span>   <span class="comment">// declare a class</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hi there!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行1 ：告诉编译器这个程序使用<strong>System命名空间</strong>的类型；<br>行3 ：声明新的名为<strong>Simple的命名空间</strong>，在这部分声明的任何类型都是该命名空间的成员（第4行到第12行）；<br>行5 ：声明新的名为<strong>Program的类类型</strong>，在这部分声明的任何成员都是组成这个类的成员（第6行到第11行）；<br>行7 ：声明一个名称为<strong>Main的方法</strong>作为<strong>类Program</strong>的成员，<strong>Main是一个特殊函数</strong>，编译器用它作为程序的起始点；<br>行9 ：包含了一条简单的语句，组成了<strong>Main的方法</strong>：简单语句以一个分号结束，这条语句使用<strong>命名空间System</strong>中的一个名为<strong>Console的类</strong>将消息输出到屏幕窗口，若没有第一条的<strong>using语句</strong>，编译器就不知道在哪里寻找<strong>类Console</strong>。</p><p><em>C#程序由一个或多个类型声明组成，命名空间是与某个名称相关联的一组类型声明</em>。上述代码创建了一个名称为Simple的新命名空间，并在其中声明了其类型（类Program），还使用了System命名空间中定义的Console类。</p><blockquote><p><strong><em>补充 ：使用 Visual Studio Code 创建 .NET 控制台应用程序（摘自官方.NET文档）</em></strong></p><p><strong>先决条件</strong>：.NET 7 SDK以及已安装 C# 扩展 的 Visual Studio Code</p><p><strong>创建应用</strong>：<br>1、在合适位置创建文件夹，并打开vscode打开该文件夹。默认情况下，文件夹名称将是项目名称和命名空间名称；<br>2、在vscode中选择Terminal - New Terminal；<br>3、在“终端”中输入以下命令：<code>dotnet new console --framework net7.0</code>；（注意7.0根据 .NET 版本修改）<br>4、此时创建了一个在控制台窗口中显示“Hello World”的简单应用程序：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>首次创建程序时，Visual Studio Code 会提示添加缺少的资产，以生成和调试应用。 选择“是”，Visual Studio Code 会创建一个包含“launch.json”和“tasks.json”文件的“.vscode”文件夹。</p><div  align="center">  <img src="https://s2.loli.net/2022/11/04/qmQSHOwfJIvMb8Y.png" width = "55%" height = "55%"/></div><p>如果未收到提示，或者意外将其关闭而未选择“是”，可以按如下操作步骤：</p><div  align="center">  <img src="https://s2.loli.net/2022/11/04/PtDE7zaYQeFGokC.png" width = "35%" height = "35%"/></div><p>也可以从菜单中选择Run - Add Configurations，在“选择环境”提示符下，选择“.NET 5+ 和 .NET Core”。<br>总之最后要见到 .vscode 中的 launch.json 和 tasks.json 文件。</p><p><strong>运行应用</strong>：<br>在“终端”中运行以下命令：<code>dotnet run</code><br>程序显示“Hello World!”并终止。</p></blockquote><h2 id="标识符-Identifiers"><a href="#标识符-Identifiers" class="headerlink" title="标识符 Identifiers"></a>标识符 Identifiers</h2><p><strong>标识符</strong>是用于命名的字符串。  </p><p>某些字符能否在标识符的特定位置出现是有规定的：</p><ul><li>字母和下划线可以出现在任何位置；</li><li>数字不能放在首字母，但可以出现在其他任何位置；</li><li>@字符只能放在标识符的首位，不推荐将@作为常用字符。</li></ul><p>标识符区分大小写，比如变量名myVar和MyVar是不同的标识符。第8章将介绍推荐的C#命名约定。</p><h2 id="关键字-Keywords"><a href="#关键字-Keywords" class="headerlink" title="关键字 Keywords"></a>关键字 Keywords</h2><p><strong>关键字</strong>不能作为标识符，除非以@字符开始。<br>所有C#关键字全部都以小写字母组成。</p><p><em>表：C#关键字</em></p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">abstract</td><td style="text-align:left">const</td><td style="text-align:left">extern</td><td style="text-align:left">int</td><td style="text-align:left">out</td><td style="text-align:left">short</td><td style="text-align:left">typeof</td></tr><tr><td style="text-align:left">as</td><td style="text-align:left">continue</td><td style="text-align:left">false</td><td style="text-align:left">interface</td><td style="text-align:left">override</td><td style="text-align:left">sizeof</td><td style="text-align:left">uint</td></tr><tr><td style="text-align:left">base</td><td style="text-align:left">decimal</td><td style="text-align:left">finally</td><td style="text-align:left">internal</td><td style="text-align:left">params</td><td style="text-align:left">stackalloc</td><td style="text-align:left">ulong</td></tr><tr><td style="text-align:left">bool</td><td style="text-align:left">default</td><td style="text-align:left">fixed</td><td style="text-align:left">is</td><td style="text-align:left">private</td><td style="text-align:left">static</td><td style="text-align:left">unchecked</td></tr><tr><td style="text-align:left">break</td><td style="text-align:left">delegate</td><td style="text-align:left">float</td><td style="text-align:left">lock</td><td style="text-align:left">protected</td><td style="text-align:left">string</td><td style="text-align:left">unsafe</td></tr><tr><td style="text-align:left">byte</td><td style="text-align:left">do</td><td style="text-align:left">for</td><td style="text-align:left">long</td><td style="text-align:left">public</td><td style="text-align:left">struct</td><td style="text-align:left">ushort</td></tr><tr><td style="text-align:left">case</td><td style="text-align:left">double</td><td style="text-align:left">foreach</td><td style="text-align:left">namespace</td><td style="text-align:left">readonly</td><td style="text-align:left">switch</td><td style="text-align:left">using</td></tr><tr><td style="text-align:left">catch</td><td style="text-align:left">else</td><td style="text-align:left">goto</td><td style="text-align:left">new</td><td style="text-align:left">ref</td><td style="text-align:left">this</td><td style="text-align:left">virtual</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">enum</td><td style="text-align:left">if</td><td style="text-align:left">null</td><td style="text-align:left">return</td><td style="text-align:left">throw</td><td style="text-align:left">void</td></tr><tr><td style="text-align:left">checked</td><td style="text-align:left">event</td><td style="text-align:left">implicit</td><td style="text-align:left">object</td><td style="text-align:left">sbyte</td><td style="text-align:left">true</td><td style="text-align:left">volatile</td></tr><tr><td style="text-align:left">class</td><td style="text-align:left">explicit</td><td style="text-align:left">in</td><td style="text-align:left">operator</td><td style="text-align:left">sealed</td><td style="text-align:left">try</td><td style="text-align:left">when while</td></tr></tbody></table></div><p><strong>上下文关键字 Contextual Keywords</strong>是仅在特定的语言结构中充当关键字的标识符，上下文关键字可以在代码的其他部分被用作标识符。</p><p><em>表：C#的上下文关键字</em></p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">add</td><td style="text-align:left">ascending</td><td style="text-align:left">async</td><td style="text-align:left">await</td><td style="text-align:left">by</td><td style="text-align:left">descending</td><td style="text-align:left">dynamic</td></tr><tr><td style="text-align:left">equals</td><td style="text-align:left">from</td><td style="text-align:left">get</td><td style="text-align:left">global</td><td style="text-align:left">group</td><td style="text-align:left">in</td><td style="text-align:left">into</td></tr><tr><td style="text-align:left">join</td><td style="text-align:left">let</td><td style="text-align:left">on</td><td style="text-align:left">orderby</td><td style="text-align:left">partial</td><td style="text-align:left">remove</td><td style="text-align:left">select</td></tr><tr><td style="text-align:left">set</td><td style="text-align:left">value</td><td style="text-align:left">var</td><td style="text-align:left">where</td><td style="text-align:left">yield</td><td style="text-align:left"></td></tr></tbody></table></div><h2 id="Main：程序的起始点"><a href="#Main：程序的起始点" class="headerlink" title="Main：程序的起始点"></a>Main：程序的起始点</h2><p>每个C#程序必须有一个类带有<strong>Main方法(函数)</strong>。</p><ul><li>每个C#程序的可执行起始点在Main中的第一条指令；</li><li>Main必须首字母大写。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空白-Whitespace"><a href="#空白-Whitespace" class="headerlink" title="空白 Whitespace"></a>空白 Whitespace</h2><p>程序中的空白指没有可视化输出的字符。在源代码中使用的空白会被编译器忽略。</p><p>空白字符包括：空格(Space)；制表符(Tab)；换行符(New line)；回车符(Carriage return)</p><p>比如，下面的代码会被编译器同等对待：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Main()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hi, there!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 连在一起</span></span><br><span class="line">Main()&#123;Console.WriteLine(<span class="string">&quot;Hi, there!&quot;</span>);&#125;</span><br></pre></td></tr></table></figure><h2 id="语句-Statements"><a href="#语句-Statements" class="headerlink" title="语句 Statements"></a>语句 Statements</h2><p>此处为简单介绍，详细见第10章。</p><p><strong>简单语句</strong>以一个<strong>分号</strong>结束，下面的代码即2条简单语句组成的序列：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> var1 = <span class="number">5</span>;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;The value of var1 is &#123;0&#125;&quot;</span>, var1);</span><br></pre></td></tr></table></figure></p><h2 id="块-Blocks"><a href="#块-Blocks" class="headerlink" title="块 Blocks"></a>块 Blocks</h2><p><strong>块</strong>是一个由成对大括号包围的0条或多条语句序列，它在语法上相当于一条语句。<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> var1 = <span class="number">5</span>;</span><br><span class="line">    System.Console.WriteLine(<span class="string">&quot;The value of var1 is &#123;0&#125;&quot;</span>, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>语法上只需要一条语句，若需要执行的动作无法用一条简单语句表达时，考虑用块；<br>有些特定的程序结构只能使用块；<br>简单语句以分号结束，块后面不跟分号。</p><h2 id="从程序中输出文本"><a href="#从程序中输出文本" class="headerlink" title="从程序中输出文本"></a>从程序中输出文本</h2><p><strong>控制台窗口console window</strong>是一种简单的命令提示窗口。BCL提供了一个名为Console的类（在System命名空间中），该类包含了讲数据输入和输出到控制台窗口的方法。</p><h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p>Write是Console类的成员，示例：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">System.Console.Write (<span class="string">&quot;This is text1. &quot;</span>);</span><br><span class="line">System.Console.Write (<span class="string">&quot;This is text2. &quot;</span>);</span><br><span class="line">System.Console.Write (<span class="string">&quot;This is text3. &quot;</span>);</span><br></pre></td></tr></table></figure></p><p>在控制台窗口输出如下：<br><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">This is text1. This is text2. This is text3.</span><br></pre></td></tr></table></figure></p><p>注意：Write没有在字符串后面添加换行符，所以三个语句都输出在同一行。</p><h3 id="WriteLine"><a href="#WriteLine" class="headerlink" title="WriteLine"></a>WriteLine</h3><p>WriteLine也是Console类的成员，但会在每个输出字符串的结尾添加一个换行符。</p><p>上面的代码用WriteLine替换掉Write，输出会变为多行：<br><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">This is text1.</span><br><span class="line">This is text2.</span><br><span class="line">This is text3.</span><br></pre></td></tr></table></figure></p><h3 id="格式字符串-The-Format-String"><a href="#格式字符串-The-Format-String" class="headerlink" title="格式字符串 The Format String"></a>格式字符串 The Format String</h3><p>Write或WriteLine语句可以有一个以上的参数，格式如下：<br><code>Console.WriteLine( FormatString, SubVal0, SubVal1, SubVal2, ... );</code></p><p>第一个参数必须总是字符串，称为<strong>格式字符串</strong>；格式字符串可以包括<strong>代替标记Substitution markers</strong>。代替标记包含大括号和一个整数，整数就是替换值的数字位置。</p><p>例如：下面的语句有2个替代标记，{0}和{1}；以及2个替换值，即3和6。<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;Two sample integers are &#123;0&#125; and &#123;1&#125;.&quot;</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></p><p>C# 6.0 还引入了<strong>字符串插值string interpolation</strong>，前提是前面加上$符号：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> var1 = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">int</span> var2 = <span class="number">6</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Two sample integers are <span class="subst">&#123;var1&#125;</span> and <span class="subst">&#123;var2&#125;</span>.&quot;</span>);</span><br></pre></td></tr></table></figure></p><h3 id="多重标记和值"><a href="#多重标记和值" class="headerlink" title="多重标记和值"></a>多重标记和值</h3><p>可以使用任意数量的替代标记和任意数量的值，比如：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;Three integers are &#123;1&#125;, &#123;0&#125; and &#123;1&#125;.&quot;</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></p><p>但标记不能引用超出替换值列表长度的值，如果引用，不会产生编译错误compile error，但会产生运行错误runtime error（称为<strong>异常exception</strong>）。比如：<code>Console.WriteLine(&quot;Two integers are &#123;0&#125; and &#123;2&#125;.&quot;, 3, 6);</code>中位置2不存在，3是位置0，6是位置1。</p><h3 id="格式化数字字符串"><a href="#格式化数字字符串" class="headerlink" title="格式化数字字符串"></a>格式化数字字符串</h3><p>指定数字格式，例如：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;The value: &#123;0&#125;.&quot;</span> , <span class="number">500</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;The value: &#123;0:C&#125;.&quot;</span>, <span class="number">500</span>); <span class="comment">// 格式化为货币</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> myInt = <span class="number">500</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;The value: <span class="subst">&#123;myInt&#125;</span>.&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;The value: <span class="subst">&#123;myInt:C&#125;</span>.&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>上述2种代码，都在控制台窗口产生同样输出：<br><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">The value: 500.</span><br><span class="line">The value: ￥500.00.</span><br></pre></td></tr></table></figure></p><p>大括号内的<strong>格式说明符format specifier</strong>的语法由三个字段fields组成：<strong>索引号index或者字符串插值变量string interpolation variable</strong>、<strong>对齐说明符alignment specifier</strong>和<strong>格式字段format field</strong>。</p><p>语法为：<code>&#123; index,alignment:format &#125;</code></p><p><em>index或string interpolation</em>：必需项，指定列表中的某一项；<br><em>alignment</em>：可选，指定字段宽度，以及是否是左对齐或是右对齐；<br><em>format</em>：可选，指定项的格式。<br><em>注意</em>：对齐前面是逗号，格式前面是冒号。</p><p><strong><em>（1）对齐说明符</em></strong><br>由一个正整数或者负整数组成：<em>整数表示字段使用字符的最少数量</em>；符号表示右对齐或左对齐，<em>正数表示右对齐，负数表示左对齐</em>。<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> myInt = <span class="number">500</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;|&#123;0, 10&#125;|&quot;</span>, myInt); <span class="comment">// 右对齐Aligned right</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;|&#123;0,-10&#125;|&quot;</span>, myInt); <span class="comment">// 左对齐Aligned left</span></span><br></pre></td></tr></table></figure></p><p>输出如下，在两个竖杠的中间有10个字符：<br><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">|       500|</span><br><span class="line">|500       |</span><br></pre></td></tr></table></figure></p><p><em>如果要表示的字符数比对齐说明符指定的字符数少，那么其余字符会使用空格填充</em>；<br><em>如果要表示的字符数多于指定的字符数，对齐说明符会被忽略，并且使用所需的字符进行表示</em>。</p><p><strong><em>（2）格式字段</em></strong><br>格式字段有三部分，①<strong>冒号</strong>后面必须紧跟格式说明符，中间不能有空格；②<strong>格式说明符format specifier</strong>是一个字母字符，是9个内置字符格式之一，可以是大写或者小写；③<strong>精度说明符precision specifier</strong>是可选的，由1~2位数字组成，实际意义取决于格式说明符。</p><p>语法为：<code>:Axx</code>，A为格式说明符，xx为精度说明符。<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> myDouble = <span class="number">12.345678</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0,-10:G&#125; -- General&quot;</span>, myDouble);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0,-10&#125; -- Default, same as General&quot;</span>, myDouble);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0,-10:F4&#125; -- Fixed Point, 4 dec places&quot;</span>, myDouble);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0,-10:C&#125; -- Currency&quot;</span>, myDouble);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0,-10:E3&#125; -- Sci. Notation, 3 dec places&quot;</span>, myDouble);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0,-10:x&#125; -- Hexadecimal integer&quot;</span>, <span class="number">1194719</span> );</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">12.345678  -- General</span><br><span class="line">12.345678  -- Default, same as General</span><br><span class="line">12.3457    -- Fixed Point, 4 dec places</span><br><span class="line">￥12.35     -- Currency</span><br><span class="line">1.235E+001 -- Sci. Notation, 3 dec places</span><br><span class="line">123adf     -- Hexadecimal integer</span><br></pre></td></tr></table></figure></p><p><strong><em>（3）标准数字格式说明符</em></strong><br>9种标准数字格式说明符，若说明符会根据大小写会有不同输出，会标注为区分大小写。</p><div class="table-container"><table><thead><tr><th style="text-align:left">名字和字符</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">货币Currency<br>C、c</td><td style="text-align:left">使用货币符号，货币符号取决于程序所在PC的区域设置<br>精度说明符：小数位数<br>示例：<code>Console.WriteLine(&quot;&#123;0 :C&#125;&quot;, 12.5);</code><br>输出：￥12.50</td></tr><tr><td style="text-align:left">十进制数Decimal<br>D、d</td><td style="text-align:left">十进制数字字符串，可以有负数符号。只能和整数类型配合使用<br>精度说明符：输出字符串的最小位数，若实际数字位数少，则左边以0填充<br>示例：<code>Console.WriteLine(&quot;&#123;0 :D4&#125;&quot;, 12);</code><br>输出：0012</td></tr><tr><td style="text-align:left">定点Fixed-point<br>F、f</td><td style="text-align:left">带有小数点的十进制数字字符串，可以有负数符号。<br>精度说明符：小数位数<br>示例：<code>Console.WriteLine(&quot;&#123;0 :F4&#125;&quot;, 12.3456789);</code><br>输出：12.3457</td></tr><tr><td style="text-align:left">常规General<br>G、g</td><td style="text-align:left">在没有指定说明符的情况下，会根据值转换为定点或科学计数法表示的形式<br>精度说明符：根据值的情况<br>示例：<code>Console.WriteLine(&quot;&#123;0 :G4&#125;&quot;, 12.3456789);</code><br>输出：12.35</td></tr><tr><td style="text-align:left">十六进制数Hexadecimal<br>X、x<br>区分大小写</td><td style="text-align:left">十六进制数字字符串。A~F会匹配说明符的大小写<br>精度说明符：输出字符串的最小位数，若实际数字位数少，则左边以0填充<br>示例：<code>Console.WriteLine(&quot;&#123;0 :x&#125;&quot;, 180026);</code><br>输出：2bf3a</td></tr><tr><td style="text-align:left">数字Number<br>N、n</td><td style="text-align:left">和定点表示法相似，但是每3个数字的一组中间有逗号或空格分隔符，使用哪个看程序所在PC的区域设置<br>精度说明符：小数位数<br>示例：<code>Console.WriteLine(&quot;&#123;0 :N2&#125;&quot;, 12345678.54321);</code><br>输出：12,345,678.54</td></tr><tr><td style="text-align:left">百分比Percent<br>P、p</td><td style="text-align:left">表示百分比的字符串，数字会乘以100<br>精度说明符：小数位数<br>示例：<code>Console.WriteLine(&quot;&#123;0 :P2&#125;&quot;, 0.1221897);</code><br>输出：12.22%</td></tr><tr><td style="text-align:left">往返过程Round-trip<br>R、r</td><td style="text-align:left">保证输出字符串后如果使用Parse方法将字符串转化为数字，Parse方法在第27章<br>精度说明符：忽略<br>示例：<code>Console.WriteLine(&quot;&#123;0 :R&#125;&quot;, 1234.21897);</code><br>输出：1234.21897</td></tr><tr><td style="text-align:left">科学计数法Scientific<br>E、e<br>区分大小写</td><td style="text-align:left">具有尾数和指数的科学计数法，e的大小写和说明符一致<br>精度说明符：小数位数<br>示例：<code>Console.WriteLine(&quot;&#123;0 :e4&#125;&quot;, 12.3456789);</code><br>输出：1.2346e+001</td></tr></tbody></table></div><h2 id="注释：为代码添加注解-Comments-Annotating-the-Code"><a href="#注释：为代码添加注解-Comments-Annotating-the-Code" class="headerlink" title="注释：为代码添加注解 Comments: Annotating the Code"></a>注释：为代码添加注解 Comments: Annotating the Code</h2><p><strong>单行注释 Single-line comments</strong> ：<code>//</code>，注释范围一直到行结束都有效。</p><p><strong>带分隔符的注释 Delimited comments</strong> ：开始标记<code>/*</code>和结束标记<code>*/</code>，带分隔符的注释可以跨越多行，或者只包括行的一部分。注释范围一直到第一个结束分隔符都有效。</p><p><strong>文档注释 Documentation Comments</strong> ：<code>///</code>，在第27章阐述。文档注释包括XML文档，可以用于产生程序文档。</p><h1 id="第四章-类型、存储和变量"><a href="#第四章-类型、存储和变量" class="headerlink" title="第四章 类型、存储和变量"></a>第四章 类型、存储和变量</h1><h2 id="C-程序是一组类型声明"><a href="#C-程序是一组类型声明" class="headerlink" title="C#程序是一组类型声明"></a>C#程序是一组类型声明</h2><p>C程序是一组函数和数据类型，C++程序是一组函数和类，C#程序或DLL是一组类型声明。</p><p>(1) 类型声明中必须有一个包含<strong>Main方法</strong>的类；<br>(2) <strong>命名空间</strong>将相关的类型声明分组并命名，所以在命名空间内声明程序类型。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyProgram</span> <span class="comment">// Declare a namespace，名为MyProgram.</span></span><br><span class="line">&#123;</span><br><span class="line">    DeclarationOfTypeA <span class="comment">// Declare a type.</span></span><br><span class="line">    DeclarationOfTypeB <span class="comment">// Declare a type.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">C</span> <span class="comment">// Declare a type.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名空间在第22章详细阐述。</p><h2 id="类型是一种模板"><a href="#类型是一种模板" class="headerlink" title="类型是一种模板"></a>类型是一种模板</h2><p>类型可以理解为一个创建数据结构的模板。类型具有以下元素：名称、用于保存的数据结构、一些行为和约束条件。</p><p>比如：short类型，名称是short，结构是2字节，行为是16位整数。int类型，名称是int，结构是4字节，行为是32位整数。</p><h2 id="实例化类型-Instantiating-a-Type"><a href="#实例化类型-Instantiating-a-Type" class="headerlink" title="实例化类型 Instantiating a Type"></a>实例化类型 Instantiating a Type</h2><p>从类型模板创建对象，即<strong>实例化</strong>该类型。</p><p>通过实例化类型而创建的对象被称为类型的<strong>对象</strong>或类型的<strong>实例</strong>。这2术语可以互换。</p><h2 id="数据成员和函数成员"><a href="#数据成员和函数成员" class="headerlink" title="数据成员和函数成员"></a>数据成员和函数成员</h2><p><strong>简单类型</strong>如short、int和long，只能存储一个数据项；<br>数组类型（array）可以存储多个同类型的数据项，这些数据项即<strong>数组元素</strong>。</p><p>然而有些类型可以包含不同类型的数据项，这些数据项被称为<strong>成员 members</strong>，包括<strong>数据成员</strong>和<strong>函数成员</strong>：<strong>数据成员</strong>保存了与这个类的对象或整个类相关数据；<strong>函数成员</strong>执行代码，定义类型的行为。</p><h2 id="预定义类型"><a href="#预定义类型" class="headerlink" title="预定义类型"></a>预定义类型</h2><p>C#有16种预定义类型，包括13种<strong>简单类型</strong>和3种<strong>非简单类型</strong>。所有预定义类型的名称都是小写。</p><p>简单类型可以分为3类：<br>(1) 11种数值类型：<br>&ensp;&ensp;&ensp;- 不同长度的有符号和无符号<em>整数类型</em>；<br>&ensp;&ensp;&ensp;- <em>浮点数类型</em>float和double；<br>&ensp;&ensp;&ensp;- <em>高精度小数类型</em>decimal，与float和double不同，decimal类型可以表示分数，常用于货币计算。<br>(2) <em>Unicode字符类型</em>char；<br>(3) <em>布尔类型</em>bool，即true和false。  </p><p>3种非简单类型为：<br>(1) string，一个Unicode字符数组；<br>(2) object，所有类型的基类；<br>(3) dynamic，使用动态语言编写的程序集使用。  </p><div  align="center">  <img src="https://s2.loli.net/2022/11/16/pKUunxX9i5ayjqt.png" width = "60%" height = "60%" alt="图9 - 预定义类型"/></div><p>所有预定义类型都映射到底层的.NET类型。<em>预定义简单类型</em>都表示一个单一的数据项，如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">含义</th><th style="text-align:left">范围</th><th style="text-align:left">.NET框架类型</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">sbyte</td><td style="text-align:left">8-bit signed integer</td><td style="text-align:left">-128 to 127</td><td style="text-align:left">System.SByte</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">byte</td><td style="text-align:left">8-bit unsigned integer</td><td style="text-align:left">0 to 255</td><td style="text-align:left">System.Byte</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">16-bit signed integer</td><td style="text-align:left">-32,768 to 32,767</td><td style="text-align:left">System.Int16</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">ushort</td><td style="text-align:left">16-bit unsigned integer</td><td style="text-align:left">0 to 65,535</td><td style="text-align:left">System.UInt16</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">32-bit signed integer</td><td style="text-align:left">-2,147,483,648 to 2,147,483,647</td><td style="text-align:left">System.Int32</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">uint</td><td style="text-align:left">32-bit unsigned integer</td><td style="text-align:left">0 to 4,294,967,295</td><td style="text-align:left">System.UInt32</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">64-bit signed integer</td><td style="text-align:left">-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td><td style="text-align:left">System.Int64</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">ulong</td><td style="text-align:left">64-bit unsigned integer</td><td style="text-align:left">0 to 18,446,744,073,709,551,615</td><td style="text-align:left">System.UInt64</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">Single-precision float</td><td style="text-align:left">1.5×10^-45 to 3.4×10^38</td><td style="text-align:left">System.Single</td><td style="text-align:left">0.0f</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">Double-precision float</td><td style="text-align:left">5×10^-324 to 1.7×10^308</td><td style="text-align:left">System.Double</td><td style="text-align:left">0.0d</td></tr><tr><td style="text-align:left">bool</td><td style="text-align:left">Boolean</td><td style="text-align:left">true, false</td><td style="text-align:left">System.Boolean</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">Unicode character</td><td style="text-align:left">U+0000 to U+ffff</td><td style="text-align:left">System.Char</td><td style="text-align:left">\x0000</td></tr><tr><td style="text-align:left">decimal</td><td style="text-align:left">Decimal value with 28-significant-digit precision</td><td style="text-align:left">±1.0×10^28 to ±7.9×10^28</td><td style="text-align:left">System.Decimal</td><td style="text-align:left">0m</td></tr></tbody></table></div><p><em>预定义非简单类型</em>，如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">含义</th><th style="text-align:left">.NET框架类型</th></tr></thead><tbody><tr><td style="text-align:left">object</td><td style="text-align:left">所有其他类型的基类，包括简单类型</td><td style="text-align:left">System.Object</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">0个或多个Unicode字符组成的序列</td><td style="text-align:left">System.String</td></tr><tr><td style="text-align:left">dynamic</td><td style="text-align:left">在使用动态语言编写的程序集assemblies时使用</td><td style="text-align:left">无相应的 .NET type</td></tr></tbody></table></div><h2 id="用户定义类型"><a href="#用户定义类型" class="headerlink" title="用户定义类型"></a>用户定义类型</h2><p>C#有16种预定义类型，另外还有6种类型可以由用户自己创建：<br><em>类类型 class</em>；<em>结构类型 struct</em>；<em>数组类型 array</em>；<em>枚举类型 enum</em>；<em>委托类型 delegate</em>；<em>接口类型 interface</em>。</p><p>类型通过<strong>类型声明type declaration</strong>创建。</p><p>预定义类型直接实例化对象即可；用户定义类型要先声明类型，然后实例化该类型对象。</p><h2 id="栈和堆-The-Stack-and-the-Heap"><a href="#栈和堆-The-Stack-and-the-Heap" class="headerlink" title="栈和堆 The Stack and the Heap"></a>栈和堆 The Stack and the Heap</h2><p>运行中的程序使用两个内存区域来存储数据：栈和堆。</p><h3 id="栈-The-Stack"><a href="#栈-The-Stack" class="headerlink" title="栈 The Stack"></a>栈 The Stack</h3><p><strong>栈</strong>是一个内存数组，是一个<strong>LIFO</strong>（后进先出）的数据结构。</p><p>数据只能从栈的顶端插入和删除；把数据放到栈顶称为<strong>入栈push</strong>；从栈顶删除数据称为<strong>出栈pop</strong>。</p><h3 id="堆-The-Heap"><a href="#堆-The-Heap" class="headerlink" title="堆 The Heap"></a>堆 The Heap</h3><p><strong>堆</strong>是一块内存区域，堆里的内存能够以任意顺序存入和移除。</p><p>虽然程序可以在堆里保存数据，但是不能显示地删除它们。CLR的自动垃圾收集器在判断出程序代码不会再访问某数据项时，会自动清理无主对象。</p><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>数据项的类型定义了存储需要的内存大小及组成该类型的数据成员，也决定了对象在内存的存储位置——栈或堆。</p><p>类型分为<strong>值类型value types</strong>和<strong>引用类型reference types</strong>：<br><em>值类型</em>只需要一段单独的内存，数据存放在栈中；<br><em>引用类型</em>需要两端内存：第一段存储实际的数据，位于堆中。第二段是一个<em>引用</em>，指向数据在堆存放的位置，而引用存放在栈中。</p><div  align="center">  <img src="https://s2.loli.net/2022/11/17/yelvL6bXRMFCacG.png" width = "70%" height = "70%" alt="图10 - 非成员数据的存储"/></div><h3 id="存储引用类型对象的成员"><a href="#存储引用类型对象的成员" class="headerlink" title="存储引用类型对象的成员"></a>存储引用类型对象的成员</h3><p>上图是当数据不是另一个对象的成员的存储方式。若数据是另一对象的成员，会有些不同。</p><p>假设一个引用类型的实例，名为MyType，包括2个成员：一个值类型成员A和一个引用类型成员B。 </p><p>对于一个引用类型，其实例的数据部分始终存放在堆中，二个成员都是对象数据的一部分，即都会存放在堆中，无论是值类型还是引用类型。即，引用类型B的数据和引用部分都存放在堆里；值类型A也在堆里。</p><div  align="center">  <img src="https://s2.loli.net/2022/11/17/tdWgnr78DFyScLx.png" width = "50%" height = "50%" alt="图11 - 引用类型对象数据的存储"/></div><h3 id="C-类型的分类"><a href="#C-类型的分类" class="headerlink" title="C#类型的分类"></a>C#类型的分类</h3><p>如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">值类型</th><th style="text-align:left">引用类型</th></tr></thead><tbody><tr><td style="text-align:left">预定义类型</td><td style="text-align:left">sbyte byte<br>short ushort<br>int uint<br>long ulong<br>bool char<br>float double<br>decimal</td><td style="text-align:left">object<br>string<br>dynamic</td></tr><tr><td style="text-align:left">用户定义类型</td><td style="text-align:left">struct<br>enum</td><td style="text-align:left">class<br>interface<br>delegate<br>array</td></tr></tbody></table></div><h2 id="变量-Variables"><a href="#变量-Variables" class="headerlink" title="变量 Variables"></a>变量 Variables</h2><p><strong>变量</strong>是一个名称，表示程序执行时存储在内存中的数据。</p><p>C#提供了4种变量，如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">局部变量Local variable</td><td style="text-align:left">在方法的作用域保存临时数据，不是类型的成员</td></tr><tr><td style="text-align:left">字段Field</td><td style="text-align:left">保存和类型或类型实例相关的数据，是类型的成员</td></tr><tr><td style="text-align:left">参数Parameter</td><td style="text-align:left">用于从一个方法到另一个方法传递数据的临时变量，不是类型的成员</td></tr><tr><td style="text-align:left">数组元素Array element</td><td style="text-align:left">同类数据项构成的有序集合的一个成员，可以是局部变量，也可以是类型的成员</td></tr></tbody></table></div><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>变量声明定义了变量，并且完成了：① 给变量命名，并关联一种类型；② 让编译器分配一块内存。一个简单的变量声明至少需要一个类型和一个名称。</p><p>比如：<code>int var2;</code> 定义了一个名为 var2 的 int 类型的变量。</p><p><em>（1）变量初始化语句</em>  </p><p><strong>变量初始化语句 variable initializer</strong>由一个等号和初始值组成：<code>int var2 = 17;</code></p><p>无初始化语句的局部变量有一个未定义的值，在赋值前不能使用。</p><div  align="center">  <img src="https://s2.loli.net/2022/11/18/YPb8zBrDXshlfwj.png" width = "70%" height = "70%" alt="图12 - 变量初始化语句"/></div><p><em>（2）自动初始化</em></p><p>有一些类型的变量如果没初始化，会被自动设为默认值。没有自动化为默认值的变量在程序为它赋值之前包含未定义值。</p><div class="table-container"><table><thead><tr><th style="text-align:left">变量类型</th><th style="text-align:left">存储位置</th><th style="text-align:left">自动初始化</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">局部变量 Local variables</td><td style="text-align:left">栈或栈和堆</td><td style="text-align:left">否</td><td style="text-align:left">用于函数成员内部的局部计算</td></tr><tr><td style="text-align:left">类字段 Class fields</td><td style="text-align:left">堆</td><td style="text-align:left">是</td><td style="text-align:left">类的成员</td></tr><tr><td style="text-align:left">结构字段 Struct fields</td><td style="text-align:left">栈或堆</td><td style="text-align:left">是</td><td style="text-align:left">结构的成员</td></tr><tr><td style="text-align:left">参数 Parameters</td><td style="text-align:left">栈</td><td style="text-align:left">否</td><td style="text-align:left">用于把值传入或传出方法</td></tr><tr><td style="text-align:left">数组元素 Array elements</td><td style="text-align:left">堆</td><td style="text-align:left">是</td><td style="text-align:left">数组的成员</td></tr></tbody></table></div><h3 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h3><p>可以在单个声明语句中声明多个变量：①多变量声明中的变量必须类型相同；②变量名必须逗号隔开，可以包含初始化语句。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一些变量，有的被初始化，有的没被初始化</span></span><br><span class="line"><span class="built_in">int</span> var3 = <span class="number">7</span>, var4, var5 = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">double</span> var6, var7 = <span class="number">6.52</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> var8, <span class="built_in">float</span> var9; <span class="comment">//错误：多变量声明的变量类型必须相同</span></span><br></pre></td></tr></table></figure><h2 id="静态-static-类型和-dynamic-关键字"><a href="#静态-static-类型和-dynamic-关键字" class="headerlink" title="静态 static 类型和 dynamic 关键字"></a>静态 static 类型和 dynamic 关键字</h2><p>C#是静态类型的语言，但 IronPython 和 IronRuby 之类的脚本语言是动态类型的，因为它们也是.NET<br>语言，C#需要能够使用这些语言编写的程序集，因此增加了dynamic关键字。</p><h2 id="可空类型-Nullable-Types"><a href="#可空类型-Nullable-Types" class="headerlink" title="可空类型 Nullable Types"></a>可空类型 Nullable Types</h2><p>在某些情况下，希望变量目前不保存有效的值。对于引用类型，可以把变量设为null；但对于值类型，不管内容是否有效，其内存都会分配。可以使用布尔指示器来和变量关联，值有效则设置为true，无效即false。</p><p><strong>可空类型</strong>允许创建可以标记为有效和无效的值类型变量。普通的值类型为<strong>非可空类型</strong>。详见第27章。</p><h1 id="第五章-类的基本概念"><a href="#第五章-类的基本概念" class="headerlink" title="第五章 类的基本概念"></a>第五章 类的基本概念</h1><h2 id="类的概述"><a href="#类的概述" class="headerlink" title="类的概述"></a>类的概述</h2><p>数据项和函数的封装集合，被称为<strong>类</strong>。</p><p>类包括数据成员和函数成员：①数据成员，存储与类或类实例相关的数据；②函数成员，执行代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">数据成员存储数据</th><th style="text-align:left">函数成员执行代码</th></tr></thead><tbody><tr><td style="text-align:left">字段 Fields<br>常量 Constants</td><td style="text-align:left">方法 Methods ；运算符 Operators ；属性 Properties ；索引器 Indexers<br>构造函数 Constructors ；事件 Events ；析构函数 Destructors</td></tr></tbody></table></div><h2 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h2><p><strong>类的声明</strong>定义类的名称、成员和特征，不创建类的实例，创建用于创建实例的模板。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyExcellentClass</span> <span class="comment">//class为关键字Keyword，MyExcellentClass是类名</span></span><br><span class="line">&#123;</span><br><span class="line">    MemberDeclarations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p><strong>字段</strong>是在类中的变量。可以是任意类型，包括预定义类型或用户定义的类型。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> MyField; <span class="comment">//MyField即字段名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 C 和 C++ 不同，<em>C#在类型外面不能申明全局变量</em>。所有字段都属于类型。</p><p>因为字段是一种变量，<strong>字段初始化语句</strong>和变量初始化语言相同；如果没有初始化语句，字段的值会被编译器设为默认值，总结的来说，每种值类型的默认值都是0，bool 型的默认值是 false，引用类型的默认值为 null 。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> F1; <span class="comment">// 初始化为0 - 值类型</span></span><br><span class="line">    <span class="built_in">string</span> F2; <span class="comment">// 初始化为null - 引用类型</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> F3 = <span class="number">25</span>; <span class="comment">// 初始化为25</span></span><br><span class="line">    <span class="built_in">string</span> F4 = <span class="string">&quot;abcd&quot;</span>; <span class="comment">// 初始化为&quot;abcd&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一语句中声明多个字段，下面语句与上面效果相同：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> F1, F3 = <span class="number">25</span>;</span><br><span class="line"><span class="built_in">string</span> F2, F4 = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>方法</strong>是具有名称的可执行代码块，相当于C++的<strong>成员函数</strong>。</p><p>声明方法包括以下4个组成部分：<br>①返回类型：声明方法返回值的类型，若不返回值，则被指定为 void ；<br>②名称：方法的名称；<br>③参数列表：由一对圆括号组成，参数列在其中；<br>④方法体：由一对大括号组成，包含执行代码。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SimpleClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintNums</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码不返回值（void），有空的参数列表，方法体有2行。</p><p>与 C 和 C++ 不同，C#<strong>没有全局函数</strong>，也没有默认的返回类型，所有方法必须包含返回类型或者 void 。</p><h2 id="创建变量和类的实例"><a href="#创建变量和类的实例" class="headerlink" title="创建变量和类的实例"></a>创建变量和类的实例</h2><p>类是引用类型，数据的引用保存在一个类类型的变量中，要创建类的实例，需要声明一个类类型的变量开始，如果变量没有被初始化，它的值是未定义的。</p><div  align="center">  <img src="https://s2.loli.net/2022/11/19/DZy8t9hd3uxGcOa.png" width = "60%" height = "60%" alt="图13 - 为类变量的引用分配内存"/></div><p>左边顶端的代码是类 Dealer 的声明，下面是类 Program 的声明，它包含 Main 方法；Main 声明了 Dealer 类型的变量 theDealer 。因为该变量没有被初始化，所有它的值是未定义的。</p><h2 id="为数据分配内存"><a href="#为数据分配内存" class="headerlink" title="为数据分配内存"></a>为数据分配内存</h2><p>声明类类型的变量所分配的内存是用来保存引用的，不是用来保存类对象实际数据的。要为实际数据分配内存，需要使用 <strong>new 运算符 operator</strong>。<br>①new 运算符能为任意指定类型的实例分配并<strong>初始化</strong>内存；<br>②使用 new 运算符组成一个<strong>对象创建表达式</strong>，包括：关键字 new ；要分配内存的实例的类型名称；成对的圆括号，包含或不包含参数。<br>③如果将内存分配给一个引用类型，则对象创建表达式返回一个引用，指向在堆中被分配或初始化的对象实例。</p><div  align="center">  <img src="https://s2.loli.net/2022/11/19/s9Vg3YBLvb7eXTP.png" width = "70%" height = "70%" alt="图14 - 为类变量的数据分配内存"/></div><p><code>Dealer theDealer;</code>声明引用变量；<code>theDealer = new Dealer();</code>为类对象分配内存并赋值给变量</p><p>合并以上两个步骤，用对象创建表达式来<strong>初始化</strong>变量：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Dealer theDealer = <span class="keyword">new</span> Dealer(); <span class="comment">// 声明并初始化</span></span><br></pre></td></tr></table></figure><h2 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h2><p><strong>实例成员 Instance members</strong>：类的每个实例都有自己的一组数据，不同于同一类的其他实例。因为数据成员和类的实例相关，所以被称为实例成员。</p><p><strong>静态成员 Static members</strong>：实例成员是默认类型，但是可以声明与类有关，与实例无关的成员，称为静态成员。见第7章。</p><h2 id="访问修饰符-Access-Modifiers"><a href="#访问修饰符-Access-Modifiers" class="headerlink" title="访问修饰符 Access Modifiers"></a>访问修饰符 Access Modifiers</h2><p><strong>访问修饰符</strong>是成员声明的可选部分，指明程序的其他部分如何访问成员，语法如下：<br>①字段：<code>访问修饰符 类型 标识符;</code> ②方法：<code>访问修饰符 返回类型 方法名()</code></p><p>5种成员访问控制如下，本章只介绍前2种，其余在第8章：<br>①私有的 private ；②公有的 public ；③受保护的 protected ；④内部的 internal ；⑤受保护内部的 protected internal</p><p>范围比较：private &lt; internal/protected &lt; protected internal &lt; public</p><h3 id="私有访问和公有访问"><a href="#私有访问和公有访问" class="headerlink" title="私有访问和公有访问"></a>私有访问和公有访问</h3><p>私有成员只能从声明它的类的内部访问，其他的类看不到或无法访问它们。<br>私有访问是默认的，若声明时不带访问修饰符，即私有成员。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> MyInt1; <span class="comment">//隐式声明为私有</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> MyInt2; <span class="comment">//显示声明为私有</span></span><br></pre></td></tr></table></figure><p>公有成员可以被程序中的其他对象访问。必须使用 public 访问修饰符指定。<code>public int MyInt;</code></p><p>成员访问示例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">C1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> F1; <span class="comment">//隐式私有字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> F2; <span class="comment">//显式私有字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> F3; <span class="comment">//公有字段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoCalc</span>() <span class="comment">//隐式私有方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetVal</span>() <span class="comment">//公有方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从类的内部访问成员"><a href="#从类的内部访问成员" class="headerlink" title="从类的内部访问成员"></a>从类的内部访问成员</h2><p>下面的类展示了类的方法对字段和其他方法的访问，私有成员可以被类的任何方法访问：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DaysTemp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> High = <span class="number">75</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> Low = <span class="number">45</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">GetHigh</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> High; <span class="comment">//访问私有字段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">GetLow</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Low; <span class="comment">//访问私有字段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">Average</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (GetHigh() + GetLow()) / <span class="number">2</span>; <span class="comment">//访问私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从类的外部访问成员"><a href="#从类的外部访问成员" class="headerlink" title="从类的外部访问成员"></a>从类的外部访问成员</h2><p>要从类的外部访问实例成员，需要<strong>点运算符 dot-syntax notation</strong>，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">DaysTemp myDt = <span class="keyword">new</span> DaysTemp(); <span class="comment">//创建类的对象</span></span><br><span class="line"><span class="built_in">float</span> fValue = myDt.Average(); <span class="comment">//从外部访问</span></span><br></pre></td></tr></table></figure><p>示例如下，DaysTemp 内的两个字段被声明为 public ，可以从类外部访问：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DaysTemp</span> <span class="comment">//声明类 DaysTemp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> High = <span class="number">75</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Low = <span class="number">45</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> <span class="comment">//声明类 Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        DaysTemp temp = <span class="keyword">new</span> DaysTemp(); <span class="comment">//创建对象</span></span><br><span class="line"></span><br><span class="line">        temp.High = <span class="number">85</span>; <span class="comment">//字段赋值</span></span><br><span class="line">        temp.Low = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;High:   &#123;0&#125;&quot;</span>, temp.High ); <span class="comment">//读取字段值</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Low:    <span class="subst">&#123;temp.Low&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">High:   85</span><br><span class="line">Low:    60</span><br></pre></td></tr></table></figure><h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><p>创建两个实例并把它们的引用保存在名称为 t1 和 t2 的变量中：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DaysTemp</span> <span class="comment">//声明类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> High, Low; <span class="comment">//声明实例字段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Average</span>() <span class="comment">//声明实例方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (High + Low) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建两个DaysTemp实例</span></span><br><span class="line">        DaysTemp t1 = <span class="keyword">new</span> DaysTemp();</span><br><span class="line">        DaysTemp t2 = <span class="keyword">new</span> DaysTemp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给字段赋值</span></span><br><span class="line">        t1.High = <span class="number">76</span>; t1.Low = <span class="number">57</span>;</span><br><span class="line">        t2.High = <span class="number">75</span>; t2.Low = <span class="number">53</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取字段值和调用实例的方法</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;t1: &#123;0&#125;, &#123;1&#125;, &#123;2&#125;&quot;</span>,</span><br><span class="line">                                  t1.High, t1.Low, t1.Average() );</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;t2: &#123;0&#125;, &#123;1&#125;, &#123;2&#125;&quot;</span>,</span><br><span class="line">                                  t2.High, t2.Low, t2.Average() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">t1: 76, 57, 66</span><br><span class="line">t2: 75, 53, 64</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/11/20/djQIPz6cxEgRlY7.png" width = "50%" height = "50%" alt="图15 - 实例t1和t2的内存布局"/></div><h1 id="第六章-方法"><a href="#第六章-方法" class="headerlink" title="第六章 方法"></a>第六章 方法</h1><h2 id="方法的结构"><a href="#方法的结构" class="headerlink" title="方法的结构"></a>方法的结构</h2><p><em>方法是类的函数成员</em>，包括方法头 method header 和方法体 method body。</p><p>方法头指定方法的特征：<code>int MyMethod ( int par1, string par2 )</code>，即返回类型、方法名称及参数列表。</p><p>方法体包含可执行代码的语句序列。</p><h2 id="方法体内部的代码执行"><a href="#方法体内部的代码执行" class="headerlink" title="方法体内部的代码执行"></a>方法体内部的代码执行</h2><p>方法体是个<strong>块</strong>，是大括号括起的语句序列。可以包括：<em>局部变量；控制流结构 Flow-of-control constructs ；方法调用 Method invocations ；内嵌的块；其他方法（局部函数）</em></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> myInt = <span class="number">3</span>; <span class="comment">//局部变量初始化为3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (myInt &gt; <span class="number">0</span>) <span class="comment">//控制流结构</span></span><br><span class="line">    &#123;</span><br><span class="line">        --myInt;</span><br><span class="line">        PrintMyMessage(); <span class="comment">//方法调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>和字段一样，局部变量也保存数据。字段通常保存和对象状态有关的数据，而局部变量是用于保存临时的计算数据。</p><p>局部变量声明的语法：<code>Type Identifier = Value;</code></p><p>下面的代码包含了2个局部变量的声明，第一个是int类型变量，第二个是SomeClass类型变量：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> myInt = <span class="number">15</span>;</span><br><span class="line">    SomeClass sc = <span class="keyword">new</span> SomeClass();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比实例字段和局部变量：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">实例字段</th><th style="text-align:left">局部变量</th></tr></thead><tbody><tr><td style="text-align:left">生存期</td><td style="text-align:left">从实例被创建时开始，直到实例不再被访问时结束</td><td style="text-align:left">从它的块中被声明的那一刻开始，在块完成执行时结束</td></tr><tr><td style="text-align:left">隐式初始化</td><td style="text-align:left">初始化成该类型的默认值</td><td style="text-align:left">没有隐式初始化。如果变量在使用之前没有被赋值，编译器就会产生一条错误消息</td></tr><tr><td style="text-align:left">存储区域</td><td style="text-align:left">由于实例字段是类的成员，所以所有字段都存储在堆里，无论是值类型还是引用类型</td><td style="text-align:left">值类型：存储在栈里；引用类型：引用存储在栈里，数据存储在堆里</td></tr></tbody></table></div><h3 id="类型推导和-var-关键字"><a href="#类型推导和-var-关键字" class="headerlink" title="类型推导和 var 关键字"></a>类型推导和 var 关键字</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> total = <span class="number">15</span>;</span><br><span class="line">    MyExcellentClass mec = <span class="keyword">new</span> MyExcellentClass();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，第一个变量声明中，编译器可以推断出15是 int 型；第二个变量声明中，右边的对象创建表达式返回了 MyExcellentClass 类型的对象。为避免冗余，可以使用<strong>关键字 var</strong> ：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">var</span> mec = <span class="keyword">new</span> MyExcellentClass();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var 关键字并不表示特殊变量，只是句法的速记 shorthand ，表示任何可以从初始化语句的右边推断出的类型。var 只能用于局部变量，不能用于字段。一旦推断出类型，即不能改变。</p><blockquote><p>var 关键字不改变 C# 的强类型性质。</p></blockquote><h3 id="嵌套块中的局部变量"><a href="#嵌套块中的局部变量" class="headerlink" title="嵌套块中的局部变量"></a>嵌套块中的局部变量</h3><p>局部变量在嵌套块的内部声明，它的生存期限于声明它的内嵌块。</p><p>在 C# 中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量。和 C 和 C++ 不同。</p><h2 id="局部常量-Local-Constants"><a href="#局部常量-Local-Constants" class="headerlink" title="局部常量 Local Constants"></a>局部常量 Local Constants</h2><p><strong>常量</strong>在声明时必须初始化，声明后不能改变。</p><p>声明语句如下：<code>const Type Identifier = Value;</code></p><p>初始化值必须在编译期决定，通常是一个预定义简单类型或其组成的表达式。还可以是null引用，但不能是某对象的引用，因为对象的引用是在运行时决定的。</p><p><strong>关键字 const</strong> 不是修饰符，是核心声明的一部分，必须直接放在类型前面。</p><p>局部常量也在方法体或代码块中声明，并在声明它的块结束的地方失效。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayRadii</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">double</span> PI = <span class="number">3.1416</span>; <span class="comment">//声明局部常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> radius = <span class="number">1</span>; radius &lt;= <span class="number">5</span>; radius++) &#123;</span><br><span class="line">        <span class="built_in">double</span> area = radius * radius * PI; <span class="comment">//读取局部常量</span></span><br><span class="line">        Console.WriteLine</span><br><span class="line">            (<span class="string">$&quot;Radius: <span class="subst">&#123; radius &#125;</span>, Area: <span class="subst">&#123; area &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制流-Flow-of-Control"><a href="#控制流-Flow-of-Control" class="headerlink" title="控制流 Flow of Control"></a>控制流 Flow of Control</h2><p>默认情况下，程序按顺序执行语句，<strong>控制流语句</strong>允许改变执行的顺序。详见第10章。</p><p>①<strong>选择语句 Selection statements</strong>：<code>if</code> 、<code>if...else</code> 、<code>switch</code> ;<br>②<strong>迭代语句 Iteration statements</strong>：<code>for 循环</code>、<code>while 循环</code>、<code>do 循环</code>、<code>foreach</code> ；<br>③<strong>跳转语句 Jump statements</strong>：<code>break</code> 、<code>continue</code> 、<code>goto</code> 、<code>return</code> 。</p><h2 id="方法调用-Method-Invocations"><a href="#方法调用-Method-Invocations" class="headerlink" title="方法调用 Method Invocations"></a>方法调用 Method Invocations</h2><p>可以从方法体的内部调用其他方法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintDateAndTime</span>() <span class="comment">//声明方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        DateTime dt = DateTime.Now; <span class="comment">//获取当前日期和时间</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; dt &#125;</span>&quot;</span>); <span class="comment">//输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>() <span class="comment">//声明方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">        mc.PrintDateAndTime( ); <span class="comment">//调用方法，别忘了空的参数列表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法时的控制顺序：当前方法的执行在调用其他方法的点被挂起 → 控制转移到被调用方法的开始 → 被调用方法执行语句直到该方法结束 → 控制回到发起调用的方法。</p><p>如果另一个方法在同一个类中，可以直接使用它的名称并传入所需参数进行调用；如果另一个方法在不同的类中，必须通过这个类的一个对象实例调用它，且另一个类中的方法必须使用 public 访问修饰符声明。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>方法要向调用代码返回一个值，除了要<strong>声明返回类型</strong>外，还要使用<strong>返回语句</strong>。若方法不返回值，即声明 void 返回类型，不需要返回语句。</p><p>返回语句包括关键字 return 及其后面的表达式：<code>return Expression;</code></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">GetHour</span>(<span class="params"> </span>) <span class="comment">//声明返回类型int</span></span></span><br><span class="line">&#123;</span><br><span class="line">    DateTime dt = DateTime.Now;</span><br><span class="line">    <span class="built_in">int</span> hour = dt.Hour;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hour; <span class="comment">//返回一个int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以返回用户定义类型的对象：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">method3</span>(<span class="params"> </span>) <span class="comment">//声明返回类型MyClass</span></span></span><br><span class="line">&#123;</span><br><span class="line">    MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> mc; <span class="comment">//返回一个MyClass对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="void-方法"><a href="#void-方法" class="headerlink" title="void 方法"></a>void 方法</h2><p>void 方法不需要返回语句。可以使用下面的返回语句提前退出方法，不带参数：<code>return;</code>。该语句只适用于 void 声明的方法。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ( SomeCondition )</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//返回到调用代码</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( OtherCondition )</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//返回到调用代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">//默认返回到调用代码</span></span><br></pre></td></tr></table></figure><h2 id="局部函数-Local-Functions"><a href="#局部函数-Local-Functions" class="headerlink" title="局部函数 Local Functions"></a>局部函数 Local Functions</h2><p>可以在一个方法内声明另一个方法，它只能在包含它的方法内调用，这些嵌入的方法被称为<strong>局部函数</strong>。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodWithLocalFunction</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">int</span> <span class="title">MyLocalFunction</span>(<span class="params"><span class="built_in">int</span> z1</span>) <span class="comment">//声明局部函数</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> z1 * <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">int</span> results = MyLocalFunction(<span class="number">5</span>); <span class="comment">//调用局部函数</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Results of local function call: <span class="subst">&#123;results&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Program myProgram = <span class="keyword">new</span> Program();</span><br><span class="line">        myProgram.MethodWithLocalFunction(); <span class="comment">//调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Results of local function call: 25</span><br></pre></td></tr></table></figure><h2 id="参数-Parameters"><a href="#参数-Parameters" class="headerlink" title="参数 Parameters"></a>参数 Parameters</h2><h3 id="形参-Formal-Parameters"><a href="#形参-Formal-Parameters" class="headerlink" title="形参 Formal Parameters"></a>形参 Formal Parameters</h3><p><strong>形参</strong>是<strong>局部变量</strong>，它声明在方法的参数列表中，而不是在方法体中：<code>public void PrintSum( int x, float y )</code>。</p><p>参数在方法体的外面定义并在方法开始之前初始化（<strong>输出参数</strong>除外，见后面）；参数列表中可以有任意数目的形参声明，而且声明必须以逗号隔开。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintSum</span>(<span class="params"> <span class="built_in">int</span> x, <span class="built_in">int</span> y </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> sum = x + y;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Newsflash: <span class="subst">&#123; x &#125;</span> + <span class="subst">&#123; y &#125;</span> is <span class="subst">&#123; sum &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实参-Actual-Parameters"><a href="#实参-Actual-Parameters" class="headerlink" title="实参 Actual Parameters"></a>实参 Actual Parameters</h3><p>调用方法时，形参的值必须在执行前初始化，用于初始化形参的表达式或变量称作<strong>实参</strong>（ actual parameters ，或称为 argument ）。</p><p>每一个实参必须与对应形参的类型相匹配，或者编译器能把实参隐式地转换为匹配的类型。</p><p>方法PrintSum的调用：<code>PrintSum( 5, someInt );</code></p><p>实参的数量必须和形参的数量一致，并且每个实参的类型也必须和所对应的形参类型一致，这种形式的参数叫做<strong>位置参数 Positional Parameters</strong> 。</p><p>位置参数示例如下，对于第二次调用，编译器把 int 值 5 和 someInt 隐式地转换成了 float 类型：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>) <span class="comment">//形参、声明方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y; <span class="comment">//返回和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">Avg</span>(<span class="params"><span class="built_in">float</span> input1, <span class="built_in">float</span> input2</span>) <span class="comment">//形参、声明方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (input1 + input2) / <span class="number">2.0F</span>; <span class="comment">//返回平均值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myT = <span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="built_in">int</span> someInt = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine</span><br><span class="line">            (<span class="string">&quot;Newsflash: Sum: &#123;0&#125; and &#123;1&#125; is &#123;2&#125;&quot;</span>,</span><br><span class="line">                <span class="number">5</span>, someInt, myT.Sum( <span class="number">5</span>, someInt )); <span class="comment">//实参、调用方法</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine</span><br><span class="line">            (<span class="string">&quot;Newsflash: Avg: &#123;0&#125; and &#123;1&#125; is &#123;2&#125;&quot;</span>,</span><br><span class="line">                <span class="number">5</span>, someInt, myT.Avg( <span class="number">5</span>, someInt )); <span class="comment">//实参、调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Newsflash: Sum: 5 and 6 is 11</span><br><span class="line">Newsflash: Avg: 5 and 6 is 5.5</span><br></pre></td></tr></table></figure><h2 id="值参数-Value-Parameters"><a href="#值参数-Value-Parameters" class="headerlink" title="值参数 Value Parameters"></a>值参数 Value Parameters</h2><p>参数种类有好几种，目前为止看到的都是默认的类型，称为<strong>值参数</strong>。</p><p>使用值参数时，通过将实参的值复制到形参的方式把数据传递给方法。方法被调用时，系统执行如下操作：①在栈中为形参分配空间；②将实参的值复制给形参。</p><p>值参数的实参不一定是变量，可以是任何能计算成相应数据类型的表达式，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">float</span> <span class="title">func1</span>(<span class="params"> <span class="built_in">float</span> val </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> j = <span class="number">2.6F</span>;</span><br><span class="line">    <span class="built_in">float</span> k = <span class="number">5.1F</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> fValue1 = func1( k ); <span class="comment">//方法调用</span></span><br><span class="line">    <span class="built_in">float</span> fValue2 = func1( (k + j) / <span class="number">3</span> ); <span class="comment">//方法调用，计算成 float 的表达式</span></span><br></pre></td></tr></table></figure><p>用作实参之前，变量必须被复制（除非是输出函数）。对于引用类型，变量可以被设置为一个实际的引用或 null 。如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Val = <span class="number">20</span>; <span class="comment">//初始化字段为20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params"> MyClass f1, <span class="built_in">int</span> f2 </span>) <span class="comment">//形参</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        f1.Val = f1.Val + <span class="number">5</span>; <span class="comment">//参数的字段加5</span></span><br><span class="line">        f2 = f2 + <span class="number">5</span>; <span class="comment">//另一个参数加5</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;f1.Val: <span class="subst">&#123; f1.Val &#125;</span>, f2: <span class="subst">&#123; f2 &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass a1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="built_in">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        MyMethod( a1, a2 ); <span class="comment">//调用方法</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;a1.Val: <span class="subst">&#123; a1.Val &#125;</span>, a2: <span class="subst">&#123; a2 &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">f1.Val: 25, f2: 15</span><br><span class="line">a1.Val: 25, a2: 10</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/11/29/phFWZkfumMcdVLw.png" width = "70%" height = "70%" alt="图16 - 值参数"/></div><p>①在方法被调用前，用作实参的变量 a2 已经在栈里了；<br>②在方法开始时，系统在栈中为形参分配空间，并从实参复制值。<br>&emsp;&emsp;- 因为 a1 是引用类型，所以<strong>引用被复制</strong>，结果实参和形参都引用堆中的同一个对象；<br>&emsp;&emsp;- 因为 a2 是值类型，所以<strong>值被复制</strong>，产生了一个独立的数据项。<br>③在方法的结尾，f2 和对象 f1 的字段都被加上了5。<br>&emsp;&emsp;- 方法执行后，形参从栈中弹出；<br>&emsp;&emsp;- a2，值类型，它的值不受方法行为影响；<br>&emsp;&emsp;- a1，引用类型，但它的值被方法的行为改变了。</p><blockquote><p>区分参数和变量，值参数可以是引用类型的变量，注意与引用参数区分。</p></blockquote><h2 id="引用参数-Reference-Parameters"><a href="#引用参数-Reference-Parameters" class="headerlink" title="引用参数 Reference Parameters"></a>引用参数 Reference Parameters</h2><p>第二种参数类型称为<strong>引用参数</strong>。</p><p>①使用引用参数时，必须在方法的声明和调用中都使用 <strong>ref 修饰符</strong>；<br>②引用参数的<strong>实参必须是变量</strong>，在用作实参前必须被赋值。如果是引用类型变量，可以赋值为一个引用或 null 。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params"> <span class="keyword">ref</span> <span class="built_in">int</span> val </span>) <span class="comment">//方法声明，包含ref修饰符</span></span></span><br><span class="line">&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> y = <span class="number">1</span>; <span class="comment">//实参变量</span></span><br><span class="line">MyMethod ( <span class="keyword">ref</span> y ); <span class="comment">//方法调用，包含ref修饰符</span></span><br><span class="line"></span><br><span class="line">MyMethod ( <span class="keyword">ref</span> <span class="number">3</span>+<span class="number">5</span> ); <span class="comment">// Error!，必须使用变量</span></span><br></pre></td></tr></table></figure><p>①引用参数不会在栈上为形参分配内存。<br>②形参的参数名将作为实参变量的别名，指向相同的内存位置。<br>由于形参名和实参名指向相同的内存位置，所以方法的执行过程中对形参做的任何改变在方法完成后依然可见。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Val = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params"><span class="keyword">ref</span> MyClass f1, <span class="keyword">ref</span> <span class="built_in">int</span> f2</span>) <span class="comment">//ref修饰符</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        f1.Val = f1.Val + <span class="number">5</span>;</span><br><span class="line">        f2 = f2 + <span class="number">5</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;f1.Val: <span class="subst">&#123; f1.Val &#125;</span>, f2: <span class="subst">&#123; f2 &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass a1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="built_in">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        MyMethod(<span class="keyword">ref</span> a1, <span class="keyword">ref</span> a2); <span class="comment">//调用方法，ref修饰符</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;a1.Val: <span class="subst">&#123; a1.Val &#125;</span>, a2: <span class="subst">&#123; a2 &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">f1.Val: 25, f2: 15</span><br><span class="line">a1.Val: 25, a2: 15</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/11/29/OJWcAat1gi8SPhv.png" width = "70%" height = "70%" alt="图17 - 对于引用参数，形参就像实参的别名"/></div><p>①在方法调用之前，将要被用作实参的变量 a1 和 a2 已经在栈里了；<br>②在方法的开始，形参名被设置为实参的别名。变量 a1 和 f1 引用相同的内存位置，a2 和 f2 引用相同的内存位置；<br>③在方法的结束位置，f2 和 f1 的对象的字段都被加上了5；<br>④方法执行后，形参的名称已经失效，但值类型 a2 的值和引用类型 a1 所指向的对象的值被方法内的行为改变了。</p><h2 id="引用类型作为值参数和引用参数"><a href="#引用类型作为值参数和引用参数" class="headerlink" title="引用类型作为值参数和引用参数"></a>引用类型作为值参数和引用参数</h2><p>本节主要描述在方法内用引用类型给形参赋值会发生什么：<br>①将引用类型对象作为<strong>值参数</strong>传递：如果在方法内创建一个新的对象并赋值给形参，将切断形参和实参之间的联系，并且在方法调用结束后，新对象将不存在。<br>②将引用类型对象作为<strong>引用参数</strong>传递：如果在方法内创建一个新的对象并赋值给形参，在方法结束后该对象依然存在，并且是实参所引用的值。</p><p><em>第一种情况 - 将引用类型对象作为值参数传递的示例：</em></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123; <span class="keyword">public</span> <span class="built_in">int</span> Val = <span class="number">20</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RefAsParameter</span>(<span class="params"> MyClass f1 </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        f1.Val = <span class="number">50</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After member assignment: <span class="subst">&#123; f1.Val &#125;</span>&quot;</span>);</span><br><span class="line">        f1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After new object creation: <span class="subst">&#123; f1.Val &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass a1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Before method call: <span class="subst">&#123; a1.Val &#125;</span>&quot;</span>);</span><br><span class="line">        RefAsParameter( a1 );</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After method call: <span class="subst">&#123; a1.Val &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Before method call: 20</span><br><span class="line">After member assignment: 50</span><br><span class="line">After new object creation: 20</span><br><span class="line">After method call: 50</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/12/04/ocsiSMEuyIdvUpn.png" width = "70%" height = "70%" alt="图18 - 对用作值参数的引用类型对象赋值"/></div><p>①在方法开始时，实参和形参都指向堆中相同的对象；<br>②在为对象的成员赋值之后，它们仍指向堆中相同的对象；<br>③当方法分配新的对象并赋值给形参时，方法外部的实参仍指向原始对象，而形参指向新对象；<br>④在方法调用之后，实参指向原始对象，形参和新对象会消失。</p><p><em>第二种情况 - 将引用类型对象作为引用参数传递的示例：</em></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Val = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RefAsParameter</span>(<span class="params"> <span class="keyword">ref</span> MyClass f1 </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        f1.Val = <span class="number">50</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After member assignment: <span class="subst">&#123; f1.Val &#125;</span>&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        f1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After new object creation: <span class="subst">&#123; f1.Val &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> <span class="built_in">string</span>[] args </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass a1 = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Before method call: <span class="subst">&#123; a1.Val &#125;</span>&quot;</span>);</span><br><span class="line">        RefAsParameter( <span class="keyword">ref</span> a1 );</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After method call: <span class="subst">&#123; a1.Val &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Before method call: 20</span><br><span class="line">After member assignment: 50</span><br><span class="line">After new object creation: 20</span><br><span class="line">After method call: 20</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/12/04/yGU3lsVcNuoPdYM.png" width = "70%" height = "70%" alt="图19 - 对用作引用参数的引用类型对象赋值"/></div><p>①在方法调用时，形参和实参指向堆中相同的对象；<br>②对成员值的修改会同时影响到形参和实参；<br>③当方法创建新的对象并赋值给形参时，形参和实参的引用都指向新对象。<br>④在方法结束后，实参指向在方法内创建的新对象。</p><h2 id="输出参数-Output-Parameters"><a href="#输出参数-Output-Parameters" class="headerlink" title="输出参数 Output Parameters"></a>输出参数 Output Parameters</h2><p><strong>输出参数</strong>用于从方法体内把数据传出到调用代码，行为和引用参数类似。<br>①必须<strong>在声明和调用中</strong>都使用修饰符，修饰符为 <strong>out</strong> 。<br>②和引用参数一样，实参必须是变量，而不能是其他类型的表达式，因为方法需要位置来保存返回值。<br>③和引用参数类似，输出参数的形参充当实参的别名，形参和实参都是同一块内存位置的名称。</p><p>与引用参数不同，输出参数有以下要求：<br>①在方法内部，给输出参数赋值之后才能读取它；即参数的初始值是无关的，而且没必要在方法调用之前为实参赋值。<br>②在方法内部，在方法返回之前，代码中每条可能的路径都必须给所有输出参数赋值。</p><p>因为方法内的代码在读取输出参数之前必须对其写入，所以不可能使用输出参数把数据传入方法；若方法中试图在方法给输出参数赋值之前读取它的值，编译器会产生一条错误消息。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add2</span>(<span class="params"> <span class="keyword">out</span> <span class="built_in">int</span> outValue </span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> var1 = outValue + <span class="number">2</span>; <span class="comment">//出错，在赋值之前读取输出参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用输出参数的示例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Val = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMethod</span>(<span class="params"><span class="keyword">out</span> MyClass f1, <span class="keyword">out</span> <span class="built_in">int</span> f2</span>) <span class="comment">//out修饰符</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        f1 = <span class="keyword">new</span> MyClass(); <span class="comment">//创建类变量</span></span><br><span class="line">        f1.Val = <span class="number">25</span>; <span class="comment">//赋值类字段</span></span><br><span class="line">        f2 = <span class="number">15</span>; <span class="comment">//赋值int参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass a1 = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">int</span> a2;</span><br><span class="line"></span><br><span class="line">        MyMethod(<span class="keyword">out</span> a1, <span class="keyword">out</span> a2); <span class="comment">//调用方法，别忘了out修饰符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/12/05/24xmMSKPvpBATVu.png" width = "65%" height = "65%" alt="图20 - 输出参数必须在方法内进行赋值"/></div><p>①在方法调用之前，将要被用作实参的变量 a1 和 a2 已经在栈里了；<br>②在方法的开始，形参的名称被设置为实参的别名。a1 和 a2 不再作用域之内，所以不能在 MyMethod 中访问；<br>③在方法的内部，代码创建了一个 MyClass 类型的对象并赋值给 f1 ；然后给 f1 的字段和 f2 赋值。对 f1 和 f2 的赋值是必须的，因为是输出参数；<br>④方法执行后，形参的名称失效，但引用类型的 a1 和值类型的 a2 都被方法内的行为改变了。</p><blockquote><p>从 C# 7.0 之后，可以直接在方法调用时的参数列表中声明变量：<br>原示例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyClass a1 = <span class="literal">null</span>; <span class="comment">//声明将被用作输出参数的变量</span></span><br><span class="line">    <span class="built_in">int</span> a2; <span class="comment">//声明将被用作输出参数的变量</span></span><br><span class="line"></span><br><span class="line">    MyMethod(<span class="keyword">out</span> a1, <span class="keyword">out</span> a2); <span class="comment">//调用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新语法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyMethod( <span class="keyword">out</span> MyClass a1, <span class="keyword">out</span> <span class="built_in">int</span> a2 ); <span class="comment">//调用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="参数数组-Parameter-Arrays"><a href="#参数数组-Parameter-Arrays" class="headerlink" title="参数数组 Parameter Arrays"></a>参数数组 Parameter Arrays</h2><p><strong>参数数组</strong>允许特定类型的零个或多个实参对应特定的形参：<br>①在一个参数列表里只能有一个参数数组，且必须是列表中的最后一个；<br>②由参数数组表示的所有参数必须是同一类型。</p><p>声明参数数组要在数据类型前使用 <strong>params 修饰符</strong>，在数据类型后放置一组<strong>空的方括号</strong>，空方括号指明了参数是一个整数数组。数组的细节在第13章。</p><p>下面是 int 型参数数组的声明语法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInts</span>(<span class="params"> <span class="keyword">params</span> <span class="built_in">int</span>[] inVals </span>) <span class="comment">//params为修饰符，int[]为int型参数数组，inVals为参数名称</span></span></span><br></pre></td></tr></table></figure><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>可以用2种方式为参数数组提供实参：<br>①一个用逗号分隔的该数据类型元素的列表，所有元素必须是方法声明中指定的类型：<br><code>ListInts( 10, 20, 30 );</code><br>②一个该数据类型元素的一维数组：<br><code>int[] intArray = &#123;1, 2, 3&#125;;</code><br><code>ListInts( intArray );</code></p><blockquote><p>注意：调用不需要使用 params 修饰符，与上面的其他参数类型的模式不同。<br>值参数的声明和调用都不带修饰符；<br>引用参数和输出参数在两个地方都需要修饰符；<br>params 修饰符在声明中需要修饰符，在调用中不允许有修饰符。</p></blockquote><p><em>延伸式 Expanded Form</em><br>方法调用的第一种形式被称为延伸式，这种形式在调用中使用独立的实参；  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInts</span>(<span class="params"> <span class="keyword">params</span> <span class="built_in">int</span>[] inVals </span>)</span> &#123; ... &#125; <span class="comment">//方法声明</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ListInts( ); <span class="comment">//0个实参</span></span><br><span class="line">ListInts( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ); <span class="comment">//3个实参</span></span><br><span class="line">ListInts( <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> ); <span class="comment">//4个实参</span></span><br><span class="line">ListInts( <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> ); <span class="comment">//5个实参</span></span><br></pre></td></tr></table></figure><p>在使用一个为参数数组使用独立参数的调用时，编译器会<br>①接受实参列表，用它们在堆中创建并初始化一个数组；<br>②把数组的引用保存在栈的形参里；<br>③如果在对应形参数组的位置没有实参，编译器会创建一个有零个元素的数组来使用。</p><p>示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ListInts</span>(<span class="params"> <span class="keyword">params</span> <span class="built_in">int</span>[] inVals </span>) <span class="comment">//参数数组</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (inVals != <span class="literal">null</span>) &amp;&amp; (inVals.Length != <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; inVals.Length; i++) <span class="comment">//处理数组</span></span><br><span class="line">            &#123;</span><br><span class="line">                inVals[i] = inVals[i] * <span class="number">10</span>;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; inVals[i] &#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> first = <span class="number">5</span>, second = <span class="number">6</span>, third = <span class="number">7</span>; <span class="comment">//声明3个int</span></span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">        mc.ListInts( first, second, third ); <span class="comment">//调用方法</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; first &#125;</span>, <span class="subst">&#123; second &#125;</span>, <span class="subst">&#123; third &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">50</span><br><span class="line">60</span><br><span class="line">70</span><br><span class="line">5, 6, 7</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/12/05/9n5PU8ZbdIkQzMy.png" width = "65%" height = "65%" alt="图21 - 参数数组示例"/></div><p>①在方法调用之前，3个实参已经在栈中；<br>②在方法的开始，3个实参被用于初始化堆中的数组，并且数组的引用被赋值给了形参 inVals ；<br>③在方法内部，代码首先检查以确认数组引用不是 null ，然后处理数组，把每个元素乘以10并保存回去；<br>④方法执行之后，形参 inVals 失效。</p><h3 id="将数组作为实参"><a href="#将数组作为实参" class="headerlink" title="将数组作为实参"></a>将数组作为实参</h3><p>也可以在方法调用之前创建并组装一个数组，把单一的数组变量作为实参传递。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">int</span>[] myArr = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;; <span class="comment">//创建并初始化数组</span></span><br><span class="line">    MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">    mc.ListInts(myArr); <span class="comment">//调用方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> x <span class="keyword">in</span> myArr)</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; x &#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">50</span><br><span class="line">60</span><br><span class="line">70</span><br><span class="line">50</span><br><span class="line">60</span><br><span class="line">70</span><br></pre></td></tr></table></figure><h2 id="参数类型总结"><a href="#参数类型总结" class="headerlink" title="参数类型总结"></a>参数类型总结</h2><div class="table-container"><table><thead><tr><th style="text-align:left">参数类型</th><th style="text-align:left">修饰符</th><th style="text-align:left">是否在声明时使用</th><th style="text-align:left">是否在调用时使用</th><th style="text-align:left">执行</th></tr></thead><tbody><tr><td style="text-align:left">值</td><td style="text-align:left">无</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">系统把实参的值复制到形参</td></tr><tr><td style="text-align:left">引用</td><td style="text-align:left">ref</td><td style="text-align:left">是</td><td style="text-align:left">是</td><td style="text-align:left">形参是实参的别名</td></tr><tr><td style="text-align:left">输出</td><td style="text-align:left">out</td><td style="text-align:left">是</td><td style="text-align:left">是</td><td style="text-align:left">仅包含一个返回的值。形参是实参的别名</td></tr><tr><td style="text-align:left">数组</td><td style="text-align:left">params</td><td style="text-align:left">是</td><td style="text-align:left">否</td><td style="text-align:left">允许传递可变数目的实参到方法</td></tr></tbody></table></div><blockquote><p>值参数主要用于传递数据；引用参数用于修改数据；输出参数用于方法输出多个值。</p></blockquote><h2 id="ref-局部变量和-ref-返回"><a href="#ref-局部变量和-ref-返回" class="headerlink" title="ref 局部变量和 ref 返回"></a>ref 局部变量和 ref 返回</h2><p>ref 关键字允许传递一个对象引用给方法调用，在调用上下文中，对对象的改动在方法返回后依然可见；<br><strong>ref 返回</strong>允许将一个引用发送到方法外，然后在调用上下文内使用这个引用；<br>与 ref 返回相关的功能是<strong>ref 局部变量</strong>，允许一个变量是另一个变量的别名。</p><h3 id="ref-局部变量"><a href="#ref-局部变量" class="headerlink" title="ref 局部变量"></a>ref 局部变量</h3><p>可以使用该功能创建一个变量的别名，对任意一个变量的赋值都会反映到另一个变量上，因为引用的是相同的对象，即使是值类型。</p><p>创建别名的语法需要使用关键字 ref 两次：<code>ref int y = ref x;</code></p><p>当 x 改变时，y 也会变，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">ref</span> <span class="built_in">int</span> y = <span class="keyword">ref</span> x;</span><br><span class="line">        Console.WriteLine( <span class="string">$&quot;x = <span class="subst">&#123;x&#125;</span>, y = <span class="subst">&#123;y&#125;</span>&quot;</span> );</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">        Console.WriteLine( <span class="string">$&quot;x = <span class="subst">&#123;x&#125;</span>, y = <span class="subst">&#123;y&#125;</span>&quot;</span> );</span><br><span class="line">        y = <span class="number">6</span>;</span><br><span class="line">        Console.WriteLine( <span class="string">$&quot;x = <span class="subst">&#123;x&#125;</span>, y = <span class="subst">&#123;y&#125;</span>&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">x = 2, y = 2</span><br><span class="line">x = 5, y = 5</span><br><span class="line">x = 6, y = 6</span><br></pre></td></tr></table></figure><h3 id="ref-返回"><a href="#ref-返回" class="headerlink" title="ref 返回"></a>ref 返回</h3><p>ref 局部变量通常和 ref 返回功能一起使用。ref 返回功能提供了一种使方法返回变量引用而不是变量值的方法。也需要使用 ref 关键字2次：一次在方法的返回类型声明之前；另一次在 return 关键字之后。</p><p>示例如下，因为调用了修改 ref 局部变量的代码，所以类的字段值改变了：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Simple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> Score = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">ref</span> <span class="built_in">int</span> <span class="title">RefToValue</span>() <span class="comment">//ref 返回的方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">ref</span> Score; <span class="comment">//ref 返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( <span class="string">$&quot;Value inside class object: <span class="subst">&#123;Score&#125;</span>&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Simple s = <span class="keyword">new</span> Simple();</span><br><span class="line">        s.Display();</span><br><span class="line">        <span class="keyword">ref</span> <span class="built_in">int</span> v1Outside = <span class="keyword">ref</span> s.RefToValue(); <span class="comment">//ref 局部变量</span></span><br><span class="line"></span><br><span class="line">        v1Outside = <span class="number">10</span>; <span class="comment">//在调用域外修改值</span></span><br><span class="line">        s.Display(); <span class="comment">//检查值是否已经改变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Value inside class object: 5</span><br><span class="line">Value inside class object: 10</span><br></pre></td></tr></table></figure><p>另一个示例，Math.Max 能够返回两个值中较大的那个，若想返回较大值的变量的引用：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">ref</span> <span class="built_in">int</span> <span class="title">Max</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> p1, <span class="keyword">ref</span> <span class="built_in">int</span> p2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p1 &gt; p2 )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">ref</span> p1; <span class="comment">//返回引用而不是值</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">ref</span> p2; <span class="comment">//返回引用而不是值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> v1 = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> v2 = <span class="number">20</span>;</span><br><span class="line">        WriteLine(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">        WriteLine(<span class="string">$&quot;v1: <span class="subst">&#123;v1&#125;</span>, v2: <span class="subst">&#123;v2&#125;</span>\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ref</span> <span class="built_in">int</span> max = <span class="function"><span class="keyword">ref</span> <span class="title">Max</span>(<span class="params"><span class="keyword">ref</span> v1, <span class="keyword">ref</span> v2</span>)</span>;</span><br><span class="line">        WriteLine(<span class="string">&quot;After assignment&quot;</span>);</span><br><span class="line">        WriteLine(<span class="string">$&quot;max: <span class="subst">&#123;max&#125;</span>\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        max++;</span><br><span class="line">        WriteLine(<span class="string">&quot;After increment&quot;</span>);</span><br><span class="line">        WriteLine(<span class="string">$&quot;max: <span class="subst">&#123;max&#125;</span>, v1: <span class="subst">&#123;v1&#125;</span>, v2: <span class="subst">&#123;v2&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Start</span><br><span class="line">v1: 10, v2: 20</span><br><span class="line"></span><br><span class="line">After assignment</span><br><span class="line">max: 20</span><br><span class="line"></span><br><span class="line">After increment</span><br><span class="line">max: 21, v1: 10, v2: 21</span><br></pre></td></tr></table></figure><p>这个功能有如下限制：<br>①不能将返回类型是 void 的方法声明为 ref 返回方法；<br>②ref return 表达式不能返回：空值、常量、枚举成员、类或结构体的属性、指向只读位置的指针；<br>③ref 局部变量只能被赋值一次；<br>④即使一个方法声明为 ref 返回方法，如果在调用中省略了 ref 关键字，则返回的是指，而不是指向值的内存位置的指针；<br>⑤如果将 ref 局部变量作为常规的实际参数传递给其他方法，则该方法仅获取该变量的一个副本，尽管 ref 局部变量包含指向存储位置的指针，但是当以这种方法使用时，传递的是值而不是引用。</p><h2 id="方法重载-Method-Overloading"><a href="#方法重载-Method-Overloading" class="headerlink" title="方法重载 Method Overloading"></a>方法重载 Method Overloading</h2><p>一个类中可以有多个同名方法，叫做<strong>方法重载 method overloading</strong>。使用相同名称的每个方法必须有一个和其他方法不同的<strong>签名 signature</strong> 。</p><blockquote><p>和 python 的方法重载区分，继承中的叫方法覆写 method overriding 。</p></blockquote><p><em>返回类型不是签名的一部分，形参的名称也不是签名的一部分</em>：<code>long AddValues( int a, out int b) &#123; ... &#125;</code>的 AddValues( int a, out int b) 部分为签名，包括方法的名称、参数的数目、参数的数据类型和顺序、参数修饰符。</p><p>示例如下，下面4个方法都是方法名 AddValues 的重载：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">long</span> <span class="title">AddValues</span>(<span class="params"> <span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">long</span> <span class="title">AddValues</span>(<span class="params"> <span class="built_in">int</span> c, <span class="built_in">int</span> d, <span class="built_in">int</span> e</span>)</span> &#123; <span class="keyword">return</span> c + d + e; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">long</span> <span class="title">AddValues</span>(<span class="params"> <span class="built_in">float</span> f, <span class="built_in">float</span> g</span>)</span> &#123; <span class="keyword">return</span> (<span class="built_in">long</span>)(f + g); &#125;</span><br><span class="line">    <span class="function"><span class="built_in">long</span> <span class="title">AddValues</span>(<span class="params"> <span class="built_in">long</span> h, <span class="built_in">long</span> m</span>)</span> &#123; <span class="keyword">return</span> h + m; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非法的方法重载的示例如下，它们具有相同的签名，因为方法名相同，参数的数目、类型和顺序也相同。编译器会生成一条错误讯息：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">long</span> <span class="title">AddValues</span>(<span class="params"> <span class="built_in">long</span> a, <span class="built_in">long</span> b</span>)</span> &#123; <span class="keyword">return</span> a+b; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">AddValues</span>(<span class="params"> <span class="built_in">long</span> c, <span class="built_in">long</span> d</span>)</span> &#123; <span class="keyword">return</span> c+d; &#125; <span class="comment">//错误，相同的签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名参数-Named-Parameters"><a href="#命名参数-Named-Parameters" class="headerlink" title="命名参数 Named Parameters"></a>命名参数 Named Parameters</h2><p>上面用到的都是位置参数，可以使用<strong>命名参数</strong>在方法调用中显示指定参数名字，以任意顺序列出实参：<code>c.Calc ( c: 2, a: 4, b: 3);</code> </p><p>在调用时，可以同时使用位置参数和命名参数，但所有<strong>位置参数必须先列出</strong>，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calc</span>(<span class="params"> <span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> c </span>)</span></span><br><span class="line">    &#123; <span class="keyword">return</span> ( a + b ) * c; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass( );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> r0 = mc.Calc( <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span> ); <span class="comment">//位置参数</span></span><br><span class="line">        <span class="built_in">int</span> r1 = mc.Calc( <span class="number">4</span>, b: <span class="number">3</span>, c: <span class="number">2</span> ); <span class="comment">//位置参数和命名参数</span></span><br><span class="line">        <span class="built_in">int</span> r2 = mc.Calc( <span class="number">4</span>, c: <span class="number">2</span>, b: <span class="number">3</span> ); <span class="comment">//顺序变换</span></span><br><span class="line">        <span class="built_in">int</span> r3 = mc.Calc( c: <span class="number">2</span>, b: <span class="number">3</span>, a: <span class="number">4</span> ); <span class="comment">//命名参数</span></span><br><span class="line">        <span class="built_in">int</span> r4 = mc.Calc( c: <span class="number">2</span>, b: <span class="number">1</span> + <span class="number">2</span>, a: <span class="number">3</span> + <span class="number">1</span> ); <span class="comment">//命名参数表达式</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; r0 &#125;</span>, <span class="subst">&#123; r1 &#125;</span>, <span class="subst">&#123; r2 &#125;</span>, <span class="subst">&#123; r3 &#125;</span>, <span class="subst">&#123; r4 &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可选参数-Optional-Parameters"><a href="#可选参数-Optional-Parameters" class="headerlink" title="可选参数 Optional Parameters"></a>可选参数 Optional Parameters</h2><p><strong>可选参数</strong>需要在方法声明中提供<strong>默认值</strong>，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calc</span>(<span class="params"> <span class="built_in">int</span> a, <span class="built_in">int</span> b = <span class="number">3</span> </span>) <span class="comment">//可选参数和默认值</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">        <span class="built_in">int</span> r0 = mc.Calc( <span class="number">5</span>, <span class="number">6</span> ); <span class="comment">//使用显示值</span></span><br><span class="line">        <span class="built_in">int</span> r1 = mc.Calc( <span class="number">5</span> ); <span class="comment">//b使用默认值</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; r0 &#125;</span>, <span class="subst">&#123; r1 &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：<br>①可选参数只能是值参数，不能是 ref 、 out 、 params 参数，且只要值类型的默认值在编译时可以确定，就可以使用值类型作为可选参数。只有在默认值是 null 的时候，引用类型才可以作为可选参数；<br>②所有必填参数 required parameters 必须在可选参数声明之前声明；如果有 params 参数，必须在所有可选参数之后声明。</p><div  align="center">  <img src="https://s2.loli.net/2022/12/06/HrlmvtKgde7EWZc.png" width = "60%" height = "60%" alt="图22 - 参数语法顺序"/></div><h2 id="栈帧-Stack-Frames"><a href="#栈帧-Stack-Frames" class="headerlink" title="栈帧 Stack Frames"></a>栈帧 Stack Frames</h2><p>局部变量和参数是位于栈上的，在调用方法时，内存从栈的顶部开始分配，保存和方法关联的数据项。这块内存叫做方法的<strong>栈帧 stack frame</strong> 。</p><p>栈帧包含的内存保存如下内容：<br>①返回地址，即方法退出时继续执行的位置；<br>②分配内存的参数，方法的值参数，或参数数组；<br>③和方法调用有关的其他管理数据项。</p><p>在方法调用时，整个栈帧都会压入栈；在方法退出时，整个栈帧会从栈上弹出。弹出栈帧有时候叫做<strong>栈展开 unwind the stack</strong> 。</p><p>示例如下，Main 调用了 MethodA ，MethodA 又调用了 MethodB ，创建了3个栈帧。在方法退出时，栈展开：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MethodA</span>(<span class="params"> <span class="built_in">int</span> par1, <span class="built_in">int</span> par2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Enter MethodA: <span class="subst">&#123; par1 &#125;</span>, <span class="subst">&#123; par2 &#125;</span>&quot;</span>);</span><br><span class="line">        MethodB(<span class="number">11</span>, <span class="number">18</span>); <span class="comment">//调用MethodB</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Exit MethodA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MethodB</span>(<span class="params"><span class="built_in">int</span> par1, <span class="built_in">int</span> par2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Enter MethodB: <span class="subst">&#123; par1 &#125;</span>, <span class="subst">&#123; par2 &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Exit MethodB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Enter Main&quot;</span>);</span><br><span class="line">        MethodA( <span class="number">15</span>, <span class="number">30</span>); <span class="comment">//调用MethodA</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Exit Main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Enter Main</span><br><span class="line">Enter MethodA: 15, 30</span><br><span class="line">Enter MethodB: 11, 18</span><br><span class="line">Exit MethodB</span><br><span class="line">Exit MethodA</span><br><span class="line">Exit Main</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/12/06/dPNMrXqxDuSelB7.png" width = "60%" height = "60%" alt="图23 - 一个简单程序中的栈帧"/></div><h2 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归 Recursion"></a>递归 Recursion</h2><p><strong>递归</strong>：方法调用自身。递归每次方法调用都把新的栈帧压入栈顶，随着递归越来越深，栈也越来越大：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Count</span>(<span class="params"><span class="built_in">int</span> inVal</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inVal == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Count(inVal - <span class="number">1</span>); <span class="comment">//调用自身</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; inVal &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Program pr = <span class="keyword">new</span> Program();</span><br><span class="line">        pr.Count(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/12/06/bhVKIcY2DPuT4qF.png" width = "65%" height = "65%" alt="图24 - 用递归的方法构建和展开栈的示例"/></div><h1 id="第七章-深入理解类"><a href="#第七章-深入理解类" class="headerlink" title="第七章 深入理解类"></a>第七章 深入理解类</h1><h2 id="类成员-1"><a href="#类成员-1" class="headerlink" title="类成员"></a>类成员</h2><div class="table-container"><table><thead><tr><th style="text-align:left">数据成员（保存数据）</th><th style="text-align:left">函数成员（执行代码）</th></tr></thead><tbody><tr><td style="text-align:left">字段 Fields <br> 常量 Constants</td><td style="text-align:left">方法 Methods&emsp; &emsp;运算符 Operators <br> 属性 Properties &emsp; &emsp;索引 Indexers <br> 构造函数 Constructors &emsp; &emsp;事件 Events <br> 析构函数 Destructors</td></tr></tbody></table></div><h2 id="成员修饰符的顺序"><a href="#成员修饰符的顺序" class="headerlink" title="成员修饰符的顺序"></a>成员修饰符的顺序</h2><p>类成员声明语句由下列部分组成：<strong>核心声明</strong>、一组可选的<strong>修饰符 modifiers</strong> 和一组可选的<strong>特性 attributes</strong> 。语法如下，方括号内的成分是可选的：<br><code>[特性] [修饰符] 核心声明</code></p><p>①修饰符：若有多个修饰符，可以任意顺序排列。<br>②特性：若有多个特性，可以任意顺序排列。在第25章介绍特性。</p><p>比如以下代码在语义上是等价的（public 和 static 都是修饰符，返回类型是核心声明的一部分）：<br><code>public static int MaxVal;</code><br><code>static public int MaxVal;</code></p><h2 id="实例类成员-Instance-Class-Members"><a href="#实例类成员-Instance-Class-Members" class="headerlink" title="实例类成员 Instance Class Members"></a>实例类成员 Instance Class Members</h2><p>类成员可以关联到类的一个实例，也可以关联到整个类。类的每个实例都拥有自己的各自类成员的副本，称为<strong>实例成员</strong>。改变一个实例字段的值，不会影响其他实例成员的值。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Mem1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        D d1 = <span class="keyword">new</span> D();</span><br><span class="line">        D d2 = <span class="keyword">new</span> D();</span><br><span class="line">        d1.Mem1 = <span class="number">10</span>; d2.Mem1 = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;d1 = <span class="subst">&#123; d1.Mem1 &#125;</span>, d2 = <span class="subst">&#123; d2.Mem1 &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">d1 = 10, d2 = 28</span><br></pre></td></tr></table></figure><h2 id="静态字段-Static-Fields"><a href="#静态字段-Static-Fields" class="headerlink" title="静态字段 Static Fields"></a>静态字段 Static Fields</h2><p>以上都是实例字段，类还可以拥有<strong>静态字段</strong>。静态字段被类的所有实例<strong>共享</strong>，所有实例都访问同一内存位置。使用 <strong>static 修饰符</strong>将字段声明为静态： </p><div  align="center">  <img src="https://s2.loli.net/2022/12/15/vjSrekiyVHofd6z.png" width = "80%" height = "80%" alt="图25 - 静态和非静态数据成员"/></div><h2 id="从类的外部访问静态成员"><a href="#从类的外部访问静态成员" class="headerlink" title="从类的外部访问静态成员"></a>从类的外部访问静态成员</h2><p><strong>点运算符</strong>由实例名、点和成员名组成。就像实例成员，静态成员也可以使用点运算符从外部访问，因为没有实例，所以使用<em>类名</em>来访问静态成员：<code>D.Mem2 = 5;</code></p><p>访问静态成员的另一种方法不需要前缀，而是使用 using static 声明：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console; <span class="comment">// includes, amongst other members, Writeline()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Math; <span class="comment">// includes, amongst other members, Sqrt()</span></span><br><span class="line">...</span><br><span class="line">WriteLine(<span class="string">$&quot;The square root of 16 is <span class="subst">&#123; Sqrt(<span class="number">16</span>) &#125;</span>&quot;</span> );</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line">...</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;The square root of 16 is <span class="subst">&#123; Math.Sqrt(<span class="number">16</span>) &#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p>第22章详细介绍 using static 声明结构体。</p><h3 id="静态字段示例："><a href="#静态字段示例：" class="headerlink" title="静态字段示例："></a>静态字段示例：</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Mem1;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> Mem2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetVars</span>(<span class="params"><span class="built_in">int</span> v1, <span class="built_in">int</span> v2</span>) <span class="comment">//设置值</span></span></span><br><span class="line">    &#123;   Mem1 = v1; Mem2 = v2;   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"> <span class="built_in">string</span> str </span>)</span></span><br><span class="line">    &#123;   Console.WriteLine(<span class="string">&quot;&#123;0&#125;: Mem1= &#123;1&#125;, Mem2= &#123;2&#125;&quot;</span>, str, Mem1, Mem2);   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        D d1 = <span class="keyword">new</span> D(), d2 = <span class="keyword">new</span> D(); <span class="comment">//创建2个实例</span></span><br><span class="line"></span><br><span class="line">        d1.SetVars(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">//设置d1的值</span></span><br><span class="line">        d1.Display(<span class="string">&quot;d1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        d2.SetVars(<span class="number">15</span>, <span class="number">17</span>); <span class="comment">//设置d2的值</span></span><br><span class="line">        d2.Display(<span class="string">&quot;d2&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        d1.Display(<span class="string">&quot;d1&quot;</span>); <span class="comment">//注意，这时Mem2静态成员的值已改变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">d1: Mem1= 2, Mem2= 4</span><br><span class="line">d2: Mem1= 15, Mem2= 17</span><br><span class="line">d1: Mem1= 2, Mem2= 17</span><br></pre></td></tr></table></figure><h3 id="静态成员的生存期"><a href="#静态成员的生存期" class="headerlink" title="静态成员的生存期"></a>静态成员的生存期</h3><p>即使类没有实例，也存在静态成员，并且可以访问。</p><h2 id="静态函数成员-Static-Function-Members"><a href="#静态函数成员-Static-Function-Members" class="headerlink" title="静态函数成员 Static Function Members"></a>静态函数成员 Static Function Members</h2><p>如同静态字段，静态函数成员独立于任何类实例，没有实例也可以调用静态方法；<em>静态函数成员不能访问实例成员，但能访问其他静态成员</em>。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="built_in">int</span> A; <span class="comment">//静态字段</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintValA</span>() <span class="comment">//静态方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Value of A: &#123;0&#125;&quot;</span>, A); <span class="comment">//访问静态字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他静态类成员类型"><a href="#其他静态类成员类型" class="headerlink" title="其他静态类成员类型"></a>其他静态类成员类型</h2><p>可声明为 static 的类成员前面有勾号：</p><div class="table-container"><table><thead><tr><th style="text-align:left">数据成员（保存数据）</th><th style="text-align:left">函数成员（执行代码）</th></tr></thead><tbody><tr><td style="text-align:left">√ 字段 Fields <br> √ 类型 Types <br> 常量 Constants</td><td style="text-align:left">√ 方法 Methods <br> √ 运算符 Operators <br> √ 属性 Properties <br> 索引 Indexers <br> √ 构造函数 Constructors <br> √ 事件 Events</td></tr></tbody></table></div><h2 id="成员常量-Member-Constants"><a href="#成员常量-Member-Constants" class="headerlink" title="成员常量 Member Constants"></a>成员常量 Member Constants</h2><p>区分局部常量和成员常量，成员常量声明在类声明中而不是方法内：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> IntVal1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> IntVal2 = <span class="number">2</span> * IntVal1; <span class="comment">//用于初始化成员常量的值在编译时必须是可计算的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C# 没有全局常量，常量必须声明在类型中，与 C 和 C++ 不同。</p></blockquote><h2 id="常量和静态量-Constants-Are-Like-Statics"><a href="#常量和静态量-Constants-Are-Like-Statics" class="headerlink" title="常量和静态量 Constants Are Like Statics"></a>常量和静态量 Constants Are Like Statics</h2><p>常量非常像静态值，没有类的实例也可以使用，但常量没有自己的存储位置，而是在编译时被编译器替换。这种方式类似于 C 和 C++ 的 #define 值。</p><div  align="center">  <img src="https://s2.loli.net/2022/12/15/7YgDBGnX5zWKS9I.png" width = "75%" height = "75%" alt="图26 - 常量字段变现得像静态字段，但是在内存中没有存储位置"/></div><p>不能将常量声明为 static ：<code>static const double PI = 3.14; //错误</code></p><h2 id="属性-Properties"><a href="#属性-Properties" class="headerlink" title="属性 Properties"></a>属性 Properties</h2><p><strong>属性</strong>是代表类实例或类中数据项的成员。使用属性如同写入和读取字段，语法相同。  </p><p>与字段不同，属性是一个函数成员：<br>①它不一定为数据存储分配内存；<br>②它执行代码</p><p><strong>属性 Properties</strong> 是一个包含2个相关方法的被命名为<strong>访问器 accessors</strong> 的组合：<br>① <strong>set</strong> 访问器为属性赋值；<br>② <strong>get</strong> 访问器从属性获取值。</p><p>如下图，注意 - 访问器从后面伸出，因为它们不能直接被调用：</p><div  align="center">  <img src="https://s2.loli.net/2022/12/15/4AuSJHGaxwBvhP6.png" width = "60%" height = "60%" alt="图27 - int 类型的、名称为 MyValue 的属性示例"/></div><h3 id="属性声明和访问器"><a href="#属性声明和访问器" class="headerlink" title="属性声明和访问器"></a>属性声明和访问器</h3><p><strong>set</strong> 访问器总是：<br>①拥有一个单独的、隐式的值参，名称为 value，与属性的类型相同；<br>②拥有一个返回类型 void 。</p><p><strong>get</strong> 访问器总是：<br>①没有参数；<br>②拥有一个与属性类型相同的返回类型。</p><div  align="center">  <img src="https://s2.loli.net/2022/12/15/jwPlrzJe3Zs1tfk.png" width = "65%" height = "65%" alt="图28 - 属性声明的语法与结构"/></div><p>set 访问器中的隐式参数 value 和其他值参一样，可以用它发送数据到方法体或访问器块。  </p><p>访问器其他要点如下：<br>1、get 访问器和所有执行路径<em>必须包含一个 return 语句</em>，返回一个属性类型的值。<br>2、访问器 set 和 get 可以以任何顺序声明，并且，除了这两个访问器外，属性不允许有其他方法。</p><h3 id="属性示例"><a href="#属性示例" class="headerlink" title="属性示例"></a>属性示例</h3><p>属性本身没有任何存储，在下面的情况下，使用名为 TheRealValue 的字段作为存储：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">C1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> theRealValue; <span class="comment">//字段：分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MyValue <span class="comment">//属性：未分配内存</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; theRealValue = <span class="keyword">value</span>; &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> theRealValue; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/12/15/8VH1CPpoYmv5RUd.png" width = "35%" height = "35%" alt="图29 - 属性访问器常常使用字段作为存储"/></div><h3 id="使用属性"><a href="#使用属性" class="headerlink" title="使用属性"></a>使用属性</h3><p>写入和读取属性时，访问器会被隐式得调用：<br><code>MyValue = 5; //赋值：隐式地调用 set 方法</code><br><code>z = MyValue; //表达式：隐式地调用 get 方法</code></p><p>注意：不能显示地调用访问器，会产生编译错误。</p><h3 id="属性和关联字段-Properties-and-Associated-Fields"><a href="#属性和关联字段-Properties-and-Associated-Fields" class="headerlink" title="属性和关联字段 Properties and Associated Fields"></a>属性和关联字段 Properties and Associated Fields</h3><p>一种常见的方式是在类中将字段声明为 private 以封装该字段，并声明一个 public 属性来控制从类外部对该字段的访问。和属性关联的字段被称为<strong>后备字段 backing field </strong>或<strong>后备存储 backing store</strong>。</p><p>以下示例使用公有属性 MyValue 来控制对私有字段 theRealValue 的访问：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">C1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> theRealValue = <span class="number">10</span>; <span class="comment">//后备字段：分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MyValue <span class="comment">//属性：不分配内存</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span>&#123; theRealValue = <span class="keyword">value</span>; &#125; <span class="comment">//设置字段值</span></span><br><span class="line">        <span class="keyword">get</span>&#123; <span class="keyword">return</span> theRealValue; &#125; <span class="comment">//获取字段值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        C1 c = <span class="keyword">new</span> C1();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyValue: &#123;0&#125;&quot;</span>, c.MyValue); <span class="comment">//把属性看作字段，从中读取它的值</span></span><br><span class="line"></span><br><span class="line">        c.MyValue = <span class="number">20</span>; <span class="comment">//使用赋值语句设置属性的值</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyValue: &#123;0&#125;&quot;</span>, c.MyValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行其他计算"><a href="#执行其他计算" class="headerlink" title="执行其他计算"></a>执行其他计算</h3><p>访问器 get 和 set 能执行任何计算，下面若输入值大于100，就将 theRealValue 设置为100：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> theRealValue = <span class="number">10</span>; <span class="comment">//字段</span></span><br><span class="line"><span class="built_in">int</span> MyValue <span class="comment">//属性</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">set</span> &#123; theRealValue = <span class="keyword">value</span> &gt; <span class="number">100</span> ? <span class="number">100</span> : <span class="keyword">value</span>; &#125; <span class="comment">//条件运算符，见第9章</span></span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> theRealValue; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C# 7.0 为属性的 getter/setter 引入了使用<strong>表达函数体</strong>的语法，见第14章。这种语法只有在访问函数体由一个表达式组成的时候才能使用：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> MyValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">set</span> =&gt; <span class="keyword">value</span> &gt; <span class="number">100</span> ? <span class="number">100</span> : <span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">get</span> =&gt; theRealValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只读和只写属性-Read-Only-and-Write-Only-Properties"><a href="#只读和只写属性-Read-Only-and-Write-Only-Properties" class="headerlink" title="只读和只写属性 Read-Only and Write-Only Properties"></a>只读和只写属性 Read-Only and Write-Only Properties</h3><p>只有 get 访问器的属性称为<strong>只读属性</strong>；只有 set 访问器的属性称为<strong>只写属性</strong>。</p><p>两个访问器中至少有一个必须被定义，否则编译器会产生一条错误信息。</p><h3 id="属性与公有字段"><a href="#属性与公有字段" class="headerlink" title="属性与公有字段"></a>属性与公有字段</h3><p>根据实践，属性比公有字段更好：<br>①属性是函数成员不是数据成员，允许处理输入和输出；<br>②属性可以只读和只写，而字段不行；<br>③编译后的变量和编译后的属性语义不同。</p><h3 id="计算只读属性示例"><a href="#计算只读属性示例" class="headerlink" title="计算只读属性示例"></a>计算只读属性示例</h3><p>在大多示例中，属性都和一个后备字段关联，并且 get 和 set 访问器引用该字段。但是属性不是必须和字段关联：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RightTriangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> A = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> B = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Hypotenuse <span class="comment">//只读属性</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123; <span class="keyword">return</span> Math.Sqrt((A*A)+(B*B)); &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        RightTriangle c = <span class="keyword">new</span> RightTriangle();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Hypotenuse: <span class="subst">&#123; c.Hypotenuse &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/12/15/JfszWaUQgRqPrt5.png" width = "35%" height = "35%" alt="图30 - 只读属性 Hypotenuse"/></div><h3 id="自动实现属性"><a href="#自动实现属性" class="headerlink" title="自动实现属性"></a>自动实现属性</h3><p>因为属性经常被关联到后备字段，所以 C# 提供了<strong>自动实现属性</strong>（automatically implemented property 或 auto-implemented property，简称为<strong>自动属性 auto-property</strong>），允许只声明属性而不声明后备字段。编译器会自动创建隐藏的后备字段，并且自动挂接到 get 和 set 访问器上。</p><p>自动实现属性要点：<br>①不声明后备字段：编译器根据属性的类型分配存储；<br>②不能提供访问器的方法体：声明为分号。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">C1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MyValue <span class="comment">//分配内存，没有声明后备字段</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span>; <span class="keyword">get</span>; <span class="comment">//访问器的方法体被声明为分号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        C1 c = <span class="keyword">new</span> C1();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyValue: &#123;0&#125;&quot;</span>, c.MyValue);</span><br><span class="line"></span><br><span class="line">        c.MyValue = <span class="number">20</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyValue: &#123;0&#125;&quot;</span>, c.MyValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">MyValue: 0</span><br><span class="line">MyValue: 20</span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>属性也可以被声明为 static ，示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> ConsoleTestApp.Trivial;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleTestApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Trivial</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> MyValue &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintValue</span>()</span></span><br><span class="line">        &#123; Console.WriteLine(<span class="string">&quot;Value from inside: &#123;0&#125;&quot;</span>, MyValue); &#125; <span class="comment">//从类内部访问MyValue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Init Value: &#123;0&#125;&quot;</span>, Trivial.MyValue); <span class="comment">//从类外部访问MyValue</span></span><br><span class="line">            Trivial.MyValue = <span class="number">10</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;New Value : &#123;0&#125;&quot;</span>, Trivial.MyValue); <span class="comment">//从类外部访问MyValue</span></span><br><span class="line"></span><br><span class="line">            MyValue = <span class="number">20</span>; <span class="comment">//从类外部访问，但因为using static，所以可以省略类名</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;New Value : <span class="subst">&#123; MyValue &#125;</span>&quot;</span>);</span><br><span class="line">            Trivial tr = <span class="keyword">new</span> Trivial();</span><br><span class="line">            tr.PrintValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Init Value: 0</span><br><span class="line">New Value : 10</span><br><span class="line">New Value : 20</span><br><span class="line">Value from inside: 20</span><br></pre></td></tr></table></figure><h2 id="实例构造函数-Instance-Constructors"><a href="#实例构造函数-Instance-Constructors" class="headerlink" title="实例构造函数 Instance Constructors"></a>实例构造函数 Instance Constructors</h2><p><strong>实例构造函数</strong>是一个特殊的方法，它在创建类的每个新实例时执行。构造函数用于初始化类实例的状态；如果要从类的外部创建类的实例，需要将构造函数声明为 public 。</p><p>构造函数的名称和类名相同；构造函数不能有返回值。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>() <span class="comment">//声明为public，没有返回类型，和类名相同</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带参数的构造函数"><a href="#带参数的构造函数" class="headerlink" title="带参数的构造函数"></a>带参数的构造函数</h3><p>构造函数可以带参数，也可以被重载，和方法类似。</p><p>在使用创建对象表达式创建类的新实例时，要使用 new 运算符，后面跟着类的构造函数，new 运算符使用该构造函数创建类的实例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Class1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Id;</span><br><span class="line">    <span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Class1</span>()</span>            &#123; Id=<span class="number">28</span>; Name=<span class="string">&quot;Nemo&quot;</span>;  &#125; <span class="comment">//构造函数0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Class1</span>(<span class="params"><span class="built_in">int</span> val</span>)</span>     &#123; Id=val; Name=<span class="string">&quot;Nemo&quot;</span>; &#125; <span class="comment">//构造函数1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Class1</span>(<span class="params">String name</span>)</span> &#123; Name=name;           &#125; <span class="comment">//构造函数2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SoundOff</span>()</span></span><br><span class="line">    &#123; Console.WriteLine(<span class="string">$&quot;Name <span class="subst">&#123; Name &#125;</span>, Id <span class="subst">&#123; Id &#125;</span>&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Class1 a = <span class="keyword">new</span> Class1(), <span class="comment">//调用构造函数0</span></span><br><span class="line">               b = <span class="keyword">new</span> Class1(<span class="number">7</span>), <span class="comment">//调用构造函数1</span></span><br><span class="line">               c = <span class="keyword">new</span> Class1(<span class="string">&quot;Bill&quot;</span>); <span class="comment">//调用构造函数2</span></span><br><span class="line"></span><br><span class="line">        a.SoundOff();</span><br><span class="line">        b.SoundOff();</span><br><span class="line">        c.SoundOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Name Nemo, Id 28</span><br><span class="line">Name Nemo, Id 7</span><br><span class="line">Name Bill, Id 0</span><br></pre></td></tr></table></figure><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>如果在类中没有显示地提供实例构造函数，那么编译器会提供一个隐式的默认构造函数，它没有参数，方法体为空。若为类声明了构造函数，那么编译器将不会为该类定义默认构造函数。</p><p>如果声明了带参数的构造函数，那么试图使用不带参数的构造函数创建新的实例时，编译器会产生一条错误消息，因为没有无参数的构造函数。</p><h2 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h2><p>实例构造函数初始化类的每个新实例，而<strong>静态构造函数</strong>初始化类级别的项，通常，静态构造函数初始化类的静态字段。</p><p>静态构造函数的特点：<br>①类只能有一个静态构造函数，而且不能带参数；<br>②静态构造函数不能有访问修饰符（static 关键字不是访问修饰符）；<br>③类即可以有静态构造函数也可以有实例构造函数；<br>④如同静态方法，静态构造函数不能访问所在类的实例成员，因此不能使用 this 访问器；<br>⑤不能从程序中显示地调用静态构造函数，系统会自动调用它们：在类的任意实例被创建之前，在类的任意静态成员被引用之前。</p><p>示例如下，Random 是 BCL 提供的用于产生随机数的类，位于 System 命名空间中：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RandomNumberClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random RandomKey; <span class="comment">//私有静态字段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">RandomNumberClass</span>() <span class="comment">//静态构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        RandomKey = <span class="keyword">new</span> Random(); <span class="comment">//初始化RandomKey</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetRandomNumber</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> RandomKey.Next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        RandomNumberClass a = <span class="keyword">new</span> RandomNumberClass();</span><br><span class="line">        RandomNumberClass b = <span class="keyword">new</span> RandomNumberClass();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Next Random #: &#123;0&#125;&quot;</span>, a.GetRandomNumber());</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Next Random #: <span class="subst">&#123; b.GetRandomNumber() &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象初始化语句-Object-Initializers"><a href="#对象初始化语句-Object-Initializers" class="headerlink" title="对象初始化语句 Object Initializers"></a>对象初始化语句 Object Initializers</h2><p><strong>对象创建表达式</strong>由关键字 new 和类构造函数加参数列表组成。<br><strong>对象初始化语句</strong>扩展了创建语法，在表达式尾部加上一组成员初始化语句，利用对象初始化语句，可以在创建新的对象实例时，设置字段和属性的值。</p><p>该语法有两种形式：<br>①包括构造函数的参数列表：<code>new TypeName(ArgList) &#123; FieldOrProp = InitExpr, FieldOrProp = InitExpr, ...&#125;</code>；<br>②不包括构造函数的参数列表：<code>new TypeName &#123; FieldOrProp = InitExpr, FieldOrProp = InitExpr, ...&#125;</code>；</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Point pt1 = <span class="keyword">new</span> Point();</span><br><span class="line">        Point pt2 = <span class="keyword">new</span> Point &#123; X = <span class="number">5</span>, Y = <span class="number">6</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;pt1: &#123;0&#125;, &#123;1&#125;&quot;</span>, pt1.X, pt1.Y);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;pt2: <span class="subst">&#123; pt2.X &#125;</span>, <span class="subst">&#123; pt2.Y &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">pt1: 1, 2</span><br><span class="line">pt2: 5, 6</span><br></pre></td></tr></table></figure><h2 id="析构函数-Destructors"><a href="#析构函数-Destructors" class="headerlink" title="析构函数 Destructors"></a>析构函数 Destructors</h2><p><strong>析构函数</strong>执行在类的实例被销毁之前需要的清理或释放非托管资源的行为。非托管资源 Unmanaged resources 是指通过 Win32 API 获得的文件句柄 file handles ，或非托管内存块。详见第27章。</p><h2 id="readonly-修饰符"><a href="#readonly-修饰符" class="headerlink" title="readonly 修饰符"></a>readonly 修饰符</h2><p><strong>readonly 修饰符</strong>类似于将字段声明为 const，一旦值设置了就不能改变：<br>① const 字段只能在字段的声明语句中初始化，而 readonly 字段可以在下列任意位置设置它的值：<br>&ensp;&ensp;- 字段声明语句，类似于 const ；<br>&ensp;&ensp;- 类的任何构造函数。如果是 static 字段，初始化必须在静态构造函数中完成。<br>② const 字段的值必须可在编译时决定，而 readonly 字段的值可以在运行时决定。<br>③ const 的行为总是静态的，而对于 readonly 字段可以是实例字段，也可以是静态字段，并且在内存中有存储位置。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="built_in">double</span> PI = <span class="number">3.1416</span>; <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="built_in">int</span> NumberOfSides; <span class="comment">//未初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span>(<span class="params"><span class="built_in">double</span> side1, <span class="built_in">double</span> side2</span>) <span class="comment">//构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        NumberOfSides = <span class="number">4</span>; <span class="comment">//在构造函数中设定</span></span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span>(<span class="params"><span class="built_in">double</span> side1, <span class="built_in">double</span> side2, <span class="built_in">double</span> side3</span>)</span> &#123; </span><br><span class="line">        NumberOfSides = <span class="number">3</span>; <span class="comment">//在构造函数中设定</span></span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p><strong>this 关键字</strong>在类中是对当前实例的引用，只能被用在实例构造函数、实例方法、属性和索引器的实例访问器。</p><p>因为静态成员不是实例的一部分，所以不能在任何静态函数成员的代码中使用 this 关键字。this 主要用于区分类成员和局部变量或参数，以及作为调用方法的实参。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Var1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ReturnMaxSum</span>(<span class="params"><span class="built_in">int</span> Var1</span>) <span class="comment">//参数</span></span></span><br><span class="line">    &#123; Parameter Field</span><br><span class="line">        <span class="keyword">return</span> Var1 &gt; <span class="keyword">this</span>.Var1</span><br><span class="line">                    ? Var1 <span class="comment">//参数</span></span><br><span class="line">                    : <span class="keyword">this</span>.Var1; <span class="comment">//字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Max: <span class="subst">&#123; mc.ReturnMaxSum(<span class="number">30</span>) &#125;</span>&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Max: <span class="subst">&#123; mc.ReturnMaxSum(<span class="number">5</span>) &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然理解 this 关键字很重要，但是很少在代码中使用。</p><h2 id="索引器-Indexers"><a href="#索引器-Indexers" class="headerlink" title="索引器 Indexers"></a>索引器 Indexers</h2><p><strong>索引器</strong>允许用索引访问类字段。</p><h3 id="什么是索引器"><a href="#什么是索引器" class="headerlink" title="什么是索引器"></a>什么是索引器</h3><p><strong>索引器</strong>是一组 get 和 set 访问器，与属性类似：</p><div  align="center">  <img src="https://s2.loli.net/2022/12/16/aEWC8UMjmXOGA6i.png" width = "60%" height = "60%" alt="图31 - 索引器的表现形式"/></div><h3 id="索引器和属性"><a href="#索引器和属性" class="headerlink" title="索引器和属性"></a>索引器和属性</h3><p>①和属性一样，索引器不用分配内存来存储；<br>②索引器和属性都主要用来访问其他数据成员，与这些成员关联，并为它们提供获取和设置访问：<br>&ensp;&ensp;- 属性表示单个数据成员；<br>&ensp;&ensp;- 索引器表示多个数据成员。</p><blockquote><p>可以认为<strong>索引器</strong>是为类的多个数据成员提供 get 和 set 访问的<strong>属性</strong>。</p></blockquote><p>但索引器总是实例成员，因此不能被声明为 static 。</p><h3 id="声明索引器"><a href="#声明索引器" class="headerlink" title="声明索引器"></a>声明索引器</h3><p>声明索引器语法如下：<br>①索引器没有名称，在名称的位置是关键字 this ；<br>②参数列表在<strong>方括号</strong>内；<br>③参数列表必须至少声明一个参数。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ReturnType <span class="keyword">this</span> [ Type param1, ... ]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="索引器的-set-访问器"><a href="#索引器的-set-访问器" class="headerlink" title="索引器的 set 访问器"></a>索引器的 set 访问器</h3><p>当索引器被用于赋值，set 访问器被调用，并接受2种数据：<br>①一个名为 value 的隐式参数，其中持有要保存的数据；<br>②索引参数，表示数据应该保存在哪里。<br><code>emp[0] = &quot;Doe&quot;;</code></p><p>set 访问器的语法和含义如下图：</p><div  align="center">  <img src="https://s2.loli.net/2022/12/16/lUVajeY5kGuXJ8W.png" width = "70%" height = "70%" alt="图32 - set 访问器的语法和含义"/></div><p>左边是访问器声明的实际语法，右边展示了 set 访问器有如下语义：<br>①它的返回类型为 void ；<br>②它使用的参数列表和索引器声明中的相同；<br>③它有一个名为 value 的隐式参数，值参类型与索引器类型相同。</p><h3 id="索引器的-get-访问器"><a href="#索引器的-get-访问器" class="headerlink" title="索引器的 get 访问器"></a>索引器的 get 访问器</h3><p>当使用索引器获取值时，可以通过索引参数调用 get 访问器：<code>string s = emp[0];</code></p><p>get 访问器方法体内的代码必须检查索引参数，来确定它表示的是哪个字段，并返回该字段的值，语法和含义如下：</p><div  align="center">  <img src="https://s2.loli.net/2022/12/16/T4EuXyLAjODoW3h.png" width = "70%" height = "70%" alt="图33 - get 访问器的语法和含义"/></div><p>①get 访问器的参数列表和索引器声明中的相同；<br>②get 访问器返回与索引器类型相同的值。  </p><h3 id="关于索引器的更多内容"><a href="#关于索引器的更多内容" class="headerlink" title="关于索引器的更多内容"></a>关于索引器的更多内容</h3><p>和属性一样，不能显示地调用 get 和 set 访问器：<br><code>emp[0] = &quot;Doe&quot;; \\自动调用 set 访问器</code><br><code>string NewName = emp[0]; \\自动调用 get 访问器</code></p><h3 id="为类声明索引器示例"><a href="#为类声明索引器示例" class="headerlink" title="为类声明索引器示例"></a>为类声明索引器示例</h3><p>①下面的索引器需要读取 string 类型的值，所以索引器的类型要和字段一致，且索引器要声明为 public ，以便从类外部访问；<br>②若索引为整数，方括号内的 index 的形参需为 int 型。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName; <span class="comment">//调用字段0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> FirstName; <span class="comment">//调用字段1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CityOfBirth; <span class="comment">//调用字段2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index] <span class="comment">//索引器声明</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> <span class="comment">//set访问器声明</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: LastName = <span class="keyword">value</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: FirstName = <span class="keyword">value</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: CityOfBirth = <span class="keyword">value</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="literal">default</span>: <span class="comment">//异常，见第23章</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">get</span> <span class="comment">//get访问器声明</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> LastName;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> FirstName;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> CityOfBirth;</span><br><span class="line"></span><br><span class="line">                <span class="literal">default</span>: <span class="comment">//异常，见第23章</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="另一个索引器示例"><a href="#另一个索引器示例" class="headerlink" title="另一个索引器示例"></a>另一个索引器示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Class1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Temp0; <span class="comment">//私有字段</span></span><br><span class="line">    <span class="built_in">int</span> Temp1; <span class="comment">//私有字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span> [ <span class="built_in">int</span> index ] <span class="comment">//索引器</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ( <span class="number">0</span> == index ) <span class="comment">//返回Temp0或Temo1的值</span></span><br><span class="line">                        ? Temp0</span><br><span class="line">                        : Temp1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="number">0</span> == index )</span><br><span class="line">                Temp0 = <span class="keyword">value</span>; <span class="comment">//隐式变量value</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Temp1 = <span class="keyword">value</span>; <span class="comment">//隐式变量value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Class1 a = <span class="keyword">new</span> Class1();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Values -- T0: &#123;0&#125;, T1: &#123;1&#125;&quot;</span>, a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">15</span>;</span><br><span class="line">        a[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Values -- T0: <span class="subst">&#123; a[<span class="number">0</span>] &#125;</span>, T1: <span class="subst">&#123; a[<span class="number">1</span>] &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Values -- T0: 0, T1: 0</span><br><span class="line">Values -- T0: 15, T1: 20</span><br></pre></td></tr></table></figure><h3 id="索引器重载"><a href="#索引器重载" class="headerlink" title="索引器重载"></a>索引器重载</h3><p>只要索引器的参数列表不同，类就可以有任意多个索引器，类型不同不行。</p><h2 id="访问器的访问修饰符"><a href="#访问器的访问修饰符" class="headerlink" title="访问器的访问修饰符"></a>访问器的访问修饰符</h2><p>默认情况下，属性或索引器这两种函数成员的两个访问器（ get 和 set ）的访问级别与成员相同。即属性的访问级别是 public ，两个访问器的访问级别也是 public 。但是可以为两个访问器分配不同的访问级别。</p><p>如下代码展示了非常常见重要的示例，将 set 访问器声明为 private ，将 get 访问器声明为 public 。get 之所以是 public ，是因为属性的访问级别是 public 。这样尽管可以从类的外部读取属性，但只能从类内部设置它（该示例在构造函数内设置），是一个非常重要的封装工具：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125; <span class="comment">//不同访问级别的访问器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"> <span class="built_in">string</span> name </span>)</span> &#123; Name = name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person( <span class="string">&quot;Capt. Ernest Evans&quot;</span> );</span><br><span class="line">        Console.WriteLine( <span class="string">$&quot;Person&#x27;s name is <span class="subst">&#123; p.Name &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Person&#x27;s name is Capt. Ernest Evans</span><br></pre></td></tr></table></figure><p>访问器的访问修饰符有几个限制：<br>①仅当成员既有 get 访问器也有 set 访问器时，其访问器才能有访问修饰符；<br>②虽然两个访问器都必须出现，但是只有一个能有访问修饰符；<br>③访问器的访问修饰符的限制必须比成员的访问级别更严格：比如若属性的访问级别是 protected ，则唯一能对访问器使用的是 private 。</p><h2 id="分部类和分部类型-Partial-Classes-and-Partial-Types"><a href="#分部类和分部类型-Partial-Classes-and-Partial-Types" class="headerlink" title="分部类和分部类型 Partial Classes and Partial Types"></a>分部类和分部类型 Partial Classes and Partial Types</h2><p>类的声明可以分割为几个分部类的声明，类的分部类声明可以在不同文件里。每个分部类声明要标注为 partial class，比普通类增加了<strong>类型修饰符 partial</strong> 。</p><blockquote><p>类型修饰符 partial 不是关键字，所以在其他上下文中，可以被用作标识符。但是在关键字 class、struct 或 interface 之前时，表示分部类型。</p></blockquote><div  align="center">  <img src="https://s2.loli.net/2022/12/16/NzhGewJvAR1kYb2.png" width = "70%" height = "70%" alt="图34 - 使用分部类型来分割类"/></div><p>组成类的所有分部类声明必须在一起编译；除了分部类还有2种分部类型，分部结构（第11章）和分部接口（第16章）</p><h2 id="分部方法-Partial-Methods"><a href="#分部方法-Partial-Methods" class="headerlink" title="分部方法 Partial Methods"></a>分部方法 Partial Methods</h2><p>分部方法是声明在分部类中不同部分的方法，分部方法的不同部分可以声明在分部类的不同部分中。</p><p>分部方法的两个部分如下：<br>①定义分部方法声明：给出签名和返回类型，声明的实现部分只是一个分号；<br>②实现分部方法声明：给出签名和返回类型，以普通语句块形式实现。</p><p>定义声明和实现声明的签名和返回类型必须匹配：<br>&ensp;&ensp;- 返回类型必须是 void ；<br>&ensp;&ensp;- 签名不能包括访问修饰符，这使分部方法是隐式的 private ；<br>&ensp;&ensp;- 参数列表不能包括 out 参数；<br>&ensp;&ensp;- 定义和实现声明中都必须包含上下文关键字 partial ，并且直接在关键字 void 之前。</p><p>可以有定义部分而没有实现部分，此时编译器会把方法的声明和方法内部对方法的调用移除。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">PrintSum</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>; <span class="comment">//定义分部方法，注意分号，没有实现部分</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>) <span class="comment">//因为分部方法是隐式私有，PrintSum不能从类外部调用，所以用公有方法Add调用PrintSum</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        PrintSum(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">PrintSum</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>) <span class="comment">//实现分部方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sum is &#123;0&#125;&quot;</span>, x + y); <span class="comment">//实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">var</span> mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">    mc.Add(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Sum is 11</span><br></pre></td></tr></table></figure><h1 id="第八章-类和继承"><a href="#第八章-类和继承" class="headerlink" title="第八章 类和继承"></a>第八章 类和继承</h1><h2 id="类继承-Class-Inheritance"><a href="#类继承-Class-Inheritance" class="headerlink" title="类继承 Class Inheritance"></a>类继承 Class Inheritance</h2><p>通过<strong>继承</strong>定义一个新类，使用一个已存在的类作为新类的基础。已存在的类称为<strong>基类 base class</strong>，新类称为<strong>派生类 derived class</strong>。</p><p>要声明一个派生类，需要在类名后加上<strong>基类规格说明 class-base specification</strong>。<br>①基类规格说明由冒号和用作基类的类名称组成：<code>class OtherClass : SomeClass</code><br>②派生类成员包括本身声明中的成员以及基类的成员；<br>③派生类 <em>不能删除</em> 它所继承的任何成员。</p><h2 id="访问继承的成员"><a href="#访问继承的成员" class="headerlink" title="访问继承的成员"></a>访问继承的成员</h2><p>继承的成员可以被访问，就像它们是派生类自己声明的一样（构造函数特殊，见本章后面）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span> <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Field1 = <span class="string">&quot;base class field &quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>(<span class="params"> <span class="built_in">string</span> <span class="keyword">value</span> </span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Base class -- Method1: <span class="subst">&#123; <span class="keyword">value</span> &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">OtherClass</span>: <span class="title">SomeClass</span> &#123; <span class="comment">//派生类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Field2 = <span class="string">&quot;derived class field&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span>(<span class="params"> <span class="built_in">string</span> <span class="keyword">value</span> </span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Derived class -- Method2: <span class="subst">&#123; <span class="keyword">value</span> &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">        OtherClass oc = <span class="keyword">new</span> OtherClass();</span><br><span class="line"></span><br><span class="line">        oc.Method1( oc.Field1 ); <span class="comment">//以基类字段为参数的基类方法</span></span><br><span class="line">        oc.Method1( oc.Field2 ); <span class="comment">//以派生类字段为参数的基类方法</span></span><br><span class="line">        oc.Method2( oc.Field1 ); <span class="comment">//以基类字段为参数的派生类方法</span></span><br><span class="line">        oc.Method2( oc.Field2 ); <span class="comment">//以派生类字段为参数的派生类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Base class -- Method1: base class field </span><br><span class="line">Base class -- Method1: derived class field</span><br><span class="line">Derived class -- Method2: base class field</span><br><span class="line">Derived class -- Method2: derived class field</span><br></pre></td></tr></table></figure><h2 id="所有类都派生自-object-类"><a href="#所有类都派生自-object-类" class="headerlink" title="所有类都派生自 object 类"></a>所有类都派生自 object 类</h2><p>所有类都是派生类，<strong>类 object</strong> 是唯一的非派生类，它是所有继承层次的基础。没有基类规格说明的类隐式地直接派生自类 object。类声明显式地派生自 object 类和隐式地派生自 object 类在语义上是等价的。</p><p>一个类声明的基类规格说明中只能有一个单独的类，称为<strong>单继承 single inheritance</strong>。</p><h2 id="屏蔽基类的成员"><a href="#屏蔽基类的成员" class="headerlink" title="屏蔽基类的成员"></a>屏蔽基类的成员</h2><p>虽然派生类不能删除它继承的任何成员，但可以用与基类成员名称相同的成员来屏蔽 mask 基类成员。<br>①要屏蔽一个继承的数据成员，需要声明一个新的相同类型的成员，并使用相同的名称；<br>②要屏蔽一个继承的函数成员，需要声明一个新的带有相同签名的函数成员，签名包括名称和参数列表，不包括返回类型；<br>③最好使用 new 修饰符，虽然没有该修饰符，程序可以成功编译，但编译器会警告你隐藏了一个继承的成员；<br>④可以屏蔽静态成员。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span> <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Field1 = <span class="string">&quot;SomeClass Field1&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123; Console.WriteLine(<span class="string">$&quot;SomeClass.Method1: <span class="subst">&#123; <span class="keyword">value</span> &#125;</span>&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">OtherClass</span> : <span class="title">SomeClass</span> <span class="comment">//派生类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">public</span> <span class="built_in">string</span> Field1 = <span class="string">&quot;OtherClass Field1&quot;</span>; <span class="comment">//屏蔽基类成员</span></span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>) <span class="comment">//屏蔽基类成员</span></span></span><br><span class="line">        &#123; Console.WriteLine(<span class="string">$&quot;OtherClass.Method1: <span class="subst">&#123; <span class="keyword">value</span> &#125;</span>&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OtherClass oc = <span class="keyword">new</span> OtherClass(); <span class="comment">//使用屏蔽成员</span></span><br><span class="line">        oc.Method1(oc.Field1); <span class="comment">//使用屏蔽成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">OtherClass.Method1: OtherClass Field1</span><br></pre></td></tr></table></figure><h2 id="基类访问-Base-Access"><a href="#基类访问-Base-Access" class="headerlink" title="基类访问 Base Access"></a>基类访问 Base Access</h2><p>如果派生类必须访问被隐藏的继承成员，可以使用<strong>基类访问 base access</strong> 表达式，由<strong>关键字 base</strong> 和点加上成员的名称组成：<code>Console.WriteLine(&quot;&#123;0&#125;&quot;, base.Field1);</code></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123; <span class="comment">//基类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Field1 = <span class="string">&quot;Field1 -- In the base class&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">OtherClass</span> : <span class="title">SomeClass</span> &#123; <span class="comment">//派生类</span></span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">public</span> <span class="built_in">string</span> Field1= <span class="string">&quot;Field1 -- In the derived class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintField1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Field1); <span class="comment">//访问派生类</span></span><br><span class="line">        Console.WriteLine(<span class="keyword">base</span>.Field1); <span class="comment">//访问基类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OtherClass oc = <span class="keyword">new</span> OtherClass();</span><br><span class="line">        oc.PrintField1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Field1 -- In the derived class</span><br><span class="line">Field1 -- In the base class</span><br></pre></td></tr></table></figure><h2 id="使用基类的引用"><a href="#使用基类的引用" class="headerlink" title="使用基类的引用"></a>使用基类的引用</h2><p>派生类的实例由基类的实例和派生类新增的成员组成，派生类的引用指向整个类对象，包括基类部分。</p><p>如果有一个派生类对象的引用，就可以获取该对象基类部分的引用（使用<strong>类型转换运算符 cast operator</strong> 把引用转换 cast 为基类类型，详见第17章）。类型转换运算符放置在对象引用的前面，由圆括号括起的要被转换成的类名组成。将派生类对象强制转换为基类对象的作用是产生的变量只能访问基类的成员（在被覆写方法中除外，见本章后面）。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDerivedClass derived = <span class="keyword">new</span> MyDerivedClass(); <span class="comment">//创建一个对象</span></span><br><span class="line">MyBaseClass mybc = (MyBaseClass) derived; <span class="comment">//转换引用</span></span><br></pre></td></tr></table></figure><p>①第一行声明并初始化了变量 derived，它包含一个 MyDerivedClass 类型对象的引用；<br>②第二行声明了一个基类类型 MyBaseClass 的变量，并把 derived 中的引用转换为该类型，给出对象的基类部分的引用。  </p><div  align="center">  <img src="https://s2.loli.net/2022/12/20/qvf8azxGJnpZkAi.png" width = "70%" height = "70%" alt="图35 - 派生类的引用可以看到完整的 MyDerivedClass 对象，而 mybc 只能看到对象的 MyBaseClass 部分"/></div><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;This is the base class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDerivedClass</span> : <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> var1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;This is the derived class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDerivedClass derived = <span class="keyword">new</span> MyDerivedClass();</span><br><span class="line">        MyBaseClass mybc = (MyBaseClass)derived; <span class="comment">//转换为基类</span></span><br><span class="line"></span><br><span class="line">        derived.Print(); <span class="comment">//从派生类部分调用Print</span></span><br><span class="line">        mybc.Print(); <span class="comment">//从基类部分调用Print</span></span><br><span class="line">        <span class="comment">// mybc.var1 = 5; //错误：基类引用无法访问派生类成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">This is the derived class.</span><br><span class="line">This is the base class.</span><br></pre></td></tr></table></figure><h3 id="虚方法和覆写方法-Virtual-and-Override-Methods"><a href="#虚方法和覆写方法-Virtual-and-Override-Methods" class="headerlink" title="虚方法和覆写方法 Virtual and Override Methods"></a>虚方法和覆写方法 Virtual and Override Methods</h3><p>上面可以看到：当基类引用访问派生类对象时，得到的是基类成员。而<strong>虚方法 virtual methods</strong> 可以将基类引用升至派生方法内，需满足以下条件：<br>①派生类的方法和基类的方法有相同的签名和返回类型；<br>②基类方法使用 <strong>virtual</strong> 标注；<br>③派生类方法使用 <strong>override</strong> 标注；  </p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>() <span class="comment">//virtual方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;This is the base class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDerivedClass</span> : <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>() <span class="comment">//override方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;This is the derived class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDerivedClass derived = <span class="keyword">new</span> MyDerivedClass();</span><br><span class="line">        MyBaseClass mybc = (MyBaseClass)derived; <span class="comment">//转换至基类</span></span><br><span class="line"></span><br><span class="line">        derived.Print();</span><br><span class="line">        mybc.Print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">This is the derived class.</span><br><span class="line">This is the derived class.</span><br></pre></td></tr></table></figure><p>当使用基类引用 mybc 调用 Print 方法时，方法调用被传递到派生类并执行，因为基类的方法被标记为 virtual ，在派生类中有匹配的 override 方法。</p><div  align="center">  <img src="https://s2.loli.net/2022/12/21/fwOFbVB5CY1axjo.png" width = "60%" height = "60%" alt="图36 - 虚方法和覆写方法"/></div><p>其他说明：<br>①覆写和被覆写的方法要具有相同的可访问性，即不能一个 private 另一个 public ；<br>②不能覆写 static 方法或非虚方法；<br>③方法、属性和索引器，以及事件都可以被声明为 virtual 和 override 。</p><h3 id="覆写标记为-override-的方法"><a href="#覆写标记为-override-的方法" class="headerlink" title="覆写标记为 override 的方法"></a>覆写标记为 override 的方法</h3><p>覆写方法允许在继承的任何层次出现：<br>①当使用对象基类部分的引用调用一个被覆写的方法时，方法的调用被沿派生层次上溯执行，一直到标记为 override 的方法的<strong>最高派生 most-derived</strong> 版本；<br>②没标记为 override 不会被调用。</p><p>下面示例分2种情况，以下为2种情况的共同部分：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyBaseClass</span> <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">    &#123; Console.WriteLine(<span class="string">&quot;This is the base class.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDerivedClass</span> : <span class="title">MyBaseClass</span> <span class="comment">//派生类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">    &#123; Console.WriteLine(<span class="string">&quot;This is the derived class.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SecondDerived</span> : <span class="title">MyDerivedClass</span> <span class="comment">//最高派生类</span></span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">//见后面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>情况1</em></strong>：SecondDerived 的 Print 方法声明为 override ：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SecondDerived</span> : <span class="title">MyDerivedClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;This is the second derived class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SecondDerived derived = <span class="keyword">new</span> SecondDerived(); <span class="comment">//使用SecondDerived</span></span><br><span class="line">        MyBaseClass mybc = (MyBaseClass)derived; <span class="comment">//使用MyBaseClass</span></span><br><span class="line"></span><br><span class="line">        derived.Print();</span><br><span class="line">        mybc.Print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">This is the second derived class.</span><br><span class="line">This is the second derived class.</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/12/21/BZcQVES3n2DleoR.png" width = "60%" height = "60%" alt="图37 - 执行被传递到多层覆写链的顶端"/></div><p><strong><em>情况2</em></strong>：SecondDerived 的 Print 方法声明为 new ：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SecondDerived</span> : <span class="title">MyDerivedClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;This is the second derived class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SecondDerived derived = <span class="keyword">new</span> SecondDerived(); <span class="comment">//使用SecondDerived</span></span><br><span class="line">        MyBaseClass mybc = (MyBaseClass)derived; <span class="comment">//使用MyBaseClass</span></span><br><span class="line"></span><br><span class="line">        derived.Print();</span><br><span class="line">        mybc.Print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">This is the second derived class.</span><br><span class="line">This is the derived class.</span><br></pre></td></tr></table></figure><div  align="center">  <img src="https://s2.loli.net/2022/12/21/WIRHS71cFj9UQra.png" width = "60%" height = "60%" alt="图38 - 隐藏覆写的方法"/></div><h3 id="覆盖其他成员类型"><a href="#覆盖其他成员类型" class="headerlink" title="覆盖其他成员类型"></a>覆盖其他成员类型</h3><p>在属性上使用 virtual / override 的示例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _myInt = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">public</span> <span class="built_in">int</span> MyProperty</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _myInt; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyDerivedClass</span> : <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _myInt = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">public</span> <span class="built_in">int</span> MyProperty</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _myInt; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    MyDerivedClass derived = <span class="keyword">new</span> MyDerivedClass();</span><br><span class="line">    MyBaseClass mybc = (MyBaseClass)derived;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine( derived.MyProperty );</span><br><span class="line">    Console.WriteLine( mybc.MyProperty );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="构造函数的执行"><a href="#构造函数的执行" class="headerlink" title="构造函数的执行"></a>构造函数的执行</h2><p>派生类对象有一部分就是基类对象：要创建对象的基类部分，需要隐式调用基类的某个构造函数。继承层次链中的每个类在执行它自己的构造函数体之前执行它的基类构造函数。</p><p>创建一个实例的过程：<em>先初始化对象的所有实例成员，然后调用基类的构造函数，然后执行该类自己的构造函数体</em> 。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyDerivedClass</span> : <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> MyField1 = <span class="number">5</span>; <span class="comment">//1.成员初始化</span></span><br><span class="line">    <span class="built_in">int</span> MyField2; <span class="comment">//成员初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDerivedClass</span>() <span class="comment">//3.执行构造函数体</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBaseClass</span>() <span class="comment">//2.调用基类构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不建议在构造函数中调用虚方法，在执行基类的构造函数时，基类的虚方法会调用派生类的覆写方法，但是是在执行派生类的构造函数方法之前，因此调用会在派生类完全初始化之前传递到派生类。</p></blockquote><h3 id="构造函数初始化语句-Constructor-Initializers"><a href="#构造函数初始化语句-Constructor-Initializers" class="headerlink" title="构造函数初始化语句 Constructor Initializers"></a>构造函数初始化语句 Constructor Initializers</h3><p>默认情况下，在构造对象时，将调用基类的无参数构造函数。但因为构造函数可以重载，所以基类可能有一个以上的构造函数，若需要指定基类构造函数，需要在<strong>构造函数初始化语句</strong>中指定它。</p><p>构造函数初始化语句有两种形式：<br>①使用<strong>关键字 base</strong> 并指明使用哪一个基类构造函数：<strong>构造函数初始化语句</strong>由关键字 base 和要调用的基类构造函数的参数列表组成 - <code>public MyDerivedClass( int x, string s ) : base( s, x )</code>，基类参数列表中的参数必须在类型和顺序上与已定的基类构造方法的参数列表相匹配。当声明一个不带构造函数初始化语句的构造函数时，实际上是隐式调用 base( ) 构造函数初始化语句； </p><p>②使用<strong>关键字 this</strong> 并指明使用当前类的哪一个构造函数：这种形式让构造过程（实际上是编译器）使用当前类中的其他构造函数。这种语法很有用的一个情形是：一个类有好几个构造函数，它们都需要在对象构造中执行一些公共代码，此时可以将公共代码提取出来作为一个构造函数，然后被其他所有的构造函数用作<strong>构造函数初始化语句</strong>。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="built_in">int</span> firstVar;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="built_in">double</span> secondVar;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> UserName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> UserIdNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyClass</span>(<span class="params"> </span>) <span class="comment">//私有构造函数执行其他构造函数共用的初始化</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        firstVar = <span class="number">20</span>;</span><br><span class="line">        secondVar = <span class="number">30.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"> <span class="built_in">string</span> firstName </span>) : <span class="title">this</span>() <span class="comment">//使用构造函数初始化语句</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        UserName = firstName;</span><br><span class="line">        UserIdNumber = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"> <span class="built_in">int</span> idNumber </span>) : <span class="title">this</span>(<span class="params"> </span>) <span class="comment">//使用构造函数初始化语句</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        UserName = <span class="string">&quot;Anonymous&quot;</span>;</span><br><span class="line">        UserIdNumber = idNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类访问修饰符-Class-Access-Modifiers"><a href="#类访问修饰符-Class-Access-Modifiers" class="headerlink" title="类访问修饰符 Class Access Modifiers"></a>类访问修饰符 Class Access Modifiers</h3><p>类的<strong>可访问性 accessibility</strong>（可访问 accessible 也被称为 可见 visible）只有两个级别：<strong>public</strong> 和 <strong>internal</strong> 。</p><blockquote><p>区分类的可访问性和成员的可访问性。</p></blockquote><p>①标记为 public 的类可以被系统内任何程序集中的代码访问；<br>②标记为 internal 的类只能被它自己所在的程序集内的类看到。这是默认的可访问级别，除非类声明中显式地指定修饰符 public，否则程序集外部的代码不能访问该类。</p><h2 id="程序集间的继承"><a href="#程序集间的继承" class="headerlink" title="程序集间的继承"></a>程序集间的继承</h2><p>C# 允许从一个在不同的程序集内定义的基类来派生类，条件如下：<br>①基类必须被声明为 public ；<br>②必须在 Visual Studio 工程中的 References 节点中添加对包含该基类的程序集的引用，若要不使用它们的完全限定名称 fully qualified names，可以在源文件放置一个 using 指令，加上要访问的类或类型所在的命名空间。</p><blockquote><p>增加对其他程序集的引用和增加 using 指令是两回事。增加对其他程序集的引用是告诉编译器所需的类型在哪里定义；增加 using 指令允许你引用其他的类而不必使用它们的完全限定名称。详见第22章。</p></blockquote><p>示例，以下代码来自两个不同的程序集：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源文件名称为Assembly1.cs</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">BaseClassNS</span> <span class="comment">//包含基类声明的命名空间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyBaseClass</span> &#123; <span class="comment">//声明为公有的，使它对程序集的外部可见</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintMe</span>()</span> &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;I am MyBaseClass&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//源文件名称为Assembly2.cs</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> BaseClassNS; <span class="comment">//包含基类声明的命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UsesBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">DerivedClass</span>: <span class="title">MyBaseClass</span> <span class="comment">//在其他程序集中的基类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//空类体</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            DerivedClass mdc = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">            mdc.PrintMe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员访问修饰符"><a href="#成员访问修饰符" class="headerlink" title="成员访问修饰符"></a>成员访问修饰符</h2><p>对类的可访问性，只有两种修饰符：internal 和 public。而<strong>成员的可访问性</strong>包括5个级别：<strong>public</strong> 、<strong>private</strong> 、<strong>protected</strong> 、<strong>internal</strong> 、<strong>protected internal</strong>。</p><p>①所有显式声明在类声明中的成员都是互相可见的，无论它们的访问性如何；<br>②继承的成员不在类的声明中显式声明，所有继承的成员对派生类的成员可以是可见的，也可以是不可见的；<br>③隐式访问级别为 private；<br>④成员的可访问性受限于它的类，若类的可访问性是 internal，无论类成员的访问修饰符是什么，类成员在程序集的外部也不可见。</p><h3 id="访问成员的区域"><a href="#访问成员的区域" class="headerlink" title="访问成员的区域"></a>访问成员的区域</h3><p>下面的类声明了5种访问级别的成员：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Member1;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> Member2;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> Member3;</span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">int</span> Member4;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">internal</span> <span class="built_in">int</span> Member5;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>另一个类能否访问这些成员取决于：另一个类是否派生自 MyClass 类；另一个类是否和 MyClass 类在同一个程序集。</p><p>以上2个特征可以划分出4个集合，如下图：</p><div  align="center">  <img src="https://s2.loli.net/2023/01/02/vWAestKFfy5VZPH.png" width = "65%" height = "65%" alt="图39 - 访问性的区域划分"/></div><h3 id="公有成员的可访问性"><a href="#公有成员的可访问性" class="headerlink" title="公有成员的可访问性"></a>公有成员的可访问性</h3><p>public 访问级别是限制最少的，所有类，包括程序集内部的类和外部的类都可以自由地访问成员。</p><div  align="center">  <img src="https://s2.loli.net/2023/01/02/6X835OUSyNsAVQr.png" width = "65%" height = "65%" alt="图40 - 公有类的公有成员对同一程序集或其他程序集的所有类可见"/></div><h3 id="私有成员的可访问性"><a href="#私有成员的可访问性" class="headerlink" title="私有成员的可访问性"></a>私有成员的可访问性</h3><p>private 访问级别最严格：<br>① private 类成员只能被它自己的类成员访问，不能被其他类访问，包括继承它的类；<br>② private 成员可以被嵌套在它的类中的类成员访问，嵌套类在第27章。</p><div  align="center">  <img src="https://s2.loli.net/2023/01/02/EIxvhMCU3RrKnpd.png" width = "65%" height = "65%" alt="图41 - 任何类的私有成员只对它自己的类（或嵌套类）的成员可见"/></div><h3 id="受保护成员的可访问性"><a href="#受保护成员的可访问性" class="headerlink" title="受保护成员的可访问性"></a>受保护成员的可访问性</h3><p>protected 访问级别比 private 访问级别多了允许派生自该类的类访问该成员，即使程序集外部继承该类的类也能访问该成员。</p><div  align="center">  <img src="https://s2.loli.net/2023/01/02/CA5WMfa9dEhjDHG.png" width = "65%" height = "65%" alt="图42 - 公有类的受保护成员对它自己的类成员或派生类的成员可见，派生类可以在其他程序集中"/></div><h3 id="内部成员的可访问性"><a href="#内部成员的可访问性" class="headerlink" title="内部成员的可访问性"></a>内部成员的可访问性</h3><p>标记为 internal 的成员对程序集内部的所有类可见，但对程序集外部的类不可见。</p><div  align="center">  <img src="https://s2.loli.net/2023/01/02/H3bdXBgxQmt7e9Z.png" width = "65%" height = "65%" alt="图43 - 内部成员对同一程序集内部的任何类成员可见，但对程序集外部的类不可见"/></div><h3 id="受保护内部成员的可访问性"><a href="#受保护内部成员的可访问性" class="headerlink" title="受保护内部成员的可访问性"></a>受保护内部成员的可访问性</h3><p>标记为 protected internal 的成员对所有继承该类的类以及程序集内部的所有类可见，是 protected 和 internal 的并集而不是交集。</p><div  align="center">  <img src="https://s2.loli.net/2023/01/02/pj4qbnR9hOcG8vr.png" width = "65%" height = "65%" alt="图44 - 公有类的受保护内部成员对相同程序集的类成员或继承该类的类成员可见，它对其他程序集中不继承该类的类不可见"/></div><h3 id="成员访问修饰符小结"><a href="#成员访问修饰符小结" class="headerlink" title="成员访问修饰符小结"></a>成员访问修饰符小结</h3><div class="table-container"><table><thead><tr><th style="text-align:left">修饰符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">private</td><td style="text-align:left">只在类内部可访问</td></tr><tr><td style="text-align:left">internal</td><td style="text-align:left">对该程序集内所有类可访问</td></tr><tr><td style="text-align:left">protected</td><td style="text-align:left">对所有继承该类的类可访问</td></tr><tr><td style="text-align:left">protected internal</td><td style="text-align:left">对所有继承该类或在该程序集内声明的类可访问</td></tr><tr><td style="text-align:left">public</td><td style="text-align:left">对任何类可访问</td></tr></tbody></table></div><p><div  align="center">  <img src="https://s2.loli.net/2023/01/02/NSo5x8qFrzABnTp.png" width = "40%" height = "40%" alt="图45 - 各种成员访问修饰符的相对可访问性"/></div></p><p></p><table>    <thead>    <tr>        <th></th>        <th colspan="2">同一程序集内的类</th>         <th colspan="2">不同程序集内的类</th>    </tr>    </thead>    <tbody>    <tr>        <td></td>        <td>非派生</td>        <td>派生</td>        <td>非派生</td>        <td>派生</td>    </tr>    <tr>        <td>private</td>        <td></td>        <td></td>        <td></td>        <td></td>       </tr>    <tr>        <td>internal</td>        <td>√</td>        <td>√</td>        <td></td>        <td></td>       </tr>    <tr>        <td>protected</td>        <td></td>        <td>√</td>        <td></td>        <td>√</td>       </tr>    <tr>        <td>protected internal</td>        <td>√</td>        <td>√</td>        <td></td>        <td>√</td>       </tr>    <tr>        <td>public</td>        <td>√</td>        <td>√</td>        <td>√</td>        <td>√</td>       </tr></table><h2 id="抽象成员-Abstract-Members"><a href="#抽象成员-Abstract-Members" class="headerlink" title="抽象成员 Abstract Members"></a>抽象成员 Abstract Members</h2><p><strong>抽象成员</strong>是指被设计为被覆写的函数成员，具有以下特征：<br>①必须是一个函数成员，字段和常量不能为抽象成员；<br>②必须用 <strong>abstract</strong> 修饰符标记；<br>③不能有实现代码块，抽象成员的代码用分号表示。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintStuff</span>(<span class="params"><span class="built_in">string</span> s</span>)</span>; <span class="comment">//分号代替实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="built_in">int</span> MyProperty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span>; <span class="comment">//分号代替实现</span></span><br><span class="line">    <span class="keyword">set</span>; <span class="comment">//分号代替实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象成员只可以在抽象类中声明，一共有4种类型的成员可以被声明为抽象：方法；属性；事件；索引器。</p><p>其他事项：<br>①尽管抽象成员必须在派生类中用相应的成员覆写，但是不能把 virtual 修饰符附加到 abstract 修饰符；<br>②类似于虚成员，派生类中抽象成员的实现必须指定 override 修饰符。</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">虚成员</th><th style="text-align:left">抽象成员</th></tr></thead><tbody><tr><td style="text-align:left">关键字</td><td style="text-align:left">virtual</td><td style="text-align:left">abstract</td></tr><tr><td style="text-align:left">实现体</td><td style="text-align:left">有实现体</td><td style="text-align:left">没有实现体，被分号取代</td></tr><tr><td style="text-align:left">在派生类中被覆写</td><td style="text-align:left">能被覆写，使用 override</td><td style="text-align:left">必须被覆写，使用 override</td></tr><tr><td style="text-align:left">成员的类型</td><td style="text-align:left">方法 属性 事件 索引器</td><td style="text-align:left">方法 属性 事件 索引器</td></tr></tbody></table></div><h2 id="抽象类-Abstract-Classes"><a href="#抽象类-Abstract-Classes" class="headerlink" title="抽象类 Abstract Classes"></a>抽象类 Abstract Classes</h2><p>抽象类是指被设计为被继承的类，<strong>抽象类</strong>只能被用作其他类的基类。<br>①不能创建抽象类的实例；<br>②抽象类使用 abstract 修饰符声明；<br>③抽象类可以包含抽象成员或非抽象成员；<br>④抽象类自己可以派生自另一个抽象类；<br>⑤任何派生自抽象类的类必须使用 override 关键字实现该类所有的抽象成员，除非派生类自己也是抽象类。</p><h3 id="抽象类和抽象方法的示例"><a href="#抽象类和抽象方法的示例" class="headerlink" title="抽象类和抽象方法的示例"></a>抽象类和抽象方法的示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbClass</span> <span class="comment">//抽象类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IdentifyBase</span>() <span class="comment">//普通方法</span></span></span><br><span class="line">    &#123; Console.WriteLine(<span class="string">&quot;I am AbClass&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IdentifyDerived</span>()</span>; <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">AbClass</span> <span class="comment">//派生类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IdentifyDerived</span>() <span class="comment">//抽象方法的实现</span></span></span><br><span class="line">    &#123; Console.WriteLine(<span class="string">&quot;I am DerivedClass&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// AbClass a = new AbClass(); //错误，抽象类不能实例化</span></span><br><span class="line">        <span class="comment">// a.IndentifyDrived();</span></span><br><span class="line"></span><br><span class="line">        DerivedClass b = <span class="keyword">new</span> DerivedClass(); <span class="comment">//实例化派生类</span></span><br><span class="line">        b.IdentifyBase(); <span class="comment">//调用继承的方法</span></span><br><span class="line">        b.IdentifyDerived(); <span class="comment">//调用抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">I am AbClass</span><br><span class="line">I am DerivedClass</span><br></pre></td></tr></table></figure><h3 id="抽象类的另一个例子"><a href="#抽象类的另一个例子" class="headerlink" title="抽象类的另一个例子"></a>抽象类的另一个例子</h3><p>注意，数据成员不能被声明为 abstract 。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">MyBase</span> <span class="comment">//抽象和非抽象成员的组合</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> SideLength = <span class="number">10</span>; <span class="comment">//数据成员</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> TriangleSideCount = <span class="number">3</span>; <span class="comment">//数据成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintStuff</span>(<span class="params"> <span class="built_in">string</span> s </span>)</span>; <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="built_in">int</span> MyInt &#123; <span class="keyword">get</span>; <span class="keyword">set</span>;&#125; <span class="comment">//抽象属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">PerimeterLength</span>() <span class="comment">//普通的非抽象方法</span></span></span><br><span class="line">    &#123; <span class="keyword">return</span> TriangleSideCount * SideLength; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">MyBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrintStuff</span>(<span class="params"> <span class="built_in">string</span> s </span>) <span class="comment">//覆写抽象方法</span></span></span><br><span class="line">    &#123; Console.WriteLine( s ); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _myInt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> MyInt <span class="comment">//覆写抽象属性</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _myInt; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _myInt = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> <span class="built_in">string</span>[] args </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line">        mc.PrintStuff( <span class="string">&quot;This is a string&quot;</span> );</span><br><span class="line">        mc.MyInt = <span class="number">28</span>;</span><br><span class="line">        Console.WriteLine( mc.MyInt );</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Perimeter Length: <span class="subst">&#123; mc.PerimeterLength( ) &#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">This is a string</span><br><span class="line">28</span><br><span class="line">Perimeter Length: 30</span><br></pre></td></tr></table></figure><h2 id="密封类-Sealed-Classes"><a href="#密封类-Sealed-Classes" class="headerlink" title="密封类 Sealed Classes"></a>密封类 Sealed Classes</h2><p>抽象类必须用作基类，不能被实例化。<strong>密封类</strong>相反，只能用作独立的类，不能被用作基类，使用 <strong>sealed</strong> 修饰符标注。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态类-Static-Classes"><a href="#静态类-Static-Classes" class="headerlink" title="静态类 Static Classes"></a>静态类 Static Classes</h2><p><strong>静态类</strong>的所有成员都是静态的，静态类用于存放不受实例影响的数据和函数。静态类的常见用途是创建一个包含一组数学方法和值的数学库。</p><p>静态类的特性如下：<br>①类本身必须标记为 static ；<br>②类的所有成员必须是静态的；<br>③类可以有一个静态构造函数，但不能有实例构造函数，因为不能创建该类的实例；<br>④静态类是隐式密封的，即不能继承静态类。</p><p>可以使用类名和成员名访问静态类成员，也可以通过使用 using static 指令来访问静态类的成员，而不必使用类名，详见第22章。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyMath</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> PI = <span class="number">3.14f</span>; <span class="comment">//成员必须是静态的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsOdd</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">        &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Times2</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">        &#123; <span class="keyword">return</span> <span class="number">2</span> * x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"> </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> val = <span class="number">3</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; is odd is &#123;1&#125;.&quot;</span>, val, MyMath.IsOdd(val));</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123; val &#125;</span> * 2 = <span class="subst">&#123; MyMath.Times2(val) &#125;</span>.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">3 is odd is True.</span><br><span class="line">3 * 2 = 6.</span><br></pre></td></tr></table></figure><h2 id="扩展方法-Extension-Methods"><a href="#扩展方法-Extension-Methods" class="headerlink" title="扩展方法 Extension Methods"></a>扩展方法 Extension Methods</h2><p><strong>扩展方法</strong>允许编写的方法和声明它的类之外的类关联。在现实世界中，扩展方法是一个特别有用的工具，几乎整个 LINQ 库都是通过扩展方法来实现的，见第20章。</p><p>通常，若想要向一个类型中添加方法，可以通过以下几种方式：修改源代码；在派生类中定义新的方法；以及，若无法修改或继承，在一个新类中编写一个方法使用该类的实例作为参数，示例如下：</p><p>要添加方法的类如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> D1; <span class="comment">//字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> D2;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> D3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyData</span>(<span class="params"><span class="built_in">double</span> d1, <span class="built_in">double</span> d2, <span class="built_in">double</span> d3</span>) <span class="comment">//构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        D1 = d1; D2 = d2; D3 = d3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Sum</span>() <span class="comment">//方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> D1 + D2 + D3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以编写以下的类，接受 MyData 的实例作为参数，来为上述类实现额外功能：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ExtendMyData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Average</span>(<span class="params"> MyData md </span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> md.Sum() / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyData md = <span class="keyword">new</span> MyData(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Average: &#123;0&#125;&quot;</span>, ExtendMyData.Average(md));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述方案只能用要改变的类的实例调用静态方法 <code>ExtendMyData.Average( md )</code>，不能直接在实例对象上调用方法 <code>md.Average();</code>。而<strong>扩展方法</strong>允许我们使用第二个形式，只需要将参数声明的类型名前增加关键字 <strong>this</strong> ，如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ExtendMyData</span> <span class="comment">//必须是一个静态类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Average</span>(<span class="params"> <span class="keyword">this</span> MyData md </span>) <span class="comment">//必须是公有的和静态的，必须包含关键字this和它所扩展的类的名称，作为第一个参数的类型</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展方法的重点要求如下：<br>①声明扩展方法的类必须声明为 static ；<br>②扩展方法本身必须声明为 public 和 static ；<br>③扩展方法的第一个参数必须包含关键字 this ，并且在后面指定扩展的类的名称。</p><p>完整的示例如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ExtensionMethods</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MyData</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">double</span> D1, D2, D3;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyData</span>(<span class="params"><span class="built_in">double</span> d1, <span class="built_in">double</span> d2, <span class="built_in">double</span> d3</span>)</span></span><br><span class="line">        &#123; D1 = d1; D2 = d2; D3 = d3; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Sum</span>()</span> &#123; <span class="keyword">return</span> D1 + D2 + D3; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ExtendMyData</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Average</span>(<span class="params"><span class="keyword">this</span> MyData md</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> md.Sum() / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            MyData md = <span class="keyword">new</span> MyData(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Sum: <span class="subst">&#123; md.Sum() &#125;</span>&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Average: &#123;0&#125;&quot;</span>, md.Average());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Sum: 12</span><br><span class="line">Average: 4</span><br></pre></td></tr></table></figure><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><p>3种主要的命名风格如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">风格名称</th><th style="text-align:left">描述</th><th style="text-align:left">推荐使用</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">Pascal 大小写</td><td style="text-align:left">标识符中每个单词的首字母大写</td><td style="text-align:left">用于类型名称和类中对外可见成员的名称。涉及的名称包括：类、方法、命名空间、属性和公有字段</td><td style="text-align:left">CardDeck、DealersHand</td></tr><tr><td style="text-align:left">Camel 大小写</td><td style="text-align:left">标识符中每个单词的首字母大写，第一个单词除外</td><td style="text-align:left">用于局部变量的名称和方法声明的形参名称</td><td style="text-align:left">totalCycleCount、randomSeedParam</td></tr><tr><td style="text-align:left">下划线加 Camel 大小写</td><td style="text-align:left">以下划线开头的 Camel 大小写标识符</td><td style="text-align:left">用于私有或受保护的字段</td><td style="text-align:left">_cycleCount、_selectedIndex</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> C#读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> .net </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blender偏好设置及插件记录</title>
      <link href="/2022/11/15/2022-11-15-blender-preference/"/>
      <url>/2022/11/15/2022-11-15-blender-preference/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章记录blender个人设置的偏好以及安装的插件，方便换电脑时重新设置。<br>blender可以将键位设置Keymap导出为python代码文件，然后导入到其他电脑。</p></blockquote><h1 id="偏好设置-Preferences"><a href="#偏好设置-Preferences" class="headerlink" title="偏好设置 Preferences"></a>偏好设置 Preferences</h1><p>1、界面 Interface - 编辑器 Editors - 状态栏 Status Bar - 场景统计数据 Scene Statistics：显示场景或选中区域的点、线、面数量等等。</p><p>2、系统 System - 内存&amp;限额 Memory&amp;Limits - 撤销次数 Undo Steps - 加大次数，大概128次或256次</p><p>3、插件 Add-ons - 节点：NW（Node：Node Wrangler）</p><p>4、插件 Add-ons - 添加网格：Extra Objects（Add Mesh：Extra Objects）</p><p>5、插件 Add-ons - 网格：编辑网格工具（Mesh：Edit Mesh Tools）</p><p>6、插件 Add-ons - 界面：Modifier Tools 修改器工具（Interface：Modifier Tools）</p><p>7、插件 Add-ons - 界面：Copy Attributes Menu 复制属性菜单（Interface：Copy Attributes Menu）</p><h1 id="非官方插件-Add-ons"><a href="#非官方插件-Add-ons" class="headerlink" title="非官方插件 Add-ons"></a>非官方插件 Add-ons</h1><p>1、BLT插件：一个综合的Blender资源和学习一体化的平台，包括插件翻译，资产库一键导入，和学习交流平台：<a href="https://pan.baidu.com/s/1o2-oQcnRf5Ivvx-xNoJpJA">https://pan.baidu.com/s/1o2-oQcnRf5Ivvx-xNoJpJA</a>或见一瓶辣椒酱的网站<a href="https://shimo.im/docs/ckYQ8xq6JhVtrGjh/read">https://shimo.im/docs/ckYQ8xq6JhVtrGjh/read</a>或者自己的百度云备份。</p><p>2、MACHIN3tools（M3工具）：一个免费开源的blender强化工具，它整合和优化了blender工作的高频操作，比如一键网格对齐、摄像机功能整合、物体属性整合等等，能在极大程度上提升工作效率。</p><p>①开发者的官方下载见<a href="https://github.com/machin3io/MACHIN3tools">https://github.com/machin3io/MACHIN3tools</a> - Code - Download ZIP<br>②或者使用一瓶辣椒酱的魔改版本<a href="https://shimo.im/docs/ckYQ8xq6JhVtrGjh/read">https://shimo.im/docs/ckYQ8xq6JhVtrGjh/read</a>，优化了快捷键，尽可能顺应用户习惯以及中文弥补，代码层面完善了BLT部分函数类型中文化。</p><p>3、Quixel Bridge插件：Epic旗下的三维扫描库，官网为<a href="https://quixel.com/">https://quixel.com/</a>，可用Epic账户登录，需要下载Bridge软件并下载其对应的Blender插件，这样可以直接在Bridge软件导入进Blender，不用一次一次下载再导入了。如果导入进来没有贴图，需要在偏好设置里的翻译一栏把新建数据勾上。</p><p>4、摄像机反求插件Fspy：一个免费开源的软件以及插件，官网为<a href="https://fspy.io">https://fspy.io</a>，其原理是通过2D图像或照片计算出相机的位置以及对应参数，并应用于静态合成工作，将3D渲染结果和2D图像融合。</p><h1 id="M3工具的快捷键"><a href="#M3工具的快捷键" class="headerlink" title="M3工具的快捷键"></a>M3工具的快捷键</h1>]]></content>
      
      
      <categories>
          
          <category> blender </category>
          
          <category> blender设置及插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blender </tag>
            
            <tag> 3d建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blender快捷键操作以及一些基础知识</title>
      <link href="/2022/11/10/2022-11-10-blender%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2022/11/10/2022-11-10-blender%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>快捷键要英文输入法！！！！！！</li><li>有些快捷键要选中物体。</li><li>区分小键盘的数字和数字键，小键盘会特别说明。</li><li>最好的教程就是blender自己的英文版官方手册</li><li>Blender保存后打开会自动清理没有被使用的数据，可以使用伪用户来保存未使用的数据</li><li>打包：将外部数据保存在blender工程中；解包：将blender工程数据保存在外部</li></ul><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="网格对象相关"><a href="#网格对象相关" class="headerlink" title="网格对象相关"></a>网格对象相关</h2><h3 id="物体模式下，移动、缩放、旋转等物体变化"><a href="#物体模式下，移动、缩放、旋转等物体变化" class="headerlink" title="物体模式下，移动、缩放、旋转等物体变化"></a>物体模式下，移动、缩放、旋转等物体变化</h3><ul><li>Grab抓取状态（移动）：<kbd>G</kbd><ul><li>再按<kbd>X</kbd>，锁定按x轴移动</li><li>再按<kbd>Y</kbd>，锁定按y轴移动</li><li>再按<kbd>Z</kbd>，锁定按z轴移动</li><li>按2次<kbd>X</kbd> or <kbd>Y</kbd> or <kbd>Z</kbd>，会按物体自己的局部坐标移动，前提是当前坐标系为全局；若为当前为局部坐标系，按一次为局部，二次为全局</li><li>按2次<kbd>G</kbd>，可以进行单一边线或顶点滑移</li></ul></li><li>同理缩放Scale、旋转Rotate：<kbd>S</kbd>、<kbd>R</kbd>，再对应X、Y、Z<ul><li>再按<kbd>shift</kbd> + <kbd>X</kbd>，锁定X轴，按Y、Z轴缩放（同理shift + Y、Z）</li><li>可以输入数字，来设置缩放大小和旋转角度</li><li>选择2个点按X或Y或Z轴方向对齐到2个点的中心，可以按<kbd>S</kbd> + <kbd>X、Y、Z</kbd> + <kbd>0</kbd></li></ul></li><li>重置移动、缩放、旋转：<kbd>alt</kbd> + <kbd>G or S or R</kbd></li><li>应用物体变化：<kbd>ctrl</kbd> + <kbd>A</kbd>；变换 -&gt; 增量的意思就是改变“归零点”，应用过增量后，移动、缩放、旋转变换物体后，重置移动、缩放、旋转回归的是增量应用后的位置。此时若要重置回到世界原点，可以勾选清除增量</li><li>镜像变换：<kbd>ctrl</kbd> + <kbd>M</kbd>，底部会有操作提示，可以按住<kbd>鼠标中键</kbd>拖拽</li></ul><h3 id="物体模式下，其他物体操作"><a href="#物体模式下，其他物体操作" class="headerlink" title="物体模式下，其他物体操作"></a>物体模式下，其他物体操作</h3><ul><li>添加对象：<kbd>shift</kbd> + <kbd>A</kbd></li><li>复制对象：<kbd>shift</kbd> + <kbd>D</kbd>；关联复制<kbd>alt</kbd> + <kbd>D</kbd>即2个物体对应同一个mesh，改动一个，另一个也会变</li><li>删除对象：<kbd>X</kbd> 或 <kbd>Del</kbd></li><li>物体合并join：<kbd>ctrl</kbd> + <kbd>J</kbd>，分离要进入编辑模式</li><li>移动游标：<kbd>shift</kbd> + <kbd>鼠标右键</kbd></li><li>调回添加物体设置菜单（微调面板）：<kbd>F9</kbd></li><li>侧边栏sidebar（n面板）：<kbd>N</kbd></li><li>工具栏：<kbd>T</kbd>可以隐藏/开启，小数字键盘的<kbd>+ 或 -</kbd>可以将UI放大缩小，也可以用鼠标拖拽让其并排显示</li><li>坐标系选择菜单：<kbd>,</kbd></li><li>轴心点选择菜单：<kbd>.</kbd></li><li>开关吸附功能：<kbd>shift</kbd> + <kbd>tab</kbd>，或者在移动物体时，按住<kbd>ctrl</kbd>来临时开启吸附功能</li><li>吸附上下文菜单：<kbd>shift</kbd> + <kbd>S</kbd></li><li>启用衰减编辑：<kbd>O</kbd></li><li>仅影响原点：<kbd>ctrl</kbd> + <kbd>.</kbd></li><li>重复上一步操作：<kbd>shift</kbd> + <kbd>R</kbd></li><li>建立父子级：选择多个物体按<kbd>ctrl</kbd> + <kbd>P</kbd>，活动项为父级，或者大纲视图（视图层）里把子级按住<kbd>shift</kbd>往父级拖</li><li>清空父级：选择子级按<kbd>alt</kbd> + <kbd>P</kbd>，或者大纲视图（视图层）里把子级按住<kbd>alt</kbd>往外拖</li><li>关联/传递数据：<kbd>ctrl</kbd> + <kbd>L</kbd>，根据最后的活动项关联</li><li>多个物体同时操作：选中多个物体，按住<kbd>alt</kbd>，可以同时操作设置多个物体</li></ul><h3 id="编辑模式下，选择点边面"><a href="#编辑模式下，选择点边面" class="headerlink" title="编辑模式下，选择点边面"></a>编辑模式下，选择点边面</h3><ul><li>编辑模式：<kbd>Tab</kbd><ul><li>编辑模式下，按<kbd>1</kbd>为点模式</li><li>编辑模式下，按<kbd>2</kbd>为线模式</li><li>编辑模式下，按<kbd>3</kbd>为面模式</li><li>按住<kbd>shift</kbd>再按<kbd>1或2或3</kbd>，可以同时选择多个模式（加选或减选）</li></ul></li><li>循环选择：<kbd>alt</kbd> + <kbd>鼠标左键</kbd></li><li>选择并排边：<kbd>ctrl</kbd>  + <kbd>alt</kbd>  + <kbd>鼠标左键</kbd></li><li>选择边界边：<kbd>alt</kbd> + <kbd>鼠标左键双击</kbd></li><li>最短路径选择：<kbd>ctrl</kbd> + <kbd>鼠标左键</kbd></li><li>反向选择（选择物体除了当前选择的部分）：<kbd>ctrl</kbd> + <kbd>I</kbd></li><li>加选或减选：<kbd>ctrl</kbd> + 小数字键盘的<kbd>+ 或 -</kbd></li><li>关联选择（选择相关联的所有点边面）：选中点、边、面 + <kbd>L</kbd>，鼠标要在选中的点、边、面附近，会受到划界的影响（详见微调菜单）；或者使用<kbd>ctrl</kbd> + <kbd>L</kbd></li></ul><h3 id="编辑模式下，常用工具"><a href="#编辑模式下，常用工具" class="headerlink" title="编辑模式下，常用工具"></a>编辑模式下，常用工具</h3><ul><li>挤出选区Extrude Region：<kbd>E</kbd>，快速挤出：<kbd>ctrl</kbd> + <kbd>鼠标右键</kbd><ul><li><strong>注意</strong>：按<kbd>E</kbd>后按右键取消，仍然会挤出，只不过重叠了看不见，需要撤销</li><li>挤出上下文菜单：<kbd>alt</kbd>  + <kbd>E</kbd></li></ul></li><li>内插面Inset Faces：<kbd>I</kbd><ul><li>上面会有操作提示</li><li>再按住<kbd>ctrl</kbd>控制深度；再按<kbd>O</kbd>外插；多个面，再按<kbd>I</kbd>分别内插；若面存在边界（即边旁边没有面），再按<kbd>B</kbd>，可让边界边不内插。</li></ul></li><li>切割工具Knife：<kbd>K</kbd>，并按回车确认<ul><li>下面会有操作提示</li><li>按住<kbd>shift</kbd>开启中点吸附，按住<kbd>ctrl</kbd>取消吸附</li><li>按<kbd>C</kbd>可以开启切穿立体，最好在正交图下切穿，并且在下刀前开启</li><li>在按钮模式下，关闭遮蔽几何体（上方），也可以切穿立体</li><li>切割下的切分工具，可以讲立体一分为二，轴阈值可以让切线吸附至最近点或线</li></ul></li><li>倒角（斜切）Bevel：<kbd>ctrl</kbd> + <kbd>B</kbd><ul><li>下面会有操作提示</li><li>注意宽度类型：偏移量、宽度、深度、百分比和绝对的区别，斜切面的长度为宽度，原边到斜切面的边（垂直距离）为偏移量，原边到斜切面的距离为深度，百分比为临边的百分比，绝对为临边的绝对距离</li><li>上下滚动鼠标滚轮，会增减斜切细分Segments的数量，即更平滑</li><li>多细分的情况下，按<kbd>P</kbd>可以控制内凹还是外凸，即形状轮廓参数（默认0.5为圆）</li><li>微调菜单中<strong>硬化法向</strong>可以平滑倒角的同时不影响原始面法向</li><li><strong>外斜接的补块和圆弧</strong>以及<strong>内部的圆弧</strong>可以更优化处理多条连接的线的倒角导致的连接问题；相交类型自动的栅格填充会自动填充多个相交边同时倒角产生的面，截止则会不产生该面</li><li>轮廓类型的自定义里面包括阶梯类型等等</li><li>一般为边倒角，<strong>顶点倒角</strong>为<kbd>ctrl</kbd> + <kbd>shift</kbd> + <kbd>B</kbd>，可以使用该方法来给平面中心开洞（配合球形化工具），或者让曲线变的圆滑</li><li>建议的倒角段数为2的倍数，比如4</li></ul></li><li>环切Loop Cut（环切并滑移）：<kbd>ctrl</kbd> + <kbd>R</kbd><ul><li>上下滚动鼠标滚轮，会增减环切边的数量</li><li>上面会有操作提示</li><li>输入数字，来设置环切边的数量</li><li>微调菜单中的<strong>均匀</strong>和<strong>翻转</strong>指的是环切的相邻的边非平行情况下使环切线优先匹配其中一条边</li><li>偏移环切边：<kbd>ctrl</kbd> + <kbd>shift</kbd> + <kbd>R</kbd>，和倒角类似，但是若选中的边非直线，偏移环切边和环切模式类似，新生成的线是选中的边和它平行的边的平均化后的线（使用均匀或翻转可以改变该模式），而倒角则完全是原来选中的边的样子。微调菜单中还有个封盖端点的功能</li></ul></li><li>多边形建形工具Poly Build：选择此工具后<ul><li>当编辑模式下，没有点时，按住<kbd>ctrl</kbd> + <kbd>左键单击</kbd>，可以生成点，可以按住<kbd>左键</kbd>拖动点</li><li>当存在面后，该工具会预选择或者说是捕捉到一条线（蓝色的线）按住<kbd>ctrl</kbd> + <kbd>左键单击</kbd>，会形成三角形，再次按住<kbd>ctrl</kbd>，形成三角形，2个三角形会形成四边形。也可以按住<kbd>左键</kbd>拖动，挤出边（四边形）</li><li>按住<kbd>shift</kbd> + <kbd>左键</kbd>可以快捷删除线（四边形面）或点（三角形）</li></ul></li><li>旋绕工具Spin：以3D游标为中心，按圆形挤出<ul><li>旋转方向的不同会改变法线的方向，需注意法线的方向</li></ul></li><li>光滑工具Smooth<ul><li>（光滑）平滑顶点：当有多个顶点时，微调菜单中的重复次数可以增加所影响的面（因为一次只影响相邻顶点）</li></ul></li><li>滑移工具Slide<ul><li>双击<kbd>G</kbd>可以对单一边线或者单一顶点进行滑移，操作提示在上方</li><li>顶点滑移：可以选取多个顶点并按<kbd>shift</kbd> + <kbd>V</kbd>进行滑移</li></ul></li><li>法向收缩：<kbd>alt</kbd> + <kbd>S</kbd><ul><li>法向收缩基于选择对象的法向进行缩放，而普通的S缩放基于轴心点缩放</li><li>推/拉：等距离的缩放，S缩放是等比例</li></ul></li><li>切变工具Shear<ul><li>切变以及球形化，球形化可以结合顶点倒角进行面开洞</li></ul></li><li>断离工具Rip：<kbd>V</kbd><ul><li>根据鼠标的位置系统自动确定断离的方向</li><li><strong>注意</strong>：按<kbd>V</kbd>后按右键取消，仍然会断离，只不过重叠了看不见，需要撤销</li><li>断离并进入滑移：<kbd>V</kbd> + <kbd>G</kbd></li><li>断离边线（挤出顶点并移动）：<kbd>alt</kbd> + <kbd>D</kbd>，可以快速加点，再按<kbd>G</kbd>可以进入滑移状态</li></ul></li></ul><h3 id="编辑模式下，其他操作"><a href="#编辑模式下，其他操作" class="headerlink" title="编辑模式下，其他操作"></a>编辑模式下，其他操作</h3><ul><li>选择菜单下的操作：<ul><li>全选：<kbd>A</kbd>，弃选：<kbd>alt</kbd> + <kbd>A</kbd></li><li>框选：<kbd>B</kbd>，刷选：<kbd>C</kbd>，按住<kbd>shift</kbd>拖动鼠标取消选取</li><li>反转（反向选择）：<kbd>ctrl</kbd> + <kbd>I</kbd></li><li>选择相似菜单：<kbd>shift</kbd> + <kbd>G</kbd></li><li>有些操作见：编辑模式下，选择点边面</li></ul></li><li>网格菜单下的操作：<ul><li>重置蒙皮尺寸（即缩放蒙皮半径）：<kbd>ctrl</kbd> + <kbd>A</kbd>，见蒙皮修改器</li><li>吸附上下文菜单：<kbd>shift</kbd> + <kbd>S</kbd></li><li>合并上下文菜单：<kbd>M</kbd>，自动合并顶点在右上角开启</li><li>拆分上下文菜单：<kbd>alt</kbd> + <kbd>M</kbd>；拆分选中项：<kbd>Y</kbd></li><li>物体分离Separate：<kbd>P</kbd>，变为独立的物体</li><li>凸壳：根据物体生成罩体</li><li>法向上下文菜单：<kbd>alt</kbd>  + <kbd>N</kbd>；法向旋转可以用<kbd>R</kbd>  + <kbd>N</kbd></li><li><strong>清理菜单</strong>：精简几何体可以减少面数；简并融并可以融并面积为零的面或长度为零的边，可以去除重叠的点；有限融并根据夹角来融并点和线；平整表面可以把不可能的四边形恢复水平</li></ul></li><li>顶点菜单下的操作：<ul><li><kbd>ctrl</kbd> + <kbd>V</kbd>弹出顶点菜单，V for vertex</li><li>从顶点创建边/面：<kbd>F</kbd>；连接顶点路径：<kbd>J</kbd>；注意F和J的区别，F是架桥，不影响沿途边线（相当于新连接的线会与沿途的边线重叠在一个面上）；J是修路，会切断沿途边和面，在一个面上使用连接顶点建议使用<kbd>J</kbd>，但是J无法连接彼此完全分离的点</li><li>打开顶点组菜单：<kbd>ctrl</kbd> + <kbd>G</kbd></li><li>钩挂：<kbd>ctrl</kbd> + <kbd>H</kbd>，详见钩挂修改器</li></ul></li><li>边菜单下的操作：<ul><li><kbd>ctrl</kbd> + <kbd>E</kbd>弹出边菜单，E for edge</li><li>桥接循环边，或者搜索Bridge Edge Loops（需2组循环边）</li><li>边线折痕强度：<kbd>shift</kbd> + <kbd>E</kbd>并拖动</li></ul></li><li>面菜单下的操作：<ul><li><kbd>ctrl</kbd> + <kbd>F</kbd>弹出面菜单，F for face</li><li>尖分面：将面拆分为数个三角面，会新建一个中心点；面三角化：<kbd>ctrl</kbd> + <kbd>T</kbd>将面拆分为数个三角面，不会新建点</li><li>三角填充：<kbd>alt</kbd> + <kbd>F</kbd></li><li>交集（切割）与交集（布尔）为自带的布尔运算</li></ul></li><li>快速收藏夹：<kbd>Q</kbd>，可以在想添加按钮右键选择添加到快速收藏夹，之后就可以使用这个快捷使用</li></ul><h2 id="曲线对象相关"><a href="#曲线对象相关" class="headerlink" title="曲线对象相关"></a>曲线对象相关</h2><h3 id="曲线编辑模式下相关操作"><a href="#曲线编辑模式下相关操作" class="headerlink" title="曲线编辑模式下相关操作"></a>曲线编辑模式下相关操作</h3><ul><li>曲线的样条类型：①多段线：控制点连线为固定的直线；②贝塞尔；③NURBS(非均匀有理B样条)</li><li>可以在视图叠加层开启全部控制柄，这样可以不先选中控制柄再调节，加快效率</li><li>贝塞尔曲线：控制点拥有权重、半径和倾斜属性（见N面板）<ul><li>自由线画笔工具：表(曲)面可以让线吸附至网格表面；锥化可以控制曲线控制点半径；偏移量指从表面偏移画笔，未开启绝对偏移时，偏移值为系数*半径</li><li>控制柄切换：<kbd>V</kbd>；对齐（粉色）：同控制点控制柄协同操控；自由（红色）：单独操控；自动（黄色）：转化为均值状态并自动适应，手动介入手柄会使其转换为对齐类型；矢量（绿色）：基于点连线，手动介入手柄转换为自由类型。重新计算控制柄：<kbd>shift</kbd> + <kbd>N</kbd></li><li>挤出工具：<kbd>E</kbd>；快速挤出：<kbd>ctrl</kbd> + <kbd>鼠标右键</kbd></li><li>调节半径：<kbd>alt</kbd> + <kbd>S</kbd></li><li>调节倾斜：<kbd>ctrl</kbd> + <kbd>T</kbd>，倾斜控制曲线法向的方向；重置倾斜：<kbd>alt</kbd> + <kbd>T</kbd></li><li>切换循环<kbd>alt</kbd> + <kbd>C</kbd>将曲线变为闭合状态；或者直接<kbd>F</kbd>首尾相连；或者在曲线属性的活动样条线里勾选循环</li></ul></li><li>NURBS(非均匀有理B样条)的每个控制点有个W值（见N面板），即weight，其根据控制点和W值进行曲线生成</li></ul><h2 id="视角、视图、窗口相关"><a href="#视角、视图、窗口相关" class="headerlink" title="视角、视图、窗口相关"></a>视角、视图、窗口相关</h2><h3 id="改变视角"><a href="#改变视角" class="headerlink" title="改变视角"></a>改变视角</h3><ul><li>旋转视角：<kbd>鼠标中键</kbd></li><li>缩放视角：<kbd>鼠标滚轮</kbd> 或者 <kbd>ctrl</kbd> + <kbd>鼠标中键</kbd></li><li>平移视角：<kbd>shift</kbd> + <kbd>鼠标中键</kbd></li><li>快速聚焦：小数字键盘上的<kbd>·</kbd>，或者按住<kbd>~</kbd>选择View Selected</li><li>快速回归全场景（聚焦全场景）：<kbd>Home</kbd></li><li>隐藏物体：<kbd>H</kbd></li><li>隐藏所有除选中物体：<kbd>shift</kbd> + <kbd>H</kbd></li><li>取消所有隐藏：<kbd>alt</kbd> + <kbd>H</kbd></li><li>第一人称视角：<kbd>shift</kbd> + <kbd>~</kbd>，底部会有操作提示</li></ul><h3 id="视图快捷键"><a href="#视图快捷键" class="headerlink" title="视图快捷键"></a>视图快捷键</h3><ul><li>正交前视图：小数字键盘<kbd>1</kbd>；后视图：<kbd>ctrl</kbd> + 小数字键盘<kbd>1</kbd></li><li>正交右视图：小数字键盘<kbd>3</kbd>；左视图：<kbd>ctrl</kbd> + 小数字键盘<kbd>3</kbd></li><li>正交顶视图：小数字键盘<kbd>7</kbd>；底视图：<kbd>ctrl</kbd> + 小数字键盘<kbd>7</kbd></li><li>以上直接使用右上角xyz的那个坐标轴比较方便</li><li>视角对齐物体局部坐标的xyz轴：<kbd>shift</kbd> + 小数字键盘<kbd>1或3或7</kbd></li><li>视图反转：小数字键盘<kbd>9</kbd></li><li>透视图和正交视图的切换：小数字键盘<kbd>5</kbd></li><li>四格视图：<kbd>ctrl</kbd> + <kbd>alt</kbd> + <kbd>Q</kbd></li><li>局部视图（只显示选中的物体，可以多选）：<kbd>/</kbd>，再次点击退出局部视图</li><li>最大化视窗（窗口）：<kbd>ctrl</kbd> + <kbd>空格</kbd>，根据鼠标的位置选择最大化的窗口，再次点击退出；全屏视窗：<kbd>ctrl</kbd> + <kbd>alt</kbd> + <kbd>空格</kbd>，同上</li><li>视图着色方式菜单：<kbd>Z</kbd>；透视模式：<kbd>alt</kbd> + <kbd>Z</kbd>，透视模式 + 线框模式：<kbd>shift</kbd> + <kbd>Z</kbd></li></ul><h3 id="摄像机相关"><a href="#摄像机相关" class="headerlink" title="摄像机相关"></a>摄像机相关</h3><ul><li>切换到摄像机视角：小数字键盘的<kbd>0</kbd>，摄像机视图大小，受 Output properties 输出属性的 Format 格式中 Resolution 分辨率控制，默认1920px*1080px</li><li>摄像机镜头对齐到当前屏幕视角：<kbd>ctrl</kbd> + <kbd>alt</kbd> + 小数字键盘的<kbd>0</kbd>，或者N面板上的view，选择Camera to View</li><li>切换到摄像机视角后，并且Camera to View（锁定摄像机到视图方位），可以开启第一人称视角（<kbd>shift</kbd> + <kbd>~</kbd>）来移动（微调）摄像机</li></ul><h1 id="其他名词解释"><a href="#其他名词解释" class="headerlink" title="其他名词解释"></a>其他名词解释</h1><ul><li><strong>缝合边Seam</strong>：UV展开的边；<strong>锐边Sharp</strong>：自动平滑不影响的边；<strong>Freestyle边</strong>：模型的轮廓边（比如三渲二下模型的描边效果）</li><li>形态键Shape Keys：用于记录顶点排布方式</li><li>纹理空间Texture Space：纹理图案映射到三维物体表面的区域，可以通过改变纹理空间配合UV改变纹理的显示区域和效果</li><li>平滑着色Shade Smooth：改变了面的法向的方向从而改变了表面着色，造成光滑表面的错觉（可以平滑着色后看看法线方向的变化）。法线与着色相互关联，完全拆分拆分法向（可以在视图叠加层显示拆分法向）可以模拟锐利的棱（即锐边），完全合并拆分法向可以模拟平滑。</li><li>纹理基础：<ul><li>图像：RGB三条通道混合产生颜色，通道位宽（bit）影响精度，而每条通道位宽可以以灰度信息进行存储，比如8 bit（0-255）为例，0即黑色对应通道贡献为0，255即白色对应通道贡献为1；而Alpha通道存储透明信息，黑色即alpha为0，显示为绝对透明，白色即alpha为1，显示为绝对不透明</li><li>高动态范围图像 HDRI 或 HDR (High Dynamic Range Imaging)，比普通8 bit RGB图像拥有更大的亮度范围，HDR文件通常使用32位浮点数来存储每个像素的颜色值；EXR文件使用16位或者32位浮点数格式</li><li>Alpha直通型：RGB先混合再乘Alpha；预乘型：RGB分别乘Alpha再混合；主要因为sRGB是非线性色彩空间，所以直通型和预乘型会有不同效果；通道打包：Alpha不与RGB通道相乘，互不影响，因为RGBA包含4个灰度通道，可以在每个通道里存储不同的灰度信息，从而1张图可以当4个灰度图使用，从而节约内存空间</li></ul></li></ul><h1 id="修改器相关操作"><a href="#修改器相关操作" class="headerlink" title="修改器相关操作"></a>修改器相关操作</h1><p>修改器的优势在于其操作可逆，更能满足动画的需求</p><h2 id="通用修改器操作"><a href="#通用修改器操作" class="headerlink" title="通用修改器操作"></a>通用修改器操作</h2><ul><li>批量应用修改器：物体模式下，<kbd>ctrl</kbd> + <kbd>A</kbd>，选择可视几何-&gt;网格；或者使用官方插件（界面：Modifier Tools 修改器工具），可以直接在修改器上面全部应用</li><li>在一个物体内复制修改器：鼠标放在要复制的修改器上<kbd>shift</kbd> + <kbd>D</kbd></li><li>复制/传递修改器至其他物体：物体模式下，<kbd>ctrl</kbd> + <kbd>L</kbd>，选择复制修改器（注意复制的是最后选择的活动项的修改器）；或者使用官方插件（界面：Copy Attributes Menu 复制属性菜单），选择要被复制的物体，加上最后选择的提供修改器属性的物体，按<kbd>ctrl</kbd> + <kbd>C</kbd>选择复制修改器；或者使用修改器的下拉菜单（同上最后选择活动项）点击复制到选定项</li><li>大纲视图里也可以改变修改器的顺序；也可以在大纲里把修改器拖至其他物体，实现复制/传递修改器的效果</li><li>注意：法向会影响到修改器的效果</li></ul><h2 id="生成类-generate-修改器"><a href="#生成类-generate-修改器" class="headerlink" title="生成类 generate 修改器"></a>生成类 generate 修改器</h2><p>生成修改器能够影响整个网格的拓扑，侧重处理原始网格生成新的结构，往往伴随着点边面的数量变化</p><h3 id="阵列修改器-Array"><a href="#阵列修改器-Array" class="headerlink" title="阵列修改器 Array"></a>阵列修改器 Array</h3><ul><li>适配类型：根据数量、长度或者曲线（曲线的长度，与形状无关）来复制网格物体</li><li>相对偏移 = 原始网格边界框*系数；恒定偏移 = 质心点距离；物体偏移根据物体与参考物体质心点的距离偏移，同时可以传递缩放和旋转信息（比如在物体模式下对参考物体缩放），其实本质是传递位置、旋转和缩放的信息</li><li>合并选项可以合并距离小于设定值的顶点，注意可能会保留的内部面</li><li>UV选项可以让UV进行偏离，根据贴图的U或V方向偏离地显示一定区域</li><li>可以借助父级网格顶点、面来生成实例，实现类似阵列修改器的效果；也可以用实例化配合阵列修改器，让除网格外的物体也能形成阵列效果（阵列修改器只作用于网格物体）；实例化类似于面向对象的实例化对象的概念，实例化集合类似于引用，可以减少内存压力</li><li>也可以借助网格生成粒子毛发，将毛发替换为物体来实现类似阵列修改器的效果</li></ul><h3 id="倒角修改器-Bevel"><a href="#倒角修改器-Bevel" class="headerlink" title="倒角修改器 Bevel"></a>倒角修改器 Bevel</h3><ul><li>与编辑模式下的倒角工具类似，详见上面</li><li>限定方式选项的角度、权重以及顶点组可以对倒角的范围进行限制</li></ul><h3 id="布尔修改器-Boolean"><a href="#布尔修改器-Boolean" class="headerlink" title="布尔修改器 Boolean"></a>布尔修改器 Boolean</h3><ul><li>两种解算器：①快速：传统的布尔算法，速度快，但是对重叠孔洞等非流形表现不佳；②准确：更高准确度，但面数较多时需要更多算力，可能会卡顿</li><li>可以使用官方插件（物体：Bool工具，建议勾选快速转换和display as wireframe）来代替该修改器提高工作效率：被布尔的物体为画布，指定目标物体为笔刷，先选择笔刷，再选择被布尔的画布。Brush布尔是添加布尔修改器但是不应用，自动布尔直接应用修改器。快速转换勾选上，点击笔刷物体，开启快速可视化，可以在准确的解算器模式下移动笔刷物体而不卡顿（其实就是移动时暂时关闭了修改器的视图实时显示）。<kbd>ctrl</kbd> + <kbd>shift</kbd> + <kbd>B</kbd>可以跳出布尔工具菜单</li><li>法向会影响布尔的效果，笔刷物体的法向（着色）信息会传递到被布尔的物体，注意面朝向导致的布尔异常</li></ul><h3 id="建形修改器-Build"><a href="#建形修改器-Build" class="headerlink" title="建形修改器 Build"></a>建形修改器 Build</h3><ul><li>使网格物体根据时间推移一个面一个面得建立或消失，顺序跟网格元素排序有关</li><li>结合物体实例化、粒子系统来实现比如灯光等等的出现与消失</li></ul><h3 id="精简修改器-Decimate"><a href="#精简修改器-Decimate" class="headerlink" title="精简修改器 Decimate"></a>精简修改器 Decimate</h3><ul><li>用于减少面与顶点的数量，并尽量维持物体的结构</li><li>有三种算法：塌陷、反细分和平面。塌陷：渐进式地合并顶点；反细分：可以认为是反向的细分，它试图删除细分操作的结果；平面：减少角度低于角度限制的平面来精简面数</li></ul><h3 id="拆边修改器-Edge-Split"><a href="#拆边修改器-Edge-Split" class="headerlink" title="拆边修改器 Edge Split"></a>拆边修改器 Edge Split</h3><ul><li>将满足条件参数的边一分为二地拆开</li></ul><h3 id="遮罩修改器-Mask"><a href="#遮罩修改器-Mask" class="headerlink" title="遮罩修改器 Mask"></a>遮罩修改器 Mask</h3><ul><li>借助顶点组或骨架，对网格物体的网格进行遮蔽隐藏</li></ul><h3 id="镜像修改器-Mirror"><a href="#镜像修改器-Mirror" class="headerlink" title="镜像修改器 Mirror"></a>镜像修改器 Mirror</h3><ul><li>镜像中心默认为物体自身原点，可设置为其他物体</li><li>使用该修改器时，注意内部面的产生</li></ul><h3 id="表面细分修改器-Subdivision-Surface"><a href="#表面细分修改器-Subdivision-Surface" class="headerlink" title="表面细分修改器 Subdivision Surface"></a>表面细分修改器 Subdivision Surface</h3><ul><li>添加表面细分修改器：物体模式下，<kbd>ctrl</kbd> + <kbd>1</kbd>，数字1-5都可以，代表的是视图层级的数字</li><li>简单型就是对每个面进行简单细分，不影响面与面之间的角度；Catmull-Clark算法会平滑网格</li><li>优化显示需要在物体模式下开启线框，开启优化显示，会显示原来边线的变化，不包括内部的细分边线</li></ul><h3 id="多级精度修改器-Multiresolution"><a href="#多级精度修改器-Multiresolution" class="headerlink" title="多级精度修改器 Multiresolution"></a>多级精度修改器 Multiresolution</h3><ul><li>跟表面细分修改器类似，但是在雕刻的时候使用该修改器合适，在雕刻模式下，只有多级精度修改器的处理数据支持直接被雕刻。使用表面细分修改器后开启雕刻模式，雕刻的是原始的基本网格，而不是被修改器修改的网格</li><li>多级精度修改器之前不能有其他修改器，它需要在修改器堆栈顶部</li><li>多级精度修改器可以一层一层添加，每一层可以用不同的算法。细分：默认的Catmull-Clark算法；简单型：对原始网格的边进行插值；线性：对目前网格物体的面进行简单细分，不影响目前网格物体的曲率</li><li>物体细分应用后，可以添加多级精度修改器进行反细分</li></ul><h3 id="重构网格修改器-Remesh"><a href="#重构网格修改器-Remesh" class="headerlink" title="重构网格修改器 Remesh"></a>重构网格修改器 Remesh</h3><ul><li>基于当前网格重新计算生成拓扑结构，拓扑结构只包含四边形</li><li>包括4种模式，块状Blocks：把原网格变成积木；平滑化Smooth：重新拓扑为只包含四边形的拓扑结构；锐利Sharp：类似于平滑化，但保留锐边和转角；体素Voxel：使用OpenVDB从当前的几何体生成一个新的流形网格，同时尝试保留网格的原始体积，体素大小越小模型越精细</li><li>可以使用物体数据属性中的重构网格来代替该修改器，需要点击下面的体素重构或者网格重构；在雕刻模式下，体素网格重构（相当于按了重构网格按钮）：<kbd>ctrl</kbd> + <kbd>R</kbd>；体素大小预估：<kbd>R</kbd>；四边形网格重构：<kbd>ctrl</kbd> + <kbd>alt</kbd> + <kbd>R</kbd></li></ul><h3 id="螺旋修改器-Screw"><a href="#螺旋修改器-Screw" class="headerlink" title="螺旋修改器 Screw"></a>螺旋修改器 Screw</h3><ul><li>螺旋轴心是物体的原点</li><li>注意可能产生的重叠点，别忘了勾选合并</li></ul><h3 id="蒙皮修改器-Skin"><a href="#蒙皮修改器-Skin" class="headerlink" title="蒙皮修改器 Skin"></a>蒙皮修改器 Skin</h3><ul><li>根据点和边线（与面无关）生成蒙皮网格数据，可用于制作基本形状，为雕刻提供便利</li><li>在编辑模式下的点模式，选择一个顶点，使用<kbd>ctrl</kbd> + <kbd>A</kbd>可以控制蒙皮半径，即n面板中的顶点数据的半径X和半径Y，可以再点击<kbd>X</kbd>或<kbd>Y</kbd>控制半径X和半径Y</li><li>分支平滑：可以控制当一个点有多个分支时该点附近蒙皮效果的半径（不调整会过于厚实）</li><li>根点：带着红圈的顶点，为蒙皮修改器不可或缺的元素，删除会导致故障</li></ul><h3 id="实体化修改器-Solidify"><a href="#实体化修改器-Solidify" class="headerlink" title="实体化修改器 Solidify"></a>实体化修改器 Solidify</h3><ul><li>实体化厚度增加减少的方向与法向有关，偏移量为1时，且厚度乘以偏移量为正数，厚度向法向的正方向增加；偏移量为-1，且厚度乘以偏移量为负数，厚度向法向的负方向增加；偏移量为0，厚度均匀地往法向正负方向增加</li><li>复杂模式可以处理非流形图形（一条边连接2个以上的面），而简单型模式会出现错误</li><li>对于厚度异常，可以先选择均衡厚度解决；若不行，再选择法向里的高质量来解决。遇到该问题，处理的顺序可按下面，越后面处理能力越强，相对计算时间也越长：①简单模式或复杂模式+固定；②简单模式+均衡厚度或者法向里的选项；③简单模式+均衡厚度和法向里的选项或者复杂模式+均匀；④复杂模式+约束</li></ul><h3 id="三角化修改器-Triangulate"><a href="#三角化修改器-Triangulate" class="headerlink" title="三角化修改器 Triangulate"></a>三角化修改器 Triangulate</h3><ul><li>将四边面或多边面转换为三角面</li></ul><h3 id="焊接修改器-Weld"><a href="#焊接修改器-Weld" class="headerlink" title="焊接修改器 Weld"></a>焊接修改器 Weld</h3><ul><li>修改器版本的按间距合并</li><li>相连项模式仅仅合并同一条边上（具有相连关系的顶点），全部模式合并所以满足条件的顶点</li><li>注意顶点合并了，但是可能会产生内部面</li></ul><h3 id="线框修改器-Wireframe"><a href="#线框修改器-Wireframe" class="headerlink" title="线框修改器 Wireframe"></a>线框修改器 Wireframe</h3><ul><li>将平面变为线框并加厚</li><li>偏移量和厚度与实体化修改器类似</li></ul><h2 id="形变类-deform-修改器"><a href="#形变类-deform-修改器" class="headerlink" title="形变类 deform 修改器"></a>形变类 deform 修改器</h2><p>形变类修改器只改变对象的形状，不改变其拓扑结构，大多数变形基于物体原点变形。比生成类修改器多出<em>应用为形态键</em>以及<em>保存为形态键</em>，保存为形态键不会应用修改器，即点击完修改器仍然存在，而应用为形态键点击完后修改器应用掉了。注意：因为只改变对象形状，所以添加修改器的物体需要足够多的顶点，否则很难呈现效果</p><h3 id="铸型修改器-Cast"><a href="#铸型修改器-Cast" class="headerlink" title="铸型修改器 Cast"></a>铸型修改器 Cast</h3><ul><li>变形为球形、柱体或者方体，球形类似于球形化工具</li><li>变形默认以物体原点为变形中心，可以尝试改变原点看看</li><li>轴向可以控制在各自轴向上是否变形；半径可以控制以物体原点为中心的变形范围，默认的0为不产生限制效果；尺寸调节发生形变部分的网格的大小尺寸；物体可以设置其他物体的原点为铸型效果中心，默认仅位置，可以勾选使用变换</li></ul><h3 id="曲线修改器-Curve"><a href="#曲线修改器-Curve" class="headerlink" title="曲线修改器 Curve"></a>曲线修改器 Curve</h3><ul><li>使用曲线物体折弯网格，同理变形默认以物体原点为变形中心</li><li>修改器修改的是网格数据，并非原点数据。当网格物体与曲线原点重合（没有相对位置差和旋转差），将会使用网格原点位置（变形原点）对应曲线起始点，所以若变形原点两侧都有网格，网格变形后的一部分会在曲线外面</li><li>前进轴取决于形变轴设置与物体原点间的旋转差，推荐使用时避免旋转差；网格原点位置和曲线原点有位置差，那么变换后的网格原点位置与曲线起始点的位置也会有该位置差（基于若该修改器会修改网格原点的局部坐标）</li><li>曲线的性质也能影响到变形，比如半径、倾斜等等</li></ul><h3 id="置换修改器-Displace"><a href="#置换修改器-Displace" class="headerlink" title="置换修改器 Displace"></a>置换修改器 Displace</h3><ul><li>基于纹理偏离顶点，对8比特位图非矢量置换来说，纯黑0对应纹理强度0，纯白255对应纹理强度1</li><li>强度力度控制纹理强度；中间值与实体化修改器的偏移量类似，控制位移</li></ul><h3 id="钩挂修改器-Hook"><a href="#钩挂修改器-Hook" class="headerlink" title="钩挂修改器 Hook"></a>钩挂修改器 Hook</h3><ul><li>利用其他物体控制网格或曲线的顶点（需要指定，指定需进入编辑模式）从而改变形状</li><li>区分指定的参与钩挂的顶点和顶点组，同时顶点组权重驱动强度的范围为参与钩挂的顶点（即指定的顶点）</li><li>衰减中心为物体原点</li></ul><h3 id="拉普拉斯形变修改器-Laplacian-Deform"><a href="#拉普拉斯形变修改器-Laplacian-Deform" class="headerlink" title="拉普拉斯形变修改器 Laplacian Deform"></a>拉普拉斯形变修改器 Laplacian Deform</h3><ul><li>一种积分变换，对非锚点顶点执行自适应计算以尽可能保持原始几何形态；使用必须指定锚点权重，然后绑定，然后在编辑模式移动指定锚点的一些顶点，修改器将其余锚点顶点保持在固定位置，并计算所有剩余顶点的最佳位置以保留原始几何细节</li><li>建议指定锚点时，一些为固定点，一些为移动点，或者这两部分都钩挂到另外物体上</li></ul><h3 id="晶格形变修改器-Lattice"><a href="#晶格形变修改器-Lattice" class="headerlink" title="晶格形变修改器 Lattice"></a>晶格形变修改器 Lattice</h3><ul><li>通过给网格添加外部晶格控制物体（需绑定），借助插值计算实现更少点控制更多点的操作</li><li>建议在物体模式下将晶格物体缩放适配被变形物体，建议设置晶格物体为父级，建议使用形态键记录晶格顶点初始位置</li><li>晶格物体的细分在物体属性里的分辨率设置以及插值类型（可以改变形变的算法）</li><li>可以通过设置父级目标<kbd>ctrl</kbd> + <kbd>P</kbd>中的晶格形变也可以对物体添加该修改器</li></ul><h3 id="网格形变修改器-Mesh-Deform"><a href="#网格形变修改器-Mesh-Deform" class="headerlink" title="网格形变修改器 Mesh Deform"></a>网格形变修改器 Mesh Deform</h3><ul><li>与晶体形变修改器相似，用外部网格物体控制物体形变（需绑定）</li><li>网格笼注意事项：尽可能包裹物体（在网格外就不会形变）；面数不宜过多；设置线框显示以及渲染不可见；法向朝外；绑定父级</li><li>相对于晶格，网格笼的初始态取决于绑定时的样子</li><li>对于面数很多的物体要生成网格笼，可以复制物体并生成凸壳（网格菜单里）再通过网格重构处理，从而减少面数</li><li>可以使用形态键控制网格笼从而以小控制大的变形，可以减少计算量</li></ul><h3 id="缩裹修改器-Shrinkwrap"><a href="#缩裹修改器-Shrinkwrap" class="headerlink" title="缩裹修改器 Shrinkwrap"></a>缩裹修改器 Shrinkwrap</h3><ul><li>将投射物体的顶点缩裹至目标物体</li><li>注意事项：缩裹形变是作用于物体顶点的，需要足够的顶点支撑变形后的结构；建议尽可能让缩裹物体与目标形态一致</li><li>缩裹方法：①最近表面的位置点：顶点投射到离目标物体表面的最近的点，最近的点不一定是垂直位置的点；②投影（允许2个目标物体）：根据被修改的物体的法向或轴向推移顶点直到与目标接触，若无法接触的顶点则位置不变；③最近的顶点：顶点投射到离目标物体表面的最近的顶点（网格上已存在的顶点）；④目标法线投影：使用目标物体的插值法向（自动平滑法向）</li><li>吸附方式：①表面上：不受目标物体法向影响的偏移；②向内/向外：目标法向向外，正值实现向内/向外偏移；③表面外围：正值向法向外侧偏移；④表面上方：沿目标物体法向使用偏移距离</li><li>可以借助缩裹实现表面重新拓扑</li></ul><h3 id="简易形变修改器-Simple-Deform"><a href="#简易形变修改器-Simple-Deform" class="headerlink" title="简易形变修改器 Simple Deform"></a>简易形变修改器 Simple Deform</h3><ul><li>扭曲：顶点按所选旋转轴螺旋排布（基于原点的旋转轴）</li><li>弯曲：根据所选轴向旋转形变，选择x、y沿着z轴弯曲，选择Z沿着x轴弯曲（看似不直观，但开关修改器结果就直观了）</li><li>锥化：原点决定锥化中心，沿着所选轴向锥化</li><li>拉伸：原点决定拉伸中心，沿着所选轴向拉伸；拉伸可以借助空物体的缩放进行调节</li><li>注意事项：注意首尾合并，不会自动合并顶点</li><li>可以使用晶格来间接控制物体，然后给晶格简易形变修改器</li></ul><h3 id="平滑修改器-Smooth"><a href="#平滑修改器-Smooth" class="headerlink" title="平滑修改器 Smooth"></a>平滑修改器 Smooth</h3><ul><li>不改变顶点数平滑网格，系数建议为0-1</li></ul><h3 id="矫正平滑修改器-Smooth-Corrective"><a href="#矫正平滑修改器-Smooth-Corrective" class="headerlink" title="矫正平滑修改器 Smooth Corrective"></a>矫正平滑修改器 Smooth Corrective</h3><ul><li>矫正平滑依据某个初始状态，将当前顶点状态朝向初始状态平滑，有利于减少网格高度扭曲</li><li>在该修改器之前添加生成类修改器可能会导致失效需要重新绑定坐标（静置源中处理）</li></ul><h3 id="拉普拉斯平滑修改器-Smooth-Laplacian"><a href="#拉普拉斯平滑修改器-Smooth-Laplacian" class="headerlink" title="拉普拉斯平滑修改器 Smooth Laplacian"></a>拉普拉斯平滑修改器 Smooth Laplacian</h3><ul><li>减少网格表面的起伏噪点，特别是对扫描模型很有用</li><li>Lambda系数控制面平滑，Lambda边界控制边界平滑，规格化用于避免极端数据的出现</li></ul><h3 id="表面形变修改器-Surface-Deform"><a href="#表面形变修改器-Surface-Deform" class="headerlink" title="表面形变修改器 Surface Deform"></a>表面形变修改器 Surface Deform</h3><ul><li>相对于晶格形变和网格形变的包裹式形变，表面形变修改器可以根据任意网格曲面控制，本质是传递其运动/形变信息</li><li>同理，可以以小控制大</li></ul><h3 id="弯绕修改器-Warp"><a href="#弯绕修改器-Warp" class="headerlink" title="弯绕修改器 Warp"></a>弯绕修改器 Warp</h3><ul><li>需要两个物体，从源物体变形至目标物体</li><li>可以基于纹理灰度图变形，比置换修改器方便控制范围和衰减</li></ul><h3 id="波浪形变修改器-Wave"><a href="#波浪形变修改器-Wave" class="headerlink" title="波浪形变修改器 Wave"></a>波浪形变修改器 Wave</h3><ul><li>理解为沿着Z轴或法向上下移位比较好</li><li>生成单向线性震荡波或单向圆形波（XY控制），会自动添加动画（循环不开启就一次）</li><li>顶点沿自身Z轴（可以改为沿法向）实现周期型移位，沿法向可以产生变大变小的动画效果（类似于心脏搏动）</li><li>宽度为半周期长度，窄度越高，脉冲越窄</li><li>时间：0帧为起始帧，速度正则波形向外扩散，速度负波形向内收缩（把偏移量拉大就可以看到）；阻尼是额外数量的帧，波从高度衰减至0；建议速率为周期（（宽度*2）/动画帧数）的倍数，否则动画会出现断离，因为没法满足循环</li><li>可以基于纹理上下移位</li></ul><h1 id="动画相关操作"><a href="#动画相关操作" class="headerlink" title="动画相关操作"></a>动画相关操作</h1><h3 id="关键帧"><a href="#关键帧" class="headerlink" title="关键帧"></a>关键帧</h3><ul><li>插入关键帧：<kbd>I</kbd></li><li>平滑关键帧：<kbd>alt</kbd> + <kbd>O</kbd></li></ul>]]></content>
      
      
      <categories>
          
          <category> blender </category>
          
          <category> blender教程 </category>
          
          <category> blender快捷键合集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blender </tag>
            
            <tag> 3d建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客教程</title>
      <link href="/2022/11/04/2022-11-04-hexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
      <url>/2022/11/04/2022-11-04-hexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该教程仅为常用的命令或操作的记录；<br>Butterfly主题网站为：<a href="https://butterfly.js.org/">https://butterfly.js.org/</a><br>持续更新中…..</p></blockquote><h1 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h1><h2 id="new命令"><a href="#new命令" class="headerlink" title="new命令"></a>new命令</h2><h3 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。  </p><h3 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径:</p><div class="table-container"><table><thead><tr><th style="text-align:left">布局</th><th style="text-align:left">路径</th></tr></thead><tbody><tr><td style="text-align:left"><code>post</code></td><td style="text-align:left"><code>source/_posts</code></td></tr><tr><td style="text-align:left"><code>page</code></td><td style="text-align:left"><code>source</code></td></tr><tr><td style="text-align:left"><code>draft</code></td><td style="text-align:left"><code>source/_drafts</code></td></tr></tbody></table></div><h3 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h3><p>Hexo默认以标题做为文件名称，建议命令里title设为<code>:year-:month-:day-:post title</code>，可以更方便地通过日期来管理文章：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;:2022-:10-:01-:post title&quot;</span><br></pre></td></tr></table></figure></p><p>上述命令会在\source\_posts\里生成2022-10-01-post-title.md；<br>文件标题在Front-matter里修改，标题可以与文件名称不一样。</p><h2 id="generate命令"><a href="#generate命令" class="headerlink" title="generate命令"></a>generate命令</h2><p>生成静态文件:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p><p>该命令可以简写为：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure></p><p>文件生成后立即部署网站：<br><code>-d, --deploy</code><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure></p><h2 id="server命令"><a href="#server命令" class="headerlink" title="server命令"></a>server命令</h2><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/。">http://localhost:4000/。</a><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><h2 id="clean命令"><a href="#clean命令" class="headerlink" title="clean命令"></a>clean命令</h2><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure></p><h1 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h1><p><strong>Front-matter</strong> 是 markdown 文件最上方以 <code>---</code> 分隔的区域，用于指定个别档案的变量。</p><ul><li>Page Front-matter 用于<code>页面</code>配置 </li><li>Post Front-matter 用于<code>文章页</code>配置</li></ul><h2 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">title</td><td style="text-align:left">【必需】文章标题</td></tr><tr><td style="text-align:left">date</td><td style="text-align:left">【必需】文章创建日期</td></tr><tr><td style="text-align:left">updated</td><td style="text-align:left">【可选】文章更新日期</td></tr><tr><td style="text-align:left">tags</td><td style="text-align:left">【可选】文章标籤</td></tr><tr><td style="text-align:left">categories</td><td style="text-align:left">【可选】文章分类</td></tr><tr><td style="text-align:left">keywords</td><td style="text-align:left">【可选】文章关键字</td></tr><tr><td style="text-align:left">description</td><td style="text-align:left">【可选】文章描述</td></tr><tr><td style="text-align:left">top_img</td><td style="text-align:left">【可选】文章顶部图片</td></tr><tr><td style="text-align:left">cover</td><td style="text-align:left">【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td></tr><tr><td style="text-align:left">mathjax</td><td style="text-align:left">【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td style="text-align:left">katex</td><td style="text-align:left">【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td style="text-align:left">highlight_shrink</td><td style="text-align:left">【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table></div><h2 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h2><p>分类和标签在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。  </p><p>Hexo 不支持指定多个同级分类，如下：</p><blockquote><p>categories:<br>&ensp;&ensp;- Diary<br>&ensp;&ensp;- Life  </p></blockquote><p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><blockquote><p>categories:<br>&ensp;&ensp;- [Diary, PlayStation]<br>&ensp;&ensp;- [Diary, Games]<br>&ensp;&ensp;- [Life]  </p></blockquote><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p><h1 id="Hexo博客备份"><a href="#Hexo博客备份" class="headerlink" title="Hexo博客备份"></a>Hexo博客备份</h1><p><code>hexo g -d</code> 或 <code>hexo d</code> 部署到<strong>Github</strong>的其实<strong>Hexo</strong>编译后的文件，这些文件是用来生成网页的，并不包含我们的本地的源文件；</p><p>它其实上传到<strong>Github</strong>的是在我们本地目录里的 <code>.deploy_git</code> 里面的内容；</p><p>我们的源文件比如相关 <code>source</code> 文件、<code>配置文件</code>等都是没有上传到<strong>Github</strong>上的，所以我们要利用<code>git</code>来做分支管理，对我们的源文件进行备份，这样我们就可以在另一台电脑上把源文件<code>clone</code>到本地安装相应的环境就可以继续写我们的博客了。</p><h2 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h2><p>在<strong>Github</strong>上博客仓库下创建一个新的分支<strong>hexo</strong>，并且将这个分支设置为默认分支，具体操作如下：</p><p>在博客的<strong>Github</strong>上的仓库的<code>Settings</code> =&gt; <code>Branches</code> =&gt; Default branch中Switch to another branch 改为<code>hexo</code>分支。</p><p><code>main</code>分支是默认的博客静态页面分支，在之后恢复博客的时候并不需要。同时这样每次同步的时候就不用指定分支，比较方便。</p><h2 id="克隆hexo分支"><a href="#克隆hexo分支" class="headerlink" title="克隆hexo分支"></a>克隆hexo分支</h2><p>在本地除了博客目录的任意一个目录下，把我们刚建的分支hexo克隆到该目录：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/XXXXXXXX/XXXXXXXX.github.io</span><br></pre></td></tr></table></figure></p><p>把克隆下来的项目里面的.git文件复制到自己本地的Hexo博客目录下。</p><p><strong>注意：如果之前搭建博客的时候自己更换过主题文件的，请把主题文件里面的.git文件删除。</strong></p><h2 id="备份分支"><a href="#备份分支" class="headerlink" title="备份分支"></a>备份分支</h2><p>在hexo博客的根目录下执行如下命令将本地文件备份到Github上：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;Blog源文件备份&quot;</span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></p><p>这时候我们会看到Github上的hexo分支就有我们的源文件了。</p><p>其中<code>node_modules</code>、<code>public</code>、<code>db.json</code>已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装。</p><h2 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h2><p>之后每次更改东西都希望备份到hexo分支上，可以执行如下步骤：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;备份&quot;</span><br><span class="line">git push</span><br><span class="line">hexo g &amp; hexo d</span><br></pre></td></tr></table></figure></p><h2 id="恢复博客"><a href="#恢复博客" class="headerlink" title="恢复博客"></a>恢复博客</h2><p>假设本地Hexo博客基础环境已经搭好：比如安装git、nodejs、hexo安装等等。</p><p>首先把Github上hexo分支上的项目克隆到本地（注意：是我们备份的那个分支）；</p><p>在clone下来的那个文件夹里面执行如下命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli</span><br><span class="line">$ npm install hexo-deployer-git</span><br></pre></td></tr></table></figure></p><p>然后再去安装主题相关的插件即可；</p><p>在此不需要执行<code>hexo init</code>这条指令，因为不是从零搭建起新博客。</p>]]></content>
      
      
      <categories>
          
          <category> 博客教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Learning Python》读书笔记（四）</title>
      <link href="/2022/10/27/2022-10-27-Learning-python4/"/>
      <url>/2022/10/27/2022-10-27-Learning-python4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该笔记为 <strong>《Learning Python》</strong> 的读书笔记，由于是早期未搞熟博客系统时所写，笔记结构较为混乱；<br>该书涉及的内容可能过于啰嗦，但包含一些python背后的逻辑和机制，可以粗略过一遍，但若仔细阅读就是在坑自己；<br>该笔记内容过多，所以不展示部分代码的结果，需复制到编辑器中查看；<br>学习完成日期为2022年10月20日。<br>本篇主要内容为：第7部分异常和第8部分高级主题：unicode编码、字节字符串、被管理的属性、装饰器、元类。</p></blockquote><div  align="center">  <img src="https://s2.loli.net/2022/09/17/ri9Ue6nguJdq1Ca.jpg" width = "80%" height = "80%" alt="Learning Python"/></div><p><strong><font size=5>PART VII Exceptions and Tools</font></strong></p><h2 id="Chapter-33-Exception-Basics"><a href="#Chapter-33-Exception-Basics" class="headerlink" title="Chapter 33 Exception Basics"></a>Chapter 33 Exception Basics</h2><h3 id="一、Exception-Basics"><a href="#一、Exception-Basics" class="headerlink" title="一、Exception Basics"></a>一、Exception Basics</h3><p><strong>1、异常的5类语句</strong><br>① <code>try/except</code>：捕捉异常并从中恢复；<br>② <code>try/finally</code>：无论异常是否发生，执行清理行为；<br>③ <code>raise</code>：手动在代码中触发异常；<br>④ <code>assert</code>：有条件地在代码中触发异常；<br>⑤ <code>with/as</code>：实现环境管理器，见下一章。  </p><p><strong>2、异常的作用</strong><br>错误处理；事件通知；特殊情况处理；终止行为；非常规控制流程</p><p><strong>3、捕获异常</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fetcher</span>(<span class="params">obj, index</span>):</span><br><span class="line">    <span class="keyword">return</span> obj[index]</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;spam&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fetcher(x, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">except</span> IndexError: <span class="comment"># Catch and recover</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;got exception&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>4、引发异常： <code>raise</code> 语句</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> IndexError <span class="comment"># Trigger exception manually</span></span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;got exception&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>5、用户定义的异常</strong><br>用户定义的异常通过类来编写，它们继承自一个<strong>内置异常类 Exception</strong> ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AlreadyGotOne</span>(<span class="title class_ inherited__">Exception</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grail</span>():</span><br><span class="line">    <span class="keyword">raise</span> AlreadyGotOne() <span class="comment"># Raise an instance</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    grail()</span><br><span class="line"><span class="keyword">except</span> AlreadyGotOne:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;got exception&#x27;</span>)</span><br></pre></td></tr></table></figure><p>可以定制出错信息文本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Career</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="string">&#x27;So I became a waiter...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">raise</span> Career()</span><br></pre></td></tr></table></figure><p><strong>6、终止动作</strong><br><code>try/finally</code>组合指明结束时一定会执行的终止动作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fetcher(x, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;after fetch&#x27;</span>)</span><br></pre></td></tr></table></figure><p>触发异常也会执行 <code>finally</code> 代码块：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">after</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fetcher(x, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;after fetch&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;after try?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">after()</span><br></pre></td></tr></table></figure><h2 id="Chapter-34-Exception-Coding-Details"><a href="#Chapter-34-Exception-Coding-Details" class="headerlink" title="Chapter 34 Exception Coding Details"></a>Chapter 34 Exception Coding Details</h2><h3 id="一、The-try-except-else-Statement"><a href="#一、The-try-except-else-Statement" class="headerlink" title="一、The try/except/else Statement"></a>一、The try/except/else Statement</h3><p><strong>1、 <code>try/except/else</code> 语句</strong><br>① <code>except</code>: 捕捉所有异常类型；<br>② <code>except name</code>: 只捕捉指定的异常；<br>③ <code>except name as value</code>: 捕捉所列异常并将该异常实例赋值给名称 value ；<br>④ <code>except (name1, name2)</code>: 捕捉任何列出的异常；<br>⑤ <code>except (name1, name2) as value</code>: 捕捉任何列出的异常，并将该异常实例元组赋值给名称 value ；<br>⑥ <code>else</code>: 如果没有引发异常，就会运行；<br>⑦ <code>finally</code>: 总是在退出 try 语句时运行此代码块；  </p><p>可以这么理解：尝试一个可能会出错的语句，除了（except）XX 错误，运行定制的语句，若没有（else）错误，运行没发生异常要执行的程序；如果 try 后面的语句执行时引发了异常，python 会回到 try 并搜索第一个与异常名称匹配的 except。</p><p>python会从上到下以及由左至右地检测 except 分句。</p><p><strong>2、合并 try 语句的语法</strong><br><code>try</code> 语句必须至少有一个 except 或一个 finally ，顺序为 <em>try -&gt; except -&gt; else -&gt; finally</em> ；如果要有 else ，必须有至少一个 except ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sep = <span class="string">&#x27;-&#x27;</span> * <span class="number">45</span> + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sep + <span class="string">&#x27;EXCEPTION RAISED AND CAUGHT&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="string">&#x27;spam&#x27;</span>[<span class="number">99</span>]</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except run&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally run&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;after run&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sep + <span class="string">&#x27;NO EXCEPTION RAISED&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="string">&#x27;spam&#x27;</span>[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except run&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally run&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;after run&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sep + <span class="string">&#x27;NO EXCEPTION RAISED, WITH ELSE&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="string">&#x27;spam&#x27;</span>[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except run&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;else run&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally run&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;after run&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sep + <span class="string">&#x27;EXCEPTION RAISED BUT NOT CAUGHT&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x = <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except run&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally run&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;after run&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="二、The-raise-Statement"><a href="#二、The-raise-Statement" class="headerlink" title="二、The raise Statement"></a>二、The raise Statement</h3><p><strong>1、引发异常</strong><br>① <code>raise instance</code><br>② <code>raise class</code><br>异常总是类的实例，如果传入一个类，python 会创建被引发的一个异常实例：即 <code>raise IndexError</code> 等价于 <code>raise IndexError()</code>；</p><p>如果 try 中包含了 <code>except name as X</code> ，那么 raise 中的异常实例会赋值给变量 X 。</p><p><strong>2、作用域和 <code>try except</code> 变量</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> X:</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br></pre></td></tr></table></figure><p>X 会被局限在 except 块中，而且该变量 X 会在 except 块退出后被移除：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">99</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> X:</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X) <span class="comment"># 会出错：NameError: name &#x27;X&#x27; is not defined</span></span><br></pre></td></tr></table></figure><p>若要在 try 语句后引用该异常实例，需要赋值给另一个变量：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> X:</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line">    Saveit = X</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Saveit)</span><br></pre></td></tr></table></figure><p><strong>3、异常链：<code>raise from</code></strong><br><code>raise newexception from otherexception</code><br>from 后面跟的表达式指定了另一个异常类或实例，该异常会附加到 newexception 的 <code>__cause__</code> 属性；如果 newexception 没有被捕获，那么 python 会把2个异常都作为标准出错消息打印出来：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> E:</span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Bad&#x27;</span>) <span class="keyword">from</span> E</span><br></pre></td></tr></table></figure><p>当异常处理程序内部，程序错误地引发一个异常，一个相似的过程会自动发生：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    badname</span><br></pre></td></tr></table></figure><h3 id="三、The-assert-Statement"><a href="#三、The-assert-Statement" class="headerlink" title="三、The assert Statement"></a>三、The assert Statement</h3><p><strong>1、assert 可视为条件式的 raise 语句</strong><br><code>assert test, data</code><br>如果 test 为假， python 就引发异常 data 项：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">assert</span> x &lt; <span class="number">0</span>, <span class="string">&#x27;x must be negative&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>) <span class="comment"># 出现错误：AssertionError: x must be negative</span></span><br></pre></td></tr></table></figure><p>assert 语句中 data 是可选的；<br>assert 几乎是用来捕捉用户定义的约束条件，而不是捕捉实际的程序设计错误；<br>因为 python 会自行捕获错误，通常没必要写 assert 去捕捉：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reciprocal</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">assert</span> x != <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / x</span><br><span class="line"><span class="comment"># 上述的assert一般都是多余的</span></span><br></pre></td></tr></table></figure><h3 id="四、with-as-Context-Managers"><a href="#四、with-as-Context-Managers" class="headerlink" title="四、with/as Context Managers"></a>四、with/as Context Managers</h3><p><strong>1、基本用法</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> expression [<span class="keyword">as</span> variable]:</span><br><span class="line">    <span class="keyword">with</span>-block</span><br></pre></td></tr></table></figure><p>这里的 expression 要返回一个支持上下文管理协议的对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;C:\misc\data&#x27;</span>) <span class="keyword">as</span> myfile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> myfile:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure><p>可以使用 <code>try/finally</code> 语句来实现类似的效果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myfile = <span class="built_in">open</span>(<span class="string">r&#x27;C:\misc\data&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> myfile:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    myfile.close()</span><br></pre></td></tr></table></figure><p><strong>2、上下文管理协议</strong><br>可以自己编写一个上下文管理器（未摘抄，有兴趣再查阅）</p><h2 id="Chapter-35-Exception-Objects"><a href="#Chapter-35-Exception-Objects" class="headerlink" title="Chapter 35 Exception Objects"></a>Chapter 35 Exception Objects</h2><h3 id="一、Class-Based-Exceptions"><a href="#一、Class-Based-Exceptions" class="headerlink" title="一、Class-Based Exceptions"></a>一、Class-Based Exceptions</h3><p><strong>1、编写异常类</strong><br>异常类拥有状态信息和行为，支持继承：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">General</span>(<span class="title class_ inherited__">Exception</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Specific1</span>(<span class="title class_ inherited__">General</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Specific2</span>(<span class="title class_ inherited__">General</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raiser0</span>():</span><br><span class="line">    X = General()</span><br><span class="line">    <span class="keyword">raise</span> X </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raiser1</span>():</span><br><span class="line">    X = Specific1()</span><br><span class="line">    <span class="keyword">raise</span> X</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raiser2</span>():</span><br><span class="line">    X = Specific2()</span><br><span class="line">    <span class="keyword">raise</span> X</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> (raiser0, raiser1, raiser2):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">except</span> General:</span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;caught: %s&#x27;</span> % sys.exc_info()[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><code>sys.exc_info</code> 用于抓取最近发生的异常，它的结果第一个元素是被引发的异常类，第二个元素是实际被引发的实例。</p><h3 id="二、Built-in-Exception-Classes"><a href="#二、Built-in-Exception-Classes" class="headerlink" title="二、Built-in Exception Classes"></a>二、Built-in Exception Classes</h3><p><strong>1、Python 能够引发的所有内置异常都是预定义的类对象，可通过 builtin 模块中的内置名称使用</strong><br>① <code>BaseException</code>：异常的顶层根父类，该类不应由用户定义的类直接继承，它提供了子类可继承的默认打印和状态保持行为；<br>② <code>Exception</code>：用户定义的异常的根父类，它是 BaseException 类的一个直接子类，并且是除系统退出事件类外，所有其他内置异常的父类；<br>③ <code>ArithmeticError</code>：Exception 的子类，数字错误的根父类，它的子类包括 <code>OverflowError</code> ,  <code>ZeroDivisionError</code> 和 <code>Floating PointError</code> ；<br>④ <code>LookupError</code>：Exception 的子类，索引错误的根父类，它的子类包括 <code>IndexError</code> ,  <code>KeyError</code> 等等。  </p><p><strong>2、默认打印和状态</strong><br>传递给内置异常类的参数，都会被自动保存在实例的 args 元组属性中，并且在打印该实例的时候自动显示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> IndexError</span><br><span class="line"><span class="keyword">raise</span> IndexError(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">I = IndexError(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(I.args)</span><br><span class="line"><span class="built_in">print</span>(I)</span><br></pre></td></tr></table></figure><p>用户定义的异常类同样如此：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>(<span class="title class_ inherited__">Exception</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">raise</span> E</span><br><span class="line"><span class="keyword">raise</span> E(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">I = E(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(I.args)</span><br><span class="line"><span class="built_in">print</span>(I)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> E(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> E <span class="keyword">as</span> X:</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line">    <span class="built_in">print</span>(X.args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(X))</span><br></pre></td></tr></table></figure><p><strong>3、定制的打印显示</strong><br>除了像上面传递参数来定制显示，也可以定义 <code>__str__</code> 或 <code>__repr__</code> 来返回希望显示的字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBad</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Always look on the bright side of life...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyBad()</span><br><span class="line"><span class="keyword">except</span> MyBad <span class="keyword">as</span> X:</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">raise</span> MyBad()</span><br></pre></td></tr></table></figure><h3 id="三、Custom-Data-and-Behavior"><a href="#三、Custom-Data-and-Behavior" class="headerlink" title="三、Custom Data and Behavior"></a>三、Custom Data and Behavior</h3><p><strong>1、内置异常父类提供了一个默认的构造函数，把构造函数参数自动存储到了一个名为 args 的实例元组属性中</strong>  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FormatError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, line, file</span>):</span><br><span class="line">        self.line = line</span><br><span class="line">        self.file = file</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parser</span>():</span><br><span class="line">    <span class="keyword">raise</span> FormatError(<span class="number">42</span>, file=<span class="string">&#x27;spam.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    parser()</span><br><span class="line"><span class="keyword">except</span> FormatError <span class="keyword">as</span> X:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error at: %s %s&#x27;</span> % (X.file, X.line))</span><br></pre></td></tr></table></figure><p><strong>2、提供异常方法</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FormatError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    logfile = <span class="string">&#x27;formaterror.txt&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, line, file</span>):</span><br><span class="line">        self.line = line</span><br><span class="line">        self.file = file</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">logerror</span>(<span class="params">self</span>):</span><br><span class="line">        log = <span class="built_in">open</span>(self.logfile, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error at:&#x27;</span>, self.file, self.line, file=log)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parser</span>():</span><br><span class="line">    <span class="keyword">raise</span> FormatError(<span class="number">40</span>, <span class="string">&#x27;spam.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    parser()</span><br><span class="line"><span class="keyword">except</span> FormatError <span class="keyword">as</span> exc:</span><br><span class="line">    exc.logerror()</span><br></pre></td></tr></table></figure><h2 id="Chapter-36-Designing-with-Exceptions"><a href="#Chapter-36-Designing-with-Exceptions" class="headerlink" title="Chapter 36 Designing with Exceptions"></a>Chapter 36 Designing with Exceptions</h2><h3 id="一、Nesting-Exception-Handlers"><a href="#一、Nesting-Exception-Handlers" class="headerlink" title="一、Nesting Exception Handlers"></a>一、Nesting Exception Handlers</h3><p><strong>嵌套异常：</strong><br>①示例：控制流嵌套：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">action2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span> + []) <span class="comment"># Generate TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">action1</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        action2()</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;inner try&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    action1()</span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;outer try&#x27;</span>)</span><br></pre></td></tr></table></figure><p>②示例：语法嵌套化：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">raise1</span>(): <span class="keyword">raise</span> IndexError</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">noraise</span>(): <span class="keyword">return</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raise2</span>(): <span class="keyword">raise</span> SyntaxError</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> (raise1, noraise, raise2):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&lt;%s&gt;&#x27;</span> % func.__name__)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            func()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;caught IndexError&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;finally run&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;...&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="二、Exception-Idioms"><a href="#二、Exception-Idioms" class="headerlink" title="二、Exception Idioms"></a>二、Exception Idioms</h3><p><strong>跳出多重循环嵌套</strong><br>可以用 raise 来跳出循环：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Exitloop</span>(<span class="title class_ inherited__">Exception</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">3</span>: <span class="keyword">raise</span> Exitloop</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;loop3: %s&#x27;</span> % i)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;loop2&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;loop1&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exitloop:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;continuing&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果 raise 换成 break ，会无线循环，因为只是跳出了 for 循环，没有跳出 while 循环。</p><p><strong><font size=5>PART VIII Advanced Topics</font></strong></p><h2 id="Chapter-37-Unicode-and-Byte-Strings"><a href="#Chapter-37-Unicode-and-Byte-Strings" class="headerlink" title="Chapter 37 Unicode and Byte Strings"></a>Chapter 37 Unicode and Byte Strings</h2><h3 id="一、String-Basics"><a href="#一、String-Basics" class="headerlink" title="一、String Basics"></a>一、String Basics</h3><p><strong>1、python 3.X 中的字符串修改</strong><br>python 2.X的 str 和 unicode 类型以及融入了python 3.X的 bytes 和 str 类型，而且新增了 bytearray 可变类型：<br>①如果使用 ASCII 或 UTF-8 ，普通的字符串 str 对象和文本文件能够应对；<br>②处理非 ASCII 的 Unicode 文本，3.X 比 2.X 对其的支持更直接好用；<br>③处理二进制数据，例如图像或音频文件，需要理解 bytes 对象。</p><p><strong>2、字符编码方案</strong><br><strong>ASCII 标准</strong>定义了从0到127的字符编码，并且允许每个字符存储在一个8位的字节中，实际上只有7位被用到（2^7=128)；</p><p><code>ord</code> 函数返回字符的二进制识别值（Unicode码点序数），<code>chr</code> 函数返回给定整数编码值的对应字符：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;啊&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">97</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">97</span>))</span><br></pre></td></tr></table></figure><p>各种符号和重音字符并不在 ASCII 所定义的字符范围内。为了容纳特殊字符，一些标准使用一个8位字节所有可能的值（0到255），并把 ASCII 范围以外的128-255分配给特殊字符，其中一个标准叫 <strong>Latin-1 字符集</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">196</span>))</span><br></pre></td></tr></table></figure><p><strong>Unicode 文本</strong>用以表示欧洲、亚洲和其他非英语的字符集，拥有比8位字节更多的字符；</p><p>字节和字符串之间的转换由2个术语定义：<br>①<strong>编码 Encoding</strong> ：把字符串翻译为原始字节形式的过程；<br>②<strong>解码 Decoding</strong> ：把一个原始字符串翻译为字符串的过程。  </p><p><strong>UTF-8 编码</strong>，采用可变的字节数 byte（8 bit 比特、位）来表示众多字符：<br>小于128的字符码为1个字节；128和 0x7ff (2047)之间的字符码转换为两个字节，其中每个字节的值都位于128-255之间， 0x7ff 以上的代码转换为3个或4个字节序列，序列每个字节的值都位于128-255之间。</p><p>ASCII 是 Latin-1 和 UTF-8 的子集，即 ASCII 字符串也是有效的 Latin-1 和 UTF-8 编码字符串；ASCII 、Latin-1 、UTF-8 以及很多其他的编码，都被认为是 Unicode ；</p><p><strong>UTF-16</strong> 和 <strong>UTF-32</strong> 分别按照每字符固定大小的2个和4个字节来格式化文本。<br>2个字符的 ASCII 字符串是2个字节，但是在 UTF-16 和 UTF-32 中它会更宽，并包含头部的字节：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;ni&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;ascii&#x27;</span>), S.encode(<span class="string">&#x27;latin1&#x27;</span>), S.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf16&#x27;</span>), <span class="built_in">len</span>(S.encode(<span class="string">&#x27;utf16&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf32&#x27;</span>), <span class="built_in">len</span>(S.encode(<span class="string">&#x27;utf32&#x27;</span>)))</span><br></pre></td></tr></table></figure><p><strong>3、Python 如何在内存中存储字符串的</strong><br>Python 3.3 以后，在内存中 python 为每个字符分配1、2或4个字节。</p><p><strong>4、Python 的字符串类型</strong><br>Python 3.X 带有3中字符串对象类型：<br>① <code>str</code> 表示解码的 Unicode 文本（包括 ASCII ）；<br>② <code>bytes</code> 表示二进制数据（包括编码的文本）；<br>③ <code>bytearray</code>，一种可变的 bytes 类型。  </p><p><strong>5、文本和二进制文件</strong><br><strong>文本文件</strong>：当一个文件以文本模式打开时，读取其数据会自动将内容解码，并且将解码的内容返回为一个 <strong>str</strong> ：写入内容需要一个 <strong>str</strong> ，并且将其传输到文件之前自动编码它；<br><strong>二进制文件</strong>：通过内置 <code>open</code> 函数的模式字符串参数添加一个 <strong>b</strong> ，就能以二进制模式打开文件，此时读取其数据不会解码它，而是将其作为一个 <strong>bytes</strong> 对象；写入同理，接受 <strong>bytes</strong> 对象。  </p><p>如果处理图像文件、经网络传输的数据、必须解压的打包二进制数据等等，使用 bytes 和二进制模式文件处理合适；<br>如果要处理的内容本质是文本化的，例如程序输出、 HTML 、电子邮件内容或 CSV 或 XML 文件，使用 str 和文本模式合适。</p><h3 id="二、Coding-Basic-Strings"><a href="#二、Coding-Basic-Strings" class="headerlink" title="二、Coding Basic Strings"></a>二、Coding Basic Strings</h3><p><strong>1、字符串字面量</strong><br><code>&#39;xxx&#39;</code>、<code>&quot;xxx&quot;</code>、<code>&#39;&#39;&#39;xxx&#39;&#39;&#39;</code>都会产生一个 str ；在它们任何一个前面添加一个 b 或 B ，则会创建一个 bytes ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = <span class="string">b&#x27;spam&#x27;</span></span><br><span class="line">S = <span class="string">&#x27;eggs&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(B), <span class="built_in">type</span>(S))</span><br></pre></td></tr></table></figure><p>bytes 对象实际上是一个<strong>短整数序列</strong>，但它尽可能地将自己打印为字符：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(B[<span class="number">0</span>], B[<span class="number">1</span>:], <span class="built_in">list</span>(B))</span><br></pre></td></tr></table></figure><p>bytes 对象也是<strong>不可修改</strong>的。</p><p><strong>2、Unicode 字面量，它们被当作普通的 str 字符串（为了兼容2.X而存在）</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">U = <span class="string">u&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(U))</span><br><span class="line"><span class="built_in">print</span>(U)</span><br></pre></td></tr></table></figure><p><strong>3、字符串类型转换</strong><br>① <code>str.encode()</code> 和 <code>bytes(S, encoding)</code> 把字符串转换为其原始字节形式；<br>② <code>bytes.decode()</code> 和 <code>str(B, encoding)</code> 把原始字节转换为其字符串形式。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;eggs&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.encode())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(S, encoding=<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">B = <span class="string">b&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(B.decode())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(B, encoding=<span class="string">&#x27;ascii&#x27;</span>))</span><br></pre></td></tr></table></figure><p>encode 和 decode 方法根据使用者的平台使用默认编码名称：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.platform)</span><br><span class="line"><span class="built_in">print</span>(sys.getdefaultencoding())</span><br></pre></td></tr></table></figure><p>str 可以省略编码名称参数，但是不带编码名称的 str 会直接返回 bytes 对象的打印字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(B))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(B)))</span><br></pre></td></tr></table></figure><h3 id="三、Coding-Unicode-Strings"><a href="#三、Coding-Unicode-Strings" class="headerlink" title="三、Coding Unicode Strings"></a>三、Coding Unicode Strings</h3><p><strong>1、Python的字符串字面量支持 “\xNN” 十六进制字节值转义以及 “\uNNNN” 和 “\UNNNNNNNN” Unicode 转义</strong><br>在 Unicode 转义中，第一种形式用4位十六进制数编码2字节字符码点，第二种形式用8位十六进制数编码4字节码点。</p><p><strong>2、编写 ASCII 文本</strong><br>ASCII 文本是一个简单的 Unicode 类型，作为字节值序列存储：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;X&#x27;</span>))</span><br><span class="line">S = <span class="string">&#x27;XYZ&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;ascii&#x27;</span>)) <span class="comment"># Values 0..127 in 1 byte (7 bits) each</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;latin-1&#x27;</span>)) <span class="comment"># Values 0..255 in 1 byte (8 bits) each</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># Values 0..127 in 1 byte, 128..2047 in 2, others 3 or 4</span></span><br></pre></td></tr></table></figure><p><strong>3、编写非 ASCII 文本</strong><br>①在 str 里，通过十六进制转义或者 Unicode 转义( escapes )；<br>②在 byte 中，通过十六进制转义。</p><p>十六进制转义 x 要求2个16进制数位，而 Unicode 转义的 u 和 U 分别为4个和8个十六进制数位，例如：十六进制值 0xCD 和 0xE8 。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">0xc4</span>), <span class="built_in">chr</span>(<span class="number">0xe8</span>))</span><br><span class="line">S = <span class="string">&#x27;\xc4\xe8&#x27;</span> <span class="comment"># Single 8-bit value hex escapes: two digits，16^2即2^8，即8位</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line">S = <span class="string">&#x27;\u00c4\u00e8&#x27;</span> <span class="comment"># 16-bit Unicode escapes: four digits each，16^4即2^16，即16位</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line">S = <span class="string">&#x27;\U000000c4\U000000e8&#x27;</span> <span class="comment"># 32-bit Unicode escapes: eight digits each，16^8即2^32，即32位</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure><p><strong>4、编码和解码非 ASCII 文本</strong><br>①编码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;\u00c4\u00e8&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;latin-1&#x27;</span>)) <span class="comment"># 1 byte per character when encoded</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 2 bytes per character when encoded</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(S.encode(<span class="string">&#x27;latin-1&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(S.encode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>②解码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = <span class="string">b&#x27;\xc4\xe8&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(B)) <span class="comment"># 2 raw bytes, two encoded characters</span></span><br><span class="line"><span class="built_in">print</span>(B.decode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br><span class="line"></span><br><span class="line">B = <span class="string">b&#x27;\xc3\x84\xc3\xa8&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(B))</span><br><span class="line"><span class="built_in">print</span>(B.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p><strong>5、混用非 ASCII 字符和 ASCII 字符</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;A\u00c4B\U000000e8C&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(S.encode(<span class="string">&#x27;latin-1&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(S.encode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>对于 UTF-16 和 UTF-32 ，使用每字符2字节和4字节方案，并有着相同大小的编码头：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf-16&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(S.encode(<span class="string">&#x27;utf-32&#x27;</span>))</span><br></pre></td></tr></table></figure><p><strong>6、byte 字节串的转义</strong><br>Python 允许特殊字符以十六进制和 Unicode 转义的方式编码到 str 字符串中，但只能以十六进制转义的方式编码到 bytes 字符串中。</p><p>在 bytes 中，Unicode 转义序列会被当作字符处理：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = <span class="string">b&#x27;A\xC4B\xE8C&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line">B = <span class="string">b&#x27;A\u00C4B\U000000E8C&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(B)</span><br></pre></td></tr></table></figure><p>字节串的字面量要求字符是 ASCII 字符， str 字符串允许字面量包含任何字符：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;AÄBèC&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line">B = <span class="string">b&#x27;AÄBèC&#x27;</span> <span class="comment"># 会出错：SyntaxError: bytes can only contain ASCII literal characters</span></span><br><span class="line">B = <span class="string">b&#x27;A\xC4B\xE8C&#x27;</span> <span class="comment"># Chars must be ASCII, or escapes</span></span><br><span class="line"><span class="built_in">print</span>(B.decode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="四、Using-bytes-Objects"><a href="#四、Using-bytes-Objects" class="headerlink" title="四、Using bytes Objects"></a>四、Using bytes Objects</h3><p><strong>1、<code>Bytes</code> 对象是一个小整数序列，每个整数在0到255之间，显示时打印为 ASCII 字符</strong><br>它支持序列操作以及 str 对象上可用的大多数方法，但不支持格式化方法或 % 格式化表达式。与 str 一样，是不可改变对象。</p><p><strong>2、方法调用</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="string">&#x27;abc&#x27;</span>)) - <span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="string">b&#x27;abc&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="string">b&#x27;abc&#x27;</span>)) - <span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="string">&#x27;abc&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>bytes 的方法需要 bytes 类型的参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = <span class="string">b&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(B.find(<span class="string">b&#x27;pa&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(B.replace(<span class="string">b&#x27;pa&#x27;</span>, <span class="string">b&#x27;XY&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(B.split(<span class="string">b&#x27;pa&#x27;</span>))</span><br></pre></td></tr></table></figure><p><strong>3、序列运算</strong><br>bytes 是一个8位的序列，对其索引会返回表示其二进制值的整数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = <span class="string">b&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">0</span>], B[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(B[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(B))</span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">1</span>:], B[:-<span class="number">1</span>], <span class="built_in">len</span>(B), B + <span class="string">b&#x27;lmn&#x27;</span>, B * <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong>4、创建 bytes 对象的其他方式</strong><br>bytes 构造函数，可以传递 str 和编码名称参数，也可以传递一系列整数的可迭代对象作为参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = <span class="built_in">bytes</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line">B = <span class="built_in">bytes</span>([<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>])</span><br><span class="line"><span class="built_in">print</span>(B)</span><br></pre></td></tr></table></figure><h3 id="五、Using-bytearray-Objects"><a href="#五、Using-bytearray-Objects" class="headerlink" title="五、Using bytearray Objects"></a>五、Using bytearray Objects</h3><p><strong>1、<code>bytearray</code> ，是范围0到255之间的整数的一个可变序列，是 bytes 的可变的变体</strong><br>它支持和 bytes 相同的字符串方法和序列操作，并且支持和列表同样多的可变的原位置修改操作。</p><p><strong>2、bytearray 内置函数来创建 bytearray 对象</strong><br>需要传入编码名称和 str 字符串，或者直接传入字节串 bytes ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">C = <span class="built_in">bytearray</span>(S, <span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"></span><br><span class="line">B = <span class="string">b&#x27;spam&#x27;</span></span><br><span class="line">C = <span class="built_in">bytearray</span>(B)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br></pre></td></tr></table></figure><p>bytearry 对象也是小整数序列，像列表一样可以修改：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(C))</span><br><span class="line"><span class="built_in">print</span>(C[<span class="number">0</span>])</span><br><span class="line">C[<span class="number">0</span>] = <span class="built_in">ord</span>(<span class="string">&#x27;x&#x27;</span>) <span class="comment"># 索引复制要提供一个整数</span></span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line">C[<span class="number">1</span>] = <span class="string">b&#x27;Y&#x27;</span>[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(C)</span><br></pre></td></tr></table></figure><p>可以用列表的方法来原处修改 bytearray ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C.append(<span class="built_in">ord</span>(<span class="string">&#x27;L&#x27;</span>)) <span class="comment"># 接受的也是数字</span></span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line">C.extend(<span class="string">b&#x27;MNO&#x27;</span>) <span class="comment"># extend接受可迭代对象</span></span><br><span class="line"><span class="built_in">print</span>(C)</span><br></pre></td></tr></table></figure><p>序列操作和字符串方法也在 bytearray 上有效：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(C + <span class="string">b&#x27;!#&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(C))</span><br><span class="line">C.replace(<span class="string">b&#x27;xY&#x27;</span>, <span class="string">b&#x27;sp&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"><span class="built_in">print</span>(C * <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="六、Using-Text-and-Binary-Files"><a href="#六、Using-Text-and-Binary-Files" class="headerlink" title="六、Using Text and Binary Files"></a>六、Using Text and Binary Files</h3><p><strong>1、文本模式意味着 str 对象，而二进制模式意味着 bytes 对象</strong><br>①<strong>文本模式文件 Text-mode files</strong> 根据 Unicode 编码来解释文件内容，要么是平台的默认编码名，要么是传递进的编码名；<br>②<strong>二进制模式文件 Binary-mode files</strong> 返回原始的文件内容，作为表示字节值的一个整数序列。  </p><p>open 内置函数的第二个参数决定了要处理文本文件还是二进制文件，比如 rb 就是读取二进制文件，默认模式是 rt ，等同于 r ；文本文件返回一个 str 供读取，需要 str 来写入；二进制文件返回 bytes 供读取，需要一个 bytes 或 bytearray 供写入。</p><p><strong>2、文本文件基础</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">size = file.write(<span class="string">&#x27;abc\n&#x27;</span>)</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>)</span><br><span class="line">text = file.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure><p><strong>3、文本和二进制模式</strong><br>写入时提供 str ，并根据 open 的模式，读取是获得 str 或 bytes ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;w&#x27;</span>).write(<span class="string">&#x27;abc\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br></pre></td></tr></table></figure><p>文本模式在输出时把 \n 转换为 \r\n ，在输入时把 \r\n 转换回 \n ，但二进制模式不会这么做。  </p><p>使用二进制文件，运行类似代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(<span class="string">b&#x27;abc\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br></pre></td></tr></table></figure><p>二进制模式在输出中，\n 没有扩展为 \r\n 。</p><p>\x00 是二进制0字节并且不是一个可打印的字符：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(<span class="string">b&#x27;a\x00c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br></pre></td></tr></table></figure><p>二进制模式文件用 bytes 对象返回其内容，但接受一个 bytes 或 bytearray 对象写入；<br>大多数 python API 接受 bytes 的同时也会接受 bytearray ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BA = <span class="built_in">bytearray</span>(<span class="string">b&#x27;\x01\x02\x03&#x27;</span>)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(BA)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br></pre></td></tr></table></figure><p>以文本模式读取默认字符集以外的二进制数据会出现 UnicodeDecodeError 。</p><p>因为文本模式的输入文件必须能够依据 Unicode 编码来解码内容，所以没有办法在文本模式下读取真正的二进制内容（区分 Unicode 码点和字节值）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>).write(<span class="string">b&#x27;\xFF\xFE\xFD&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br></pre></td></tr></table></figure><p>所以最好文本文件以文本模式读取，二进制文件以二进制模式读取。</p><h3 id="七、Using-Unicode-Files"><a href="#七、Using-Unicode-Files" class="headerlink" title="七、Using Unicode Files"></a>七、Using Unicode Files</h3><p><strong>1、open 内置函数接受一个编码名称，可以自动解码和编码</strong></p><p><strong>2、读写 Unicode 文件</strong><br>把字符串以特定编码写入一个文本文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;A\xc4B\xe8C&#x27;</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;latindata&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;latin-1&#x27;</span>).write(S)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;utf8data&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).write(S)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;latindata&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;utf8data&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br></pre></td></tr></table></figure><p>以特定编码读取文本文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;latindata&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;latin-1&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;utf8data&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).read())</span><br></pre></td></tr></table></figure><p>手动解码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="built_in">open</span>(<span class="string">&#x27;latindata&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(X.decode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br><span class="line">X = <span class="built_in">open</span>(<span class="string">&#x27;utf8data&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(X.decode())</span><br></pre></td></tr></table></figure><p><strong>3、处理 BOM</strong><br>一些编码方式在文件开始处存储了一个特殊的<strong>字节顺序标记（BOM，byte order marker）</strong>序列，来指定数据的大小尾方式 endianness (which end of a string of bits is most significant to its value)，或者声明编码类型。</p><p>如果编码名暗示了 BOM ，python 在输入时会忽略该标记，在输出时写入该标记；例如，在 UTF-16 和 UTF-32 中，BOM 指定大尾或小尾格式；一个 UTF-8 文本可能也会包含一个 BOM ，通常只是申明 UTF-8 格式：<br>①在 UTF-16 中，总是对 utf-16 进行 BOM 处理，而更为特定的编码名称 “utf-16-le” 标示小尾格式；<br>②在 UTF-8 中，更为特定的编程名称 “utf-8-sig” 迫使 python 在输入和输出时分别跳过和写入 BOM ，但是常用的 “utf-8” 不会这样做。</p><p>小尾 Little Endian 方式：低位字节放在内存的低地址处，高位字节放在高地址处；<br>大尾 Big Endian 方式：低位字节放在内存的高地址处，高位字节放在低地址处。</p><p><strong>4、记事本 BOM 示例</strong><br>如果 spam.txt 保存为 UTF-8 模式（默认模式）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getdefaultencoding())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).read())</span><br></pre></td></tr></table></figure><p>如果 spam.txt 保存为 UTF-8 BOM 模式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>).read())</span><br></pre></td></tr></table></figure><p>如果 spam.txt 保存为 UTF-16 BE（大尾）模式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-16&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;spam.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-16-be&#x27;</span>).read())</span><br></pre></td></tr></table></figure><p><strong>5、用 Python 代码让 UTF-8 带有 BOM（使用 utf-8-sig ）</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).write(<span class="string">&#x27;spam\nSPAM\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>).write(<span class="string">&#x27;spam\nSPAM\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).read()) <span class="comment"># Keeps BOM</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>).read()) <span class="comment"># Skips BOM</span></span><br></pre></td></tr></table></figure><p>对于 UTF-16 ，BOM 被自动处理：在输出时，数据以平台本地的大小尾方式书写，并且 BOM 总是存在；</p><p>在输入时，数据根据 BOM 解码，并且总是去掉 BOM ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.byteorder) <span class="comment"># 显示little</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-16&#x27;</span>).write(<span class="string">&#x27;spam\nSPAM\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-16&#x27;</span>).read())</span><br></pre></td></tr></table></figure><p>UTF-16 编码名称可以指定不同的大小尾：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-16-be&#x27;</span>).write(<span class="string">&#x27;\ufeffspam\nSPAM\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-16&#x27;</span>).read())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-16-be&#x27;</span>).read())</span><br></pre></td></tr></table></figure><h3 id="八、Other-String-Tool"><a href="#八、Other-String-Tool" class="headerlink" title="八、Other String Tool"></a>八、Other String Tool</h3><p>本节内容较为简单，需额外查阅其他资料。</p><p><strong>1、re 模式匹配模块 re Pattern-Matching Module（正则表达式）</strong><br>这里介绍得太简单了，详见菜鸟教程。</p><p>re 模块使 Python 语言拥有全部的正则表达式功能，可用于 str 、 bytes 和 bytearray ；<code>re.match</code>函数；在模式字符串中，(.*)表示任意除换行符（\n、\r）之外字符，(.)重复0或多次(*)，并作为匹配的子字符串单独保存；groups() 方法返回一个包含所有小组字符串的元组：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">S = <span class="string">&#x27;Bugger all down here on earth!&#x27;</span></span><br><span class="line">B = <span class="string">b&#x27;Bugger all down here on earth!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(re.<span class="keyword">match</span>(<span class="string">&#x27;(.*) down (.*) on (.*)&#x27;</span>, S).groups())</span><br><span class="line"><span class="built_in">print</span>(re.<span class="keyword">match</span>(<span class="string">b&#x27;(.*) down (.*) on (.*)&#x27;</span>, B).groups())</span><br></pre></td></tr></table></figure><p><strong>2、struct 二进制数据模块</strong><br>struct 模块用来从字符串中创建和提取打包的二进制数据：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">B = struct.pack(<span class="string">&#x27;&gt;i4sh&#x27;</span>, <span class="number">7</span>, <span class="string">b&#x27;spam&#x27;</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line">vals = struct.unpack(<span class="string">&#x27;&gt;i4sh&#x27;</span>, B)</span><br></pre></td></tr></table></figure><p>也可以创建和读取二进制文件：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F = <span class="built_in">open</span>(<span class="string">&#x27;data.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">data = struct.pack(<span class="string">&#x27;&gt;i4sh&#x27;</span>, <span class="number">7</span>, <span class="string">b&#x27;spam&#x27;</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">F.write(data)</span><br><span class="line">F.close()</span><br><span class="line"></span><br><span class="line">F = <span class="built_in">open</span>(<span class="string">&#x27;data.bin&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">data = F.read()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">values = struct.unpack(<span class="string">&#x27;&gt;i4sh&#x27;</span>, data)</span><br><span class="line"><span class="built_in">print</span>(values)</span><br></pre></td></tr></table></figure><p><strong>3、pickle 对象序列化模块</strong><br>pickle 总是创建一个 bytes 对象（不管传入的协议），使用该模块的 dumps 调用来返回对象的pickle 字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="built_in">print</span>(pickle.dumps([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment"># default protocol=3=binary</span></span><br><span class="line"><span class="built_in">print</span>(pickle.dumps([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], protocol=<span class="number">0</span>)) <span class="comment"># ASCII protocol 0</span></span><br></pre></td></tr></table></figure><p>存储 pickle 化对象的文件必须总是以二进制模式打开：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pickle.dump([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(pickle.load(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;temp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read())</span><br></pre></td></tr></table></figure><p><strong>4、XML 解析工具 Parsing Tools</strong><br>XML 是一种基于标签的语言，用于定义结构化信息，通常用来定义通过Web传输的文档和数据；Python 自身附带一个完整的 XML 解析工具包，支持 SAX 和 DOM 解析模式。</p><p>不抄写，学了 XML 后可以再来了解。</p><h2 id="Chapter-38-Managed-Attributes"><a href="#Chapter-38-Managed-Attributes" class="headerlink" title="Chapter 38 Managed Attributes"></a>Chapter 38 Managed Attributes</h2><h3 id="一、Why-Manage-Attributes"><a href="#一、Why-Manage-Attributes" class="headerlink" title="一、Why Manage Attributes"></a>一、Why Manage Attributes</h3><p><strong>1、为什么使用被管理的属性</strong><br>对工具构建者来说，被管理属性的访问是灵活的 API 的一个重要部分；</p><p>在整个程序对使用了某名称的所有地方都进行修改，不是个小任务，可以选择编写方法来管理对属性值的访问。</p><p><strong>2、属性访问器 attribute accessor</strong><br>四种访问器技术：<br>① <code>__getattr__</code> 和 <code>__setattr__</code> 方法，用于把未定义的属性获取和所有属性赋值路由到通用的处理方法；<br>② <code>__getattribute__</code> 方法，用于把所有属性获取都路由到一个泛化的处理方法；<br>③ <code>property</code> 内置函数，用于把特定属性访问路由到 <code>get</code> 和 <code>set</code> 函数；<br>④描述符协议，用于把特定属性访问路由到具有任意访问和修改处理方法的类的实例，是 <code>property</code> 和 <code>slot</code> 工具的基础。  </p><p>这4中属性拦截技术都用于把任意属性路由到被包装对象的、基于委托的代理类。</p><h3 id="二、Properties"><a href="#二、Properties" class="headerlink" title="二、Properties"></a>二、Properties</h3><p><strong>property</strong> 协议允许我们把一个特定属性的获取、设置和修改操作指向我们所提供的函数或方法，使得我们能够插入在属性访问时自动运行的代码，或是拦截属性的删除；</p><p>property 内置函数可以创建 property 并将其赋值给类属性，跟方法函数一样；同时也是可以被子类和实例继承的属性；<br>property 的访问拦截函数带有 self 实例参数，可以在主体实例上访问状态信息和类属性；<br>一个 property 管理一个单一的、特定的属性；<br>property 就是描述符 descriptors 的一种受限制的形式。</p><p><strong>1、基础知识</strong><br>将 property 赋值给类属性：<code>attribute = property(fget, fset, fdel, doc)</code>  </p><p>参数都不是必需的：<br>① <code>fget</code> 传入函数（或类方法）用于拦截属性访问；<br>② <code>fset</code>（或类方法）传入函数用于属性赋值；<br>③ <code>fdel</code>（或类方法）传入函数用于属性删除；<br>④ <code>fget</code> 函数返回被计算好的属性值，<code>fset</code> 和 <code>fdel</code> 返回 None ；<br>⑤ <code>doc</code> 参数接受该属性的一个文档字符串。</p><p>property 函数返回一个 property 对象，将其赋予要被管理的类属性名称，它又被类的所有实例继承。</p><p><strong>2、第一个示例</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self._name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;fetch...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setName</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;change...&#x27;</span>)</span><br><span class="line">        self._name = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;remove...&#x27;</span>)</span><br><span class="line">        <span class="keyword">del</span> self._name</span><br><span class="line">    name = <span class="built_in">property</span>(getName, setName, delName, <span class="string">&quot;name property docs&quot;</span>)</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name) <span class="comment"># 属性访问Runs getName</span></span><br><span class="line">bob.name = <span class="string">&#x27;Robert Smith&#x27;</span> <span class="comment"># 属性赋值Runs setName，打印出change...</span></span><br><span class="line"><span class="built_in">print</span>(bob.name) <span class="comment"># 属性访问Runs getName</span></span><br><span class="line"><span class="keyword">del</span> bob.name <span class="comment"># 属性删除Runs delName</span></span><br><span class="line"></span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sue.name)</span><br><span class="line"><span class="built_in">print</span>(Person.name.__doc__)</span><br></pre></td></tr></table></figure><p><strong>3、动态地计算属性的值</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PropSquare</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start</span>):</span><br><span class="line">        self.value = start</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getX</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setX</span>(<span class="params">self, value</span>): </span><br><span class="line">        self.value = value</span><br><span class="line">    X = <span class="built_in">property</span>(getX, setX)</span><br><span class="line"></span><br><span class="line">P = PropSquare(<span class="number">3</span>)</span><br><span class="line">Q = PropSquare(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(P.X)</span><br><span class="line">P.X = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(P.X)</span><br><span class="line"><span class="built_in">print</span>(Q.X)</span><br></pre></td></tr></table></figure><p><strong>4、使用装饰器编写 property</strong><br>property 对象也有 getter 、 setter 和 deleter 方法，这些方法赋值了相应的 property 访问器方法，并且返回了 property 自身的副本。</p><p>可以通过装饰器来指定这些组件，getter 组件由创建 property 自身的行为来自动填充：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self._name = name</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property </span><span class="comment"># name = property(name)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;name property docs&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;fetch...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter </span><span class="comment"># name = name.setter(name)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;change...&#x27;</span>)</span><br><span class="line">        self._name = value</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @name.deleter </span><span class="comment"># name = name.deleter(name)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;remove...&#x27;</span>)</span><br><span class="line">        <span class="keyword">del</span> self._name</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line">bob.name = <span class="string">&#x27;Robert Smith&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line"><span class="keyword">del</span> bob.name</span><br></pre></td></tr></table></figure><h3 id="三、Descriptors"><a href="#三、Descriptors" class="headerlink" title="三、Descriptors"></a>三、Descriptors</h3><p><strong>描述符</strong>协议允许把一个特定的属性的获取、设置和删除操作指向一个单独类对象的方法； property 是描述符的一种。</p><p>描述符编写成独立的类，它们就像方法函数一样赋值给类属性，会被子类和实例继承；通过为描述符自身提供一个 self ，或通过让客户类实例的属性引用描述符对象。因此它们可以保留和使用自身的状态信息，以及主体实例的状态信息。</p><p>描述符也管理一个单一的、指定的属性。</p><p><strong>1、基础知识</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Descriptor</span>:</span><br><span class="line">    <span class="string">&quot;docstring goes here&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>): ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self, instance</span>): ...</span><br></pre></td></tr></table></figure><p>所有带有这些方法（ <code>__get__</code> 、 <code>__set__</code> 和 <code>__delete__</code> ）的类都可以看作描述符。</p><p>与 property 不同，省略了 <code>__set__</code> 意味着允许被管理的属性通过赋值重新定义，这样就会隐藏描述符；要使一个属性是只读的，必须定义 <code>__set__</code> 来捕获赋值并引发一个异常；带有 <code>__set__</code> 的描述符被称为数据描述符 data descriptor ，相比于其他正常继承规则而定位的属性拥有优先权。</p><p>区分描述符的 <code>__delete__</code> 方法和常见的 <code>__del__</code> 方法，前者会在试图删除被管理属性的名称时被调用；而后者是通用的实例析构函数方法，会在任何类的实例将要进行垃圾回收时被调用。</p><p><strong>2、描述符方法参数</strong><br><code>__get__</code> 访问方法额外接受一个 owner 参数，指定了描述符实例所依附的类；instance 参数要么是被访问属性的实例，要么当访问的属性是类属性的时候是 None 。</p><p>属性获取自动传递到 <code>__get__</code> 方法中的参数，<code>X.attr -&gt; Descriptor.__get__(Subject.attr, X, Subject)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Descriptor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(self, instance, owner, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>:</span><br><span class="line">    attr = Descriptor()</span><br><span class="line"></span><br><span class="line">X = Subject()</span><br><span class="line">X.attr</span><br><span class="line">Subject.attr</span><br></pre></td></tr></table></figure><p><strong>3、只读描述符 Read-only descriptors</strong><br>在描述符类中捕获赋值操作并引发一个异常来阻止属性赋值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">*args</span>): <span class="built_in">print</span>(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">*args</span>): <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;cannot set&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    a = D()</span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line">X.a</span><br><span class="line">X.a = <span class="number">99</span> <span class="comment"># 会出错：AttributeError: cannot set</span></span><br></pre></td></tr></table></figure><p><strong>4、第一个示例</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span>:</span><br><span class="line">    <span class="string">&quot;name descriptor docs&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;fetch...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> instance._name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;change...&#x27;</span>)</span><br><span class="line">        instance._name = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self, instance</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;remove...&#x27;</span>)</span><br><span class="line">        <span class="keyword">del</span> instance._name</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self._name = name</span><br><span class="line">    name = Name()</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name) <span class="comment"># Runs Name.__get__</span></span><br><span class="line">bob.name = <span class="string">&#x27;Robert Smith&#x27;</span> <span class="comment"># Runs Name.__set__</span></span><br><span class="line"><span class="built_in">print</span>(bob.name) <span class="comment"># Runs Name.__get__</span></span><br><span class="line"><span class="keyword">del</span> bob.name <span class="comment"># Runs Name.__delete__</span></span><br><span class="line"></span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sue.name)</span><br><span class="line"><span class="built_in">print</span>(Name.__doc__)</span><br></pre></td></tr></table></figure><p>描述符的 <code>__get__</code>方法里，self 是 Name 类实例，instance 是 Person 类实例，owner 是 Person 类。描述符类实例是一个类的属性，因此被客户类和所有实例和子类继承。</p><p><strong>5、动态地计算属性的值</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DescSquare</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start</span>):</span><br><span class="line">        self.value = start</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client1</span>:</span><br><span class="line">    X = DescSquare(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client2</span>:</span><br><span class="line">    X = DescSquare(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">c1 = Client1()</span><br><span class="line">c2 = Client2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c1.X)</span><br><span class="line">c1.X = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(c1.X)</span><br><span class="line"><span class="built_in">print</span>(c2.X)</span><br></pre></td></tr></table></figure><p><strong>6、在描述符中使用状态信息</strong><br>在上面2个描述符的例子中，第一个例子（ name 属性）使用了存储在客户实例中的数据，第二个例子（属性平方）使用了附加到描述符对象本身的数据；</p><p>描述符可以使用实例状态和描述符状态，或者二者的任意组合：<br>①描述符状态用于管理描述符内部使用的数据，或是横跨所有实例的数据；<br>②实例状态记录了和客户类相关、或是被客户类创建的信息。  </p><p>描述符状态基于描述符的数据，实例状态基于客户类实例的数据。</p><p>下面的描述符把信息附加到了它自己的实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DescState</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;DescState get&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.value * <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;DescState set&#x27;</span>)</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalcAttrs</span>:</span><br><span class="line">    X = DescState(<span class="number">2</span>)</span><br><span class="line">    Y = <span class="number">3</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.Z = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">obj = CalcAttrs()</span><br><span class="line"><span class="built_in">print</span>(obj.X, obj.Y, obj.Z)</span><br><span class="line">obj.X = <span class="number">5</span></span><br><span class="line">CalcAttrs.Y = <span class="number">6</span></span><br><span class="line">obj.Z = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(obj.X, obj.Y, obj.Z)</span><br><span class="line"></span><br><span class="line">obj2 = CalcAttrs()</span><br><span class="line"><span class="built_in">print</span>(obj2.X, obj2.Y, obj2.Z)</span><br></pre></td></tr></table></figure><p>这段代码的内部 value 信息仅存在于描述符之中；这里只管理了描述符的属性，即对 X 的获取和设置访问被拦截，对 Y 和 Z 的访问没被拦截。</p><p>对描述符存储或使用附加到客户类实例中的一个属性：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InstState</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;InstState get&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> instance._X * <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;InstState set&#x27;</span>)</span><br><span class="line">        instance._X = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalcAttrs</span>:</span><br><span class="line">    X = InstState()</span><br><span class="line">    Y = <span class="number">3</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._X = <span class="number">2</span></span><br><span class="line">        self.Z = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">obj = CalcAttrs()</span><br><span class="line"><span class="built_in">print</span>(obj.X, obj.Y, obj.Z)</span><br><span class="line">obj.X = <span class="number">5</span></span><br><span class="line">CalcAttrs.Y = <span class="number">6</span></span><br><span class="line">obj.Z = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(obj.X, obj.Y, obj.Z)</span><br><span class="line"></span><br><span class="line">obj2 = CalcAttrs()</span><br><span class="line"><span class="built_in">print</span>(obj2.X, obj2.Y, obj2.Z)</span><br></pre></td></tr></table></figure><p>可以同时使用这2种状态信息：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DescBoth</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s, %s&#x27;</span> % (self.data, instance.data)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        instance.data = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">    managed = DescBoth(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"></span><br><span class="line">I = Client(<span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(I.managed)</span><br><span class="line">I.managed = <span class="string">&#x27;SPAM&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(I.managed)</span><br><span class="line"><span class="built_in">print</span>(I.data)</span><br></pre></td></tr></table></figure><h3 id="四、-getattr-and-getattribute"><a href="#四、-getattr-and-getattribute" class="headerlink" title="四、__getattr__ and __getattribute__"></a>四、__getattr__ and __getattribute__</h3><p>① <code>__getattr__</code> 针对未定义的属性运行，只能为不存储在实例中或是不继承自它的类的属性运行；<br>② <code>__getattribute__</code> 针对所有的属性运行，要避免把属性访问传递给父类而导致递归循环。</p><p>这两个方法更加通用，更适合基于委托 delegation-based 的编码模式：用于实现包装器 wrapper （或代理 proxy ）来管理对一个内嵌对象的所有属性访问。</p><p>这两种方法拦截属性获取；<code>__setattr__</code> 方法捕获赋值对属性的更改；<code>__delattr__</code> 方法拦截属性删除。</p><p><strong>1、基础知识</strong><br>① <code>def __getattr__(self, name):</code> On undefined attribute fetch [obj.name]<br>② <code>def __getattribute__(self, name):</code> On all attribute fetch [obj.name]<br>③ <code>def __setattr__(self, name, value):</code> On all attribute assignment [obj.name=value]<br>④ <code>def __delattr__(self, name):</code> On all attribute deletion [del obj.name]<br>2个 get 方法返回属性的值，另外2个返回 None 。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Catcher</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Get: %s&#x27;</span> % name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Set: %s %s&#x27;</span> % (name, value))</span><br><span class="line"></span><br><span class="line">X = Catcher()</span><br><span class="line">X.job</span><br><span class="line">X.pay</span><br><span class="line">X.pay = <span class="number">99</span></span><br></pre></td></tr></table></figure><p><strong>2、避免属性拦截方法的循环</strong><br>由于 <code>__getattribute__</code> 和 <code>__setattr__</code> 针对所有的属性运行，要避免自己调用自己而触发递归循环 recursive loop 。</p><p>①比如在 <code>__getattribute__</code> 方法内的属性获取，会再次触发 <code>__getaatribute__</code> ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, name</span>):</span><br><span class="line">    x = self.other</span><br></pre></td></tr></table></figure><p>当属性访问被编写在 <code>__getattribute__</code> 自身中，要避免循环，就需要另外把获取指向更高的父类，从而跳过这个层级的版本。因为object类总是新式类的父类，选择它比较好：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, name</span>):</span><br><span class="line">    x = <span class="built_in">object</span>.__getattribute__(self, <span class="string">&#x27;other&#x27;</span>)</span><br></pre></td></tr></table></figure><p>②在 <code>__setattr__</code> 方法内赋值任何属性，都会再次触发 <code>__setattr__</code> ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">    self.other = value</span><br></pre></td></tr></table></figure><p>为解决这个问题，可以把属性赋值为实例的 <code>__dict__</code> 命名空间字典中的一个键赋值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">    self.__dict__[<span class="string">&#x27;other&#x27;</span>] = value</span><br></pre></td></tr></table></figure><p>也可以把自己属性赋值传递给一个更高的父类而避免循环：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">    <span class="built_in">object</span>.__setattr__(self, <span class="string">&#x27;other&#x27;</span>, value)</span><br></pre></td></tr></table></figure><p><strong>3、第一个示例</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self._name = name <span class="comment"># Triggers __setattr__！！</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get: &#x27;</span> + attr)</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;name&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self._name</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(attr)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, attr, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;set: &#x27;</span> + attr)</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;name&#x27;</span>:</span><br><span class="line">            attr = <span class="string">&#x27;_name&#x27;</span></span><br><span class="line">        self.__dict__[attr] = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;del: &#x27;</span> + attr)</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;name&#x27;</span>:</span><br><span class="line">            attr = <span class="string">&#x27;_name&#x27;</span></span><br><span class="line">        <span class="keyword">del</span> self.__dict__[attr]</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name) <span class="comment"># Runs __getattr__</span></span><br><span class="line">bob.name = <span class="string">&#x27;Robert Smith&#x27;</span> <span class="comment"># Runs __setattr__</span></span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line"><span class="keyword">del</span> bob.name <span class="comment"># Runs __delattr__</span></span><br><span class="line"></span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sue.name)</span><br></pre></td></tr></table></figure><p><strong>4、使用 <code>__getattribute__</code></strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, attr</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;get: &#x27;</span> + attr)</span><br><span class="line">    <span class="keyword">if</span> attr == <span class="string">&#x27;name&#x27;</span>:</span><br><span class="line">        attr = <span class="string">&#x27;_name&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self, attr)</span><br></pre></td></tr></table></figure><p>把 <code>__getattr__</code> 替换为这个，结果是类似的，但是在 <code>__setattr__</code> 的获取中会触发一次额外的 <code>__getattribute__</code> 调用。</p><p><strong>5、计算出的属性</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AttrSquare</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start</span>):</span><br><span class="line">        self.value = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.value ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(attr)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, attr, value</span>):</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">            attr = <span class="string">&#x27;value&#x27;</span></span><br><span class="line">        self.__dict__[attr] = value</span><br><span class="line">    </span><br><span class="line">A = AttrSquare(<span class="number">3</span>)</span><br><span class="line">B = AttrSquare(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.X)</span><br><span class="line">A.X = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(A.X)</span><br><span class="line"><span class="built_in">print</span>(B.X)</span><br></pre></td></tr></table></figure><p><strong>6、__getattr__和__getattribute__的区别</strong><br>attr1 是一个类属性，attr2 是一个实例属性，attr3 是一个在获取时被管理的属性：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GetAttr</span>:</span><br><span class="line">    attr1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.attr2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get: &#x27;</span> + attr)</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;attr3&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(attr)</span><br><span class="line"></span><br><span class="line">X = GetAttr()</span><br><span class="line"><span class="built_in">print</span>(X.attr1)</span><br><span class="line"><span class="built_in">print</span>(X.attr2)</span><br><span class="line"><span class="built_in">print</span>(X.attr3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetAttribute</span>:</span><br><span class="line">    attr1 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.attr2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get: &#x27;</span> + attr)</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;attr3&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">object</span>.__getattribute__(self, attr)</span><br><span class="line"></span><br><span class="line">X = GetAttribute()</span><br><span class="line"><span class="built_in">print</span>(X.attr1)</span><br><span class="line"><span class="built_in">print</span>(X.attr2)</span><br><span class="line"><span class="built_in">print</span>(X.attr3)</span><br></pre></td></tr></table></figure><p><code>__getattr__</code> 只拦截 attr3 的访问，因为 attr3 是未定义的。</p><h2 id="Chapter-39-Decorators"><a href="#Chapter-39-Decorators" class="headerlink" title="Chapter 39 Decorators"></a>Chapter 39 Decorators</h2><h3 id="一、The-Basics"><a href="#一、The-Basics" class="headerlink" title="一、The Basics"></a>一、The Basics</h3><p><strong>装饰 Decoration</strong> 是一种为函数和类指定管理或扩增代码的一种方式；即分为<strong>函数装饰器 Function decorators</strong>和<strong>类装饰器 Class decorators</strong> 。</p><p><strong>1、函数装饰器</strong></p><p>①用法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">arg</span>):</span><br><span class="line">    ...</span><br><span class="line">F(<span class="number">99</span>)</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">arg</span>):</span><br><span class="line">    ...</span><br><span class="line">F = decorator(F)</span><br><span class="line">F(<span class="number">99</span>)</span><br></pre></td></tr></table></figure><p>②实现：<br>装饰器自身是一个返回可调用对象的可调用对象（函数和类的任何组合都可以使用）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">F</span>):</span><br><span class="line">    <span class="keyword">return</span> F</span><br></pre></td></tr></table></figure><p>可以用一个装饰器返回和最初函数不同的一个对象；</p><p>用类来实现类似的装饰器，可以重载调用操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">decorator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args</span>):</span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y</span>)</span><br></pre></td></tr></table></figure><p>③支持方法装饰：<br>对类的方法进行装饰，上面的方式就不行了，用嵌套函数会更好：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">F</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y</span>):</span><br><span class="line">    ...</span><br><span class="line">func(<span class="number">6</span>, <span class="number">7</span>) <span class="comment"># calls wrapper(6, 7)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line"><span class="meta">    @decorator</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line">X.method(<span class="number">6</span>, <span class="number">7</span>) <span class="comment"># calls wrapper(X, 6, 7)</span></span><br></pre></td></tr></table></figure><p>这样子 wrapper 在其第一个参数里接收了 C 类的实例。</p><p><strong>2、类装饰器</strong><br>类装饰器是管理类的一种方法，或是使用额外逻辑来完成实例构造调用的一种方式：</p><p>①用法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    ...</span><br><span class="line">x = C(<span class="number">99</span>)</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    ...</span><br><span class="line">C = decorator(C)</span><br><span class="line">x = C(<span class="number">99</span>)</span><br></pre></td></tr></table></figure><p>之后用类名调用创建一个实例时，最终会触发装饰器返回的可调用对象。</p><p>②实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">C</span>):</span><br><span class="line">    <span class="comment"># Save or use class C；Return a different callable: nested def, class with __call__, etc.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: ...</span><br></pre></td></tr></table></figure><p>这样一个类装饰器返回的可调用对象，通常创建并返回最初类的一个新实例，并以某种方式扩展以管理接口。</p><p>比如下面的装饰器插入一个对象来拦截类实例的未定义属性：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Wrapper</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args</span>):</span><br><span class="line">            self.wrapped = cls(*args) <span class="comment"># self.wrapped = C(6, 7)即一个实例</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, name)</span><br><span class="line">    <span class="keyword">return</span> Wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>): <span class="comment"># Run by Wrapper.__init__</span></span><br><span class="line">        self.attr = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"></span><br><span class="line">x = C(<span class="number">6</span>, <span class="number">7</span>) <span class="comment"># Really calls Wrapper(6, 7)</span></span><br><span class="line"><span class="built_in">print</span>(x.attr) <span class="comment"># Runs Wrapper.__getattr__, 返回了self.wrapped.attr，由于self.wrapped为C类的实例，所以prints &quot;spam&quot;</span></span><br></pre></td></tr></table></figure><p>类装饰器通常可以编写为一个创建并返回可调用对象的工厂函数，或是创建并返回类的工厂函数，使用 <code>__init__</code> 或 <code>__call__</code> 方法来拦截调用操作。</p><p>工厂函数通常在外层作用域引用中保持状态，而类在属性中保持状态。</p><p><strong>3、装饰器嵌套</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@A</span></span><br><span class="line"><span class="meta">@B</span></span><br><span class="line"><span class="meta">@C</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">...</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">...</span>):</span><br><span class="line">    ...</span><br><span class="line">f = A(B(C(f)))</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">d1</span>(<span class="params">F</span>): <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="string">&#x27;X&#x27;</span> + F()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">d2</span>(<span class="params">F</span>): <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="string">&#x27;Y&#x27;</span> + F()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">d3</span>(<span class="params">F</span>): <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="string">&#x27;Z&#x27;</span> + F()</span><br><span class="line"></span><br><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="meta">@d3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(): <span class="comment"># func = d1(d2(d3(func)))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func())</span><br></pre></td></tr></table></figure><p><strong>4、装饰器参数</strong><br>函数装饰器和类装饰器都能接受参数，这些参数传递给了返回装饰器的装饰器，而装饰器再返回可调用对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator(<span class="params">A, B</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">arg</span>):</span><br><span class="line">    ...</span><br><span class="line">F(<span class="number">99</span>)</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">arg</span>):</span><br><span class="line">    ...</span><br><span class="line">F = decorator(A, B)(F)</span><br><span class="line">F(<span class="number">99</span>)</span><br></pre></td></tr></table></figure><p>例子中的装饰器函数的例子如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">A, B</span>):</span><br><span class="line">    <span class="comment"># Save or use A, B</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">actualDecorator</span>(<span class="params">F</span>):</span><br><span class="line">        <span class="comment"># Save or use function F</span></span><br><span class="line">        <span class="comment"># Return a callable: nested def, class with __call__, etc.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">callable</span></span><br><span class="line">    <span class="keyword">return</span> actualDecorator</span><br></pre></td></tr></table></figure><h3 id="二、Coding-Function-Decorators"><a href="#二、Coding-Function-Decorators" class="headerlink" title="二、Coding Function Decorators"></a>二、Coding Function Decorators</h3><p>编写函数装饰器的示例：</p><p><strong>1、跟踪调用</strong><br>使用一个函数装饰器，统计被装饰函数的调用次数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.calls = <span class="number">0</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        self.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (self.calls, self.func.__name__))</span><br><span class="line">        self.func(*args)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer </span><span class="comment"># 在def末尾触发tracer的__init__，创建了实例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment"># 触发tracer的__call__</span></span><br><span class="line">spam(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(spam.calls)</span><br><span class="line"><span class="built_in">print</span>(spam)</span><br></pre></td></tr></table></figure><p><strong>2、装饰器状态保持方案</strong><br>实例属性、全局变量、非局部闭包变量和函数属性，都可以用于保持状态：</p><p>①类实例属性<br>上个例子的扩展版本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>): </span><br><span class="line">        self.calls = <span class="number">0</span> <span class="comment"># 类实例属性保存状态</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        self.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (self.calls, self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eggs</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x ** y)</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">spam(a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">eggs(<span class="number">2</span>, <span class="number">16</span>)</span><br><span class="line">eggs(<span class="number">4</span>, y=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>②外层作用域和全局变量<br>闭包函数（带有外围def作用域引用和嵌套的def）可以实现同样的效果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">calls = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tracer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">global</span> calls</span><br><span class="line">        calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (calls, func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eggs</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x ** y)</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">spam(a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">eggs(<span class="number">2</span>, <span class="number">16</span>)</span><br><span class="line">eggs(<span class="number">4</span>, y=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>上面的方案因为计数器是全局变量，意味着被每个被包装函数所共享，对于任何函数调用，计数器都会累计，而不是各自独立计数。</p><p>③外层作用域和非局部变量<br>修改上面方案，改为外层作用域的非局部变量，允许拥有各自的状态：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tracer</span>(<span class="params">func</span>):</span><br><span class="line">    calls = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> calls</span><br><span class="line">        calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (calls, func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eggs</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x ** y)</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">spam(a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">eggs(<span class="number">2</span>, <span class="number">16</span>)</span><br><span class="line">eggs(<span class="number">4</span>, y=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>④函数属性<br>使用 <code>func.attr = value</code> 也可以实现于 nonlocal 版本一样的结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tracer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        wrapper.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (wrapper.calls, func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    wrapper.calls = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eggs</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x ** y)</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">spam(a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">eggs(<span class="number">2</span>, <span class="number">16</span>)</span><br><span class="line">eggs(<span class="number">4</span>, y=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>⑤错误：对方法进行装饰<br>最上面跟踪调用的例子无法对类方法进行装饰，会发生错误；<br>根源在于 tracer 的 <code>__call__</code> 方法的 self 参数，是一个 tracer 的实例，而并未在参数列表传递被装饰的类的主体。<br>被装饰的主体类的实例没有包括在 *args 中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.calls = <span class="number">0</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        self.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (self.calls, self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, pay</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.pay = pay</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @tracer</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent</span>):</span><br><span class="line">        self.pay *= (<span class="number">1.0</span> + percent)</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>, <span class="number">50000</span>)</span><br><span class="line">bob.giveRaise(<span class="number">.25</span>) <span class="comment"># 会出错，因为tracer(giveRaise)(bob, .25)中的bob不会被*args接收</span></span><br></pre></td></tr></table></figure><p>⑥使用嵌套函数装饰方法<br>可以在简单函数和类级别的方法上都能工作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tracer</span>(<span class="params">func</span>):</span><br><span class="line">    calls = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onCall</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> calls</span><br><span class="line">        calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (calls, func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> onCall</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eggs</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> ** N</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">spam(a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(eggs(<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, pay</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.pay = pay</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @tracer</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent</span>): <span class="comment"># giveRaise = tracer(giveRaise)，调用时返回onCall(sue, .10)</span></span><br><span class="line">        self.pay *= (<span class="number">1.0</span> + percent)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @tracer</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name.split()[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;methods...&#x27;</span>)</span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>, <span class="number">50000</span>)</span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name, sue.name)</span><br><span class="line">sue.giveRaise(<span class="number">.10</span>) <span class="comment"># Runs onCall(sue, .10)，返回了giveRaise(sue, .10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(sue.pay))</span><br><span class="line"><span class="built_in">print</span>(bob.lastName(), sue.lastName())</span><br></pre></td></tr></table></figure><p>⑦使用描述符装饰方法<br>由于描述符的 <code>__get__</code> 方法在调用时接受描述符类实例和主体类实例，非常适合装饰类方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.calls = <span class="number">0</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        self.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (self.calls, self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> wrapper(self, instance)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wrapper</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, desc, subj</span>): <span class="comment"># save了主体类实例和装饰器（描述符）实例</span></span><br><span class="line">        self.desc = desc <span class="comment"># 装饰器（描述符）实例</span></span><br><span class="line">        self.subj = subj <span class="comment"># 主体实例</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> self.desc(self.subj, *args, **kwargs) <span class="comment"># Runs tracer.__call__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c) <span class="comment"># Uses __call__ only</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, pay</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.pay = pay</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @tracer</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent</span>):</span><br><span class="line">        self.pay *= (<span class="number">1.0</span> + percent)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @tracer</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name.split()[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">spam(a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;methods...&#x27;</span>)</span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>, <span class="number">50000</span>)</span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name, sue.name)</span><br><span class="line">sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(sue.pay))</span><br><span class="line"><span class="built_in">print</span>(bob.lastName(), sue.lastName())</span><br></pre></td></tr></table></figure><p>上面的理解：<br>①被装饰的函数（ spam ）只调用 tracer 类的 <code>__call__</code> ，而不会调用其 <code>__get__</code> ；<br>②被装饰的类方法（ giveRaise 、 lastName ）首先调用 tracer 类的 <code>__get__</code> 来解析方法名获取，返回 wrapper 实例调用，触发了 wrapper 对象的 <code>__call__</code> 方法，转而调用了 <code>tracer.__call__</code> ；<br>③比如 <code>sue.giveRaise(.10)</code> ，首先运行 <code>tracer.__get__</code> ，返回 <code>wrapper(tracer(giveRaise), sue)(sue, .10)</code> ，然后因为调用返回 <code>wrapper.__call__</code> ，即 <code>tracer(giveRaise)(sue, .10)</code> ，因为 sue 不会被 *args 接收，所以不会重复 sue ，见v、错误：对方法进行装饰。最后调用 <code>tracer.__call__</code> ，返回了 <code>giveRaise(sue, .10)</code> 。</p><p>下面的版本和上面的效果一样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tracer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.calls = <span class="number">0</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        self.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (self.calls, self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">return</span> self(instance, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><h3 id="三、Coding-Function-Decorators-2"><a href="#三、Coding-Function-Decorators-2" class="headerlink" title="三、Coding Function Decorators 2"></a>三、Coding Function Decorators 2</h3><p><strong>1、函数装饰器的第二个例子：调用计时</strong><br>包括单次调用计时，也包括全部调用总时间：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">timer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.alltime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kargs</span>):</span><br><span class="line">        start = time.perf_counter()</span><br><span class="line">        result = self.func(*args, **kargs)</span><br><span class="line">        elapsed = time.perf_counter() - start</span><br><span class="line">        self.alltime += elapsed</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %.5f, %.5f&#x27;</span> % (self.func.__name__, elapsed, self.alltime))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listcomp</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">return</span> [x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mapcall</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>((<span class="keyword">lambda</span> x: x * <span class="number">2</span>), <span class="built_in">range</span>(N)))</span><br><span class="line"></span><br><span class="line">result = listcomp(<span class="number">5</span>)</span><br><span class="line">listcomp(<span class="number">50000</span>)</span><br><span class="line">listcomp(<span class="number">500000</span>)</span><br><span class="line">listcomp(<span class="number">1000000</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;allTime = %s&#x27;</span> % listcomp.alltime) <span class="comment"># listcomp是timer的实例</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">result = mapcall(<span class="number">5</span>)</span><br><span class="line">mapcall(<span class="number">50000</span>)</span><br><span class="line">mapcall(<span class="number">500000</span>)</span><br><span class="line">mapcall(<span class="number">1000000</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;allTime = %s&#x27;</span> % mapcall.alltime)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n**map/comp = %s&#x27;</span> % <span class="built_in">round</span>(mapcall.alltime / listcomp.alltime, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>实际上如果 map 没有将其包装在一个 list 调用中迫使结果生成， map 测试在 Python 中几乎不花时间，它返回一个可迭代对象而没有进行迭代。</p><p><strong>2、添加装饰器参数</strong><br>提供一个输出标签并且可以打开或关闭跟踪消息：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">label=<span class="string">&#x27;&#x27;</span>, trace=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Timer</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">            self.func = func</span><br><span class="line">            self.alltime = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kargs</span>):</span><br><span class="line">            start = time.perf_counter()</span><br><span class="line">            result = self.func(*args, **kargs)</span><br><span class="line">            elapsed = time.perf_counter() - start</span><br><span class="line">            self.alltime += elapsed</span><br><span class="line">            <span class="keyword">if</span> trace:</span><br><span class="line">                <span class="built_in">format</span> = <span class="string">&#x27;%s %s: %.5f, %.5f&#x27;</span></span><br><span class="line">                values = (label, self.func.__name__, elapsed, self.alltime)</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">format</span> % values)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外层的 timer 函数，返回 Timer 类作为实际的装饰器。装饰时，它记住了被装饰的函数自身，还能访问位于外围函数作用域中的装饰器参数（ label 和 trace ）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params">label=<span class="string">&#x27;[CCC]==&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listcomp</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">return</span> [x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params">trace=<span class="literal">True</span>, label=<span class="string">&#x27;[MMM]==&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mapcall</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>((<span class="keyword">lambda</span> x: x * <span class="number">2</span>), <span class="built_in">range</span>(N)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> (listcomp, mapcall):</span><br><span class="line">    result = func(<span class="number">5</span>)</span><br><span class="line">    func(<span class="number">50000</span>)</span><br><span class="line">    func(<span class="number">500000</span>)</span><br><span class="line">    func(<span class="number">1000000</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;allTime = %s\n&#x27;</span> % func.alltime)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;**map/comp = %s&#x27;</span> % <span class="built_in">round</span>(mapcall.alltime / listcomp.alltime, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><h3 id="四、Coding-Class-Decorators"><a href="#四、Coding-Class-Decorators" class="headerlink" title="四、Coding Class Decorators"></a>四、Coding Class Decorators</h3><p>类装饰器可以用于管理类自身，或者用来拦截实例创建调用以管理实例。</p><p><strong>1、单例类 Singleton Classes</strong><br>下面的代码实现了传统的单例编程模式 classic singleton coding pattern ，其中每个类最多只有一个实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">aClass</span>): <span class="comment"># 接受被包装类，并保留状态信息，返回onCall</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onCall</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> aClass <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[aClass] = aClass(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instances[aClass]</span><br><span class="line">    <span class="keyword">return</span> onCall</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>: <span class="comment"># Person = singleton(Person) = onCall，onCall再接受实例参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, hours, rate</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.hours = hours</span><br><span class="line">        self.rate = rate</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.hours * self.rate</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.attr = val</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">40</span>, <span class="number">10</span>) <span class="comment"># 即onCall(&#x27;Bob&#x27;, 40, 10)，并返回Person实例</span></span><br><span class="line"><span class="built_in">print</span>(bob.name, bob.pay())</span><br><span class="line"></span><br><span class="line">sue = Person(<span class="string">&#x27;Sue&#x27;</span>, <span class="number">50</span>, <span class="number">20</span>) <span class="comment"># 无法再创建新的实例，所以sue仍然是bob实例</span></span><br><span class="line"><span class="built_in">print</span>(sue.name, sue.pay())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(instances)</span><br><span class="line"></span><br><span class="line">X = Spam(val=<span class="number">42</span>)</span><br><span class="line">Y = Spam(<span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(X.attr, Y.attr)</span><br></pre></td></tr></table></figure><p><strong>2、编写替代方案</strong><br>①使用 nonlocal 语句改写上面例子，并实现了同样效果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">aClass</span>):</span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onCall</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> instance</span><br><span class="line">        <span class="keyword">if</span> instance == <span class="literal">None</span>:</span><br><span class="line">            instance = aClass(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    <span class="keyword">return</span> onCall</span><br></pre></td></tr></table></figure><p>②使用函数属性，效果同上：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">aClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onCall</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> onCall.instance == <span class="literal">None</span>:</span><br><span class="line">            onCall.instance = aClass(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> onCall.instance</span><br><span class="line">    onCall.instance = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> onCall</span><br></pre></td></tr></table></figure><p>③使用类，为每次装饰使用一个实例，效果同上，这个例子会在后面看到一个常见的装饰器类错误。这里只想要一个实例，实际不是这样。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">singleton</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, aClass</span>):</span><br><span class="line">        self.aClass = aClass</span><br><span class="line">        self.instance = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> self.instance == <span class="literal">None</span>:</span><br><span class="line">            self.instance = self.aClass(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> self.instance</span><br></pre></td></tr></table></figure><p><strong>3、跟踪对象接口</strong><br>类装饰器的另一个常用场景是为每个生成的实例扩展接口；<br>类装饰器可以在实例上安装一个包装器 wrapper 和代理 proxy 逻辑层。</p><p>①非装饰器版的委托示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">object</span></span>):</span><br><span class="line">        self.wrapped = <span class="built_in">object</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attrname</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Trace:&#x27;</span>, attrname)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, attrname)</span><br><span class="line"></span><br><span class="line">x = Wrapper([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">x.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(x.wrapped)</span><br><span class="line"></span><br><span class="line">x = Wrapper(&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(x.keys()))</span><br></pre></td></tr></table></figure><p>②类装饰器版：<br>上面的类示例可以编写为一个类装饰器，能够触发被包装实例的创建；<br>通过拦截实例创建调用，下面的类装饰器允许跟踪整个对象接口（即跟踪对任何属性的访问）；<br>每个实例都会生成一个新的 Wrapper 实例，并拥有自己的访问计数器：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Tracer</span>(<span class="params">aClass</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Wrapper</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kargs</span>):</span><br><span class="line">            self.fetches = <span class="number">0</span></span><br><span class="line">            self.wrapped = aClass(*args, **kargs)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attrname</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Trace: &#x27;</span> + attrname)</span><br><span class="line">            self.fetches += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, attrname)</span><br><span class="line">    <span class="keyword">return</span> Wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tracer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Spam!&#x27;</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tracer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, hours, rate</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.hours = hours</span><br><span class="line">        self.rate = rate</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.hours * self.rate</span><br><span class="line"></span><br><span class="line">food = Spam()</span><br><span class="line">food.display()</span><br><span class="line"><span class="built_in">print</span>([food.fetches])</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line"><span class="built_in">print</span>(bob.pay())</span><br><span class="line"></span><br><span class="line">sue = Person(<span class="string">&#x27;Sue&#x27;</span>, rate=<span class="number">100</span>, hours=<span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(sue.name)</span><br><span class="line"><span class="built_in">print</span>(sue.pay())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line"><span class="built_in">print</span>(bob.pay())</span><br><span class="line"><span class="built_in">print</span>([bob.fetches, sue.fetches])</span><br></pre></td></tr></table></figure><p><strong>4、类错误二：保持多个实例</strong><br>修改上面例子，使用装饰器类来装饰类，而不是装饰器函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, aClass</span>):</span><br><span class="line">        self.aClass = aClass</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        self.wrapped = self.aClass(*args)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attrname</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Trace: &#x27;</span> + attrname)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, attrname)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Tracer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Spam!&#x27;</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">food = Spam() <span class="comment"># Triggers __init__</span></span><br><span class="line">food.display() <span class="comment"># Triggers __getattr__</span></span><br></pre></td></tr></table></figure><p>上面不能处理给定类的多个实例：每个实例构建调用都会触发 <code>__call__</code> ，会覆盖前面的实例，所以 Tracer 只能保存最后创建的实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Tracer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br><span class="line">Sue = Person(<span class="string">&#x27;Sue&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sue.name) <span class="comment"># sue overwrites bob</span></span><br><span class="line"><span class="built_in">print</span>(bob.name)</span><br></pre></td></tr></table></figure><h3 id="五、Managing-Functions-and-Classes-Directly"><a href="#五、Managing-Functions-and-Classes-Directly" class="headerlink" title="五、Managing Functions and Classes Directly"></a>五、Managing Functions and Classes Directly</h3><p><strong>1、 之前的示例，都设计来拦截函数和实例创建调用；下面的示例用于管理函数和类本身</strong><br>下面定义了一个装饰器，把函数或类对象添加到一个基于字典的注册表，并返回对象本身：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">registry = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">obj</span>):</span><br><span class="line">    registry[obj.__name__] = obj</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span>(x ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ham</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span>(x ** <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.data = x ** <span class="number">4</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Registry:&#x27;</span>) </span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> registry:</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, registry[name], <span class="built_in">type</span>(registry[name]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nManual calls:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(spam(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(ham(<span class="number">2</span>))</span><br><span class="line">X = Eggs(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nRegistry calls:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> registry:</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, registry[name](<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><strong>2、函数装饰器也能用来处理函数属性，并且类装饰器可以动态地插入新的类属性或方法</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):</span><br><span class="line">    func.marked = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(spam.marked)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">annotate</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):</span><br><span class="line">        func.label = text</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="meta">@annotate(<span class="params"><span class="string">&#x27;spam data&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(spam(<span class="number">1</span>, <span class="number">2</span>), spam.label)</span><br></pre></td></tr></table></figure><h3 id="六、“Private”-and-“Public”-Attributes"><a href="#六、“Private”-and-“Public”-Attributes" class="headerlink" title="六、“Private” and “Public” Attributes"></a>六、“Private” and “Public” Attributes</h3><p><strong>1、实现私有属性</strong><br>下面的类装饰器实现一个用于类实例属性的 Private 声明；</p><p>不接受被装饰类的外部对属性的获取或修改访问，但仍允许类自身在自己的方法中自由地访问这些名称：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Privacy for attributes fetched from class instances.</span></span><br><span class="line"><span class="string">See self-test code at end of file for a usage example.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Decorator same as: Doubler = Private(&#x27;data&#x27;, &#x27;size&#x27;)(Doubler).</span></span><br><span class="line"><span class="string">Private returns onDecorator, onDecorator returns onInstance,</span></span><br><span class="line"><span class="string">and each onInstance instance embeds a Doubler instance.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">traceMe = <span class="literal">False</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">if</span> traceMe: <span class="built_in">print</span>(<span class="string">&#x27;[&#x27;</span> + <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, args)) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Private</span>(<span class="params">*privates</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onDecorator</span>(<span class="params">aClass</span>):</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">onInstance</span>:</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kargs</span>):</span><br><span class="line">                self.wrapped = aClass(*args, **kargs)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">                trace(<span class="string">&#x27;get:&#x27;</span>, attr)</span><br><span class="line">                <span class="keyword">if</span> attr <span class="keyword">in</span> privates:</span><br><span class="line">                    <span class="keyword">raise</span> TypeError(<span class="string">&#x27;private attribute fetch: &#x27;</span> + attr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, attr)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, attr, value</span>):</span><br><span class="line">                trace(<span class="string">&#x27;set:&#x27;</span>, attr, value)</span><br><span class="line">                <span class="keyword">if</span> attr == <span class="string">&#x27;wrapped&#x27;</span>:</span><br><span class="line">                    self.__dict__[attr] = value <span class="comment"># Avoid looping</span></span><br><span class="line">                <span class="keyword">elif</span> attr <span class="keyword">in</span> privates:</span><br><span class="line">                    <span class="keyword">raise</span> TypeError(<span class="string">&#x27;private attribute change: &#x27;</span> + attr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">setattr</span>(self.wrapped, attr, value)</span><br><span class="line">        <span class="keyword">return</span> onInstance</span><br><span class="line">    <span class="keyword">return</span> onDecorator</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    traceMe = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @Private(<span class="params"><span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;size&#x27;</span></span>)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Doubler</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, label, start</span>):</span><br><span class="line">            self.label = label</span><br><span class="line">            self.data = start</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.size()):</span><br><span class="line">                self.data[i] = self.data[i] * <span class="number">2</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s =&gt; %s&#x27;</span> % (self.label, self.data))</span><br><span class="line">    </span><br><span class="line">X = Doubler(<span class="string">&#x27;X is&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># self.wrapped = aClass(*args, **kargs)触发了__setattr__方法</span></span><br><span class="line">Y = Doubler(<span class="string">&#x27;Y is&#x27;</span>, [-<span class="number">10</span>, -<span class="number">20</span>, -<span class="number">30</span>]) <span class="comment"># 同上</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X.label)</span><br><span class="line">X.display(); X.double(); X.display()</span><br><span class="line"><span class="built_in">print</span>(Y.label)</span><br><span class="line">Y.display(); Y.double()</span><br><span class="line">Y.label = <span class="string">&#x27;Spam&#x27;</span></span><br><span class="line">Y.display()</span><br></pre></td></tr></table></figure><p>下面都会出现错误：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(X.size()) <span class="comment"># prints &quot;TypeError: private attribute fetch: size&quot;</span></span><br><span class="line"><span class="built_in">print</span>(X.data)</span><br><span class="line">X.data = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">X.size = <span class="keyword">lambda</span> S: <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(Y.data)</span><br><span class="line"><span class="built_in">print</span>(Y.size())</span><br></pre></td></tr></table></figure><p>在上述代码，用到了三个层面的状态保存：<br>①传递给 Private 的参数在装饰发生前，作为一个外层作用域保持，供 onDecorator 和 onInstance 使用；<br>② onDecorator 的类参数在装饰时，作为一个外层作用域保持，供实例构建时使用；<br>③被包装的实例对象保存为 onInstance 代理对象中的一个实例属性，以便从类外部访问属性。</p><p><strong>2、公有声明</strong><br>Public 声明一个类的实例属性，可以从任何地方自由地访问，而没有声明为 Public 的任何名称，不能从类的外部访问。</p><p>当使用了 Private ，所有未声明的名称就是 Public ；当使用了 Public ，所有未声明的名称就是 Private 。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Class decorator with Private and Public attribute declarations.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Controls external access to attributes stored on an instance, or</span></span><br><span class="line"><span class="string">Inherited by it from its classes. Private declares attribute names</span></span><br><span class="line"><span class="string">that cannot be fetched or assigned outside the decorated class,</span></span><br><span class="line"><span class="string">and Public declares all the names that can.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Caveat: this works in 3.X for explicitly named attributes only: __X__</span></span><br><span class="line"><span class="string">operator overloading methods implicitly run for built-in operations</span></span><br><span class="line"><span class="string">do not trigger either __getattr__ or __getattribute__ in new-style</span></span><br><span class="line"><span class="string">classes. Add __X__ methods here to intercept and delegate built-ins.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">traceMe = <span class="literal">False</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">if</span> traceMe: <span class="built_in">print</span>(<span class="string">&#x27;[&#x27;</span> + <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, args)) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accessControl</span>(<span class="params">failIf</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">onDecorator</span>(<span class="params">aClass</span>):</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">onInstance</span>:</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kargs</span>):</span><br><span class="line">                self.__wrapped = aClass(*args, **kargs)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">                trace(<span class="string">&#x27;get:&#x27;</span>, attr)</span><br><span class="line">                <span class="keyword">if</span> failIf(attr):</span><br><span class="line">                    <span class="keyword">raise</span> TypeError(<span class="string">&#x27;private attribute fetch: &#x27;</span> + attr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">getattr</span>(self.__wrapped, attr)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, attr, value</span>):</span><br><span class="line">                trace(<span class="string">&#x27;set:&#x27;</span>, attr, value)</span><br><span class="line">                <span class="keyword">if</span> attr == <span class="string">&#x27;_onInstance__wrapped&#x27;</span>: <span class="comment"># 见31-2伪私有属性，__wrapped变成了_onInstance__wrapped</span></span><br><span class="line">                    self.__dict__[attr] = value</span><br><span class="line">                <span class="keyword">elif</span> failIf(attr):</span><br><span class="line">                    <span class="keyword">raise</span> TypeError(<span class="string">&#x27;private attribute change: &#x27;</span> + attr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">setattr</span>(self.__wrapped, attr, value)</span><br><span class="line">        <span class="keyword">return</span> onInstance</span><br><span class="line">    <span class="keyword">return</span> onDecorator</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Private</span>(<span class="params">*attributes</span>):</span><br><span class="line">    <span class="keyword">return</span> accessControl(failIf=(<span class="keyword">lambda</span> attr: attr <span class="keyword">in</span> attributes))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Public</span>(<span class="params">*attributes</span>):</span><br><span class="line">    <span class="keyword">return</span> accessControl(failIf=(<span class="keyword">lambda</span> attr: attr <span class="keyword">not</span> <span class="keyword">in</span> attributes))</span><br><span class="line"></span><br><span class="line"><span class="meta">@Private(<span class="params"><span class="string">&#x27;age&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">X = Person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(X.name)</span><br><span class="line">X.name = <span class="string">&#x27;Sue&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(X.name)</span><br><span class="line"><span class="comment"># X.age # TypeError: private attribute fetch: age</span></span><br><span class="line"><span class="comment"># X.age = &#x27;Tom&#x27; # TypeError: private attribute change: age</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Public(<span class="params"><span class="string">&#x27;name&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">X = Person(<span class="string">&#x27;bob&#x27;</span>, <span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(X.name)</span><br><span class="line">X.name = <span class="string">&#x27;Sue&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(X.name)</span><br><span class="line">X.age <span class="comment"># TypeError: private attribute fetch: age</span></span><br><span class="line">X.age = <span class="string">&#x27;Tom&#x27;</span> <span class="comment"># TypeError: private attribute change: age</span></span><br></pre></td></tr></table></figure><p>虽然控制了对实例及类属性的访问控制，但是仍然可以显示地调用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(X._onInstance__wrapped.age)</span><br></pre></td></tr></table></figure><p>内置操作隐式运行地 <code>__X__</code> 运算符重载方法不会在新式类触发 <code>__getattr__</code> 或 <code>__getattribute__</code> ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Private(<span class="params"><span class="string">&#x27;age&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.age = <span class="number">42</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Person: &#x27;</span> + <span class="built_in">str</span>(self.age)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, yrs</span>):</span><br><span class="line">        self.age += yrs</span><br><span class="line"></span><br><span class="line">X = Person()</span><br><span class="line"><span class="built_in">print</span>(X.age) <span class="comment"># TypeError: private attribute fetch: age</span></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">X + <span class="number">10</span> <span class="comment"># TypeError: unsupported operand type(s) for +: &#x27;onInstance&#x27; and &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Chapter-40-Metaclasses"><a href="#Chapter-40-Metaclasses" class="headerlink" title="Chapter 40 Metaclasses"></a>Chapter 40 Metaclasses</h2><h3 id="一、Metaclass-Basics"><a href="#一、Metaclass-Basics" class="headerlink" title="一、Metaclass Basics"></a>一、Metaclass Basics</h3><p><strong>元类</strong>是创建类的类。  </p><p>某种程度上来说，元类只是扩展了装饰器的代码插入模型，元类允许拦截并扩展类的创建，提供了一种在 class 语句结束时运行插入额外逻辑的 API 。元类主要由构建API工具的程序员使用。  </p><p>类装饰器在被装饰类创建完成之后运行；而元类在类创建过程中就运行，创建并返回新的客户类。</p><p><strong>1、类是类型的实例</strong><br>用户定义的类对象是名为 <strong>type</strong> 的对象的实例，<strong>type</strong> 本身是一个类；<br>类继承自 <strong>object</strong> ， <strong>object</strong> 是 <strong>type</strong> 的一个子类；  </p><p>内置类型的实例的类型是内置的类型，例如列表的实例的类型是 list ，而列表类型的类型是 type 本身。</p><p><strong>类即类型，类型即类</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>([]), <span class="built_in">type</span>(<span class="built_in">type</span>([])))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">list</span>), <span class="built_in">type</span>(<span class="built_in">type</span>))</span><br></pre></td></tr></table></figure><p>用户定义的类是产生它们自己的实例的类型；</p><p>类有链接到 type 的一个 <code>__class__</code> 属性，就像实例有链接到创建它的类的 <code>__class__</code> 一样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">pass</span></span><br><span class="line">X = C()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(X))</span><br><span class="line"><span class="built_in">print</span>(X.__class__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(C))</span><br><span class="line"><span class="built_in">print</span>(C.__class__)</span><br></pre></td></tr></table></figure><p><strong>2、元类是 Type 的子类</strong><br>因为类是 type 类的实例，所以从 type 的定制的子类创建类允许我们实现各种定制的类；</p><p>①元类是 type 类的子类；<br>②类对象是 type 类的实例或子类；</p><p>为了控制创建类以及扩展其行为的方式，可以指定一个用户定义的类创建自一个用户定义的元类，而不是常规的 type 类。</p><p>主要上面的类型实例关系与继承不同，但不会暴露在正常的继承搜索中，即不出现在类的 <code>__bases__</code> 元组中，见后面。</p><p><strong>3、class 语句协议</strong><br>在一条 class 语句的末尾，Python 遵循一个标准协议，运行了所有内嵌的代码后，python 会调用 type 对象来创建 class 对象：<br><code>class = type(classname, superclasses, attributedict)</code>  </p><p>type 对象定义了一个 <code>__call__</code> 运算符重载方法，当 type 被调用时，该方法运行2个其他方法：<br>① <code>type.__new__(typeclass, classname, superclasses, attributedict)</code><br>② <code>type.__init__(class, classname, superclasses, attributedict)</code><br><code>__new__</code> 方法创建并返回新的 class 对象，然后 <code>__init__</code> 方法初始化新创建的对象。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>: ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(<span class="title class_ inherited__">Eggs</span>):</span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br></pre></td></tr></table></figure><p>这里会在 class 语句末尾调用 type 对象来产生 class 对象：<br><code>Spam = type(&#39;Spam&#39;, (Eggs,), &#123;&#39;data&#39;: 1, &#39;meth&#39;: meth, &#39;__module__&#39;: &#39;__main__&#39;&#125;)</code></p><p>也可以显示地调用 type 来动态地创建一个类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">type</span>(<span class="string">&#x27;Spam&#x27;</span>, (), &#123;<span class="string">&#x27;data&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;meth&#x27;</span>: (<span class="keyword">lambda</span> x, y: x.data + y)&#125;) <span class="comment"># 空的父类元组会自动添加object父类</span></span><br><span class="line">i = x()</span><br><span class="line"><span class="built_in">print</span>(x, i)</span><br><span class="line"><span class="built_in">print</span>(i.data, i.meth(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(x.__bases__)</span><br></pre></td></tr></table></figure><p><strong>4、声明元类</strong><br>在类头部把想要使用的元类作为关键字参数列出来：<br><code>class Spam(metaclass=Meta):</code><br>与继承的父类同时列在头部，父类必须列在元类之前：<br><code>class Spam(Eggs, metaclass=Meta):</code></p><p>当一个特定的元类按照上面的语法声明时，运行在 class 语句末尾来创建 class 对象的调用被修改为了调用元类而不是默认的 type ：<code>class = Meta(classname, superclasses, attributedict)</code></p><p>因为元类是 type 的一个子类，所以如果元类定义了 <code>__new__</code> 和 <code>__init__</code> 方法的话，那么 type 的 <code>__call__</code> 会把创建和初始化新的 class 对象的调用委托给元类：<br><code>Meta.__new__(Meta, classname, superclasses, attributedict)</code><br><code>Meta.__init__(class, classname, superclasses, attributedict)</code></p><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=Meta):</span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br></pre></td></tr></table></figure><p>在 class 语句末尾，python 内部会自动运行如下代码：<br><code>Spam = Meta(&#39;Spam&#39;, (Eggs,), &#123;&#39;data&#39;: 1, &#39;meth&#39;: meth, &#39;__module__&#39;: &#39;__main__&#39;&#125;)</code></p><p>如果元类定义了自己的 <code>__new__</code> 或 <code>__init__</code> ，在调用期间，它们会依次由所继承的 type 类的 <code>__call__</code> 方法调用，以创建并初始化新类。</p><h3 id="二、Coding-Metaclasses"><a href="#二、Coding-Metaclasses" class="headerlink" title="二、Coding Metaclasses"></a>二、Coding Metaclasses</h3><p><strong>1、一个基础的元类</strong><br>简单的示例：一个带有 <code>__new__</code> 方法的 type 的子类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Meta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Run by inherited type.__call__&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(meta, classname, supers, classdict)</span><br></pre></td></tr></table></figure><p>元类的 <code>__new__</code> 方法通常执行所需的定制并且调用 type 父类的 <code>__new__</code> 方法来创建并返回新的类对象。</p><p>稍微复杂的示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetaOne</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaOne.new:&#x27;</span>, meta, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(meta, classname, supers, classdict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=MetaOne):</span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making instance&#x27;</span>)</span><br><span class="line">X = Spam()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>, X.data, X.meth(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>在 class 语句末尾调用元类，Spam 继承自 Eggs 并且是 Metaone 的一个实例，X 是 Spam 的一个实例并且继承自 Spam 。</p><p><strong>2、定制构建和初始化</strong><br><code>__new__</code> 创建并返回了类对象，而 <code>__init__</code> 初始化了作为参数被传入的已经创建的类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetaTwo</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaTwo.new: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(meta, classname, supers, classdict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">Class, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaTwo.init:&#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;...init class object:&#x27;</span>, <span class="built_in">list</span>(Class.__dict__.keys()))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=MetaTwo):</span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making instance&#x27;</span>)</span><br><span class="line">X = Spam()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>, X.data, X.meth(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>类初始化方法（ <code>__init__</code> ）在类构建方法（ <code>__new__</code> ）之后运行；<br>Spam 的 <code>__init__</code> 会在实例创建的时候运行，而不会被元类的 <code>__init__</code> 影响。</p><p><strong>3、其他元类编写技巧</strong><br>①使用工厂函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">MetaFunc</span>(<span class="params">classname, supers, classdict</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;In MetaFunc: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(classname, supers, classdict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=MetaFunc):</span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making instance&#x27;</span>)</span><br><span class="line">X = Spam()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>, X.data, X.meth(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>②用普通类重载类创建调用<br>下面的类没有继承自 type ，而是提供了一个 <code>__call__</code> 方法；<br><code>__new__</code> 和 <code>__init__</code> 要重新命名为其他名称（比如下面的 __New__ 和 __Init__ ），否则会在 Meta 实例创建时运行，而不是之后在元类的角色中被调用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetaObj</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaObj.call: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        Class = self.__New__(classname, supers, classdict)</span><br><span class="line">        self.__Init__(Class, classname, supers, classdict)</span><br><span class="line">        <span class="keyword">return</span> Class</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__New__</span>(<span class="params">self, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaObj.new: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(classname, supers, classdict)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Init__</span>(<span class="params">self, Class, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaObj.init:&#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;...init class object:&#x27;</span>, <span class="built_in">list</span>(Class.__dict__.keys()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=MetaObj()): <span class="comment"># MetaObj是一个类实例</span></span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making instance&#x27;</span>)</span><br><span class="line">X = Spam()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>, X.data, X.meth(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>三个方法通过正常实例继承来的 <code>__call__</code> 方法被分发。</p><p>使用父类继承来扮演 type 类似的角色：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMetaObj</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SuperMetaObj.call: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        Class = self.__New__(classname, supers, classdict)</span><br><span class="line">        self.__Init__(Class, classname, supers, classdict)</span><br><span class="line">        <span class="keyword">return</span> Class</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubMetaObj</span>(<span class="title class_ inherited__">SuperMetaObj</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__New__</span>(<span class="params">self, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SubMetaObj.new: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(classname, supers, classdict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__Init__</span>(<span class="params">self, Class, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SubMetaObj.init:&#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;...init class object:&#x27;</span>, <span class="built_in">list</span>(Class.__dict__.keys()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=SubMetaObj()):</span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making instance&#x27;</span>)</span><br><span class="line">X = Spam()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>, X.data, X.meth(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>③用元类重载 <code>__call__</code><br>对 <code>__new__</code> 和 <code>__call__</code> 的重载需调用 type 来启动：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SuperMeta.call: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__call__(meta, classname, supers, classdict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">Class, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SuperMeta init:&#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;...init class object:&#x27;</span>, <span class="built_in">list</span>(Class.__dict__.keys()))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making metaclass&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubMeta</span>(<span class="built_in">type</span>, metaclass=SuperMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SubMeta.new: &#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(meta, classname, supers, classdict)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">Class, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SubMeta init:&#x27;</span>, classname, supers, classdict, sep=<span class="string">&#x27;\n...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;...init class object:&#x27;</span>, <span class="built_in">list</span>(Class.__dict__.keys()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(Eggs, metaclass=SubMeta): <span class="comment"># Invoke SubMeta, via SuperMeta.__call__</span></span><br><span class="line">    data = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;making instance&#x27;</span>)</span><br><span class="line">X = Spam()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>, X.data, X.meth(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>元类用于创造类对象，但是只在作为一个元类角色被调用的时候才产生它们的实例；<br>元类也可以从其他元类继承名称，元类间的继承只适用于显式的名称获取，而不能作用于内置操作的调用的隐式名称查找；<br>内置操作的调用的隐式名称可以在它的 <code>__class__</code> 中找到，要么是默认的 type ，要么是一个元类。</p><p>SubMeta 中的 metaclass 是必要的；<br>SuperMeta 的 <code>__call__</code> 方法不会运行在 SubMeta 创建时的 SuperMeta 调用，而是会运行在 Spam 创建时的 SubMeta 调用；<br>SubMeta 的创建会路由到 type 。</p><p>如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SuperMeta.call:&#x27;</span>, classname)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__call__(meta, classname, supers, classdict)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubMeta</span>(<span class="title class_ inherited__">SuperMeta</span>): <span class="comment"># Created by type default，普通的父类被内置操作跳过，但显式的获取调用不会跳过</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">Class, classname, supers, classdict</span>): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In SubMeta init:&#x27;</span>, classname)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(SubMeta.__class__)</span><br><span class="line"><span class="built_in">print</span>([n.__name__ <span class="keyword">for</span> n <span class="keyword">in</span> SubMeta.__mro__])</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(SubMeta.__call__) <span class="comment"># 显式调用</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">SubMeta.__call__(SubMeta, <span class="string">&#x27;xxx&#x27;</span>, (), &#123;&#125;) <span class="comment"># 显式调用：运行了SuperMeta的__call__，元类继承</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">SubMeta(<span class="string">&#x27;yyy&#x27;</span>, (), &#123;&#125;) <span class="comment"># 隐式内置调用：没运行SuperMeta的__call__，元类的类是type</span></span><br></pre></td></tr></table></figure><p>更深刻的理解见后面。</p><h3 id="三、Inheritance-and-Instance"><a href="#三、Inheritance-and-Instance" class="headerlink" title="三、Inheritance and Instance"></a>三、Inheritance and Instance</h3><p><strong>1、元类和父类继承</strong><br>区分元类的指定方式和父类继承，相似但不一样。</p><p>①元类继承自 type 类<br>元类通常重新定义 type 类的 <code>__new__</code> 和 <code>__init__</code> 方法，也可以重新定义 <code>__call__</code> （不常见，而且会出现上一节中看到的复杂性）</p><p>②元类声明会被子类继承<br><code>metaclass=M</code> 会被该类的普通子类继承，继承了该声明的类的构建都会运行该元类。</p><p>③元类属性不会被类实例继承<br>因为类是元类的实例，所以元类中定义的行为适用于类，但不适用于类的实例；<br>实例从类和父类获取行为，但不会从元类获取行为；<br>普通实例属性继承通常只查找该实例、对应的类、所有父类的 <code>__dict__</code> 字典；不包括元类。</p><p>④元类属性会被类获取<br>类能通过继承关系从元类获得方法；<br>类通过类的 <code>__class__</code> 链接来获取元类属性，这跟普通实例从它们的类获取名称是一样的，但是通过 <code>__dict__</code> 继承的名称会被优先搜索；<br>当同一名称同时出现在元类和父类，父类的版本（通过继承）会被优先使用，而元类（作为元类的实例）会被忽略；<br>而类的 <code>__class__</code> 不会被它本身的实例所继承。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetaOne</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;In MetaOne.new:&#x27;</span>, classname)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(meta, classname, supers, classdict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">toast</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;toast&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>(metaclass=MetaOne):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Super</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eggs</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;eggs&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码运行时，元类会同时处理2个客户类的构建，并且实例继承类属性而不是元类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = Sub()</span><br><span class="line"><span class="built_in">print</span>(X.eggs(), X.spam())</span><br><span class="line"><span class="built_in">print</span>(X.toast()) <span class="comment"># 会出错：AttributeError: &#x27;Sub&#x27; object has no attribute &#x27;toast&#x27;</span></span><br></pre></td></tr></table></figure><p>但类可以从父类继承名字，也可以从元类获取名字；<br>从元类获取的方法被绑定到了主体类上，从普通类获取的方法通过类获取是非绑定的，而通过实例获取是绑定的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(Sub.eggs(X), Sub.spam(X))</span><br><span class="line"><span class="built_in">print</span>(Sub.toast())</span><br><span class="line"><span class="built_in">print</span>(Sub.toast)</span><br><span class="line"><span class="built_in">print</span>(Sub.spam)</span><br><span class="line"><span class="built_in">print</span>(X.spam)</span><br></pre></td></tr></table></figure><p><strong>2、元类 vs 父类</strong><br>简单地来说，类作为元类的实例继承了元类的属性，但是这个属性不能被类自己的实例继承：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">type</span>): attr = <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(metaclass=A): <span class="keyword">pass</span></span><br><span class="line">I = B()</span><br><span class="line"><span class="built_in">print</span>(B.attr)</span><br><span class="line"><span class="built_in">print</span>(I.attr) <span class="comment"># 出现错误：AttributeError: &#x27;B&#x27; object has no attribute &#x27;attr&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> B.__dict__, <span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> A.__dict__)</span><br></pre></td></tr></table></figure><p>把 A 从元类改为父类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: attr = <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line">I = B()</span><br><span class="line"><span class="built_in">print</span>(B.attr)</span><br><span class="line"><span class="built_in">print</span>(I.attr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> B.__dict__, <span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> A.__dict__)</span><br></pre></td></tr></table></figure><p>同一名称出现在父类和元类中的情形：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">M</span>(<span class="title class_ inherited__">type</span>): attr = <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: attr = <span class="number">2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(A, metaclass=M): <span class="keyword">pass</span></span><br><span class="line">I = B()</span><br><span class="line"><span class="built_in">print</span>(B.attr, I.attr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> B.__dict__, <span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> A.__dict__, <span class="string">&#x27;attr&#x27;</span> <span class="keyword">in</span> M.__dict__)</span><br></pre></td></tr></table></figure><p>python 会优先通过 MRO （通过继承）检查每个类的 <code>__dict__</code> ，之后再到元类（作为实例）中获取：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">M</span>(<span class="title class_ inherited__">type</span>): attr = <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: attr = <span class="number">2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(B, metaclass=M): <span class="keyword">pass</span></span><br><span class="line">I = C()</span><br><span class="line"><span class="built_in">print</span>(I.attr, C.attr)</span><br><span class="line"><span class="built_in">print</span>([x.__name__ <span class="keyword">for</span> x <span class="keyword">in</span> C.__mro__])</span><br></pre></td></tr></table></figure><p>类通过自身的 <code>__class__</code> 链接来获取元类属性（即实例通过 <code>__class__</code> 获取类属性的方式）；<br>但是实例继承是将其作用域限制在 MRO 顺序搜索到的每一个类的 <code>__dict__</code> 中，即跟随每个类的 <code>__bases__</code> ，而且只使用实例的 <code>__class__</code> 链接一次：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(I.__class__)</span><br><span class="line"><span class="built_in">print</span>(C.__bases__)</span><br><span class="line"><span class="built_in">print</span>(C.__class__)</span><br><span class="line"><span class="built_in">print</span>(C.__class__.attr)</span><br></pre></td></tr></table></figure><p><strong>3、继承：完整的例子</strong><br>①实例从它的类继承；类则从类和元类继承；元类从父元类继承：  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">M1</span>(<span class="title class_ inherited__">type</span>): attr1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M2</span>(<span class="title class_ inherited__">M1</span>): attr2 = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>: attr3 = <span class="number">3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>(C1,metaclass=M2): attr4 = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">I = C2()</span><br><span class="line"><span class="built_in">print</span>(I.attr3, I.attr4)</span><br><span class="line"><span class="built_in">print</span>(C2.attr1, C2.attr2, C2.attr3, C2.attr4)</span><br><span class="line"><span class="built_in">print</span>(M2.attr1, M2.attr2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(I.__class__, C2.__bases__)</span><br><span class="line"><span class="built_in">print</span>(C2.__class__, M2.__bases__)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(M2.__class__)</span><br><span class="line"><span class="built_in">print</span>([x.__name__ <span class="keyword">for</span> x <span class="keyword">in</span> C2.__mro__]) <span class="comment"># __bases__ tree from I.__class__</span></span><br><span class="line"><span class="built_in">print</span>([x.__name__ <span class="keyword">for</span> x <span class="keyword">in</span> M2.__mro__]) <span class="comment"># __bases__ tree from C2.__class__</span></span><br></pre></td></tr></table></figure><p>综上所述，继承会在利用 <code>__class__</code> 之前先利用 <code>__bases__</code> ，因为 <code>__bases__</code> 被用于创造类的时候建立 <code>__mro__</code> 顺序，而继承基于 MRO 。<br>普通实例没有 <code>__bases__</code> ；而类二者都有，包括类和元类。</p><p>②继承算法顺序  </p><ul><li>从实例 I 出发，先搜索该实例，再搜索它的类，之后搜索所有父类：  <ul><li>实例 I 的 <code>__dict__</code>；   </li><li>所有在 I 的 <code>__class__</code> 中的 <code>__mro__</code> 找到的类的 <code>__dict__</code>。  </li></ul></li><li>从类 C 出发，先搜索该类，再搜索它的所有父类，之后搜索它的元类树：  <ul><li>所有 C 的 <code>__mro__</code> 中的类的 <code>__dict__</code> ； </li><li>所有在 C 的 <code>__class__</code> 中的 <code>__mro__</code> 找到的类的 <code>__dict__</code> ；  </li></ul></li><li>步骤 b 出现的数据描述符具有优先权；</li><li>内置操作跳过步骤 a ，从步骤 b 开始搜索。</li></ul><p>③描述符特例  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>): <span class="built_in">print</span>(<span class="string">&#x27;__get__&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>): <span class="built_in">print</span>(<span class="string">&#x27;__set__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: d = D() <span class="comment"># Data descriptor attribute</span></span><br><span class="line">I = C()</span><br><span class="line">I.d</span><br><span class="line">I.d = <span class="number">1</span></span><br><span class="line">I.__dict__[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">I.d <span class="comment"># 命名空间的d不会覆盖数据描述符</span></span><br></pre></td></tr></table></figure><p>④内置操作特例<br>实例和类都会跳过内置操作；<br>比如，str 是内置操作，<code>__str__</code> 是它等价的显式名称，实例在内置操作的搜索被跳过：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    attr = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="keyword">return</span>(<span class="string">&#x27;class&#x27;</span>)</span><br><span class="line"></span><br><span class="line">I = C()</span><br><span class="line"><span class="built_in">print</span>(I.__str__(), <span class="built_in">str</span>(I)) <span class="comment"># 都来自类C</span></span><br><span class="line"></span><br><span class="line">I.__str__ = <span class="keyword">lambda</span>: <span class="string">&#x27;instance&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(I.__str__(), <span class="built_in">str</span>(I)) <span class="comment"># 前者来自实例的命名空间，后者来自C的命名空间，即显式调用来自实例，内置操作来自类</span></span><br></pre></td></tr></table></figure><p>同样规则也适用于类与元类，显式名称搜索从类开始，内置操作从类的类开始，即元类（默认是 type ）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="keyword">return</span>(<span class="string">&#x27;D class&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">D</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(C.__str__(C), <span class="built_in">str</span>(C)) <span class="comment"># C的元类是type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">D</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="keyword">return</span>(<span class="string">&#x27;C class&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(C.__str__(C), <span class="built_in">str</span>(C))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(metaclass=D):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="keyword">return</span>(<span class="string">&#x27;C class&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(C.__str__(C), <span class="built_in">str</span>(C))</span><br></pre></td></tr></table></figure><p>所有的类也继承自 object ，包括默认的 type 元类。</p><p>比如下面，C 按照继承（ MRO ）从 object 获取了默认的 <code>__str__</code> ，而非从元类中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(metaclass=D):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(C.__str__(C), <span class="built_in">str</span>(C))</span><br><span class="line"><span class="built_in">print</span>(C.__str__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> (C, C.__class__, <span class="built_in">type</span>): <span class="built_in">print</span>([x.__name__ <span class="keyword">for</span> x <span class="keyword">in</span> k.__mro__])</span><br></pre></td></tr></table></figure><h3 id="四、Metaclass-Methods"><a href="#四、Metaclass-Methods" class="headerlink" title="四、Metaclass Methods"></a>四、Metaclass Methods</h3><p><strong>1、元类方法</strong><br>元类方法能够处理对应的实例类，不是普通实例对象 self ，而是类本身：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">cls</span>): <span class="built_in">print</span>(<span class="string">&#x27;ax&#x27;</span>, cls) <span class="comment"># 注意：不是self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">y</span>(<span class="params">cls</span>): <span class="built_in">print</span>(<span class="string">&#x27;ay&#x27;</span>, cls)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(metaclass=A):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">y</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;by&#x27;</span>, self)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">z</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;bz&#x27;</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(B.x, B.y, B.z)</span><br><span class="line">B.x()</span><br><span class="line"></span><br><span class="line">I = B()</span><br><span class="line">I.y()</span><br><span class="line">I.z()</span><br><span class="line">I.x() <span class="comment"># 出现错误：AttributeError: &#x27;B&#x27; object has no attribute &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>2、元类方法中的运算符重载</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">cls, name</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(cls.data, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(metaclass=A):</span><br><span class="line">    data = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(B.upper())</span><br><span class="line"><span class="built_in">print</span>(B.upper)</span><br><span class="line"><span class="built_in">print</span>(B.__getattr__)</span><br><span class="line">I = B()</span><br><span class="line">I.upper <span class="comment"># 出现错误：AttributeError: &#x27;B&#x27; object has no attribute &#x27;upper&#x27;</span></span><br><span class="line">I.__getattr__ <span class="comment"># 出现错误：AttributeError: &#x27;B&#x27; object has no attribute &#x27;__getattr__&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="五、Examples"><a href="#五、Examples" class="headerlink" title="五、Examples"></a>五、Examples</h3><p><strong>1、实例：向类添加方法</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">eggsfunc</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">return</span> obj.value * <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hamfunc</span>(<span class="params">obj, value</span>):</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&#x27;ham&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Extender</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">meta, classname, supers, classdict</span>):</span><br><span class="line">        classdict[<span class="string">&#x27;eggs&#x27;</span>] = eggsfunc</span><br><span class="line">        classdict[<span class="string">&#x27;ham&#x27;</span>] = hamfunc</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(meta, classname, supers, classdict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client1</span>(metaclass=Extender):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client2</span>(metaclass=Extender):</span><br><span class="line">    value = <span class="string">&#x27;ni?&#x27;</span></span><br><span class="line"></span><br><span class="line">X = Client1(<span class="string">&#x27;Ni!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(X.spam())</span><br><span class="line"><span class="built_in">print</span>(X.eggs())</span><br><span class="line"><span class="built_in">print</span>(X.ham(<span class="string">&#x27;bacon&#x27;</span>))</span><br><span class="line"></span><br><span class="line">Y = Client2()</span><br><span class="line"><span class="built_in">print</span>(Y.eggs())</span><br><span class="line"><span class="built_in">print</span>(Y.ham(<span class="string">&#x27;bacon&#x27;</span>))</span><br></pre></td></tr></table></figure><p>上述示例中的元类把2个已知的方法添加到了声明了元类的每个类中。</p><p><strong>2、基于装饰器的上述代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">eggsfunc</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">return</span> obj.value * <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hamfunc</span>(<span class="params">obj, value</span>):</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&#x27;ham&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Extender</span>(<span class="params">aClass</span>):</span><br><span class="line">    aClass.eggs = eggsfunc</span><br><span class="line">    aClass.ham = hamfunc</span><br><span class="line">    <span class="keyword">return</span> aClass</span><br><span class="line"></span><br><span class="line"><span class="meta">@Extender</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Extender</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client2</span>:</span><br><span class="line">    value = <span class="string">&#x27;ni?&#x27;</span></span><br><span class="line"></span><br><span class="line">X = Client1(<span class="string">&#x27;Ni!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(X.spam())</span><br><span class="line"><span class="built_in">print</span>(X.eggs())</span><br><span class="line"><span class="built_in">print</span>(X.ham(<span class="string">&#x27;bacon&#x27;</span>))</span><br><span class="line"></span><br><span class="line">Y = Client2()</span><br><span class="line"><span class="built_in">print</span>(Y.eggs())</span><br><span class="line"><span class="built_in">print</span>(Y.ham(<span class="string">&#x27;bacon&#x27;</span>))</span><br></pre></td></tr></table></figure><p><strong>3、元类 vs 类装饰器</strong><br>①类装饰器可以管理类和实例，但是通常不能创建类，需要额外步骤来创建新的类；<br>②元类可以管理类和实例，但是管理实例需要一些额外的工作； </p><p>类装饰器在 class 语句末尾，把类名绑定到装饰器函数或类的结果；<br>元类通过一条 class 语句末尾把类对象的创建路由到一个对象，从而创建新的类。</p><p>本章后面有元类和类装饰器比较以及结合的例子，因为暂无学习的必要性，未作摘抄，大致了解即可，之后面向需求学习。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Learning Python》读书笔记（三）</title>
      <link href="/2022/10/24/2022-10-24-Learning-python3/"/>
      <url>/2022/10/24/2022-10-24-Learning-python3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该笔记为 <strong>《Learning Python》</strong> 的读书笔记，由于是早期未搞熟博客系统时所写，笔记结构较为混乱；<br>该书涉及的内容可能过于啰嗦，但包含一些python背后的逻辑和机制，可以粗略过一遍，但若仔细阅读就是在坑自己；<br>该笔记内容过多，所以不展示部分代码的结果，需复制到编辑器中查看；<br>学习完成日期为2022年10月20日。<br>本篇主要内容为：Python解释器；Python对象类型的初步介绍；数值类型。</p></blockquote><div  align="center">  <img src="https://s2.loli.net/2022/09/17/ri9Ue6nguJdq1Ca.jpg" width = "80%" height = "80%" alt="Learning Python"/></div><h1 id="PART-V-Modules-and-Packages"><a href="#PART-V-Modules-and-Packages" class="headerlink" title="PART V Modules and Packages"></a>PART V Modules and Packages</h1><h2 id="chapter-22-Modules-The-Big-Picture"><a href="#chapter-22-Modules-The-Big-Picture" class="headerlink" title="chapter 22 Modules: The Big Picture"></a>chapter 22 Modules: The Big Picture</h2><h3 id="一、Python-Program-Architecture"><a href="#一、Python-Program-Architecture" class="headerlink" title="一、Python Program Architecture"></a>一、Python Program Architecture</h3><ol><li><p>一个模块文件顶层定义的所有变量都变成了被导入的模块对象的属性。</p></li><li><p>Python Program Architecture程序架构</p><ul><li>一个python拥有一个主体的顶层文件，辅以数个被称为模块的支持文件；</li><li>顶层文件包含了程序的主要控制流程：即用来启动应用程序的文件；</li><li>模块文件是工具库。</li></ul></li><li><p>Imports and Attributes导入与属性</p><ul><li><code>import语句</code>会逐行运行在目标文档中对的语句从而构建其中对象，使其变成模块的属性即<code>module.attribute</code>。</li></ul></li><li><p>How Imports Work导入语句如何工作</p><ul><li>导入会执行3个步骤：找到模块文件；编译成字节码；执行模块的代码来创建其所定义的对象；</li><li>这3步骤只会在程序第一次导入才会进行，之后导入相同的模块时，会跳过这3个步骤，只提取内存中已加载的模块对象；</li><li>python会把载入的模块存储在一个叫sys.modules的表中，每次导入操作先检查该表，不存在，则启动上述3个步骤。</li><li>Python使用标准模块搜索路径来找出import语句所对应的模块文件，详见第24章；</li><li>python会把模块编译为字节码，如果发现字节码文件比源代码旧，则会自动生成新的字节代码。字节码被存在<strong>pycache</strong>子目录里，只有被导入的文件才会在机器上留下.pyc字节码文件，顶层文件的字节码在内部使用后就丢弃了；</li><li>import的最后步骤就是执行，文件中的语句会从头到尾被执行。</li></ul></li></ol><h3 id="二、The-Module-Search-Path"><a href="#二、The-Module-Search-Path" class="headerlink" title="二、The Module Search Path"></a>二、The Module Search Path</h3><ol><li><p>模块搜索路径</p><ul><li>多数情况下，我们可以依赖模块导入搜索路径的自动特性，完全不需要配置这些路径；</li><li>python的模块搜索路径是下面这些主要组件拼接的结果，其中有些需要自定义：<ul><li>程序的主目录；（自动的）<br>即包含程序的顶层脚本文件所在的目录；这个目录总是会优先被搜索，所以会覆盖其他目录中相同名称的模块。</li><li>PYTHONPATH目录（可配置的configurable）；<br>python会从左到右搜索PYTHONPATH环境变量设置中罗列出的所有目录；PYTHONPATH是设置包含python程序文件的目录列表，可以把想导入的目录都加进来。</li><li>标准库目录（自动的）；</li><li>任何.pth文件中的内容（可配置的）；<br>不常用，python允许用户把需要的目录写在后缀名为.pth的文本文件中一行一行列出来，作为PYTHONPATH设置的一种替代方案；可以把文件放在python安装目录的顶层（C:\Python33）或者标准库所在位置的sitepackages子目录（C:\Python33\Lib\site-packages）。</li><li>第三方扩展应用的site-packages主目录（自动的）；<br>python会自动将标准库的site-packages子目录添加到模块搜索路径。</li><li>以上5个组件组合成了<code>sys.path</code>。</li></ul></li></ul></li><li><p>Configuring the Search Path配置搜索路径</p><ul><li>可以通过【我的电脑】-【属性】-【高级系统设置】-【环境变量】-【新建】，变量名写PYTHONPATH，变量值就是你要导入模块的路径；或者在python安装目录下创建.pth文本文件。</li><li>上面的方法是永久设置模块的搜索路径。</li></ul></li><li><p>sys.path列表</p><ul><li>暂时设置模块的搜索路径；</li><li>Python在程序启动时配置sys.path，自动将上述5个目录合并，形成一个列表；</li><li>这个列表提供一种让脚本手动定制其搜索路径的方式，这种修改只在脚本执行时保持，可以采用<code>sys.path.append</code>或<code>sys.path.insert</code>来改变列表：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br><span class="line">sys.path.append(<span class="string">r&#x27;XXXX&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>模块文件选择</p><ul><li>python会在搜索路径中选择第一个能够匹配导入名称的文件；</li><li>导入语句的本质是外部组件暴露的接口，包括以下类型：源代码文件b.py; 字节码文件b.pyc; 优化字节码文件b.pyo（不常见）; 目录b（对于包导入而言，见24章）；编译拓展模块（c或c++编写），导入时使用动态链接；用c编写的编译好的内置模块，变被静态链接至python；ZIP文件组件，导入时自动解压缩（标准库路径就是一个.zip文件）</li><li>更多细节参考Python标准库手册中的内置<strong>import</strong>函数的说明，这个函数是import语句的可定制工具。</li></ul></li></ol><h2 id="chapter-23-Module-Coding-Basics"><a href="#chapter-23-Module-Coding-Basics" class="headerlink" title="chapter 23 Module Coding Basics"></a>chapter 23 Module Coding Basics</h2><h3 id="一、Module-Creation-and-Usage"><a href="#一、Module-Creation-and-Usage" class="headerlink" title="一、Module Creation and Usage"></a>一、Module Creation and Usage</h3><ol><li><p><code>import语句</code>和<code>from语句</code></p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module</span><br><span class="line">module.method()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> method</span><br><span class="line">method()</span><br></pre></td></tr></table></figure></li><li><p><code>from*语句</code></p><ul><li>当我们使用*代替特定名称时，会取得模块顶层被赋值的所有名称的副本：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> *</span><br><span class="line">method()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Imports Happen Only Once导入只发生一次</p><ul><li>simple.py如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">spam = <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li>导入执行从头到尾执行一次module文件：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> simple <span class="comment"># 执行了代码，打印了hello</span></span><br><span class="line"><span class="built_in">print</span>(simple.spam)</span><br></pre></td></tr></table></figure></li><li>第二次导入并不会重新执行该模块的代码，只是从内部模块表取出已创建的模块对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">simple.spam = <span class="number">2</span></span><br><span class="line"><span class="keyword">import</span> simple</span><br><span class="line"><span class="built_in">print</span>(simple.spam)</span><br></pre></td></tr></table></figure></li><li>如果需要再一次运行，需要内置函数<code>reload</code>，见后面。</li></ul></li><li><p>import和from是赋值语句</p><ul><li>import和from是可执行语句，可以被嵌套在if测试里，在def里等等；</li><li>import和from是隐式的赋值语句；</li><li><em>import将整个模块对象赋值给一个单独名称</em>；</li><li><em>from将一个或多个名称赋值给另一个模块中的同名对象</em>；</li><li><em>以from复制的名称会变成对共享对象的引用，所以要小心共享的可变对象</em>：</li><li>比如small.py，如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>导入small.py：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> small <span class="keyword">import</span> x, y</span><br><span class="line">x = <span class="number">42</span> <span class="comment"># Changes local x only</span></span><br><span class="line">y[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line"><span class="keyword">import</span> small</span><br><span class="line"><span class="built_in">print</span>(small.x)</span><br><span class="line"><span class="built_in">print</span>(small.y)</span><br></pre></td></tr></table></figure></li><li>若想修改另一文件的全局变量名，必须用import：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> small</span><br><span class="line">small.x = <span class="number">42</span> <span class="comment"># Changes x in other module</span></span><br><span class="line"><span class="built_in">print</span>(small.x)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>import and from Equivalence等价性</p><ul><li>from只是把名称从一个模块复制到另一个模块，但是不会对模块名本身进行赋值；</li><li>所以从概念上来说，以下2段代码是等价的<ul><li><code>from module import name1, name2</code>；</li><li>import module<br>  name1 = module.name1<br>  name2 = module.name2<br>  del module</li></ul></li><li>跟所有赋值语句一样，from语句会在导入者中创建新的变量，而这些变量在初始化时引用了被导入文件中的同名对象，不过，只复制了名称，没复制引用的对象。</li></ul></li><li><p>Potential Pitfalls潜在陷阱 of the from Statement</p><ul><li>因为from语句会让变量的位置更隐式和模糊，所以推荐使用import而不是from，虽然使用from也没什么太多可怕的后果。</li></ul></li></ol><h3 id="二、Module-Namespaces"><a href="#二、Module-Namespaces" class="headerlink" title="二、Module Namespaces"></a>二、Module Namespaces</h3><ol><li><p>模块命名空间</p><ul><li>理解模块的一种方式就是把它看作名称的封装；</li><li>模块就是命名空间，存在于一个模块内的名称被称为模块对象的属性。<ul><li>模块语句会在首次导入时执行：模块被导入时，python会建立空的模块对象，并逐一执行该模块文件内的语句；</li><li>顶层的赋值语句会创建模块属性：在导入时，文件顶层（即不在def与class之内）的赋值名称语句会建立对象的属性，存储在模块的命名空间里；</li><li>模块的命名空间可以通过属性<strong>dict</strong>会dir(M)获取；</li><li>模块是一个独立的作用域：模块文件的作用域在模块导入后就成为模块对象属性的命名空间。</li></ul></li><li>模块在首次导入，从头到尾执行语句：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># module2.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;starting to load...&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">name = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">klass</span>: <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;done loading.&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module2</span><br></pre></td></tr></table></figure></li><li>模块被加载后，它的作用域就变成了返回的模块对象的一个属性命名空间：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(module2.sys)</span><br><span class="line"><span class="built_in">print</span>(module2.name)</span><br><span class="line"><span class="built_in">print</span>(module2.func)</span><br><span class="line"><span class="built_in">print</span>(module2.klass)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>命名空间字典：<strong>dict</strong></p><ul><li>在内部，模块命名空间被存储为字典对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(module2.__dict__.keys()))</span><br></pre></td></tr></table></figure></li><li>里面的<strong>file</strong>指明模块是从哪个文件加载，<strong>name</strong>指明导入者的名称。</li></ul></li><li><p>Attribute Name Qualification属性名称的点号运算<br><strong>qualification点号运算</strong> (a.k.a. attribute fetch属性获取) syntax object.attribute</p></li><li><p>导入vs作用域</p><ul><li>moda.py：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">88</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="keyword">global</span> X</span><br><span class="line">    X = <span class="number">99</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> moda </span><br><span class="line">moda.f() </span><br><span class="line"><span class="built_in">print</span>(X, moda.X)</span><br></pre></td></tr></table></figure></li><li>moda.f()修改了moda中的X，而不是这个文件的X。moda.f的全局作用域一定是所在文件；</li><li>一段代码的作用域完全由该代码在文件中所处的实际位置决定。作用域绝不会被函数调用或模块导入影响。</li></ul></li><li><p>命名空间的嵌套Namespace Nesting</p><ul><li>虽然导入不会使命名空间发送向上的嵌套，但确实会发生向下的嵌套。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mod3.py</span></span><br><span class="line">X = <span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mod2.py</span></span><br><span class="line">X = <span class="number">2</span></span><br><span class="line"><span class="keyword">import</span> mod3</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(mod3.X)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">1</span></span><br><span class="line"><span class="keyword">import</span> mod2 <span class="comment"># 打印出2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X, end=<span class="string">&#x27; &#x27;</span>) <span class="comment"># 打印1</span></span><br><span class="line"><span class="built_in">print</span>(mod2.X, end=<span class="string">&#x27; &#x27;</span>) <span class="comment"># 打印2</span></span><br><span class="line"><span class="built_in">print</span>(mod2.mod3.X) <span class="comment"># 打印3</span></span><br></pre></td></tr></table></figure></li><li>无法编写<code>import mod2.mod3</code>。这会启用包导入，在下一章介绍。</li></ul></li></ol><h3 id="三、Reloading-Modules"><a href="#三、Reloading-Modules" class="headerlink" title="三、Reloading Modules"></a>三、Reloading Modules</h3><ol><li><p>Reloading Modules</p><ul><li>要强制使模块代码重新载入并重新运行，要调用<code>reload内置函数</code>。</li></ul></li><li><p>reload基础</p><ul><li>reload是函数，不是语句；reload传入的参数是一个存在的模块对象；reload在python 3.X中位于模块之中，需要导入才能使用；</li><li>一般的用法是导入一个模块，在文本编辑器内修改其代码，然后将其重新加载；</li><li>当调用reload时，Python会重读模块文件的源代码，重新执行其顶层语句；</li><li>reload会在原位置修改模块对象，reload并不会删除并重新创建模块对象。<ul><li>reload会在模块当前命名空间内执行模块文件的新代码：覆盖其现有命名空间而不是删除重建；</li><li>文件中顶层赋值语句会将名称替换为新的值；</li><li>重新加载只会对以后使用from的用户程序造成影响，之前使用from来读取属性的程序不会受到重新加载影响；</li><li>重新加载会影响所以使用import读取了模块的用户程序；</li><li>重新加载只适用于单一的模块。</li></ul></li></ul></li><li><p>reload示例</p><ul><li>要用python解释器演示，上述函数打印出来后，不要关掉解释器，此时修改changer.py文件的代码，然后调用reload：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># changer.py</span></span><br><span class="line">message = <span class="string">&quot;First version&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printer</span>():</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> changer</span><br><span class="line">changer.printer()</span><br></pre></td></tr></table></figure>修改后：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> reload</span><br><span class="line">reload(changer) <span class="comment"># reload会返回模块对象&lt;module &#x27;changer&#x27; from XXXXXXXXXX&gt;</span></span><br><span class="line">changer.printer() <span class="comment"># 这时候会显示修改后的结果</span></span><br></pre></td></tr></table></figure></li><li>除了在交互式命令行下重新加载模块外，模块重新加载在较大程序也十分有用，重新加载使程序能够提供高度动态的接口。</li></ul></li></ol><h2 id="chapter-24-Module-Packages"><a href="#chapter-24-Module-Packages" class="headerlink" title="chapter 24 Module Packages"></a>chapter 24 Module Packages</h2><h3 id="一、Package-Import-Basics"><a href="#一、Package-Import-Basics" class="headerlink" title="一、Package Import Basics"></a>一、Package Import Basics</h3><p>1、除了模块名之外，导入还可以指定目录路径</p><ul><li>Python代码的目录被称为<strong>包 package</strong>；</li><li>包导入是把目录变成Python命名空间，其属性对应目录中所包含的子目录和模块文件。</li></ul><p>2、包导入基础</p><ul><li><code>import dir1.dir2.mod</code> 或 <code>from dir1.dir2.mod import x</code></li><li>上述语句表明了dir1里有子目录dir2，dir2里包含mod.py</li></ul><p>3、包和搜索路径设置</p><ul><li>import语句中的目录路径只能是以点号间隔的变量，不能import C:\mycode\dir1\dir2\mod。</li></ul><p>4、__init__.py包文件</p><ul><li>如果选择使用包导入，包导入语句的路径中的<em>每个目录</em>都必须有__init__.py这个文件，否则包导入会失败；</li><li>也就是说上面dir1和dir2里都必须包含__init__.py文件，而容器目录dir0不需要__init__.py文件，dir0必须在模块搜索路径的sys.path列表中；</li><li>即dir0\dir1\dir2\mod.py 对应 import dir1.dir2.mod</li><li>__init__.py可以包含代码，也可以是空的；</li><li>它们的代码将在python第一次导入一个路径的时候被自动运行，所以可以被作为执行包的初始化的钩子。</li></ul><p>5、Package initialization file roles包初始化文件的角色</p><ul><li>__init__.py文件用作包初始化的钩子hook，将目录声明成一个Python包，替目录生成一个模块命名空间以及在目录导入时实现from* 语句</li><li>包的初始化：python在首次导入目录时，会自动执行该目录下__init__.py文件中的代码；</li><li>模块使用的声明：包的__init__.py文件即声明一个路径是Python的包；</li><li>模块命名空间的初始化：导入表达式dir1.dir2运行后，会返回一个模块对象，该对象的命名空间包含了dir2的__init__.py文件中赋值的所有名称；</li><li>from* 语句的行为：可以在__init__.py文件内定义__all__列表来规定目录以from*语句形式导入什么。__all__列表指包名称使用from*时，应该导入的子模块的名称清单。如果没有设定__all__，from*语句不会自动加载嵌套于该目录内的子模块。__init__.py可以是空白，但必须存在。</li></ul><h3 id="二、Package-Import-Example"><a href="#二、Package-Import-Example" class="headerlink" title="二、Package Import Example"></a>二、Package Import Example</h3><p>1、包导入示例</p><ul><li>在dir1和dir2文件夹里设置__init__.py文件：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dir1\__init__.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;dir1 init&#x27;</span>)</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dir1\dir2\__init__.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;dir2 init&#x27;</span>)</span><br><span class="line">y = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dir1\dir2\mod.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;in mod.py&#x27;</span>)</span><br><span class="line">z = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dir1.dir2.mod</span><br><span class="line"><span class="keyword">import</span> dir1.dir2.mod <span class="comment"># 第二次import不再执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> reload</span><br><span class="line">reload(dir1)</span><br><span class="line">reload(dir1.dir2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dir1)</span><br><span class="line"><span class="built_in">print</span>(dir1.dir2)</span><br><span class="line"><span class="built_in">print</span>(dir1.dir2.mod)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dir1.x)</span><br><span class="line"><span class="built_in">print</span>(dir1.dir2.y)</span><br><span class="line"><span class="built_in">print</span>(dir1.dir2.mod.z)</span><br></pre></td></tr></table></figure><p>2、包的from语句 vs 包的import语句<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dir1.dir2 <span class="keyword">import</span> mod</span><br><span class="line"><span class="built_in">print</span>(mod.z)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dir1.dir2.mod <span class="keyword">import</span> z</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dir1.dir2.mod <span class="keyword">as</span> mod</span><br><span class="line"><span class="built_in">print</span>(mod.z)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dir1.dir2.mod <span class="keyword">import</span> z <span class="keyword">as</span> modz</span><br><span class="line"><span class="built_in">print</span>(modz)</span><br></pre></td></tr></table></figure></p><p>3、 为什么使用包导入</p><ul><li>包导入提供了程序文件的目录信息；</li><li>包导入也可以简化PYTHONPATH和.pth文件搜索路径设置；</li><li>包能解决多个同名文件安装在同一个机器上所引发的模糊性。</li></ul><h3 id="三、Package-Relative-Imports"><a href="#三、Package-Relative-Imports" class="headerlink" title="三、Package Relative Imports"></a>三、Package Relative Imports</h3><p>1、包相对导入</p><ul><li>包内部导入同一个包中的内容时，可以使用和外部导入相同的完整路径语法，也可以利用特殊的包内搜索规则来简化import语句：</li><li>对于包中导入：<ul><li>默认跳过包自己的目录。导入只检查sys.path列表中的搜索路径。称为<strong>绝对导入</strong>：<code>import XX</code>；</li><li>from语句允许显式地要求导入只搜索包的目录（以点号开始）。称为<strong>相对导入</strong>：<code>from . import XX</code>。</li></ul></li></ul><p>2、相对导入基础知识</p><ul><li>from语句可以使用以点号开头的子句来导入位于同一包中的模块（包相对导入），而不是位于模块导入搜索路径上某处的模块（绝对导入）；</li><li>比如：<code>from . import spam</code> 即将文件相同包路径中名为spam的一个模块导入；</li><li>类似：<code>from .spam import name</code> 在文件所位于的包内，找到spam的模块并导入其中变量name；</li><li>而import string则总是在sys.path上的某处查找一个string模块，而不会查找该包中的同名模块，即绝对导入。</li><li>例：在一个名为mypkg的包目录下的一个模块文件：<ul><li><code>from .string import name1, name2</code> 即Imports names from mypkg.string；</li><li><code>from . import string</code> 即Imports mypkg.string；</li><li><code>from .. import string</code> 即从mypkg的父目录导入string模块。</li></ul></li><li><em>相对导入中的 “.” 用来表示包含当前文件的包目录；“..” 表示当前包的父目录的相对导入。</em><ul><li><code>from . import D</code> 即 Imports A.B.D (. means A.B)</li><li><code>from .. import E</code> 即 Imports A.E (.. means A)</li><li><code>from .D import X</code> 即 Imports A.B.D.X (. means A.B)</li><li><code>from ..E import X</code> 即 Imports A.E.X (.. means A)</li></ul></li></ul><p>3、相对导入的实际应用</p><ul><li>包外导入  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="built_in">print</span>(string)</span><br></pre></td></tr></table></figure><ul><li>上述代码，如果当前工作目录下，没有string.py，则会导入标准库的string模块；</li><li>但是因为模块搜索路径的第一项就是当前工作目录（current working directory，CWD）。</li></ul></li><li>包内导入<ul><li>在pkg文件夹下设置空的__init__.py：  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># code\pkg\spam.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> eggs  <span class="comment"># import eggs会出错，因为import是绝对导入，会查找该包中的模块</span></span><br><span class="line"><span class="built_in">print</span>(eggs.X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># code\pkg\eggs.py</span></span><br><span class="line">X = <span class="number">99999</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="built_in">print</span>(string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pkg.spam</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>4、包相对导入的陷阱</p><ul><li>不能随意使用from . 的相对导入语法，除非发起导入的文件本身是包的一部分；</li><li>导入不会搜索一个包模块自身的路径，除非使用from . 的相对导入语法；</li><li>最好能使用完整包路径导入，即<code>from system.section.mypkg import mod</code>，来替代包相对导入或简单导入（import mode）</li><li>详见书720-724</li></ul><p>5、__name__ == “__main__“</p><ul><li>当一个模块作为顶级脚本被运行时，它的__name__属性的值是“__main__”字符串，但当它被导入却不是；</li><li>即<code>if __name__ == &quot;__main__&quot;</code>后的语句在被导入后不被执行。</li></ul><h3 id="四、Namespace-Packages"><a href="#四、Namespace-Packages" class="headerlink" title="四、Namespace Packages"></a>四、Namespace Packages</h3><p>1、命名空间包</p><ul><li>4种导入模型：<ul><li><strong>基础模块导入</strong>：<code>import mod</code>, <code>from mod import attr</code></li><li><strong>包导入</strong>：<code>import dir1.dir2.mod</code>, <code>from dir1.mod import attr</code></li><li><strong>包相对导入</strong>：<code>from . import mod</code> (相对), <code>import mod</code> (绝对)</li><li><strong>命名空间包</strong>：<code>import splitdir.mod</code>：运行包横跨多个目录，不需要<strong>init</strong>.py初始化文件。</li></ul></li><li>两种风格的包：<ul><li>原始的模型，现在称为<strong>常规包regular packages</strong>；</li><li>可选的模型，称为<strong>命名空间包namespace packages</strong>。</li></ul></li><li>命名空间包模型常常被作为一种后备选项进行使用。</li></ul><p>2、命名空间包的语义</p><ul><li>常规包必须拥有一个<strong>init</strong>.py文件，而且必须位于一个独立的目录里；</li><li>命名空间包可以横跨多个路径，这些路径在被导入时被收集；</li><li>所有能够成为一个命名空间包组成部分的目录都不能包含一个<strong>init</strong>.py文件，但是可以被嵌套在里面当作一个单独的包。</li></ul><p>3、命名空间包导入算法</p><ul><li>当对每个模块搜索路径中的directory搜索名为spam的被导入包时，python会按照下面的顺序测试一系列匹配条件：<ul><li>如果找到directory\spam\__init__.py，便会导入一个常规包并返回；</li><li>如果找到directory\spam.{py, pyc, or other module extension}，便会导入一个简单模块并返回；</li><li>如果找到文件夹directory\spam，便把它记录下来，而扫描将从搜索路径中的下一个目录继续；</li><li>如果上述的所有都没找到，扫描将从搜索路径中的下一个目录继续。</li></ul></li><li>如果搜索路径没有从上述步骤1和步骤2中返回一个模块或包，但在步骤3至少记录了一个路径，就会创建一个命名空间包；</li><li>python只会在一个模块或常规包被找到的时候，或者整个路径已经被完全扫描过以后才停止搜索；</li><li>命名空间包只有在整个过程中没有找到其他同名的模块、包或文件才会被返回；</li><li>在模块搜索路径上任意位置的模块文件和常规包都优先于命名空间包目录；</li><li>命名空间包的创建会立即发生，不会推迟到子层级的导入发生之时。新的命名空间包有一个__path__属性；</li><li>该属性被设置为在上述步骤3中扫描并记录的目录路径字符串的可迭代对象，但是没有<strong>file</strong>属性；</li><li>__path__属性在随后更深的访问过程中用于搜索所有包组件；</li><li>命名空间包是访问更低层次项目的“父路径”。</li></ul><p>4、对常规包的影响：可选的__init__.py</p><ul><li>如果一个单独目录包没有该文件，它将被当作一个单独目录命名空间包，而且不会引发任何警告；</li><li>同时，原始的常规包模型仍然支持，而且作为一个初始化钩子会自动运行__init__.py文件中的代码；</li><li>而且常规包有性能上的优势。</li></ul><p>5、命名空间包的实际应用</p><ul><li>在这一结构中，2个名为sub的子目录位于2个不同的父目录dir1和dir2中：<ul><li>C:\code\ns\dir1\sub\mod1.py</li><li>C:\code\ns\dir2\sub\mod2.py</li></ul></li><li>如果将dir1和dir2都添加进模块搜索路径，sub将成为一个横跨2个目录的命名空间包</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ns\dir1\sub\mod1.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;dir1\sub\mod1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ns\dir2\sub\mod2.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;dir2\sub\mod2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">r&#x27;XXXXX\\ns\\dir1&#x27;</span>)</span><br><span class="line">sys.path.append(<span class="string">r&#x27;XXXXX\\ns\\dir2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sub.mod1 <span class="comment"># 无错误，可以运行</span></span><br><span class="line"><span class="keyword">import</span> sub.mod2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sub.mod1)</span><br><span class="line"><span class="built_in">print</span>(sub.mod2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sub)</span><br><span class="line"><span class="built_in">print</span>(sub.__path__)</span><br></pre></td></tr></table></figure><ul><li><p>相对导入也适用于命名空间包：</p><ul><li><p>可以把mod1里的代码改为</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> mod2</span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;dir1\sub\mod1&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>这样import sub.mod1会得到dir2\sub\mod2和dir1\sub\mod1。</p></li></ul></li></ul><p>6、命名空间包嵌套</p><ul><li>命名空间包支持任意嵌套，并成为低层级的“父路径”；</li><li>较低层的组件可以是一个模块、常规包也可以是另一个命名空间包。</li></ul><blockquote><p><strong>分界线（之前的笔记格式要调整）</strong></p></blockquote><h2 id="chapter-25-Advanced-Module-Topics"><a href="#chapter-25-Advanced-Module-Topics" class="headerlink" title="chapter 25 Advanced Module Topics"></a>chapter 25 Advanced Module Topics</h2><h3 id="一、Module-Design-Concepts"><a href="#一、Module-Design-Concepts" class="headerlink" title="一、Module Design Concepts"></a>一、Module Design Concepts</h3><p>1、模块设计概念</p><ul><li>在python中用户总是位于某个模块中，即使在交互式命令行下输入的代码实际上也存在于<em>__main__</em>的内置模块中；</li><li>最小化模块<em>耦合coupling</em>：全局变量，模块应该尽可能地独立于其他模块内使用的全局变量；</li><li>最大化模块<em>内聚cohesion</em>：统一的目标；</li><li>模块尽可能不去更改其他模块的变量；</li><li>模块不仅可以被导入，而且还可以导入和使用其他用python或者诸如C的其他语言编写的模块。</li></ul><p>2、使 * 的破坏最小化：<em>_X</em> 和 <em>__all__</em></p><ul><li>可以在名称前面加上下划线，防止导入时把名称复制出来，最小化对命名空间的破坏；</li><li><code>from *</code> 是复制出所有的名称；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># unders.py</span></span><br><span class="line">a, _b, c, _d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unders <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(a, c)</span><br><span class="line"><span class="built_in">print</span>(_b) <span class="comment"># 会出现NameError</span></span><br></pre></td></tr></table></figure><ul><li>但 import 仍然可以获取并修改这类名称：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unders</span><br><span class="line"><span class="built_in">print</span>(unders._b)</span><br></pre></td></tr></table></figure><ul><li>可以通过在模块顶层把变量名的字符串列表赋值给变量 <em>__all__</em> ，从而达到类似于 <em>_X</em> 命名惯例的隐藏效果；</li><li>使用此功能时，<code>from *</code> 语句只会把列在 <em>__all__ 列表</em>中的这些名称复制出来；</li><li><em>__all__</em> 是指明要复制的名称，而 <em>_X</em> 是指明不被复制的名称。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># alls.py</span></span><br><span class="line">__all__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;_c&#x27;</span>]</span><br><span class="line">a, b, _c, _d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> alls <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(a, _c)</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># 会出现NameError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> alls <span class="keyword">import</span> a, b, _c, _d</span><br><span class="line"><span class="built_in">print</span>(a, b, _c, _d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> alls</span><br><span class="line"><span class="built_in">print</span>(alls.a, alls.b, alls._c, alls._d)</span><br></pre></td></tr></table></figure><ul><li>就像 <em>_X</em> 一样，<em>__all__ 列表</em>只对 <code>from *</code> 语句有效；其他导入语句仍然能访问全部名称。</li></ul><p>3、启用未来语言特性：<em>__future__ 模块</em></p><ul><li>可以在Python 2.X中使用<code>from __future__ import featurename</code>来获取3.X的语言特性。</li></ul><h3 id="二、Built-in-Attribute-name"><a href="#二、Built-in-Attribute-name" class="headerlink" title="二、Built-in Attribute __name__"></a>二、Built-in Attribute __name__</h3><p>1、<em>__name__</em> 和 <em>__main__</em></p><ul><li>每个模块都有一个名为 <em>__name__</em> 的内置属性：<ul><li>如果文件作为顶层程序文件执行，在启动时 <em>__name__</em> 就会被设置为字符串<em>“__main__“</em>；</li><li>如果文件被导入， <em>__name__</em> 就会设为客户程序所了解的模块名。</li></ul></li></ul><p>2、混合使用模式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># runme.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tester</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s Christmas in Heaven...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tester()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> runme <span class="comment"># 因为是导入，不是顶层文件执行，所以导入语句执行模块代码时，不直接调用函数</span></span><br><span class="line">runme.tester() <span class="comment"># 正常调用函数</span></span><br></pre></td></tr></table></figure><ul><li>这里的 <em>__name__</em> 允许模块被同时编写成一个可导入的库和一个顶层文件；</li><li>因为<code>if __name__ == &#39;__main__&#39;</code>后面是调用，不是定义函数或者 print ；</li><li>所以 <em>__name__</em> 可以用于自我测试，判断是在执行还是在导入。</li></ul><p>3、以 <em>__name__</em> 进行测试</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># minmax.py</span></span><br><span class="line"><span class="comment"># 直接执行minmax得到I am: __main__；1；6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am:&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minmax</span>(<span class="params">test, *args</span>):</span><br><span class="line">    res = args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> test(arg, res):</span><br><span class="line">            res = arg</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lessthan</span>(<span class="params">x, y</span>): <span class="keyword">return</span> x &lt; y</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grtrthan</span>(<span class="params">x, y</span>): <span class="keyword">return</span> x &gt; y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(minmax(lessthan, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="built_in">print</span>(minmax(grtrthan, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> minmax <span class="comment"># 得到I am: minmax</span></span><br><span class="line"><span class="built_in">print</span>(minmax.minmax(minmax.lessthan, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)) <span class="comment"># 得到&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="三、Other-Advanced-Module-related-Topics"><a href="#三、Other-Advanced-Module-related-Topics" class="headerlink" title="三、Other Advanced Module-related Topics"></a>三、Other Advanced Module-related Topics</h3><p>1、修改模块搜索路径</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br></pre></td></tr></table></figure><ul><li><code>sys.path.append(&#39;C:\\sourcedir&#39;)</code> 添加路径；</li><li><code>sys.path = [r&#39;d:\temp&#39;]</code> 修改路径；</li><li><code>sys.path.insert(0, &#39;..&#39;)</code> 插入路径；</li><li><code>sys.path</code>是暂时的，只存在于发生的 python 会话，修改不会被保留下来。</li></ul><p>2、 import 语句和 from 语句的<em> as 拓展</em></p><ul><li>重命名 import 的模块：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> reallylongmodulename <span class="keyword">as</span> name</span><br><span class="line">name.func()</span><br></pre></td></tr></table></figure><ul><li>同理 from 也可以：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> utility <span class="keyword">as</span> util1</span><br><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> utility <span class="keyword">as</span> util2</span><br><span class="line">util1(); util2()</span><br></pre></td></tr></table></figure><p>3、用名称字符串导入模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">import</span> X</span><br></pre></td></tr></table></figure><ul><li>这样代码会尝试导入 X.py ，而不是 string 模块。</li><li>要用<code>exec内置函数</code>解决， <em>exec</em> 会编译代码字符串，传给解释器执行：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">modname = <span class="string">&#x27;minmax&#x27;</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;import &#x27;</span> + modname)</span><br></pre></td></tr></table></figure><ul><li>或者用内置的<code>__import__函数</code>，但是这个函数返回模块对象：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">modname = <span class="string">&#x27;minmax&#x27;</span></span><br><span class="line">minmax = <span class="built_in">__import__</span>(modname)</span><br><span class="line"><span class="built_in">print</span>(minmax)</span><br></pre></td></tr></table></figure><ul><li>或者用<code>importlib.import_module</code>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line">modname = <span class="string">&#x27;minmax&#x27;</span></span><br><span class="line">minmax = importlib.import_module(modname)</span><br><span class="line"><span class="built_in">print</span>(minmax)</span><br></pre></td></tr></table></figure><h3 id="四、Module-Gotchas"><a href="#四、Module-Gotchas" class="headerlink" title="四、Module Gotchas"></a>四、Module Gotchas</h3><p>1、模块名称冲突：包和包相对导入</p><ul><li>如果有2个同名模块，默认情况下， python 总是选择搜索路径 <em>sys.path</em> 中最左边的那一项，要么避免这问题，要么使用包导入功能。</li></ul><p>2、顶层代码中语句次序很重要</p><ul><li>当模块被导入（或重载）， python 会从头到尾执行它的代码语句。</li></ul><p>3、from 复制名称，而不是链接，和 import 不太一样</p><ul><li>import 是将模块对象赋值到名称。</li></ul><p>4、reload 不能作用于 from 导入</p><ul><li>因为 from 是复制，不会链接到名称所在模块，所以重载无效。</li></ul><p>5、递归形式的 from 导入可能无法工作</p><ul><li>相互导入的模块，称为<em>递归导入 recursive imports</em>；</li><li>用 from 可能会导致递归不会实际发生，有可能在导入时，名称尚不存在，用 import 可能没什么影响。</li></ul><h1 id="PART-VI-Classes-and-OOP"><a href="#PART-VI-Classes-and-OOP" class="headerlink" title="PART VI Classes and OOP"></a>PART VI Classes and OOP</h1><h2 id="chapter-26-OOP-The-Big-Picture"><a href="#chapter-26-OOP-The-Big-Picture" class="headerlink" title="chapter 26 OOP: The Big Picture"></a>chapter 26 OOP: The Big Picture</h2><h3 id="一、OOP-and-Class"><a href="#一、OOP-and-Class" class="headerlink" title="一、OOP and Class"></a>一、OOP and Class</h3><p>1、<em>类 Classes</em> 是<em>面向对象程序设计 object-oriented programming (OOP)</em> 的主要工具</p><ul><li>类支持<strong>继承 inheritance</strong> ，一种代码定制和复用的机制，真正的OOP，对象需要有继承层次。</li></ul><p>2、类 Classes</p><ul><li><em>多重实例 Multiple instances</em><ul><li>类是产生对象的工厂。每当调用类，就会产生一个带有独立命名空间的新对象，该对象可以读取类的属性，并用自己的命名空间来存储数据；</li></ul></li><li><em>通过继承进行定制 Customization via inheritance</em><ul><li>可以在类的外部以编写子类的方式，来重新定义其属性进而扩充类；</li></ul></li><li><em>运算符重载 Operator overloading</em><ul><li>python 提供了一些可以让类使用的钩子，从而能够拦截并实现任何的内置类型运算。</li></ul></li></ul><p>3、属性继承搜索</p><ul><li><code>object.attribute</code></li><li>当对 class 语句产生的对象使用上述表达式时，会启用一次搜索，搜索对象连接的类树；</li><li>即：找到 attribute 首次出现的地方，先搜索 object ，然后是该对象上的所有类，由下往上；</li><li><em>属性访问就是搜索类树，这种搜索即继承</em>，因为树中较低位置的对象继承了较高位置的对象的所有属性；</li><li>树中较高位置的类称为<strong>父类 superclass</strong>，较低位置称为<strong>子类 subclass</strong>；父类提供了所有子类共享的行为，子类可以重新定义父类的名称，从而覆盖父类定义的行为。</li></ul><p>4、编写类树</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>: ... <span class="comment"># 创建父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span>: ... <span class="comment"># 创建父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>(C2, C3): ... <span class="comment"># 继承父类，括号内从左到右的顺序决定了树中次序</span></span><br><span class="line"></span><br><span class="line">I1 = C1() <span class="comment"># 类调用，创建实例</span></span><br><span class="line">I2 = C1()</span><br></pre></td></tr></table></figure><ul><li>类的属性是在 class 语句的顶层语句块中通过赋值语句添加到类的；</li><li>属性是通过 <strong>self</strong> 的赋值，来附加给实例的。 <strong>self</strong> 提供了被处理的实例的引用；</li><li>类通过方法函数为实例提供行为（即 class 里的 def 语句）：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>: ... </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span>: ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>(C2, C3):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setname</span>(<span class="params">self, who</span>):</span><br><span class="line">        self.name = who</span><br><span class="line"></span><br><span class="line">I1 = C1()</span><br><span class="line">I2 = C1()</span><br><span class="line"></span><br><span class="line">I1.setname(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">I2.setname(<span class="string">&#x27;sue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(I1.name)</span><br></pre></td></tr></table></figure><ul><li>上面的代码，直到 setname 调用前，C1 类都不会把 name 属性附加到实例上。</li><li><code>__init__方法</code>（又称为<strong>构造函数</strong>），如果没有<code>__init__方法</code>，类调用将返回一个空实例，而不会将其初始化：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>: ... </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span>: ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>(C2, C3):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, who</span>):</span><br><span class="line">        self.name = who</span><br><span class="line"></span><br><span class="line">I1 = C1(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">I2 = C1(<span class="string">&#x27;sue&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(I1.name)</span><br></pre></td></tr></table></figure><p>5、在很多应用领域，可以获取或购买父类的集合，即软件框架 framework<br>这些软件框架可能提供一些数据库接口、测试协议、GUI工具包等</p><h2 id="chapter-27-Class-Coding-Basics"><a href="#chapter-27-Class-Coding-Basics" class="headerlink" title="chapter 27 Class Coding Basics"></a>chapter 27 Class Coding Basics</h2><h3 id="一、Classes-Generate-Multiple-Instance-Objects"><a href="#一、Classes-Generate-Multiple-Instance-Objects" class="headerlink" title="一、Classes Generate Multiple Instance Objects"></a>一、Classes Generate Multiple Instance Objects</h3><p>1、类对象和实例对象</p><ul><li><em>类对象 class objects</em> 提供默认行为，<em>实例对象 instance objects</em> 是程序处理的实际对象；</li><li>class 语句创建类并赋值给一个名称，class 语句内的赋值语句会创建类的属性；</li><li>类属性提供了对象的<strong>状态信息</strong>和<strong>行为</strong>；</li><li>调用类对象会创建实例对象，每个实例对象继承了类的属性并获得了自己的命名空间；</li><li>在方法内对 self 属性做赋值运算会产生每个实例自己的属性。</li></ul><p>2、第一个示例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setdata</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data)</span><br><span class="line"></span><br><span class="line">x = FirstClass() <span class="comment"># 调用产生实例</span></span><br><span class="line">y = FirstClass()</span><br><span class="line">x.setdata(<span class="string">&quot;King Arthur&quot;</span>)</span><br><span class="line">y.setdata(<span class="number">3.14159</span>)</span><br><span class="line"></span><br><span class="line">x.display()</span><br><span class="line">y.display()</span><br></pre></td></tr></table></figure><ul><li>类中的函数称为<strong>方法 methods</strong> ；</li><li>setdata 函数中，传入的值会赋给 self.data 。 self 会自动引用当前处理的实例，所以赋值语句会把值存储在实例的命名空间；</li><li>可以修改实例属性：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.data = <span class="string">&quot;New value&quot;</span></span><br><span class="line">x.display()</span><br></pre></td></tr></table></figure><ul><li>也可以在类方法函数外，在实例命名空间内产生全新的属性（很少见，不常用）：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.anothername = <span class="string">&quot;spam&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x.anothername)</span><br></pre></td></tr></table></figure><h3 id="二、Classes-Are-Customized-by-Inheritance"><a href="#二、Classes-Are-Customized-by-Inheritance" class="headerlink" title="二、Classes Are Customized by Inheritance"></a>二、Classes Are Customized by Inheritance</h3><p>1、类产生的实例对象继承类的属性。也可以让类继承其他类。</p><ul><li>父类列在 class 语句头部的括号里；</li><li>类从其父类中继承属性；</li><li>实例会继承所有可访问类的属性；</li><li>每个 object.attribute 引用都会启动一个独立的搜索；</li><li>逻辑的修改是通过创建子类，而不是修改父类。</li></ul><p>2、第二个示例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setdata</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondClass</span>(<span class="title class_ inherited__">FirstClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>): <span class="comment"># Changes display</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Current value = &quot;%s&quot;&#x27;</span> % self.data)</span><br></pre></td></tr></table></figure><ul><li>继承搜索会从实例往上进行，首先到子类，然后到父类；</li><li>所以 SecondClass 覆盖了 FirstClass 中的 display ，有时称这种重新定义取代属性的动作为<em>重载 overloading</em> ：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = SecondClass()</span><br><span class="line">z.setdata(<span class="number">42</span>) <span class="comment"># FirstClass的setdata</span></span><br><span class="line">z.display()</span><br></pre></td></tr></table></figure><p>3、类是模块内的属性</p><ul><li>若 FirstClass 从其他模块导入：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modulename <span class="keyword">import</span> FirstClass</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondClass</span>(<span class="title class_ inherited__">FirstClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>): ...</span><br></pre></td></tr></table></figure><ul><li>或者，其等效写法如下：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> modulename</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondClass</span>(modulename.FirstClass):   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>): ...</span><br></pre></td></tr></table></figure><h3 id="三、Classes-Can-Intercept-Python-Operators"><a href="#三、Classes-Can-Intercept-Python-Operators" class="headerlink" title="三、Classes Can Intercept Python Operators"></a>三、Classes Can Intercept Python Operators</h3><p>1、<strong>运算符重载</strong>，即让类编写的对象，截获并响应用在内置类型上的运算：加法、切片、打印和点号运算等，运算符重载能让对象拥有内置对象那样的行为。</p><ul><li>以双下划线命名的方法（<em>__X__</em>）是特殊钩子，来拦截运算；</li><li>当实例出现在内置运算中，这类方法会自动被调用；</li><li>类可以重载绝大多数内置类型运算；</li><li>默认的运算符不存在，如果类没有定义或继承运算符重载方法，那么类的实例将不能支持相应运算；</li><li>新式类有一些默认的运算符重载方法。新式类见后面；</li><li>运算符将类与对象模型结合到一起，让类获得与内置对象一样的行为；</li><li>运算符重载主要被 Python 工具开发人员使用，而不是应用程序开发人员。所以不应被随意使用；</li><li>但是<code>__init__方法</code>，几乎每个类都会用到，也称为构造函数方法，用于初始化对象状态。</li></ul><p>2、第三个示例</p><ul><li><code>__init__</code>会在创建实例时被调用： self 是新的 ThirdClass 对象；<code>__add__</code>会在 ThirdClass 实例出现在 + 表达式时被调用；<code>__str__</code>会在打印对象时被调用：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FirstClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setdata</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondClass</span>(<span class="title class_ inherited__">FirstClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>): <span class="comment"># Changes display</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Current value = &quot;%s&quot;&#x27;</span> % self.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThirdClass</span>(<span class="title class_ inherited__">SecondClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> ThirdClass(self.data + other)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[ThirdClass: %s]&#x27;</span> % self.data</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">self, other</span>):</span><br><span class="line">        self.data *= other</span><br><span class="line"></span><br><span class="line">a = ThirdClass(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">a.display()</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># __str__: returns display string</span></span><br><span class="line"></span><br><span class="line">b = a + <span class="string">&#x27;xyz&#x27;</span> <span class="comment"># __add__: makes a new instance。实例对象a传给了__add__中的self，右侧传给了other</span></span><br><span class="line">b.display()</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line">a.mul(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h3 id="四、The-World’s-Simplest-Python-Class"><a href="#四、The-World’s-Simplest-Python-Class" class="headerlink" title="四、The World’s Simplest Python Class"></a>四、The World’s Simplest Python Class</h3><p>1、最简单的类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rec</span>: <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>可以在 class 语句外，通过赋值变量名给这个类增加属性：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Rec.name = <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">Rec.age = <span class="number">40</span></span><br></pre></td></tr></table></figure><ul><li>此时创建实例，会继承附加在类上的属性：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = Rec()</span><br><span class="line">y = Rec()</span><br><span class="line"><span class="built_in">print</span>(x.name, y.name)</span><br></pre></td></tr></table></figure><ul><li>可以再对实例对象赋值属性，因为属性引用会启动继承搜索，所以实例会先获得实例属性：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.name = <span class="string">&#x27;Sue&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(Rec.name, x.name, y.name)</span><br></pre></td></tr></table></figure><ul><li>命名空间对象的属性通常以字典形式实现的，类继承树就是互相连接的字典，详见第29章。</li><li><code>__dict__属性</code>是大多数基于类的对象的命名空间字典：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(Rec.__dict__.keys()))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(name <span class="keyword">for</span> name <span class="keyword">in</span> Rec.__dict__ <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&#x27;__&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(x.__dict__.keys()))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(y.__dict__.keys()))</span><br></pre></td></tr></table></figure><ul><li><code>__class__</code>代表实例指向其类的链接：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(x.__class__)</span><br></pre></td></tr></table></figure><ul><li>类也有个<code>__bases__属性</code>，它是其父类对象引用的元组，在这里是隐含的 object 根类：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(Rec.__bases__)</span><br></pre></td></tr></table></figure><p>2、python的类模型是相当动态的</p><ul><li>类和实例只是<em>命名空间对象</em>，可以在任何地方使用它们的属性；</li><li>方法也可以独立地创建在任意类对象的外部：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">uppername</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">return</span> obj.name.upper()</span><br></pre></td></tr></table></figure><ul><li>只要传入一个带 name 属性（该属性自带有 upper 方法）的 obj 对象就可以调用</li><li>x 这个类实例适合 uppername 的接口：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(uppername(x))</span><br></pre></td></tr></table></figure><ul><li>我们也可以把函数赋值成类的属性，该函数就变成了类的方法：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Rec.method = uppername</span><br><span class="line"><span class="built_in">print</span>(x.method())</span><br><span class="line"><span class="built_in">print</span>(y.method())</span><br><span class="line"><span class="built_in">print</span>(Rec.method(x))</span><br></pre></td></tr></table></figure><h2 id="chapter-28-A-More-Realistic-Example"><a href="#chapter-28-A-More-Realistic-Example" class="headerlink" title="chapter 28 A More Realistic Example"></a>chapter 28 A More Realistic Example</h2><h3 id="一、Example-of-Classes"><a href="#一、Example-of-Classes" class="headerlink" title="一、Example of Classes"></a>一、Example of Classes</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># person.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="comment"># 步骤1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, job=<span class="literal">None</span>, pay=<span class="number">0</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastName</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">return</span> self.name.split()[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent</span>):</span><br><span class="line">        self.pay = <span class="built_in">int</span>(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤3</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[Person: %s, %s]&#x27;</span> % (self.name, self.pay)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤4</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="comment"># 步骤5</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, pay</span>):</span><br><span class="line">        Person.__init__(self, name, <span class="string">&#x27;mgr&#x27;</span>, pay)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤4</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent, bonus=<span class="number">.10</span></span>):</span><br><span class="line">        Person.giveRaise(self, percent + bonus) <span class="comment"># 也可以复制父类的代码self.pay = int(self.pay * (1 + percent + bonus))，坏处就是修改代码就需要修改2次了</span></span><br></pre></td></tr></table></figure><p><strong>步骤1</strong>：创建实例</p><ul><li>实例对象属性在类方法函数中的 self 属性赋值来创建。常见方法是在<em>__init__构造函数方法</em>中赋值给 self ；</li><li>self 就是新创建的实例对象。job 参数是 <em>__init__</em> 函数作用域里的一个局部变量，而 self.job 是实例的一个属性；</li><li><code>self.job = job</code> 就是把局部 job 赋给 self.job 属性。</li><li>生成几个实例：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> Person</span><br><span class="line"></span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>, job=<span class="string">&#x27;dev&#x27;</span>, pay=<span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.name, bob.pay)</span><br><span class="line"><span class="built_in">print</span>(sue.name, sue.pay)</span><br></pre></td></tr></table></figure><p><strong>步骤2</strong>：添加行为方法</p><ul><li><strong>封装encapsulation</strong>：封装思想就是把操作逻辑包装到接口之后；</li><li>把操作对象的代码编写到类方法，即封装的一种方式：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bob.lastName(), sue.lastName())</span><br><span class="line">sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line"><span class="built_in">print</span>(sue.pay)</span><br></pre></td></tr></table></figure><p><strong>步骤3</strong>：运算符重载</p><ul><li>排在 <em>__init__</em> 之后第二常用的运算符重载 <em>__repr__</em> ，以及 <em>__str__</em> ；</li><li>打印对象会显示该对象的 <em>__str__</em> 或 <em>__repr__</em> 方法所返回的内容；</li><li>这2者被用在不同的上下文实现不同的显示，但是只编写 <em>__repr__</em> 足以支持几乎所有的场景：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(bob)</span><br><span class="line"><span class="built_in">print</span>(sue)</span><br></pre></td></tr></table></figure><p><strong>步骤4</strong>：通过编写子类定制行为</p><ul><li>编写名为 Manager 的子类：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> Manager</span><br><span class="line">tom = Manager(<span class="string">&#x27;Tom Jones&#x27;</span>, <span class="number">50000</span>)</span><br><span class="line">tom.giveRaise(<span class="number">.10</span>)</span><br><span class="line"><span class="built_in">print</span>(tom.lastName())</span><br><span class="line"><span class="built_in">print</span>(tom)</span><br></pre></td></tr></table></figure><ul><li><code>super内置函数</code>也可以调用父类，详见第32章。</li><li>多态的应用：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--All three--&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> (bob, sue, tom):</span><br><span class="line">    obj.giveRaise(<span class="number">.10</span>)</span><br><span class="line">    <span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure><ul><li>对象可能是一个 Person 或 Manager ，而 Python 自动运行相应的 giveRaise ，这就是 Python 中的多态概念</li></ul><p><strong>步骤5</strong>：定制构造函数</p><ul><li>为 Manager 定制构造函数，初始化对象的状态信息属性。</li><li>组合类 Combine Classes 的其他方式</li><li><code>__getattr__运算符重载方法</code>，能拦截未定义属性的访问并把这些访问委托给一个带有 getattr 内置调用的内嵌对象，详见第30章。第31章将讨论组合 composition 的设计问题。</li></ul><p><strong>步骤6</strong>：使用<em>内省工具 Introspection</em></p><ul><li>Python 的内省工具允许我们访问对象实现的内部机制的一些特殊属性和函数，语言框架工具的开发者会比应用程序开发者更广泛地使用它们：<ul><li>内置的 <em>instance.__class__ 属性</em>提供了一个从实例到创建它的类的链接。同时类还有个 <em>__name__</em> ，还有一个 <em>__base__</em> 序列来提供父类的访问；</li><li>内置的 <em>object.__dict__</em> 属性提供了一个字典，将所有命名空间对象中的属性都存储为键值对。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob)</span><br><span class="line"><span class="built_in">print</span>(bob.__class__)</span><br><span class="line"><span class="built_in">print</span>(bob.__class__.__name__)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(bob.__dict__.keys()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> bob.__dict__:</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;=&gt;&#x27;</span>, bob.__dict__[key])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> bob.__dict__:</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;=&gt;&#x27;</span>, <span class="built_in">getattr</span>(bob, key))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(bob))</span><br></pre></td></tr></table></figure><p><strong>步骤7</strong>：把对象存储到数据库中</p><ul><li>我们关闭 python ，实例会消失，因为它是内存中临时性对象；</li><li>因为应用程序往往需要永久性改变，所以需要把对象持久化 object persistence/permanence；<ul><li><code>pickle 模块</code>：实现任意 python 对象与字节串之间的序列化和解序列化；</li><li><code>dbm 模块</code>：实现一个通过键访问的文件系统，以存储字节串；</li><li><code>shelve 模块</code>：使用以上2个模块，按照键把 Python 对象存储到一个文件中；</li><li>shelve 使用 pickle 把一个对象转换为其 pickle 化的字节串，并将其存储在一个 dbm 文件中的键之下；pickle：腌制、酸菜 shelve：搁置。</li></ul></li><li>在 shelve 数据库中存储对象，详见 makedb.py ：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># makedb.py</span></span><br><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> Person, Manager</span><br><span class="line">bob = Person(<span class="string">&#x27;Bob Smith&#x27;</span>)</span><br><span class="line">sue = Person(<span class="string">&#x27;Sue Jones&#x27;</span>, job=<span class="string">&#x27;dev&#x27;</span>, pay=<span class="number">100000</span>)</span><br><span class="line">tom = Manager(<span class="string">&#x27;Tom Jones&#x27;</span>, <span class="number">50000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">db = shelve.<span class="built_in">open</span>(<span class="string">&#x27;persondb&#x27;</span>) <span class="comment"># Filename where objects are stored</span></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> (bob, sue, tom): <span class="comment"># 把对象的名称用做键，把它们赋给shelve</span></span><br><span class="line">    db[obj.name] = obj</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><ul><li>交互式地探索 shelve ：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">db = shelve.<span class="built_in">open</span>(<span class="string">&#x27;persondb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(db))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(db.keys()))</span><br><span class="line"></span><br><span class="line">bob = db[<span class="string">&#x27;Bob Smith&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(bob)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bob.lastName())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> db:</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;=&gt;&#x27;</span>, db[key]) <span class="comment"># db[key]即对应的对象，打印出来就是运行了__repr__方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(db):</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;=&gt;&#x27;</span>, db[key])</span><br></pre></td></tr></table></figure><ul><li>以上代码即导入了实例对象，并且将 bob 连接到它。</li><li>更新 shelve 中的对象：<ul><li>编写一个程序，在每次运行的时候都更新一个实例，以证实对象是持久的，即每次运行时，它们当前的值都是可用的，详见 updatedb.py ：</li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># updatedb.py</span></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">db = shelve.<span class="built_in">open</span>(<span class="string">&#x27;persondb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(db):</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;\t=&gt;&#x27;</span>, db[key])</span><br><span class="line"></span><br><span class="line">sue = db[<span class="string">&#x27;Sue Jones&#x27;</span>]</span><br><span class="line">sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">db[<span class="string">&#x27;Sue Jones&#x27;</span>] = sue</span><br><span class="line">db.close()</span><br><span class="line"><span class="comment"># 每次运行都会永久改变 sue 的工资，可以证明对象的持久化。</span></span><br></pre></td></tr></table></figure><ul><li>如果要了解 pickle 和 shelve 的更多细节，见官方手册。</li></ul><h2 id="chapter-29-Class-Coding-Details"><a href="#chapter-29-Class-Coding-Details" class="headerlink" title="chapter 29 Class Coding Details"></a>chapter 29 Class Coding Details</h2><h3 id="一、The-class-Statement"><a href="#一、The-class-Statement" class="headerlink" title="一、The class Statement"></a>一、The class Statement</h3><p>1、Class 语句是对象的创建者并且是一个隐含的赋值运算：当它执行时产生类对象，并把其引用值存储到前面所使用的名称中</p><ul><li>class语句的一般形式：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">name</span>(superclass,...):</span><br><span class="line">    attr = value </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self,...</span>):</span><br><span class="line">        self.attr = value</span><br></pre></td></tr></table></figure><p>2、示例</p><ul><li>当 python 执行 class 语句时，会从头到尾执行其主体内语句；</li><li>在 class 语句中的赋值语句所创建的名称，位于 class 的局部作用域中，会成为类对象中的属性。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedData</span>:</span><br><span class="line">    spam = <span class="number">42</span></span><br><span class="line">    <span class="built_in">print</span>(spam)</span><br><span class="line"></span><br><span class="line">x = SharedData()</span><br><span class="line">y = SharedData()</span><br><span class="line"><span class="built_in">print</span>(x.spam, y.spam)</span><br></pre></td></tr></table></figure><ul><li><strong><em>可以通过类名称修改类属性</em></strong>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SharedData.spam = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(x.spam, y.spam, SharedData.spam)</span><br></pre></td></tr></table></figure><ul><li><strong><em>对实例对象赋值修改实例属性</em></strong>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.spam = <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(x.spam, y.spam, SharedData.spam)</span><br></pre></td></tr></table></figure><ul><li>以下例子能更好解释这种把同一名称存储在两个位置的行为：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MixedNames</span>:</span><br><span class="line">    data = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.data, MixedNames.data)</span><br><span class="line"></span><br><span class="line">x = MixedNames(<span class="number">1</span>)</span><br><span class="line">y = MixedNames(<span class="number">2</span>)</span><br><span class="line">x.display(); y.display()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> spam</span><br><span class="line"><span class="number">2</span> spam</span><br></pre></td></tr></table></figure><ul><li>data 位于 2 个地方：在实例对象内（由 __init__ 中的 self.data 赋值运算所创建以及在实例继承的类中（由类中的data赋值运算所创建）</li></ul><h3 id="二、Methods"><a href="#二、Methods" class="headerlink" title="二、Methods"></a>二、Methods</h3><p>1、在一个类方法中，第一位参数为 self 。这个参数给方法提供了一个钩子 hook ，从而返回调用的主体，即<strong>实例对象</strong>。</p><ul><li>这个名称的存在是为了明确脚本中使用的是实例的属性名称，而不是局部作用域或全局作用域中的名称。</li></ul><p>2、示例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NextClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printer</span>(<span class="params">self, text</span>):</span><br><span class="line">        self.message = text</span><br><span class="line">        <span class="built_in">print</span>(self.message)</span><br><span class="line"></span><br><span class="line">x = NextClass()</span><br><span class="line">x.printer(<span class="string">&#x27;instance call&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x.message)</span><br></pre></td></tr></table></figure><ul><li>当对实例进行点号运算来调用它时，printer 会先通过继承进行定位，然后它的 self 参数会被自动赋值为实例对象；</li><li>text 参数会得到在调用时传入的字符串（’instance call’）；</li><li><em>方法能通过实例或类本身2种方式的任意一种进行调用</em>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">NextClass.printer(x, <span class="string">&#x27;class call&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x.message)</span><br></pre></td></tr></table></figure><h3 id="三、Inheritance"><a href="#三、Inheritance" class="headerlink" title="三、Inheritance"></a>三、Inheritance</h3><p>1、在 Python 中，当对对象进行点号运算时就会触发继承，以及搜索属性定义树，即在一个或多个相互链接的命名空间中搜索</p><ul><li>实例属性是由对方法内的 self 属性进行赋值运算产生的；</li><li>类属性是通过 class 语句内的语句创建的；</li><li>父类的连接是通过 class 语句首行的括号内列出的类而产生的；</li><li>结果就是连接实例的属性命名空间树，到产生它的类、再到类首行中列出的所有父类。</li></ul><p>2、子类可以完全替代继承的属性，也可以拓展父类方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;in Super.method&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Super</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;starting Sub.method&#x27;</span>)</span><br><span class="line">        Super.method(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ending Sub.method&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>这类 sub 替代了 super 的方法，同时又调用了 super 的方法，即拓展：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = Super()</span><br><span class="line">x.method()</span><br><span class="line"></span><br><span class="line">x = Sub()</span><br><span class="line">x.method()</span><br></pre></td></tr></table></figure><p>3、抽象父类 Abstract Superclasses</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delegate</span>(<span class="params">self</span>):</span><br><span class="line">        self.action()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Provider</span>(<span class="title class_ inherited__">Super</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">action</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;in Provider.action&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = Provider()</span><br><span class="line">x.delegate()</span><br></pre></td></tr></table></figure><ul><li>上述代码的调用 delegate 方法时，会发生 2 次独立的继承搜索：<ul><li>x.delegate 调用时，python 会搜索 Provider 实例和类树中更上层的类对象，直到 Super 中找到 delegate ，实例 x 传给该方法的 self 参数；</li><li>在 Super.delegate 方法中， self.action 会对 self 以及它上层的对象发起另一次继承搜索。因为 self 引用了一个 Provider 实例，所以 action 方法会在 Provider 子类中找到；</li></ul></li><li>这个例子中的父类有时被称为<strong>抽象父类 abstract superclass</strong>，即类的部分行为预期由其子类来提供；</li><li>如果所预期的方法没有在子类中定义，那么当继承搜索失败时， python 会引发名称未定义的异常。</li></ul><h3 id="四、Namespaces-The-Conclusion"><a href="#四、Namespaces-The-Conclusion" class="headerlink" title="四、Namespaces: The Conclusion"></a>四、Namespaces: The Conclusion</h3><p>1、<strong>命名空间 Namespaces</strong>与<strong>作用域 Scopes</strong></p><ul><li>带点号和无点号的名称采用不同的处理方式；</li><li>无点号运算的名称( X )对应于作用域；</li><li>带点号的属性名( object.X )使用的是对象的命名空间。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">    X = <span class="number">22</span></span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    X = <span class="number">33</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m</span>(<span class="params">self</span>):</span><br><span class="line">        X = <span class="number">44</span></span><br><span class="line">        <span class="built_in">print</span>(X)</span><br><span class="line">        self.X = <span class="number">55</span></span><br></pre></td></tr></table></figure><ul><li>上述代码产生了5个 X 变量：模块属性（11）、函数内的局部变量（22）、类属性（33）、方法中的局部变量（44）以及实例属性（55）：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">f()</span><br><span class="line">g()</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line">obj = C()</span><br><span class="line"><span class="built_in">print</span>(obj.X)</span><br><span class="line"></span><br><span class="line">obj.m()</span><br><span class="line"><span class="built_in">print</span>(obj.X)</span><br><span class="line"><span class="built_in">print</span>(C.X)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">44</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure><p>2、嵌套的类：重温 LEGB 作用域规则</p><p>（1）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nester</span>():</span><br><span class="line">    <span class="built_in">print</span>(X)                         <span class="comment"># Global: 1</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">        <span class="built_in">print</span>(X)                     <span class="comment"># Global: 1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method1</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(X)                 <span class="comment"># Global: 1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method2</span>(<span class="params">self</span>):</span><br><span class="line">            X = <span class="number">3</span></span><br><span class="line">            <span class="built_in">print</span>(X)                 <span class="comment"># Local: 3</span></span><br><span class="line">    I = C()</span><br><span class="line">    I.method1()</span><br><span class="line">    I.method2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">nester()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br></pre></td></tr></table></figure><p>（2）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nester</span>():</span><br><span class="line">    X = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(X)                         <span class="comment"># Local: 2</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">        <span class="built_in">print</span>(X)                     <span class="comment"># In enclosing def (nester): 2</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method1</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(X)                 <span class="comment"># In enclosing def (nester): 2</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method2</span>(<span class="params">self</span>):</span><br><span class="line">            X = <span class="number">3</span></span><br><span class="line">            <span class="built_in">print</span>(X)                 <span class="comment"># Local: 3</span></span><br><span class="line">    I = C()</span><br><span class="line">    I.method1()</span><br><span class="line">    I.method2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">nester()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br></pre></td></tr></table></figure><p>（3）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nester</span>():</span><br><span class="line">    X = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(X)                        <span class="comment"># Local: 2</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">        X = <span class="number">3</span></span><br><span class="line">        <span class="built_in">print</span>(X)                    <span class="comment"># Local: 3</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method1</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(X)                <span class="comment"># In enclosing def (not 3 in class!): 2</span></span><br><span class="line">            <span class="built_in">print</span>(self.X)           <span class="comment"># Inherited class local: 3</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method2</span>(<span class="params">self</span>):</span><br><span class="line">            X = <span class="number">4</span></span><br><span class="line">            <span class="built_in">print</span>(X)                <span class="comment"># Local: 4</span></span><br><span class="line">            self.X = <span class="number">5</span></span><br><span class="line">            <span class="built_in">print</span>(self.X)           <span class="comment"># Located in instance: 5</span></span><br><span class="line">    I = C()</span><br><span class="line">    I.method1()</span><br><span class="line">    I.method2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">nester()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">40</span>)</span><br></pre></td></tr></table></figure><p>上面3个运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">----------------------------------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">----------------------------------------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure><ul><li>像 X 这样简单名称的查找规则从来不会搜索外层 class 语句，只搜索 def 语句、模块和内置的；</li><li>是 LEGB 规则，不是 CLEGB ！！</li><li>所以在 method1 中， X 在位于其外层类外部的 def 语句中被找到；</li><li>想要访问类中被赋值的名称，必须将其作为类对象或者实例对象的属性来获取。</li></ul><h3 id="五、Namespace-Dictionaries-Review"><a href="#五、Namespace-Dictionaries-Review" class="headerlink" title="五、Namespace Dictionaries: Review"></a>五、Namespace Dictionaries: Review</h3><p>1、命名空间字典</p><ul><li>如同模块的命名空间，类对象和实例对象的命名空间被实现为字典，即内置的 <code>__dict__ 属性</code>；</li><li>属性继承就是搜索链接的字典；实例对象和类对象就是互相之间带有链接的字典：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        self.data1 = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Super</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hola</span>(<span class="params">self</span>):</span><br><span class="line">        self.data2 = <span class="string">&#x27;eggs&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>当我们创建子类的实例时，该实例一开始是空的命名空间字典，但是有指向它的类的链接，让继承搜索能顺着寻找；</li><li>继承树可在特殊的属性中显式获取；</li><li>实例对象的 <code>__class__ 属性</code>链接到了它的类，而类有一个 <code>__bases__ 属性</code>（一个元组），其中包含通往更高的父类的链接：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = Sub()</span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br><span class="line"><span class="built_in">print</span>(X.__class__)</span><br><span class="line"><span class="built_in">print</span>(Sub.__bases__)</span><br><span class="line"><span class="built_in">print</span>(Super.__bases__)</span><br></pre></td></tr></table></figure><ul><li>当类为 self 属性赋值时，属性会位于实例的属性命名空间字典内：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y = Sub()</span><br><span class="line">X.hello()</span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br><span class="line">X.hola()</span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(Sub.__dict__.keys()))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(Super.__dict__.keys()))</span><br><span class="line"><span class="built_in">print</span>(Y.__dict__)</span><br></pre></td></tr></table></figure><ul><li>因为属性在 python 内部是字典键，所以有2种方式进行访问或赋值：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(X.data1, X.__dict__[<span class="string">&#x27;data1&#x27;</span>])</span><br><span class="line">X.data3 = <span class="string">&#x27;toast&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br><span class="line">X.__dict__[<span class="string">&#x27;data3&#x27;</span>] = <span class="string">&#x27;ham&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br></pre></td></tr></table></figure><ul><li>但是属性的点号运算会执行继承搜索，而字典索引无法访问继承属性；</li><li>比如继承的属性 X.hello 就无法由 <code>X.__dict__[&#39;hello&#39;]</code> 来访问。</li></ul><h3 id="六、Documentation-Strings-Revisited"><a href="#六、Documentation-Strings-Revisited" class="headerlink" title="六、Documentation Strings Revisited"></a>六、Documentation Strings Revisited</h3><p>1、如同模块，文档字符串 Documentation Strings 也可以用于类</p><ul><li>文本字符串由 python 自动保存到相应对象的 __doc__ 属性中；</li><li>文档字符串适用于模块文件、函数定义，以及类和方法：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docstr.py</span></span><br><span class="line"><span class="string">&quot;I am: docstr.__doc__&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="string">&quot;I am: docstr.func.__doc__&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">spam</span>:</span><br><span class="line">    <span class="string">&quot;I am: spam.__doc__ or docstr.spam.__doc__ or self.__doc__&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;I am: spam.method.__doc__ or self.method.__doc__&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(self.__doc__)</span><br><span class="line">        <span class="built_in">print</span>(self.method.__doc__)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> docstr</span><br><span class="line"><span class="built_in">print</span>(docstr.__doc__)</span><br><span class="line"><span class="built_in">print</span>(docstr.func.__doc__)</span><br><span class="line"><span class="built_in">print</span>(docstr.spam.__doc__)</span><br><span class="line"><span class="built_in">print</span>(docstr.spam.method.__doc__)</span><br><span class="line"></span><br><span class="line">x = docstr.spam()</span><br><span class="line">x.method()</span><br></pre></td></tr></table></figure><ul><li>第15章还讨论了 PyDoc 工具，该工具能将这些文档字符串整理成报告和网页：<code>help(docstr)</code>。</li></ul><h2 id="chapter-30-Class-Coding-Details"><a href="#chapter-30-Class-Coding-Details" class="headerlink" title="chapter 30 Class Coding Details"></a>chapter 30 Class Coding Details</h2><h3 id="一、The-Basics"><a href="#一、The-Basics" class="headerlink" title="一、The Basics"></a>一、The Basics</h3><p>1、运算符重载 operator overloading 基础知识</p><ul><li>运算符重载让类拦截常规的 Python 操作；</li><li>类可重载所有 python 表达式运算符；</li><li>类也可以重载打印、函数调用、属性访问等内置运算；</li><li>重载使类实例的行为更接近内置类型；</li><li>重载是通过在一个类中提供特殊名称的方法来实现的。</li></ul><p>2、构造函数和捕捉减法的表达式： __init__ 和 __sub__</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start</span>):</span><br><span class="line">        self.data = start</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sub__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Number(self.data - other)</span><br><span class="line"></span><br><span class="line">X = Number(<span class="number">5</span>)</span><br><span class="line">Y = X - <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(Y.data)</span><br></pre></td></tr></table></figure><ul><li>__sub__ 跟第27章的 __add__ 方法类似，会拦截减法表达式并返回一个新的对象实例作为结果；</li><li>在一个实例被创建的过程中，首先触发是 __new__ 方法，这一方法将创建并返回一个新的实例对象，并传入 __init__ 函数以供初始化，见第40章。</li></ul><p>3、常见的运算符重载方法</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法名 Method</th><th style="text-align:left">实现功能 Implements</th><th style="text-align:left">触发调用的形式 Called for</th></tr></thead><tbody><tr><td style="text-align:left">__init__</td><td style="text-align:left">Constructor</td><td style="text-align:left">Object creation: X = Class(args)</td></tr><tr><td style="text-align:left">__del__</td><td style="text-align:left">Destructor</td><td style="text-align:left">Object reclamation of X</td></tr><tr><td style="text-align:left">__add__</td><td style="text-align:left">Operator +</td><td style="text-align:left">X + Y, X += Y if no __iadd__</td></tr><tr><td style="text-align:left">__or__</td><td style="text-align:left">Operator &#124; (bitwise OR)</td><td style="text-align:left">X &#124; Y, X &#124;= Y if no __ior__</td></tr><tr><td style="text-align:left">__repr__, __str__</td><td style="text-align:left">Printing, conversions</td><td style="text-align:left">print(X), repr(X), str(X)</td></tr><tr><td style="text-align:left">__call__</td><td style="text-align:left">Function calls</td><td style="text-align:left">X(*args, **kargs)</td></tr><tr><td style="text-align:left">__getattr__</td><td style="text-align:left">Attribute fetch</td><td style="text-align:left">X.undefined</td></tr><tr><td style="text-align:left">__setattr__</td><td style="text-align:left">Attribute assignment</td><td style="text-align:left">X.any = value</td></tr><tr><td style="text-align:left">__delattr__</td><td style="text-align:left">Attribute deletion</td><td style="text-align:left">del X.any</td></tr><tr><td style="text-align:left">__getattribute__</td><td style="text-align:left">Attribute fetch</td><td style="text-align:left">X.any</td></tr><tr><td style="text-align:left">__getitem__</td><td style="text-align:left">Indexing, slicing, iteration</td><td style="text-align:left">X[key], X[i:j], for loops and other iterations if no __iter__</td></tr><tr><td style="text-align:left">__setitem__</td><td style="text-align:left">Index and slice assignment</td><td style="text-align:left">X[key] = value, X[i:j] = iterable</td></tr><tr><td style="text-align:left">__delitem__</td><td style="text-align:left">Index and slice deletion</td><td style="text-align:left">del X[key], del X[i:j]</td></tr><tr><td style="text-align:left">__len__</td><td style="text-align:left">Length</td><td style="text-align:left">len(X), truth tests if no __bool__</td></tr><tr><td style="text-align:left">__bool__</td><td style="text-align:left">Boolean tests</td><td style="text-align:left">bool(X), truth tests (named __nonzero__ in 2.X)</td></tr><tr><td style="text-align:left">__lt__, __gt__</td><td style="text-align:left">Comparisons</td><td style="text-align:left">X &lt; Y, X &gt; Y</td></tr><tr><td style="text-align:left">__le__, __ge__</td><td style="text-align:left">Comparisons</td><td style="text-align:left">X &lt;= Y, X &gt;= Y</td></tr><tr><td style="text-align:left">__eq__, __ne__</td><td style="text-align:left">Comparisons</td><td style="text-align:left">X == Y, X != Y</td></tr><tr><td style="text-align:left">__radd__</td><td style="text-align:left">Right-side operators</td><td style="text-align:left">Other + X</td></tr><tr><td style="text-align:left">__iadd__</td><td style="text-align:left">In-place augmented operators</td><td style="text-align:left">X += Y (or else __add__)</td></tr><tr><td style="text-align:left">__iter__, __next__</td><td style="text-align:left">Iteration contexts</td><td style="text-align:left">I=iter(X), next(I); for loops, in if no __contains__, all comprehensions, map(F,X), others</td></tr><tr><td style="text-align:left">__contains__</td><td style="text-align:left">Membership test</td><td style="text-align:left">item in X (any iterable)</td></tr><tr><td style="text-align:left">__index__</td><td style="text-align:left">Integer value</td><td style="text-align:left">hex(X), bin(X), oct(X), O[X], O[X:] (replaces 2.X __oct__, __hex__)</td></tr><tr><td style="text-align:left">__enter__, __exit__</td><td style="text-align:left">Context manager</td><td style="text-align:left">with obj as var:</td></tr><tr><td style="text-align:left">__get__, __set__, __delete__</td><td style="text-align:left">Descriptor attributes</td><td style="text-align:left">X.attr, X.attr = value, del X.attr</td></tr><tr><td style="text-align:left">__new__</td><td style="text-align:left">Creation</td><td style="text-align:left">Object creation, before __init__</td></tr></tbody></table></div><ul><li>运算符重载方法是可选的，如果没有给出相应的运算符重载方法的话，大多数内置函数会对类实例失效。</li></ul><h3 id="二、Indexing-and-Slicing-getitem-and-setitem"><a href="#二、Indexing-and-Slicing-getitem-and-setitem" class="headerlink" title="二、Indexing and Slicing: __getitem__ and __setitem__"></a>二、Indexing and Slicing: __getitem__ and __setitem__</h3><p>1、<code>__getitem__</code>：如果类定义或继承了该方法，该方法会自动被调用并进行实例的索引运算</p><ul><li>即实例 X 出现在 <code>X[i]</code> 的运算中，python 会调用实例继承的 <code>__getitem__</code> 方法，把 X 作为第一个参数传入，索引值传给第二个参数：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Indexer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> index ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">X = Indexer()</span><br><span class="line"><span class="built_in">print</span>(X[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>2、拦截分片 Intercepting Slices</p><ul><li>除了索引，<code>__getitem__</code> 也会被分片表达式调用：</li><li>以下为分片相关，详见第7章：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">2</span>:<span class="number">4</span>], L[<span class="number">1</span>:], L[:-<span class="number">1</span>], L[::<span class="number">2</span>])</span><br></pre></td></tr></table></figure><ul><li>也可以手动地传入分片对象：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(L[<span class="built_in">slice</span>(<span class="number">2</span>, <span class="number">4</span>)], L[<span class="built_in">slice</span>(<span class="number">1</span>, <span class="literal">None</span>)], L[<span class="built_in">slice</span>(<span class="literal">None</span>, -<span class="number">1</span>)], L[<span class="built_in">slice</span>(<span class="literal">None</span>, <span class="literal">None</span>, <span class="number">2</span>)])</span><br></pre></td></tr></table></figure><ul><li>而 <code>__getitem__</code> 即能被基础索引（带有一个索引）调用，又能被分片（带有一个分片对象）调用：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Indexer</span>:</span><br><span class="line">    data = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;getitem:&#x27;</span>, index)</span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line"></span><br><span class="line">X = Indexer()</span><br><span class="line">X[<span class="number">0</span>]</span><br><span class="line">X[<span class="number">1</span>]</span><br><span class="line">X[-<span class="number">1</span>]</span><br><span class="line">X[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">X[<span class="number">1</span>:]</span><br><span class="line">X[:-<span class="number">1</span>]</span><br><span class="line">X[::<span class="number">2</span>]</span><br></pre></td></tr></table></figure><ul><li><code>__getitem__</code> 可以检测它接收的参数类型，并提取分片对象的边界。分片对象拥有 start 、 stop 和 step 这些属性，任意一项被省略的话都是 None ：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Indexer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(index, <span class="built_in">int</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;indexing&#x27;</span>, index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;slicing&#x27;</span>, index.start, index.stop, index.step)</span><br><span class="line"></span><br><span class="line">X = Indexer()</span><br><span class="line">X[<span class="number">99</span>]</span><br><span class="line">X[<span class="number">1</span>:<span class="number">99</span>:<span class="number">2</span>]</span><br><span class="line">X[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p>3、<code>__setitem__</code> 方法是对索引进行赋值，可以拦截索引赋值或分片赋值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IndexSetter</span>:</span><br><span class="line">    data = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, index, value</span>):</span><br><span class="line">        self.data[index] = value ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">X = IndexSetter()</span><br><span class="line">X[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(X.data)</span><br></pre></td></tr></table></figure><p>4、<code>__index__</code> 方法不是索引</p><ul><li><code>__index__</code> 方法会为一个实例返回一个整数值，供转化数字串的内置函数使用：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__index__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">255</span></span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(X))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(X))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(X))</span><br></pre></td></tr></table></figure><ul><li>也可以作为索引：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="string">&#x27;C&#x27;</span> * <span class="number">256</span>)[<span class="number">255</span>])</span><br><span class="line"><span class="built_in">print</span>((<span class="string">&#x27;C&#x27;</span> * <span class="number">256</span>)[X])</span><br><span class="line"><span class="built_in">print</span>((<span class="string">&#x27;C&#x27;</span> * <span class="number">256</span>)[X:])</span><br></pre></td></tr></table></figure><p>5、索引迭代：<code>__getitem__</code></p><ul><li><code>__getitem__</code> 也可以是 Python 中一种重载迭代的方式；</li><li>可以重复对序列进行索引运算，直到检测到超出边界的 IndexError 异常。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StepperIndex</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data[i]</span><br><span class="line">    </span><br><span class="line">X = StepperIndex()</span><br><span class="line">X.data = <span class="string">&quot;Spam&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X[<span class="number">1</span>])  <span class="comment"># Indexing calls __getitem__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> X:  <span class="comment"># for loops call __getitem__</span></span><br><span class="line">    <span class="built_in">print</span>(item, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>成员关系测试 in 、列表推导、内置函数 map 、列表和元组赋值运算以及类型构造方法都会自动调用 <code>__getitem__</code> ：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> X)</span><br><span class="line"><span class="built_in">print</span>([c <span class="keyword">for</span> c <span class="keyword">in</span> X])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>.upper, X)))</span><br><span class="line">(a, b, c, d) = X</span><br><span class="line"><span class="built_in">print</span>(a, c, d)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(X), <span class="built_in">tuple</span>(X), <span class="string">&#x27;&#x27;</span>.join(X))</span><br><span class="line"><span class="built_in">print</span>(X)</span><br></pre></td></tr></table></figure><h3 id="三、Iterable-Objects-iter-and-next"><a href="#三、Iterable-Objects-iter-and-next" class="headerlink" title="三、Iterable Objects: __iter__ and __next__"></a>三、Iterable Objects: __iter__ and __next__</h3><p>1、Python 中所有的迭代上下文都先尝试 <code>__iter__</code> 方法，再尝试 <code>__getitem__</code></p><p>2、用类定义用户自定义可迭代对象</p><ul><li>迭代上下文是通过将一个可迭代对象传入内置函数 iter ，并尝试调用 __iter__ 方法来实现的，该方法返回一个迭代器对象；</li><li>如果提供了这种方法，python 会重复调用这个迭代器对象的 __next__ 方法来产生元素，直到引发 StopIteration 异常。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Squares</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, stop</span>):</span><br><span class="line">        self.value = start - <span class="number">1</span></span><br><span class="line">        self.stop = stop</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self <span class="comment"># __iter__方法返回的迭代器对象就是实例对象self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.value == self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration <span class="comment"># 迭代通过raise语句来结束</span></span><br><span class="line">        self.value += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.value ** <span class="number">2</span> <span class="comment"># 改为生成平方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Squares(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = Squares(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">I = <span class="built_in">iter</span>(X)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br></pre></td></tr></table></figure><p>3、单遍扫描和多遍扫描</p><ul><li>类的 <code>__iter__</code> 被设计为只遍历一次，而不是多次；</li><li>类在代码中显式地选择扫描行为；</li><li>由于上面 Squares 类的 __iter__ 通常返回只带有一份迭代状态复制的 self ，因此是一个一次性的迭代；</li><li>一旦迭代过这个类的一个实例，它就变为空；</li><li>所以需要为每一次新的迭代创建一个新的可迭代实例对象。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = Squares(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>([n <span class="keyword">for</span> n <span class="keyword">in</span> X]) <span class="comment"># Exhausts items: __iter__ returns self</span></span><br><span class="line"><span class="built_in">print</span>([n <span class="keyword">for</span> n <span class="keyword">in</span> X]) <span class="comment"># Now it&#x27;s empty: __iter__ returns same self</span></span><br><span class="line"><span class="built_in">print</span>([n <span class="keyword">for</span> n <span class="keyword">in</span> Squares(<span class="number">1</span>, <span class="number">5</span>)]) <span class="comment"># Make a new iterable object</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(Squares(<span class="number">1</span>, <span class="number">3</span>))) <span class="comment"># A new object for each new __iter__ call</span></span><br></pre></td></tr></table></figure><p>4、单个对象上的多个迭代器</p><ul><li>例如14章提到的：生成器函数、生成器表达式以及 map 和 zip 这样的内置函数，是单次迭代对象，只能支持唯一一个活跃扫描；</li><li>range 内置函数和其他的内置类型（如列表），则支持多个带有独立位置的活跃迭代器。</li></ul><p>（1）单次遍历迭代对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="built_in">map</span>(<span class="built_in">list</span>, <span class="string">&#x27;ace&#x27;</span>) <span class="comment"># 得到的是[&#x27;a&#x27;],[&#x27;b&#x27;],[&#x27;c&#x27;]的迭代器</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> S:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> S:</span><br><span class="line">        <span class="built_in">print</span>(x + y, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure><p>（2）多次遍历迭代对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="built_in">list</span>(<span class="string">&#x27;ace&#x27;</span>) <span class="comment"># 得到的是[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> S:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> S:</span><br><span class="line">        <span class="built_in">print</span>(x + y, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>当用类编写用户定义的可迭代对象，要达到多个迭代器的效果，__iter__ 只需替迭代器定义一个新的对象状态，而不是在每次迭代器请求中都返回 self ；</li><li>下面的 SkipObject 类定义了一个可迭代对象。由于它的迭代器对象会在每次迭代时都被一个支持类重新创建，因此能够支持多个循环：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SkipObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, wrapped</span>):</span><br><span class="line">        self.wrapped = wrapped</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> SkipIterator(self.wrapped) <span class="comment"># New iterator each time</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkipIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, wrapped</span>):</span><br><span class="line">        self.wrapped = wrapped <span class="comment"># Iterator state information</span></span><br><span class="line">        self.offset = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.offset &gt;= <span class="built_in">len</span>(self.wrapped):</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            item = self.wrapped[self.offset]</span><br><span class="line">            self.offset += <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">alpha = <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line">skipper = SkipObject(alpha)</span><br><span class="line">I = <span class="built_in">iter</span>(skipper)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I), <span class="built_in">next</span>(I), <span class="built_in">next</span>(I))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> skipper:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> skipper:</span><br><span class="line">        <span class="built_in">print</span>(x + y, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure><p>5、编程备选方案：<code>__iter__</code> 加 yield</p><ul><li>包含 yield 语句的函数都会被转换成一个生成器函数；</li><li>当被调用时，它返回一个新的生成器对象；</li><li>一个被自动创建的 __iter__ 方法返回它本身；</li><li>而另一个自动创建的 __next__ 方法要么开始函数的执行，要么回到上一次执行的位置：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x): <span class="keyword">yield</span> i ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">G = gen(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(G.__iter__() == G)</span><br><span class="line">I = <span class="built_in">iter</span>(G)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I), <span class="built_in">next</span>(I))</span><br></pre></td></tr></table></figure><ul><li>这个带有 yield 的生成器函数可以作为类的 __iter__ 重载方法；</li><li>这样的方法会放回带有 __next__方法的新生成器对象；</li><li>在类中作为方法的生成器函数有权访问存储在实例属性和局部作用域变量中的状态：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Squares</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, stop</span>):</span><br><span class="line">        self.start = start</span><br><span class="line">        self.stop = stop</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(self.start, self.stop + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">yield</span> value ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Squares(<span class="number">1</span>, <span class="number">5</span>): <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>__iter__ 返回了一个生成器对象，该生成器对象带有一个自动创建的 __next__ 类，如果调用结果对象的 next 接口，就能按需产生结果：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = Squares(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line">I = <span class="built_in">iter</span>(S)</span><br><span class="line"><span class="built_in">print</span>(I)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I), <span class="built_in">next</span>(I))</span><br></pre></td></tr></table></figure><ul><li>除了将生成器函数作为 __iter__ 方法，可以手动访问属性和调用，如<code>Squares(1,5).gen()</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Squares</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, stop</span>):</span><br><span class="line">        self.start = start</span><br><span class="line">        self.stop = stop</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gen</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(self.start, self.stop + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">yield</span> value ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Squares(<span class="number">1</span>, <span class="number">5</span>).gen(): <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure><p>①当有 __iter__ 时，迭代触发 __iter__ 并返回一个新的带有 __next__ 的生成器；<br>②当没有 __iter__ 时，代码会调用一个生成器，自动创建 __iter__ 方法返回它本身。</p><p>6、使用 yield 的多重迭代器</p><ul><li>之前的 __iter__ 加 yield 组合自动支持多重活跃迭代器；</li><li>因为每次对__iter__的调用都是返回一个新的生成器：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Squares</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, stop</span>):</span><br><span class="line">        self.start = start</span><br><span class="line">        self.stop = stop</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(self.start, self.stop + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">yield</span> value ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">S = Squares(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">I = <span class="built_in">iter</span>(S)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I), <span class="built_in">next</span>(I))</span><br><span class="line">J = Squares(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">J = <span class="built_in">iter</span>(S)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(J), <span class="built_in">next</span>(J))</span><br><span class="line"></span><br><span class="line">S = Squares(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> S:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s:%s&#x27;</span> % (i, j), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="四、Membership-contains-iter-and-getitem"><a href="#四、Membership-contains-iter-and-getitem" class="headerlink" title="四、Membership: __contains__, __iter__, and __getitem__"></a>四、Membership: __contains__, __iter__, and __getitem__</h3><p>1、in 成员关系</p><ul><li>类通常把 in 成员关系运算符实现为一个迭代，使用 <code>__iter__</code> 方法或 <code>__getitem__</code> 方法；</li><li>类还可以通过编写 <code>__contain__</code> 方法来支持更加特定具体的成员关系。</li><li>即当 <code>__contain__</code> 方法存在时，它优先于 <code>__iter__</code> 方法，而 <code>__iter__</code> 方法优先于 <code>__getitem__</code> 方法；</li><li><code>__contain__</code> 方法应该把成员关系定义为对一个键值做映射，或定义为对序列的搜索。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Iters</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get[%s]:&#x27;</span> % i, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.data[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;iter=&gt; &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        self.ix = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;next:&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.ix == <span class="built_in">len</span>(self.data): <span class="keyword">raise</span> StopIteration</span><br><span class="line">        item = self.data[self.ix]</span><br><span class="line">        self.ix += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;contains: &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">in</span> self.data</span><br><span class="line"></span><br><span class="line">X = Iters([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> X: </span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; | &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>([i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> X])</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">bin</span>, X)) )</span><br><span class="line"></span><br><span class="line">I = <span class="built_in">iter</span>(X)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(I), end=<span class="string">&#x27; @ &#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;-&#x27;</span> * <span class="number">128</span>)</span><br></pre></td></tr></table></figure><p>2、上述代码去掉 <code>__contains__</code> 方法后，成员关系由 <code>__iter__</code> 执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Iters</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get[%s]:&#x27;</span> % i, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.data[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;iter=&gt; &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        self.ix = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;next:&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.ix == <span class="built_in">len</span>(self.data): <span class="keyword">raise</span> StopIteration</span><br><span class="line">        item = self.data[self.ix]</span><br><span class="line">        self.ix += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">X = Iters([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> X: </span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; | &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>([i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> X])</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">bin</span>, X)) )</span><br><span class="line"></span><br><span class="line">I = <span class="built_in">iter</span>(X)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(I), end=<span class="string">&#x27; @ &#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;-&#x27;</span> * <span class="number">128</span>)</span><br></pre></td></tr></table></figure><p>3、上述代码去掉 <code>__contains__</code> 和 <code>__iter__</code> 方法后，成员关系和其他迭代上下文，由 <code>__getitem__</code> 方法调用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Iters</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.data = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get[%s]:&#x27;</span> % i, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.data[i]</span><br><span class="line"></span><br><span class="line">X = Iters([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> X: </span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; | &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>([i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> X])</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">bin</span>, X)) )</span><br><span class="line"></span><br><span class="line">I = <span class="built_in">iter</span>(X)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(I), end=<span class="string">&#x27; @ &#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;-&#x27;</span> * <span class="number">128</span>)</span><br></pre></td></tr></table></figure><ul><li><code>__getitem__</code> 方法更加通用，除了迭代，还拦截显式索引和分片：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = Iters(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(X[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X[<span class="number">1</span>:])</span><br><span class="line"><span class="built_in">print</span>(X[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(X))</span><br></pre></td></tr></table></figure><h3 id="五、Attribute-Access-getattr-and-setattr"><a href="#五、Attribute-Access-getattr-and-setattr" class="headerlink" title="五、Attribute Access: __getattr__ and __setattr__"></a>五、Attribute Access: __getattr__ and __setattr__</h3><p>1、类在需要的时候也可以拦截基本的属性访问（点号运算），即 <code>object.contribute</code> </p><p>2、属性引用</p><ul><li><code>__getattr__</code>方法可以用来拦截属性引用；</li><li>每当用一个未定义的（不存在的）属性名称字符串对一个实例对象做点号运算时，它就会被调用；</li><li>正因为如此，<code>__getattr__</code> 可以用作以泛化形式响应属性请求的钩子；</li><li>它通常用于将代理控制对象的调用委托给内嵌（被包装）的对象；</li><li>这个方法也可以用于让类适配一个接口，或是为数据属性添加一个访问方法。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attrname</span>):</span><br><span class="line">        <span class="keyword">if</span> attrname == <span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">40</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(attrname)</span><br><span class="line"></span><br><span class="line">X = Empty()</span><br><span class="line"><span class="built_in">print</span>(X.age)</span><br></pre></td></tr></table></figure><p>3、属性赋值和删除</p><ul><li><code>__setattr__</code> 会拦截所有的属性赋值；</li><li>如果定义或继承了这个方法，<code>self.attr = value</code> 会变成 <code>self.__setattr__(&#39;attr&#39;, value)</code></li><li>注意事项：如果在 <code>__setattr__</code> 中对任何 self 属性做赋值，都将再次调用 <code>__setattr__</code> ，会导致无限递归循环（最终结果是相对快速的栈溢出异常）；</li><li>记住：<code>__setattr__</code> 会捕获所有的属性赋值；</li><li>如果你想使用该方法，可以把实例属性的赋值编写成对属性字典键的赋值来避免循环；</li><li>即，使用 <code>self.__dict__[&#39;name&#39;] = x</code> ，而不是 <code>self.name = x</code> ，来避免循环：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accesscontrol</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, attr, value</span>):</span><br><span class="line">        <span class="keyword">if</span> attr == <span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">            self.__dict__[attr] = value + <span class="number">10</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(attr + <span class="string">&#x27; not allowed&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = Accesscontrol()</span><br><span class="line">X.age = <span class="number">40</span></span><br><span class="line"><span class="built_in">print</span>(X.age)</span><br></pre></td></tr></table></figure><ul><li>第三个属性管理方法 <code>__delattr__</code> 被传入属性名称字符串并在所有属性删除操作被调用；</li><li>它也必须通过 <code>__dict__</code> 来进行属性删除操作，从而避免循环调用。</li></ul><p>4、其他属性管理工具</p><ul><li><code>__getattribute__</code> 方法拦截所有的属性访问，不只是未定义的；</li><li>property 内置函数允许把方法对指定类属性上的访问和修改操作关联起来；</li><li>描述符 Descriptors 提供了一个协议，把一个类的 <code>__get__</code> 和 <code>__set__</code> 方法对指定类属性上的访问关联起来；</li><li>slot 属性在类中被声明，但在每个实例中都会创建隐式的存储。</li></ul><h3 id="六、String-Representation-repr-and-str"><a href="#六、String-Representation-repr-and-str" class="headerlink" title="六、String Representation: __repr__ and __str__"></a>六、String Representation: __repr__ and __str__</h3><p>1、<code>__repr__</code> 和 <code>__str__</code></p><ul><li><code>__str__</code> 会首先被打印操作和 str 内置函数尝试；</li><li><code>__repr__</code> 用于交互式命令行、 repr 函数、嵌套的显示，以及没有 __str__ 时的 print 和 str 调用</li><li><code>__str__</code> 用于程序的用户友好的显示，而 <code>__repr__</code> 通常用于代码或底层的显示：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">adder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value=<span class="number">0</span></span>):</span><br><span class="line">        self.data = value</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        self.data += other</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">addrepr</span>(<span class="title class_ inherited__">adder</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;addrepr(%s)&#x27;</span> % self.data</span><br><span class="line"></span><br><span class="line">x = addrepr(<span class="number">2</span>)</span><br><span class="line">x + <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>在交互式命令行中，x 显示 addrepr(3) ，与 print(x) 一样：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(x) </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">addstr</span>(<span class="title class_ inherited__">adder</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[Value: %s]&#x27;</span> % self.data</span><br><span class="line"></span><br><span class="line">x = addstr(<span class="number">3</span>)</span><br><span class="line">x + <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>在交互式命令行中， x 显示 <code>&lt;__main__.addstr object at 0x00000000029738D0&gt;</code>，与 print(x) 不一样：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">addboth</span>(<span class="title class_ inherited__">adder</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;[Value: %s]&#x27;</span> % self.data</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;addboth(%s)&#x27;</span> % self.data</span><br><span class="line"></span><br><span class="line">x = addboth(<span class="number">4</span>)</span><br><span class="line">x + <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>在交互式命令行中， x 显示 addboth(5) ，运行 <code>__repr__</code> 方法：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(x) <span class="comment"># 运行__str__方法 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(x), <span class="built_in">repr</span>(x))</span><br></pre></td></tr></table></figure><p>2、使用提示</p><ul><li><code>__str__</code> 和 <code>__repr__</code> 都必须返回字符串；</li><li><code>__str__</code> 只会应用在对象出现在打印操作顶层时；在对象中内嵌的对象仍然使用 <code>__repr__</code> 方法打印</li><li>我的理解是 <code>__repr__</code> 表示对象本身显示什么，<code>__str__</code> 表示对象打印出什么。</li><li>打印容器对象的 <code>__str__</code> 方法：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.val)</span><br><span class="line"></span><br><span class="line">objs = [Printer(<span class="number">2</span>), Printer(<span class="number">3</span>)]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> objs: <span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(objs)</span><br></pre></td></tr></table></figure><ul><li>打印容器对象的 <code>__repr__</code> 方法：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.val)</span><br><span class="line"></span><br><span class="line">objs = [Printer(<span class="number">2</span>), Printer(<span class="number">3</span>)]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> objs: <span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(objs)</span><br></pre></td></tr></table></figure><h3 id="七、Right-Side-and-In-Place-Uses-radd-and-iadd"><a href="#七、Right-Side-and-In-Place-Uses-radd-and-iadd" class="headerlink" title="七、Right-Side and In-Place Uses: __radd__ and __iadd__"></a>七、Right-Side and In-Place Uses: __radd__ and __iadd__</h3><p>1、右侧加法</p><ul><li>目前编写的 <code>__add__</code> 方法并不支持把实例对象写在 + 右侧；</li><li>为了实现更通用的表达式，需要同时编写 <code>__radd__</code> 方法；</li><li>只有当 + 右侧是实例对象且左侧不是实例对象时，python 才会调用 <code>__radd__</code>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Commuter1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;add&#x27;</span>, self.val, other)</span><br><span class="line">        <span class="keyword">return</span> self.val + other</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>): <span class="comment"># 顺序反转：self在 + 的右侧，other在左侧</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;radd&#x27;</span>, self.val, other)</span><br><span class="line">        <span class="keyword">return</span> other + self.val</span><br><span class="line"></span><br><span class="line">x = Commuter1(<span class="number">88</span>)</span><br><span class="line">y = Commuter1(<span class="number">99</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> + y)</span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br></pre></td></tr></table></figure><ul><li>2个实例对象相加后，python首先运行 <code>__add__</code> ，在 <code>__add__</code> 内部的 return 中又有加号即 88 + y，这个 + 触发了 <code>__radd__</code> 方法；</li><li>所以上面 <code>__add__</code> 方法中，<code>return self.val + other</code> 改为 <code>return other + self.val</code> ，就会看到2次 add ；</li></ul><p>2、在 <code>__radd__</code> 中使用 <code>__add__</code></p><ul><li>可以在 <code>__radd__</code> 中直接调用 <code>__add__</code> ；要么交换位置，间接触发 <code>__add__</code> ；要么在类的顶层直接把 <code>__radd__</code> 赋值成 <code>__add__</code> 的别名：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Commuter2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;add&#x27;</span>, self.val, other)</span><br><span class="line">        <span class="keyword">return</span> self.val + other</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__add__(other)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Commuter3</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;add&#x27;</span>, self.val, other)</span><br><span class="line">        <span class="keyword">return</span> self.val + other</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self + other</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Commuter4</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;add&#x27;</span>, self.val, other)</span><br><span class="line">        <span class="keyword">return</span> self.val + other</span><br><span class="line">    __radd__ = __add__</span><br></pre></td></tr></table></figure><p> 3、return 类类型，需要 isinstance 测试来避免嵌套</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Commuter5</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Commuter5): <span class="comment"># 如果不测试，会得到嵌套在Commuter5中的Commuter5对象</span></span><br><span class="line">            other = other.val</span><br><span class="line">        <span class="keyword">return</span> Commuter5(self.val + other)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> Commuter5(other + self.val)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;Commuter5: %s&gt;&#x27;</span> % self.val</span><br><span class="line"></span><br><span class="line">x = Commuter5(<span class="number">88</span>)</span><br><span class="line">y = Commuter5(<span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(x + <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> + y)</span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"><span class="built_in">print</span>(x + y + <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>4、原位置加法 In-Place Addition</p><ul><li>为了实现 += ，可以编写一个 <code>__iadd__</code> 或 <code>__add__</code>；</li><li><code>__iadd__</code> 更高效，若不存在，则会使用 <code>__add__</code>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iadd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        self.val += other</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">x = Number(<span class="number">5</span>)</span><br><span class="line">x += <span class="number">1</span></span><br><span class="line">x += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(x.val)</span><br><span class="line"></span><br><span class="line">y = Number([<span class="number">1</span>])</span><br><span class="line">y += [<span class="number">2</span>]</span><br><span class="line">y += [<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(y.val)</span><br></pre></td></tr></table></figure><p>5、每个运算符都有右侧和原位置重置方法，例如乘法的 <code>__mul__</code> 、 <code>__rmul__</code> 、 <code>__imul__</code>。</p><h3 id="八、Other-Operator-Overloading"><a href="#八、Other-Operator-Overloading" class="headerlink" title="八、Other Operator Overloading"></a>八、Other Operator Overloading</h3><p>1、Call Expressions: <code>__call__</code></p><ul><li>调用实例会使用 <code>__call__</code> 方法：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Callee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *pargs, **kargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Called:&#x27;</span>, pargs, kargs)</span><br><span class="line"></span><br><span class="line">C = Callee()</span><br><span class="line">C(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">C(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, x=<span class="number">4</span>, y=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>2、Comparisons: <code>__lt__</code> , <code>__gt__</code> , and Others</p><ul><li>类可以定义方法来捕获&lt;、&gt;、&lt;=、&gt;=、==、!=</li><li>比较运算符没有隐含关系，比如 == 为真并不意味着 != 为假。因此 <code>__eq__</code> 和 <code>__ne__</code> 的定义要确保两个运算符都正确地工作；</li><li>以下为简单介绍：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    data = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__gt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data &gt; other</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data &lt; other</span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line"><span class="built_in">print</span>(X &gt; <span class="string">&#x27;ham&#x27;</span>) <span class="comment"># runs __gt__</span></span><br><span class="line"><span class="built_in">print</span>(X &lt; <span class="string">&#x27;ham&#x27;</span>) <span class="comment"># runs __lt__</span></span><br></pre></td></tr></table></figure><p>3、Boolean Tests: <code>__bool__</code> and <code>__len__</code></p><ul><li>Python会首先尝试 <code>__bool__</code> 来获取一个直接的布尔值；如果没有该方法，则尝试 <code>__len__</code> 来根据对象长度确定真值：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">X = Truth()</span><br><span class="line"><span class="keyword">if</span> X: <span class="built_in">print</span>(<span class="string">&#x27;yes!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">X = Truth()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(X))</span><br></pre></td></tr></table></figure><ul><li>如果没有上述方法，python 会使用长度，非零长度为真，零长度为假：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">X = Truth()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> X: <span class="built_in">print</span>(<span class="string">&#x27;no!&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>如果上述2者都没有定义，对象会被看作真：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Truth</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">X = Truth()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(X))</span><br></pre></td></tr></table></figure><p>4、Object Destruction: <code>__del__</code> 对象析构函数</p><ul><li>每当实例空间被收回时，<code>__del__</code>（析构函数方法）会自动执行：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Life</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="string">&#x27;unknown&#x27;</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hello &#x27;</span> + name)</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">live</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Goodbye &#x27;</span> + self.name)</span><br><span class="line"></span><br><span class="line">brian = Life(<span class="string">&#x27;Brian&#x27;</span>)</span><br><span class="line">brian.live()</span><br><span class="line">brian = <span class="string">&#x27;loretta&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>当 brain 被赋值为一个字符串时，我们会失去 Life 实例的最后一个引用并因此触发其析构函数；</li><li>python 在回收实例时，会自动回收该实例拥有的内存空间，所以析构函数并不需要考虑空间管理。</li></ul><h2 id="chapter-31-Designing-with-Classes"><a href="#chapter-31-Designing-with-Classes" class="headerlink" title="chapter 31 Designing with Classes"></a>chapter 31 Designing with Classes</h2><h3 id="一、Python-and-OOP"><a href="#一、Python-and-OOP" class="headerlink" title="一、Python and OOP"></a>一、Python and OOP</h3><p>该章内容是一些常用的 OOP 的设计模式，本书在这一块只是抛砖引玉，大致了解一下就行，按需学习，需要深入了解的时候再去深入了解。  </p><p>大致包括<em>继承</em>、<em>组合</em>、<em>委托</em>和<em>工厂</em>，以及<em>伪私有属性</em>、<em>多重继承</em>和<em>绑定方法</em></p><p>1、OOP and Inheritance</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, salary=<span class="number">0</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.salary = salary</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent</span>):</span><br><span class="line">        self.salary = self.salary + (self.salary * percent)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;does stuff&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;Employee: name=%s, salary=%s&gt;&quot;</span> % (self.name, self.salary)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chef</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        Employee.__init__(self, name, <span class="number">50000</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;makes food&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        Employee.__init__(self, name, <span class="number">40000</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;interfaces with customer&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaRobot</span>(<span class="title class_ inherited__">Chef</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        Chef.__init__(self, name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;makes pizza&quot;</span>)</span><br><span class="line"></span><br><span class="line">bob = PizzaRobot(<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob)</span><br><span class="line">bob.work()</span><br><span class="line">bob.giveRaise(<span class="number">0.20</span>)</span><br><span class="line"><span class="built_in">print</span>(bob)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> klass <span class="keyword">in</span> Employee, Chef, Server, PizzaRobot:</span><br><span class="line">    obj = klass(klass.__name__)</span><br><span class="line">    obj.work()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p>2、OOP and Composition 组合</p><ul><li>组合涉及把其他对象嵌入容器对象内，促使其实现容器方法；</li><li>有些书称组合为聚合 aggregation ：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">order</span>(<span class="params">self, server</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;orders from&quot;</span>, server)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, server</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&quot;pays for item to&quot;</span>, server)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Oven</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bake</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;oven bakes&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaShop</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.server = Server(<span class="string">&#x27;Pat&#x27;</span>)</span><br><span class="line">        self.chef = PizzaRobot(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">        self.oven = Oven()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">order</span>(<span class="params">self, name</span>):</span><br><span class="line">        customer = Customer(name)</span><br><span class="line">        customer.order(self.server)</span><br><span class="line">        self.chef.work()</span><br><span class="line">        self.oven.bake()</span><br><span class="line">        customer.pay(self.server)</span><br><span class="line"></span><br><span class="line">scene = PizzaShop()</span><br><span class="line">scene.order(<span class="string">&#x27;Homer&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">scene.order(<span class="string">&#x27;Shaggy&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><ul><li>以上的 PizzaShop 类就是容器和控制器；</li><li>每份订单都会创建新的 Customer 对象，并把内嵌的 Server 对象传给 Customer 的方法。</li></ul><p>3、OOP and Delegation 委托：包装器代理对象 “Wrapper” Proxy Objects</p><ul><li>委托通常是指控制器对象内嵌其他对象，并把操作请求传递给那些内嵌的对象；</li><li>控制器负责管理类活动，例如记录日志和验证访问，为接口组件添加额外步骤，或监视活跃实例；</li><li>委托是组合的一种特殊形式，它使用包装器（代理）类管理单一的内嵌对象，而包装器类保留了内嵌对象的大多数或全部的接口。</li><li>通常使用 <code>__getattr__</code> 方法钩子来实现委托，来把任意的访问转发给被包装的对象：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">object</span></span>):</span><br><span class="line">        self.wrapped = <span class="built_in">object</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attrname</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Trace: &#x27;</span> + attrname)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, attrname)</span><br></pre></td></tr></table></figure><ul><li><code>__getattr__</code> 方法会获取属性名称的字符串，<code>getattr</code> 内置函数可通过名称字符串获取被包装对象的属性：<code>getattr(X,N)</code> 就是 <code>X.N</code></li><li>这里 Wrapper 类只是在每次属性访问时打印跟踪消息，并把属性请求委托给内嵌的 wrapped 对象：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = Wrapper([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">x.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(x.wrapped)</span><br><span class="line">x = Wrapper(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(x.keys()))</span><br></pre></td></tr></table></figure><ul><li>总的效果就是通过 Wrapper 类内的额外代码来扩充被包装对象的全部接口；</li><li>可以利用这种方法记录方法调用，把方法调用路由到额外或定制的逻辑，使类适应一个新接口。</li></ul><h3 id="二、Pseudoprivate-Class-Attributes"><a href="#二、Pseudoprivate-Class-Attributes" class="headerlink" title="二、Pseudoprivate Class Attributes"></a>二、Pseudoprivate Class Attributes</h3><p>1、类的伪私有属性 Pseudoprivate Class Attributes</p><ul><li>python 支持名称重整 mangling ，使类中的某些名称局部化；</li><li>重整后的名称会被误以为是私有属性，但名称重整并不能阻止来自类外部代码的访问；</li><li>这个功能主要是为了避免实例内的命名空间冲突，而不是限制名称的访问，所以重整后的变量名称为伪私有。</li></ul><p>2、名称重整的工作方式</p><ul><li>只在 class 内部，任意开头双下划线，结尾没双下划线的名称，会自动在前面包含外围类的名称从而进行扩展；</li><li>比如 Spam 类中的 __X 会自动变成 _Spam__X ，这样就不会和其他类中相同的变量名相冲突；</li><li>实例属性引用也需要使用 <code>self._Spam__X</code>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth1</span>(<span class="params">self</span>): self.__X = <span class="number">88</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth2</span>(<span class="params">self</span>): <span class="built_in">print</span>(self.__X)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">metha</span>(<span class="params">self</span>): self.__X = <span class="number">99</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">methb</span>(<span class="params">self</span>): <span class="built_in">print</span>(self.__X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span>(C1, C2): <span class="keyword">pass</span></span><br><span class="line">I = C3()</span><br><span class="line"></span><br><span class="line">I.meth1(); I.metha()</span><br><span class="line"><span class="built_in">print</span>(I.__dict__)</span><br><span class="line">I.meth2(); I.methb()</span><br></pre></td></tr></table></figure><ul><li>这样可避免实例中潜在的名称冲突，如下：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth1</span>(<span class="params">self</span>): self.X = <span class="number">88</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">meth2</span>(<span class="params">self</span>): <span class="built_in">print</span>(self.X)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">metha</span>(<span class="params">self</span>): self.X = <span class="number">99</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">methb</span>(<span class="params">self</span>): <span class="built_in">print</span>(self.X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C3</span>(C1, C2): <span class="keyword">pass</span></span><br><span class="line">I = C3()</span><br><span class="line">I.meth1(); I.metha()</span><br><span class="line"><span class="built_in">print</span>(I.__dict__)</span><br></pre></td></tr></table></figure><h3 id="三、Methods-Are-Objects-Bound-or-Unbound"><a href="#三、Methods-Are-Objects-Bound-or-Unbound" class="headerlink" title="三、Methods Are Objects: Bound or Unbound"></a>三、Methods Are Objects: Bound or Unbound</h3><p>1、类的方法可以通过实例或类来访问<br>①未绑定 Unbound 的类方法对象（无 self ）：直接对类进行点号运算从而获取类的函数属性。<br>②绑定 Bound 的实例方法对象（ self +函数）：对实例进行点号运算从而获取类的函数属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doit</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">object1 = Spam()</span><br><span class="line">x = object1.doit <span class="comment"># Bound method object: instance+function</span></span><br><span class="line">x(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>如果对类进行点号运算来获取 doit ，就会得到未绑定的方法对象；</li><li>要调用该方法，需要传入实例作为最左侧的参数。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = Spam.doit <span class="comment"># Unbound method object</span></span><br><span class="line">object1 = Spam()</span><br><span class="line">t(object1, <span class="string">&#x27;howdy&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>同理可以在类的方法内引用 self 的属性，而该属性指向类中另外的方法：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Eggs</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m1</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m2</span>(<span class="params">self</span>):</span><br><span class="line">        x = self.m1</span><br><span class="line">        x(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">Eggs().m2()</span><br></pre></td></tr></table></figure><p>2、在Python 3.X 中，未绑定方法是函数</p><ul><li>打印一个非实例类的方法的类型，在 python 2.X 显示为未绑定方法，在 python 3.X 显示为函数：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Selfless</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">selfless</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">        <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">normal</span>(<span class="params">self, arg1, arg2</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data + arg1 + arg2</span><br><span class="line"></span><br><span class="line">X = Selfless(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(X.normal(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(Selfless.normal(X, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(Selfless.selfless(<span class="number">3</span>, <span class="number">4</span>)) <span class="comment"># No instance: works in 3.X, fails in 2.X!</span></span><br><span class="line">X.selfless(<span class="number">3</span>, <span class="number">4</span>) <span class="comment"># 会出现TypeError: selfless() takes 2 positional arguments but 3 were given</span></span><br></pre></td></tr></table></figure><p>3、绑定方法和其他可调用对象</p><ul><li>绑定方法可以作为一般对象处理，比如用列表存储绑定方法对象：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, base</span>):</span><br><span class="line">        self.base = base</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">double</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.base * <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.base * <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">x = Number(<span class="number">2</span>)</span><br><span class="line">y = Number(<span class="number">3</span>)</span><br><span class="line">z = Number(<span class="number">4</span>)</span><br><span class="line">acts = [x.double, y.double, y.triple, z.double]</span><br><span class="line"><span class="keyword">for</span> act <span class="keyword">in</span> acts:</span><br><span class="line">    <span class="built_in">print</span>(act())</span><br></pre></td></tr></table></figure><ul><li>绑定函数对象也有自己的内省信息，包括一些属性能够让其访问配对的实例对象和方法函数：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bound = x.double</span><br><span class="line"><span class="built_in">print</span>(bound.__self__, bound.__func__)</span><br><span class="line"><span class="built_in">print</span>(bound.__self__.base)</span><br></pre></td></tr></table></figure><p>4、绑定方法只是可调用对象的一种，以下都可以用类似方式处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="keyword">return</span> arg ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sum</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.val + arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.val * arg</span><br><span class="line"></span><br><span class="line">sobject = Sum(<span class="number">2</span>)</span><br><span class="line">pobject = Product(<span class="number">3</span>)</span><br><span class="line">actions = [square, sobject, pobject.method]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> act <span class="keyword">in</span> actions:</span><br><span class="line">    <span class="built_in">print</span>(act(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(actions[-<span class="number">1</span>](<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>([act(<span class="number">5</span>) <span class="keyword">for</span> act <span class="keyword">in</span> actions])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> act: act(<span class="number">5</span>), actions)))</span><br></pre></td></tr></table></figure><h3 id="四、Classes-Are-Objects-Generic-Object-Factories"><a href="#四、Classes-Are-Objects-Generic-Object-Factories" class="headerlink" title="四、Classes Are Objects: Generic Object Factories"></a>四、Classes Are Objects: Generic Object Factories</h3><p>1、The factory design pattern</p><ul><li>工厂：将任意可调用对象，比如类，传递给生成其他种类对象的函数。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factory</span>(<span class="params">aClass, *pargs, **kargs</span>):</span><br><span class="line">    <span class="keyword">return</span> aClass(*pargs, **kargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doit</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, job=<span class="literal">None</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line"></span><br><span class="line">object1 = factory(Spam)</span><br><span class="line">object2 = factory(Person, <span class="string">&quot;Arthur&quot;</span>, <span class="string">&quot;King&quot;</span>)</span><br><span class="line">object3 = factory(Person, name=<span class="string">&#x27;Brian&#x27;</span>)</span><br><span class="line"></span><br><span class="line">object1.doit(<span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(object2.name, object2.job)</span><br><span class="line"><span class="built_in">print</span>(object3.name, object3.job)</span><br></pre></td></tr></table></figure><ul><li>工厂允许代码与动态配置的对象构造细节相隔绝。</li></ul><h3 id="五、Multiple-Inheritance-“Mix-in”-Classes"><a href="#五、Multiple-Inheritance-“Mix-in”-Classes" class="headerlink" title="五、Multiple Inheritance: “Mix-in” Classes"></a>五、Multiple Inheritance: “Mix-in” Classes</h3><p>1、多继承的缺点就是当相同的方法名称在不止一个父类中定义时，就会造成冲突</p><ul><li>搜索属性时，python 会从左到右遍历搜索类首行的父类<ul><li>在经典类 classic classes 中，所有情形下的属性搜索始终实行<strong>深度优先 depth-first</strong> 搜索，直到继承树的顶端，然后从左至右进行，这顺序称为 <strong>DFLR（depth-first, left-to-right path）</strong></li><li>在新式类 new-style classes 中，属性搜索通常是一样的，但在<strong>钻石模式 diamond patterns</strong> 下以<strong>广度优先</strong>方式进行，搜索向上移动之前沿着继承树的同一级搜索，这顺序称为新式 <strong>MRO（method resolution order）</strong></li></ul></li><li>当继承树中的多个类共享一个共同父类时，钻石模式就会出现；</li><li>新式搜索顺序旨在访问完全部子类后，仅访问一次这样的共享父类；</li><li>当冲突产生时，而不愿意使用继承的第一个名称时，会是个问题，详见下一章的新式类、MRO和新式工具。</li></ul><p>2、编写 mix-in 类</p><ul><li>多继承的最常见方法就是 to “mix in” general-purpose methods from superclasses</li><li>就是编写一个通用的类，然后通过多继承去使用它，跟模块作用类似；</li><li>下面的代码定义了一个名为 ListInstance 的 mix-in 类，它为继承了它的所有类都重载了 <code>__str__</code> 方法：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListInstance</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__attrnames</span>(<span class="params">self</span>):</span><br><span class="line">        result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> attr <span class="keyword">in</span> <span class="built_in">sorted</span>(self.__dict__):</span><br><span class="line">            result += <span class="string">&#x27;\t%s=%s\n&#x27;</span> % (attr, self.__dict__[attr])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;Instance of %s, address %s:\n%s&gt;&#x27;</span> % (</span><br><span class="line">            self.__class__.__name__,</span><br><span class="line">            <span class="built_in">id</span>(self),</span><br><span class="line">            self.__attrnames())</span><br></pre></td></tr></table></figure><ul><li>每个实例都有一个内置的 <code>__class__</code> 属性，引用创建本实例的类；每个类都有一个 <code>__name__</code> 属性，引用类头部的名称；</li><li>id 内置函数显示实例的内存地址。</li></ul><p>3、单继承模型下，混合上述的类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>(<span class="title class_ inherited__">ListInstance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.data1 = <span class="string">&#x27;food&#x27;</span></span><br><span class="line"></span><br><span class="line">x = Spam()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p>4、多继承：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Super</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.data1 = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ham</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(Super, ListInstance):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Super.__init__(self)</span><br><span class="line">        self.data2 = <span class="string">&#x27;eggs&#x27;</span></span><br><span class="line">        self.data3 = <span class="number">42</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">X = Sub()</span><br><span class="line"><span class="built_in">print</span>(X)</span><br></pre></td></tr></table></figure><h2 id="chapter-32-Advanced-Class-Topics"><a href="#chapter-32-Advanced-Class-Topics" class="headerlink" title="chapter 32 Advanced Class Topics"></a>chapter 32 Advanced Class Topics</h2><h3 id="一、Extending-Built-in-Types"><a href="#一、Extending-Built-in-Types" class="headerlink" title="一、Extending Built-in Types"></a>一、Extending Built-in Types</h3><p>1、内嵌方式扩展类型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value = []</span>):</span><br><span class="line">        self.data = []</span><br><span class="line">        self.concat(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersect</span>(<span class="params">self, other</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.data:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> other:</span><br><span class="line">                res.append(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Set</span>(res)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, other</span>):</span><br><span class="line">        res = self.data[:]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> other:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">in</span> res:</span><br><span class="line">                res.append(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Set</span>(res)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> value:               <span class="comment"># Removes duplicates</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">in</span> self.data:</span><br><span class="line">                self.data.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>): <span class="keyword">return</span> self.data[key] </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__and__</span>(<span class="params">self, other</span>): <span class="keyword">return</span> self.intersect(other)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__or__</span>(<span class="params">self, other</span>): <span class="keyword">return</span> self.union(other)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="string">&#x27;Set:&#x27;</span> + <span class="built_in">repr</span>(self.data)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="built_in">iter</span>(self.data) <span class="comment"># 生成迭代操作</span></span><br></pre></td></tr></table></figure><ul><li>通过索引和迭代操作，能让上述定义的 Set 类充当真正的列表：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="type">Set</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>(x.union(<span class="type">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>])))</span><br><span class="line"><span class="built_in">print</span>(x | <span class="type">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>]))</span><br></pre></td></tr></table></figure><p>2、通过子类扩展类型</p><ul><li>在 python 中， list ,  str ,  dict , 和 tuple 这样的类型转换函数实际上是调用了类型的对象构造函数；</li><li>因此可以通过建立类型名称的子类来定制或扩展内置类型的行为，比如把列表的偏移量从1开始算起而不是0：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, offset</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;(indexing %s at %s)&#x27;</span> % (self, offset))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>.__getitem__(self, offset - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="string">&#x27;abc&#x27;</span>))</span><br><span class="line">x = MyList(<span class="string">&#x27;abc&#x27;</span>)  <span class="comment"># __init__ inherited from list</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># __repr__ inherited from list</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">x.append(<span class="string">&#x27;spam&#x27;</span>); <span class="built_in">print</span>(x) <span class="comment"># # Attributes from list superclass</span></span><br><span class="line">x.reverse(); <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><ul><li>上述的编码方式可以提供编写第一个例子的 Set 的另一种方式，即作为内置 list 的子类：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value = []</span>):</span><br><span class="line">        <span class="built_in">list</span>.__init__([]) <span class="comment"># 继承父类</span></span><br><span class="line">        self.concat(value)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersect</span>(<span class="params">self, other</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> other:</span><br><span class="line">                res.append(x)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Set</span>(res)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, other</span>):</span><br><span class="line">        res = <span class="type">Set</span>(self)</span><br><span class="line">        res.concat(other)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">concat</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> value:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">in</span> self:</span><br><span class="line">                self.append(x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__and__</span>(<span class="params">self, other</span>): <span class="keyword">return</span> self.intersect(other)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__or__</span>(<span class="params">self, other</span>): <span class="keyword">return</span> self.union(other)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>): <span class="keyword">return</span> <span class="string">&#x27;Set:&#x27;</span> + <span class="built_in">list</span>.__repr__(self)</span><br><span class="line"></span><br><span class="line">x = <span class="type">Set</span>([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>])</span><br><span class="line">y = <span class="type">Set</span>([<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(x, y, <span class="built_in">len</span>(x))</span><br><span class="line"><span class="built_in">print</span>(x.intersect(y), y.union(x))</span><br><span class="line"><span class="built_in">print</span>(x &amp; y, x | y)</span><br><span class="line">x.reverse(); <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><h3 id="二、The-“New-Style”-Class-Model"><a href="#二、The-“New-Style”-Class-Model" class="headerlink" title="二、The “New Style” Class Model"></a>二、The “New Style” Class Model</h3><p>1、介绍</p><ul><li>本书之前谈到的类和新式类相比，称为经典类，但在 python 3.X 中类的区分已经融合了；</li><li>在 python 3.X 中，所有的类都是所谓的新式类，不管是否显式地继承自 object ；</li><li>所有的类都继承自 object ，不管是显式的还是隐式的，所有的类都隐含是 object 的子类；</li><li>所以在 python 3.X 中新式类的功能成为了常规的类功能。</li><li>新式类要么从内置类型（如list）派生，要么从一个叫做 object 的特殊内置类派生。</li></ul><p>2、新式类的变化</p><ul><li>①针对内置属性的获取：跳过实例<ul><li><code>__getattr__</code> 和 <code>__getattribute__</code> 通用属性拦截方法仍然通过显式名称访问属性，但不再适用于那些被内置运算隐式获取的属性。</li></ul></li><li>②类和类型的合并：类型检验<ul><li><strong>类就是类型，类型就是类</strong>； <code>type(instance)</code> 内置函数返回一个实例对应的类，与 <code>instance.__class__</code> 是相同的。</li></ul></li><li>③ object 自动根类：默认情况<ul><li>所有的新式类继承自 object 类。该类在 3.X 中被自动添加为用户定义类继承树的根（最顶级夫）类，并且不需要被显式地指定为父类。</li></ul></li><li>④继承搜索顺序：MRO与钻石模式<ul><li>多继承的钻石模式的搜索顺序更像广度优先搜索，先横向搜索再纵向搜索。这种属性搜索顺序称为 <strong>MRO</strong> ，可以用新式类中的 <code>__mro__</code> 属性来跟踪。</li></ul></li><li>⑤继承算法：第40章<ul><li>新式类所使用的继承算法比经典类的深度优先模式更加复杂，包括了描述符、元类和内置函数的特殊情况。</li></ul></li><li>⑥新的高级工具：代码的影响</li><li>新式类有一组新的类工具，包括 <strong>slot</strong> 、 <strong>property</strong> 、<strong>描述符</strong>、 <strong>super</strong> 和 <code>__getattribute__</code> 方法</li></ul><p>3、内置属性的获取将跳过实例</p><ul><li>即在新式类中，通用实例属性拦截方法 <code>__getattr__</code> 和 <code>__getattribute__</code> 不能再拦截下以 <code>__X__</code> 命名的运算符重载方法名的调用；</li><li>也就是说对 <code>__X__</code> 这一类名称的搜索是从类开始，而非从实例开始；</li><li>为什么引入搜索改变：它反映了一个由元类模型引入的难题。类现在是元类 metaclass 的实例，又因为元类可以定义内置运算符方法来处理它们生成的类；</li><li>所以在类上运行的方法调用必须跳过类本身，并在更高层次选择处理该类的方法，而不是选取类本身的版本；</li><li>类本身的版本可能会导致非绑定方法调用，因为类自身方法会处理低一层次的实例；</li><li>结果是类本身即是类型又是实例，因此实例在内置运算方法搜索的时候都被跳过了；</li><li>但非内置名称和内置名称的直接显式调用仍旧会检测实例：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>): <span class="keyword">pass</span> <span class="comment"># object可有可无</span></span><br><span class="line">X = C()</span><br><span class="line"></span><br><span class="line">X.normal = <span class="keyword">lambda</span>: <span class="number">99</span> <span class="comment"># 在方法外修改实例属性</span></span><br><span class="line"><span class="built_in">print</span>(X.normal())</span><br><span class="line"></span><br><span class="line">X.__add__ = <span class="keyword">lambda</span> y: y + <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(X.__add__(<span class="number">1</span>)) <span class="comment"># 内置方法的显式调用</span></span><br></pre></td></tr></table></figure><ul><li><code>print(X + 1)</code> # 3.X 会出现 TypeError ，因为不会搜索实例的内置方法，在 2.X 得到结果89</li></ul><p>4、类型模型改变</p><ul><li><strong>类即类型</strong> Classes are types；Types are classes</li><li>类是由元类生成，元类要么是 type 自身，要么是由 type 定制来扩展或管理生成的类的一个子类；</li><li>内置的类型（比如列表、字符串）和用户定义的编写为类的类型之间没有真正的区别；</li><li>可以编写元类：使用 class 语句编写的用户定义 type 子类，控制作为它们的实例的类的创建：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">I = C()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(I), I.__class__) <span class="comment"># 在2.X中，类实例的类型是instance，&lt;type &#x27;instance&#x27;&gt;, I.__class__结果一样</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(C), C.__class__) <span class="comment"># 在2.X中，type(C)结果为&lt;type &#x27;classobj&#x27;&gt;，而C.__class__会出错，class C has no attribute &#x27;__class__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].__class__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">list</span>), <span class="built_in">list</span>.__class__)</span><br></pre></td></tr></table></figure><ul><li>元类，详见第40章：</li></ul><blockquote><p>① object 类是所有新式类的父类；<br>② type 是所有类的类；<br>③ object 类是由元类 type 创建的，但是 type 类又继承了 object 类， type 元类的类则是由 type 元类自身创建的；<br>④所以任何元素都是对象（都是 type 的实例对象），一切都继承 object ，一切皆对象。</p></blockquote><p>5、所有对象派生自 “object”</p><ul><li>所有的类都隐式或显式地继承自 object 类，并且由于所有的类型都是类，所以每个对象都派生自 object 内置类；</li><li>一个类实例的类型就是产生它的类，一个类的类型就是 type 类；</li><li>实例和类都继承自内置的 object 类：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(X, <span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(C, <span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(C.__bases__)</span><br></pre></td></tr></table></figure><ul><li>内置类型 built-in types 也是如此，内置类型也是类，它们的实例继承自 object ：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">str</span>, <span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.__bases__)</span><br></pre></td></tr></table></figure><ul><li>实际上， type 自身继承自 object ，而且 object 继承自 type ，即使二者是不同对象：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">type</span>, <span class="built_in">object</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="built_in">object</span>, <span class="built_in">type</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span> <span class="keyword">is</span> <span class="built_in">object</span>)</span><br></pre></td></tr></table></figure><p>6、钻石继承改变</p><ul><li>钻石模式指：有多于一个的父类指向同个更高级父类的树状模式（长得像钻石）；</li><li>① DFLR 搜索顺序：经典类<ul><li>深度优先 depth first ，然后从左到右 left to right （首字母：DFLR）：python 一路向上搜索，深入树的左侧，返回后才开始找右侧</li></ul></li><li>② MRO 搜索顺序：新式类<ul><li>广度优先 breadth-first ，先搜索当前父类右侧的所有其他父类，再一路往上至顶端( MRO:method resolution order )</li></ul></li><li>新式的 MRO 允许较底层的父类覆盖高层父类的属性：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>): attr = <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>): attr = <span class="number">2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">x = D()</span><br><span class="line"><span class="built_in">print</span>(x.attr) <span class="comment"># 在2.X中，结果为1，完整的DFLR搜索顺序为x、D, B, A, C, A</span></span><br><span class="line"><span class="comment"># 而完整的MRO搜索顺序为x、D、B、C、A</span></span><br></pre></td></tr></table></figure><ul><li>可以显式得解决冲突：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): attr = B.attr</span><br><span class="line">x = D()</span><br><span class="line"><span class="built_in">print</span>(x.attr)</span><br></pre></td></tr></table></figure><ul><li>object 父类为各种内置运算提供了默认方法，在没有 MRO 的搜索模式下，多继承中 object 的默认方法总是覆盖用户编写的类中的定制代码。</li></ul><p>7、 <code>__mro__</code> 方法</p><ul><li><code>class.__mro__</code> 方法可以跟踪新式类的默认继承方式，将返回类的 MRO 顺序；</li><li>一个给定类的 MRO 列表包括了类本身，它的父类，以及直到继承树顶端 object 的所有高级父类；</li><li>在这个列表中，每个类出现在它的父类之前，而且多个父类保持了它们在 <code>__bases__</code> 父类元组中出现的顺序</li><li>super 函数调用可以使用 MRO 列表中的下一个类，而这个类不一定是一个父类。</li><li>注意 MRO 顺序只适用于钻石继承模式，如下：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(D.__mro__)</span><br></pre></td></tr></table></figure><ul><li>对于非钻石继承模式，还是 DFLR ，如下：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(D.__mro__)</span><br></pre></td></tr></table></figure><ul><li><code>class.mro()</code> 方法在每次类进行实例化时被调用，返回值是一个列表：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(D.mro() == <span class="built_in">list</span>(D.__mro__))</span><br></pre></td></tr></table></figure><h3 id="三、New-Style-Class-Extensions-Slots"><a href="#三、New-Style-Class-Extensions-Slots" class="headerlink" title="三、New-Style Class Extensions - Slots"></a>三、New-Style Class Extensions - Slots</h3><p>1、Slots : 属性声明</p><ul><li>通过将一系列的字符串属性名称赋值给特殊的 <code>__slots__</code> 类属性，可以让新式类限制实例会得到的属性集，又能优化内存和速度性能</li></ul><p>2、slot 基础</p><ul><li>只有 <code>__slots__</code> 列表内的名称可赋值为实例属性：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">limiter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;job&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x = limiter()</span><br><span class="line">x.age = <span class="number">40</span></span><br><span class="line">x.spam = <span class="number">40</span> <span class="comment"># 会出现错误：AttributeError: &#x27;limiter&#x27; object has no attribute &#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(x.age)</span><br></pre></td></tr></table></figure><ul><li>slots 最好只在有大量实例出现的、内存密集型应用的情况下使用。</li></ul><p>3、slot 与命名空间字典</p><ul><li>slot 会使类模型复杂化；</li><li>有些带有 slot 的实例会没有 <code>__dict__</code> 属性命名空间字典（替换命名空间字典存储），有些可能会拥有这个字典不包含的数据属性（共存）；</li><li>这是新式类模型和传统类模型的不兼容性，导致通用访问属性的代码复杂化，甚至让程序失败：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line">X.a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(X.a)</span><br><span class="line"><span class="built_in">print</span>(X.__dict__) <span class="comment"># 会出现错误：AttributeError: &#x27;C&#x27; object has no attribute &#x27;__dict__&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>仍然可以使用 getattr 、 setattr （不仅查找 <code>__dict__</code> ，也会查找例如 slot 的类一级名称）和 dir（会收集整个类树上所有被继承的名称）；</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(X, <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="built_in">setattr</span>(X, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(X.b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(X))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(X))</span><br></pre></td></tr></table></figure><ul><li>如果没有一个属性命名空间字典，不能给不在 slot 列表中的实例赋值新的名称：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.d = <span class="number">4</span> <span class="comment"># 无法赋值，创建实例后会出错</span></span><br><span class="line"></span><br><span class="line">X = D() <span class="comment"># 会出现错误：AttributeError: &#x27;D&#x27; object has no attribute &#x27;d&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>可以在 <code>__slots__</code> 中显式包含 <code>__dict__</code> 来创建一个属性命名空间字典：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line">    c = <span class="number">3</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.d = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">X = D()</span><br><span class="line"><span class="built_in">print</span>(X.d)</span><br><span class="line"><span class="built_in">print</span>(X.c)</span><br><span class="line">X.a = <span class="number">1</span></span><br><span class="line">X.b = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br><span class="line"><span class="built_in">print</span>(X.__slots__)</span><br></pre></td></tr></table></figure><p>4、父类中的多个 <code>__slots__</code> 列表</p><ul><li>slot 列表可能会不止一次出现在类树；</li><li>因为 slot 名称是类的一级属性（ class-level attributes ），实例按一般继承规则，获得了类树中其他位置的所有 slot 名称的并集：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">E</span>):</span><br><span class="line">    __slots__ = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X = D()</span><br><span class="line">X.a = <span class="number">1</span>; X.b = <span class="number">2</span>; X.c = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(X.a, X.c)</span><br></pre></td></tr></table></figure><ul><li>如果只检测被直接继承的 slot 列表，则不能获取在类树的更高层次定义的 slot ：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(E.__slots__)</span><br><span class="line"><span class="built_in">print</span>(D.__slots__)</span><br><span class="line"><span class="built_in">print</span>(X.__slots__)</span><br><span class="line"><span class="built_in">print</span>(X.__dict__)</span><br></pre></td></tr></table></figure><ul><li>但是 dir 包含所有的 slot ：<code>print(dir(X))</code></li></ul><p>5、slot 使用规则</p><ul><li>slot 声明可以出现在一个类树中的多个类<ul><li>若父类没有 slot ，子类的 slot 就没有意义：如果子类继承自一个没有 <code>__slots__</code> 的父类，为父类创建的 <code>__dict__</code> 实例属性将总是可访问的。而避免 <code>__dict__</code> 是使用 slot 的主要原因；</li><li>如果子类没有 slot ，父类的 slot 也没有意义：同上</li><li>重新定义让父类的 slot 变得没有意义：如果一个类定义了父类中相同的 slot 名称，它的重新定义会根据一般继承规则隐藏父类中的 slot 。需要从父类获取描述符来访问父类的 slot ；</li><li>slot 会阻止类一级的默认名称：slot 被实现成类一级的描述符，不能在类一级中对同名类属性进行赋值。</li></ul></li></ul><h3 id="四、New-Style-Class-Extensions-Properties"><a href="#四、New-Style-Class-Extensions-Properties" class="headerlink" title="四、New-Style Class Extensions - Properties"></a>四、New-Style Class Extensions - Properties</h3><p>1、property ：属性访问器</p><ul><li>property 能自动调用（动态地）方法来访问或者赋值实例属性。功能与 Java 和 C# 语言的属性类似，但在 python 最好少用；</li><li>property 和 slot 都属于类一级描述符 class-level attribute descriptors ，见第38章。</li></ul><p>2、property 基础</p><ul><li>property 是一种被赋值给类属性名称的对象；</li><li>产生 property 的方式：调用内置函数 property ，同时传入三个访问器方法（分别用于处理获取、设置和删除操作），以及一个可选的 property 文档字符串；</li><li>如果任一参数以 None 传入，特性就不能支持对应操作；</li><li>最终得到的 property 对象，一般是在 class 顶层赋值给名称（ <code>name = property()</code> ），以及后面会说的“@”来自动化这一个步骤：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">properties</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getage</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">40</span></span><br><span class="line">    age = <span class="built_in">property</span>(getage, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>) <span class="comment"># (get, set, del, docs), or use @</span></span><br><span class="line"></span><br><span class="line">x = properties()</span><br><span class="line"><span class="built_in">print</span>(x.age) <span class="comment"># 对property名称的访问，会被自动路由到property调用的一个访问器方法</span></span><br></pre></td></tr></table></figure><ul><li>新增对属性赋值运算的支持：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">properties</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getage</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">40</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setage</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;set age: %s&#x27;</span> % value)</span><br><span class="line">        self._age = value</span><br><span class="line">    age = <span class="built_in">property</span>(getage, setage, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">x = properties()</span><br><span class="line"><span class="built_in">print</span>(x.age)</span><br><span class="line">x.age = <span class="number">42</span></span><br><span class="line"><span class="built_in">print</span>(x._age)</span><br><span class="line"><span class="built_in">print</span>(x.age)</span><br><span class="line">x.job = <span class="string">&#x27;trainer&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(x.job)</span><br></pre></td></tr></table></figure><ul><li>用函数装饰器 function decorator 来编写 property 见第38章；</li><li><code>__getattribute__</code> and Descriptors 描述符也是类扩展，见第38章。</li></ul><h3 id="五、Static-and-Class-Methods"><a href="#五、Static-and-Class-Methods" class="headerlink" title="五、Static and Class Methods"></a>五、Static and Class Methods</h3><p>1、静态方法和类方法介绍</p><ul><li>静态方法大致与类中简单无实例函数的工作方法类似，而类方法被传入一个类而不是一个实例；</li><li>要使用这些方法，要在类中调用特殊的内置函数：<code>staticmethod</code> 和 <code>classmethod</code> ，或使用 <code>“@name”</code> 装饰语法；</li><li>在 python 3.X 中，无实例的方法只通过一个类名调用，而不需要一个 <code>staticmethod</code> 申明，但要实例来调用，仍然需要。</li></ul><p>①静态方法：嵌套在类中的没有 self 参数的简单函数；<br>②类方法：传入方法的第一个参数不是实例对象，而是类对象；<br>③实例方法：即常规方法，需要接受实例。</p><p>2、Python 2.X 和 3.X 中的静态方法<br>①在 Python 2.X 和 3.X 中，当一个方法通过实例被获取的时候，会产生一个绑定方法；<br>②在 Python 2.X 中，从一个类中获取一个方法会产生一个非绑定方法，如果不手动地传入一个实例就不能调用这个方法；<br>③在 Python 3.X 中，从一个类中获取一个方法会产生一个简单函数，该函数在没有传入一个实例的时候也可以正常被调用；<br>④在 Python 2.X 中，必须总是把一个方法声明为静态的，才能不传入实例来调用它，不管是通过类还是实例调用；<br>⑤在 Python 3.X 中，如果一个方法只通过一个类调用，不需要声明为静态的。但是要通过实例来调用，必须声明为静态的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>: <span class="comment"># 类实例计数器</span></span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.numInstances = Spam.numInstances + <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Number of instances created: %s&quot;</span> % Spam.numInstances)</span><br><span class="line"></span><br><span class="line">a = Spam()</span><br><span class="line">b = Spam()</span><br><span class="line">c = Spam()</span><br><span class="line"></span><br><span class="line">Spam.printNumInstances()</span><br><span class="line">a.printNumInstances() <span class="comment"># 会出现错误：TypeError: Spam.printNumInstances() takes 0 positional arguments but 1 was given</span></span><br></pre></td></tr></table></figure><ul><li>以下为上述例子的常规方法：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.numInstances = Spam.numInstances + <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Number of instances created: %s&quot;</span> % Spam.numInstances)</span><br><span class="line"></span><br><span class="line">a, b, c = Spam(), Spam(), Spam()</span><br><span class="line">a.printNumInstances()</span><br><span class="line">Spam.printNumInstances(a)</span><br><span class="line">Spam().printNumInstances()</span><br></pre></td></tr></table></figure><p>3、内置函数 <code>staticmethod</code> 和 <code>classmethod</code></p><ul><li>静态方法不需要实例，类方法需要一个类参数：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Methods</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">imeth</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="built_in">print</span>([self, x])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smeth</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">print</span>([x])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cmeth</span>(<span class="params">cls, x</span>):</span><br><span class="line">        <span class="built_in">print</span>([cls, x])</span><br><span class="line">    </span><br><span class="line">    smeth = <span class="built_in">staticmethod</span>(smeth)</span><br><span class="line">    cmeth = <span class="built_in">classmethod</span>(cmeth)</span><br><span class="line"><span class="comment"># 常规实例方法</span></span><br><span class="line">obj = Methods()</span><br><span class="line">obj.imeth(<span class="number">1</span>)</span><br><span class="line">Methods.imeth(obj, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 静态方法</span></span><br><span class="line">Methods.smeth(<span class="number">3</span>)</span><br><span class="line">obj.smeth(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 类方法：python自动将类传入类方法的第一位，不管是类调用还是实例调用</span></span><br><span class="line">Methods.cmeth(<span class="number">5</span>)</span><br><span class="line">obj.cmeth(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>4、子类继承并定制静态方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.numInstances += <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Number of instances: %s&quot;</span> % Spam.numInstances)</span><br><span class="line">    printNumInstances = <span class="built_in">staticmethod</span>(printNumInstances)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Spam</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Extra stuff...&quot;</span>)</span><br><span class="line">        Spam.printNumInstances()</span><br><span class="line">    printNumInstances = <span class="built_in">staticmethod</span>(printNumInstances)</span><br><span class="line"></span><br><span class="line">a = Sub()</span><br><span class="line">b = Sub()</span><br><span class="line">a.printNumInstances()</span><br><span class="line">Sub.printNumInstances()</span><br><span class="line">Spam.printNumInstances() <span class="comment"># 调用父类的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>(<span class="title class_ inherited__">Spam</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">c = Other()</span><br><span class="line">c.printNumInstances() <span class="comment"># 这里会打印出3，是因为子类都是继承了父类的构造方法</span></span><br></pre></td></tr></table></figure><p>5、继承类方法</p><ul><li>类方法接受的是调用主体的最直接的类：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.numInstances += <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Number of instances: %s %s&quot;</span> % (cls.numInstances, cls))</span><br><span class="line">    printNumInstances = <span class="built_in">classmethod</span>(printNumInstances)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Spam</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Extra stuff...&quot;</span>, cls)</span><br><span class="line">        Spam.printNumInstances()</span><br><span class="line">    printNumInstances = <span class="built_in">classmethod</span>(printNumInstances)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>(<span class="title class_ inherited__">Spam</span>): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">x = Sub()</span><br><span class="line">y = Spam()</span><br><span class="line">x.printNumInstances() <span class="comment"># 子类的实例调用类方法，传入了sub，又由于Sub显式调用了Spam父类，故父类方法接受了父类自己</span></span><br><span class="line">Sub.printNumInstances()</span><br><span class="line">y.printNumInstances()</span><br><span class="line"></span><br><span class="line">z = Other()</span><br><span class="line">z.printNumInstances()</span><br></pre></td></tr></table></figure><p>6、由于类总是接受实例树中最底层（lowest）的类</p><ul><li>因此更适合处理同一类树中的各个类之间相互区别的数据，比如为每个类管理实例计数器：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">cls</span>):</span><br><span class="line">        cls.numInstances += <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.count()</span><br><span class="line">    count = <span class="built_in">classmethod</span>(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Spam</span>):</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.__init__(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>(<span class="title class_ inherited__">Spam</span>):</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">x = Spam()</span><br><span class="line">y1, y2 = Sub(), Sub()</span><br><span class="line">z1, z2, z3 = Other(), Other(), Other()</span><br><span class="line"><span class="built_in">print</span>(x.numInstances, y1.numInstances, z1.numInstances)</span><br><span class="line"><span class="built_in">print</span>(Spam.numInstances, Sub.numInstances, Other.numInstances)</span><br></pre></td></tr></table></figure><h3 id="六、Decorators-and-Metaclasses-Part-1"><a href="#六、Decorators-and-Metaclasses-Part-1" class="headerlink" title="六、Decorators and Metaclasses: Part 1"></a>六、Decorators and Metaclasses: Part 1</h3><p>1、装饰器介绍<br>①<strong>函数装饰器 Function decorators</strong>：同时为简单函数和类方法指明了特殊运算模式，通过把简单函数和类方法包在一层额外的逻辑实现中，也称为元函数 metafunction；<br>②<strong>类装饰器Class decorators</strong>：为类添加管理全体对象和其接口的支持。  </p><p>python 提供一些内置的函数装饰器，程序员也可以自己编写定制装饰器，装饰器不是严格地被要求写成类，但是通常被编写成类</p><p>2、函数装饰器基础</p><ul><li>函数装饰器可以看作是它跟在后面的函数的运行时声明；</li><li>它包含 <strong>“@”</strong> 符号，和跟着后面的元函数 metafunction（管理另一函数的函数）：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.numInstances = Spam.numInstances + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod </span><span class="comment"># 跟写在后面的printNumInstances = staticmethod(printNumInstances)一样</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printNumInstances</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Number of instances created: %s&quot;</span> % Spam.numInstances)</span><br><span class="line"></span><br><span class="line">a = Spam()</span><br><span class="line">b = Spam()</span><br><span class="line">c = Spam()</span><br><span class="line">Spam.printNumInstances()</span><br><span class="line">a.printNumInstances()</span><br></pre></td></tr></table></figure><ul><li>因为 <code>classmethod</code> 和 <code>property</code> 内置函数也接受和返回函数，也能用作装饰器：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Methods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">imeth</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="built_in">print</span>([self, x])</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smeth</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">print</span>([x])</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cmeth</span>(<span class="params">cls, x</span>):</span><br><span class="line">        <span class="built_in">print</span>([cls, x])</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Bob &#x27;</span> + self.__class__.__name__</span><br><span class="line"></span><br><span class="line">obj = Methods()</span><br><span class="line">obj.imeth(<span class="number">1</span>)</span><br><span class="line">obj.smeth(<span class="number">2</span>)</span><br><span class="line">obj.cmeth(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br></pre></td></tr></table></figure><p>3、用户定义函数装饰器</p><ul><li>下面的代码在实例中存储被装饰的函数，并捕获对原来函数名的调用：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.calls = <span class="number">0</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        self.calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s to %s&#x27;</span> % (self.calls, self.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tracer </span><span class="comment"># Same as spam = tracer(spam)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spam</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(spam(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>))</span><br></pre></td></tr></table></figure><p>4、类装饰器和元类</p><ul><li>同理，在类前面的装饰器 <code>@decorator</code> 等同于在 class 语句后面的 <code>Class = decorator(Class)</code>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">aClass</span>):</span><br><span class="line">    aClass.numInstances = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> aClass</span><br><span class="line"></span><br><span class="line"><span class="meta">@count</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.numInstances += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@count</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span>(<span class="title class_ inherited__">Spam</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Spam.__init__(self)</span><br><span class="line">        Sub.numInstances += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a = Spam()</span><br><span class="line">b = Sub()</span><br><span class="line"><span class="built_in">print</span>(a.numInstances, Spam.numInstances)</span><br><span class="line"><span class="built_in">print</span>(b.numInstances, Sub.numInstances)</span><br></pre></td></tr></table></figure><ul><li>类装饰器也可以通过拦截构造函数，并将实例对象包在一个代理中，管理实例的全部接口；</li><li>详见第39章，下面是模型的预习：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Proxy</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args</span>):</span><br><span class="line">            self.wrapped = cls(*args)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(self.wrapped, name)</span><br><span class="line">    <span class="keyword">return</span> Proxy</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: ...</span><br><span class="line">X = C()</span><br></pre></td></tr></table></figure><ul><li>元类能把一个类对象的创建路由到顶级 type 类的一个子类，见第40章。</li></ul><h3 id="七、The-super-Built-in-Function"><a href="#七、The-super-Built-in-Function" class="headerlink" title="七、The super Built-in Function"></a>七、The super Built-in Function</h3><p>1、传统的父类调用形式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">C</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>):</span><br><span class="line">        C.act(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = D()</span><br><span class="line">X.act()</span><br></pre></td></tr></table></figure><p>2、super 的基础用法</p><ul><li>super 通过检测调用栈来自动定位 self 参数和寻找父类，并且将 self 参数和父类配对在一个特殊的代理对象中，从而将之后的调用路由到父类方法；</li><li>但 super 函数后面的没有 self ：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">C</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().act()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = D()</span><br><span class="line">X.act()</span><br></pre></td></tr></table></figure><p>3、局限性：多继承</p><ul><li>super 函数是钻石多继承树中的协同多继承分发协议，依赖于 MRO 算法；</li><li>钻石多继承树中的协同多继承分发协议：cooperative multiple inheritance dispatch protocols in diamond multiple-inheritance trees。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().act()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, A):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">act</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().act()</span><br><span class="line"></span><br><span class="line">X = C()</span><br><span class="line">X.act() <span class="comment"># super根据MRO顺序，找到最左边的带有该方法的类</span></span><br><span class="line">Y = D()</span><br><span class="line">Y.act() <span class="comment"># 同理</span></span><br></pre></td></tr></table></figure><ul><li>在多继承中，能用传统继承就用传统继承，因为 super 只能继承一个。</li></ul><p>4、super的优势：继承树的修改与分发<br>①在运行时改变父类：可以通过super来分发调用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;X.m&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;Y.m&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">X</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m</span>(<span class="params">self</span>): <span class="built_in">super</span>().m()</span><br><span class="line"></span><br><span class="line">i = C()</span><br><span class="line">i.m()</span><br><span class="line">C.__bases__ = (Y,)</span><br><span class="line">i.m()</span><br></pre></td></tr></table></figure><p>②协同多继承方法的分发：当多继承树对多个类的同名函数进行分发时，super 提供一种顺序调用路由的协议；</p><ul><li>钻石类树模型下：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;A.__init__&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;B.__init__&#x27;</span>); A.__init__(self)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;C.__init__&#x27;</span>); A.__init__(self)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">x = D() <span class="comment"># 运行B</span></span><br></pre></td></tr></table></figure><ul><li>相比之下，如果所有类都使用super，方法调用将按照 MRO 类顺序分发：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;A.__init__&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;B.__init__&#x27;</span>); <span class="built_in">super</span>().__init__()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="built_in">print</span>(<span class="string">&#x27;C.__init__&#x27;</span>); <span class="built_in">super</span>().__init__()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">x = D()</span><br></pre></td></tr></table></figure><ul><li>上面先运行 B ，而 B 中的 super() 是按照 D 的 MRO 顺序（D、B、C、A）来的，所以 B 中的 super() 会运行 C ，再 C 的 super() 运行 A ；</li><li>故结果是 <code>B.__init__、C.__init__、A.__init__</code>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(D.__mro__)</span><br></pre></td></tr></table></figure><ul><li>只要所有类都采用了 super 调用，通过在 MRO 序列下选择下一个类，一个类方法的 super 调用就能在类树上传递调用；</li><li>总之， super 要么不用，要么全用，最好不用。</li></ul><p>5、相同参数限制</p><ul><li>若方法参数随着类不同而变化时，使用 super 会让程序员很难确定 super 选择的版本（实际上会随着类树而变化）：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, salary</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.salary = salary</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chef</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, <span class="number">50000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span>(<span class="title class_ inherited__">Employee</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, <span class="number">40000</span>)</span><br><span class="line"></span><br><span class="line">bob = Chef(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">sue = Server(<span class="string">&#x27;Sue&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bob.salary, sue.salary)</span><br></pre></td></tr></table></figure><ul><li>上面没问题，因为是单继承树；</li><li>但如果<code>class TwoJobs(Chef, Server): pass</code>，再<code>tom = TwoJobs(&#39;Tom&#39;)</code>，会出错误：<code>TypeError: __init__() takes 2 positional arguments but 3 were given</code>。</li></ul><h3 id="八、Class-Gotchas"><a href="#八、Class-Gotchas" class="headerlink" title="八、Class Gotchas"></a>八、Class Gotchas</h3><p>1、修改类属性</p><ul><li>所有从类产生的实例都共享这个类的命名空间，所以对类层次的修改都会反映在实例里：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>:</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">I = X()</span><br><span class="line"><span class="built_in">print</span>(I.a)</span><br><span class="line"><span class="built_in">print</span>(X.a)</span><br><span class="line"><span class="comment"># class语句外修改类属性</span></span><br><span class="line">X.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(I.a)</span><br><span class="line"><span class="built_in">print</span>(X.a)</span><br></pre></td></tr></table></figure><p>2、修改可变的类属性，比如列表</p><ul><li>因为类属性被所有实例共享，如果一个类属性引用一个可变对象，那么任何实例在原位置修改该对象会影响到所有实例和类：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    shared = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.perobj = []</span><br><span class="line"></span><br><span class="line">x = C()</span><br><span class="line">y = C()</span><br><span class="line"><span class="built_in">print</span>(y.shared, y.perobj)</span><br><span class="line">x.shared.append(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">x.perobj.append(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x.shared, x.perobj)</span><br><span class="line"><span class="built_in">print</span>(y.shared, y.perobj)</span><br><span class="line"><span class="built_in">print</span>(C.shared)</span><br></pre></td></tr></table></figure><p>3、方法和类中的作用域</p><ul><li>类 Spam 是在 generate 函数的局部作用域中赋值的，所以能被内嵌的函数看到，即 LEGB 作用域的 E ：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>():</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Spam</span>:</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="built_in">print</span>(Spam.count)</span><br><span class="line">    <span class="keyword">return</span> Spam()</span><br><span class="line"></span><br><span class="line">generate().method()</span><br></pre></td></tr></table></figure><ul><li>尽管如此， method 方法是看不到外层类的局部作用域， method 方法只看得到外层 def 的局部作用域；</li><li>这也是为什么方法得通过 self 实例，或类名称来引用外层类定义得方法或属性；</li><li>即必须使用 self.count 或 Spam.count ，而不是 count ；</li><li>method 方法能够访问：它自己的作用域、外层函数的作用域、外围模块的全局作用域、所有存储在类的 self 实例的数据，以及它的非局部名称的类本身。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Learning Python》读书笔记（二）</title>
      <link href="/2022/10/21/2022-10-21-Learning-python2/"/>
      <url>/2022/10/21/2022-10-21-Learning-python2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该笔记为 <strong>《Learning Python》</strong> 的读书笔记，由于是早期未搞熟博客系统时所写，笔记结构较为混乱；<br>该书涉及的内容可能过于啰嗦，但包含一些python背后的逻辑和机制，可以粗略过一遍，但若仔细阅读就是在坑自己；<br>该笔记内容过多，所以不展示部分代码的结果，需复制到编辑器中查看；<br>学习完成日期为2022年10月20日。<br>本篇主要内容为：Python解释器；Python对象类型的初步介绍；数值类型。</p></blockquote><div  align="center">  <img src="https://s2.loli.net/2022/09/17/ri9Ue6nguJdq1Ca.jpg" width = "80%" height = "80%" alt="Learning Python"/></div><h1 id="PART-III-Statements-and-Syntax"><a href="#PART-III-Statements-and-Syntax" class="headerlink" title="PART III Statements and Syntax"></a>PART III Statements and Syntax</h1><h2 id="chapter-10-Introducing-Python-Statements"><a href="#chapter-10-Introducing-Python-Statements" class="headerlink" title="chapter 10 Introducing Python Statements"></a>chapter 10 Introducing Python Statements</h2><h3 id="一、Python’s-Statements"><a href="#一、Python’s-Statements" class="headerlink" title="一、Python’s Statements"></a>一、Python’s Statements</h3><ol><li><p>Python程序结构<br><em>程序由模块构成；模块包含语句；语句包含表达式；表达式创建并处理对象</em><br>Programs are composed of modules；Modules contain statements；Statements contain expressions；Expressions create and process objects</p></li><li><p>Python’s Statements语句</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">Statement</th><th style="text-align:left">Role</th><th style="text-align:left">Example</th></tr></thead><tbody><tr><td style="text-align:left">赋值语句</td><td style="text-align:left">创建引用reference</td><td style="text-align:left">a, b = ‘good’, ‘bad’</td></tr><tr><td style="text-align:left">调用和其他表达式</td><td style="text-align:left">运行函数</td><td style="text-align:left">log.write(“spam, ham”)</td></tr><tr><td style="text-align:left">print语句</td><td style="text-align:left">打印对象</td><td style="text-align:left">print(‘The Killer’, joke)</td></tr><tr><td style="text-align:left">if/elif语句</td><td style="text-align:left">选择行为</td><td style="text-align:left">if “python” in text: print(text)</td></tr><tr><td style="text-align:left">for语句</td><td style="text-align:left">迭代</td><td style="text-align:left">for x in mylist: print(x)</td></tr><tr><td style="text-align:left">while语句</td><td style="text-align:left">循环loop</td><td style="text-align:left">while X &gt; Y: print(‘hello’)</td></tr><tr><td style="text-align:left">pass</td><td style="text-align:left">空占位符Empty placeholder</td><td style="text-align:left">while True: pass</td></tr><tr><td style="text-align:left">break</td><td style="text-align:left">退出循环</td><td style="text-align:left">while True: if exittest(): break</td></tr><tr><td style="text-align:left">continue</td><td style="text-align:left">循环继续</td><td style="text-align:left">while True: if skiptest(): continue</td></tr><tr><td style="text-align:left">def</td><td style="text-align:left">函数与方法</td><td style="text-align:left">def f(a, b, c=1, *d): print(a+b+c+d[0])</td></tr><tr><td style="text-align:left">return</td><td style="text-align:left">函数结果</td><td style="text-align:left">def f(a, b, c=1, *d): return a+b+c+d[0]</td></tr><tr><td style="text-align:left">yield</td><td style="text-align:left">生成器函数</td><td style="text-align:left">def gen(n): for i in n: yield i*2</td></tr><tr><td style="text-align:left">global</td><td style="text-align:left">命名空间Namespaces</td><td style="text-align:left">def function(): global x</td></tr><tr><td style="text-align:left">nonlocal</td><td style="text-align:left">非局部声明</td><td style="text-align:left">def outer(): x = ‘old’ def function(): nonlocal x; x = ‘new’</td></tr><tr><td style="text-align:left">import</td><td style="text-align:left">获取模块</td><td style="text-align:left">import sys</td></tr><tr><td style="text-align:left">from</td><td style="text-align:left">获取模块属性</td><td style="text-align:left">from sys import stdin</td></tr><tr><td style="text-align:left">class</td><td style="text-align:left">构建对象</td><td style="text-align:left">class Subclass(Superclass):</td></tr><tr><td style="text-align:left">try/except/finally</td><td style="text-align:left">捕捉异常Catching exceptions</td><td style="text-align:left">try:</td></tr><tr><td style="text-align:left">raise</td><td style="text-align:left">触发异常</td><td style="text-align:left">raise EndSearch(location)</td></tr><tr><td style="text-align:left">assert</td><td style="text-align:left">调试异常Debugging checks</td><td style="text-align:left">assert X &gt; Y, ‘X too small’</td></tr><tr><td style="text-align:left">with/as</td><td style="text-align:left">上下文管理器</td><td style="text-align:left">with open(‘data’) as myfile:</td></tr><tr><td style="text-align:left">del</td><td style="text-align:left">删除引用</td><td style="text-align:left">del data[k]</td></tr></tbody></table></div><ol><li><strong>语句分隔符</strong>：即分号，同一行出现多个语句时使用：<br><code>a = 1; b = 2; print(a + b)</code></li></ol><h2 id="chapter-11-Assignments-Expressions-and-Prints"><a href="#chapter-11-Assignments-Expressions-and-Prints" class="headerlink" title="chapter 11 Assignments, Expressions, and Prints"></a>chapter 11 Assignments, Expressions, and Prints</h2><h3 id="一、Assignment-Statements"><a href="#一、Assignment-Statements" class="headerlink" title="一、Assignment Statements"></a>一、Assignment Statements</h3><ol><li>赋值语句形式Assignment Statement Forms</li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Interpretation</th></tr></thead><tbody><tr><td style="text-align:left">spam = ‘Spam’</td><td style="text-align:left">基础模式</td></tr><tr><td style="text-align:left">spam, ham = ‘yum’, ‘YUM’</td><td style="text-align:left">元组赋值（基于位置）</td></tr><tr><td style="text-align:left">[spam, ham] = [‘yum’, ‘YUM’]</td><td style="text-align:left">列表赋值（基于位置）</td></tr><tr><td style="text-align:left">a, b, c, d = ‘spam’</td><td style="text-align:left">序列赋值</td></tr><tr><td style="text-align:left">a, *b = ‘spam’</td><td style="text-align:left">扩展序列解包Extended sequence unpacking</td></tr><tr><td style="text-align:left">spam = ham = ‘lunch’</td><td style="text-align:left">多目标赋值</td></tr><tr><td style="text-align:left">spams += 42</td><td style="text-align:left">增量赋值Augmented assignments</td></tr></tbody></table></div><ol><li><p>序列赋值</p><ul><li>序列赋值右侧可以接受任意类型的序列（可迭代对象），只要长度等于左侧序列即可：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[a, b, c] = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a, c)</span><br><span class="line">(a, b, c) = <span class="string">&quot;ABC&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a, c)</span><br></pre></td></tr></table></figure></li><li>赋值内嵌序列：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">((a, b), c) = (<span class="string">&#x27;SP&#x27;</span>, <span class="string">&#x27;AM&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure></li><li>序列解包赋值：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">red, green, blue = <span class="built_in">range</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(red, blue)</span><br></pre></td></tr></table></figure></li><li>循环中把序列分割为开头和剩余两部分：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">while</span> L:</span><br><span class="line">    front, L = L[<span class="number">0</span>], L[<span class="number">1</span>:]</span><br><span class="line">    <span class="built_in">print</span>(front, L)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>拓展序列解包Extended Sequence Unpacking</p><ul><li>带星号的名称（<em>X）会被赋值**</em>一个列表<em>*</em>，收集序列剩下的没被赋值给其他名称的所有项：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a, *b = seq <span class="comment"># a匹配第一项，b匹配剩下的内容</span></span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line">*a, b = seq</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br><span class="line">a, *b, c = seq</span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="number">4</span></span><br><span class="line"><span class="number">1</span> [<span class="number">2</span>, <span class="number">3</span>] <span class="number">4</span></span><br></pre></td></tr></table></figure></li><li>拓展的序列解包对于任意可迭代对象都有效：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, *b, c = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br><span class="line">a, *b, c = <span class="built_in">range</span>(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s [<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;a&#x27;</span>] m</span><br><span class="line"><span class="number">0</span> [<span class="number">1</span>, <span class="number">2</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li>和分片的区别：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S[<span class="number">0</span>], S[<span class="number">1</span>:<span class="number">3</span>], S[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s pa m</span><br></pre></td></tr></table></figure></li><li>循环：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">while</span> L:</span><br><span class="line">    front, *L = L</span><br><span class="line">    <span class="built_in">print</span>(front, L)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">2</span> [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">3</span> [<span class="number">4</span>]</span><br><span class="line"><span class="number">4</span> []</span><br></pre></td></tr></table></figure></li><li><em>带星号的名称有可能只匹配到单个的项，但总会向其赋值一个列表</em>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a, b, c, *d = seq</span><br><span class="line"><span class="built_in">print</span>(a, b, c, d)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> [<span class="number">4</span>]</span><br></pre></td></tr></table></figure></li><li>若无剩下的内容，则被赋值一个空列表：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b, c, d, *e = seq</span><br><span class="line"><span class="built_in">print</span>(a, b, c, d, e)</span><br><span class="line">a, b, *e, c, d = seq</span><br><span class="line"><span class="built_in">print</span>(a, b, c, d, e)</span><br><span class="line">*a, = seq</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a, *b, c = seq</span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> []</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> []</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">1</span> [<span class="number">2</span>, <span class="number">3</span>] <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>增量赋值<br>在X += Y中，代码只需运行一次。但X = X + Y，X会出现2次，也必须执行2次；<br>增量赋值有自动选择的优化技术。对于支持原位置改变的对象，自动选择原位置修改，而不是更慢的复制运算：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">L = L + [<span class="number">3</span>] <span class="comment"># 拼接会创建一个新对象</span></span><br><span class="line">L.append(<span class="number">4</span>) <span class="comment"># 原位置改变，会更快</span></span><br><span class="line">L.extend([<span class="number">5</span>, <span class="number">6</span>]) <span class="comment"># 原位置改变，会更快</span></span><br><span class="line"><span class="comment"># 而增量赋值会自动调用较快的extend方法，而不是使用较慢的+拼接运算</span></span><br><span class="line">L += [<span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment"># 所以+=不在所有情况都等于+和=，对于列表+=更像extend，能接受任意序列</span></span><br><span class="line">L = []</span><br><span class="line">L += <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="comment"># +=对于列表就是原位置修改</span></span><br><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">M = L</span><br><span class="line">L = L + [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(L, M)</span><br><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">M = L</span><br><span class="line">L += [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(L, M)</span><br></pre></td></tr></table></figure></li></ol><h3 id="二、Expression-Statements"><a href="#二、Expression-Statements" class="headerlink" title="二、Expression Statements"></a>二、Expression Statements</h3><p>1、常见的表达式语句  </p><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Interpretation</th></tr></thead><tbody><tr><td style="text-align:left">spam(eggs, ham)</td><td style="text-align:left">函数调用</td></tr><tr><td style="text-align:left">spam.ham(eggs)</td><td style="text-align:left">方法调用</td></tr><tr><td style="text-align:left">spam</td><td style="text-align:left">在交互式解释器打印</td></tr><tr><td style="text-align:left">print(a, b, c)</td><td style="text-align:left">print语句</td></tr><tr><td style="text-align:left">yield x ** 2</td><td style="text-align:left">yield表达式语句</td></tr></tbody></table></div><p>表达式作为语句（让表达式独占一行），这样不会存储表达式结果。<br>print也会像其他函数调用一样返回一个值（返回值为None，为不返回任何有意义内容的函数的默认返回值）：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">print</span>(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></p><p>2、 表达式语句用于原位置修改<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">L.append(<span class="number">3</span>) <span class="comment"># 表达式语句</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="comment"># 但新手可能会写成赋值语句</span></span><br><span class="line">L = L.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(L) <span class="comment"># 返回None对象</span></span><br></pre></td></tr></table></figure></p><h3 id="三、Print-Operations"><a href="#三、Print-Operations" class="headerlink" title="三、Print Operations"></a>三、Print Operations</h3><ol><li><p>打印操作<br>python的打印操作与文件和流的概念紧密相连：<br>（1）文件对象方法：print将对象写入<strong>stdout流</strong>，同时加入一些自动的格式化；<br>（2）<strong>标准输出流standard output stream（常称为stdout）</strong>：是发送一个程序文本输出的默认位置。加上<strong>标准输入流standard input</strong>和<strong>标准出错流error streams</strong>，为脚本启动时所创建的3种数据连接；<br>（3）标准输出流在python中可以作为内置的sys模块中的stdout文件对象来使用。  </p></li><li><p>print函数</p><ul><li>print内置函数的调用通常独占一行，但它不会返回值（返回None）；</li><li>调用形式：<code>print([object, ...][, sep=&#39; &#39;][, end=&#39;\n&#39;][, file=sys.stdout][, flush=False])</code></li><li>print内置函数打印一个或多个对象，在中间用字符串<code>sep</code>来分隔，<code>sep</code>默认一个单个的空格，在结尾加上字符串<code>end</code>，通过<code>file</code>来指定输出流，并按照<code>flush</code>来决定是否刷新输出缓冲区：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">y = <span class="number">99</span></span><br><span class="line">z = [<span class="string">&#x27;eggs&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(x, y, z)</span><br><span class="line"><span class="built_in">print</span>(x, y, z, sep=<span class="string">&#x27;, &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x, y, z, end=<span class="string">&#x27;&#x27;</span>); <span class="built_in">print</span>(x, y, z)</span><br><span class="line"><span class="built_in">print</span>(x, y, z, sep=<span class="string">&#x27;...&#x27;</span>, file=<span class="built_in">open</span>(<span class="string">&#x27;11-Assignments, Expressions, and Prints\data.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)) <span class="comment"># print to a file</span></span><br><span class="line"><span class="built_in">print</span>(x, y, z) <span class="comment"># back to stdout</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;11-Assignments, Expressions, and Prints\data.txt&#x27;</span>).read())</span><br></pre></td></tr></table></figure></li></ul></li><li><p>打印流重定向</p><ul><li>打印都默认将文本发送到标准输出流，也可以发送到其他地方；</li><li>print提供了sys.stdout对象的简单接口，再加上一些默认的格式设置；</li><li>也可以通过下面编写打印操作：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.stdout.write(<span class="string">&#x27;hello world\n&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>上述程序显示调用了<code>sys.stdout</code>的<code>write方法</code>。而print操作隐藏了大部分细节：<code>print(X, Y)</code>等价于<code>import sys</code>和<code>sys.stdout.write(str(X) + &#39; &#39; + str(Y) + &#39;\n&#39;)</code></li><li>可以把sys.stdout重新赋值给标准输出流以外的对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.stdout = <span class="built_in">open</span>(<span class="string">&#x27;11-Assignments, Expressions, and Prints\log.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="comment"># redirect prints to a file</span></span><br><span class="line"><span class="built_in">print</span>(x, y, x) <span class="comment"># shows up in log.txt</span></span><br></pre></td></tr></table></figure></li><li>在这里把<code>sys.stdout</code>重设成一个已打开的名为log.txt的文件对象，该文件以附加模式打开。重设后，print会将文本写至文件log.txt的末尾，而不是原本的输出流。print语句会持续调用<code>sys.stdout</code>的<code>write</code>方法。通过这种方式赋值<code>sys.stdout</code>会让程序中所有的print都被重新定向。</li></ul></li><li><p>恢复输出流定向</p><ul><li>先把sys.stdout存储到一个对象里：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">temp = sys.stdout <span class="comment"># 先把sys.stdout存储到一个对象里</span></span><br><span class="line">sys.stdout = <span class="built_in">open</span>(<span class="string">&#x27;11-Assignments, Expressions, and Prints\log.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">sys.stdout.close() <span class="comment"># Flush output to disk</span></span><br><span class="line">sys.stdout = temp <span class="comment"># Restore original stream</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;back here&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;11-Assignments, Expressions, and Prints\log.txt&#x27;</span>).read())</span><br></pre></td></tr></table></figure></li><li>这样手动保存和恢复原始输出流需要额外工作，所以python引入了print拓展，<code>file</code>关键字允许一个单次的print调用将文本发送给一个文件的<code>write方法</code>，而不是费力地重设<code>sys.stdout</code>。print拓展的重定向是临时的，之后的print还是会继续打印到标准输出流。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">log2= <span class="built_in">open</span>(<span class="string">&#x27;11-Assignments, Expressions, and Prints\log2.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="comment"># 同上见test2.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, file=log2)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, file=log2)</span><br><span class="line">log2.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;11-Assignments, Expressions, and Prints\log2.txt&#x27;</span>).read())</span><br></pre></td></tr></table></figure></li></ul></li><li><p>标准错误流（standard error stream）sys.stderr</p><ul><li>拓展的print形式也常用于把错误消息打印到标准错误流<code>sys.stderr</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.stderr.write((<span class="string">&#x27;Bad!&#x27;</span> * <span class="number">8</span>) + <span class="string">&#x27;\n&#x27;</span>) <span class="comment"># 标准错误流的write方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Bad!&#x27;</span> * <span class="number">8</span>, file=sys.stderr)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>理解print语句和sys.stdout之间的等价性</p><ul><li>print语句只是把文本传送给<code>sys.stdout.write方法</code>，所以可以把<code>sys.stdout</code>赋值给一个对象，来捕获程序中待打印的文本，并通过该对象的write方法处理文本：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileFaker</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self, string</span>):</span><br><span class="line">        Do something <span class="keyword">with</span> printed text <span class="keyword">in</span> string</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.stdout = FileFaker()</span><br><span class="line"><span class="built_in">print</span>(someObjects) <span class="comment"># Sends to class write method</span></span><br></pre></td></tr></table></figure></li><li><code>sys.stdout</code>是什么不重要，只要它有一个名为write的方法(接口)即可，详见第六部分类。</li></ul></li></ol><h2 id="chapter-12-if-Tests-and-Syntax-Rules"><a href="#chapter-12-if-Tests-and-Syntax-Rules" class="headerlink" title="chapter 12 if Tests and Syntax Rules"></a>chapter 12 if Tests and Syntax Rules</h2><h3 id="一、if-Statements"><a href="#一、if-Statements" class="headerlink" title="一、if Statements"></a>一、if Statements</h3><ol><li><p>基础示例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span>: <span class="comment"># 1是布尔真值，即True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;true&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;true&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;false&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>多路分支<br>Python会执行第一次测试为真的语句，当所有的测试都为假时执行else部分：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">&#x27;killer rabbit&#x27;</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="string">&#x27;roger&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;shave and a haircut&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="string">&#x27;bugs&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;what&#x27;s up doc?&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run away! Run away!&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>语句分隔符：行与行间连接符</p><ul><li>如果使用语法括号对，语句可横跨数行，比如封闭的()、{}、[]；</li><li>如果语句以反斜杠<code>\</code>结尾，可横跨数行；</li><li>三重引号字符串可横跨数行：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">&quot;Good&quot;</span>,</span><br><span class="line"><span class="string">&quot;Bad&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ugly&quot;</span>]</span><br><span class="line"><span class="comment"># 反斜杠来继续多行（不常用）：</span></span><br><span class="line"><span class="keyword">if</span> a == b <span class="keyword">and</span> c == d <span class="keyword">and</span> \</span><br><span class="line">    d == e <span class="keyword">and</span> f == g:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;olde&#x27;</span>)</span><br><span class="line"><span class="comment"># 因为任何表达式都可以包含在括号内：</span></span><br><span class="line"><span class="keyword">if</span> (a == b <span class="keyword">and</span> c == d <span class="keyword">and</span></span><br><span class="line">    d == e <span class="keyword">and</span> e == f):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;new&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>真值和布尔测试</p><ul><li>所有对象都有一个固有的布尔真/假值，任何非零数字或非空对象都为真，数字零、空对象以及None都为假；</li><li>比较相等测试会递归地应用到数据结构；</li><li>布尔<code>and</code>和<code>or</code>运算符会在结果确定的时候立即停止计算（‘短路’）；</li><li>对于<code>or</code>测试，python会从左到右计算操作对象，然后返回第一个为真的对象，一旦得出结果就使表达式其余部分短路（终止）：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">or</span> <span class="number">3</span>, <span class="number">3</span> <span class="keyword">or</span> <span class="number">2</span>) <span class="comment"># 真或真</span></span><br><span class="line"><span class="built_in">print</span>([] <span class="keyword">or</span> <span class="number">3</span>) <span class="comment"># 假或真</span></span><br><span class="line"><span class="built_in">print</span>([] <span class="keyword">or</span> &#123;&#125;) <span class="comment"># 假或假</span></span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>对于<code>and</code>测试，python会从左到右计算操作对象，当遇到假的对象就停止运算：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">and</span> <span class="number">3</span>, <span class="number">3</span> <span class="keyword">and</span> <span class="number">2</span>) <span class="comment"># 真和真</span></span><br><span class="line"><span class="built_in">print</span>([] <span class="keyword">and</span> &#123;&#125;) <span class="comment"># 假和假</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">and</span> []) <span class="comment"># 真和假</span></span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line">[]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>if/else三元表达式Ternary Expression<br><code>A = Y if X else Z</code>：当X为真时，执行表达式Y，否则执行Z</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = <span class="string">&#x27;t&#x27;</span> <span class="keyword">if</span> <span class="string">&#x27;spam&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;f&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line">A = <span class="string">&#x27;t&#x27;</span> <span class="keyword">if</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;f&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br></pre></td></tr></table></figure></li><li><p><code>filter函数</code>或列表推导来筛选真的对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;ham&#x27;</span>, []]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="built_in">bool</span>, L)))</span><br><span class="line"><span class="built_in">print</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> L <span class="keyword">if</span> x])</span><br></pre></td></tr></table></figure></li><li><p><code>any</code>和<code>all</code>内置函数用于检测是否存中或者所有元素都为真</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">any</span>(L), <span class="built_in">all</span>(L))</span><br></pre></td></tr></table></figure></li></ol><h2 id="chapter-13-while-and-for-Loops"><a href="#chapter-13-while-and-for-Loops" class="headerlink" title="chapter 13 while and for Loops"></a>chapter 13 while and for Loops</h2><h3 id="一、while-Loops"><a href="#一、while-Loops" class="headerlink" title="一、while Loops"></a>一、while Loops</h3><ol><li><p>while循环Loops一般形式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> test:</span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure></li><li><p>break、continue、pass和循环的else</p><ul><li><code>break</code>：跳过整个循环语句；</li><li><code>continue</code>：来到循环头部；</li><li><code>pass</code>：空占位语句；</li><li><code>else</code>：当且仅当循环正常离开时才会执行。</li></ul></li><li><p>pass  </p><ul><li><code>while True: pass</code>：pass语句是无运算的占位语句，因为主体只是空语句，所以python会陷入死循环（ctrl-c推出）；</li><li>pass主要用于定义类时，pass暂时填充函数主体，表示以后填上。</li></ul></li><li><p>continue</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> x:</span><br><span class="line">    x = x-<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span>: <span class="keyword">continue</span> <span class="comment"># 跳到循环顶端</span></span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>break</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&#x27;Enter name:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;stop&#x27;</span>: <span class="keyword">break</span> <span class="comment"># 立即从循环体退出，包括else分句</span></span><br><span class="line">    age = <span class="built_in">input</span>(<span class="string">&#x27;Enter age: &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello&#x27;</span>, name, <span class="string">&#x27;=&gt;&#x27;</span>, <span class="built_in">int</span>(age) ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>循环的else</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = <span class="built_in">input</span>(<span class="string">&#x27;Enter number:&#x27;</span>)</span><br><span class="line">x = <span class="built_in">int</span>(y) // <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> x &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(y) % x == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(y, <span class="string">&#x27;has factor&#x27;</span>, x)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    x -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(y, <span class="string">&#x27;is prime&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="二、for-Loops"><a href="#二、for-Loops" class="headerlink" title="二、for Loops"></a>二、for Loops</h3><ol><li><p>for循环</p><ul><li><code>for循环</code>是一个通用的序列迭代器，用来遍历任何有序序列或者其他可迭代对象内的元素：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> target <span class="keyword">in</span> <span class="built_in">object</span>:</span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure></li><li>python在运行for循环时，会逐个将可迭代对象object中的元素赋值给名称target：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&quot;spam&quot;</span>, <span class="string">&quot;eggs&quot;</span>, <span class="string">&quot;ham&quot;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + x</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure></li><li>for循环用于字符串和元组：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&quot;lumberjack&quot;</span></span><br><span class="line">T = (<span class="string">&quot;and&quot;</span>, <span class="string">&quot;I&#x27;m&quot;</span>, <span class="string">&quot;okay&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> S: <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> T: <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>for循环中的元组赋值</p><ul><li>元组赋值：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="keyword">for</span> (a, b) <span class="keyword">in</span> T:</span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br><span class="line"></span><br><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> D:</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;=&gt;&#x27;</span>, D[key])</span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> D.items():</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;=&gt;&#x27;</span>, value)</span><br></pre></td></tr></table></figure></li><li>可以在循环中手动赋值解包：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="keyword">for</span> both <span class="keyword">in</span> T:</span><br><span class="line">    a, b = both</span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br></pre></td></tr></table></figure></li><li>嵌套的结构自动解包：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ((a, b), c) <span class="keyword">in</span> [((<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>), ((<span class="number">4</span>, <span class="number">5</span>), <span class="number">6</span>)]: <span class="built_in">print</span>(a, b, c)</span><br><span class="line"><span class="keyword">for</span> ((a, b), c) <span class="keyword">in</span> [([<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>), [<span class="string">&#x27;XY&#x27;</span>, <span class="number">6</span>]]: <span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>for循环中的拓展序列赋值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (a, *b, c) <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)]:</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure></li><li><p>嵌套for循环</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items = [<span class="string">&quot;aaa&quot;</span>, <span class="number">111</span>, (<span class="number">4</span>, <span class="number">5</span>), <span class="number">2.01</span>]</span><br><span class="line">tests = [(<span class="number">4</span>, <span class="number">5</span>), <span class="number">3.14</span>]</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> tests:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> item == key:</span><br><span class="line">            <span class="built_in">print</span>(key, <span class="string">&quot;was found&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(key, <span class="string">&quot;not found!&quot;</span>)</span><br><span class="line"></span><br><span class="line">seq1 = <span class="string">&quot;spam&quot;</span></span><br><span class="line">seq2 = <span class="string">&quot;scam&quot;</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> seq1:</span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">in</span> seq2:</span><br><span class="line">        res.append(x)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># 上面例子可以直接用列表推导式</span></span><br><span class="line">res = [x <span class="keyword">for</span> x <span class="keyword">in</span> seq1 <span class="keyword">if</span> x <span class="keyword">in</span> seq2]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li><li><p>文件扫描器File Scanners</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;13-while and for Loops/test.txt&#x27;</span>).readlines(): <span class="comment"># readlines方法生成每一行的字符串的列表</span></span><br><span class="line">    <span class="built_in">print</span>(line.rstrip())</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;13-while and for Loops/test.txt&#x27;</span>): <span class="comment"># 文件迭代器</span></span><br><span class="line">    <span class="built_in">print</span>(line.rstrip())</span><br></pre></td></tr></table></figure></li></ol><h3 id="三、Loop-Coding-Techniques"><a href="#三、Loop-Coding-Techniques" class="headerlink" title="三、Loop Coding Techniques"></a>三、Loop Coding Techniques</h3><ol><li><p>计数器循环Counter Loops：range</p><ul><li><code>range</code>是一个可迭代对象，当range传入2个参数，第一个参数为下边界。第三个可选参数为步长（默认值+1）：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(-<span class="number">5</span>, <span class="number">5</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">1</span>)))</span><br></pre></td></tr></table></figure></li><li>序列乱序器Sequence Shufflers：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">    S = S[<span class="number">1</span>:] + S[:<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(S)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">    X = S[i:] + S[:i]</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br></pre></td></tr></table></figure></li><li>非穷尽遍历Nonexhaustive Traversals：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;abcdefghijk&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(S), <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(S[i], end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="comment"># 上面例子不如直接用分片表达式的第三个参数</span></span><br><span class="line">S = <span class="string">&#x27;abcdefghijk&#x27;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> S[::<span class="number">2</span>]:  <span class="comment"># 见7-3</span></span><br><span class="line">    <span class="built_in">print</span>(c, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>并行遍历Parallel Traversals：zip和map</p><ul><li><code>zip函数</code>将序列并排元素配对得到元组的列表，返回的是一个可迭代对象，需要用list调用来显示结果：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">L2 = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(L1, L2)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x, y) <span class="keyword">in</span> <span class="built_in">zip</span>(L1, L2):</span><br><span class="line">    <span class="built_in">print</span>(x, y, <span class="string">&#x27;--&#x27;</span>, x+y)</span><br></pre></td></tr></table></figure></li><li>当各个参数长度不一时，zip按最短序列长度为准：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S1 = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">S2 = <span class="string">&#x27;xyz123&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(S1, S2)))</span><br></pre></td></tr></table></figure></li><li><code>map函数</code>：输入函数和序列，从序列抽取元素调用函数，并收集结果，详见19、20章：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="string">&#x27;spam&#x27;</span>)))</span><br></pre></td></tr></table></figure></li><li>使用<code>zip</code>来构造字典：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keys = [<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;toast&#x27;</span>]</span><br><span class="line">vals = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">D3 = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keys, vals))</span><br><span class="line"><span class="built_in">print</span>(D3)</span><br></pre></td></tr></table></figure></li><li>字典推导：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(&#123;k: v <span class="keyword">for</span> (k, v) <span class="keyword">in</span> <span class="built_in">zip</span>(keys, vals)&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>enumerate函数：同时给出偏移量和元素</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (offset, item) <span class="keyword">in</span> <span class="built_in">enumerate</span>(S):</span><br><span class="line">    <span class="built_in">print</span>(item, <span class="string">&#x27;appears at offset&#x27;</span>, offset)</span><br></pre></td></tr></table></figure><ul><li><code>enumerate函数</code>会返回一个<strong>生成器对象generator object</strong>：支持<strong>迭代协议iteration protocol</strong>，可以被<code>内置函数next</code>调用，详见第14章：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">E = <span class="built_in">enumerate</span>(S)</span><br><span class="line"><span class="built_in">print</span>(E)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(E))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(E))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(E))</span><br></pre></td></tr></table></figure></li><li>推导和for循环：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>([c * i <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>(S)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i, l) <span class="keyword">in</span> <span class="built_in">enumerate</span>(S):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s) %s&#x27;</span> % (i, l.rstrip()))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="chapter-14-Iterations-and-Comprehensions"><a href="#chapter-14-Iterations-and-Comprehensions" class="headerlink" title="chapter 14 Iterations and Comprehensions"></a>chapter 14 Iterations and Comprehensions</h2><h3 id="一、Iterations"><a href="#一、Iterations" class="headerlink" title="一、Iterations"></a>一、Iterations</h3><ol><li><p>简单介绍<br><strong>迭代工具iteration tools</strong>可用于任何<strong>可迭代对象iterable object</strong>；<em>迭代工具包括for循环、列表推导、in成员关系测试以及map函数等</em>，可迭代对象本质上就是序列观念的通用化。可迭代对象包括实际序列以及虚拟序列。</p></li><li><p>可迭代对象iterable与迭代器iterator</p><ul><li><strong><em>可迭代对象</em></strong>指代一个支持<code>iter</code>调用的对象；</li><li><strong><em>迭代器</em></strong>指代一个支持<code>next()</code>调用的对象：</li><li><strong><em>生成器generator</em></strong>指代能自动支持迭代协议的对象，生成器本身就是可迭代对象。</li></ul></li><li><p>迭代协议Iteration Protocol：文件迭代器</p><ul><li><code>readline方法</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;14-Iterations and Comprehensions/script2.py&#x27;</span>).read())</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;14-Iterations and Comprehensions/script2.py&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(f.readline())</span><br><span class="line"><span class="built_in">print</span>(f.readline())</span><br><span class="line"><span class="built_in">print</span>(f.readline())</span><br><span class="line"><span class="built_in">print</span>(f.readline())</span><br><span class="line"><span class="built_in">print</span>(f.readline())</span><br></pre></td></tr></table></figure></li><li>文件也有一个名为<code>_next_</code>的方法，跟上面有着相同的效果，即每次调用返回文件的下一行。唯一的区别是，到达文件尾部，<code>_next_</code>会引发内置<code>StopIteration异常</code>，而不是返回空字符串：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;14-Iterations and Comprehensions/script2.py&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(f.__next__())</span><br><span class="line"><span class="built_in">print</span>(f.__next__())</span><br><span class="line"><span class="built_in">print</span>(f.__next__())</span><br><span class="line"><span class="built_in">print</span>(f.__next__())</span><br></pre></td></tr></table></figure></li><li>这个接口基本上就是Python中的迭代协议：所有带<code>_next_方法</code>的对象会前进到下一个结果，这个对象也被称为迭代器；</li><li>任何这类对象也能在for循环或其他迭代工具遍历，因为所有迭代工具都是在每次迭代中调用<code>_next_</code>，并且捕捉<code>StopIteration异常</code>来确定何时离开；</li><li>完整的迭代协议包括iter调用，见后面。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;14-Iterations and Comprehensions/script2.py&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(line.upper(), end=<span class="string">&#x27;&#x27;</span>) <span class="comment"># 这里end=&#x27;&#x27;，因为行字符串已经自带一个\n，如果没有end=&#x27;&#x27;，则会变成2行隔开</span></span><br></pre></td></tr></table></figure></li><li><code>readlines方法</code>会形成行字符串的列表，并一次性加载至内存，如果文件太大可能会无法工作。而<code>readline方法</code>基于迭代器，一次只读一行，所以运行更快：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;14-Iterations and Comprehensions/script2.py&#x27;</span>).readlines():</span><br><span class="line">    <span class="built_in">print</span>(line.upper(), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>或用<code>while循环</code>逐行读取文件，然而while循环会比基于迭代器的for循环运行得更慢，因为迭代器在python内部以C语言的速度运行，而while循环则是通过Python虚拟机运行Python字节码：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;14-Iterations and Comprehensions/script2.py&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line: <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(line.upper(), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>在第21章会介绍一种计时技术，可以衡量替代方案的相对速度。</li></ul></li><li><p>手动迭代：iter和next</p><ul><li>内置函数<code>next</code>，自动调用对象的<code>_next_方法</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;14-Iterations and Comprehensions/script2.py&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(f))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(f))</span><br></pre></td></tr></table></figure></li><li>迭代协议还有一点：<em>for循环在开始时，会首先把可迭代对象传入内置函数iter，并由此拿到一个迭代器，返回的迭代器有_next_方法</em>；</li><li>iter函数也是在内部调用_iter_方法。</li></ul></li><li><p>完整的迭代协议</p><ul><li>(1) <strong>可迭代对象The iterable object</strong>：迭代的被调对象，其<code>_iter_方法</code>被<code>iter函数</code>调用</li><li>(2) <strong>迭代器对象The iterator object</strong>：可迭代对象的返回结果，在迭代过程中实际提供值的对象。其<code>_next_方法</code>被<code>next</code>运行，并在结束时触发<code>StopIteration异常</code>。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">I = <span class="built_in">iter</span>(L)</span><br><span class="line"><span class="built_in">print</span>(I.__next__())</span><br><span class="line"><span class="built_in">print</span>(I.__next__())</span><br><span class="line"><span class="built_in">print</span>(I.__next__())</span><br></pre></td></tr></table></figure></li><li><code>iter</code>这一步对于文件不是必须的，因为文件对象自身就是迭代器：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;14-Iterations and Comprehensions/script2.py&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">iter</span>(f) <span class="keyword">is</span> f)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">iter</span>(f) <span class="keyword">is</span> f.__iter__())</span><br></pre></td></tr></table></figure></li><li>对于列表等可迭代对象但自身不是迭代器的，需要调用iter来启动迭代：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">iter</span>(L) <span class="keyword">is</span> L)</span><br><span class="line">I = <span class="built_in">iter</span>(L)</span><br><span class="line"><span class="built_in">print</span>(I.__next__())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他内置类型可迭代对象Other Built-in Type Iterables</p><ul><li>字典在迭代上下文中会自动返回键：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">I = <span class="built_in">iter</span>(D)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> D:</span><br><span class="line">    <span class="built_in">print</span>(key, D[key])</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="二、List-Comprehensions"><a href="#二、List-Comprehensions" class="headerlink" title="二、List Comprehensions"></a>二、List Comprehensions</h3><ol><li><p>简单介绍</p><ul><li>列表推导会产生新的列表对象，并且比for循环语句运行更快，因为在解释器内部由C语言的速度执行：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">L = [x + <span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> L]</span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在文件上使用列表推导</p><ul><li>列表推导也有垃圾回收机制，在表达式运行结束后，将临时文件对象关闭，对于Cpython以外的python版本，需要手动关闭文件：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lines = [line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;14-Iterations and Comprehensions\script2.py&#x27;</span>)]</span><br><span class="line"><span class="built_in">print</span>(lines)</span><br><span class="line">lines = [line.rstrip().upper() <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;14-Iterations and Comprehensions\script2.py&#x27;</span>)] <span class="comment"># 方法链式调用是有效的</span></span><br><span class="line"><span class="built_in">print</span>(lines)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>拓展的列表推导语法</p><ul><li>筛选分句：if：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lines = [line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;14-Iterations and Comprehensions\script2.py&#x27;</span>) <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(lines)</span><br><span class="line"><span class="comment"># 更复杂的例子：</span></span><br><span class="line">lines = [line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;14-Iterations and Comprehensions\script2.py&#x27;</span>) <span class="keyword">if</span> line.rstrip()[-<span class="number">1</span>].isdigit()]</span><br><span class="line"><span class="built_in">print</span>(lines)</span><br></pre></td></tr></table></figure></li><li>嵌套循环：for<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [x + y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">&#x27;lmn&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="comment"># 其等价形式：</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">&#x27;lmn&#x27;</span>:</span><br><span class="line">        res.append(x + y)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、Other-Iteration-Contexts"><a href="#三、Other-Iteration-Contexts" class="headerlink" title="三、Other Iteration Contexts"></a>三、Other Iteration Contexts</h3><ol><li><p>其他迭代上下文</p><ul><li>用户定义的类也可以实现迭代协议。</li><li><code>map</code>把一个函数调用应用于传入的可迭代对象中的每一项，<code>内置函数map</code>当作用于一个文件时，也利用了文件对象的迭代器来逐行扫描，通过<code>_iter_</code>获取一个迭代器并每次调用<code>_next_方法</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = <span class="built_in">map</span>(<span class="built_in">str</span>.upper, <span class="built_in">open</span>(<span class="string">&#x27;script.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(M)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(M))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他可处理可迭代对象的内置函数、方法或工具</p><ul><li><code>sorted</code>排序可迭代对象中的每项，返回的是一个新的list：<br><code>print(sorted(open(&#39;script.py&#39;)))</code></li><li><code>zip</code>能够组合可迭代对象中的每项：<br><code>print(list(zip(open(&#39;script.py&#39;), open(&#39;script.py&#39;))))</code></li><li><code>enumerate</code>把可迭代对象中的项与它们的相对位置进行匹配：<br><code>print(list(enumerate(open(&#39;script.py&#39;))))</code></li><li><code>filter</code>按照一个函数是否为真来选择可迭代对象中的项：<br><code>print(list(filter(bool, open(&#39;script.py&#39;))))</code></li><li>字符串<code>join方法</code>：<br><code>print(&#39;&amp;&amp;&#39;.join(open(&#39;script.py&#39;)))</code></li><li>序列赋值：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b, c, d = <span class="built_in">open</span>(<span class="string">&#x27;script.py&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a, d)</span><br><span class="line">a, *b = <span class="built_in">open</span>(<span class="string">&#x27;script.py&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br></pre></td></tr></table></figure></li><li>in成员测试：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y = 2\n&#x27;</span> <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;script.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x = 2\n&#x27;</span> <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;script.py&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li>分片赋值：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line">L[<span class="number">1</span>:<span class="number">3</span>] = <span class="built_in">open</span>(<span class="string">&#x27;script.py&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure></li><li>列表的<code>extend方法</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">11</span>]</span><br><span class="line">L.extend(<span class="built_in">open</span>(<span class="string">&#x27;script.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure></li><li><code>append</code>不能自动迭代：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">11</span>]</span><br><span class="line">L.append(<span class="built_in">open</span>(<span class="string">&#x27;script.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(L[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></li><li>字典推导表达式：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(&#123;ix: line <span class="keyword">for</span> ix, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">open</span>(<span class="string">&#x27;script.py&#x27;</span>))&#125;)</span><br><span class="line"><span class="built_in">print</span>(&#123;ix: line <span class="keyword">for</span> (ix, line) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">open</span>(<span class="string">&#x27;script.py&#x27;</span>)) <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><code>*arg</code>形式，可以把对象的值解包成单个参数，也接受任何可迭代对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, c, d</span>): <span class="built_in">print</span>(a, b, c, d, sep=<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">f(*[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">f(*<span class="built_in">open</span>(<span class="string">&#x27;script.py&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="四、New-Iterables-in-Python-3-X"><a href="#四、New-Iterables-in-Python-3-X" class="headerlink" title="四、New Iterables in Python 3.X"></a>四、New Iterables in Python 3.X</h3><ol><li><p>range可迭代对象</p><ul><li>range对象支持迭代、索引以及len函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="number">2</span> ** x, <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> M: <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">R = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(R)</span><br><span class="line">I = <span class="built_in">iter</span>(R) <span class="comment"># Make an iterator from the range iterable</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(R))</span><br><span class="line"><span class="built_in">print</span>(R[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(R[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(I.__next__())</span><br></pre></td></tr></table></figure></li></ul></li><li><p>map、zip和filter可迭代对象</p><ul><li>与range不同，上述对象本身就是迭代器，无需用<code>iter()</code>转换；</li><li><code>map函数</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = <span class="built_in">map</span>(<span class="built_in">abs</span>, (-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(M)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(M))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(M))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(M))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> M: <span class="built_in">print</span>(x) <span class="comment"># 结果为空，因为在遍历其结果一次后，就用尽了map iterator is now empty</span></span><br><span class="line"></span><br><span class="line">M = <span class="built_in">map</span>(<span class="built_in">abs</span>, (-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)) <span class="comment"># Make a new iterable/iterator to scan again</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> M: <span class="built_in">print</span>(x) <span class="comment"># Iteration contexts auto call next()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, (-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))))</span><br></pre></td></tr></table></figure></li><li><code>zip函数</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Z = <span class="built_in">zip</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(Z))</span><br><span class="line"><span class="keyword">for</span> pair <span class="keyword">in</span> Z: <span class="built_in">print</span>(pair) <span class="comment"># Exhausted after one pass</span></span><br><span class="line"></span><br><span class="line">Z = <span class="built_in">zip</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line"><span class="keyword">for</span> pair <span class="keyword">in</span> Z: <span class="built_in">print</span>(pair)</span><br><span class="line"></span><br><span class="line">Z = <span class="built_in">zip</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(Z))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(Z))</span><br></pre></td></tr></table></figure></li><li><code>filter函数</code>，传入一个函数返回得到True的各项，filter可以接受一个可迭代对象处理，并返回一个可迭代对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">filter</span>(<span class="built_in">bool</span>, [<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;ni&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="built_in">bool</span>, [<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;ni&#x27;</span>])))</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>多遍迭代器vs单遍迭代器 Multiple Versus Single Pass Iterators</strong></p><ul><li>range不是自己的迭代器，并且支持在其结果上的多个迭代器：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">R = <span class="built_in">range</span>(<span class="number">3</span>)</span><br><span class="line">I1 = <span class="built_in">iter</span>(R)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I1))</span><br><span class="line">I2 = <span class="built_in">iter</span>(R)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I1))</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></li><li>相反，zip、map和filter不支持同一结果上的多个活跃迭代器，因此iter调用是可选的，它们的iter结果就是它们自身：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Z = <span class="built_in">zip</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>))</span><br><span class="line">I1 = <span class="built_in">iter</span>(Z)</span><br><span class="line">I2 = <span class="built_in">iter</span>(Z)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I2))</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">11</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字典视图可迭代对象Dictionary View Iterables</p><ul><li>字典的<code>keys</code>、<code>values</code>和<code>items</code>方法会返回可迭代的视图对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = <span class="built_in">dict</span>(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(D)</span><br><span class="line">K = D.keys()</span><br><span class="line"><span class="built_in">print</span>(K)</span><br><span class="line">I = <span class="built_in">iter</span>(K)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> D.keys(): <span class="built_in">print</span>(k)</span><br></pre></td></tr></table></figure></li><li>字典本身就是可迭代对象，带有返回键的迭代器：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">I = <span class="built_in">iter</span>(D)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="chapter-15-The-Documentation-Interlude"><a href="#chapter-15-The-Documentation-Interlude" class="headerlink" title="chapter 15 The Documentation Interlude"></a>chapter 15 The Documentation Interlude</h2><h3 id="一、Python-Documentation-Sources"><a href="#一、Python-Documentation-Sources" class="headerlink" title="一、Python Documentation Sources"></a>一、Python Documentation Sources</h3><ol><li><p>Python文档资源<br>井号注释；dir函数；文档字符串：__doc__；PyDoc: help函数；PyDoc: HTML报告；Sphinx第三方工具；标准手册集；网络资源；已出版的书籍</p></li><li><p>井号注释<br>文档字符串docstrings是较大型功能性的文档的最优选择，#注释更适用于较小代码的文档。</p></li><li><p>dir函数</p><ul><li><code>dir函数</code>可以抓取对象内所有可用属性，可以向其传入对象、模块、内置类型或者数据类型的名字：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(sys))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">dir</span>(sys)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">dir</span>(sys) <span class="keyword">if</span> <span class="keyword">not</span> x.startswith(<span class="string">&#x27;__&#x27;</span>)])) <span class="comment"># 双下划线开头意味着与解释器相关</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">dir</span>(sys) <span class="keyword">if</span> <span class="keyword">not</span> x[<span class="number">0</span>] == <span class="string">&#x27;_&#x27;</span>])) <span class="comment"># 单下划线开头意味着非正式的私有属性实现</span></span><br></pre></td></tr></table></figure></li><li>查看列表和字符串的属性，可以向dir传入空列表和空字符串：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>([]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">dir</span>([])), <span class="built_in">len</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">dir</span>([]) <span class="keyword">if</span> <span class="keyword">not</span> x.startswith(<span class="string">&#x27;__&#x27;</span>)]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">dir</span>(<span class="string">&#x27;&#x27;</span>)), <span class="built_in">len</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="string">&#x27;&#x27;</span>) <span class="keyword">if</span> <span class="keyword">not</span> x.startswith(<span class="string">&#x27;__&#x27;</span>)]))</span><br><span class="line"><span class="built_in">print</span>([a <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">list</span>) <span class="keyword">if</span> <span class="keyword">not</span> a.startswith(<span class="string">&#x27;__&#x27;</span>)])</span><br><span class="line"><span class="built_in">print</span>([a <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">dict</span>) <span class="keyword">if</span> <span class="keyword">not</span> a.startswith(<span class="string">&#x27;__&#x27;</span>)])</span><br></pre></td></tr></table></figure></li><li>可以传入一个类型名称而不是字面量：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">str</span>) == <span class="built_in">dir</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">list</span>) == <span class="built_in">dir</span>([]))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>文档字符串：__doc__</p><ul><li>Python会自动装载文档字符串的文本，使其成为相应对象的<code>__doc__属性</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> docstrings</span><br><span class="line"><span class="built_in">print</span>(docstrings.__doc__)</span><br><span class="line"><span class="built_in">print</span>(docstrings.square.__doc__)</span><br><span class="line"><span class="built_in">print</span>(docstrings.Employee.__doc__)</span><br></pre></td></tr></table></figure>docstrings.py代码如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Module documentation</span></span><br><span class="line"><span class="string">Words Go Here</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">spam = <span class="number">40</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    function documentation</span></span><br><span class="line"><span class="string">    can we have your liver then?</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span> <span class="comment"># square</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    <span class="string">&quot;class documentation&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(square(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(square.__doc__)</span><br></pre></td></tr></table></figure></li><li>内置文档字符串Built-in docstrings：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.__doc__)</span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount.__doc__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.__doc__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>.__doc__)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>PyDoc：help函数</p><ul><li>标准的PyDoc工具是一段Python程序，用于提取文档字符串及相关的结构化信息；</li><li>最主要的PyDoc接口是内置的help函数同PyDoc基于GUI和基于Web的HTML报告接口：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">help</span>(sys.getrefcount)</span><br><span class="line"><span class="built_in">help</span>(sys) <span class="comment"># 按空格键移动到下一页，按回车键移动到下一行，按Q键退出</span></span><br></pre></td></tr></table></figure></li><li>help也可以传入内置函数、方法以及类型名称：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span>(<span class="built_in">str</span>.replace)</span><br><span class="line"><span class="built_in">help</span>(<span class="string">&#x27;&#x27;</span>.replace)</span><br></pre></td></tr></table></figure></li><li>help函数也可以用于自己的模块：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> docstrings</span><br><span class="line"><span class="built_in">help</span>(docstrings.square)</span><br><span class="line"><span class="built_in">help</span>(docstrings.Employee)</span><br><span class="line"><span class="built_in">help</span>(docstrings)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>PyDoc：HTML报告</p><ul><li>PyDoc的全浏览器模式，可以通过开始菜单中的模块文档启动（Python 3.10 Module Docs (64-bit)）；也可以通过命令行<code>pydoc -g</code>启动；可以任意选择下面三种命令：<br><code>c:\code&gt; python -m pydoc -b</code><br><code>c:\code&gt; py -m pydoc -b</code><br><code>c:\code&gt; C:\python33\python -m pydoc -b</code>  </li></ul></li><li><p>Sphinx：更强大的方式为python系统编写文档<br>详见<a href="http://sphinx-doc.org">http://sphinx-doc.org</a></p></li><li><p>标准手册集The Standard Manual Set</p><ul><li>可以通过开始菜单中的Python 3.10 Manuals (64-bit)启动；</li><li>也可以从IDLE的help选项菜单中打开；</li><li>还可以从<a href="http://www.python.org">http://www.python.org</a> 官方网站获取</li></ul></li></ol><h1 id="PART-IV-Functions-and-Generators"><a href="#PART-IV-Functions-and-Generators" class="headerlink" title="PART IV Functions and Generators"></a>PART IV Functions and Generators</h1><h2 id="chapter-16-Function-Basics"><a href="#chapter-16-Function-Basics" class="headerlink" title="chapter 16 Function Basics"></a>chapter 16 Function Basics</h2><h3 id="一、Coding-Functions"><a href="#一、Coding-Functions" class="headerlink" title="一、Coding Functions"></a>一、Coding Functions</h3><ol><li><p>函数相关的语句和表达式</p><ul><li><code>def</code>创建了一个函数对象并将其赋值给了某一变量名；</li><li><code>lambda</code>创建一个函数对象并将其作为结果返回，见第19章；</li><li><code>return</code>将一个结果对象传回给调用者，默认返回None；</li><li><code>yield</code>向调用者发回一个结果对象，并挂起它们的状态；</li><li><code>global</code>声明了一个模块级的可被赋值的变量；</li><li><code>nonlocal</code>声明了一个需要被赋值的外层函数变量；</li><li>参数通过赋值(对象引用)传递给函数，除非你显式指明形式参数与实际参数的对应，否则实际参数按位置赋值给形式参数。参数、返回值与变量不需要被声明。</li></ul></li><li><p>def语句</p><ul><li>一般格式一下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">arg1, arg2,... argN</span>):</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure></li><li>def的头部定义了被赋值函数对象的函数名，圆括号parentheses中包含了<strong>形式参数arguments (sometimes called parameters)</strong>，简称<strong>形参</strong>；</li><li>在函数调用时，括号内的传入对象将赋值给头部的形式参数；</li><li>Python的return语句将结束函数调用并把结果返回至函数调用处，return语句是可选的，一个没有返回值的函数自动返回None对象；</li><li>可以将函数赋值给一个不同的变量名，并通过新的变量名进行调用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">othername = func</span><br><span class="line">othername()</span><br></pre></td></tr></table></figure></li><li>函数也是对象，在程序运行时被明确地记录在内存中。除了调用以外，函数允许将任意属性附加到其中以供之后使用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(): ... </span><br><span class="line">func() </span><br><span class="line">func.attr = value</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="二、A-First-Example-Definitions-and-Calls"><a href="#二、A-First-Example-Definitions-and-Calls" class="headerlink" title="二、A First Example: Definitions and Calls"></a>二、A First Example: Definitions and Calls</h3><ol><li><p>定义Definition</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">times</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br></pre></td></tr></table></figure></li><li><p>调用Calls</p><ul><li>参数是通过赋值传入的，函数头部的形式参数x被赋值为2，y被赋值为4：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(times(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(times(<span class="string">&#x27;Ni&#x27;</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure></li><li><em>函数体（嵌套在函数定义语句中的代码）在函数被一个调用表达式调用时才会执行</em>；</li><li>不调用是不执行函数体的，可以试试def一个有错误的函数，不调用它去运行。</li></ul></li><li><p>Python中的<strong>多态Polymorphism</strong></p><ul><li>如上所示，times函数中表达式x<em>y完全取决于x和y的对象类型，这种依赖类型的行为称为<em>*多态Polymorphism</em></em>；</li><li>函数可以自动地应用到所有类别的对象上。只要对象支持所预期的接口（也称为协议，即预期的方法和表达式运算符），函数就能处理它们；</li><li>从宏观上来说，Python为对象接口object interfaces编程，不是为数据类型编程。</li></ul></li></ol><h3 id="三、A-Second-Example-Intersecting-Sequences"><a href="#三、A-Second-Example-Intersecting-Sequences" class="headerlink" title="三、A Second Example: Intersecting Sequences"></a>三、A Second Example: Intersecting Sequences</h3><ol><li><p>定义</p><ul><li>将代码封装<strong>package</strong>（或者<strong>wrap</strong>）在函数中：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">intersect</span>(<span class="params">seq1, seq2</span>):</span><br><span class="line">    res = [] </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> seq1: </span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> seq2: </span><br><span class="line">            res.append(x) </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ul></li><li><p>调用</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">&quot;SPAM&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;SCAM&quot;</span></span><br><span class="line"><span class="built_in">print</span>(intersect(s1, s2))</span><br></pre></td></tr></table></figure></li><li><p>多态</p><ul><li>对于intersect函数，只要第一个参数支持for循环，第二个参数支持in成员测试，就能正常工作：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = intersect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>局部变量Local Variables</strong></p><ul><li>intersect函数中的res变量在Python中被称为局部变量，仅在函数运行时存在；</li><li>在函数内部进行赋值的变量名都默认为<strong>局部变量</strong>；</li><li>res被赋值过，所以是局部变量；参数也是通过赋值被传入的，所以seq1和seq2也是局部变量；for循环中的变量x也是局部变量；</li><li>所有的局部变量在函数调用时出现，在函数退出时消失。详见第17章。</li></ul></li></ol><h2 id="chapter-17-Scopes"><a href="#chapter-17-Scopes" class="headerlink" title="chapter 17 Scopes"></a>chapter 17 Scopes</h2><h3 id="一、Python-Scope-Basics"><a href="#一、Python-Scope-Basics" class="headerlink" title="一、Python Scope Basics"></a>一、Python Scope Basics</h3><ol><li><p>Python作用域基础</p><ul><li>Python创建、改变或查找变量名都是在所谓的<strong>命名空间namespace</strong>中进行的，<strong>作用域scope</strong>就是命名空间；</li><li>在代码中给一个变量赋值的地方决定了这个变量将存在于哪个命名空间；</li><li>一个函数内赋值的所有变量名都与该函数的命名空间相关联；</li><li>在def内赋值的变量名与在def外赋值的变量名不冲突，即使是相同的变量名。</li><li>变量可以在3个不同的地方被赋值，分别对应3种不同的作用域：<ul><li>If a variable is assigned inside a def, it is <strong>local</strong> to that function.</li><li>If a variable is assigned in an enclosing def, it is <strong>nonlocal</strong> to nested functions.</li><li>If a variable is assigned outside all defs, it is <strong>global</strong> to the entire file.</li></ul></li><li>我们将其称为语义作用域lexical scoping，因为变量的作用域由源代码的位置决定，而不是由函数调用决定：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">99</span> <span class="comment"># Global (module) scope X</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    X = <span class="number">88</span> <span class="comment"># Local (function) scope X: a different variable</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>作用域细节<br>函数提供了嵌套的命名空间（作用域），使其内部使用的变量名局部化。而模块定义了全局作用域。</p></li><li><p>变量名解析Name Resolution：<strong>LEGB机制</strong></p><ul><li>在默认情况下，变量名赋值会创建或改变局部变量；</li><li>变量名引用至多在4种作用域内查找：<em>先局部local，再外层的函数enclosing functions，再全局global，最后内置built-in（这四个就是LEGB）</em>；</li><li>使用<code>global</code>和<code>nonlocal</code>语句声明的名称将赋值的变量名分别映射到外围的模块和函数的作用域；</li><li>所有在函数def语句内赋值的变量名默认均为局部变量。函数能够任意使用在外层函数内或全局作用域中的变量名，但必须声明为非局部变量和全局变量来改变其属性。</li></ul></li><li><p>作用域实例</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">99</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">Y</span>):</span><br><span class="line">    Z = X + Y</span><br><span class="line">    <span class="keyword">return</span> Z</span><br><span class="line"><span class="built_in">print</span>(func(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><ul><li>全局变量名：X，func；局部变量名：Y，Z。</li><li>当函数调用结束时，局部变量会从内存中移除。</li></ul></li><li><p>内置作用域The Built-in Scope</p><ul><li>内置作用域仅仅是一个名为<code>builtins</code>的内置模块，要导入builtins才能使用内置作用域：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(builtins))</span><br></pre></td></tr></table></figure></li><li>这个列表中的变量名组成了python中的内置作用域。前一半是内置的异常，后一半是内置函数；</li><li>Python会在LEGB查找中的最后自动查找这个模块；</li><li>因此有2种方式引用一个内置函数：利用LEGB法则，或者手动导入builtins模块：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">zip</span>)</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="built_in">print</span>(builtins.<span class="built_in">zip</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">zip</span> <span class="keyword">is</span> builtins.<span class="built_in">zip</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>不要重定义内置名称</p><ul><li>由于LEGB查找的流程，会使它在第一处找到变量名的地方生效。</li><li>在局部作用域中的变量名可能会覆盖在全局作用域和内置作用域中有着相同变量名的变量，而全局变量名可能会覆盖内置的变量名：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hider</span>():</span><br><span class="line">    <span class="built_in">open</span> = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">    <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 这样的话，open在函数内就不能打开文件了</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="二、The-global-Statement"><a href="#二、The-global-Statement" class="headerlink" title="二、The global Statement"></a>二、The global Statement</h3><ol><li><p>global语句</p><ul><li>全局变量是在外层模块文件的顶层被赋值的变量名；</li><li>全局变量如果是在函数内被赋值的话，必须经过声明；</li><li>全局变量名在函数的内部不经过声明也可以被引用。</li><li>global允许我们修改一个def外的模块文件顶层的名称；nonlocal适用于外层def的局部作用域内的名称：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">88</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> X</span><br><span class="line">    X = <span class="number">99</span> <span class="comment"># Global X: outside def</span></span><br><span class="line">func()</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line">y, z = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">all_global</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x = y + z</span><br><span class="line"><span class="comment"># 上面x、y、z都是all_global函数内的全局变量</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在Python中使用多线程Multithreading进行并行计算的程序也要依赖全局变量</p><ul><li>因为全局变量在并行线程中在不同的函数之间成为共享内存；</li><li>多线程与程序的其余部分并行地执行函数调用，由Python的标准库模块_thread、threading和queue提供支持。多线程不在本书探讨内容，详见其他书籍。</li></ul></li><li><p>其他访问全局变量的方法</p><ul><li>一个模块文件的全局作用域一旦被导入就成了这个模块对象的一个属性命名空间：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># thismod.py</span></span><br><span class="line">var = <span class="number">99</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">local</span>():</span><br><span class="line">    var = <span class="number">0</span> <span class="comment"># 局部变量，不改变全局的var</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">glob1</span>():</span><br><span class="line">    <span class="keyword">global</span> var</span><br><span class="line">    var += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">glob2</span>():</span><br><span class="line">    var = <span class="number">0</span> <span class="comment"># 局部变量，不改变全局的var</span></span><br><span class="line">    <span class="keyword">import</span> thismod <span class="comment"># 导入自己</span></span><br><span class="line">    thismod.var += <span class="number">1</span> <span class="comment"># 改变全局变量var</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">glob3</span>():</span><br><span class="line">    var = <span class="number">0</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    glob = sys.modules[<span class="string">&#x27;thismod&#x27;</span>] <span class="comment"># 得到模组对象</span></span><br><span class="line">    glob.var += <span class="number">1</span> <span class="comment"># 改变全局变量var</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(var)</span><br><span class="line">    local(); glob1(); glob2(); glob3()</span><br><span class="line">    <span class="built_in">print</span>(var)</span><br></pre></td></tr></table></figure></li><li>可以通过导入外层模块并对其属性进行赋值来模拟global语句，见thismod.py的glob2()、glob3()函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> thismod</span><br><span class="line">thismod.test()</span><br><span class="line"><span class="built_in">print</span>(thismod.var)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、Scopes-and-Nested-Functions"><a href="#三、Scopes-and-Nested-Functions" class="headerlink" title="三、Scopes and Nested Functions"></a>三、Scopes and Nested Functions</h3><ol><li><p>嵌套作用域Nested Scope</p><ul><li>接下来深入学习LEGB查找规则中的E，即任意外层函数局部作用域的形式：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">99</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    X = <span class="number">88</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="built_in">print</span>(X)</span><br><span class="line">    f2() <span class="comment"># f2是一个临时函数，仅在f1内部执行的过程中存在</span></span><br><span class="line">f1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    X = <span class="number">88</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        <span class="built_in">print</span>(X)</span><br><span class="line">    <span class="keyword">return</span> f2 <span class="comment"># Return f2 but don&#x27;t call it</span></span><br><span class="line">action = f1()</span><br><span class="line">action()</span><br></pre></td></tr></table></figure></li><li>对action名称的调用本质上运行了f1运行时我们命名为f2的函数；</li><li>因为Python中的函数与其他一切一样是对象，因此可以作为其他函数的返回值传递回来；</li><li>f2也记住了f1的嵌套作用域中的X，尽管f1已经不处于激活状态，详见下面。</li></ul></li><li><p><strong>工厂函数Factory Functions：闭包Closures</strong></p><ul><li>这种代码行为可以叫做<strong>Closures</strong>，也可以<strong>Factory Functions</strong>；</li><li>即函数对象能够记忆外层作用域里的值，不管嵌套作用域是否还在内存中存在：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maker</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">action</span>(<span class="params">X</span>): </span><br><span class="line">        <span class="keyword">return</span> X ** N </span><br><span class="line">    <span class="keyword">return</span> action</span><br></pre></td></tr></table></figure></li><li>上面定义了一个外层函数，用来生成并返回一个嵌套的函数，却不调用这个内嵌的函数；</li><li>maker创造出action，但只是简单地返回action而不执行它。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = maker(<span class="number">2</span>) <span class="comment"># 调用maker函数，执行maker内的代码，创建了action函数，并返回action函数</span></span><br><span class="line"><span class="built_in">print</span>(f)</span><br></pre></td></tr></table></figure></li><li>f是生成的内嵌函数即action的一个引用，因为是return action，maker函数创建并返回action函数。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(f(<span class="number">3</span>)) <span class="comment"># f(3)调用action函数，将3传递进X，返回3**2</span></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">4</span>))</span><br></pre></td></tr></table></figure></li><li>上面调用了maker函数创建的并传回的一个内嵌函数。这里不平常的地方在于，在调用action时，maker已经退出，但是内嵌的函数记住了整数2。实际上，在外层嵌套局部作用域内的N被作为执行的状态信息保留了下来，并附加到生成的action函数上。如果再调用外层的函数，可以得到一个新的有不同状态信息的嵌套函数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = maker(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(g(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">4</span>))</span><br></pre></td></tr></table></figure></li><li>名称g的函数记住了3，名称f的函数记住了2；每个函数都有自己的状态信息state information。</li><li>上述是一种相对高级的技术，在代码中不太常见；另外嵌套作用域常常被lambda函数创建表达式利用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maker</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> X: X ** N</span><br><span class="line">h = maker(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(h(<span class="number">4</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>闭包vs类</p><ul><li>类是一个更好的实现这种状态记忆的选择，因为它们用属性赋值来更加显式地创建它们的内存；</li><li>当记忆状态是唯一目标时，闭包函数经常提供一个轻量级的可行的替代方案；</li><li>它为每一次调用提供局部化存储空间，来存储一个单独的内嵌函数所需的数据；</li><li>nonlocal语句允许嵌套作用域状态改变；</li><li>当class嵌套在def中，闭包也可以被创建，详见第29章关于嵌套类的说明。</li></ul></li><li><p>使用默认值参数defaults,来保存外层作用域的状态</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    x = <span class="number">88</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">x=x</span>):</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    f2()</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><ul><li>x=x意味着参数x会默认使用外层作用域中x的值，由于第二个x在python进入内嵌的def之前就已经完成其求值，仍引用f1中的x；实际上嵌套作用域查找规则之所以加入到python中就是为了让默认值参数不再扮演这种角色；所以无需x=x，因为python会自动记住所需要的外层作用域的任意值，从而在内嵌的def中使用。</li><li>避免在def中嵌套def，会让程序更简单：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    x = <span class="number">88</span></span><br><span class="line">    f2(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">f1()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>嵌套作用域，lambda</p><ul><li><code>lambda</code>表达式也为其创建的函数引入新的局部作用域：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    x = <span class="number">4</span></span><br><span class="line">    action = (<span class="keyword">lambda</span> n: x ** n)</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">x = func()</span><br><span class="line"><span class="built_in">print</span>(x(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>循环变量可能需要默认值参数，而不是作用域</p><ul><li>如果在函数中定义的lambda或者def嵌套在一个循环之中，而这个内嵌函数又引用了一个外层作用域的变量，该变量被循环所改变，那么所有在这个循环中产生的函数会有相同的值，也就是最后一次循环中完成时被引用变量的值。在这种情形下，需要使用默认值参数来保存变量的当前值：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">makeActions</span>():</span><br><span class="line">    acts = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>): <span class="comment"># Tries to remember each i</span></span><br><span class="line">        acts.append(<span class="keyword">lambda</span> x: i ** x)</span><br><span class="line">    <span class="keyword">return</span> acts</span><br><span class="line"></span><br><span class="line">T = makeActions()</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>运行结果如下为<code>&lt;function makeActions.&lt;locals&gt;.&lt;lambda&gt; at 0x0000020EEE2D9F30&gt;</code></li><li>上面的代码会出问题：因为外层作用域中的变量在嵌套的函数被调用时才进行查找，而此时i=4。所以它们实际上记住的是同样的值，也就是最后一次循环迭代中循环变量的值。所以当下面的所有调用传入底数2时，列表中每个结果都是2的4次方：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(T[<span class="number">0</span>](<span class="number">2</span>)) <span class="comment"># 因为acts列表里面都是lambda函数，所以要先索引再传递参数</span></span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">1</span>](<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">2</span>](<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">3</span>](<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">4</span>](<span class="number">2</span>))</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure></li><li>为了让这类代码能够工作，必须使用默认值参数来传入当前外层作用域中的值。因为默认值参数的求值是在嵌套函数创建时就发生的（而不是该函数之后被调用时），所以每一个函数都记住了属于自己的变量i：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">makeActions</span>():</span><br><span class="line">    acts = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        acts.append(<span class="keyword">lambda</span> x, i=i: i ** x)</span><br><span class="line">    <span class="keyword">return</span> acts</span><br><span class="line"></span><br><span class="line">T = makeActions()</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">0</span>](<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">1</span>](<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">2</span>](<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">3</span>](<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">4</span>](<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li><li>更详细见第18章对默认值参数和第19章对lambda的介绍。</li></ul></li></ol><h3 id="四、The-nonlocal-Statement"><a href="#四、The-nonlocal-Statement" class="headerlink" title="四、The nonlocal Statement"></a>四、The nonlocal Statement</h3><ol><li><p>nonlocal语句</p><ul><li><code>nonlocal</code>语句可以使内嵌的def对外层函数中的名称进行读取和写入访问；</li><li><code>nonlocal</code>语句通过提供可改写的状态信息，让嵌套作用域闭包变得更加有用；</li><li>声明nonlocal名称的时候，必须以及存在于该外层函数的作用域中，不能由内嵌def中的第一次赋值来创建。</li></ul></li><li><p>nonlocal基础</p><ul><li><code>nonlocal</code>语句除了允许修改外层def中的名称外，还会强制引用的发起。nonlocal使得对该语句列出的名称的查找从外层的def的作用域开始，而不是从该函数的局部作用域开始。当执行到nonlocal语句时，nonlocal中列出的名称必须在一个外层的def中被提前定义过，否则将引发一个错误；</li><li>nonlocal将作用域查找限制为只在外层的def中，不会继续进入到全局或内置作用域。</li></ul></li><li><p>nonlocal应用</p><ul><li>下面代码中，tester创建并返回函数nested以便随后调用，而nested中的state引用遵从常规的作用域查找规则：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tester</span>(<span class="params">start</span>):</span><br><span class="line">    state = start</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nested</span>(<span class="params">label</span>):</span><br><span class="line">        <span class="built_in">print</span>(label, state)</span><br><span class="line">    <span class="keyword">return</span> nested</span><br><span class="line"></span><br><span class="line">F = tester(<span class="number">0</span>)</span><br><span class="line">F(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">F(<span class="string">&#x27;ham&#x27;</span>)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spam <span class="number">0</span></span><br><span class="line">ham <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li>使用nonlocal进行修改，即使通过名称F调用返回的nested函数时，tester已经返回并退出了，这也是有效的：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tester</span>(<span class="params">start</span>):</span><br><span class="line">    state = start</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nested</span>(<span class="params">label</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> state <span class="comment"># state，即nonlocal名称必须在外层def作用域中被赋值过，否则会得到一个错误。在全局作用域被赋值也会错误。</span></span><br><span class="line">        <span class="built_in">print</span>(label, state)</span><br><span class="line">        state += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nested</span><br><span class="line"></span><br><span class="line">F = tester(<span class="number">0</span>)</span><br><span class="line">F(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">F(<span class="string">&#x27;ham&#x27;</span>)</span><br><span class="line">F(<span class="string">&#x27;eggs&#x27;</span>)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spam <span class="number">0</span></span><br><span class="line">ham <span class="number">1</span></span><br><span class="line">eggs <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li>可以多次调用tester工厂（闭包）函数，以便在内存中获得其状态的多个副本：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G = tester(<span class="number">42</span>)</span><br><span class="line">G(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">G(<span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line">F(<span class="string">&#x27;bacon&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="五、Why-nonlocal-State-Retention-Options"><a href="#五、Why-nonlocal-State-Retention-Options" class="headerlink" title="五、Why nonlocal? - State Retention Options"></a>五、Why nonlocal? - State Retention Options</h3><ol><li><p>为什么选nonlocal<br>nonlocal增强了对外层作用域的引用：允许在内存中保持可更改状态的多个副本。</p></li><li><p>全局变量的状态：只有一个副本</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tester</span>(<span class="params">start</span>):</span><br><span class="line">    <span class="keyword">global</span> state </span><br><span class="line">    state = start </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nested</span>(<span class="params">label</span>):</span><br><span class="line">        <span class="keyword">global</span> state</span><br><span class="line">        <span class="built_in">print</span>(label, state)</span><br><span class="line">        state += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nested</span><br><span class="line"></span><br><span class="line">F = tester(<span class="number">0</span>)</span><br><span class="line">F(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">F(<span class="string">&#x27;eggs&#x27;</span>)</span><br></pre></td></tr></table></figure><p> 运行结果如下：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spam <span class="number">0</span></span><br><span class="line">eggs <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>上述代码可能会引起全局作用域的名称冲突，并且只允许模块作用域中保存状态信息的单个共享副本；</li><li>如果再次调用tester，将会重置模块的state变量，而先前的调用的state会被覆盖：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G = tester(<span class="number">42</span>)</span><br><span class="line">G(<span class="string">&#x27;toast&#x27;</span>)</span><br><span class="line">G(<span class="string">&#x27;bacon&#x27;</span>)</span><br><span class="line">F(<span class="string">&#x27;ham&#x27;</span>)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">toast <span class="number">42</span></span><br><span class="line">bacon <span class="number">43</span></span><br><span class="line">ham <span class="number">44</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>类的状态：显式属性（预习）</p><ul><li>同嵌套函数和nonlocal一样，类支持所保存的数据存在多个副本：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tester</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start</span>):</span><br><span class="line">        self.state = start</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nested</span>(<span class="params">self, label</span>):</span><br><span class="line">        <span class="built_in">print</span>(label, self.state)</span><br><span class="line">        self.state += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">F = tester(<span class="number">0</span>)</span><br><span class="line">F.nested(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">F.nested(<span class="string">&#x27;ham&#x27;</span>)</span><br><span class="line"></span><br><span class="line">G = tester(<span class="number">42</span>)</span><br><span class="line">G.nested(<span class="string">&#x27;toast&#x27;</span>)</span><br><span class="line">G.nested(<span class="string">&#x27;bacon&#x27;</span>)</span><br><span class="line">F.nested(<span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(F.state)</span><br></pre></td></tr></table></figure></li><li>预习：运算符重载把类对象用作可调用函数。<strong>call</strong>拦截了一个实例上的直接调用，因此无需调用方法（详见第30章）：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tester</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start</span>):</span><br><span class="line">        self.state = start</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, label</span>): </span><br><span class="line">        <span class="built_in">print</span>(label, self.state) </span><br><span class="line">        self.state += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">H = tester(<span class="number">99</span>)</span><br><span class="line">H(<span class="string">&#x27;juice&#x27;</span>)</span><br><span class="line">H(<span class="string">&#x27;pancakes&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数属性Function Attributes</strong>的状态</p><ul><li>可以使用函数属性来达到与nonlocal相同的效果。函数属性允许状态变量从内嵌函数的外部被访问，就像类属性那样（内嵌函数的属性必须在内嵌的def之后初始化）：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tester</span>(<span class="params">start</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nested</span>(<span class="params">label</span>):</span><br><span class="line">        <span class="built_in">print</span>(label, nested.state)</span><br><span class="line">        nested.state += <span class="number">1</span></span><br><span class="line">    nested.state = start <span class="comment"># 因为要先定义内嵌函数nested()，否则nested.state的nested函数就没有来源</span></span><br><span class="line">    <span class="keyword">return</span> nested</span><br><span class="line"></span><br><span class="line">F = tester(<span class="number">0</span>)</span><br><span class="line">F(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line">F(<span class="string">&#x27;ham&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(F.state)</span><br></pre></td></tr></table></figure></li><li>也支持调用多个副本：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G = tester(<span class="number">42</span>)</span><br><span class="line">G(<span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line">F(<span class="string">&#x27;ham&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(G.state)</span><br><span class="line"><span class="built_in">print</span>(F <span class="keyword">is</span> G)</span><br></pre></td></tr></table></figure></li><li>函数属性详见第19章。</li></ul></li><li><p>可变对象State with mutables的状态</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tester</span>(<span class="params">start</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nested</span>(<span class="params">label</span>):</span><br><span class="line">        <span class="built_in">print</span>(label, state[<span class="number">0</span>])</span><br><span class="line">        state[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">    state = [start]</span><br><span class="line">    <span class="keyword">return</span> nested</span><br></pre></td></tr></table></figure><ul><li>这里利用了列表的可变性，而且与函数属性一样依赖于原位置对象修改不会将一个名称归类为局部。</li></ul></li></ol><h2 id="chapter-18-Arguments"><a href="#chapter-18-Arguments" class="headerlink" title="chapter 18 Arguments"></a>chapter 18 Arguments</h2><h3 id="一、Argument-Passing-Basics"><a href="#一、Argument-Passing-Basics" class="headerlink" title="一、Argument-Passing Basics"></a>一、Argument-Passing Basics</h3><ol><li><p>参数传递基础</p><ul><li>参数的传递是通过自动将对象赋值给局部变量名来实现，参数都是通过指针传入的；</li><li>在函数内部赋值参数名不会影响调用者作用域的变量；</li><li>改变函数的可变对象也许会对调用者有影响。</li></ul></li><li><p>参数和共享引用</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a</span>):</span><br><span class="line">    a = <span class="number">99</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">b = <span class="number">88</span></span><br><span class="line">f(b)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><ul><li>上述，在f(b)调用函数的时候，变量a被赋值了对象88；</li><li>但是a只存在于被调用的函数之中，在被调函数中修改a（即a=99）对于主动调用函数的地方没有影响。</li></ul></li><li><p>可变对象的原位置修改</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">changer</span>(<span class="params">a, b</span>):</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br><span class="line">X = <span class="number">1</span></span><br><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">changer(X, L)</span><br><span class="line"><span class="built_in">print</span>(X, L)</span><br></pre></td></tr></table></figure><ul><li>L和b引用了相同对象。</li></ul></li><li><p>避免修改可变参数</p><ul><li>可以通过<code>list.copy</code>或者无参数切片，来复制列表，创建一个副本：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">changer(X, L[:])</span><br><span class="line"><span class="built_in">print</span>(X, L)</span><br><span class="line"><span class="comment"># 或者在函数内部复制</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changer</span>(<span class="params">a, b</span>):</span><br><span class="line">    b = b[:]</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">&#x27;spam&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="二、Special-Argument-Matching-Modes"><a href="#二、Special-Argument-Matching-Modes" class="headerlink" title="二、Special Argument-Matching Modes"></a>二、Special Argument-Matching Modes</h3><ol><li><p>特殊的参数匹配模式<br>默认情况下，参数按照从左到右的位置进行匹配。也可以通过<em>形式参数名</em>、<em>提供默认值的参数值</em>和<em>对额外参数使用容器collectors</em>三种方法来指定匹配。</p></li><li><p>参数匹配基础</p><ul><li><strong>位置参数Positionals</strong>：从左到右；</li><li><strong>关键字参数Keywords</strong>：通过参数名进行匹配；</li><li><strong>默认值参数Defaults</strong>；</li><li><strong>可变长参数Varargs</strong>收集：收集任意多的基于位置或关键字的参数：<em>或*</em>开头的特殊参数；</li><li><strong>可变长参数Varargs解包unpacking</strong>：传入任意多的基于位置或关键字的参数。</li></ul></li><li><p>参数匹配语法</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">Syntax</th><th style="text-align:left">Location</th><th style="text-align:left">Interpretation</th></tr></thead><tbody><tr><td style="text-align:left">func(value)</td><td style="text-align:left">调用</td><td style="text-align:left">常规参数：位置匹配</td></tr><tr><td style="text-align:left">func(name=value)</td><td style="text-align:left">调用</td><td style="text-align:left">关键字参数：名称匹配</td></tr><tr><td style="text-align:left">func(*iterable)</td><td style="text-align:left">调用</td><td style="text-align:left">将iterable中所有对象作为独立的基于位置的参数传入</td></tr><tr><td style="text-align:left">func(**dict)</td><td style="text-align:left">调用</td><td style="text-align:left">将dict中所有的键/值对作为独立的关键字参数传入</td></tr><tr><td style="text-align:left">def func(name)</td><td style="text-align:left">函数定义</td><td style="text-align:left">常规参数：位置或名称匹配</td></tr><tr><td style="text-align:left">def func(name=value)</td><td style="text-align:left">函数定义</td><td style="text-align:left">默认值参数</td></tr><tr><td style="text-align:left">def func(*name)</td><td style="text-align:left">函数定义</td><td style="text-align:left">将剩下的基于位置的参数匹配并收集到一个元组中</td></tr><tr><td style="text-align:left">def func(**name)</td><td style="text-align:left">函数定义</td><td style="text-align:left">将剩下的关键字参数匹配并收集到一个字典中</td></tr><tr><td style="text-align:left">def func(*other, name)</td><td style="text-align:left">函数定义</td><td style="text-align:left">在调用中必须通过关键字传入的参数</td></tr><tr><td style="text-align:left">def func(*, name=value)</td><td style="text-align:left">函数定义</td><td style="text-align:left">在调用中必须通过关键字传入的参数</td></tr></tbody></table></div><ol><li><p>更深入的细节</p><ul><li>如果组合使用特殊参数匹配模式，需遵循下面顺序规则：<ul><li><em>函数调用的参数顺序：位置参数；关键字参数；</em>iterable形式的组合；<em>*dict形式</em>；</li><li><em>函数定义的参数顺序：一般参数；默认值参数；</em>name；keyword-only参数；<em>*name</em>。</li></ul></li><li>Python内部大致是使用以下的步骤来赋值前匹配参数的：<ul><li>通过位置分配物关键字参数；</li><li>通过匹配名称分配关键字参数；</li><li>将剩下的非关键字参数分配到*name元组中；</li><li>将剩下的关键字参数分配到**name字典中；</li><li>把默认值分配给在头部未得到匹配的参数。</li></ul></li><li>函数头部可以有个<em>注解值annotation values</em>，其指定形式为name:value，详见第19章函数注解。</li></ul></li><li><p>关键字参数和默认值参数的示例</p><ul><li>位置参数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, c</span>): <span class="built_in">print</span>(a, b, c)</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li>关键字参数Keywords：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(c=<span class="number">3</span>, b=<span class="number">2</span>, a=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li>混用位置参数和关键字参数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, c=<span class="number">3</span>, b=<span class="number">2</span>) <span class="comment"># 只能先位置参数再关键字参数</span></span><br></pre></td></tr></table></figure></li><li>默认值参数Defaults：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b=<span class="number">2</span>, c=<span class="number">3</span></span>): <span class="built_in">print</span>(a, b, c)</span><br><span class="line">f(<span class="number">1</span>)</span><br><span class="line">f(a=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li>当函数传递2个值时，只有c得到默认值，当且仅当3个值传递时，不会使用默认值：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">f(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li><li>关键字参数和默认值参数混用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>, c=<span class="number">6</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>混合使用关键字参数和默认值参数</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">spam, eggs, toast=<span class="number">0</span>, ham=<span class="number">0</span></span>):</span><br><span class="line">    <span class="built_in">print</span>((spam, eggs, toast, ham))</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">func(<span class="number">1</span>, ham=<span class="number">1</span>, eggs=<span class="number">0</span>) </span><br><span class="line">func(spam=<span class="number">1</span>, eggs=<span class="number">0</span>) </span><br><span class="line">func(toast=<span class="number">1</span>, eggs=<span class="number">2</span>, spam=<span class="number">3</span>) </span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><ul><li>如果默认值参数是一个可变对象（比如def f(a=[])）。这个参数会保留上次调用的值，详见第21章陷阱。</li></ul></li><li><p>可变长参数Arbitrary Arguments的实例</p><ul><li><strong>*</strong> 和 <strong>**</strong> 旨在让函数支持接受任意多的参数：</li><li>(1) 函数定义：收集参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">*args</span>): <span class="built_in">print</span>(args)</span><br><span class="line"><span class="comment"># &quot;*&quot;将所有基于位置的参数收集到新的元组</span></span><br><span class="line">f()</span><br><span class="line">f(<span class="number">1</span>)</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># &quot;**&quot;将关键字参数收集到一个新的字典中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">**args</span>): <span class="built_in">print</span>(args)</span><br><span class="line">f()</span><br><span class="line">f(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 混用&quot;*&quot;和&quot;**&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, *pargs, **kargs</span>): <span class="built_in">print</span>(a, pargs, kargs)</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, x=<span class="number">1</span>, y=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">()</span><br><span class="line">(<span class="number">1</span>,)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="number">1</span> (<span class="number">2</span>, <span class="number">3</span>) &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></li><li>(2) 函数调用：解包参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, c, d</span>): <span class="built_in">print</span>(a, b, c, d)</span><br><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">args += (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">func(*args) <span class="comment"># Same as func(1, 2, 3, 4) 解包参数</span></span><br><span class="line"><span class="comment"># 上面不能直接func(args) 因为它会以为整个（1，2，3，4）都是a，就没有b、c、d了</span></span><br><span class="line">args = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">args[<span class="string">&#x27;d&#x27;</span>] = <span class="number">4</span></span><br><span class="line">func(**args) <span class="comment"># Same as func(a=1, b=2, c=3, d=4) 解包键值对</span></span><br><span class="line"><span class="comment"># 混用</span></span><br><span class="line">func(*(<span class="number">1</span>, <span class="number">2</span>), **&#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;)</span><br><span class="line">func(<span class="number">1</span>, *(<span class="number">2</span>, <span class="number">3</span>), **&#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;)</span><br><span class="line">func(<span class="number">1</span>, c=<span class="number">3</span>, *(<span class="number">2</span>,), **&#123;<span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;)</span><br><span class="line">func(<span class="number">1</span>, *(<span class="number">2</span>,), c=<span class="number">3</span>, **&#123;<span class="string">&#x27;d&#x27;</span>:<span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></li><li>注意1，在调用时的*pargs形式是一个迭代上下文，接受迭代工具，解包参数；但在头部中的*pargs，只是将额外参数绑定到一个元组；</li><li>注意2，<strong>扩展序列解包</strong>（注意区分）赋值创建列表而非元组：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x, *y = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(x, y)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s [<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>keyword-only参数</p><ul><li><code>keyword-only参数</code>为出现在*args之后的参数，必须使用关键字语法调用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">kwonly</span>(<span class="params">a, *b, c</span>): <span class="built_in">print</span>(a, b, c) <span class="comment"># 这里的c因为在*b后面，所以只能使用关键字参数</span></span><br><span class="line">kwonly(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><em>可以在参数列表中使用一个”</em>“字符，使之后的参数只能作为关键字参数传入*：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">kwonly</span>(<span class="params">a, *, b, c</span>): <span class="built_in">print</span>(a, b, c)</span><br><span class="line">kwonly(<span class="number">1</span>, c=<span class="number">3</span>, b=<span class="number">2</span>)</span><br><span class="line">kwonly(c=<span class="number">3</span>, b=<span class="number">2</span>, a=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>顺序规则</p><ul><li>有名参数不能出现在**args的后面，**也不能单独出现在参数列表中，这2种做法都会产生语法错误；</li><li>也就是<em>顺序必须是参数（位置或关键字），\</em>args，keyword-only参数，**args*：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, *b, c=<span class="number">6</span>, **d</span>): <span class="built_in">print</span>(a, b, c, d)</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, x=<span class="number">4</span>, y=<span class="number">5</span>)</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, x=<span class="number">4</span>, y=<span class="number">5</span>, c=<span class="number">7</span>)</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, c=<span class="number">7</span>, x=<span class="number">4</span>, y=<span class="number">5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, c=<span class="number">6</span>, *b, **d</span>): <span class="built_in">print</span>(a, b, c, d)</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, x=<span class="number">4</span>)</span><br></pre></td></tr></table></figure></li><li>在函数调用中也是类似的情况：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, *b, c=<span class="number">6</span>, **d</span>): <span class="built_in">print</span>(a, b, c, d)</span><br><span class="line">f(<span class="number">1</span>, *(<span class="number">2</span>, <span class="number">3</span>), **<span class="built_in">dict</span>(x=<span class="number">4</span>, y=<span class="number">5</span>))</span><br><span class="line">f(<span class="number">1</span>, *(<span class="number">2</span>, <span class="number">3</span>), c=<span class="number">7</span>, **<span class="built_in">dict</span>(x=<span class="number">4</span>, y=<span class="number">5</span>))</span><br><span class="line">f(<span class="number">1</span>, c=<span class="number">7</span>, *(<span class="number">2</span>, <span class="number">3</span>), **<span class="built_in">dict</span>(x=<span class="number">4</span>, y=<span class="number">5</span>))</span><br><span class="line">f(<span class="number">1</span>, *(<span class="number">2</span>, <span class="number">3</span>), **<span class="built_in">dict</span>(x=<span class="number">4</span>, y=<span class="number">5</span>, c=<span class="number">7</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="chapter-19-Advanced-Function-Topics"><a href="#chapter-19-Advanced-Function-Topics" class="headerlink" title="chapter 19 Advanced Function Topics"></a>chapter 19 Advanced Function Topics</h2><h3 id="一、Function-Design-Concepts"><a href="#一、Function-Design-Concepts" class="headerlink" title="一、Function Design Concepts"></a>一、Function Design Concepts</h3><ol><li>函数设计概念<ul><li>函数的内聚性cohesion：将任务分解成有目的性的函数；</li><li>函数的耦合性coupling：函数之间相互通信；</li><li>guidelines：<ul><li>耦合性：在输入时使用参数，输出时使用return语句；</li><li>耦合性：只在真正必要的情况下使用全局变量；</li><li>耦合性：不要改变可变类型的参数，除非调用者希望这么做；</li><li>内聚性：每一个函数都应该有一个单一的、统一的目标；</li><li>大小：每一个函数应该相对较小；</li><li>耦合性：避免直接改变其他模块文件中的变量。</li></ul></li></ul></li></ol><h3 id="二、Recursive-Functions"><a href="#二、Recursive-Functions" class="headerlink" title="二、Recursive Functions"></a>二、Recursive Functions</h3><ol><li><p>用递归求和（<strong>Recursive Functions递归函数</strong>）</p><ul><li>当以这种方式使用递归的时候，对于函数调用的每一个打开的层级来说，在运行时的调用栈上都有自己的一个函数局部作用域的副本，每个层级的L都是不同的：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mysum</span>(<span class="params">L</span>):</span><br><span class="line">    <span class="built_in">print</span>(L)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> L:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> L[<span class="number">0</span>] + mysum(L[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mysum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure></li><li>将上面函数分为2个：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mysum</span>(<span class="params">L</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> L: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> nonempty(L)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nonempty</span>(<span class="params">L</span>):</span><br><span class="line">    <span class="keyword">return</span> L[<span class="number">0</span>] + mysum(L[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mysum([<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>]))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>循环vs递归</p><ul><li>Python强调循环这样的简单过程式语句，循环语句更为自然；</li><li>while语句：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> L:</span><br><span class="line">    <span class="built_in">sum</span> += L[<span class="number">0</span>]</span><br><span class="line">    L = L[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure></li><li>for循环：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> L: <span class="built_in">sum</span> += x</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure></li><li>有了循环语句，就不需要在调用栈上为每次迭代都保留一个局部作用域的副本，并避免相关的开销（详见第21章计时器）。</li></ul></li><li><p>处理任意结构</p><ul><li>递归能够遍历任意结构，比如嵌套子列表结构：[1, [2, [3, 4], 5], 6, [7, 8]]<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumtree</span>(<span class="params">L</span>):</span><br><span class="line">    tot = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> L:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, <span class="built_in">list</span>):</span><br><span class="line">            tot += x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tot += sumtree(x)</span><br><span class="line">    <span class="keyword">return</span> tot</span><br><span class="line"></span><br><span class="line">L = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"><span class="built_in">print</span>(sumtree(L))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>递归Recursion vs 队列queue和栈stacks</p><ul><li>在内部，Python通过每一次递归调用时把信息压入调用栈来实现递归；</li><li>实际上，不使用递归调用而实现递归风格的过程式编程是可能的；</li><li>例1：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumtree</span>(<span class="params">L</span>):</span><br><span class="line">    tot = <span class="number">0</span></span><br><span class="line">    items = <span class="built_in">list</span>(L)</span><br><span class="line">    <span class="keyword">while</span> items:</span><br><span class="line">        <span class="built_in">print</span>(items)</span><br><span class="line">        front = items.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(front, <span class="built_in">list</span>):</span><br><span class="line">            tot += front</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            items.extend(front) <span class="comment"># extend方法可处理可迭代器，详见8-2和14-3，注意extend和append方法的不同</span></span><br><span class="line">    <span class="keyword">return</span> tot</span><br><span class="line">L = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"><span class="built_in">print</span>(sumtree(L))</span><br></pre></td></tr></table></figure></li><li>上述代码采用<strong>广度优先</strong>的方式<strong>breadth-first fashion</strong>遍历了列表，形成了一个<strong>先进先出的队列first-in-first-out queue</strong>。</li><li>例2：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumtree</span>(<span class="params">L</span>):</span><br><span class="line">    tot = <span class="number">0</span></span><br><span class="line">    items = <span class="built_in">list</span>(L)</span><br><span class="line">    <span class="keyword">while</span> items:</span><br><span class="line">        <span class="built_in">print</span>(items)</span><br><span class="line">        front = items.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(front, <span class="built_in">list</span>):</span><br><span class="line">            tot += front</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            items[:<span class="number">0</span>] = front</span><br><span class="line">    <span class="keyword">return</span> tot</span><br><span class="line">L = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"><span class="built_in">print</span>(sumtree(L))</span><br></pre></td></tr></table></figure></li><li>上述代码执行<strong>深度优先</strong>遍历<strong>depth-first traversal</strong>，形成<strong>后进先出的栈last-in-first-out stack</strong>。</li></ul></li><li><p>标准python限制了运行时调用栈的深度</p><ul><li>可以使用sys模块来扩大这一上限：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getrecursionlimit())</span><br><span class="line">sys.setrecursionlimit(<span class="number">10000</span>)</span><br><span class="line"><span class="built_in">print</span>(sys.getrecursionlimit())</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、Function-Objects-Attributes-and-Annotations"><a href="#三、Function-Objects-Attributes-and-Annotations" class="headerlink" title="三、Function Objects: Attributes and Annotations"></a>三、Function Objects: Attributes and Annotations</h3><ol><li><p>函数本身是对象，存储在内存块里，也支持<strong>属性attribute</strong>存储和<strong>注解annotation</strong></p></li><li><p>间接函数调用：“一等”对象</p><ul><li>函数对象可以赋值给其他的名称、传递给其他函数、嵌入到数据结构中、从一个函数返回给另一个函数；</li><li>函数和其他对象一样，属于一个通用类别，被称为first-class object model。</li><li>函数赋值给其他的名称：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">message</span>):</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line">x = echo</span><br><span class="line">x(<span class="string">&#x27;Indirect call!&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>函数作为参数传入其他函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">indirect</span>(<span class="params">func, arg</span>):</span><br><span class="line">    func(arg)</span><br><span class="line">indirect(echo, <span class="string">&#x27;Argument call!&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>函数对象存入数据结构：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">schedule = [ (echo, <span class="string">&#x27;Spam!&#x27;</span>), (echo, <span class="string">&#x27;Ham!&#x27;</span>) ]</span><br><span class="line"><span class="keyword">for</span> (func, arg) <span class="keyword">in</span> schedule:</span><br><span class="line">    func(arg)</span><br></pre></td></tr></table></figure></li><li>闭包closure：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make</span>(<span class="params">label</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">message</span>):</span><br><span class="line">        <span class="built_in">print</span>(label + <span class="string">&#x27;:&#x27;</span> + message)</span><br><span class="line">    <span class="keyword">return</span> echo</span><br><span class="line"></span><br><span class="line">F = make(<span class="string">&#x27;Spam&#x27;</span>)</span><br><span class="line">F(<span class="string">&#x27;Ham!&#x27;</span>)</span><br><span class="line">F(<span class="string">&#x27;Eggs!&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数自省Function Introspection</p><ul><li><strong>自省工具Introspection tools</strong>允许我们探索实现细节，函数已经附加了代码对象，代码对象提供了函数局部变量和参数等方面的细节：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a</span>):</span><br><span class="line">    b = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> b * a</span><br><span class="line"><span class="built_in">print</span>(func.__code__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(func.__code__))</span><br><span class="line"><span class="built_in">print</span>(func.__code__.co_varnames)</span><br><span class="line"><span class="built_in">print</span>(func.__code__.co_argcount)</span><br></pre></td></tr></table></figure></li><li>编写者可以利用这些信息来管理函数。</li></ul></li><li><p>函数属性Function Attributes</p><ul><li>函数对象除了系统定义的属性，还可以<em>附加任意用户定义的属性</em>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(func)</span><br><span class="line">func.count = <span class="number">0</span></span><br><span class="line">func.count += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(func.count)</span><br><span class="line">func.handles = <span class="string">&#x27;Button-Press&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(func.handles)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(func)) <span class="comment"># 属性多了count和handles</span></span><br></pre></td></tr></table></figure></li><li>这些属性可以直接把状态信息附加到函数对象，而不必使用全局、非局部和类等技术。</li></ul></li><li><p>函数注解Function Annotations</p><ul><li><strong>函数注解</strong>编写在def头部行，对于参数，注解在参数的冒号后；对于返回值，在-&gt;后：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a: <span class="built_in">float</span>, b: <span class="built_in">float</span>, c: <span class="built_in">float</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"><span class="built_in">print</span>(func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(func.__annotations__)</span><br></pre></td></tr></table></figure></li><li>编写了注解仍然可以对参数使用默认值：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a: <span class="built_in">float</span> = <span class="number">4</span>, b: <span class="built_in">float</span> = <span class="number">5</span>, c: <span class="built_in">float</span> = <span class="number">6</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br></pre></td></tr></table></figure></li><li>注解只在def语句有效，对lambda表达式无效。</li></ul></li></ol><h3 id="四、Anonymous-Functions-lambda"><a href="#四、Anonymous-Functions-lambda" class="headerlink" title="四、Anonymous Functions: lambda"></a>四、Anonymous Functions: lambda</h3><ol><li><p>lambda表达式基础</p><ul><li><code>lambda argument1, argument2,... argumentN : expression using arguments</code></li><li>lambda是一个表达式，而不是语句，可以选择性地被赋值给一个变量名；</li><li>lambda的主体是一个单独的表达式，而不是代码块；</li><li>可以使用lambda表达式，通过显式地将结果赋值给一个变量名，用变量名调用函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x, y, z: x + y + z</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure></li><li>lambda也可以使用默认参数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = (<span class="keyword">lambda</span> a=<span class="string">&quot;fee&quot;</span>, b=<span class="string">&quot;fie&quot;</span>, c=<span class="string">&quot;foe&quot;</span>: a + b + c)</span><br><span class="line"><span class="built_in">print</span>(x(<span class="string">&quot;wee&quot;</span>))</span><br></pre></td></tr></table></figure></li><li>lambda的代码与def一样都遵循LEGB规则：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knights</span>():</span><br><span class="line">    title = <span class="string">&#x27;Sir&#x27;</span></span><br><span class="line">    action = (<span class="keyword">lambda</span> x: title + <span class="string">&#x27; &#x27;</span> + x)</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">act = knights()</span><br><span class="line">msg = act(<span class="string">&#x27;robin&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line"><span class="built_in">print</span>(act)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>为什么使用lambda</p><ul><li>lambda起到一个函数速写的作用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="keyword">lambda</span> x: x ** <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">lambda</span> x: x ** <span class="number">3</span>,</span><br><span class="line">    <span class="keyword">lambda</span> x: x ** <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> L:</span><br><span class="line">    <span class="built_in">print</span>(f(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">0</span>](<span class="number">3</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>多分支switch语句</p><ul><li>用字典或其他数据结构构建动作表：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = <span class="string">&#x27;got&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="string">&#x27;already&#x27;</span>: (<span class="keyword">lambda</span>: <span class="number">2</span> + <span class="number">2</span>),</span><br><span class="line">    <span class="string">&#x27;got&#x27;</span>: (<span class="keyword">lambda</span>: <span class="number">2</span> * <span class="number">4</span>),</span><br><span class="line">    <span class="string">&#x27;one&#x27;</span>: (<span class="keyword">lambda</span>: <span class="number">2</span> ** <span class="number">6</span>)&#125;[key]())</span><br></pre></td></tr></table></figure></li><li>不使用lambda，用def：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(): <span class="keyword">return</span> <span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(): <span class="keyword">return</span> <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>(): <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">6</span></span><br><span class="line">key = <span class="string">&#x27;one&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="string">&#x27;already&#x27;</span>: f1, <span class="string">&#x27;got&#x27;</span>: f2, <span class="string">&#x27;one&#x27;</span>: f3&#125;[key]())</span><br></pre></td></tr></table></figure></li></ul></li><li><p>lambda中嵌套选择逻辑或执行循环</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lower = (<span class="keyword">lambda</span> x, y: x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y)</span><br><span class="line"><span class="built_in">print</span>(lower(<span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">showall = <span class="keyword">lambda</span> x: <span class="built_in">list</span>(<span class="built_in">map</span>(sys.stdout.write, x))</span><br><span class="line">t = showall([<span class="string">&#x27;spam\n&#x27;</span>, <span class="string">&#x27;toast\n&#x27;</span>, <span class="string">&#x27;eggs\n&#x27;</span>])</span><br><span class="line"></span><br><span class="line">showall = <span class="keyword">lambda</span> x: [sys.stdout.write(line) <span class="keyword">for</span> line <span class="keyword">in</span> x]</span><br><span class="line">t = showall((<span class="string">&#x27;bright\n&#x27;</span>, <span class="string">&#x27;side\n&#x27;</span>, <span class="string">&#x27;of\n&#x27;</span>, <span class="string">&#x27;life\n&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>作用域：lambda也能嵌套</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">action = (<span class="keyword">lambda</span> x: (<span class="keyword">lambda</span> y: x + y))</span><br><span class="line">act = action(<span class="number">99</span>) <span class="comment"># lambda先获取变量x</span></span><br><span class="line"><span class="built_in">print</span>(act(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(((<span class="keyword">lambda</span> x: (<span class="keyword">lambda</span> y: x + y))(<span class="number">99</span>))(<span class="number">4</span>))</span><br></pre></td></tr></table></figure></li><li><p>lambda回调（Callbacks）</p><ul><li>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</li><li>Python的tkinker GUI API定义内联的回调函数</li><li>例如：下面的代码创建了一个按钮，按钮按下会打印一行消息：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> Button, mainloop</span><br><span class="line">x = Button(</span><br><span class="line">    text=<span class="string">&#x27;Press me&#x27;</span>,</span><br><span class="line">    command=(<span class="keyword">lambda</span>: sys.stdout.write(<span class="string">&#x27;Spam\n&#x27;</span>)))</span><br><span class="line">x.pack()</span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure></li><li>回调处理器通过传递一个lambda函数作为command的关键字参数来注册的。</li></ul></li></ol><h3 id="五、Functional-Programming-Tools"><a href="#五、Functional-Programming-Tools" class="headerlink" title="五、Functional Programming Tools"></a>五、Functional Programming Tools</h3><ol><li><p>函数式编程工具</p><ul><li>Python混合支持多种编程范式：过程式procedural（使用基础语句）；面向对象式object-oriented（使用类）；函数式functional；</li><li>Python提供了一整套进行函数式编程的内置工具，把函数作用于序列和其他可迭代对象：</li><li>比如<code>map</code>：在可迭代对象的各项上调用函数的工具；<code>filter</code>：使用一个测试函数来过滤项；<code>reduce</code>：把函数作用在成对的项上来允许结果。</li></ul></li><li><p>在可迭代对象上映射函数：map</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counters = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inc</span>(<span class="params">x</span>): <span class="keyword">return</span> x + <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(inc, counters)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>((<span class="keyword">lambda</span> x: x + <span class="number">10</span>), counters)))</span><br></pre></td></tr></table></figure><ul><li>编写自己的映射工具：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mymap</span>(<span class="params">func, seq</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> seq: res.append(func(x))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mymap(inc, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure></li><li>map可用于多个序列：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">pow</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>选择可迭代对象中的元素：filter</p><ul><li>filter也返回可迭代对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>((<span class="keyword">lambda</span> x: x &gt; <span class="number">0</span>), <span class="built_in">range</span>(-<span class="number">5</span>, <span class="number">5</span>))))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>合并可迭代对象中的元素：reduce</p><ul><li>reduce位于functools模块，接受并处理一个迭代器，返回一个结果（非迭代器）：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="built_in">print</span>(reduce((<span class="keyword">lambda</span> x, y: x + y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line"><span class="built_in">print</span>(reduce((<span class="keyword">lambda</span> x, y: x * y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure></li><li>用for循环模拟reduce：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">res = L[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> L[<span class="number">1</span>:]:</span><br><span class="line">    res = res + x</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li><li>编写自己的reduce函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myreduce</span>(<span class="params">function, sequence</span>):</span><br><span class="line">    tally = sequence[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> sequence[<span class="number">1</span>:]:</span><br><span class="line">        tally = function(tally, <span class="built_in">next</span>)</span><br><span class="line">    <span class="keyword">return</span> tally</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(myreduce((<span class="keyword">lambda</span> x, y: x + y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"><span class="built_in">print</span>(myreduce((<span class="keyword">lambda</span> x, y: x * y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure></li><li>内置的operator模块，提供了内置表达式对应的函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> operator, functools</span><br><span class="line"><span class="built_in">print</span>(functools.reduce(operator.add, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]))</span><br><span class="line"><span class="built_in">print</span>(functools.reduce((<span class="keyword">lambda</span> x, y: x + y), [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="chapter-20-Comprehensions-and-Generations"><a href="#chapter-20-Comprehensions-and-Generations" class="headerlink" title="chapter 20 Comprehensions and Generations"></a>chapter 20 Comprehensions and Generations</h2><h3 id="一、List-Comprehensions-and-Functional-Tools"><a href="#一、List-Comprehensions-and-Functional-Tools" class="headerlink" title="一、List Comprehensions and Functional Tools"></a>一、List Comprehensions and Functional Tools</h3><ol><li><p>list comprehensions apply an arbitrary expression to items in an iterable, rather than applying a function. </p></li><li><p>List Comprehensions Versus map</p><ul><li>用循环收集字符串中字符的ASCII编码：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;spam&#x27;</span>:</span><br><span class="line">    res.append(<span class="built_in">ord</span>(x))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li><li>用<code>map函数</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="string">&#x27;spam&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li><li><strong>列表推导表达式 list comprehension expression</strong>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = [<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;spam&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Adding Tests and Nested Loops: filter</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>((<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>), <span class="built_in">range</span>(<span class="number">5</span>))))</span><br><span class="line"><span class="built_in">print</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>])</span><br></pre></td></tr></table></figure><ul><li>等效的for循环：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        res.append(x)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Formal comprehension syntax标准推导语法</p><ul><li>通用的列表推导的结构如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ expression <span class="keyword">for</span> target1 <span class="keyword">in</span> iterable1 <span class="keyword">if</span> condition1</span><br><span class="line">             <span class="keyword">for</span> target2 <span class="keyword">in</span> iterable2 <span class="keyword">if</span> condition2 ...</span><br><span class="line">             <span class="keyword">for</span> targetN <span class="keyword">in</span> iterableN <span class="keyword">if</span> conditionN ]</span><br></pre></td></tr></table></figure></li><li>例子：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = [x + y <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([x + y + z <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;spam&#x27;</span> <span class="keyword">if</span> x <span class="keyword">in</span> <span class="string">&#x27;sm&#x27;</span></span><br><span class="line">                 <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">&#x27;SPAM&#x27;</span> <span class="keyword">if</span> y <span class="keyword">in</span> (<span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                 <span class="keyword">for</span> z <span class="keyword">in</span> <span class="string">&#x27;123&#x27;</span> <span class="keyword">if</span> z &gt; <span class="string">&#x27;1&#x27;</span>])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>List Comprehensions and Matrixes列表推导和矩阵</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">     [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">     [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">N = [[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">     [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">     [<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> M])</span><br><span class="line"><span class="built_in">print</span>([M[row][<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)])</span><br><span class="line"><span class="built_in">print</span>([M[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M))])</span><br><span class="line"><span class="built_in">print</span>([M[i][<span class="built_in">len</span>(M)-<span class="number">1</span>-i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M))])</span><br><span class="line"><span class="built_in">print</span>([[col + <span class="number">10</span> <span class="keyword">for</span> col <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> M])</span><br><span class="line"><span class="built_in">print</span>([[M[row][col] * N[row][col] <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]) <span class="comment"># 这个语句是先for row再for col</span></span><br><span class="line"><span class="built_in">print</span>([[col1 * col2 <span class="keyword">for</span> (col1, col2) <span class="keyword">in</span> <span class="built_in">zip</span>(row1, row2)] <span class="keyword">for</span> (row1, row2) <span class="keyword">in</span> <span class="built_in">zip</span>(M, N)])</span><br></pre></td></tr></table></figure></li><li><p>性能</p><ul><li><code>map调用比等效的for循环要快2倍，而列表推导往往比map调用要再快一些</code>；</li><li>map和列表推导是以C语言的速度来运行，而for循环在虚拟机PVM中运行。</li></ul></li></ol><h3 id="二、Generator-Functions"><a href="#二、Generator-Functions" class="headerlink" title="二、Generator Functions"></a>二、Generator Functions</h3><ol><li><p>Generator Functions and Expressions 生成器函数和生成器表达式</p><ul><li>下面2种语言特性让用户可以推迟结果的计算：<ul><li><strong>Generator functions生成器函数</strong>：使用def编写，但是使用yield语句返回结果；</li><li><strong>Generator expressions生成器表达式</strong>：它返回按需产生结果的对象。</li></ul></li><li>以上两者节省了内存空间，允许计算时间分摊到各次结果请求上。</li></ul></li><li><p>Generator Functions: yield Versus return</p><ul><li>State suspension状态挂起<ul><li>和返回一个值并退出的常规函数不同，<strong>生成器函数</strong>能够自动挂起并在生成值的时候恢复之前的状态并继续函数的执行。由于生成器函数在挂起时保存的状态包含它们的代码位置和整个局部作用域，因此当函数恢复时，它们的局部变量保持了信息并使其可用。</li><li>生成器函数产生yield一个值，而不是返回return一个值，<code>yield语句</code>会挂起该函数并向调用者传回一个值，同时也保留了状态。</li></ul></li><li>Iteration protocol integration与迭代协议集成<ul><li>函数若包含一条yield语句，该函数将被特别编译为<strong>生成器</strong>：它们不再是普通函数，而是作为通过特定的迭代协议方法来返回对象的函数。当调用时，它们返回一个生成器对象，该对象支持用一个自动创建的名为<code>__next__</code>的方法接口。</li><li>生成器函数也可以有一条return语句，在def语句块的结尾，用于终止值的生成。</li></ul></li></ul></li><li><p>生成器函数的应用</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gensquares</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">yield</span> i ** <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>这个函数在每次循环时都会yield一个值，之后将其返还给它的调用者。当它被暂停后，它的上一个状态被保存了下来，包括变量i和N，并且在yield语句之后被收回控制权。</li><li>调用生成器函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = gensquares(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></li><li>返回的生成器对象有一个<code>__next__</code>方法，该方法可以开始这个函数，或者从它上次yield值后的地方恢复，并且在得到一系列值后，引发StopIteration异常：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(x))</span><br></pre></td></tr></table></figure></li><li><em>生成器函数本身就是迭代器</em>，所以不需要iter调用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = gensquares(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">iter</span>(y) <span class="keyword">is</span> y)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(y))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>为什么要使用生成器函数</p><ul><li>生成器对于大型程序而言，在内存使用和性能方面都更好。生成器将产生一系列值的时间分散到每一次的循环迭代中；</li><li>生成器函数是一种“穷人的”多线程机制：将操作拆分到每一次的yield之间。然而生成器仍然运行在一个单线程的控制内。</li></ul></li><li><p>拓展生成器函数协议：send vs next</p><ul><li>生成器函数协议有一个<code>send方法</code>，可以生成一系列结果的下一个元素，就像<strong>next</strong>方法一样，但是它也提供了一种调用者与生成器之间通讯的方式；</li><li>yield可以返回发送给send函数的元素（必须用A = yield X）；</li><li>当使用这一额外的协议时，值可以通过调用G.send(value)发送给一个生成器G。之后恢复生成器代码的执行，并且生成器中的yield表达式返回了发送给send函数的值，如果提前调用了G.__next__()方法，yield返回None。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        X = <span class="keyword">yield</span> i</span><br><span class="line">        <span class="built_in">print</span>(X)</span><br><span class="line">G = gen()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(G)) <span class="comment"># Must call next() first, to start generator,否则会出错</span></span><br><span class="line"><span class="built_in">print</span>(G.send(<span class="number">77</span>))</span><br><span class="line"><span class="built_in">print</span>(G.send(<span class="number">77</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(G))</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">77</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">77</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、Generator-Expressions"><a href="#三、Generator-Expressions" class="headerlink" title="三、Generator Expressions"></a>三、Generator Expressions</h3><ol><li><p>Generator Expressions: Iterables Meet Comprehensions生成器表达式：当可迭代对象遇见推导语法</p><ul><li><strong>生成器表达式</strong>跟列表推导很像，但是是在圆括号内，而不是方括号：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>([x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]) <span class="comment"># List comprehension</span></span><br><span class="line"><span class="built_in">print</span>((x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>))) <span class="comment"># Generator Expressions</span></span><br></pre></td></tr></table></figure></li><li>生成器表达式也是迭代器，不需要iter调用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">iter</span>(G) <span class="keyword">is</span> G)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(G))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(G))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(G))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(G))</span><br></pre></td></tr></table></figure></li><li>我们一般不会在生成器表达式看到next机制的使用，因为for循环会自动触发：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s, %s&#x27;</span> % (num, num / <span class="number">2.0</span>))</span><br></pre></td></tr></table></figure></li><li>每个迭代上下文都如上，包括for循环、sum、map和sorted等内置函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(x.upper() <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;aaa,bbb,ccc&#x27;</span>.split(<span class="string">&#x27;,&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>((x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)), reverse=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>为什么使用生成器表达式</p><ul><li>就像生成器函数，生成器表达式是一种对内存空间的优化；</li><li>生成器表达式在实际运行起来可能比列表推导稍慢一些，但对于非常大的运算或不能等待全部数据产生结果的应用来说是最优选择。</li></ul></li><li><p>生成器表达式 vs map</p><ul><li>生成器表达式通常等效于map调用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, (-<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">abs</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (-<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)))</span><br></pre></td></tr></table></figure></li><li>map和生成器都可以任意嵌套，下面的列表推导与map产生相同的结果，但是列表推导创建了2个列表：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="built_in">abs</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> (-<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)]]</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, <span class="built_in">map</span>(<span class="built_in">abs</span>, (-<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>生成器表达式 vs filter</p><ul><li>filter和一个带有if分句的生成器表达式是等价的：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line = <span class="string">&#x27;aa bbb c&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(x <span class="keyword">for</span> x <span class="keyword">in</span> line.split() <span class="keyword">if</span> <span class="built_in">len</span>(x) &gt; <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x) &gt; <span class="number">1</span>, line.split())))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="四、Generator-Functions-Versus-Generator-Expressions"><a href="#四、Generator-Functions-Versus-Generator-Expressions" class="headerlink" title="四、Generator Functions Versus Generator Expressions"></a>四、Generator Functions Versus Generator Expressions</h3><ol><li><p>生成器函数 vs 生成器表达式</p><ul><li>生成器函数：一个使用了yield表达式的def语句是一个生成器函数。当被调用时，它返回一个新的生成器对象；</li><li>生成器表达式：一个被包括在圆括号内的列表推导表达式被称为一个生成器表达式；</li><li>这2个都包括一个返回自身的<strong>iter</strong>方法以及一个启动隐式循环或从上次运行离开的地方重新开始的<strong>next</strong>方法，都可以在能主动调用这些接口的迭代上下文中自动按需产生结果。</li></ul></li><li><p><strong>生成器是单遍迭代对象Generators Are Single-Iteration Objects</strong></p><ul><li>生成器函数和生成器表达式本身都是迭代器，在一个生成器上调用iter没有实际效果。如果尝试手动使用多个迭代器来迭代结果，它们都将指向相同位置：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G = (c * <span class="number">4</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;SPAM&#x27;</span>)</span><br><span class="line">I1 = <span class="built_in">iter</span>(G)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I1))</span><br><span class="line">I2 = <span class="built_in">iter</span>(G)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I2))</span><br></pre></td></tr></table></figure></li><li>一旦任一迭代器运行结束，我们必须产生一个新的生成器以便重新开始。</li><li>这与某些内置类型的行为不同。内置类型支持多个迭代器与多次迭代，并且在活跃迭代器中传递并反映它们的原位置修改：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">I1, I2 = <span class="built_in">iter</span>(L), <span class="built_in">iter</span>(L)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(I2))</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>yield from</code>拓展</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">both</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N): <span class="keyword">yield</span> i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(N)): <span class="keyword">yield</span> i</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(both(<span class="number">5</span>)))</span><br></pre></td></tr></table></figure><ul><li>用<code>yield from</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">both</span>(<span class="params">N</span>):</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="built_in">range</span>(N)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(both(<span class="number">5</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; : &#x27;</span>.join(<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> both(<span class="number">5</span>)))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="五、Generation-in-Built-in-Types-Tools-and-Classes"><a href="#五、Generation-in-Built-in-Types-Tools-and-Classes" class="headerlink" title="五、Generation in Built-in Types, Tools, and Classes"></a>五、Generation in Built-in Types, Tools, and Classes</h3><ol><li><p>Generators and library tools: Directory walkers生成器和库工具：目录遍历器</p><ul><li><code>os.walk</code>在Python中的os.py标准库文件中被编写为一个迭代函数，它使用yield返回结果，因此它是一个迭代器：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> (root, subs, files) <span class="keyword">in</span> os.walk(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">&#x27;20&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(root, name)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Generators and function application生成器和函数应用</p><ul><li>带“*”的参数可以将一个可迭代对象解包成单独的参数，详见第18章。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, c</span>): <span class="built_in">print</span>(<span class="string">&#x27;%s, %s, and %s&#x27;</span> % (a, b, c))</span><br><span class="line">f(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f(*<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">f(*(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)))</span><br></pre></td></tr></table></figure></li><li>对字典的解包：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = <span class="built_in">dict</span>(a=<span class="string">&#x27;Bob&#x27;</span>, b=<span class="string">&#x27;dev&#x27;</span>, c=<span class="number">40.5</span>)</span><br><span class="line">f(a=<span class="string">&#x27;Bob&#x27;</span>, b=<span class="string">&#x27;dev&#x27;</span>, c=<span class="number">40.5</span>)</span><br><span class="line">f(**D)</span><br><span class="line">f(*D)</span><br><span class="line">f(*D.values())</span><br></pre></td></tr></table></figure></li></ul></li><li><p>类中用户定义的可迭代对象 详见第30章</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeIterable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">...</span>): ... </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">...</span>): ...</span><br></pre></td></tr></table></figure></li><li><p>Permutations排列: All possible combinations</p><ul><li>用递归的方式实现排列（包括不同的顺序）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute1</span>(<span class="params">seq</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> seq:</span><br><span class="line">        <span class="keyword">return</span> [seq]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(seq)):</span><br><span class="line">            rest = seq[:i] + seq[i+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> permute1(rest):</span><br><span class="line">                res.append(seq[i:i+<span class="number">1</span>] + x)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(permute1(<span class="string">&#x27;spam&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li>上述递归，直接看可能有点难理解，用数学来解释排列会好理解一点：</li><li>如果让你弄出spam的所有的排列顺序，你会先提出来s，放到最前面，并对pam进行排序；再提出p，放到最前面，并对sam进行排序；…</li><li>对应代码为 rest = seq[:i] + seq[i+1:]，即：把当前的节点数字去掉；</li><li>对pam进行排序，需要先提出来p，放到最前面，并对am进行排序；对am进行排序，需要先提出来a；这也是为什么需要递归的原因，需要一层一层排序，并且拼接；</li><li>对应代码为 for x in permute1(rest):，即：对剩余的数字进行排序；</li><li>而 seq[i:i+1] + x 的意思就是把一个个提出来的字母拼接到前面去；</li><li>最后返回所有排列组合。</li><li>上面例子的生成器函数版本：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute2</span>(<span class="params">seq</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> seq:</span><br><span class="line">        <span class="keyword">yield</span> seq</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(seq)):</span><br><span class="line">            rest = seq[:i] + seq[i+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> permute2(rest):</span><br><span class="line">                <span class="keyword">yield</span> seq[i:i+<span class="number">1</span>] + x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(permute2(<span class="string">&#x27;spam&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(permute1(<span class="string">&#x27;spam&#x27;</span>) == <span class="built_in">list</span>(permute2(<span class="string">&#x27;spam&#x27;</span>)))</span><br><span class="line">G = permute2(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(G))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(G))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>不要过度使用生成器</p><ul><li>生成器的隐式行为可能对于其他程序员难以理解，没必要强行使用让代码变复杂；</li><li>列表能自动进行垃圾回收，同时更快地被编写（见下一章节）；</li><li>生成器能减少内存和延迟。</li></ul></li></ol><h3 id="六、Comprehension-Syntax-Summary"><a href="#六、Comprehension-Syntax-Summary" class="headerlink" title="六、Comprehension Syntax Summary"></a>六、Comprehension Syntax Summary</h3><ol><li><p>Scopes and Comprehension Variables 作用域及推导变量</p><ul><li>生成器推导、集合推导、字典推导以及列表推导中的临时循环变量名的作用域只局限于表达式内，不会与外部变量名冲突，这和for循环不一样：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)])</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">y = <span class="number">99</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>): <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>集合推导和字典推导</p><ul><li>集合推导和字典推导可视为把生成器表达式传递给类型名：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(&#123;x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line"><span class="built_in">print</span>(&#123;x: x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>((x, x * x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure></li><li>与列表推导及生成器表达式一样，集合推导和字典推导接受if分句、嵌套for循环、在可迭代对象上迭代。</li></ul></li></ol><h2 id="chapter-21-The-Benchmarking-Interlude"><a href="#chapter-21-The-Benchmarking-Interlude" class="headerlink" title="chapter 21 The Benchmarking Interlude"></a>chapter 21 The Benchmarking Interlude</h2><h3 id="一、Timing-Iteration-Alternatives"><a href="#一、Timing-Iteration-Alternatives" class="headerlink" title="一、Timing Iteration Alternatives"></a>一、Timing Iteration Alternatives</h3><ol><li><p>计时迭代可选方案</p><ul><li>列表推导有时比for循环有速度优势，而map调用看情况，列表推导有时比for循环有速度优势，而map调用看情况：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func, *args</span>):</span><br><span class="line">    start = time.perf_counter() </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>): <span class="comment"># 执行1000次</span></span><br><span class="line">        func(*args)</span><br><span class="line">    <span class="keyword">return</span> time.perf_counter()  - start</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(timer(<span class="built_in">pow</span>, <span class="number">2</span>, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure></li><li>上述代码有一些局限，包括额外计入了range的时间、不支持关键字参数，扩展上述代码，详见timer.py，如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># timer.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Homegrown timing tools for function calls.</span></span><br><span class="line"><span class="string">Does total time, best-of time, and best-of-totals time</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time, sys</span><br><span class="line">timer = time.perf_counter <span class="keyword">if</span> sys.platform[:<span class="number">3</span>] == <span class="string">&#x27;win&#x27;</span> <span class="keyword">else</span> time.time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">total</span>(<span class="params">reps, func, *pargs, **kargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Total time to run func() reps times.</span></span><br><span class="line"><span class="string">    Returns (total time, last result)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    repslist = <span class="built_in">list</span>(<span class="built_in">range</span>(reps))</span><br><span class="line">    start = timer()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> repslist:</span><br><span class="line">        ret = func(*pargs, **kargs)</span><br><span class="line">    elapsed = timer() - start</span><br><span class="line">    <span class="keyword">return</span> (elapsed, ret)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bestof</span>(<span class="params">reps, func, *pargs, **kargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Quickest func() among reps runs.</span></span><br><span class="line"><span class="string">    Returns (best time, last result)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    best = <span class="number">2</span> ** <span class="number">32</span> <span class="comment"># 136 years seems large enough</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(reps): <span class="comment"># range usage not timed here</span></span><br><span class="line">        start = timer()</span><br><span class="line">        ret = func(*pargs, **kargs)</span><br><span class="line">        elapsed = timer() - start <span class="comment"># Or call total() with reps=1</span></span><br><span class="line">        <span class="keyword">if</span> elapsed &lt; best: best = elapsed <span class="comment"># Or add to list and take min()</span></span><br><span class="line">    <span class="keyword">return</span> (best, ret)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bestoftotal</span>(<span class="params">reps1, reps2, func, *pargs, **kargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Best of totals:</span></span><br><span class="line"><span class="string">    (best of reps1 runs of (total of reps2 runs of func))</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> bestof(reps1, total, reps2, func, *pargs, **kargs)</span><br></pre></td></tr></table></figure>运行代码如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timer</span><br><span class="line"><span class="built_in">print</span>(timer.total(<span class="number">1000</span>, <span class="built_in">pow</span>, <span class="number">2</span>, <span class="number">1000</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(timer.total(<span class="number">1000</span>, <span class="built_in">str</span>.upper, <span class="string">&#x27;spam&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(timer.bestof(<span class="number">1000</span>, <span class="built_in">str</span>.upper, <span class="string">&#x27;spam&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(timer.bestof(<span class="number">1000</span>, <span class="built_in">pow</span>, <span class="number">2</span>, <span class="number">1000000</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(timer.bestof(<span class="number">50</span>, timer.total, <span class="number">1000</span>, <span class="built_in">str</span>.upper, <span class="string">&#x27;spam&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(timer.bestoftotal(<span class="number">50</span>, <span class="number">1000</span>, <span class="built_in">str</span>.upper, <span class="string">&#x27;spam&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>计时脚本</p><ul><li>计时迭代工具的计时器脚本，详见timeseqs.py，如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Test the relative speed of iteration tool alternatives.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, timer</span><br><span class="line">reps = <span class="number">10000</span></span><br><span class="line">repslist = <span class="built_in">list</span>(<span class="built_in">range</span>(reps))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forLoop</span>():</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> repslist:</span><br><span class="line">        res.append(<span class="built_in">abs</span>(x))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listComp</span>():</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">abs</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> repslist]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mapCall</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, repslist))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">genExpr</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">abs</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> repslist)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">genFunc</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> repslist:</span><br><span class="line">            <span class="keyword">yield</span> <span class="built_in">abs</span>(x)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(gen())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.version)</span><br><span class="line"><span class="keyword">for</span> test <span class="keyword">in</span> (forLoop, listComp, mapCall, genExpr, genFunc):</span><br><span class="line">    (bestof, (total, result)) = timer.bestoftotal(<span class="number">5</span>, <span class="number">1000</span>, test)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;%-9s: %.5f =&gt; [%s...%s]&#x27;</span> %</span><br><span class="line">    (test.__name__, bestof, result[<span class="number">0</span>], result[-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></li><li>如代码所示，它报告的时间反应了这5个测试函数执行1000万部的快慢，每个函数创建了1000次带有10000个元素的列表；</li><li>根据timeseqs.py的运行结果，生成器表达式比列表推导慢很多；map，即映射内置函数abs这样的内置函数，map会比列表推导快。</li></ul></li><li><p>无论如何，性能不是编写python代码的第一优先级。写出具有可读性和间接性的代码优先，然后在需要时优化。</p></li></ol><h3 id="二、Timing-Iterations-and-Pythons-with-timeit"><a href="#二、Timing-Iterations-and-Pythons-with-timeit" class="headerlink" title="二、Timing Iterations and Pythons with timeit"></a>二、Timing Iterations and Pythons with timeit</h3><ol><li><p>python标准库的timeit模块，自动化了代码计时</p><ul><li><code>timeit</code>，测试可以用可调用对象或语句字符串所指定；</li><li>语句字符串：支持分隔符“；”或换行符“\n”分开的多条语句，以及用空格或制表符表示的缩进语句。</li></ul></li><li><p>Interactive usage and API calls交互式用法与API调用</p><ul><li><code>timeit模块</code>中的<code>repeat</code>：表示调用运行若干组相同测试并返回一个列表，列表中的各项表示运行各组测试的总时间；</li><li>每组测试由若干条相同测试语句（由number指定）组成；</li><li>列表中的最小项（可通过min获取）就是各组运行的最佳时间；</li><li>stmt是statement的缩写。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(timeit.repeat(stmt=<span class="string">&quot;[x ** 2 for x in range(1000)]&quot;</span>, number=<span class="number">1000</span>, repeat=<span class="number">5</span>)))</span><br></pre></td></tr></table></figure></li><li>上述代码运行5次，每次都执行了1000次的创建了拥有1000个元素的列表推导式。</li></ul></li><li><p>Command-line usage命令行用法</p><ul><li>timeit模块可以通过Python的 -m 标签自动地在路径上定位作为脚本运行：<br><code>c:\code&gt; python -m timeit -n 1000 &quot;[x ** 2 for x in range(1000)]&quot;</code><br><code>c:\code&gt; py −3 -m timeit -n 1000 -r 5 &quot;[x ** 2 for x in range(1000)]&quot;</code><br><code>c:\code&gt; C:\python33\Lib\timeit.py -n 1000 &quot;[x ** 2 for x in range(1000)]&quot;</code>  </li></ul></li><li><p>Timing multiline statements计时对行语句</p><ul><li>在API调用模式下，可以使用换行符、制表符或空格写出多行代码：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(timeit.repeat(number=<span class="number">10000</span>, repeat=<span class="number">3</span>,</span><br><span class="line">    stmt=<span class="string">&quot;L = [1, 2, 3, 4, 5]\nfor i in range(len(L)): L[i] += 1&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(timeit.repeat(number=<span class="number">10000</span>, repeat=<span class="number">3</span>,</span><br><span class="line">    stmt=<span class="string">&quot;L = [1, 2, 3, 4, 5]\ni=0\nwhile i &lt; len(L):\n\tL[i] += 1\n\ti += 1&quot;</span>)))</span><br></pre></td></tr></table></figure></li><li>在命令行模式下运行多行语句，可以把每条语句作为单独参数传入，并使用空白缩进；</li><li>timeit会把所有行拼接起来并插入换行符：<br><code>c:\code&gt; py −3 -m timeit -n 1000 -r 3 &quot;L = [1,2,3,4,5]&quot; &quot;M = [x + 1 for x in L]&quot;</code></li></ul></li><li><p>Other usage modes: Setup, totals, and objects其他使用模式：初始化、总时间和可运行对象</p><ul><li>timeit允许让初始化的代码不计入要测试的语句的总时间:<ul><li>指定初始化代码，在命令行里用-s标签：<br><code>c:\code&gt; python -m timeit -n 1000 -r 3 -s &quot;L = [1,2,3,4,5]&quot; &quot;M = [x + 1 for x in L]&quot;</code> 这里把列表作为初始化语句分离了出来；</li><li>或在API调用模式下使用setup参数字符串：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(timeit.repeat(number=<span class="number">10000</span>, repeat=<span class="number">3</span>,</span><br><span class="line">    setup=<span class="string">&quot;L = [1, 2, 3, 4, 5]&quot;</span>,</span><br><span class="line">    stmt=<span class="string">&quot;for i in range(len(L)): L[i] += 1&quot;</span>)))</span><br></pre></td></tr></table></figure></li></ul></li><li>timeit可以只计时总时间，使用模块的类API，计时可调用对象而不是字符串，详见库手册：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="built_in">print</span>(timeit.timeit(stmt=<span class="string">&#x27;[x ** 2 for x in range(1000)]&#x27;</span>, number=<span class="number">1000</span>)) <span class="comment"># Total time</span></span><br><span class="line"><span class="built_in">print</span>(timeit.Timer(stmt=<span class="string">&#x27;[x ** 2 for x in range(1000)]&#x27;</span>).timeit(<span class="number">1000</span>)) <span class="comment"># Class API</span></span><br><span class="line"><span class="built_in">print</span>(timeit.repeat(stmt=<span class="string">&#x27;[x ** 2 for x in range(1000)]&#x27;</span>, number=<span class="number">1000</span>, repeat=<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testcase</span>():</span><br><span class="line">    y = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(timeit.repeat(stmt=testcase, number=<span class="number">1000</span>, repeat=<span class="number">3</span>)))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、Function-Gotchas"><a href="#三、Function-Gotchas" class="headerlink" title="三、Function Gotchas"></a>三、Function Gotchas</h3><ol><li><p>Local Names Are Detected Statically局部变量是被静态检测的</p><ul><li>python是在编译def代码时静态检测Python的局部变量的，而不是在运行时检测的：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">99</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selector</span>(): </span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line"><span class="comment">#   X = 88 如果这个语句在def里面，则出现未定义变量名错误</span></span><br><span class="line">selector()</span><br></pre></td></tr></table></figure></li><li>在编译时，python看到对X的赋值语句，决定了X会在函数中所有地方都是局部变量。但当函数运行时，执行print时，赋值并未发送，这时就会出现未定义变量名错误；</li><li>产生这个问题的原因是，被赋值的变量名在函数内部的所有位置都被当做局部变量对待，不是在赋值以后的语句才被当作局部变量。</li><li>如果想打印全局变量X，需要global语句：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selector</span>():</span><br><span class="line">    <span class="keyword">global</span> X</span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line">    X = <span class="number">88</span></span><br><span class="line">selector()</span><br><span class="line"><span class="built_in">print</span>(X)</span><br></pre></td></tr></table></figure></li><li>但这样会改变全局变量X，如果不想改变，需要导入外围模块：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">99</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selector</span>():</span><br><span class="line">    <span class="keyword">import</span> __main__</span><br><span class="line">    <span class="built_in">print</span>(__main__.X)</span><br><span class="line">    X = <span class="number">88</span></span><br><span class="line">    <span class="built_in">print</span>(X)</span><br><span class="line">selector()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Defaults and Mutable Objects默认值参数和可变对象</p><ul><li>用作默认值参数的可变值可以在调用之间保留状态；</li><li>当def语句运行时，默认值参数就被求值并保存，而不是调用时；</li><li>python会将每一个默认值参数保存成一个对象，附加在函数本身；</li><li>因为默认值参数在def时被求值，它能在外层作用域中保存值（详见工厂函数）。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">saver</span>(<span class="params">x=[]</span>):</span><br><span class="line">    x.append(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">saver([<span class="number">2</span>])</span><br><span class="line">saver()</span><br><span class="line">saver()</span><br><span class="line">saver()</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Learning Python》读书笔记（一）</title>
      <link href="/2022/09/17/2022-09-17-Learning-python1/"/>
      <url>/2022/09/17/2022-09-17-Learning-python1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该笔记为 <strong>《Learning Python》</strong> 的读书笔记，由于是早期未搞熟博客系统时所写，笔记结构较为混乱；<br>该书涉及的内容可能过于啰嗦，但包含一些python背后的逻辑和机制，可以粗略过一遍，但若仔细阅读就是在坑自己；<br>该笔记内容过多，所以不展示部分代码的结果，需复制到编辑器中查看；<br>学习完成日期为2022年10月20日。<br>本篇主要内容为：Python解释器；Python对象类型的初步介绍；数值类型。</p></blockquote><div  align="center">  <img src="https://s2.loli.net/2022/09/17/ri9Ue6nguJdq1Ca.jpg" width = "80%" height = "80%" alt="Learning Python"/></div><h1 id="PART-I-Getting-Started"><a href="#PART-I-Getting-Started" class="headerlink" title="PART I Getting Started"></a>PART I Getting Started</h1><h2 id="Chapter-2-How-Python-Runs-Programs"><a href="#Chapter-2-How-Python-Runs-Programs" class="headerlink" title="Chapter 2 How Python Runs Programs"></a>Chapter 2 How Python Runs Programs</h2><h3 id="一、Python-Interpreter-解释器"><a href="#一、Python-Interpreter-解释器" class="headerlink" title="一、Python Interpreter 解释器"></a>一、Python Interpreter 解释器</h3><ul><li>Python即是计算机语言，又是叫解释器的安装包</li><li>Python语言代码 → python解释器 → 执行</li><li>the interpreter is a layer of software logic between your code and the computer hardware on your machine.</li></ul><h3 id="二、Byte-code-compilation-字节码编译"><a href="#二、Byte-code-compilation-字节码编译" class="headerlink" title="二、Byte code compilation 字节码编译"></a>二、Byte code compilation 字节码编译</h3><ol><li>python interpreter将source code（源代码）编译成byte code（字节码），再转发到 → virtual machine（虚拟机）；</li><li>byte code<ul><li>字节码比源代码运行速度快；</li><li>python会将程序的字节码保持在.pyc的拓展名文件，并存储在<strong>pycache</strong>的子目录中（在源文件同一路径）；</li><li>若上次保存的字节码之后没修改过源代码，则直接加载.pyc文件；</li><li>字节码不是机器的2进制代码，是特定于python的一种表达形式。这也是python比c慢的原因，字节码比cpu指令需要更多的工作。</li></ul></li><li>python virtual machine(PVM)<ul><li>字节码发送至虚拟机的程序上执行，虚拟机是runtime engine of Python，是python系统的一部分。</li></ul></li></ol><h3 id="三、Python编译器的变种或者实现方式（implementation）"><a href="#三、Python编译器的变种或者实现方式（implementation）" class="headerlink" title="三、Python编译器的变种或者实现方式（implementation）"></a>三、Python编译器的变种或者实现方式（implementation）</h3><ul><li>5个主要的变体：CPython, Jython, IronPython, Stackless, and PyPy。</li></ul><ol><li><p>CPython</p><ul><li>The original, and standard, implementation of Python is usually called CPython；</li><li>cpython就是大部分人使用的；</li><li>Cpython允许python脚本化C和C++。</li></ul></li><li><p>Jython: Python for Java</p><ul><li>Jython包含Java类，这些类将python源代码编译成Java字节码，在到Java虚拟机(JVM)；</li><li>Jython让Python代码能够脚本化Java应用程序，python代码被翻译成Java字节码，运行起来像Java程序。</li></ul></li><li><p>IronPython: Python for .NET</p><ul><li>让python程序与windows的.NET框架以及linux的开源的Mono编写的应用相集成（integrate with）；</li><li>IronPython allows Python programs to act as both client and server components, gain accessibility both to and from other .NET languages。</li></ul></li><li><p>Stackless: Python for concurrency（并发性）</p><ul><li>Because it does not save state on the C language call stack, Stackless Python can make Python easier to port to small；</li><li>stack architectures, provides efficient multiprocessing options, and fosters novel programming structures such as coroutines；</li><li>上面的翻译：因为它不会在C语言调用栈上保存状态，让它更易移植到较小的栈架构中，提供了高效的多处理选项，并且促进了协程(coroutine)的编程结构的出现。</li></ul></li><li><p>PyPy: Python for speed</p><ul><li>PyPy是Cpython的另一种实现，It provides a fast Python implementation with a JIT (just-in-time) compiler；</li><li>JIT：字节码转换和程序运行同时进行；</li><li>PyPy is the successor（继任者） to the original Psyco JIT；</li><li>PyPy currently claims a 5.7X speedup over CPython，让某些情况下跟C一样快，有时超越C。</li></ul></li></ol><h2 id="Chapter-3-How-You-Run-Programs"><a href="#Chapter-3-How-You-Run-Programs" class="headerlink" title="Chapter 3 How You Run Programs"></a>Chapter 3 How You Run Programs</h2><h3 id="一、Interactive-command-line交互式命令行；interactive-prompt交互式提示"><a href="#一、Interactive-command-line交互式命令行；interactive-prompt交互式提示" class="headerlink" title="一、Interactive command line交互式命令行；interactive prompt交互式提示"></a>一、Interactive command line交互式命令行；interactive prompt交互式提示</h3><ol><li>就是Windows上的DOS console window（DOS控制台窗口）—a program named cmd.exe and usually known as Command Prompt(命令提示符)；</li><li>DOS：Disk Operating System磁盘操作系统(一种面向磁盘的系统软件)，DOS就是人给机器下达命令的集合，是存储在操作系统中的命令集。</li></ol><h3 id="二、The-System-Path系统路径"><a href="#二、The-System-Path系统路径" class="headerlink" title="二、The System Path系统路径"></a>二、The System Path系统路径</h3><ol><li>if you have not set your system’s PATH environment variable to include Python’s install directory, you may need to replace；</li><li>the word “python” with the full path to the Python executable on your machine；</li><li>比如c:\Users&gt; c:\python33\python而不是C:\Users\> python</li></ol><h3 id="三、Running-Code-Interactively交互式地运行代码"><a href="#三、Running-Code-Interactively交互式地运行代码" class="headerlink" title="三、Running Code Interactively交互式地运行代码"></a>三、Running Code Interactively交互式地运行代码</h3><ol><li>When working interactively, the results of your code are displayed below the &gt;&gt;&gt; input lines after you press the Enter key.</li></ol><h3 id="四、程序program、模块module、脚本script的区别"><a href="#四、程序program、模块module、脚本script的区别" class="headerlink" title="四、程序program、模块module、脚本script的区别"></a>四、程序program、模块module、脚本script的区别</h3><ol><li>Terminology in this domain can vary somewhat；</li><li>module files are often referred to as programs in Python—a program is considered to be a series of precoded statements stored in a file for repeated execution；</li><li>Module files that are run directly are also sometimes called scripts—an informal term usually meaning a top-level顶层 program file；</li><li>Some reserve the term “module” for a file imported from another file, and “script” for the main file of a program; we generally will here, too.</li></ol><h3 id="五、IDLE-GUI-Integrated-Development-and-Learning-Environment-Graphical-User-Interface-集成开发和学习环境的图形用户界面"><a href="#五、IDLE-GUI-Integrated-Development-and-Learning-Environment-Graphical-User-Interface-集成开发和学习环境的图形用户界面" class="headerlink" title="五、IDLE GUI (Integrated Development and Learning Environment; Graphical User Interface)集成开发和学习环境的图形用户界面"></a>五、IDLE GUI (Integrated Development and Learning Environment; Graphical User Interface)集成开发和学习环境的图形用户界面</h3><ol><li>shell （计算机壳层）指为使用者提供操作界面的软件，类似于DOS下的COMMAND.COM和后来的cmd.exe；</li><li>基本上shell分两大类： GUI shell（图形界面shell）和Command Line Interface shell（命令行式shell）；</li><li>在命令行shell中python draft.py &gt; saveit.txt 可以让输出行都存储在该txt文件中，这叫流重定向 stream redirection。</li></ol><h3 id="六、Module的属性（Attributes）"><a href="#六、Module的属性（Attributes）" class="headerlink" title="六、Module的属性（Attributes）"></a>六、Module的属性（Attributes）</h3><ol><li>a module is mostly just a package of variable names, known as a namespace, and the names within that package are called attributes；</li><li>模块是变量名的包，即命名空间，在包内的变量名称为属性；</li><li>An attribute is simply a variable name that is attached to a specific object (like a module).</li></ol><h1 id="PART-II-Types-and-Operations"><a href="#PART-II-Types-and-Operations" class="headerlink" title="PART II Types and Operations"></a>PART II Types and Operations</h1><h2 id="chapter-4-Introducing-Python-Object-Types"><a href="#chapter-4-Introducing-Python-Object-Types" class="headerlink" title="chapter 4 Introducing Python Object Types"></a>chapter 4 Introducing Python Object Types</h2><h3 id="一、Python-object-types"><a href="#一、Python-object-types" class="headerlink" title="一、Python object types"></a>一、Python object types</h3><ol><li>OOP Object Oriented Programming 面向对象编程</li><li>Python’s Core Data Types或built-in object types（内置对象类型）<ul><li>数字Numbers；字符串Strings；列表Lists；字典Dictionaries；元组Tuples；文件Files；集合Sets；</li><li>Other core types：布尔型Booleans；类型types  Program unit types：函数Functions；模块modules；类classes；</li><li>Implementation-related types：已编译代码Compiled code, 调用栈跟踪stack tracebacks；</li><li>列表是对象的有序集合，字典通过键key存储对象。</li></ul></li><li>作用于多种类型的通用操作都是以内置函数或表达式的形式出现的（如len(X)、X[0])；类型特定的操作是以方法调用的形式出现的（如string.upper())</li></ol><h3 id="二、numbers-and-strings"><a href="#二、numbers-and-strings" class="headerlink" title="二、numbers and strings"></a>二、numbers and strings</h3><ol><li><p>数字Numbers</p><ul><li>数字没有长度，要先转变为字符串再用len函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(<span class="number">12345</span>)))</span><br></pre></td></tr></table></figure></li><li>math module和random module:    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(math.pi)</span><br><span class="line"><span class="built_in">print</span>(math.sqrt(<span class="number">85</span>))</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br><span class="line"><span class="built_in">print</span>(random.choice([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符串Strings</p><ul><li>严格来说字符串是由单字符的字符串所组成的序列sequence；</li><li>（1）序列操作：字符串支持位置顺序的操作，可通过索引indexing操作<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;Spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(S))</span><br><span class="line"><span class="built_in">print</span>(S[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(S[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(S[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(S[<span class="built_in">len</span>(S)-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(S[<span class="number">1</span>:<span class="number">3</span>])  <span class="comment"># 这个叫分片（slice）X[I:J]，注意不包括J。</span></span><br><span class="line"><span class="built_in">print</span>(S[<span class="number">1</span>:])</span><br><span class="line"><span class="built_in">print</span>(S[:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(S[:])</span><br></pre></td></tr></table></figure></li><li>（2）拼接concatenation：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(S + <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(S * <span class="number">8</span>)</span><br></pre></td></tr></table></figure></li><li>加号既可以用作数字加号，也可以字符串拼接，这就是一种多态性 polymorphism：the meaning of an operation depends on the objects being operated on；</li><li>（3）不可变性Immutability：</li><li>you can’t change a string by assigning to one of its positions, but you can always build a new one and assign it to the same name；</li><li>不能通过对位置进行赋值（assign）而改变字符串，但是可以对整个变量赋值；</li><li>比如不能 S[0] = ‘z’<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;z&#x27;</span> + S[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure></li><li>（4）数字、字符串和元组是不可变的，列表、集合、字典是可以变的；</li><li>（5）基于位置改变文本数据：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;shrubbery&#x27;</span></span><br><span class="line">L = <span class="built_in">list</span>(S)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">L[<span class="number">1</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>.join(L)) <span class="comment"># join()方法 str.join(sequence) 将序列中的元素以指定的字符连接生成一个新的字符串</span></span><br><span class="line">B = <span class="built_in">bytearray</span>(<span class="string">b&#x27;spam&#x27;</span>) <span class="comment"># 用bytearray()方法进行拼接</span></span><br><span class="line">B.extend(<span class="string">b&#x27;eggs&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="built_in">print</span>(B.decode())</span><br></pre></td></tr></table></figure></li><li>（6）其他字符串的方法：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;Spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.find(<span class="string">&#x27;pa&#x27;</span>)) <span class="comment"># find()方法 str.find(str, beg=0, end=len(string)) 返回一个查找的字符的偏移量offset，没有找到就返回-1</span></span><br><span class="line"><span class="built_in">print</span>(S.replace(<span class="string">&#x27;pa&#x27;</span>, <span class="string">&#x27;XYZ&#x27;</span>)) <span class="comment">#  replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)</span></span><br><span class="line"><span class="built_in">print</span>(S) <span class="comment"># 因为字符不可变，所以上面方法只是创建新的字符串作为结果</span></span><br><span class="line">line = <span class="string">&#x27;aaa,bbb,ccccc,dd&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(line.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">S = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.upper())</span><br><span class="line"><span class="built_in">print</span>(S.isalpha()) <span class="comment"># isalpha()方法检测字符串是否只由字母组成</span></span><br><span class="line">line = <span class="string">&#x27;aaa,bbb,ccccc,dd\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(line.rstrip())</span><br><span class="line"><span class="built_in">print</span>(line.rstrip().split(<span class="string">&#x27;,&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li>（7）字符串formatting的替代操作（包括f字符串），以下都可以：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;SPAM!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s, eggs, and %s&#x27;</span> % (a, b)) <span class="comment"># Formatting expression (all)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;, eggs, and &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(a, b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;, eggs, and &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;a&#125;</span>, eggs, and <span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:,.2f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">296999.2567</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%.2f | %+05d&#x27;</span> % (<span class="number">3.14159</span>, -<span class="number">42</span>))</span><br></pre></td></tr></table></figure></li><li>（8）内置的dir函数，这个函数会列出再调用者作用域内，形式参数的默认值。 dir：directory（目录）</li><li>这个函数也会返回一个列表，包含对象的所有属性。由于方法是函数属性，也会在列表里。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(S))</span><br><span class="line"><span class="comment"># 例如字符串的_add_方法是真正执行字符串拼接的函数。但尽量避免使用下面的第二个方法，因为运行更慢</span></span><br><span class="line"><span class="built_in">print</span>(S + <span class="string">&#x27;NI!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(S.__add__(<span class="string">&#x27;NI!&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li>help函数可以查询方法是做什么的 比如help(S.replace)</li><li>（9） ord()函数是chr()函数（对于8位的ASCII字符串）或unichr()函数（对于Unicode对象）的配对函数</li><li>它以一个字符（长度为1的字符串）作为参数，返回对应的ASCII数值，或者Unicode数值，是ordinal的缩写<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li>（10）原始raw字符串，去掉反斜线转义机制<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;\nhaha&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nhaha&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>（11）Unicode字符串(ASCII是一种简单的Unicode)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sp\xc4m&#x27;</span>) <span class="comment"># 3.X: normal str strings are Unicode text    \x为16进制转义符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;a\x01c&#x27;</span>) <span class="comment"># bytes字符串表示原始字节值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">u&#x27;sp\u00c4m&#x27;</span>) <span class="comment"># The 2.X Unicode literal works in 3.3+: just str   \u为Unicode转义符，可百度查表\u00c4对应Ä</span></span><br></pre></td></tr></table></figure></li><li>（12）encode()方法、decode()方法进行编码解码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str = &quot;菜鸟教程&quot;</span><br><span class="line">str_utf8 = str.encode(&quot;UTF-8&quot;)</span><br><span class="line">print(&quot;UTF-8 编码：&quot;, str_utf8)</span><br><span class="line">print(&quot;UTF-8 解码：&quot;, str_utf8.decode(&#x27;UTF-8&#x27;))</span><br></pre></td></tr></table></figure></li><li>（13）★正则表达式(regular expression) Python的re模块 用于文本的模式匹配</li><li>正则表达式描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串(搜索)、将匹配的子串替换或者从某个串中取出符合某个条件的子串(分割)等。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">&#x27;Hello[ \t]*(.*)world&#x27;</span>, <span class="string">&#x27;Hello Python world&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">&#x27;[/:](.*)[/:](.*)[/:](.*)&#x27;</span>, <span class="string">&#x27;/usr/home:lumberjack&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.groups())</span><br></pre></td></tr></table></figure></li><li>大致了解一下，37章会更详细说明</li></ul></li></ol><h3 id="三、lists"><a href="#三、lists" class="headerlink" title="三、lists"></a>三、lists</h3><ol><li>列表Lists<ul><li>（1）列表是可变的mutable，与字符串不同，通过对对应偏移量offset进行赋值或者其他方法对列表进行操作，可对列表进行改变：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">123</span>, <span class="string">&#x27;spam&#x27;</span>, <span class="number">1.23</span>] </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(L))</span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">0</span>])</span><br><span class="line">(L[:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(L + [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(L * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(L) <span class="comment"># 列表没变，因为没有赋值</span></span><br><span class="line"></span><br><span class="line">L.append(<span class="string">&#x27;NI&#x27;</span>) <span class="comment"># append方法增加了列表的大小</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="built_in">print</span>(L.pop(<span class="number">2</span>)) <span class="comment"># 弹出并返回 改变了列表 pop：出栈</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line">M = [<span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>]</span><br><span class="line">M.sort() <span class="comment"># sort方法 按升序修改列表排序</span></span><br><span class="line"><span class="built_in">print</span>(M)</span><br><span class="line">M.reverse() <span class="comment"># reverse方法 对列表进行反转修改</span></span><br><span class="line"><span class="built_in">print</span>(M)</span><br></pre></td></tr></table></figure></li><li>（2）嵌套Nesting、矩阵matrixes或者多维数组multidimensional arrays:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(M)</span><br><span class="line"><span class="built_in">print</span>(M[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(M[<span class="number">1</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure></li><li>（3）list comprehension expression列表解析(推导)表达式：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col2 = [row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> M] <span class="comment"># row可以为任意变量名</span></span><br><span class="line"><span class="built_in">print</span>(col2)</span><br><span class="line"><span class="built_in">print</span>([row[<span class="number">1</span>] + <span class="number">1</span> <span class="keyword">for</span> row <span class="keyword">in</span> M])</span><br><span class="line"><span class="built_in">print</span>([row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> M <span class="keyword">if</span> row[<span class="number">1</span>] % <span class="number">2</span> == <span class="number">0</span>])</span><br><span class="line">diag = [M[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="built_in">print</span>(diag)</span><br><span class="line">doubles = [c * <span class="number">2</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;spam&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(doubles)</span><br></pre></td></tr></table></figure></li><li>用range函数来表示循环的次数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">4</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(-<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>([[x ** <span class="number">2</span>, x ** <span class="number">3</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)])</span><br><span class="line"><span class="built_in">print</span>([[x, x / <span class="number">2</span>, x * <span class="number">2</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>) <span class="keyword">if</span> x &gt; <span class="number">0</span>])</span><br></pre></td></tr></table></figure></li><li>下面的内容比较复杂，下面只是作为前瞻：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G = (<span class="built_in">sum</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> M) <span class="comment"># 创建★生成器generator，把一个列表生成式的[]改成()，generator也是可迭代对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(G)) <span class="comment"># iter(G) not required here   iter()函数：生成迭代器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(G)) <span class="comment"># Run the iteration protocol next()  next()：返回迭代器的下一个项目</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">sum</span>, M))) <span class="comment"># map()会根据提供的函数对指定序列做映射</span></span><br></pre></td></tr></table></figure></li><li>comprehension syntax推导语法也可用于字典和集合，以及之前的列表和生成器generators<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(&#123;<span class="built_in">sum</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> M&#125;)</span><br><span class="line"><span class="built_in">print</span>(&#123;i : <span class="built_in">sum</span>(M[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>([<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;spaam&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;spaam&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(&#123;x: <span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;spaam&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>((<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;spaam&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="四、dictionaries"><a href="#四、dictionaries" class="headerlink" title="四、dictionaries"></a>四、dictionaries</h3><ol><li>字典Dictionaries<ul><li>（1）字典不是序列，而是映射（mapping）：</li><li>映射操作，字典编写在大括号里，包含一系列键值对（“key: value” pairs）。不能通过相对位置进行索引。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;food&#x27;</span>: <span class="string">&#x27;Spam&#x27;</span>, <span class="string">&#x27;quantity&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;pink&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(D[<span class="string">&#x27;food&#x27;</span>])</span><br><span class="line">D[<span class="string">&#x27;quantity&#x27;</span>] += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(D)</span><br></pre></td></tr></table></figure></li><li>（2）对键赋值assignments创建新的键值对或修改键值对<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;&#125;</span><br><span class="line">D[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;Tom&#x27;</span> </span><br><span class="line">D[<span class="string">&#x27;job&#x27;</span>] = <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">D[<span class="string">&#x27;age&#x27;</span>] = <span class="number">40</span></span><br><span class="line"><span class="built_in">print</span>(D)</span><br><span class="line">D[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(D)</span><br></pre></td></tr></table></figure></li><li>（3）其他方式创建字典<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bob1 = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, job=<span class="string">&#x27;dev&#x27;</span>, age=<span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(bob1)</span><br><span class="line">bob2 = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;job&#x27;</span>, <span class="string">&#x27;age&#x27;</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;dev&#x27;</span>, <span class="number">40</span>])) <span class="comment"># zip()函数将对象中对应的元素打包成一个个元组</span></span><br><span class="line"><span class="built_in">print</span>(bob2)</span><br></pre></td></tr></table></figure></li><li>（4）nesting嵌套<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rec = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: &#123;<span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;Smith&#x27;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;jobs&#x27;</span>: [<span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;mgr&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">40.5</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(rec[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(rec[<span class="string">&#x27;name&#x27;</span>][<span class="string">&#x27;last&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(rec[<span class="string">&#x27;jobs&#x27;</span>][-<span class="number">1</span>])</span><br><span class="line">rec[<span class="string">&#x27;jobs&#x27;</span>].append(<span class="string">&#x27;janitor&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rec)</span><br></pre></td></tr></table></figure></li><li>（5）用if语句测试键是否在字典里<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="string">&#x27;f&#x27;</span> <span class="keyword">in</span> D: <span class="comment"># &#x27;f&#x27; in D是False，not False = True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;missing&#x27;</span>)</span><br><span class="line"><span class="comment"># 其他方法测试，大致介绍，后面会详细</span></span><br><span class="line">value = D.get(<span class="string">&#x27;x&#x27;</span>, <span class="number">0</span>) <span class="comment">#  get()函数返回指定键的值，如果指定的键不存在时返回指定的默认值</span></span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line">value = D[<span class="string">&#x27;x&#x27;</span>] <span class="keyword">if</span> <span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> D <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure></li><li>（6）键的排序<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">Ks = <span class="built_in">list</span>(D.keys())</span><br><span class="line">Ks.sort() <span class="comment"># 列表的sort()方法</span></span><br><span class="line"><span class="built_in">print</span>(Ks)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> Ks: </span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;=&gt;&#x27;</span>, D[key])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(D): <span class="comment"># sorted()函数</span></span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&#x27;=&gt;&#x27;</span>, D[key])</span><br></pre></td></tr></table></figure></li><li>（7）迭代和优化Iteration and Optimization</li><li>for loop（for循环）是通用迭代工具，遵守迭代协议；</li><li>an object is iterable if it is either a physically stored sequence in memory, or an object that generates one item at a time in the context of an iteration operation — a sort of “virtual” sequence；</li><li>一个可迭代对象可以是在内存物理存储的序列，也可以是迭代操作下产生的对象（一种虚拟的序列）；</li><li>前面的生成器（generator）就是一个可迭代对象，它在值并非存储在内存中，而是通过迭代工具在被请求时生成；</li><li>这里初步认识一下，后面会详细说明迭代协议iteration protocol；</li><li>任何一个从左到右扫描一个对象的Python工具都使用迭代协议；</li><li>下面2种工具在迭代协议内部发挥作用，并产生相同结果：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]] <span class="comment"># 列表推导表达式</span></span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]: </span><br><span class="line">    squares.append(x ** <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br></pre></td></tr></table></figure></li><li>列表推导和相关的函数编程工具（如map和filter）通常运行得比for循环快；</li><li>“iterable,” means either a physical sequence, or a virtual one that produces its items on request.</li></ul></li></ol><h3 id="五、tuples"><a href="#五、tuples" class="headerlink" title="五、tuples"></a>五、tuples</h3><ol><li>元组Tuples<ul><li>（1）元组是序列，但它具有不可变性，和字符串类似。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(T))</span><br><span class="line"><span class="built_in">print</span>(T + (<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></li><li>（2）元组还有2个专有的可调用方法<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(T.index(<span class="number">4</span>)) <span class="comment"># T中4的索引是3</span></span><br><span class="line"><span class="built_in">print</span>(T.count(<span class="number">4</span>)) <span class="comment"># T中4出现了1次</span></span><br></pre></td></tr></table></figure></li><li>（3）元组不能对索引进行赋值，因为具有不可变性</li><li>比如T[0] = 2会错误</li><li>只含一个元素的元组需要逗号作为结尾<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">T = (<span class="number">2</span>,) + T[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(T)</span><br></pre></td></tr></table></figure></li><li>（4）嵌套nesting</li><li>元组元素的圆括号通常可以被省略<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = <span class="string">&#x27;spam&#x27;</span>, <span class="number">3.0</span>, [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">2</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="六、files"><a href="#六、files" class="headerlink" title="六、files"></a>六、files</h3><ol><li>文件Files<ul><li>（1）File objects are Python code’s main interface（接口） to external files on your computer；</li><li>open函数实例如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;Hello\n&#x27;</span>) <span class="comment"># 该方法会返回6，因为有6bytes被写入，utf-8中一个英文字符等于一个字节，该源文件由utf-8编码。</span></span><br><span class="line">f.write(<span class="string">&#x27;world\n&#x27;</span>) <span class="comment"># 该方法会返回6，因为有6bytes被写入，utf-8中一个英文字符等于一个字节</span></span><br><span class="line">f.close()</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">text = f.read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"><span class="built_in">print</span>(text.split())</span><br></pre></td></tr></table></figure></li><li>如今读取一个文件的最佳方式就是根本不读它，而是通过文件提供的一个迭代器（iterator）在for循环或其他上下文自动逐行读取：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>): <span class="built_in">print</span>(line)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(f))</span><br></pre></td></tr></table></figure></li><li>（2）二进制字节文件Binary Bytes Files</li><li>文本文件把内容显示为正常的str字符串，并且在写入读取数据时自动执行Unicode编码和解码；</li><li>而二进制文件把内容显示为一个特定的字节字符串，并且允许你不修改地访问文件内容；</li><li>Python的struct模块可以同时创建和解析被打包过的二进制数据来写入一个二进制模式的文件；<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">packed = struct.pack(<span class="string">&#x27;&gt;i4sh&#x27;</span>, <span class="number">7</span>, <span class="string">b&#x27;spam&#x27;</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(packed) <span class="comment"># 10 bytes, not objects or text，显示出的为特定的字节字符串</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;data.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">file.write(packed) <span class="comment"># 该方法会返回10，因为有10bytes被写入</span></span><br><span class="line">file.close()</span><br><span class="line">data = <span class="built_in">open</span>(<span class="string">&#x27;data.bin&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">4</span>:<span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(data)) <span class="comment"># 小写s的Unicode编码为115，p为112，a为97，m为109</span></span><br><span class="line"><span class="built_in">print</span>(struct.unpack(<span class="string">&#x27;&gt;i4sh&#x27;</span>, data))</span><br></pre></td></tr></table></figure></li><li>（3）Unicode文本文件Unicode Text Files</li><li>为了访问文件中的非ASCII编码的Unicode文本，可以传入一个编码名参数。读取和写入时按指定的编码范式进行解码和编码；<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;sp\xc4m&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;unidata.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment"># Write/encode UTF-8 text</span></span><br><span class="line">file.write(S) <span class="comment"># 该方法会返回4，因为有4bytes被写入</span></span><br><span class="line">file.close()</span><br><span class="line">text = <span class="built_in">open</span>(<span class="string">&#x27;unidata.txt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(text))</span><br><span class="line"></span><br><span class="line">raw = <span class="built_in">open</span>(<span class="string">&#x27;unidata.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(raw)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(raw))</span><br><span class="line"><span class="built_in">print</span>(text.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(raw.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(text.encode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(text.encode(<span class="string">&#x27;utf-16&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(text.encode(<span class="string">&#x27;latin-1&#x27;</span>)), <span class="built_in">len</span>(text.encode(<span class="string">&#x27;utf-16&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;\xff\xfes\x00p\x00\xc4\x00m\x00&#x27;</span>.decode(<span class="string">&#x27;utf-16&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li>（4）其他类文件工具：Python comes with additional file-like tools: pipes(管道), FIFOs, sockets(套接字), keyed-access files(键值访问文件), persistent object shelves(持久化对象shelve), descriptor-based files(基于描述符的文件), relational and object-oriented database interfaces(关系型数据库接口和面向对象数据库接口等), and more.</li></ul></li></ol><h3 id="七、Other-core-types"><a href="#七、Other-core-types" class="headerlink" title="七、Other core types"></a>七、Other core types</h3><ol><li><p>集合Sets</p><ul><li>集合不是映射也不是序列，它是不可变的唯一对象的无序集合；</li><li><p>集合是大括号{}，更像是一个无值的字典的键；</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="built_in">set</span>(<span class="string">&#x27;spam&#x27;</span>) <span class="comment"># set()函数</span></span><br><span class="line">Y = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>&#125;</span><br><span class="line">Z = X, Y</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"><span class="built_in">print</span>(X &amp; Y) <span class="comment"># Intersection</span></span><br><span class="line"><span class="built_in">print</span>(X | Y) <span class="comment"># Union</span></span><br><span class="line"><span class="built_in">print</span>(X - Y) <span class="comment"># Difference</span></span><br><span class="line"><span class="built_in">print</span>(X &gt; Y) <span class="comment"># Superset</span></span><br><span class="line"><span class="built_in">print</span>(&#123;n ** <span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;) <span class="comment"># Set comprehensions 集合推导式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>])))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="string">&#x27;spam&#x27;</span>) - <span class="built_in">set</span>(<span class="string">&#x27;ham&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="string">&#x27;spam&#x27;</span>) == <span class="built_in">set</span>(<span class="string">&#x27;asmp&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> <span class="built_in">set</span>(<span class="string">&#x27;spam&#x27;</span>), <span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;ham&#x27;</span> <span class="keyword">in</span> [<span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;ham&#x27;</span>])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数值类型：十进制数decimal和分数fraction</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">1</span>/<span class="number">3</span>))</span><br><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line">d = decimal.Decimal(<span class="string">&#x27;3.141&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(d + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(d+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">decimal.getcontext().prec = <span class="number">2</span> <span class="comment"># prec:precision精度</span></span><br><span class="line">e = decimal.Decimal(<span class="string">&#x27;1.00&#x27;</span>) / decimal.Decimal(<span class="string">&#x27;3.00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line">f = Fraction(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f))</span><br><span class="line"><span class="built_in">print</span>(f + Fraction(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></li><li><p>布尔值 Booleans 包括True、False、None</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span> &gt; <span class="number">2</span>, <span class="number">1</span> &lt; <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&#x27;spam&#x27;</span>))  <span class="comment"># Object&#x27;s Boolean value</span></span><br><span class="line">X = <span class="literal">None</span></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line">L = [<span class="literal">None</span>] * <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(L))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(L)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(L) == <span class="built_in">type</span>([]): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(L) == <span class="built_in">list</span>: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(L, <span class="built_in">list</span>): <span class="comment"># 判断一个对象是否为一个类型</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;yes&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>定义的类class</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, pay</span>): <span class="comment"># Initialize when created</span></span><br><span class="line">        self.name = name <span class="comment"># self is the new object</span></span><br><span class="line">        self.pay = pay</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastName</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name.split()[-<span class="number">1</span>] <span class="comment"># Split string on blanks</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">giveRaise</span>(<span class="params">self, percent</span>):</span><br><span class="line">        self.pay *= (<span class="number">1</span> + percent) <span class="comment"># Update pay in place</span></span><br><span class="line"></span><br><span class="line">bob = Worker(<span class="string">&#x27;Bob Smith&#x27;</span>, <span class="number">50000</span>) <span class="comment"># Make two instances</span></span><br><span class="line">sue = Worker(<span class="string">&#x27;Sue Jones&#x27;</span>, <span class="number">60000</span>) </span><br><span class="line"><span class="built_in">print</span>(bob.lastName()) <span class="comment"># Call method: bob is self</span></span><br><span class="line"><span class="built_in">print</span>(sue.lastName()) <span class="comment"># sue is the self subject</span></span><br><span class="line">sue.giveRaise(<span class="number">.10</span>) <span class="comment"># Updates sue&#x27;s pay</span></span><br><span class="line"><span class="built_in">print</span>(sue.pay)</span><br></pre></td></tr></table></figure><ul><li>name和pay是类的属性attributes (sometimes called 状态信息state information)；</li><li>lastName和giveRaise是类的方法functions (normally called methods)。</li></ul></li></ol><h2 id="chapter-5-Numeric-Types"><a href="#chapter-5-Numeric-Types" class="headerlink" title="chapter 5 Numeric Types"></a>chapter 5 Numeric Types</h2><h3 id="一、Numeric-Type-Basics"><a href="#一、Numeric-Type-Basics" class="headerlink" title="一、Numeric Type Basics"></a>一、Numeric Type Basics</h3><ol><li><p>完整的Python数值类型工具包括：</p><ul><li>Integer and floating-point objects 整数和浮点对象；</li><li>Complex number objects 复数对象；</li><li>Decimal: fixed-precision objects 小数：固定精度对象；</li><li>Fraction: rational number objects 分数：有理数对象；</li><li>Sets: collections with numeric operations 集合：带有数值运算的集合体；</li><li>Booleans: true and false 布尔值：真和假；</li><li>Built-in functions and modules: round, math, random, etc. 内置函数和模块；</li><li>Expressions; unlimited integer precision; bitwise operations; hex, octal, and binary formats 表达式；无限制整数精度；位运算；十六进制，八进制和二进制格式；</li><li>Third-party extensions: vectors, libraries, visualization, plotting, etc. 第三方拓展：向量、库、可视化、作图等。</li></ul></li><li><p>数值字面量Numeric Literals</p><ul><li>浮点数包括小数和带科学计数标志e即幂的数字；</li><li>十六进制以0X或0x开头；八进制以0o或0O开头；二进制以0b或0B开头：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">18</span>)) <span class="comment"># 转换为十六进制hexadecimal</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">18</span>)) <span class="comment"># 转换为八进制octonary</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">18</span>)) <span class="comment"># 转换为二进制binary</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;0b100&#x27;</span>, base=<span class="number">2</span>)) <span class="comment"># 将字符串以base进制转换为整数</span></span><br></pre></td></tr></table></figure></li><li>复数字面量被写成实部realpart和虚部imaginarypart，虚部以j或J结尾：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">aa=<span class="number">123</span>-<span class="number">12j</span></span><br><span class="line"><span class="built_in">print</span>(aa.real)</span><br><span class="line"><span class="built_in">print</span>(aa.imag)</span><br><span class="line"><span class="built_in">print</span>(aa)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">complex</span>(<span class="number">123</span>, -<span class="number">12</span>)) <span class="comment"># complex(real, imag)来创建复数</span></span><br></pre></td></tr></table></figure></li><li>导入模块调入小数分数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> decimal, fractions</span><br><span class="line"><span class="built_in">print</span>(decimal.Decimal(<span class="string">&#x27;1.0&#x27;</span>)) </span><br><span class="line"><span class="built_in">print</span>(fractions.Fraction(<span class="number">1</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>内置built-in数值工具</p><ul><li>包括表达式运算符Expression Operators；内置数学函数；工具模块</li><li>下面的运算符从上到下优先级逐渐升高：</li></ul></li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">Operators</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">yield x</td><td style="text-align:left">生成器函数send协议</td></tr><tr><td style="text-align:left">lambda args: expression</td><td style="text-align:left">创建匿名函数</td></tr><tr><td style="text-align:left">x if y else z</td><td style="text-align:left">三元选择表达式（仅当y为真时，x才会被计算）Ternary selection</td></tr><tr><td style="text-align:left">x or y</td><td style="text-align:left">逻辑或（仅当x为假时，y才会被计算）Logical OR</td></tr><tr><td style="text-align:left">x and y</td><td style="text-align:left">逻辑与（仅当x为真时，y才会被计算）Logical AND</td></tr><tr><td style="text-align:left">not x</td><td style="text-align:left">逻辑非Logical negation</td></tr><tr><td style="text-align:left">x in y, x not in y</td><td style="text-align:left">成员关系 (iterables, sets)</td></tr><tr><td style="text-align:left">x is y, x is not y</td><td style="text-align:left">对象同一性测试</td></tr><tr><td style="text-align:left">x &lt; y, x &lt;= y, x &gt; y, x &gt;= y</td><td style="text-align:left">大小比较、集合的子集和超集subset and superset</td></tr><tr><td style="text-align:left">x == y, x != y</td><td style="text-align:left">值等价性运算符</td></tr><tr><td style="text-align:left">x &#124; y</td><td style="text-align:left">按位与、集合交集Bitwise OR, set union</td></tr><tr><td style="text-align:left">x ^ y</td><td style="text-align:left">按位异或、集合对称差集Bitwise XOR, set symmetric difference</td></tr><tr><td style="text-align:left">x &amp; y</td><td style="text-align:left">按位与、集合交集Bitwise AND, set intersection</td></tr><tr><td style="text-align:left">x &lt;&lt; y, x &gt;&gt; y</td><td style="text-align:left">将x左移或右移y位Shift x left or right by y bits</td></tr><tr><td style="text-align:left">x + y</td><td style="text-align:left">加法、拼接Addition, concatenation</td></tr><tr><td style="text-align:left">x – y</td><td style="text-align:left">减法、集合差集Subtraction, set difference</td></tr><tr><td style="text-align:left">x * y</td><td style="text-align:left">乘法、重复Multiplication, repetition</td></tr><tr><td style="text-align:left">x % y</td><td style="text-align:left">取余数、格式化字符串Remainder, format</td></tr><tr><td style="text-align:left">x / y, x // y</td><td style="text-align:left">真除法、向下取整除法Division: true and floor</td></tr><tr><td style="text-align:left">−x, +x</td><td style="text-align:left">取负、取正Negation, identity</td></tr><tr><td style="text-align:left">˜x</td><td style="text-align:left">按位非（取反码）Bitwise NOT (inversion)</td></tr><tr><td style="text-align:left">x ** y</td><td style="text-align:left">幂运算（指数）Power (exponentiation)</td></tr><tr><td style="text-align:left">x[i]</td><td style="text-align:left">索引（序列、映射等）Indexing (sequence, mapping, others)</td></tr><tr><td style="text-align:left">x[i:j:k]</td><td style="text-align:left">分片Slicing</td></tr><tr><td style="text-align:left">x(…)</td><td style="text-align:left">调用（函数、方法、类，其他可调用对象）Call (function, method, class, other callable)</td></tr><tr><td style="text-align:left">x.attr</td><td style="text-align:left">属性引用Attribute reference</td></tr><tr><td style="text-align:left">(…)</td><td style="text-align:left">元组、表达式、生成器表达式 Tuple, expression, generator expression</td></tr><tr><td style="text-align:left">[…]</td><td style="text-align:left">列表、列表推导List, list comprehension</td></tr><tr><td style="text-align:left">{…}</td><td style="text-align:left">字典、集合、集合与字典推导Dictionary, set, set and dictionary comprehensions</td></tr></tbody></table></div><ol><li>运算符重载和多态Operator overloading and polymorphism<ul><li>Python itself automatically overloads some operators, such that they perform different actions depending on the type of built-in objects being processed.</li><li>就是比如加号在数字上就是加法，字符串上就是拼接，用在自己定义的类的对象上时，可以执行任意操作；</li><li>这种特性被成为多态，即操作的意义由操作对象来决定。</li></ul></li></ol><h3 id="二、Numbers-in-Action"><a href="#二、Numbers-in-Action" class="headerlink" title="二、Numbers in Action"></a>二、Numbers in Action</h3><ol><li><p>数值的显示格式</p><ul><li><p>以下的字符串格式化string formatting在第7章介绍</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">1</span> / <span class="number">3.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%e&#x27;</span> % num)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%4.2f&#x27;</span> % num)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:4.2f&#125;&#x27;</span>.<span class="built_in">format</span>(num))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>普通比较和链式比较Chained</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = <span class="number">2</span></span><br><span class="line">Y = <span class="number">4</span></span><br><span class="line">Z = <span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(X &lt; Y &lt; Z) <span class="comment"># 链式比较，等于X &lt; Y and Y &lt; Z</span></span><br></pre></td></tr></table></figure><ul><li><p>★注意：浮点数的比较可能会出错，需要其他处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1.1</span> + <span class="number">2.2</span> == <span class="number">3.3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1.1</span> + <span class="number">2.2</span>) <span class="comment"># 浮点数因为有限的比特位数，而不能精确地表示某些值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="number">1.1</span> + <span class="number">2.2</span>) == <span class="built_in">int</span>(<span class="number">3.3</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>经典除法</p><ul><li>在Python 2.X或之前的版本中，5/2得到的结果为2，这个就是经典除法，因为整数除以整数得到整数；</li><li><p>在Python 3.X中总是执行真除法，不管操作数的类型，都返回包括任何小数部分的一个浮点结果，甚至包括9/3得到3.0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="number">9</span> / <span class="number">3</span>), (<span class="number">9.0</span> / <span class="number">3</span>), (<span class="number">9</span> // <span class="number">3</span>), (<span class="number">9</span> // <span class="number">3.0</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>向下取整除法vs截断除法Floor versus truncation</p><ul><li>//运算符地非正式别名为截断除法，但向下舍入不是严格地截断；</li><li><p>用math模块可以看出上述区别：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(math.floor(<span class="number">2.5</span>))</span><br><span class="line"><span class="built_in">print</span>(math.floor(-<span class="number">2.5</span>))</span><br><span class="line"><span class="built_in">print</span>(math.trunc(<span class="number">2.5</span>)) <span class="comment"># truncation截断</span></span><br><span class="line"><span class="built_in">print</span>(math.trunc(-<span class="number">2.5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> // <span class="number">2</span>, <span class="number">5</span> // -<span class="number">2</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> // <span class="number">2.0</span>, <span class="number">5</span> // -<span class="number">2.0</span>) <span class="comment"># //的结果的数据类型总是依赖于操作数的类型</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>十六进制、八进制和二进制：字面量Literals与转换</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">0o1</span>, <span class="number">0o20</span>, <span class="number">0o377</span>) <span class="comment"># 八进制字面量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0x01</span>, <span class="number">0x10</span>, <span class="number">0xFF</span>) <span class="comment"># 十六进制字面量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0b1</span>, <span class="number">0b10000</span>, <span class="number">0b11111111</span>) <span class="comment"># 二进制字面量</span></span><br><span class="line"><span class="comment"># 十进制转换为其他进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">64</span>), <span class="built_in">hex</span>(<span class="number">64</span>), <span class="built_in">bin</span>(<span class="number">64</span>))</span><br><span class="line"><span class="comment"># 通过int函数将字符串转换为选定进制的整数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;64&#x27;</span>), <span class="built_in">int</span>(<span class="string">&#x27;100&#x27;</span>, <span class="number">8</span>), <span class="built_in">int</span>(<span class="string">&#x27;40&#x27;</span>, <span class="number">16</span>), <span class="built_in">int</span>(<span class="string">&#x27;1000000&#x27;</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># eval()函数用来执行一个字符串表达式，并返回表达式的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;64&#x27;</span>), <span class="built_in">eval</span>(<span class="string">&#x27;0o100&#x27;</span>), <span class="built_in">eval</span>(<span class="string">&#x27;0x40&#x27;</span>), <span class="built_in">eval</span>(<span class="string">&#x27;0b1000000&#x27;</span>))</span><br><span class="line"><span class="comment"># 用字符串格式化将整数转换为指定的字符串，详见第七章</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:o&#125;, &#123;1:x&#125;, &#123;2:b&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">64</span>, <span class="number">64</span>, <span class="number">64</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%o, %x, %x, %X&#x27;</span> % (<span class="number">64</span>, <span class="number">64</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br></pre></td></tr></table></figure></li><li><p>按位操作Bitwise Operations</p><ul><li>bit：位、比特、比特位；byte：字节</li><li><p>这里不涉及位运算的细节。工作中若涉及二进制数据包会有用，需要再学习。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(x &lt;&lt; <span class="number">2</span>) <span class="comment"># 1为0001 in bits 向左移2 bits 即0100，相当于十进制的4</span></span><br><span class="line"><span class="built_in">print</span>(x | <span class="number">2</span>) <span class="comment"># Bitwise OR 按位或：0001|0010 = 0011，相当于十进制的3</span></span><br><span class="line"><span class="built_in">print</span>(x &amp; <span class="number">1</span>) <span class="comment"># Bitwise AND 按位和：0001&amp;0001 = 0001，相当于十进制的1</span></span><br><span class="line">X = <span class="number">0xFF</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(X))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(X ^ <span class="number">0b10101010</span>)) <span class="comment"># Bitwise XOR 按位异或：either but not both：11111111^10101010 = 01010101</span></span><br><span class="line"><span class="comment"># 用bit_length方法获取数字的位数，len函数也可以</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">256</span>), (<span class="number">256</span>).bit_length(), <span class="built_in">len</span>(<span class="built_in">bin</span>(<span class="number">256</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他内置数值工具Other Built-in Numeric Tools</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内置函数pow和abs，内置模块math</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(math.pi, math.e)</span><br><span class="line"><span class="built_in">print</span>(math.sin(<span class="number">2</span> * math.pi / <span class="number">180</span>)) <span class="comment"># math.pi = 3.14 = 180°，故这里结果为sin(2)</span></span><br><span class="line"><span class="built_in">print</span>(math.sqrt(<span class="number">144</span>), math.sqrt(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">4</span>), <span class="number">2</span> ** <span class="number">4</span>, <span class="number">2.0</span> ** <span class="number">4.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(-<span class="number">42.0</span>), <span class="built_in">sum</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>), <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(math.floor(<span class="number">2.567</span>), math.floor(-<span class="number">2.567</span>))</span><br><span class="line"><span class="built_in">print</span>(math.trunc(<span class="number">2.567</span>), math.trunc(-<span class="number">2.567</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">2.567</span>), <span class="built_in">round</span>(<span class="number">2.467</span>), <span class="built_in">round</span>(<span class="number">2.567</span>, <span class="number">2</span>)) <span class="comment"># round(2.5)为2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%.1f&#x27;</span> % <span class="number">2.567</span>, <span class="string">&#x27;&#123;0:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">2.567</span>))</span><br><span class="line"><span class="comment"># 平方根的3种方式</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(math.sqrt(<span class="number">144</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">144</span> ** <span class="number">.5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">144</span>, <span class="number">.5</span>))</span><br><span class="line"><span class="comment"># random模块</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.random()) <span class="comment"># 0-1的随机浮点数</span></span><br><span class="line"><span class="built_in">print</span>(random.randint(<span class="number">1</span>, <span class="number">10</span>)) <span class="comment"># 2个数字之间挑选一个随机整数</span></span><br><span class="line"><span class="comment"># random模块从一个序列中随机选取一项，或随机打乱shuffle列表中的元素，shuffle：洗牌、打乱次序</span></span><br><span class="line"><span class="built_in">print</span>(random.choice([<span class="string">&#x27;Life of Brian&#x27;</span>, <span class="string">&#x27;Holy Grail&#x27;</span>, <span class="string">&#x27;Meaning of Life&#x27;</span>]))</span><br><span class="line">suits = [<span class="string">&#x27;hearts&#x27;</span>, <span class="string">&#x27;clubs&#x27;</span>, <span class="string">&#x27;diamonds&#x27;</span>, <span class="string">&#x27;spades&#x27;</span>]</span><br><span class="line">random.shuffle(suits)</span><br><span class="line"><span class="built_in">print</span>(suits)</span><br></pre></td></tr></table></figure></li></ol><h3 id="三、Other-Numeric-Types"><a href="#三、Other-Numeric-Types" class="headerlink" title="三、Other Numeric Types"></a>三、Other Numeric Types</h3><ol><li><p>Decimal Type小数类型</p><ul><li>区分Decimal与浮点数，Decimal有固定的位数和小数点，可以理解为精度固定的浮点数。</li><li>浮点数运算缺乏精确性，所有小数对象虽然带来了性能上的损失，但精度更大。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> - <span class="number">0.3</span>)</span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="built_in">print</span>(Decimal(<span class="string">&#x27;0.1&#x27;</span>) + Decimal(<span class="string">&#x27;0.1&#x27;</span>) + Decimal(<span class="string">&#x27;0.1&#x27;</span>) - Decimal(<span class="string">&#x27;0.3&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Decimal(<span class="string">&#x27;0.1&#x27;</span>) + Decimal(<span class="string">&#x27;0.1&#x27;</span>) + Decimal(<span class="string">&#x27;0.1&#x27;</span>) - Decimal(<span class="string">&#x27;0.3&#x27;</span>)))</span><br><span class="line"><span class="comment"># Decimal最好传入字符串，也可以传入浮点数，但是会产生默认且庞大的小数位数，所以最好用str函数变为字符串</span></span><br><span class="line"><span class="built_in">print</span>(Decimal(<span class="number">0.1</span>) + Decimal(<span class="number">0.1</span>) + Decimal(<span class="number">0.1</span>) - Decimal(<span class="number">0.3</span>))</span><br><span class="line"><span class="comment"># 设置全局小数精度</span></span><br><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line"><span class="built_in">print</span>(decimal.Decimal(<span class="number">1</span>) / decimal.Decimal(<span class="number">7</span>))</span><br><span class="line">decimal.getcontext().prec = <span class="number">4</span> <span class="comment"># 全局小数精度</span></span><br><span class="line"><span class="built_in">print</span>(decimal.getcontext())</span><br><span class="line"><span class="built_in">print</span>(decimal.Decimal(<span class="number">1</span>) / decimal.Decimal(<span class="number">7</span>))</span><br><span class="line"><span class="built_in">print</span>(Decimal(<span class="number">0.1</span>) + Decimal(<span class="number">0.1</span>) + Decimal(<span class="number">0.1</span>) - Decimal(<span class="number">0.3</span>))</span><br><span class="line"><span class="comment"># 用with上下文管理器语句context manager statement来临时重置小数精度</span></span><br><span class="line"><span class="comment"># 在with语句退出后，精度会重置为初始值。with语句详见第34章</span></span><br><span class="line"><span class="built_in">print</span>(decimal.Decimal(<span class="string">&#x27;1.00&#x27;</span>) / decimal.Decimal(<span class="string">&#x27;3.00&#x27;</span>))</span><br><span class="line"><span class="keyword">with</span> decimal.localcontext() <span class="keyword">as</span> ctx: <span class="comment"># 注意是local</span></span><br><span class="line">    ctx.prec = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(decimal.Decimal(<span class="string">&#x27;1.00&#x27;</span>) / decimal.Decimal(<span class="string">&#x27;3.00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(decimal.Decimal(<span class="string">&#x27;1.00&#x27;</span>) / decimal.Decimal(<span class="string">&#x27;3.00&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Fraction Type分数类型</p><ul><li>也可处理浮点类型的数值不确定性<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line">x = Fraction(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">y = Fraction(<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(x, y)</span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"><span class="built_in">print</span>(x * y)</span><br><span class="line"><span class="comment"># 分数对象也可以用浮点数字符串来创建</span></span><br><span class="line"><span class="built_in">print</span>(Fraction(<span class="string">&#x27;.25&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Fraction和Decimal都提供了得到精确结果的方式，但这需要付出一些速度和代码冗余性的代价。</p></li><li><p>分数转换和混用类型</p><ul><li>浮点数对象的as_integer_ratio()方法：将一个float用分数表示出来，返回的是一个二元元组。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="number">2.5</span>).as_integer_ratio())</span><br><span class="line">f = <span class="number">2.5</span></span><br><span class="line">z = Fraction(*f.as_integer_ratio()) <span class="comment"># 这里的*是一种特殊的语法syntax，可以把一个元组展开为独立的参数。18章会更详细</span></span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">float</span>(z))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Fraction.from_float(<span class="number">1.75</span>)) <span class="comment"># 分数的from_float方法</span></span><br><span class="line"><span class="built_in">print</span>(Fraction(*(<span class="number">1.75</span>).as_integer_ratio()))</span><br><span class="line"><span class="comment"># 表达式允许某些类型的互用</span></span><br><span class="line"><span class="built_in">print</span>(x + <span class="number">2</span>) <span class="comment"># Fraction + int -&gt; Fraction</span></span><br><span class="line"><span class="built_in">print</span>(x + <span class="number">2.0</span>) <span class="comment"># Fraction + float -&gt; float</span></span><br><span class="line"><span class="built_in">print</span>(x + (<span class="number">1.</span>/<span class="number">3</span>)) <span class="comment"># Fraction + float -&gt; float</span></span><br><span class="line"><span class="built_in">print</span>(x + Fraction(<span class="number">4</span>, <span class="number">3</span>)) <span class="comment"># Fraction + Fraction -&gt; Fraction</span></span><br><span class="line"><span class="comment"># 尽管可以把浮点数转换为分数，但会出现精度损失</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">4.0</span> / <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>((<span class="number">4.0</span> / <span class="number">3</span>).as_integer_ratio())</span><br><span class="line">a = Fraction(*(<span class="number">4.0</span> / <span class="number">3</span>).as_integer_ratio())</span><br><span class="line"><span class="built_in">print</span>(<span class="number">6004799503160661</span> / <span class="number">4503599627370496</span>) <span class="comment"># 非常接近于4/3</span></span><br><span class="line"><span class="built_in">print</span>(a.limit_denominator(<span class="number">10</span>)) <span class="comment"># 限制分母的最大值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Sets集合</p><ul><li>集合是无序的unordered，可迭代的iterable，既不是序列sequence也不是映射mapping类型，是一些唯一的、不可变的对象的一个无序集合体。同数学集合。</li><li>集合是无值的字典，可以使用集合字面量形式set literal form，即花括号（大括号）curly braces<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set函数</span></span><br><span class="line">x = <span class="built_in">set</span>(<span class="string">&#x27;abcde&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">y = <span class="built_in">set</span>(<span class="string">&#x27;bdxyz&#x27;</span>)</span><br><span class="line"><span class="comment"># 集合通过表达式运算符支持一般的数学集合运算。</span></span><br><span class="line"><span class="built_in">print</span>(x - y) <span class="comment"># Difference</span></span><br><span class="line"><span class="built_in">print</span>(x | y) <span class="comment"># Union</span></span><br><span class="line"><span class="built_in">print</span>(x &amp; y) <span class="comment"># Intersection</span></span><br><span class="line"><span class="built_in">print</span>(x ^ y) <span class="comment"># Symmetric difference (XOR)</span></span><br><span class="line"><span class="built_in">print</span>(x &gt; y, x &lt; y) <span class="comment"># Superset, subset</span></span><br><span class="line"><span class="comment"># in测试</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;e&#x27;</span> <span class="keyword">in</span> x)</span><br><span class="line"><span class="comment"># 集合的intersection方法；union方法；add方法；update方法；remove方法；issubst方法</span></span><br><span class="line">z = x.intersection(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line">z.add(<span class="string">&#x27;SPAM&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line">z.update(<span class="built_in">set</span>([<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line">z.remove(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line">S = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(S.union([<span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line"><span class="built_in">print</span>(S.intersection((<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>)))</span><br><span class="line"><span class="built_in">print</span>(S.issubset(<span class="built_in">range</span>(-<span class="number">5</span>, <span class="number">5</span>)))</span><br></pre></td></tr></table></figure></li><li>集合是可迭代的容器，可以用于len、for循环和列表推导的操作</li><li>{}是个字典，空的集合需要用函数set来创建</li><li>Immutable constraints and frozen sets不可变性限制与冻结集合</li><li>集合只能包含不可变的immutable (a.k.a. “hashable”)对象类型，列表和字典不能嵌入到集合里，但元组可以嵌入集合</li><li>比如print(S.add([1, 2, 3])) 会出来TypeError: unhashable type: ‘list’</li><li>若要在另一个集合中存储一个集合，可以用内置函数frozenset创建一个不可变的集合，该集合不可修改，并且可以嵌套到其他集合中。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">set</span>(<span class="string">&#x27;abc&#x27;</span>): <span class="built_in">print</span>(item * <span class="number">3</span>)</span><br><span class="line">S = &#123;<span class="number">1.23</span>&#125;</span><br><span class="line">S.add((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"><span class="comment"># Set comprehensions集合推导式</span></span><br><span class="line"><span class="built_in">print</span>(&#123;x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"><span class="built_in">print</span>(&#123;c * <span class="number">4</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;spam&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># 集合可以用于提取列表、字符串以及可迭代对象的差异</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="built_in">bytes</span>)) - <span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="built_in">bytearray</span>))) <span class="comment"># In bytes but not bytearray</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="built_in">bytearray</span>)) - <span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="built_in">bytes</span>))) <span class="comment"># In bytearray but not bytes</span></span><br><span class="line"><span class="comment"># 可以借助集合进行顺序无关的等价性测试</span></span><br><span class="line">L1, L2 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(L1 == L2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(L1) == <span class="built_in">set</span>(L2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(L1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(L1) == <span class="built_in">sorted</span>(L2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;spam&#x27;</span> == <span class="string">&#x27;asmp&#x27;</span>, <span class="built_in">set</span>(<span class="string">&#x27;spam&#x27;</span>) == <span class="built_in">set</span>(<span class="string">&#x27;asmp&#x27;</span>), <span class="built_in">sorted</span>(<span class="string">&#x27;spam&#x27;</span>) == <span class="built_in">sorted</span>(<span class="string">&#x27;asmp&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Booleans布尔型</p><ul><li>True和False可看作整数1和0<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="literal">True</span>, <span class="built_in">int</span>)) <span class="comment"># isinstance() 函数来判断一个对象是否是一个已知的类型，bool实际上是只是内置整数类型int的子类。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> + <span class="number">4</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="chapter-6-The-Dynamic-Typing-Interlude"><a href="#chapter-6-The-Dynamic-Typing-Interlude" class="headerlink" title="chapter 6 The Dynamic Typing Interlude"></a>chapter 6 The Dynamic Typing Interlude</h2><h3 id="一、The-Case-of-the-Missing-Declaration-Statements"><a href="#一、The-Case-of-the-Missing-Declaration-Statements" class="headerlink" title="一、The Case of the Missing Declaration Statements"></a>一、The Case of the Missing Declaration Statements</h3><ol><li><p>在python中，不用申明脚本中使用的对象的确切类型。python为<strong><em>动态类型模式</em></strong>，c、c++、java为<strong><em>静态类型语言</em></strong>。</p></li><li><p>变量、对象和引用</p><ul><li>在运行a = 3后的变量名和对象。变量a变成对象3的一个<strong><em>引用reference</em></strong>。在内部，变量事实上是到对象内存空间的一个<strong><em>指针pointer</em></strong>。These links from variables to objects are called references in Python。<em>引用通过内存中的指针的形式来实现</em>。</li><li>（1）变量是一个系统表的入口，包含了指向对象的连接。（2）对象是被分配到的一块内存，有足够的空间去表示它们所代表的值。（3）引用是自动形成的从变量到对象的指针。</li><li>每一个对象都有两个标准的头部信息：类型标志符type designator标识了这个对象的类型；引用的计数器reference counter决定何时回收这个对象。  </li></ul></li><li><p>对象的<strong><em>垃圾回收garbage collection</em></strong></p><ul><li>在python中，每当一个变量名被赋予一个新的对象，如果原来的对象没有被其他的变量名或对象所引用，那么之前占用的空间会被回收，即垃圾回收；</li><li>每个对象保留一个计数器，记录当前指向对象的引用的数目。一旦计数器被设置为0，这个对象的内存空间会自动回收。假设每次x都被赋值给了一个新的对象，则前对象的引用计数器会变为零。</li></ul></li></ol><h3 id="二、Shared-References"><a href="#二、Shared-References" class="headerlink" title="二、Shared References"></a>二、Shared References</h3><ol><li><p><strong><em>共享引用Shared References</em></strong></p><ul><li>下面的示例的实际效果是变量a、b都引用了相同对象3（即相同的内存空间，该空间由字面量表达式3创建），a和b并没有彼此的关联：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">3</span>  </span><br><span class="line">b = a</span><br></pre></td></tr></table></figure></li><li>在python中，变量总是一个指向对象的指针：给变量赋一个新值，并不是替换原始的对象，而是让变量去引用另一个对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = a + <span class="number">2</span>  </span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><em>原位置修改In-Place Changes</em></strong></p><ul><li>有一些对象和操作确实会在原位置改变对象（包括列表、字典和集合在内的<code>Python可变类型</code>）。</li><li>在一个列表中对一个偏移进行赋值确实会改变这个列表对象，而不是生成一个全新的列表对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">L2 = L1</span><br><span class="line">L1[<span class="number">0</span>] = <span class="number">24</span></span><br><span class="line"><span class="built_in">print</span>(L1, L2)</span><br></pre></td></tr></table></figure></li><li>如果你不想这样的现象发生，可以请求python复制对象，而不是创建引用，常用的是从头到尾的分片，也可以用list函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">L2 = L1[:]</span><br><span class="line">L1[<span class="number">0</span>] = <span class="number">24</span></span><br><span class="line"><span class="built_in">print</span>(L1, L2) <span class="comment"># 2个变量指向不同的内存空间</span></span><br></pre></td></tr></table></figure></li><li>这种分片不会应用在字典和集合上（因为不是序列），要用标准库的<code>copy模块</code>进行复制，或者用dict和set函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;haha&#x27;</span>, <span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;bob&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">X = copy.copy(D) <span class="comment"># 浅拷贝：拷贝父对象，不会拷贝对象的内部的子对象。</span></span><br><span class="line">Y = copy.deepcopy(D) <span class="comment"># 深度拷贝：完全拷贝了父对象及其子对象。</span></span><br><span class="line">D[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;niaobu&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(X, D, Y) <span class="comment"># 关于浅拷贝和深度拷贝，详见第八、九章</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>共享引用和相等</p><ul><li>基于python的引用模型，有2个不同的方法去检查是否相等:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">M = L</span><br><span class="line"><span class="built_in">print</span>(L == M) <span class="comment"># 测试对象是否具有相同的值</span></span><br><span class="line"><span class="built_in">print</span>(L <span class="keyword">is</span> M) <span class="comment"># 检查对象的同一性，如果2个变量名指向同一对象，它会返回True。即is比较了实现引用的指针</span></span><br></pre></td></tr></table></figure></li><li><strong><em>对象缓存cache和复用reuse机制</em></strong>:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">M = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># M和L引用了不同的对象</span></span><br><span class="line"><span class="built_in">print</span>(L == M, L <span class="keyword">is</span> M)</span><br><span class="line">X = <span class="number">42</span></span><br><span class="line">Y = <span class="number">42</span></span><br><span class="line"><span class="built_in">print</span>(X == Y,X <span class="keyword">is</span> Y) <span class="comment"># 因为小的整数和字符串被缓存并复用了，所以is告诉我们X和Y引用了一个相同的对象。</span></span><br></pre></td></tr></table></figure></li><li>查询一个对象的引用次数，用标准的<code>sys模块</code>的<code>getrefcount</code>函数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(<span class="number">1</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="chapter-7-String-Fundamentals"><a href="#chapter-7-String-Fundamentals" class="headerlink" title="chapter 7 String Fundamentals"></a>chapter 7 String Fundamentals</h2><h3 id="一、String-Basics"><a href="#一、String-Basics" class="headerlink" title="一、String Basics"></a>一、String Basics</h3><p>常见的字符串字面量和操作：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Interpretation</th></tr></thead><tbody><tr><td style="text-align:left">S = ‘’</td><td style="text-align:left">空字符串</td></tr><tr><td style="text-align:left">S = “spam’s”</td><td style="text-align:left">双引号Double quotes</td></tr><tr><td style="text-align:left">S = ‘s\np\ta\x00m’</td><td style="text-align:left">转义序列Escape sequences</td></tr><tr><td style="text-align:left">S = “””…multiline…”””</td><td style="text-align:left">三引号块字符串Triple-quoted block strings</td></tr><tr><td style="text-align:left">S = r’\temp\spam’</td><td style="text-align:left">原始字符串（不进行转义）Raw strings (no escapes)</td></tr><tr><td style="text-align:left">B = b’sp\xc4m’</td><td style="text-align:left">字节串Byte strings in 2.6, 2.7, and 3.X (Chapter 4, Chapter 37)</td></tr><tr><td style="text-align:left">U = u’sp\u00c4m’</td><td style="text-align:left">unicode字符串Unicode strings in 2.X and 3.3+ (Chapter 4, Chapter 37)</td></tr><tr><td style="text-align:left">S1 + S2</td><td style="text-align:left">拼接Concatenate</td></tr><tr><td style="text-align:left">S * 3</td><td style="text-align:left">重复repeat</td></tr><tr><td style="text-align:left">S[i]</td><td style="text-align:left">索引Index</td></tr><tr><td style="text-align:left">S[i:j]</td><td style="text-align:left">切片slice</td></tr><tr><td style="text-align:left">len(S)</td><td style="text-align:left">长度length</td></tr><tr><td style="text-align:left">“a %s parrot” % S</td><td style="text-align:left">字符串格式化表达式String formatting expression</td></tr><tr><td style="text-align:left">“a {0} parrot”.format(S)</td><td style="text-align:left">字符串格式化方法String formatting method in 2.6, 2.7, and 3.X</td></tr><tr><td style="text-align:left">S.find(‘pa’)</td><td style="text-align:left">字符串方法String methods</td></tr><tr><td style="text-align:left">S.rstrip()</td><td style="text-align:left">移除右侧空白remove whitespace</td></tr><tr><td style="text-align:left">S.replace(‘pa’, ‘xx’)</td><td style="text-align:left">替换replacement</td></tr><tr><td style="text-align:left">S.split(‘,’)</td><td style="text-align:left">用分隔符分组split on delimiter</td></tr><tr><td style="text-align:left">S.isdigit()</td><td style="text-align:left">内容测试content test检测字符串是否只由数字组成</td></tr><tr><td style="text-align:left">S.lower()</td><td style="text-align:left">大小写转换case conversion</td></tr><tr><td style="text-align:left">S.endswith(‘spam’)</td><td style="text-align:left">尾部测试end test</td></tr><tr><td style="text-align:left">‘-‘.join(‘s’, ‘p’, ‘a’, ‘m’)</td><td style="text-align:left">分隔符连接delimiter join</td></tr><tr><td style="text-align:left">S.encode(‘latin-1’)</td><td style="text-align:left">编码Unicode encoding</td></tr><tr><td style="text-align:left">B.decode(‘utf8’)</td><td style="text-align:left">解码Unicode decoding</td></tr><tr><td style="text-align:left">for x in S: print(x)</td><td style="text-align:left">迭代Iteration</td></tr><tr><td style="text-align:left">‘spam’ in S</td><td style="text-align:left">成员关系membership</td></tr><tr><td style="text-align:left">[c * 2 for c in S]</td><td style="text-align:left">推导式comprehensions</td></tr><tr><td style="text-align:left">map(ord, S)</td><td style="text-align:left">ord返回单个字符的ASCII序号</td></tr><tr><td style="text-align:left">re.match(‘sp(.*)am’, ‘-‘)</td><td style="text-align:left">模式匹配：库模块Pattern matching: library module</td></tr></tbody></table></div><h3 id="二、String-Literals"><a href="#二、String-Literals" class="headerlink" title="二、String Literals"></a>二、String Literals</h3><ol><li><p>字符串字面量</p><ul><li>字符串之间没有逗号会自动拼接相邻的字符串字面量；</li><li>通过反斜杠转义来嵌入引号字符：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">title = <span class="string">&quot;Meaning &quot;</span> <span class="string">&#x27;of&#x27;</span> <span class="string">&quot; Life&quot;</span></span><br><span class="line"><span class="built_in">print</span>(title)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;knight\&#x27;s&#x27;</span>, <span class="string">&quot;knight\&quot;s&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>转义序列<strong><em>Escape</em></strong> Sequences</p><ul><li><code>\n</code>换行符newline character，<code>\t</code>制表符tab character<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;a\nb\tc&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s)) <span class="comment"># 这个字符串有5个字符，包含了一个ASCII a字符、一个换行字符、一个ASCII b字符等。</span></span><br></pre></td></tr></table></figure></li><li>字符串反斜杠字符合集String backslash characters</li></ul></li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">Escape</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left">\newline</td><td style="text-align:left">行的延续，一句代码太长了，直接回车会报错，写个\再换行，就会当做同一行处理</td></tr><tr><td style="text-align:left">\\</td><td style="text-align:left">反斜杠 Backslash (保留一个\)</td></tr><tr><td style="text-align:left">\’</td><td style="text-align:left">单引号 Single quote (保留 ‘)</td></tr><tr><td style="text-align:left">\”</td><td style="text-align:left">双引号 Double quote (保留 “)</td></tr><tr><td style="text-align:left">\a</td><td style="text-align:left">响铃 Bell</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">退格 Backspace</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">换页 Formfeed</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">换行 Newline (linefeed)</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车 Carriage return</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">水平制表符 Horizontal tab</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">垂直制表符 Vertical tab</td></tr><tr><td style="text-align:left">\xhh</td><td style="text-align:left">十六进制 Character with hex value hh (exactly 2 digits)</td></tr><tr><td style="text-align:left">\ooo</td><td style="text-align:left">八进制 Character with octal value ooo (up to 3 digits)</td></tr><tr><td style="text-align:left">\0</td><td style="text-align:left">空字符：二进制的0字符</td></tr><tr><td style="text-align:left">\N{ id }</td><td style="text-align:left">Unicode数据库ID（不包括前面的r）</td></tr><tr><td style="text-align:left">\uhhhh</td><td style="text-align:left">16位十六进制值的Unicode值 Unicode character with 16-bit hex value</td></tr><tr><td style="text-align:left">\Uhhhhhhhh</td><td style="text-align:left">32位的十六进制的Unicode值</td></tr><tr><td style="text-align:left">\other</td><td style="text-align:left">Not an escape (keeps both \ and other)</td></tr></tbody></table></div><ol><li><p><strong><em>原始字符串Raw Strings</em></strong></p><ul><li>例如：<code>myfile = open(&#39;C:\new\text.dat&#39;, &#39;w&#39;)</code></li><li>这里因为有\n、\t存在转义机制，所以要用原始字符串：<code>myfile = open(r&#39;C:\new\text.dat&#39;, &#39;w&#39;)</code>或者用2个反斜杠代替一个反斜杠：<code>myfile = open(&#39;C:\\new\\text.dat&#39;, &#39;w&#39;)</code></li></ul></li><li><p><strong>三引号编写多行块字符串Triple Quotes Code Multiline Block Strings</strong></p><ul><li>三引号会保留所有包围的文本，包括你以为的注释的文本：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">menu = <span class="string">&quot;&quot;&quot;spam # comments here added to string!</span></span><br><span class="line"><span class="string"><span class="meta">... </span>eggs # ditto</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(menu)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、Strings-in-Action"><a href="#三、Strings-in-Action" class="headerlink" title="三、Strings in Action"></a>三、Strings in Action</h3><ol><li><p>索引和分片<strong><em>Indexing and Slicing</em></strong></p><ul><li><code>分片（S[i:j]）</code>：不包括上(右)边界，即S[1:3]获取从 <strong><em>偏移量(offset)</em></strong> 1到不包括偏移量为3之间的元素；<code>拓展的分片（S[i:j:k]）</code>：接受一个步长k，其默认值为+1。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S[<span class="number">0</span>], S[-<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(S[<span class="number">1</span>:<span class="number">3</span>], S[<span class="number">1</span>:], S[:-<span class="number">1</span>])</span><br><span class="line">S = <span class="string">&#x27;abcdefghijklmnop&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S[<span class="number">1</span>:<span class="number">10</span>:<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(S[::<span class="number">2</span>])</span><br></pre></td></tr></table></figure></li><li>倒序收集元素，使用负数步幅，2个边界实际进行了反转：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S[::-<span class="number">1</span>])</span><br><span class="line">S = <span class="string">&#x27;abcedfg&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S[<span class="number">5</span>:<span class="number">1</span>:-<span class="number">1</span>]) <span class="comment"># 获取了从2到5的元素</span></span><br></pre></td></tr></table></figure></li><li><code>slice()</code>函数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;spam&#x27;</span>[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;spam&#x27;</span>[<span class="built_in">slice</span>(<span class="number">1</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;spam&#x27;</span>[::-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;spam&#x27;</span>[<span class="built_in">slice</span>(<span class="literal">None</span>, <span class="literal">None</span>, -<span class="number">1</span>)])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符串转换工具</p><ul><li><code>int</code>函数；<code>str</code>函数；<code>repr</code>函数：return the canonical string representation of the object将对象转化为供解释器读取的string形式：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&quot;42&quot;</span>), <span class="built_in">str</span>(<span class="number">42</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(<span class="number">42</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="string">&#x27;spam&#x27;</span>), <span class="built_in">repr</span>(<span class="string">&#x27;spam&#x27;</span>)) <span class="comment"># repr() 的输出追求明确性，除了对象内容，还需要展示出对象的数据类型信息</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符串代码转换</p><ul><li><code>ord()</code>函数是<code>chr()</code>函数对于8位的ASCII字符串或<code>unichr()</code>函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的ASCII数值，或者Unicode数值，返回值是对应的十进制整数。ord全称为<strong><em>ordinal(序数)</em></strong>、chr全称为<strong><em>character</em></strong>。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;s&#x27;</span>), <span class="built_in">chr</span>(<span class="number">115</span>))</span><br></pre></td></tr></table></figure></li><li><code>int()</code>函数、<code>bin()</code>函数：int函数接受字符串或数字以及一个base（进制数，默认十进制）；bin即binary，返回整数的二进制：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;1101&#x27;</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">13</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改字符串</p><ul><li><strong><em>字符串是不可变序列</em></strong>，不能对索引进行赋值，不能<code>S[0]=&#39;x&#39;</code>，要用拼接或分片赋值一个新的字符串或者用<code>replace</code>函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">S = S + <span class="string">&#x27;SPAM!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line">S = S[:<span class="number">4</span>] + <span class="string">&#x27;Burger&#x27;</span> + S[-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"></span><br><span class="line">S = <span class="string">&#x27;splot&#x27;</span></span><br><span class="line">S = S.replace(<span class="string">&#x27;pl&#x27;</span>, <span class="string">&#x27;pamal&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure></li><li><strong><em>字符串格式化</em></strong>，生成一个新的字符串：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;That is %d %s bird!&#x27;</span> % (<span class="number">1</span>, <span class="string">&#x27;dead&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;That is &#123;0&#125; &#123;1&#125; bird!&#x27;</span>.<span class="built_in">format</span>(<span class="number">1</span>, <span class="string">&#x27;dead&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="四、String-Methods"><a href="#四、String-Methods" class="headerlink" title="四、String Methods"></a>四、String Methods</h3><ol><li><p>字符串方法</p><ul><li><strong>方法</strong>与特定对象相关联，是依附于对象的<strong>属性attribute</strong>，而这些属性引用了可调用的函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(S)) <span class="comment"># 打印出来是字符串的所有属性或方法</span></span><br></pre></td></tr></table></figure></li><li>显式结果为：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__contains__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>, <span class="string">&#x27;__getnewargs__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__len__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__mod__&#x27;</span>, <span class="string">&#x27;__mul__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__rmod__&#x27;</span>, <span class="string">&#x27;__rmul__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;capitalize&#x27;</span>, <span class="string">&#x27;casefold&#x27;</span>, <span class="string">&#x27;center&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;encode&#x27;</span>, <span class="string">&#x27;endswith&#x27;</span>, <span class="string">&#x27;expandtabs&#x27;</span>, <span class="string">&#x27;find&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;format_map&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;isalnum&#x27;</span>, <span class="string">&#x27;isalpha&#x27;</span>, <span class="string">&#x27;isascii&#x27;</span>, <span class="string">&#x27;isdecimal&#x27;</span>, <span class="string">&#x27;isdigit&#x27;</span>, <span class="string">&#x27;isidentifier&#x27;</span>, <span class="string">&#x27;islower&#x27;</span>, <span class="string">&#x27;isnumeric&#x27;</span>, <span class="string">&#x27;isprintable&#x27;</span>, <span class="string">&#x27;isspace&#x27;</span>, <span class="string">&#x27;istitle&#x27;</span>, <span class="string">&#x27;isupper&#x27;</span>, <span class="string">&#x27;join&#x27;</span>, <span class="string">&#x27;ljust&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>, <span class="string">&#x27;lstrip&#x27;</span>, <span class="string">&#x27;maketrans&#x27;</span>, <span class="string">&#x27;partition&#x27;</span>, <span class="string">&#x27;removeprefix&#x27;</span>, <span class="string">&#x27;removesuffix&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>, <span class="string">&#x27;rfind&#x27;</span>, <span class="string">&#x27;rindex&#x27;</span>, <span class="string">&#x27;rjust&#x27;</span>, <span class="string">&#x27;rpartition&#x27;</span>, <span class="string">&#x27;rsplit&#x27;</span>, <span class="string">&#x27;rstrip&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;splitlines&#x27;</span>, <span class="string">&#x27;startswith&#x27;</span>, <span class="string">&#x27;strip&#x27;</span>, <span class="string">&#x27;swapcase&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;translate&#x27;</span>, <span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;zfill&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用方法修改字符串</p><ul><li><code>replace</code>方法：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;spammy&#x27;</span></span><br><span class="line">S = S.replace(<span class="string">&#x27;mm&#x27;</span>, <span class="string">&#x27;xx&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"></span><br><span class="line">S = <span class="string">&#x27;xxxxSPAMxxxxSPAMxxxx&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.replace(<span class="string">&#x27;SPAM&#x27;</span>, <span class="string">&#x27;EGGS&#x27;</span>)) <span class="comment"># replace方法会生成一个新的字符串，因为字符串不可变。</span></span><br><span class="line"><span class="built_in">print</span>(S.replace(<span class="string">&#x27;SPAM&#x27;</span>, <span class="string">&#x27;EGGS&#x27;</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure></li><li><code>find</code>方法：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;xxxxSPAMxxxxSPAMxxxx&#x27;</span></span><br><span class="line">where = S.find(<span class="string">&#x27;SPAM&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(where)</span><br><span class="line">S = S[:where] + <span class="string">&#x27;EGGS&#x27;</span> + S[(where+<span class="number">4</span>):]</span><br><span class="line"><span class="built_in">print</span>(S)</span><br></pre></td></tr></table></figure></li><li><code>join</code>方法，join将列表的字符串连在一起，并在元素间用分隔符delimiter隔开：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S = <span class="string">&#x27;spammy&#x27;</span></span><br><span class="line">L = <span class="built_in">list</span>(S)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">L[<span class="number">3</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line">L[<span class="number">4</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">S = <span class="string">&#x27;&#x27;</span>.join(L)</span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;SPAM&#x27;</span>.join([<span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;sausage&#x27;</span>, <span class="string">&#x27;ham&#x27;</span>, <span class="string">&#x27;toast&#x27;</span>])) <span class="comment"># 用分隔符SPAM加入后面列表</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>用方法解析文本Parsing Text</p><ul><li>方法<code>split()</code>将一个字符串从分隔符处切成一系列子串，默认分隔符为空格、制表符或换行符：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line = <span class="string">&#x27;aaa bbb ccc&#x27;</span></span><br><span class="line">cols = line.split()</span><br><span class="line"><span class="built_in">print</span>(cols)</span><br><span class="line">line = <span class="string">&#x27;bob,hacker,40&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(line.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">line = <span class="string">&quot;i&#x27;mSPAMaSPAMlumberjack&quot;</span></span><br><span class="line"><span class="built_in">print</span>(line.split(<span class="string">&quot;SPAM&quot;</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他常见字符串方法</p><ul><li>方法<code>rstrip()</code>，<code>upper()</code>，<code>isalpha()</code>，<code>endswith()</code>，<code>startswith()</code>，<code>find()</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line = <span class="string">&quot;The knights who say Ni!\n&quot;</span></span><br><span class="line"><span class="built_in">print</span>(line.rstrip())</span><br><span class="line"><span class="built_in">print</span>(line.upper())</span><br><span class="line"><span class="built_in">print</span>(line.isalpha()) <span class="comment"># isalpha()检测字符串是否只由字母或文字组成</span></span><br><span class="line"><span class="built_in">print</span>(line.endswith(<span class="string">&#x27;Ni!\n&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(line.startswith(<span class="string">&#x27;The&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(line.find(<span class="string">&#x27;Ni&#x27;</span>)) <span class="comment"># find方法返回字符串的索引值</span></span><br></pre></td></tr></table></figure></li><li>可以使用<code>help(S.method)</code>的结果来得到关于方法的更多提示。</li></ul></li></ol><h3 id="五、String-Formatting-Expressions"><a href="#五、String-Formatting-Expressions" class="headerlink" title="五、String Formatting Expressions"></a>五、String Formatting Expressions</h3><ol><li><p><strong>字符串格式化表达式String Formatting Expressions</strong></p><ul><li><code>&#39;...%s...&#39; % (values)</code>：这一形式是基于C语言的printf模型，并且在现有编码中广泛使用。</li></ul></li><li><p><strong>字符串格式化方法调用String formatting method calls</strong></p><ul><li><code>&#39;...&#123;&#125;...&#39;.format(values)</code>：这是Python 3.0新增的技术，起源于C#/.NET中的同名工具。</li></ul></li><li><p><strong>f字符串f-strings</strong></p><ul><li><code>f&#39;...&#123;values&#125;...&#39;</code>：Python 3.6新增的。</li></ul></li><li><p>格式化表达式基础</p><ul><li>在%运算符的左侧放置一个或多个需要进行格式化的字符串，如%d，%s；在%运算符的右侧放置一个或多个（内嵌在元组中）对象；</li><li>%s的意思是把他们转换为字符串，因此每种对象类型都适用于%s转换，一般只需记得用%s转换就行：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;That is %d %s bird!&#x27;</span> % (<span class="number">1</span>, <span class="string">&#x27;dead&#x27;</span>)) <span class="comment"># 前面的%后面的字母见后面类型码type codes</span></span><br><span class="line">exclamation = <span class="string">&#x27;Ni&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The knights who say %s!&#x27;</span> % exclamation)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%d %s %g you&#x27;</span> % (<span class="number">1</span>, <span class="string">&#x27;spam&#x27;</span>, <span class="number">4.0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s -- %s -- %s&#x27;</span> % (<span class="number">42</span>, <span class="number">3.14159</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">That is 1 dead bird!</span><br><span class="line">The knights who say Ni!</span><br><span class="line">1 spam 4 you</span><br><span class="line">42 -- 3.14159 -- [1, 2, 3]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>类型码String formatting type codes</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">Code</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left">s</td><td style="text-align:left">字符串</td></tr><tr><td style="text-align:left">r</td><td style="text-align:left">Same as s, but uses repr, not str</td></tr><tr><td style="text-align:left">c</td><td style="text-align:left">字符Character (int or str)</td></tr><tr><td style="text-align:left">d</td><td style="text-align:left">十进制数字</td></tr><tr><td style="text-align:left">i</td><td style="text-align:left">整数</td></tr><tr><td style="text-align:left">u</td><td style="text-align:left">与d相同（已废弃：不再是无符号整数）</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">八进制整数（以8为底）</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">十六进制整数（以16为底）</td></tr><tr><td style="text-align:left">X</td><td style="text-align:left">与x相同</td></tr><tr><td style="text-align:left">e</td><td style="text-align:left">带指数的浮点数</td></tr><tr><td style="text-align:left">E</td><td style="text-align:left">与e相同</td></tr><tr><td style="text-align:left">f</td><td style="text-align:left">十进制浮点数</td></tr><tr><td style="text-align:left">F</td><td style="text-align:left">与f相同</td></tr><tr><td style="text-align:left">g</td><td style="text-align:left">浮点数e或f，g根据数字内容选择格式（如果指数小于-4或不小于精度，则使用e，其他则使用f，默认总位数精度为6）</td></tr><tr><td style="text-align:left">G</td><td style="text-align:left">浮点数E或F</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">%字面量 Literal % (coded as %%)</td></tr></tbody></table></div><ol><li><p>格式化字符串表达式左侧的转换目标支持多种转换操作</p><ul><li>一般结构为：<code>%[(keyname)][flags][width][.precision]typecode</code></li><li><code>keyname</code>：为索引在表达式右侧使用的字典所提供的键名称</li><li><code>flags</code>：说明格式的标签，如左对齐(-)、数值符号(+)、正数前的空白以及负数前的-(空格)、零填充(0)</li><li><code>width</code>：最小字段宽度</li><li><code>precision</code>：为浮点数设置小数点后显示的数位</li><li>width和precision部分都可以编写成一个*，以指定他们应该从表达式右侧的输入值中的下一项取值。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1234</span></span><br><span class="line">res = <span class="string">&#x27;integers: ...%d...%-6d...%06d&#x27;</span> % (x, x, x) <span class="comment"># 6位的左对齐格式化和6位补零的格式化</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">x = <span class="number">1.23456789</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%e | %f | %g&#x27;</span> % (x, x, x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%E&#x27;</span> % x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%-6.2f | %05.2f | %+06.1f&#x27;</span> % (x, x, x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s&#x27;</span> % x, <span class="built_in">str</span>(x))</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">integers: ...1234...1234  ...001234</span><br><span class="line">1.234568e+00 | 1.234568 | 1.23457</span><br><span class="line">1.234568E+00</span><br><span class="line">1.23   | 01.23 | +001.2</span><br><span class="line">1.23456789 1.23456789</span><br></pre></td></tr></table></figure></li><li>可以在格式化字符中用一个<code>*</code>来指定宽度和精度，迫使它们的值从%运算符右边的输入中的下一项获取：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%f, %.2f, %.*f&#x27;</span> % (<span class="number">1</span>/<span class="number">3.0</span>, <span class="number">1</span>/<span class="number">3.0</span>, <span class="number">4</span>, <span class="number">1</span>/<span class="number">3.0</span>))</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.333333, 0.33, 0.3333</span><br></pre></td></tr></table></figure></li></ul></li><li><p>基于字典的格式化表达式    </p><ul><li><code>print(&#39;%(qty)d more %(food)s&#39; % &#123;&#39;qty&#39;: 1, &#39;food&#39;: &#39;spam&#39;&#125;)</code></li><li>生成类似HTML或XML文本的程序往往利用这一技术:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reply = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Greetings...</span></span><br><span class="line"><span class="string">Hello %(name)s!</span></span><br><span class="line"><span class="string">Your age is %(age)s</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">values = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">40</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(reply % values)</span><br></pre></td></tr></table></figure></li><li>内置函数<code>vars()</code>，这个函数返回的字典包含了在它被调用的地方所有存在的变量，可以利用这个来访问变量：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">food = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">qty = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%(qty)d more %(food)s&#x27;</span> % <span class="built_in">vars</span>())</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="六、String-Formatting-Method-Calls"><a href="#六、String-Formatting-Method-Calls" class="headerlink" title="六、String Formatting Method Calls"></a>六、String Formatting Method Calls</h3><ol><li><p>字符串格式化方法基础</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">template = <span class="string">&#x27;&#123;0&#125;, &#123;1&#125; and &#123;2&#125;&#x27;</span> <span class="comment"># 通过位置</span></span><br><span class="line"><span class="built_in">print</span>(template.<span class="built_in">format</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;ham&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>))</span><br><span class="line">template = <span class="string">&#x27;&#123;motto&#125;, &#123;pork&#125; and &#123;food&#125;&#x27;</span> <span class="comment"># 通过键</span></span><br><span class="line"><span class="built_in">print</span>(template.<span class="built_in">format</span>(motto=<span class="string">&#x27;spam&#x27;</span>, pork=<span class="string">&#x27;ham&#x27;</span>, food=<span class="string">&#x27;eggs&#x27;</span>)) <span class="comment"># 跟上一节的不一样，后面不是字典，见下面</span></span><br><span class="line">template = <span class="string">&#x27;&#123;motto&#125;, &#123;0&#125; and &#123;food&#125;&#x27;</span> <span class="comment"># 通过位置和键</span></span><br><span class="line"><span class="built_in">print</span>(template.<span class="built_in">format</span>(<span class="string">&#x27;ham&#x27;</span>, motto=<span class="string">&#x27;spam&#x27;</span>, food=<span class="string">&#x27;eggs&#x27;</span>))</span><br><span class="line">template = <span class="string">&#x27;&#123;&#125;, &#123;&#125; and &#123;&#125;&#x27;</span> <span class="comment"># 通过相对位置</span></span><br><span class="line"><span class="built_in">print</span>(template.<span class="built_in">format</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;ham&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>比较：上一节的格式化表达式</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">template = <span class="string">&#x27;%s, %s and %s&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(template % (<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;ham&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>))</span><br><span class="line">template = <span class="string">&#x27;%(motto)s, %(pork)s and %(food)s&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(template % <span class="built_in">dict</span>(motto=<span class="string">&#x27;spam&#x27;</span>, pork=<span class="string">&#x27;ham&#x27;</span>, food=<span class="string">&#x27;eggs&#x27;</span>)) <span class="comment"># 通过dict()函数转为字典</span></span><br></pre></td></tr></table></figure><ul><li>格式化方法可以让任意的对象类型在目标上替换，有点像格式化表达式中的%s目标码：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;motto&#125;, &#123;0&#125; and &#123;food&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">42</span>, motto=<span class="number">3.14</span>, food=[<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line">X = <span class="string">&#x27;&#123;motto&#125;, &#123;0&#125; and &#123;food&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">42</span>, motto=<span class="number">3.14</span>, food=[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(X.split(<span class="string">&#x27; and &#x27;</span>)) <span class="comment"># 以空格and空格为分隔符</span></span><br><span class="line">Y = X.replace(<span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;but under no circumstances&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>添加键、属性和偏移量</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;My &#123;1[kind]&#125; runs &#123;0.platform&#125;&#x27;</span>.<span class="built_in">format</span>(sys, &#123;<span class="string">&#x27;kind&#x27;</span>: <span class="string">&#x27;laptop&#x27;</span>&#125;))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;My &#123;map[kind]&#125; runs &#123;sys.platform&#125;&#x27;</span>.<span class="built_in">format</span>(sys=sys, <span class="built_in">map</span>=&#123;<span class="string">&#x27;kind&#x27;</span>: <span class="string">&#x27;laptop&#x27;</span>&#125;))</span><br><span class="line">somelist = <span class="built_in">list</span>(<span class="string">&#x27;SPAM&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(somelist)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;first=&#123;0[0]&#125;, third=&#123;0[2]&#125;&#x27;</span>.<span class="built_in">format</span>(somelist))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;first=&#123;0&#125;, last=&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(somelist[<span class="number">0</span>], somelist[-<span class="number">1</span>]))</span><br><span class="line">parts = somelist[<span class="number">0</span>], somelist[-<span class="number">1</span>], somelist[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;first=&#123;0&#125;, last=&#123;1&#125;, middle=&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(*parts)) <span class="comment"># *是一种特殊的语法syntax，可以把一个元组展开为独立的参数。18章会更详细</span></span><br></pre></td></tr></table></figure><p> 运行结果如下：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">My laptop runs win32</span><br><span class="line">My laptop runs win32</span><br><span class="line">[&#x27;S&#x27;, &#x27;P&#x27;, &#x27;A&#x27;, &#x27;M&#x27;]</span><br><span class="line">first=S, third=A</span><br><span class="line">first=S, last=M</span><br><span class="line">first=S, last=M, middle=[&#x27;P&#x27;, &#x27;A&#x27;]</span><br></pre></td></tr></table></figure></li><li><p>高级格式化方法语法Advanced Formatting Method Syntax</p><ul><li>可以在格式化字符串中添加额外的语法来实现更具体的层级，以下是是一个字符串中的形式化格式，四个部分都为可选的，中间不能有空格：</li><li><code>&#123;fieldname component !conversionflag :formatspec&#125;</code></li><li><code>fieldname</code>是辨识参数，位置参数或键值number or keyword；<code>component</code>是大于等于零个的.name或[index]；<code>converionflag</code>是以!开始的，后面跟着r、s或a，分别调用repr、str或ascii内置函数；<code>formatspec</code>是以:开始的，后面跟着文本指定字段宽度、对齐方式、补零、小数精度等细节；</li><li><code>formatspec</code>的形式：<code>[[fill]align][sign][#][0][width][,][.precision][typecode]</code></li><li><code>fill</code>可以是除{和}之外的任意填充字符；<code>align</code>可以是&lt;、&gt;、=、^，分别代表左对齐、右对齐、符号字符后的填充、居中对齐；<code>sign</code>可以是+、-或空格；<code>逗号(,)</code>请求千分位分隔符；<code>width</code>、<code>precision</code>和<code>typecode</code>与%表达式一样，但<code>typecode</code>多一个二进制格式b</li></ul></li><li><p>高级格式化方法举例</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:10&#125; = &#123;1:10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="number">123.4567</span>)) <span class="comment"># &#123;0:10&#125;指10字符宽的字段的第一个位置参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:&gt;10&#125; = &#123;1:&lt;10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="number">123.4567</span>)) <span class="comment"># &gt;右对齐</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0.platform:&gt;10&#125; = &#123;1[kind]:&lt;10&#125;&#x27;</span>.<span class="built_in">format</span>(sys, <span class="built_in">dict</span>(kind=<span class="string">&#x27;laptop&#x27;</span>)))</span><br><span class="line"><span class="comment"># 省略位置参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:10&#125; = &#123;:10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="number">123.4567</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:&gt;10&#125; = &#123;:&lt;10&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="number">123.4567</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;.platform:&gt;10&#125; = &#123;[kind]:&lt;10&#125;&#x27;</span>.<span class="built_in">format</span>(sys, <span class="built_in">dict</span>(kind=<span class="string">&#x27;laptop&#x27;</span>)))</span><br><span class="line"><span class="comment"># 浮点数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:e&#125;, &#123;1:.3e&#125;, &#123;2:g&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14159</span>, <span class="number">3.14159</span>, <span class="number">3.14159</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:f&#125;, &#123;1:.2f&#125;, &#123;2:06.2f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">3.14159</span>, <span class="number">3.14159</span>, <span class="number">3.14159</span>)) <span class="comment"># &#123;2:06.2f&#125;添加一个6字符宽度的字段，并在左边补充0</span></span><br><span class="line"><span class="comment"># 十六进制、八进制、二进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:X&#125;, &#123;1:o&#125;, &#123;2:b&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">255</span>), <span class="built_in">int</span>(<span class="string">&#x27;11111111&#x27;</span>, <span class="number">2</span>), <span class="number">0b11111111</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">255</span>), <span class="built_in">int</span>(<span class="string">&#x27;FF&#x27;</span>, <span class="number">16</span>), <span class="number">0xFF</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">255</span>), <span class="built_in">int</span>(<span class="string">&#x27;377&#x27;</span>, <span class="number">8</span>), <span class="number">0o377</span>)</span><br><span class="line"><span class="comment"># 格式化的参数可以通过嵌套的格式化语法从参数列表动态获取，很想格式化表达式的*语法（见7-5-4）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:.&#123;1&#125;f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">1</span> / <span class="number">3.0</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%.*f&#x27;</span> % (<span class="number">4</span>, <span class="number">1</span> / <span class="number">3.0</span>))</span><br><span class="line"><span class="comment"># format函数(字符串方法的替代方案)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">1.2345</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(<span class="number">1.2345</span>, <span class="string">&#x27;.2f&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span> % <span class="number">1.2345</span>)</span><br><span class="line"><span class="comment"># 千分位分隔符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:,d&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">999999999999</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:,.2f&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">296999.2567</span>))</span><br></pre></td></tr></table></figure><p> 运行结果如下：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spam       =   123.4567</span><br><span class="line">      spam = 123.4567</span><br><span class="line">     win32 = laptop</span><br><span class="line">spam       =   123.4567</span><br><span class="line">      spam = 123.4567</span><br><span class="line">     win32 = laptop</span><br><span class="line">3.141590e+00, 3.142e+00, 3.14159</span><br><span class="line">3.141590, 3.14, 003.14</span><br><span class="line">FF, 377, 11111111</span><br><span class="line">0b11111111 255 255</span><br><span class="line">0xff 255 255</span><br><span class="line">0o377 255 255</span><br><span class="line">0.3333</span><br><span class="line">0.3333</span><br><span class="line">1.23</span><br><span class="line">1.23</span><br><span class="line">1.23</span><br><span class="line">999,999,999,999</span><br><span class="line">296,999.26</span><br></pre></td></tr></table></figure></li><li><p>与%格式化表达式做比较</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s=%s&#x27;</span> % (<span class="string">&#x27;spam&#x27;</span>, <span class="number">42</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;=&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="number">42</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;spam&#x27;</span>, <span class="number">42</span>))</span><br><span class="line"><span class="comment"># 和上面5进行比较</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%-10s = %10s&#x27;</span> % (<span class="string">&#x27;spam&#x27;</span>, <span class="number">123.4567</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%10s = %-10s&#x27;</span> % (<span class="string">&#x27;spam&#x27;</span>, <span class="number">123.4567</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%(plat)10s = %(kind)-10s&#x27;</span> % <span class="built_in">dict</span>(plat=sys.platform, kind=<span class="string">&#x27;laptop&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%e, %.3e, %g&#x27;</span> % (<span class="number">3.14159</span>, <span class="number">3.14159</span>, <span class="number">3.14159</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%f, %.2f, %06.2f&#x27;</span> % (<span class="number">3.14159</span>, <span class="number">3.14159</span>, <span class="number">3.14159</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%x, %o&#x27;</span> % (<span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;My &#123;1[kind]:&lt;8&#125; runs &#123;0.platform:&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(sys, &#123;<span class="string">&#x27;kind&#x27;</span>: <span class="string">&#x27;laptop&#x27;</span>&#125;))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;My %(kind)-8s runs %(plat)8s&#x27;</span> % <span class="built_in">dict</span>(kind=<span class="string">&#x27;laptop&#x27;</span>, plat=sys.platform))</span><br><span class="line"></span><br><span class="line">data = <span class="built_in">dict</span>(platform=sys.platform, kind=<span class="string">&#x27;laptop&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;My &#123;kind:&lt;8&#125; runs &#123;platform:&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(**data)) <span class="comment"># **data见第十八章，它把字典解包成一组name=value的关键字参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;My %(kind)-8s runs %(platform)8s&#x27;</span> % data)</span><br></pre></td></tr></table></figure><p> 运行结果如下：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spam=42</span><br><span class="line">spam=42</span><br><span class="line">spam=42</span><br><span class="line">spam       =   123.4567</span><br><span class="line">      spam = 123.4567</span><br><span class="line">     win32 = laptop</span><br><span class="line">3.141590e+00, 3.142e+00, 3.14159</span><br><span class="line">3.141590, 3.14, 003.14</span><br><span class="line">ff, 377</span><br><span class="line">My laptop   runs    win32</span><br><span class="line">My laptop   runs    win32</span><br><span class="line">My laptop   runs    win32</span><br><span class="line">My laptop   runs    win32</span><br></pre></td></tr></table></figure></li></ol><h3 id="七、Why-the-Format-Method"><a href="#七、Why-the-Format-Method" class="headerlink" title="七、Why the Format Method?"></a>七、Why the Format Method?</h3><ol><li><p>字符串格式化方法支持表达式一些额外的功能</p><ul><li>例如<strong>二进制类型码binary type codes</strong>和<strong>千分位分组thousands groupings</strong>，但字符串表达式不支持二进制，即没有2进制的类型码，见7-5，<code>print(&#39;%b&#39; % ((2 ** 16) - 1))</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0:b&#125;&#x27;</span>.<span class="built_in">format</span>((<span class="number">2</span> ** <span class="number">16</span>) - <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>((<span class="number">2</span> ** <span class="number">16</span>) - <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s&#x27;</span> % <span class="built_in">bin</span>((<span class="number">2</span> ** <span class="number">16</span>) - <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">bin</span>((<span class="number">2</span> ** <span class="number">16</span>) - <span class="number">1</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s&#x27;</span> % <span class="built_in">bin</span>((<span class="number">2</span> ** <span class="number">16</span>) - <span class="number">1</span>)[<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># 字符串表达式不支持千分位分组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;:,d&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">999999999999</span>))</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111111111111111</span><br><span class="line">0b1111111111111111</span><br><span class="line">0b1111111111111111</span><br><span class="line">0b1111111111111111</span><br><span class="line">1111111111111111</span><br><span class="line">999,999,999,999</span><br></pre></td></tr></table></figure></li></ul></li><li><p>基于字典，2种方法之间的比较</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;name&#125; &#123;job&#125; &#123;name&#125;&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;Bob&#x27;</span>, job=<span class="string">&#x27;dev&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%(name)s %(job)s %(name)s&#x27;</span> % <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, job=<span class="string">&#x27;dev&#x27;</span>))</span><br><span class="line">D = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, job=<span class="string">&#x27;dev&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0[name]&#125; &#123;0[job]&#125; &#123;0[name]&#125;&#x27;</span>.<span class="built_in">format</span>(D))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;name&#125; &#123;job&#125; &#123;name&#125;&#x27;</span>.<span class="built_in">format</span>(**D))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%(name)s %(job)s %(name)s&#x27;</span> % D)</span><br></pre></td></tr></table></figure><p> 运行结果全为<code>Bob dev Bob</code>。</p></li></ol><h2 id="chapter-8-Lists-and-Dictionaries"><a href="#chapter-8-Lists-and-Dictionaries" class="headerlink" title="chapter 8 Lists and Dictionaries"></a>chapter 8 Lists and Dictionaries</h2><h3 id="一、Lists"><a href="#一、Lists" class="headerlink" title="一、Lists"></a>一、Lists</h3><ol><li><p>列表的特性</p><ul><li>任意对象的有序集合；通过偏移访问；可变长度、异构以及任意嵌套Variable-length, heterogeneous, and arbitrarily nestable；</li><li>属于<strong>可变序列</strong>的分类；对象引用数组。</li></ul></li><li><p>常用列表字面量和操作</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Interpretation</th></tr></thead><tbody><tr><td style="text-align:left">L = []</td><td style="text-align:left">空列表</td></tr><tr><td style="text-align:left">L = [123, ‘abc’, 1.23, {}]</td><td style="text-align:left">Four items: indexes 0..3</td></tr><tr><td style="text-align:left">L1 = [‘Bob’, 40.0, [‘dev’, ‘mgr’]]</td><td style="text-align:left">嵌套子列表Nested sublists</td></tr><tr><td style="text-align:left">L2 = list(‘spam’)</td><td style="text-align:left">可迭代对象元素的列表List of an iterable’s items</td></tr><tr><td style="text-align:left">L2 = list(range(-4, 4))</td><td style="text-align:left">list of successive integers</td></tr><tr><td style="text-align:left">L[i]</td><td style="text-align:left">索引 index</td></tr><tr><td style="text-align:left">L[i][j]</td><td style="text-align:left">索引的索引 index of index</td></tr><tr><td style="text-align:left">L[i:j]</td><td style="text-align:left">分片 slice</td></tr><tr><td style="text-align:left">len(L)</td><td style="text-align:left">length</td></tr><tr><td style="text-align:left">L1 + L2</td><td style="text-align:left">拼接 Concatenate</td></tr><tr><td style="text-align:left">L * 3</td><td style="text-align:left">重复 Repeat</td></tr><tr><td style="text-align:left">for x in L: print(x)</td><td style="text-align:left">迭代 Iteration</td></tr><tr><td style="text-align:left">3 in L</td><td style="text-align:left">成员关系 membership</td></tr><tr><td style="text-align:left">L.append(4)</td><td style="text-align:left">列表末尾添加新的对象</td></tr><tr><td style="text-align:left">L.extend([5,6,7])</td><td style="text-align:left">用新列表扩展原来的列表</td></tr><tr><td style="text-align:left">L.insert(i, X)</td><td style="text-align:left">插入</td></tr><tr><td style="text-align:left">L.index(X)</td><td style="text-align:left">查找索引</td></tr><tr><td style="text-align:left">L.count(X)</td><td style="text-align:left">统计元素出现次数</td></tr><tr><td style="text-align:left">L.sort()</td><td style="text-align:left">排序</td></tr><tr><td style="text-align:left">L.reverse()</td><td style="text-align:left">反转</td></tr><tr><td style="text-align:left">L.copy()</td><td style="text-align:left">复制</td></tr><tr><td style="text-align:left">L.clear()</td><td style="text-align:left">清除</td></tr><tr><td style="text-align:left">L.pop(i)</td><td style="text-align:left">弹出并返回元素</td></tr><tr><td style="text-align:left">L.remove(X)</td><td style="text-align:left">删除元素</td></tr><tr><td style="text-align:left">del L[i]</td><td style="text-align:left">删除</td></tr><tr><td style="text-align:left">del L[i:j]</td><td style="text-align:left">删除切片</td></tr><tr><td style="text-align:left">L[i:j] = []</td><td style="text-align:left">删除切片</td></tr><tr><td style="text-align:left">L[i] = 3</td><td style="text-align:left">索引赋值</td></tr><tr><td style="text-align:left">L[i:j] = [4,5,6]</td><td style="text-align:left">分片赋值</td></tr><tr><td style="text-align:left">L = [x**2 for x in range(5)]</td><td style="text-align:left">列表推导List comprehensions</td></tr><tr><td style="text-align:left">list(map(ord, ‘spam’))</td><td style="text-align:left">映射 map</td></tr></tbody></table></div><h3 id="二、Lists-in-Action"><a href="#二、Lists-in-Action" class="headerlink" title="二、Lists in Action"></a>二、Lists in Action</h3><ol><li><p>基本列表操作：拼接与重复</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="built_in">print</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>([<span class="string">&#x27;Ni!&#x27;</span>] * <span class="number">4</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>列表迭代和推导List Iteration and Comprehensions</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(x, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">res = [c * <span class="number">4</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;SPAM&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="comment"># map()会根据提供的函数对指定序列做映射</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, [-<span class="number">1</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])))</span><br></pre></td></tr></table></figure><p>显式结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">True</span><br><span class="line">1 2 3 [&#x27;SSSS&#x27;, &#x27;PPPP&#x27;, &#x27;AAAA&#x27;, &#x27;MMMM&#x27;]</span><br><span class="line">[1, 2, 0, 1, 2]</span><br></pre></td></tr></table></figure></li><li><p><strong>索引、分片和矩阵Indexing, Slicing, and Matrixes</strong></p><ul><li>对列表进行<strong>分片</strong>会返回一个新的列表：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;Spam&#x27;</span>, <span class="string">&#x27;SPAM!&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(L[-<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SPAM!</span><br><span class="line">Spam</span><br><span class="line">[&#x27;Spam&#x27;, &#x27;SPAM!&#x27;]</span><br></pre></td></tr></table></figure></li><li><strong>矩阵和嵌套</strong>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(matrix[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(matrix[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(matrix[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">        [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(matrix[<span class="number">1</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>原位置修改列表</p><ul><li><strong>索引</strong>和<strong>分片</strong>的<strong>赋值</strong>都直接修改列表，而不是生成一个新的列表；</li><li>分片赋值slice assignment可分成2步理解：（1）删除等号左边指定分片；（2）将等号右边插入被删除的部分；</li><li>分片赋值可用于替换、增长、删除<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;Spam&#x27;</span>, <span class="string">&#x27;SPAM!&#x27;</span>]</span><br><span class="line">L[<span class="number">1</span>] = <span class="string">&#x27;eggs&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">L[<span class="number">0</span>:<span class="number">2</span>] = [<span class="string">&#x27;eat&#x27;</span>, <span class="string">&#x27;more&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"></span><br><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">L[<span class="number">2</span>:<span class="number">5</span>] = L[<span class="number">3</span>:<span class="number">6</span>] <span class="comment"># 右侧在左侧被执行删除前就被取出来了</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">L[<span class="number">1</span>:<span class="number">2</span>] = [<span class="number">4</span>, <span class="number">5</span>] <span class="comment"># 插入的元素数目不需要与被删除的数目相匹配</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">L[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">6</span>, <span class="number">7</span>] <span class="comment"># 将1：1之间的空白切片插入6、7</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">L[<span class="number">1</span>:<span class="number">2</span>] = []</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">L = [<span class="number">1</span>]</span><br><span class="line">L[:<span class="number">0</span>] = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="comment"># 在最前面插入</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">L[<span class="built_in">len</span>(L):] = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] <span class="comment"># 在最后面插入</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">L.extend([<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;SPAM!&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;eat&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;SPAM!&#x27;</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>列表方法调用</p><ul><li><code>L.append(X)</code>跟<code>L+[X]</code>类似，不同的是前者原位置修改L，而后者会生成新的列表：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">&#x27;eat&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;SPAM!&#x27;</span>]</span><br><span class="line">L.append(<span class="string">&#x27;please&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure></li><li><code>sort</code>方法，可以传入关键词参数对sort行为进行修改：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;ABD&#x27;</span>, <span class="string">&#x27;aBe&#x27;</span>]</span><br><span class="line">L.sort()</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">L = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;ABD&#x27;</span>, <span class="string">&#x27;aBe&#x27;</span>]</span><br><span class="line">L.sort(key=<span class="built_in">str</span>.lower) <span class="comment"># 小写后排序</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">L = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;ABD&#x27;</span>, <span class="string">&#x27;aBe&#x27;</span>]</span><br><span class="line">L.sort(key=<span class="built_in">str</span>.lower, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure></li><li><code>append</code>和<code>sort</code>方法不会返回列表对象，返回值都是<code>None</code>。</li><li><code>sorted</code>函数，返回一个新的列表：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;ABD&#x27;</span>, <span class="string">&#x27;aBe&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(L, key=<span class="built_in">str</span>.lower, reverse=<span class="literal">True</span>))</span><br><span class="line">L = [<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;ABD&#x27;</span>, <span class="string">&#x27;aBe&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>([x.lower() <span class="keyword">for</span> x <span class="keyword">in</span> L], reverse=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他常见列表方法或操作</p><ul><li><code>extend</code>方法是循环访问传入的可迭代对象，并逐个把产生的元素添加到列表尾部，而append是直接将传入的可迭代对象添加到尾部。详见第14章。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">L.extend([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure></li><li><code>pop</code>方法弹出并返回最后最后一个元素，并且能够接受被删除并返回的元素的偏移量（默认为-1）：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(L.pop())</span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure></li><li><code>reverse</code>方法和<code>reversed</code>函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L.reverse()</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">reversed</span>(L)) <span class="comment"># 结果是一个能够按需产生值的迭代器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(L)))</span><br></pre></td></tr></table></figure></li><li><code>pop</code>方法和<code>append</code>方法联用，以实现快速的<strong>后进先出栈结构last in-first-out (LIFO) stack structure</strong>，列表的末端作为<strong>栈</strong>的顶端：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = []</span><br><span class="line">L.append(<span class="number">1</span>) <span class="comment"># Push onto stack</span></span><br><span class="line">L.append(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="built_in">print</span>(L.pop()) <span class="comment"># Pop off stack</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure></li><li><code>remove</code>、<code>insert</code>、<code>count</code>、<code>index</code>方法：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;ham&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(L.index(<span class="string">&#x27;eggs&#x27;</span>)) <span class="comment"># 查找某元素的偏移</span></span><br><span class="line">L.insert(<span class="number">1</span>, <span class="string">&#x27;toast&#x27;</span>) <span class="comment"># 在偏移处插入某元素</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">L.remove(<span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="built_in">print</span>(L.count(<span class="string">&#x27;spam&#x27;</span>)) <span class="comment"># 计算元素出现的次数</span></span><br></pre></td></tr></table></figure></li><li><code>del</code>语句del statement：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;ham&#x27;</span>, <span class="string">&#x27;toast&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> L[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="keyword">del</span> L[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、Dictionaries"><a href="#三、Dictionaries" class="headerlink" title="三、Dictionaries"></a>三、Dictionaries</h3><ol><li><p>字典的特性</p><ul><li>字典有时叫做关联数组associative arrays或散列表hashes；</li><li>通过键而不是偏移量来读取；任意对象的无序集合（以前无序，从python3.6开始，dict的插入变为有序，即字典整体变的有序）；</li><li>长度可变、异构、任意嵌套Variable-length, heterogeneous, and arbitrarily nestable；属于可变映射类型Of the category “mutable mapping”；对象引用表（散列表）。</li></ul></li><li><p>常见字典字面量和操作</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Interpretation</th></tr></thead><tbody><tr><td style="text-align:left">D = {}</td><td style="text-align:left">空字典</td></tr><tr><td style="text-align:left">D = {‘name’: ‘Bob’, ‘age’: 40}</td><td style="text-align:left">字典</td></tr><tr><td style="text-align:left">E = {‘cto’: {‘name’: ‘Bob’, ‘age’: 40}}</td><td style="text-align:left">嵌套 Nesting</td></tr><tr><td style="text-align:left">D = dict(name=’Bob’, age=40)</td><td style="text-align:left">dict函数</td></tr><tr><td style="text-align:left">D = dict([(‘name’, ‘Bob’), (‘age’, 40)])</td><td style="text-align:left">键值对</td></tr><tr><td style="text-align:left">D = dict(zip(keyslist, valueslist))</td><td style="text-align:left">拉链式键值对zipped key/value pairs</td></tr><tr><td style="text-align:left">D = dict.fromkeys([‘name’, ‘age’])</td><td style="text-align:left">键列表</td></tr><tr><td style="text-align:left">D[‘name’]</td><td style="text-align:left">键索引</td></tr><tr><td style="text-align:left">E[‘cto’][‘age’]</td><td style="text-align:left">嵌套索引</td></tr><tr><td style="text-align:left">‘age’ in D</td><td style="text-align:left">成员关系：键存在测试</td></tr><tr><td style="text-align:left">D.keys()</td><td style="text-align:left">方法：所有键</td></tr><tr><td style="text-align:left">D.values()</td><td style="text-align:left">所有值</td></tr><tr><td style="text-align:left">D.items()</td><td style="text-align:left">所有键值元组</td></tr><tr><td style="text-align:left">D.copy()</td><td style="text-align:left">复制copy (top-level)</td></tr><tr><td style="text-align:left">D.clear()</td><td style="text-align:left">清除</td></tr><tr><td style="text-align:left">D.update(D2)</td><td style="text-align:left">通过键合并 merge by keys</td></tr><tr><td style="text-align:left">D.get(key, default)</td><td style="text-align:left">通过键获取，如果不存在返回default或None</td></tr><tr><td style="text-align:left">D.pop(key, default)</td><td style="text-align:left">通过键删除，如果不存在返回default或错误</td></tr><tr><td style="text-align:left">D.setdefault(key, default)</td><td style="text-align:left">通过键获取，如果不存在default设置为None</td></tr><tr><td style="text-align:left">D.popitem()</td><td style="text-align:left">删除/返回键值对</td></tr><tr><td style="text-align:left">len(D)</td><td style="text-align:left">长度，存储的键值对的对数</td></tr><tr><td style="text-align:left">D[key] = 42</td><td style="text-align:left">增加键值对</td></tr><tr><td style="text-align:left">del D[key]</td><td style="text-align:left">删除键值对</td></tr><tr><td style="text-align:left">list(D.keys())</td><td style="text-align:left">查看键</td></tr><tr><td style="text-align:left">D = {x: x*2 for x in range(10)}</td><td style="text-align:left">字典推导</td></tr></tbody></table></div><h3 id="四、Dictionaries-in-Action"><a href="#四、Dictionaries-in-Action" class="headerlink" title="四、Dictionaries in Action"></a>四、Dictionaries in Action</h3><ol><li><p>字典的基本操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;spam&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;ham&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;eggs&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(D[<span class="string">&#x27;spam&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(D)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(D))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ham&#x27;</span> <span class="keyword">in</span> D) <span class="comment"># 直接测试键是否存在</span></span><br><span class="line"><span class="built_in">print</span>(D.keys()) <span class="comment"># 返回的是一个可迭代对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(D.keys()))</span><br></pre></td></tr></table></figure></li><li><p>原位置修改字典</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D[<span class="string">&#x27;ham&#x27;</span>] = [<span class="string">&#x27;grill&#x27;</span>, <span class="string">&#x27;bake&#x27;</span>, <span class="string">&#x27;fry&#x27;</span>] <span class="comment"># 修改元素</span></span><br><span class="line"><span class="built_in">print</span>(D)</span><br><span class="line"><span class="keyword">del</span> D[<span class="string">&#x27;eggs&#x27;</span>] <span class="comment"># 删除元素</span></span><br><span class="line"><span class="built_in">print</span>(D)</span><br><span class="line">D[<span class="string">&#x27;brunch&#x27;</span>] = <span class="string">&#x27;Bacon&#x27;</span> <span class="comment"># 新增元素</span></span><br><span class="line"><span class="built_in">print</span>(D)</span><br></pre></td></tr></table></figure></li><li><p>其他字典方法</p><ul><li><code>values</code>方法和<code>items</code>方法，都返回可迭代对象，values返回值，items返回键值对的元组：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;spam&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;ham&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;eggs&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(D.values()))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(D.items()))</span><br></pre></td></tr></table></figure></li><li><code>get</code>方法通过键获取值，若键不存在，则返回默认值None或指定的默认值：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(D.get(<span class="string">&#x27;spam&#x27;</span>)) <span class="comment"># get方法通过键获取值，若键不存在，则返回默认值None或指定的默认值</span></span><br><span class="line"><span class="built_in">print</span>(D.get(<span class="string">&#x27;toast&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(D.get(<span class="string">&#x27;toast&#x27;</span>, <span class="number">88</span>))</span><br></pre></td></tr></table></figure></li><li><code>update</code>方法，类似于拼接：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;eggs&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;spam&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;ham&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">D2 = &#123;<span class="string">&#x27;toast&#x27;</span>:<span class="number">4</span>, <span class="string">&#x27;muffin&#x27;</span>:<span class="number">5</span>&#125;</span><br><span class="line">D.update(D2)</span><br><span class="line"><span class="built_in">print</span>(D)</span><br></pre></td></tr></table></figure></li><li><code>pop</code>方法删除一个键并返回它的值：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(D.pop(<span class="string">&#x27;muffin&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(D.pop(<span class="string">&#x27;toast&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(D)</span><br></pre></td></tr></table></figure></li><li>遍历字典的键列表：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = &#123;<span class="string">&#x27;1975&#x27;</span>: <span class="string">&#x27;Holy Grail&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;1979&#x27;</span>: <span class="string">&#x27;Life of Brian&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1983&#x27;</span>: <span class="string">&#x27;The Meaning of Life&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> table:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>\t<span class="subst">&#123;table[year]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>推导语法，从值到键；在字典中可能一个值会有多个键与之对应：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = &#123;<span class="string">&#x27;Holy Grail&#x27;</span>: <span class="string">&#x27;1975&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;Life of Brian&#x27;</span>: <span class="string">&#x27;1979&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;The Meaning of Life&#x27;</span>: <span class="string">&#x27;1983&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(table.items()))</span><br><span class="line"><span class="built_in">print</span>([title <span class="keyword">for</span> (title, year) <span class="keyword">in</span> table.items() <span class="keyword">if</span> year == <span class="string">&#x27;1975&#x27;</span>]) <span class="comment"># 详见14章、32章</span></span><br></pre></td></tr></table></figure></li><li>copy方法在第9章进行讨论。</li></ul></li><li><p>用整数、元组作键</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = &#123;<span class="number">1975</span>: <span class="string">&#x27;Holy Grail&#x27;</span>,</span><br><span class="line">    <span class="number">1979</span>: <span class="string">&#x27;Life of Brian&#x27;</span>, </span><br><span class="line">    <span class="number">1983</span>: <span class="string">&#x27;The Meaning of Life&#x27;</span>&#125;</span><br><span class="line">Matrix = &#123;&#125;</span><br><span class="line">Matrix[(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)] = <span class="number">88</span></span><br><span class="line">Matrix[(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)] = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(Matrix)</span><br></pre></td></tr></table></figure></li><li><p>字典的嵌套</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rec = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;jobs&#x27;</span>: [<span class="string">&#x27;developer&#x27;</span>, <span class="string">&#x27;manager&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;web&#x27;</span>: <span class="string">&#x27;www.bobs.org/˜Bob&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;home&#x27;</span>: &#123;<span class="string">&#x27;state&#x27;</span>: <span class="string">&#x27;Overworked&#x27;</span>, <span class="string">&#x27;zip&#x27;</span>: <span class="number">12345</span>&#125;&#125;</span><br><span class="line"><span class="built_in">print</span>(rec[<span class="string">&#x27;jobs&#x27;</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(rec[<span class="string">&#x27;home&#x27;</span>][<span class="string">&#x27;zip&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>dict函数创建字典</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">40</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">40</span>)]))</span><br><span class="line"><span class="comment"># zip函数，详见13、14章</span></span><br><span class="line">keyslist = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">valueslist = [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">40</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>(keyslist, valueslist)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">zip</span>(keyslist, valueslist))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])))</span><br><span class="line"><span class="built_in">print</span>(&#123;k: v <span class="keyword">for</span> (k, v) <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])&#125;) <span class="comment"># 字典推导表达式</span></span><br><span class="line"><span class="built_in">print</span>(&#123;x: x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"><span class="comment"># fromkeys方法将同一值传入键列表，默认值为None</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>.fromkeys(<span class="string">&#x27;spam&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>字典视图Dictionary views<br>字典的keys, values和items方法都返回<strong><em>视图对象view objects</em></strong>：<strong>视图对象</strong>是<strong>可迭代对象</strong>，每次只产生一个结果项的对象，而不是在内存中立即产生结果列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = <span class="built_in">dict</span>(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(D.keys())</span><br><span class="line"><span class="built_in">print</span>(D.values())</span><br><span class="line"><span class="built_in">print</span>(D.items())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(D.keys()), <span class="built_in">list</span>(D.values()), <span class="built_in">list</span>(D.items()))</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> D.keys(): <span class="built_in">print</span>(k)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> D: <span class="built_in">print</span>(key)</span><br><span class="line"><span class="comment"># 对字典的改变会改变视图对象</span></span><br><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">K = D.keys()</span><br><span class="line">V = D.values()</span><br><span class="line"><span class="keyword">del</span> D[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(K), <span class="built_in">list</span>(V))</span><br></pre></td></tr></table></figure></li><li><p>字典视图和集合</p><ul><li><code>keys</code>方法返回的视图对象类似于集合，支持交集和并集等操作：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(D.keys() &amp; D.keys())</span><br><span class="line"><span class="built_in">print</span>(D.keys() &amp; &#123;<span class="string">&#x27;b&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(D.keys() &amp; &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(D.keys() | &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><code>values</code>视图不支持，因为值不唯一，但<code>items</code>可以，因为键值对是唯一的，并且是<strong>可散列的hashable</strong>(具有<strong>不变性的immutable</strong>)：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(D.values() &amp; &#123;<span class="number">1</span>&#125;)  <span class="comment"># TypeError: unsupported operand type(s) for &amp;: &#x27;dict_values&#x27; and &#x27;set&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(D.items() &amp; D.items())</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;(<span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>)&#125;</span><br></pre></td></tr></table></figure></li><li>如果字典项视图是<strong>可散列</strong>的话，也就是，只包括<strong>不可变的对象</strong>的话，他们类似于集合；Items views are set-like too if they are <strong>hashable</strong>—that is, if they contain only <strong>immutable</strong> objects：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(D.items()))</span><br><span class="line"><span class="built_in">print</span>(D.items() | D.keys())</span><br><span class="line"><span class="built_in">print</span>(D.items() | D)</span><br><span class="line"><span class="built_in">print</span>(D.items() | &#123;(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>)&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(D.items() | &#123;(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>)&#125;))</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, (<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>)&#125;</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>, (<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>)&#125;</span><br><span class="line">&#123;(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>)&#125;</span><br><span class="line">&#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></li><li>视图对象不能用方法：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">Ks = D.keys()</span><br><span class="line">Ks.sort() <span class="comment"># AttributeError: &#x27;dict_keys&#x27; object has no attribute &#x27;sort&#x27;</span></span><br><span class="line"><span class="comment"># 要排序用sorted函数</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(Ks): <span class="built_in">print</span>(k, D[k])</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(D): <span class="built_in">print</span>(k, D[k])</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="chapter-9-Tuples-Files-and-Everything-Else"><a href="#chapter-9-Tuples-Files-and-Everything-Else" class="headerlink" title="chapter 9 Tuples, Files, and Everything Else"></a>chapter 9 Tuples, Files, and Everything Else</h2><h3 id="一、Tuples"><a href="#一、Tuples" class="headerlink" title="一、Tuples"></a>一、Tuples</h3><ol><li><p>元组的特性<br>任意对象的有序集合；通过偏移量存取；属于<strong>不可变序列</strong>；固定长度、多样性、任意嵌套；对象引用的数组。</p></li><li><p>元组字面量和运算</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Interpretation</th></tr></thead><tbody><tr><td style="text-align:left">()</td><td style="text-align:left">空元组</td></tr><tr><td style="text-align:left">T = (0,)</td><td style="text-align:left">单个元素的元组</td></tr><tr><td style="text-align:left">T = (0, ‘Ni’, 1.2, 3)</td><td style="text-align:left">多元素元组</td></tr><tr><td style="text-align:left">T = 0, ‘Ni’, 1.2, 3</td><td style="text-align:left">同上(无括号)</td></tr><tr><td style="text-align:left">T = (‘Bob’, (‘dev’, ‘mgr’))</td><td style="text-align:left">嵌套元组</td></tr><tr><td style="text-align:left">T = tuple(‘spam’)</td><td style="text-align:left">可迭代对象的元素组成的元组</td></tr><tr><td style="text-align:left">T[i]</td><td style="text-align:left">索引</td></tr><tr><td style="text-align:left">T[i][j]</td><td style="text-align:left">嵌套索引</td></tr><tr><td style="text-align:left">T[i:j]</td><td style="text-align:left">切片</td></tr><tr><td style="text-align:left">len(T)</td><td style="text-align:left">长度</td></tr><tr><td style="text-align:left">T1 + T2</td><td style="text-align:left">拼接</td></tr><tr><td style="text-align:left">T * 3</td><td style="text-align:left">重复</td></tr><tr><td style="text-align:left">for x in T: print(x)</td><td style="text-align:left">迭代</td></tr><tr><td style="text-align:left">‘spam’ in T</td><td style="text-align:left">成员关系</td></tr><tr><td style="text-align:left">[x ** 2 for x in T]</td><td style="text-align:left">列表推导</td></tr><tr><td style="text-align:left">T.index(‘Ni’)</td><td style="text-align:left">查找方法</td></tr><tr><td style="text-align:left">T.count(‘Ni’)</td><td style="text-align:left">计数</td></tr><tr><td style="text-align:left">namedtuple(‘Emp’, [‘name’, ‘jobs’])</td><td style="text-align:left">有名元组拓展类型</td></tr></tbody></table></div><h3 id="二、Tuples-in-Action"><a href="#二、Tuples-in-Action" class="headerlink" title="二、Tuples in Action"></a>二、Tuples in Action</h3><ol><li><p>元组的基本操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(T[<span class="number">0</span>], T[<span class="number">1</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure></li><li><p>逗号和圆括号<br>python允许忽略元组的圆括号，但建议一直使用圆括号；<em>单个元素的元组如果没逗号，不是元组</em>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = (<span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x)) <span class="comment"># 不加逗号，x为整数</span></span><br><span class="line">y = (<span class="number">40</span>,)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(y))</span><br></pre></td></tr></table></figure></li><li><p>转换、方法或不可变性</p><ul><li>因为元组是<strong>不可变对象</strong>，需要转为列表再用<code>sort方法</code>排序：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = (<span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;dd&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">tmp = <span class="built_in">list</span>(T)</span><br><span class="line">tmp.sort()</span><br><span class="line">T = <span class="built_in">tuple</span>(tmp)</span><br><span class="line"><span class="built_in">print</span>(T)</span><br></pre></td></tr></table></figure></li><li><code>sorted函数</code>接受任何序列对象，返回的是一个新的list：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = (<span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;dd&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(T))</span><br></pre></td></tr></table></figure></li><li><strong>列表推导</strong>总是会创建新的列表，可以用来遍历元组、字符串在内的任何序列对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">L = [x + <span class="number">20</span> <span class="keyword">for</span> x <span class="keyword">in</span> T]</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">X = (x + <span class="number">20</span> <span class="keyword">for</span> x <span class="keyword">in</span> T)</span><br><span class="line"><span class="built_in">print</span>(X)</span><br></pre></td></tr></table></figure></li><li><code>index方法</code>和<code>count方法</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(T.index(<span class="number">2</span>)) <span class="comment"># 第一个2的偏移量</span></span><br><span class="line"><span class="built_in">print</span>(T.index(<span class="number">2</span>, <span class="number">2</span>)) <span class="comment"># 偏移量2后面的2的偏移量</span></span><br><span class="line"><span class="built_in">print</span>(T.count(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li><li>元组的不可变性只适用于本组本身顶层而并非其内容，比如<em>元组内列表可以修改</em>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">T = (<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>)</span><br><span class="line">T[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(T)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>有名元组Named Tuples</p><ul><li><code>namedtuple</code>工具（<code>collections</code>模块）实现了一个增加了逻辑的元组拓展类型，能同时支持使用序号和属性名访问组件，也可以使用键的类字典形式访问；有名元组的属性名来自类，因此与键不完全相同：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Rec = namedtuple(<span class="string">&#x27;Rec&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;jobs&#x27;</span>])</span><br><span class="line">bob = Rec(<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">40.5</span>, jobs=[<span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;mgr&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(bob)</span><br><span class="line"><span class="built_in">print</span>(bob[<span class="number">0</span>], bob[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(bob.name, bob.jobs)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Rec(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">40.5</span>, jobs=[<span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;mgr&#x27;</span>])</span><br><span class="line">Bob [<span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;mgr&#x27;</span>]</span><br><span class="line">Bob [<span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;mgr&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li>在需要时，可以转换成一个类字典的基于键的形式：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">O = bob._asdict()</span><br><span class="line"><span class="built_in">print</span>(O[<span class="string">&#x27;name&#x27;</span>], O[<span class="string">&#x27;jobs&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(O)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Bob [<span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;mgr&#x27;</span>]</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">40.5</span>, <span class="string">&#x27;jobs&#x27;</span>: [<span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;mgr&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure></li><li>元组赋值，元组和有名元组都支持<strong>解包元组赋值</strong>，详见第13章：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bob = Rec(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">40.5</span>, [<span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;mgr&#x27;</span>])</span><br><span class="line">name, age, jobs = bob</span><br><span class="line"><span class="built_in">print</span>(name, jobs)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> bob: <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>运行结果如下：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Bob [<span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;mgr&#x27;</span>]</span><br><span class="line">Bob</span><br><span class="line"><span class="number">40.5</span></span><br><span class="line">[<span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;mgr&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、Files"><a href="#三、Files" class="headerlink" title="三、Files"></a>三、Files</h3><ol><li>常见的文件操作</li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Interpretation</th></tr></thead><tbody><tr><td style="text-align:left">output = open(r’C:\spam’, ‘w’)</td><td style="text-align:left">创建输出文件，防止出现字符串转义要用原始字符串r</td></tr><tr><td style="text-align:left">input = open(‘data’, ‘r’)</td><td style="text-align:left">创建输入文件</td></tr><tr><td style="text-align:left">input = open(‘data’)</td><td style="text-align:left">与上一行一样，r是默认值</td></tr><tr><td style="text-align:left">aString = input.read()</td><td style="text-align:left">把整个文件读入一个字符串</td></tr><tr><td style="text-align:left">aString = input.read(N)</td><td style="text-align:left">读取接下来的N个字符到一个字符串</td></tr><tr><td style="text-align:left">aString = input.readline()</td><td style="text-align:left">读取下一行（包括\n换行符）到一个字符串</td></tr><tr><td style="text-align:left">aList = input.readlines()</td><td style="text-align:left">读取整个文件到一个字符串列表（包括\n换行符）</td></tr><tr><td style="text-align:left">output.write(aString)</td><td style="text-align:left">把字符串写入文件</td></tr><tr><td style="text-align:left">output.writelines(aList)</td><td style="text-align:left">把列表内所以字符串写入文件</td></tr><tr><td style="text-align:left">output.close()</td><td style="text-align:left">手动关闭（当文件收集完成时会替你关闭文件）</td></tr><tr><td style="text-align:left">output.flush()</td><td style="text-align:left">把输出缓冲区刷入硬盘中，但不关闭文件</td></tr><tr><td style="text-align:left">anyFile.seek(N)</td><td style="text-align:left">将文件位置移动到偏移量N处以便进行下一个操作</td></tr><tr><td style="text-align:left">for line in open(‘data’): use line</td><td style="text-align:left">文件迭代器逐行读取</td></tr><tr><td style="text-align:left">open(‘f.txt’, encoding=’latin-1’)</td><td style="text-align:left">Unicode文本文件</td></tr><tr><td style="text-align:left">open(‘f.bin’, ‘rb’)</td><td style="text-align:left">字节码文件</td></tr></tbody></table></div><ol><li><p>打开文件</p><ul><li><code>open函数</code>：<code>afile = open(filename, mode)</code></li><li><code>open函数</code>的第二个参数是处理模式，<code>&#39;r&#39;</code>以输入模式打开文件（默认值），<code>&#39;w&#39;</code>以输出模式生成并打开文件，<code>&#39;a&#39;</code>表示在文件尾部追加内容并打开文件；</li><li>在模式字符串中加上<code>&#39;b&#39;</code>可以进行二进制数据处理；加上<code>&#39;+&#39;</code>意味着被打开文件同时支持输入输出；</li><li><code>open函数</code>的前2个参数必须是字符串。第三个为可选参数，它能够用来控制输出缓冲：传入<code>0</code>意味着输出无缓冲（写入方法调用时立即传入外部文件）；</li><li><code>open函数</code>的其他参数可用于特殊种类的文件。</li></ul></li><li><p>使用文件的基础用法的提示：</p><ul><li>文件迭代器最适合逐行读取，见第14章；</li><li>内容是字符串，不是对象：从文件读取的数据回到脚本时是一个字符串；</li><li>文件是被缓冲的以及可定位的：默认情况下，输出文件总是被缓冲的，这意味着写入的文本不能不会立即自动从内存转移到硬盘，除非关闭一个文件，或者运行其flush方法，才能强制被缓冲的数据进入硬盘；</li><li><code>close</code>通常是可选的：回收时自动关闭：但手动关闭调用在大型程序中通常是不错的习惯，当循环中有许多文件被打开时，可能需要在垃圾回收机制发挥作用前，调用close释放资源。</li></ul></li></ol><h3 id="四、Files-in-Action"><a href="#四、Files-in-Action" class="headerlink" title="四、Files in Action"></a>四、Files in Action</h3><ol><li><p>文件的基本操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myfile = <span class="built_in">open</span>(<span class="string">&#x27;9-Tuples, Files, and Everything Else\myfile.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">myfile.write(<span class="string">&#x27;hello text file\n&#x27;</span>) <span class="comment"># 该方法会返回写入的字符数16</span></span><br><span class="line">myfile.write(<span class="string">&#x27;goodbye text file\n&#x27;</span>) <span class="comment"># 该方法会返回写入的字符数18</span></span><br><span class="line">myfile.close()</span><br><span class="line">myfile = <span class="built_in">open</span>(<span class="string">&#x27;9-Tuples, Files, and Everything Else\myfile.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(myfile.readline())</span><br><span class="line"><span class="built_in">print</span>(myfile.readline())</span><br><span class="line"><span class="built_in">print</span>(myfile.readline())</span><br><span class="line"><span class="comment"># read方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">&#x27;9-Tuples, Files, and Everything Else\myfile.txt&#x27;</span>).read())</span><br><span class="line"><span class="comment"># 文件迭代器</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;9-Tuples, Files, and Everything Else\myfile.txt&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>获取当前文件的路径：<code>os模块</code></p><ul><li><code>os.getcwd()方法</code>，cwd：current working directory：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.getcwd())</span><br></pre></td></tr></table></figure></li><li><code>os.chdir()方法</code>改变默认路径，chdir：change directory：<code>os.chdir(&#39;C:\Users\XXXXXXXXXXXXXXXXXX&#39;)</code></li></ul></li><li><p>文本文件和二进制文件Text and Binary Files<br>文本文件把内容表示为常规的str字符串，自动执行Unicode编码和解码，并且默认执行末行转换；二进制文件把内容表示为一个特殊的bytes字节串类型，并且允许程序不修改地访问内容；二进制文件不会对数据执行任何换行符转换，而文本文件会默认执行对\n的来回转换，并采用Unicode编码。详见第37章：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="built_in">open</span>(<span class="string">&#x27;9-Tuples, Files, and Everything Else\data.bin&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">4</span>:<span class="number">8</span>])</span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">4</span>:<span class="number">8</span>][<span class="number">0</span>]) <span class="comment"># s的ASCII码是115</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(data[<span class="number">4</span>:<span class="number">8</span>][<span class="number">0</span>]))</span><br></pre></td></tr></table></figure></li><li><p>在文件中存储Python对象：转换</p><ul><li>文件数据在脚本中一定是字符串，需要使用转换工具把对象转为字符串：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, Y, Z = <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span></span><br><span class="line">S = <span class="string">&#x27;Spam&#x27;</span></span><br><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">F = <span class="built_in">open</span>(<span class="string">&#x27;9-Tuples, Files, and Everything Else\datafile.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">F.write(S + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">F.write(<span class="string">&#x27;%s,%s,%s\n&#x27;</span> % (X, Y, Z))</span><br><span class="line">F.write(<span class="built_in">str</span>(L) + <span class="string">&#x27;$&#x27;</span> + <span class="built_in">str</span>(D) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">F.close()</span><br><span class="line">chars = <span class="built_in">open</span>(<span class="string">&#x27;9-Tuples, Files, and Everything Else\datafile.txt&#x27;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(chars)</span><br></pre></td></tr></table></figure></li><li><code>rstrip方法</code>，删除\n：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F = <span class="built_in">open</span>(<span class="string">&#x27;9-Tuples, Files, and Everything Else\datafile.txt&#x27;</span>)</span><br><span class="line">line = F.readline()</span><br><span class="line"><span class="built_in">print</span>(line.rstrip())</span><br></pre></td></tr></table></figure></li><li><code>spilt方法</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line = F.readline()</span><br><span class="line"><span class="built_in">print</span>(line)</span><br><span class="line">parts = line.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(parts)</span><br><span class="line">numbers = [<span class="built_in">int</span>(P) <span class="keyword">for</span> P <span class="keyword">in</span> parts] <span class="comment"># int函数去除\n</span></span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br></pre></td></tr></table></figure></li><li><code>eval函数</code>，来执行一个字符串表达式，并返回表达式的值。把字符串当作可执行程序代码：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line = F.readline()</span><br><span class="line"><span class="built_in">print</span>(line)</span><br><span class="line">parts = line.split(<span class="string">&#x27;$&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(parts)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(parts[<span class="number">0</span>]))</span><br><span class="line">objects = [<span class="built_in">eval</span>(P) <span class="keyword">for</span> P <span class="keyword">in</span> parts] <span class="comment"># eval函数去除\n</span></span><br><span class="line"><span class="built_in">print</span>(objects)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>存储原生对象：pickle模块 (Storing Native Python Objects: pickle)<br><code>pickle模块</code>能够让我们直接在文件中存储任何python对象的高级工具，同时并不需要对字符串进行来回转换。可视为通用的数据格式化和解析工具；pickle模块会执行所谓的对象序列化，也就是对象与字节字符串之间的相互转换：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">F = <span class="built_in">open</span>(<span class="string">&#x27;9-Tuples, Files, and Everything Else\datafile.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">pickle.dump(D, F)</span><br><span class="line">F = <span class="built_in">open</span>(<span class="string">&#x27;9-Tuples, Files, and Everything Else\datafile.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">E = pickle.load(F)</span><br><span class="line"><span class="built_in">print</span>(E)</span><br></pre></td></tr></table></figure></li><li><p>用JSON格式存储Python对象：json标准库<br>由于JSON与Python中字典和列表在语法上的相似性，因此<code>json标准库</code>能够很容易地在python对象与JSON格式之间来回转换：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">dict</span>(first=<span class="string">&#x27;Bob&#x27;</span>, last=<span class="string">&#x27;Smith&#x27;</span>)</span><br><span class="line">rec = <span class="built_in">dict</span>(name=name, job=[<span class="string">&#x27;dev&#x27;</span>, <span class="string">&#x27;mgr&#x27;</span>], age=<span class="number">40.5</span>)</span><br><span class="line"><span class="built_in">print</span>(rec)</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">S = json.dumps(rec)</span><br><span class="line"><span class="built_in">print</span>(S)</span><br><span class="line">O = json.loads(S)</span><br><span class="line"><span class="built_in">print</span>(O)</span><br><span class="line"><span class="built_in">print</span>(O == rec)</span><br><span class="line"></span><br><span class="line">json.dump(rec, fp=<span class="built_in">open</span>(<span class="string">r&#x27;9-Tuples, Files, and Everything Else\testjson.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>), indent=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">open</span>(<span class="string">r&#x27;9-Tuples, Files, and Everything Else\testjson.txt&#x27;</span>).read())</span><br><span class="line">P = json.load(<span class="built_in">open</span>(<span class="string">r&#x27;9-Tuples, Files, and Everything Else\testjson.txt&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(P)</span><br></pre></td></tr></table></figure></li><li><p>存储打包二进制数据：struct模块<br><code>struct模块</code>能够构造并解析打包二进制数据，要生成一个打包二进制数据文件，可以用’wb’（写入二进制）模式打开它，并将一个格式化字符串和几个对象传给struct，python会创建一个我们通常写入文件的二进制bytes数据字节码，主要由不可打印字符的十六进制转义组成：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F = <span class="built_in">open</span>(<span class="string">&#x27;9-Tuples, Files, and Everything Else\data.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">data = struct.pack(<span class="string">&#x27;&gt;i4sh&#x27;</span>, <span class="number">7</span>, <span class="string">b&#x27;spam&#x27;</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">F.write(data)</span><br><span class="line">F.close()</span><br><span class="line"></span><br><span class="line">F = <span class="built_in">open</span>(<span class="string">&#x27;9-Tuples, Files, and Everything Else\data.bin&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">data = F.read()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">values = struct.unpack(<span class="string">&#x27;&gt;i4sh&#x27;</span>, data)</span><br><span class="line"><span class="built_in">print</span>(values)</span><br></pre></td></tr></table></figure></li><li><p>文件上下文管理器File Context Managers<br><em>它可以把文件处理代码包装到一个逻辑层中，以确保在退出后自动关闭文件，而不是依赖于垃圾回收时的自动关闭</em>，详见34章：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;C:\code\data.txt&#x27;</span>) <span class="keyword">as</span> myfile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> myfile:</span><br></pre></td></tr></table></figure></li></ol><h3 id="五、Core-Types-Review-and-Summary"><a href="#五、Core-Types-Review-and-Summary" class="headerlink" title="五、Core Types Review and Summary"></a>五、Core Types Review and Summary</h3><ol><li><p>类型分类和要点</p><ul><li>字符串、列表和元组都拥有如拼接、长度和索引等序列操作；</li><li>只有可变对象（列表、字典和集合）可以在原位置修改；不能原位置修改数字、字符串或元组；</li><li>文件只导出方法，因此可变性并不真的适用它们；</li><li>数字包括整数、浮点数、复数、小数和分数；</li><li>字符串包括str，以及bytes字节串；bytearray字符串类型是可变的；</li><li>集合是一个没有值只有键的字典，不能映射，没有顺序，因此不是映射或序列类型，frozenset是集合的一种拥有不可变性的变体。</li></ul></li><li><p>对象类型</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">对象类型</th><th style="text-align:left">分类</th><th style="text-align:left">是否可变</th></tr></thead><tbody><tr><td style="text-align:left">数字</td><td style="text-align:left">数值</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">字符串</td><td style="text-align:left">序列</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">列表</td><td style="text-align:left">序列</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">字典</td><td style="text-align:left">映射</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">元组</td><td style="text-align:left">序列</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">文件</td><td style="text-align:left">拓展</td><td style="text-align:left">N/A</td></tr><tr><td style="text-align:left">集合</td><td style="text-align:left">集合</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">frozenset</td><td style="text-align:left">集合</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">bytearray</td><td style="text-align:left">序列</td><td style="text-align:left">是</td></tr></tbody></table></div><ol><li><p>对象灵活性<br>列表、字典和元组可以包括任何种类的对象；集合可以包含任意的<strong>不可变类型immutable对象（可哈希的hashable）</strong>；列表、字典和元组可以任意嵌套；列表、字典和集合可以动态地扩大和缩小。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">&#x27;abc&#x27;</span>, [(<span class="number">1</span>, <span class="number">2</span>), ([<span class="number">3</span>], <span class="number">4</span>)], <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(L[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure></li><li><p>引用vs复制</p><ul><li>由于赋值会产生相同对象的多个引用，因此原位置修改可变对象时，可能会影响其他程序，特别是当涉及嵌套时，关系会复杂：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">L = [<span class="string">&#x27;a&#x27;</span>, X, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">D = &#123;<span class="string">&#x27;x&#x27;</span>:X, <span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">上面为第一行的列表创建了<span class="number">3</span>个引用，由于列表是可变的，修改对象会改变另外<span class="number">2</span>个</span><br><span class="line">X[<span class="number">1</span>] = <span class="string">&#x27;surprise&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line"><span class="built_in">print</span>(D)</span><br></pre></td></tr></table></figure></li><li>复制的方法：i、无参数分片表达式(L[:])；ii、字典、集合或列表的copy方法；iii、list、dict、set函数；iv、copy标准库模块。补：无参数的分片和字典的copy方法只能进行顶层复制，即不能复制嵌套的数据结构，如果要复制深层嵌套的数据结构，要用copy模块的deepcopy方法，见6-2章节。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">D = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">A = L[:]</span><br><span class="line">B = D.copy()</span><br><span class="line">A[<span class="number">1</span>] = <span class="string">&#x27;Ni&#x27;</span></span><br><span class="line">B[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(L, D)</span><br><span class="line"><span class="built_in">print</span>(A, B)</span><br><span class="line"><span class="comment"># 就中最开始的例子来说，用分片即可避免共同引用</span></span><br><span class="line">X = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">L = [<span class="string">&#x27;a&#x27;</span>, X[:], <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">D = &#123;<span class="string">&#x27;x&#x27;</span>:X[:], <span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>比较、等价性和真值Comparisons, Equality, and Truth<br>当嵌套对象存在时，python能够自动遍历数据结构，并从左到右地应用比较，这被称为<strong>递归比较recursive comparison</strong>，见第19章。就核心类型而言，递归功能是默认实现的。例如，比较列表对象将自动比较所有内容：</p><ul><li>==运算符测试值的等价性；is表达式测试对象的同一性：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">1</span>, (<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line">L2 = [<span class="number">1</span>, (<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="built_in">print</span>(L1 == L2, L1 <span class="keyword">is</span> L2) <span class="comment"># L1和L2相等但不是同一个对象</span></span><br></pre></td></tr></table></figure></li><li>理论上下面应该是不同对象相同值，因为python内部会对临时存储并重复使用字符串做优化，所以事实上内存中只有一个字符串’spam’：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S1 = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line">S2 = <span class="string">&#x27;spam&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S1 == S2, S1 <span class="keyword">is</span> S2)</span><br></pre></td></tr></table></figure></li><li>相对大小比较也能递归地应用于嵌套的数据结构：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L1 = [<span class="number">1</span>, (<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>)]</span><br><span class="line">L2 = [<span class="number">1</span>, (<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>)]</span><br><span class="line"><span class="built_in">print</span>(L1 &lt; L2, L1 == L2, L1 &gt; L2)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>比较不同类型</p><ul><li>数字比较数值的相对大小；</li><li>字符串按照字母字典顺序比较（按照ord函数返回字符集编码顺序）字符从左到右比较（’abc’&lt;’ac’）；</li><li>列表和元组从左到右，而是对嵌套结构是递归的（[2]&gt;[1,2]）；</li><li>集合相对大小采用子集超集的标准；</li><li>字典通过比较后的(key,value)来判断是否相同，但不支持相对大小比较。</li></ul></li><li><p>True和False<br><strong><em>整数0为真，整数1为假；空数据结构为假，非空数据结构为真</em></strong>，比如<code>if X != &#39;&#39;</code>:是为了测试对象是否包括内容：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&#x27;spam&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(&#123;&#125;))</span><br></pre></td></tr></table></figure></li><li><p>None对象<br><code>None</code>为一个特殊对象，可被认为是假。一般起到一个空占位符的作用；但<code>None</code>不意味着未定义，<code>None</code>是一个对象，而不是没有内容。</p></li><li><p>类型测试</p><ul><li>严格来说，对象的类型本身，也属于type类型的对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(<span class="number">1</span>)))</span><br></pre></td></tr></table></figure></li><li>类型测试及<code>isinstance函数</code>：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>([<span class="number">1</span>]) == <span class="built_in">type</span>([]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>([<span class="number">1</span>]) == <span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>([<span class="number">1</span>], <span class="built_in">list</span>))</span><br></pre></td></tr></table></figure></li><li><code>types模块</code>提供了不能作为内置类型使用的类型的名称：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(): <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f) == types.FunctionType)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="六、Built-in-Type-Gotchas"><a href="#六、Built-in-Type-Gotchas" class="headerlink" title="六、Built-in Type Gotchas"></a>六、Built-in Type Gotchas</h3><ol><li><p>序列重复</p><ul><li>序列重复就是多次将序列加在自己身上：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">X = L * <span class="number">4</span></span><br><span class="line">Y = [L] * <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure></li><li>由于L在赋值给Y时是被嵌套的，因此Y中包含了指向原本L的列表的引用：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure></li><li>解决上面的问题与之前一样，复制个副本：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">Y = [<span class="built_in">list</span>(L)] * <span class="number">4</span></span><br><span class="line">L[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure></li><li>尽管Y与L不再共用同一个列表对象，但Y中的嵌套的列表都指向同一对象：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">99</span> <span class="comment"># 所有四个都被改变了</span></span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure></li><li>避免上述共享，需要保证每个嵌套都有一个单独副本：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">Y = [<span class="built_in">list</span>(L) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br><span class="line">Y[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">99</span> <span class="comment"># 这样就只改变了第一个</span></span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>循环数据结构Cyclic Data Structures<br>如果一个复合对象包含指向自身的引用，就称之为循环对象。python在对象中检测到循环，都会打印成[…]，除非真的需要，不建议使用循环引用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">&#x27;grail&#x27;</span>]</span><br><span class="line">L.append(L)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure></li><li><p>不可变类型不可以在原位置改变<br>不能在原位置改变不可变对象，必须通过分片、拼接等操作来创建一个新的对象，再赋值回原来的引用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python编程从入门到实践》读书笔记（二）</title>
      <link href="/2022/09/12/2022-09-12-Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>/2022/09/12/2022-09-12-Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该笔记为 <strong>《Python编程从入门到实践》</strong> 的读书笔记，由于是早期未搞熟博客系统时所写，笔记结构较为混乱；<br>该笔记涉及的内容较为基础，可能含有大量废话；<br>该书的内容不涉及对Python底层逻辑的理解，不利于巩固基础，<br>建议看完后粗略过一下 <strong>《Learning Python》</strong>（但不建议仔细阅读该书）；<br>学习完成日期为2021年12月13日。</p></blockquote><p><img src="https://s2.loli.net/2022/09/09/F45BwnLIjXxVCtT.png" alt="Python编程从入门到实践"></p><h1 id="第-8-章-函数"><a href="#第-8-章-函数" class="headerlink" title="第 8 章　函数"></a>第 8 章　函数</h1><h2 id="一、定义函数"><a href="#一、定义函数" class="headerlink" title="一、定义函数"></a>一、定义函数</h2><ol><li>定义简单函数 <code>def functionname()：</code> 。</li><li>文档字符串(docstrings) 文档字符串用三引号，注释和文档字符串的区别主要在于文档字符串是可以调用的，而注释不行。</li><li>向函数传递信息 <code>def functionname(parameters):</code> 。</li><li>形参：parameter 实参：argument。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、定义简单函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet_user</span>(): <span class="comment"># 括号必不可少！！别忘了冒号！！</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot;</span> <span class="comment"># 这个就是文档字符串，3个单引号或双引号，也要缩进4格</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">greet_user() <span class="comment"># 函数的调用，也别忘了这个括号！</span></span><br><span class="line"><span class="built_in">print</span>(greet_user.__doc__) <span class="comment"># 文档字符串(docstrings)的调用</span></span><br><span class="line"><span class="comment"># 2、向函数传递信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet_user</span>(<span class="params">username</span>): <span class="comment"># 这里添加username ，就可让函数接受你给username指定的任何值</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;username.title()&#125;</span>!&quot;</span>)</span><br><span class="line">greet_user(<span class="string">&#x27;jesse&#x27;</span>) <span class="comment"># 调用函数时，可将一个名字传递给它</span></span><br><span class="line"><span class="comment"># 3、在上面案例的函数greet_user()的定义中，变量username是一个形参</span></span><br><span class="line"><span class="comment"># 在代码greet_user(&#x27;jesse&#x27;)中，值&#x27;jesse&#x27;是一个实参 。实参是调用函数时传递给函数的信息。</span></span><br><span class="line"><span class="comment"># 我们调用函数时，将要让函数使用的信息放在括号内。在greet_user(&#x27;jesse&#x27;)中，将实参&#x27;jesse&#x27;传递给了函数greet_user()，这个值被存储在形参username中。</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">Hello!</span><br><span class="line">显示简单的问候语</span><br><span class="line"># 2.</span><br><span class="line">Hello, Jesse!</span><br></pre></td></tr></table></figure><h2 id="二、传递实参"><a href="#二、传递实参" class="headerlink" title="二、传递实参"></a>二、传递实参</h2><ol><li>位置实参positional arguments 每个实参都关联到函数定义中的一个形参，最简单的关联方式是基于实参的顺序，即位置实参。</li><li>关键字实参keyword arguments 指传递给函数的名称值对，关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。</li><li>默认值 可给每个形参指定默认值。在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、位置实参</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">describe_pet</span>(<span class="params">animal_type, pet_name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nI have a <span class="subst">&#123;animal_type&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;My <span class="subst">&#123;animal_type&#125;</span>&#x27;s name is <span class="subst">&#123;pet_name.title()&#125;</span>.&quot;</span>)</span><br><span class="line">describe_pet(<span class="string">&#x27;hamster&#x27;</span>, <span class="string">&#x27;harry&#x27;</span>)</span><br><span class="line"><span class="comment"># 2、关键字实参</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">describe_pet</span>(<span class="params">animal_type, pet_name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nI have a <span class="subst">&#123;animal_type&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;My <span class="subst">&#123;animal_type&#125;</span>&#x27;s name is <span class="subst">&#123;pet_name.title()&#125;</span>.&quot;</span>)</span><br><span class="line">describe_pet(animal_type=<span class="string">&#x27;hamster&#x27;</span>, pet_name=<span class="string">&#x27;harry&#x27;</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;harry&#x27;</span>, animal_type=<span class="string">&#x27;hamster&#x27;</span>)</span><br><span class="line"><span class="comment"># 3、默认值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">describe_pet</span>(<span class="params">pet_name, animal_type=<span class="string">&#x27;dog&#x27;</span></span>):  <span class="comment"># ★注意：使用默认值时，必须先没有默认值的形参，再有默认值的形参。</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nI have a <span class="subst">&#123;animal_type&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;My <span class="subst">&#123;animal_type&#125;</span>&#x27;s name is <span class="subst">&#123;pet_name.title()&#125;</span>.&quot;</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;willie&#x27;</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;harry&#x27;</span>, animal_type=<span class="string">&#x27;hamster&#x27;</span>)</span><br><span class="line"><span class="comment"># 4、等效的函数调用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">describe_pet</span>(<span class="params">pet_name, animal_type=<span class="string">&#x27;dog&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">describe_pet(<span class="string">&#x27;willie&#x27;</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;willie&#x27;</span>)</span><br><span class="line">describe_pet(<span class="string">&#x27;harry&#x27;</span>, <span class="string">&#x27;hamster&#x27;</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;harry&#x27;</span>, animal_type=<span class="string">&#x27;hamster&#x27;</span>)</span><br><span class="line">describe_pet(animal_type=<span class="string">&#x27;hamster&#x27;</span>, pet_name=<span class="string">&#x27;harry&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">I have a hamster.</span><br><span class="line">My hamster&#x27;s name is Harry.</span><br><span class="line"># 2.</span><br><span class="line">I have a hamster.</span><br><span class="line">My hamster&#x27;s name is Harry.</span><br><span class="line"></span><br><span class="line">I have a hamster.</span><br><span class="line">My hamster&#x27;s name is Harry.</span><br><span class="line"># 3.</span><br><span class="line">I have a dog.</span><br><span class="line">My dog&#x27;s name is Willie.</span><br><span class="line"></span><br><span class="line">I have a hamster.</span><br><span class="line">My hamster&#x27;s name is Harry.</span><br><span class="line"># 4.</span><br><span class="line">I have a dog.</span><br><span class="line">My dog&#x27;s name is Willie.</span><br><span class="line"></span><br><span class="line">I have a dog.</span><br><span class="line">My dog&#x27;s name is Willie.</span><br><span class="line"></span><br><span class="line">I have a hamster.</span><br><span class="line">My hamster&#x27;s name is Harry.</span><br><span class="line"></span><br><span class="line">I have a hamster.</span><br><span class="line">My hamster&#x27;s name is Harry.</span><br><span class="line"></span><br><span class="line">I have a hamster.</span><br><span class="line">My hamster&#x27;s name is Harry.</span><br></pre></td></tr></table></figure><h2 id="三、定义的函数的返回值"><a href="#三、定义的函数的返回值" class="headerlink" title="三、定义的函数的返回值"></a>三、定义的函数的返回值</h2><ul><li><code>return</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、返回值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_formatted_name</span>(<span class="params">first_name, last_name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回整洁的姓名&quot;&quot;&quot;</span></span><br><span class="line">    full_name = <span class="string">f&quot;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(musician)</span><br><span class="line"><span class="comment"># 2、让实参变成可选的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_formatted_name</span>(<span class="params">first_name, last_name, middle_name=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回整洁的姓名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> middle_name:</span><br><span class="line">        full_name = <span class="string">f&quot;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;middle_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        full_name = <span class="string">f&quot;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(musician)</span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;hooker&#x27;</span>, <span class="string">&#x27;lee&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(musician)</span><br><span class="line"><span class="comment"># 3、返回字典</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_person</span>(<span class="params">first_name, last_name, age = <span class="literal">None</span></span>):  <span class="comment"># 这里age = None也可以是上面的 age = &quot;&quot;，也可以是age = False</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回一个字典，其中包含有关一个人的信息&quot;&quot;&quot;</span></span><br><span class="line">    person = &#123;<span class="string">&#x27;first&#x27;</span>: first_name, <span class="string">&#x27;last&#x27;</span>: last_name&#125;</span><br><span class="line">    <span class="keyword">if</span> age:</span><br><span class="line">        person[<span class="string">&#x27;age&#x27;</span>] = age</span><br><span class="line">    <span class="keyword">return</span> person</span><br><span class="line">musician = build_person(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>, age=<span class="number">27</span>)</span><br><span class="line"><span class="built_in">print</span>(musician)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">Jimi Hendrix</span><br><span class="line"># 2.</span><br><span class="line">Jimi Hendrix</span><br><span class="line">John Lee Hooker</span><br><span class="line">&#123;&#x27;first&#x27;: &#x27;jimi&#x27;, &#x27;last&#x27;: &#x27;hendrix&#x27;, &#x27;age&#x27;: 27&#125;</span><br></pre></td></tr></table></figure><h2 id="四、向函数传递列表"><a href="#四、向函数传递列表" class="headerlink" title="四、向函数传递列表"></a>四、向函数传递列表</h2><ol><li>给函数传递列表，向函数传递列表很有用，这种列表包含的可能是名字、数字或更复杂的对象（如字典）。</li><li>在函数中修改列表，在函数中对这个列表所做的任何修改都是永久性的，这让你能够高效地处理大量的数据。</li><li>切片表示法[:] <code>function_name(list_name[:])</code> 创建列表的副本，向函数传递列表的副本而不是原件。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、传递列表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet_users</span>(<span class="params">names</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        msg = <span class="string">f&quot;Hello, <span class="subst">&#123;name.title()&#125;</span>!&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">usernames = [<span class="string">&#x27;hannah&#x27;</span>, <span class="string">&#x27;ty&#x27;</span>, <span class="string">&#x27;margot&#x27;</span>]</span><br><span class="line">greet_users(usernames)</span><br><span class="line"><span class="comment"># 2、修改列表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_models</span>(<span class="params">unprinted_designs, completed_models</span>):  <span class="comment"># 这个函数跟7-3第一个知识点是一样的</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    模拟打印每个设计，直到没有未打印的设计为止</span></span><br><span class="line"><span class="string">    打印每个设计后，都将其移到列表completed_models中</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> unprinted_designs:</span><br><span class="line">        current_design = unprinted_designs.pop()</span><br><span class="line">        <span class="comment"># 模拟根据设计制作3D打印模型的过程</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Printing model: <span class="subst">&#123;current_design&#125;</span>&quot;</span>)</span><br><span class="line">        completed_models.append(current_design)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_completed_models</span>(<span class="params">completed_models</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示打印好的所有模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nThe following models have been printed:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> completed_model <span class="keyword">in</span> completed_models:</span><br><span class="line">        <span class="built_in">print</span>(completed_model)</span><br><span class="line"></span><br><span class="line">unprinted_designs = [<span class="string">&#x27;iphone case&#x27;</span>, <span class="string">&#x27;robot pendant&#x27;</span>, <span class="string">&#x27;dodecahedron&#x27;</span>]</span><br><span class="line">completed_models = []</span><br><span class="line">print_models(unprinted_designs, completed_models)</span><br><span class="line">show_completed_models(completed_models)</span><br><span class="line"><span class="comment"># 3、切片表示法创建列表的副本</span></span><br><span class="line">print_models(unprinted_designs[:], completed_models) <span class="comment"># 像下面这样调用print_models(), 但它使用的是列表unprinted_designs 的副本，而不是列表unprinted_designs本身。</span></span><br><span class="line"><span class="comment"># 说明：虽然向函数传递列表的副本可保留原始列表的内容，但除非有充分的理由需要传递副本，否则还是应该将原始列表传递给函数。</span></span><br><span class="line"><span class="comment"># 因为让函数使用现成列表可避免花时间和内存创建副本，从而提高效率，在处理大型列表时尤其如此。</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">Hello, Hannah!</span><br><span class="line">Hello, Ty!</span><br><span class="line">Hello, Margot!</span><br><span class="line"># 2.</span><br><span class="line">Printing model: dodecahedron</span><br><span class="line">Printing model: robot pendant</span><br><span class="line">Printing model: iphone case</span><br><span class="line"></span><br><span class="line">The following models have been printed:</span><br><span class="line">dodecahedron</span><br><span class="line">robot pendant</span><br><span class="line">iphone case</span><br></pre></td></tr></table></figure><h2 id="五、传递任意数量实参"><a href="#五、传递任意数量实参" class="headerlink" title="五、传递任意数量实参"></a>五、传递任意数量实参</h2><ol><li>形参名<code>*parameter</code>中的星号让python创建一个名为parameter的☆空元组tuple，并将收到的所有值都封装到这个元组里（即便函数只收到了一个值）。</li><li>通用形参名*args (arguments的缩写)，收集任意数量的位置实参。</li><li>形参<code>**parameter</code>中的两个星号让Python创建一个名为parameter的空字典dict，并将收到的所有名称值对都封装到这个字典中。</li><li>通用形参名**kwargs (keyword arguments的缩写)，收集任意数量的关键字实参。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、任意数量实参*parameter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_pizza</span>(<span class="params">*toppings</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印顾客点的所有配料&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(toppings)</span><br><span class="line">make_pizza(<span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br><span class="line"><span class="comment"># 2、结合使用位置实参和任意数量实参</span></span><br><span class="line"><span class="comment"># ★说明：如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_pizza</span>(<span class="params">size, *toppings</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nMaking a <span class="subst">&#123;<span class="built_in">str</span>(size)&#125;</span>-inch pizza with the following toppings:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;- &quot;</span> + topping)</span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br><span class="line"><span class="comment"># 3、使用任意数量的关键字实参</span></span><br><span class="line"><span class="comment"># 说明：可将函数编写成能够接受任意数量的键值对</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_profile</span>(<span class="params">first, last, **user_info</span>):</span><br><span class="line">    user_info[<span class="string">&#x27;first_name&#x27;</span>] = first</span><br><span class="line">    user_info[<span class="string">&#x27;last_name&#x27;</span>] = last</span><br><span class="line">    <span class="keyword">return</span> user_info</span><br><span class="line">user_profile = build_profile(<span class="string">&#x27;albert&#x27;</span>, <span class="string">&#x27;einstein&#x27;</span>, location = <span class="string">&#x27;princeton&#x27;</span>, field = <span class="string">&#x27;physics&#x27;</span>) <span class="comment"># 注意location和field上面不要引号，用赋值给函数键值对</span></span><br><span class="line"><span class="built_in">print</span>(user_profile)</span><br><span class="line"><span class="comment"># 打印出来顺序是这样的&#123;&#x27;location&#x27;: &#x27;princeton&#x27;, &#x27;field&#x27;: &#x27;physics&#x27;, &#x27;first_name&#x27;: &#x27;albert&#x27;, &#x27;last_name&#x27;: &#x27;einstein&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 我的理解是自定义函数先接收了2个参数，2个键值对，先把键值对放入了字典，然后下面2个语句将参数变成了键值对，最后返回字典</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">(&#x27;pepperoni&#x27;,)</span><br><span class="line">(&#x27;mushrooms&#x27;, &#x27;green peppers&#x27;, &#x27;extra cheese&#x27;)</span><br><span class="line"># 2.</span><br><span class="line">Making a 16-inch pizza with the following toppings:</span><br><span class="line">- pepperoni</span><br><span class="line"></span><br><span class="line">Making a 12-inch pizza with the following toppings:</span><br><span class="line">- mushrooms</span><br><span class="line">- green peppers</span><br><span class="line">- extra cheese</span><br><span class="line"># 3.</span><br><span class="line">&#123;&#x27;location&#x27;: &#x27;princeton&#x27;, &#x27;field&#x27;: &#x27;physics&#x27;, &#x27;first_name&#x27;: &#x27;albert&#x27;, &#x27;last_name&#x27;: &#x27;einstein&#x27;&#125;</span><br></pre></td></tr></table></figure><h2 id="六、把函数储存在模块里"><a href="#六、把函数储存在模块里" class="headerlink" title="六、把函数储存在模块里"></a>六、把函数储存在模块里</h2><ol><li>import语句 将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。import语句允许在当前运行的程序文件中使用模块中的代码。</li><li><code>module_name.function_name()</code> 用这种import语句导入了名为module_name.py的整个模块，就可使用该语法来使用其中任何一个函数。</li><li><code>from module_name import function_name</code> 导入模块中的特定函数 注意：导入没有小括号，使用才要小括号。</li><li><code>from module_name import function_0, function_1, function_2</code> 通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数。</li><li><code>from module_name import function_name as fn</code> 用as将函数重命名。</li><li><code>import module_name as mn</code> 用as给模块重命名。</li><li><code>from module_name import *</code> 使用星号（*）运算符让Python导入模块中的所有函数。</li></ol><p>以下为pizza.py模块内的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pizza.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_pizza</span>(<span class="params">size, *toppings</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nMaking a <span class="subst">&#123;<span class="built_in">str</span>(size)&#125;</span>-inch pizza with the following toppings:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;- <span class="subst">&#123;topping&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>以下为示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、导入整个模块</span></span><br><span class="line"><span class="keyword">import</span> pizza</span><br><span class="line">pizza.make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">pizza.make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br><span class="line"><span class="comment"># 2、导入特定的函数</span></span><br><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza</span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>) <span class="comment"># 与上面的区别就是不用在函数之前写module_name.了</span></span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>) </span><br><span class="line"><span class="comment"># ★ 若使用这种语法，调用函数时就无需使用句点。由于我们在import语句中显式地导入了函数make_pizza()，因此调用它时只需指定其名称。</span></span><br><span class="line"><span class="comment"># 理解：因为1里面导入的是模块，所以要模块.函数()，但2直接导入了函数，所以直接使用函数，下面的3、4可以证明这点</span></span><br><span class="line"><span class="comment"># 3、使用as给函数指定别名</span></span><br><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza <span class="keyword">as</span> mp</span><br><span class="line">mp(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">mp(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br><span class="line"><span class="comment"># 4、使用as给模块指定别名</span></span><br><span class="line"><span class="keyword">import</span> pizza <span class="keyword">as</span> p</span><br><span class="line">p.make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">p.make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br><span class="line"><span class="comment"># 5、导入模块中的所有函数</span></span><br><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> * <span class="comment"># import 语句中的星号让Python将模块pizza中的每个函数都复制到这个程序文件中。</span></span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">Making a 16-inch pizza with the following toppings:</span><br><span class="line">- pepperoni</span><br><span class="line"></span><br><span class="line">Making a 12-inch pizza with the following toppings:</span><br><span class="line">- mushrooms</span><br><span class="line">- green peppers</span><br><span class="line">- extra cheese</span><br><span class="line"># 2.</span><br><span class="line">Making a 16-inch pizza with the following toppings:</span><br><span class="line">- pepperoni</span><br><span class="line"></span><br><span class="line">Making a 12-inch pizza with the following toppings:</span><br><span class="line">- mushrooms</span><br><span class="line">- green peppers</span><br><span class="line">- extra cheese</span><br><span class="line"># 3.</span><br><span class="line">Making a 16-inch pizza with the following toppings:</span><br><span class="line">- pepperoni</span><br><span class="line"></span><br><span class="line">Making a 12-inch pizza with the following toppings:</span><br><span class="line">- mushrooms</span><br><span class="line">- green peppers</span><br><span class="line">- extra cheese</span><br><span class="line"># 4.</span><br><span class="line">Making a 16-inch pizza with the following toppings:</span><br><span class="line">- pepperoni</span><br><span class="line"></span><br><span class="line">Making a 12-inch pizza with the following toppings:</span><br><span class="line">- mushrooms</span><br><span class="line">- green peppers</span><br><span class="line">- extra cheese</span><br><span class="line"># 5.</span><br><span class="line">Making a 16-inch pizza with the following toppings:</span><br><span class="line">- pepperoni</span><br><span class="line"></span><br><span class="line">Making a 12-inch pizza with the following toppings:</span><br><span class="line">- mushrooms</span><br><span class="line">- green peppers</span><br><span class="line">- extra cheese</span><br></pre></td></tr></table></figure><h1 id="第-9-章-类"><a href="#第-9-章-类" class="headerlink" title="第 9 章　类"></a>第 9 章　类</h1><h2 id="一、创建和使用类"><a href="#一、创建和使用类" class="headerlink" title="一、创建和使用类"></a>一、创建和使用类</h2><ol><li>面向对象编程是最有效的软件编写方法之一。基于类创建对象时，每个对象都具备通用行为，然后可根据需要赋予每个对象独特的个性。<ul><li>根据类来创建对象被称为<strong>实例化</strong>，这让你能够使用类的实例。</li><li>在本章中，你将编写一些类并创建其实例。你将指定可在实例中存储什么信息，定义可对这些实例执行哪些操作。</li><li>你还将编写一些类来扩展既有类的功能，让相似的类能够高效地共享代码。你将把自己编写的类存储在模块中，并在自己的程序文件中导入其他程序员编写的类。</li></ul></li><li>创建类 <code>class ClassName</code>: 注意：类的名称首字母要大写。</li><li>构造方法<code>__init__()</code> 该方法在类实例化时会自动调用。</li><li>根据类创建实例instance 类是一系列说明，让Python知道如何创建表示特定类的实例。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建和使用类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="comment"># 注意大写和冒号</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>): <span class="comment"># self可以理解为传递实例给类</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化属性name和age&quot;&quot;&quot;</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sit</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗被命令时蹲下&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is now sitting.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">roll_over</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗被命令时打滚&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> rolled over!&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>方法<strong>init</strong>() 称为构造方法<ul><li>类中的函数称为方法，方法<strong>init</strong>() 是一个特殊的方法，每当你根据Dog类创建新实例时，Python都会自动运行它。开头和末尾各有两个下划线。</li><li>我们将方法<strong>init</strong>()定义成了包含三个形参：self 、name 和age 。在这个方法的定义中，形参self必不可少，还必须位于其他形参的前面。</li><li>python调用这个<strong>init</strong>()方法来创建Dog实例时，将自动传入实参self。每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。</li><li>我们创建Dog实例时，Python将调用Dog类的方法<strong>init</strong>()。我们将通过实参向Dog()传递名字和年龄；self会自动传递，因此我们不需要传递它。</li><li><code>self.name = name</code> 以self为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。</li><li><code>self.name = name</code> 获取存储在形参name中的值，并将其存储到变量name中，然后该变量被关联到当前创建的实例。</li><li>像这样可通过实例访问的变量称为属性。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据类创建实例</span></span><br><span class="line">my_dog = Dog(<span class="string">&#x27;willie&#x27;</span>, <span class="number">6</span>) </span><br><span class="line"><span class="comment"># Python使用实参&#x27;willie&#x27;和6调用Dog类中的方法__init__()。方法__init__()创建一个表示特定小狗的示例，并使用我们提供的值来设置属性name和age。</span></span><br><span class="line"><span class="comment"># 方法__init__()并未显式地包含return语句，但Python自动返回一个表示这条小狗的实例。我们将这个实例存储在变量my_dog中</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My dog&#x27;s name is <span class="subst">&#123;my_dog.name&#125;</span>.&quot;</span>) </span><br><span class="line"><span class="comment"># my_dog.name访问实例的属性，Python先找到实例my_dog，再查找与这个实例相关联的属性name。</span></span><br><span class="line"><span class="comment"># 在Dog类中引用这个属性时，使用的是self.name</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My dog is <span class="subst">&#123;my_dog.age&#125;</span> years old.&quot;</span>)</span><br><span class="line">my_dog.sit() <span class="comment"># 调用方法 句点表示法来调用Dog类中定义的任何方法，别忘了括号</span></span><br><span class="line">my_dog.roll_over() <span class="comment"># 要调用方法，可指定实例的名称（这里是my_dog）和要调用的方法，并用句点分隔它们。</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">My dog&#x27;s name is willie.</span><br><span class="line">My dog is 6 years old.</span><br><span class="line">willie is now sitting.</span><br><span class="line">willie rolled over!</span><br></pre></td></tr></table></figure><ul><li>你可按需求根据一个类创建任意数量的实例，条件是将每个实例都存储在不同的变量中，或占用列表或字典的不同位置。</li></ul><h2 id="二、使用类和实例"><a href="#二、使用类和实例" class="headerlink" title="二、使用类和实例"></a>二、使用类和实例</h2><ol><li>给属性指定默认值，在方法<code>__init__()</code>内指定设置默认值，如果你对某个属性这样做了，就无需包含为它提供初始值的形参。</li><li>以三种不同的方式修改属性的值：直接通过实例进行修改；通过方法进行设置；通过方法进行递增（增加特定的值）。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、给属性指定默认值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_descriptive_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="string">f&quot;<span class="subst">&#123;self.year&#125;</span> <span class="subst">&#123;self.make&#125;</span> <span class="subst">&#123;self.model&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_odometer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;This car has <span class="subst">&#123;self.odometer_reading&#125;</span> miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2（1）、直接修改属性的值</span></span><br><span class="line">my_new_car.odometer_reading = <span class="number">23</span> <span class="comment"># 通过实例直接访问它</span></span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2（2）、通过方法修改属性的值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_odometer</span>(<span class="params">self, mileage</span>): <span class="comment"># 添加了方法，这个方法接受一个里程值，并将其存储到self.odometer_reading中</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数设置为指定的值&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading = mileage</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_odometer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;This car has <span class="subst">&#123;self.odometer_reading&#125;</span> miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line">my_new_car.update_odometer(<span class="number">23</span>)</span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2（3）通过方法对属性的值进行递增</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_odometer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条指出汽车里程的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;This car has <span class="subst">&#123;self.odometer_reading&#125;</span> miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_odometer</span>(<span class="params">self, mileage</span>): </span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数设置为指定的值&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading = mileage</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment_odometer</span>(<span class="params">self, miles</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数增加指定的量&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line">my_used_car = Car(<span class="string">&#x27;subaru&#x27;</span>, <span class="string">&#x27;outback&#x27;</span>, <span class="number">2013</span>)</span><br><span class="line">my_used_car.update_odometer(<span class="number">23_500</span>) <span class="comment"># _的作用见2-6</span></span><br><span class="line">my_used_car.read_odometer()</span><br><span class="line">my_used_car.increment_odometer(<span class="number">100</span>)</span><br><span class="line">my_used_car.read_odometer()</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">2016 Audi A4</span><br><span class="line">This car has 0 miles on it.</span><br><span class="line"># 2.(1).</span><br><span class="line">This car has 23 miles on it.</span><br><span class="line"># 2.(2).</span><br><span class="line">This car has 23 miles on it.</span><br><span class="line"># 2.(3).</span><br><span class="line">This car has 23500 miles on it.</span><br><span class="line">This car has 23600 miles on it.</span><br></pre></td></tr></table></figure><h2 id="三、继承类"><a href="#三、继承类" class="headerlink" title="三、继承类"></a>三、继承类</h2><ol><li>一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类，而新类称为子类。</li><li>子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。</li><li>用<code>super()</code>函数调用父类。父类也称为超类 （superclass），名称super因此而得名。</li><li>给子类添加任意数量的属性和方法。</li><li>重写父类的方法 在子类中定义一个与父类同名的方法，对其进行重写。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、super()函数调用父类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_descriptive_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="string">f&quot;<span class="subst">&#123;self.year&#125;</span> <span class="subst">&#123;self.make&#125;</span> <span class="subst">&#123;self.model&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span>(<span class="title class_ inherited__">Car</span>): <span class="comment"># 定义子类时，必须在括号内指定父类的名称。</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)  <span class="comment"># 注意：★super函数后面的没有self</span></span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2019</span>) <span class="comment"># 这行代码调用ElectricCar类中定义的方法__init__()，后者让Python调用父类Car中定义的方法__init__()。</span></span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、给子类定义属性和方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_descriptive_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="string">f&quot;<span class="subst">&#123;self.year&#125;</span> <span class="subst">&#123;self.make&#125;</span> <span class="subst">&#123;self.model&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span>(<span class="title class_ inherited__">Car</span>): <span class="comment"># ★定义子类时，必须在括号内指定父类的名称。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        电动汽车的独特之处</span></span><br><span class="line"><span class="string">        初始化父类的属性，再初始化电动汽车特有的属性</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line">        self.battery_size = <span class="number">75</span> <span class="comment"># 子类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">describe_battery</span>(<span class="params">self</span>): <span class="comment"># 子类方法</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;This car has a <span class="subst">&#123;self.battery_size&#125;</span>-kWh battery.&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2019</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.describe_battery()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、重写父类的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_descriptive_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="string">f&quot;<span class="subst">&#123;self.year&#125;</span> <span class="subst">&#123;self.make&#125;</span> <span class="subst">&#123;self.model&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span>(<span class="title class_ inherited__">Car</span>): </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_descriptive_name</span>(<span class="params">self</span>): <span class="comment"># 重写父类的方法</span></span><br><span class="line">        long_name = <span class="string">f&quot;model: <span class="subst">&#123;self.year&#125;</span> <span class="subst">&#123;self.make&#125;</span> <span class="subst">&#123;self.model&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2019</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">2019 Tesla Model S</span><br><span class="line"># 2.</span><br><span class="line">2019 Tesla Model S</span><br><span class="line">This car has a 75-kWh battery.</span><br><span class="line"># 3.</span><br><span class="line">Model: 2019 Tesla Model S</span><br></pre></td></tr></table></figure><h2 id="四、将实例用作属性"><a href="#四、将实例用作属性" class="headerlink" title="四、将实例用作属性"></a>四、将实例用作属性</h2><ul><li>给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。你可以将大型类拆分成多个协同工作的小类。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将实例用作属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_descriptive_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性信息&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="string">f&quot;<span class="subst">&#123;self.year&#125;</span> <span class="subst">&#123;self.make&#125;</span> <span class="subst">&#123;self.model&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Battery</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟电动汽车电瓶的简单尝试&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, battery_size=<span class="number">75</span></span>): <span class="comment"># 如果没有给它提供值，电瓶容量将被设置为75。</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化电瓶的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.battery_size = battery_size</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">describe_battery</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;This car has a <span class="subst">&#123;self.battery_size&#125;</span>-kWh battery.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化父类的属性，再初始化电动汽车特有的属性</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line">        self.battery = Battery()  <span class="comment"># ★这里就是将实例用作属性，这行代码让Python创建一个新的Battery实例（默认值75），并将该实例存储在属性self.battery中</span></span><br><span class="line"><span class="comment"># 每当方法__init__()被调用时，都将执行该操作；因此现在每个ElectricCar实例都包含一个自动创建的Battery实例。</span></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.battery.describe_battery() <span class="comment"># ★这行代码让Python在实例my_tesla中查找属性battery，并对存储在该属性中的Battery实例调用方法describe_battery()。</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016 Tesla Model S</span><br><span class="line">This car has a 75-kWh battery.</span><br></pre></td></tr></table></figure><h2 id="五、导入类"><a href="#五、导入类" class="headerlink" title="五、导入类"></a>五、导入类</h2><ol><li>导入一个类 <code>from module_name import Class_name</code> 。</li><li>导入多个类 <code>from module_name import Class_name0, Class_name1</code> 。</li><li>导入整个模块 <code>import module_name</code> 。</li><li>导入模块中的所有类 <code>from module_name import *</code> 。</li><li>在一个模块中导入另一个模块 注意：若只使用子模块，无需导入母模块。</li><li>使用别名 <code>from module_name import Class_name as CN</code> 创建实例时，可以使用这个别名：<code>instance = CN(&quot;arugment0&quot;, &quot;argument1&quot;)</code> 。</li></ol><p>以下是car.py的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># car.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;一个可用于表示汽车的类&quot;&quot;&quot;</span> <span class="comment"># 这是一个模块级文档字符串，对该模块的内容做了简要的描述。你应为自己创建的每个模块都编写文档字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化描述汽车的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_descriptive_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回整洁的描述性名称&quot;&quot;&quot;</span></span><br><span class="line">        long_name = <span class="string">f&quot;<span class="subst">&#123;self.year&#125;</span> <span class="subst">&#123;self.make&#125;</span> <span class="subst">&#123;self.model&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_odometer</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条消息，指出汽车的里程&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;This car has <span class="subst">&#123;self.odometer_reading&#125;</span> miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_odometer</span>(<span class="params">self, mileage</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将里程表读数设置为指定的值</span></span><br><span class="line"><span class="string">        拒绝将里程表往回拨</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t roll back an odometer!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment_odometer</span>(<span class="params">self, miles</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将里程表读数增加指定的量&quot;&quot;&quot;</span></span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Battery</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟电动汽车电瓶的简单尝试&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, battery_size = <span class="number">75</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化电瓶的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.battery_size = battery_size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">describe_battery</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;This car has a <span class="subst">&#123;self.battery_size&#125;</span>-kWh battery.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_range</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;打印一条描述电瓶续航里程的消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.battery_size == <span class="number">75</span>:</span><br><span class="line">            <span class="built_in">range</span> = <span class="number">260</span></span><br><span class="line">        <span class="keyword">elif</span> self.battery_size == <span class="number">100</span>:</span><br><span class="line">            <span class="built_in">range</span> = <span class="number">315</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;This car can go about <span class="subst">&#123;<span class="built_in">range</span>&#125;</span> miles on a full charge.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟电动汽车的独特之处&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化父类的属性，再初始化电动汽车特有的属性</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line">        self.battery = Battery()</span><br></pre></td></tr></table></figure><p>以下为本节示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、导入单个类</span></span><br><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line">my_new_car = Car(<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="number">2019</span>)</span><br><span class="line"><span class="built_in">print</span>(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.odometer_reading = <span class="number">23</span></span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line"><span class="comment"># 2、在一个模块中存储多个类，并导入子类</span></span><br><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> ElectricCar</span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2019</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.battery.describe_battery()</span><br><span class="line">my_tesla.battery.get_range()</span><br><span class="line"><span class="comment"># 3、从一个模块中导入多个类</span></span><br><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car, ElectricCar</span><br><span class="line">my_beetle = Car(<span class="string">&#x27;volkswagen&#x27;</span>, <span class="string">&#x27;beetle&#x27;</span>, <span class="number">2019</span>)</span><br><span class="line"><span class="built_in">print</span>(my_beetle.get_descriptive_name())</span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;roadster&#x27;</span>, <span class="number">2019</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line"><span class="comment"># 4、导入整个模块</span></span><br><span class="line"><span class="keyword">import</span> car</span><br><span class="line">my_beetle = car.Car(<span class="string">&#x27;volkswagen&#x27;</span>, <span class="string">&#x27;beetle&#x27;</span>, <span class="number">2019</span>) <span class="comment"># 因为导入了整个模块，所以要使用句点表示法访问需要的类</span></span><br><span class="line"><span class="built_in">print</span>(my_beetle.get_descriptive_name())</span><br><span class="line">my_tesla = car.ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;roadster&#x27;</span>, <span class="number">2019</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line"><span class="comment"># 5、导入模块中的所有类</span></span><br><span class="line"><span class="comment"># 不推荐使用</span></span><br><span class="line"><span class="comment"># 6、在一个模块中导入另一个模块</span></span><br><span class="line"><span class="comment"># 可以将类存储在多个模块中时，一个模块中的类依赖于另一个模块中的类。在这种情况下，可在前一个模块中导入必要的类。</span></span><br><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line"><span class="keyword">from</span> electric_car <span class="keyword">import</span> ElectricCar </span><br><span class="line">my_beetle = Car(<span class="string">&#x27;volkswagen&#x27;</span>, <span class="string">&#x27;beetle&#x27;</span>, <span class="number">2019</span>)</span><br><span class="line"><span class="built_in">print</span>(my_beetle.get_descriptive_name())</span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;roadster&#x27;</span>, <span class="number">2019</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">2019 Audi A4</span><br><span class="line">This car has 23 miles on it.</span><br><span class="line"># 2.</span><br><span class="line">2019 Tesla Model S</span><br><span class="line">This car has a 75-kWh battery.</span><br><span class="line">This car can go about 260 miles on a full charge.</span><br><span class="line"># 3.</span><br><span class="line">2019 Volkswagen Beetle</span><br><span class="line">2019 Tesla Roadster</span><br><span class="line"># 4.</span><br><span class="line">2019 Volkswagen Beetle</span><br><span class="line">2019 Tesla Roadster</span><br><span class="line"># 6.</span><br><span class="line">2019 Volkswagen Beetle</span><br><span class="line">2019 Tesla Roadster</span><br></pre></td></tr></table></figure><h2 id="六、Python标准库"><a href="#六、Python标准库" class="headerlink" title="六、Python标准库"></a>六、Python标准库</h2><ul><li>Python标准库是一组模块，安装的Python都包含它。可使用标准库中的任何函数和类，为此只需在程序开头包含一条简单的import语句。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、模块random的函数randint()。它将2个整数作为参数，并随机返回一个位于2个整数之间（含）的整数。</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="built_in">print</span>(randint(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># 2、模块random的函数choice()。它将一个列表或元组作为参数，并随机返回一个元素。</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line">first_up = choice(players)</span><br><span class="line"><span class="built_in">print</span>(first_up)</span><br></pre></td></tr></table></figure><h2 id="七、类编码风格"><a href="#七、类编码风格" class="headerlink" title="七、类编码风格"></a>七、类编码风格</h2><ol><li>类名应采用驼峰命名法 ，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。</li><li>对于每个类，都应紧跟在类定义后面包含一个文档字符串。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式约定。</li><li>每个模块也都应包含一个文档字符串，对其中的类可用于做什么进行描述。</li><li>可使用空行来组织代码，但不要滥用。在类中，可使用一个空行来分隔方法；而在模块中，可使用两个空行来分隔类。</li><li>需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的import语句，再添加一个空行，然后编写导入你自己编写的模块的import语句。</li></ol><h1 id="第-10-章-文件和异常"><a href="#第-10-章-文件和异常" class="headerlink" title="第 10 章　文件和异常"></a>第 10 章　文件和异常</h1><h2 id="一、从文件读取数据（一）"><a href="#一、从文件读取数据（一）" class="headerlink" title="一、从文件读取数据（一）"></a>一、从文件读取数据（一）</h2><ol><li>用关键字with、函数open()、方法read()读取整个文件 <code>with open(&#39;file_name.txt&#39;) as file_object:</code> 。</li><li>打开不在程序文件所属目录中的文件 要让Python打开不与程序文件位于同一个目录中的文件，需要提供文件路径，它让Python到系统的特定位置去查找。</li><li>绝对文件路径、相对文件路径。</li></ol><p>以下为pi_digits.txt的内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.1415926535</span><br><span class="line">  8979323846</span><br><span class="line">  2643383279</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取整个文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;pi_digits.txt&#x27;</span>) <span class="keyword">as</span> file_object: <span class="comment"># 别忘了冒号，并注意是open函数里面是字符串！！</span></span><br><span class="line">    contents = file_object.read() <span class="comment"># 别忘了方法read()</span></span><br><span class="line"><span class="built_in">print</span>(contents)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.1415926535</span><br><span class="line">  8979323846</span><br><span class="line">  2643383279</span><br></pre></td></tr></table></figure><ul><li>函数<code>open()</code>接受一个参数：要打开的文件的名称。Python在当前执行的文件所在的目录中查找指定的文件。</li><li>函数<code>open()</code>返回一个表示文件的对象。在这里，<code>open(&#39;pi_digits.txt&#39;)</code> 返回一个表示文件pi_digits.txt的对象；Python将这个对象存储在我们将在后面使用的变量中。</li><li>关键字<code>with</code>在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open()，但没有调用close()。<ul><li>你也可以调用open()和close()来打开和关闭文件，但这样做时，如果程序存在bug，导致close()语句未执行，文件将不会关闭。</li><li>这看似微不足道，但未妥善地关闭文件可能会导致数据丢失或受损。如果在程序中过早地调用close()，你会发现需要使用文件时它已关闭（无法访问），这会导致更多的错误。</li><li>并非在任何情况下都能轻松确定关闭文件的恰当时机，但通过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它，Python自会在合适的时候自动将其关闭。</li></ul></li><li>方法<code>read()</code> 读取这个文件的全部内容，并将其作为一个长长的字符串存储在变量contents中。</li></ul><h2 id="二、从文件读取数据（二）"><a href="#二、从文件读取数据（二）" class="headerlink" title="二、从文件读取数据（二）"></a>二、从文件读取数据（二）</h2><ol><li>逐行读取 使用for循环以每次一行的方式检查文件。</li><li>创建一个包含文件各行内容的列表 方法<code>readlines()</code>从文件中读取每一行，并将其存储在一个列表中 注意后面的s，别忘了加！！！！不加就读一行。</li><li>Python将所有文本都解读为字符串。如果读的是数，需要使用函数<code>int()</code>或函数<code>float()</code>。</li><li>打印到小数点后20位 用字符串切片 <code>str[:52]</code>。</li><li>检查某个字符串是否包含在文件里 用<code>if str_0 in str_1:</code> (str_1由读取文件而来，比如3中的pi_string）。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、逐行读取</span></span><br><span class="line">filename = <span class="string">&#x27;pi_digits.txt&#x27;</span> <span class="comment"># 别忘了是字符串</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file_object: <span class="comment"># 注意line只是变量名称，可以为任意变量名称</span></span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"><span class="comment"># 打印结果多了空白行，在这个文件中，每行的末尾都有一个看不见的换行符，而print语句也会加上一个换行符，因此每行末尾都有两个换行符：一个来自文件，另一个来自print语句。</span></span><br><span class="line"><span class="built_in">print</span>(file_object)</span><br><span class="line"><span class="comment"># 2、方法readlines()</span></span><br><span class="line"><span class="comment"># 使用关键字with时，open()返回的文件对象只在with代码块内可用。如果要在with代码块外访问文件的内容，可在with代码块内将文件的各行存储在一个列表中</span></span><br><span class="line">filename = <span class="string">&#x27;pi_digits.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="built_in">print</span>(line.rstrip())</span><br><span class="line"><span class="built_in">print</span>(lines)</span><br><span class="line"><span class="comment"># 3、使用文件的内容</span></span><br><span class="line">filename = <span class="string">&#x27;pi_digits.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line">pi_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    pi_string += line.rstrip()</span><br><span class="line"><span class="built_in">print</span>(pi_string)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(pi_string))</span><br><span class="line"><span class="comment"># 因为每行左边都有空格，可使用strip()</span></span><br><span class="line">pi_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    pi_string += line.strip()</span><br><span class="line"><span class="built_in">print</span>(pi_string)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(pi_string))</span><br><span class="line"><span class="comment"># 4、打印到小数点后20位</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;pi_string[:<span class="number">20</span>]&#125;</span>...&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">3.1415926535</span><br><span class="line"></span><br><span class="line">  8979323846</span><br><span class="line"></span><br><span class="line">  2643383279</span><br><span class="line">&lt;_io.TextIOWrapper name=&#x27;pi_digits.txt&#x27; mode=&#x27;r&#x27; encoding=&#x27;cp936&#x27;&gt;</span><br><span class="line"># 2.</span><br><span class="line">3.1415926535</span><br><span class="line">  8979323846</span><br><span class="line">  2643383279</span><br><span class="line">[&#x27;3.1415926535\n&#x27;, &#x27;  8979323846\n&#x27;, &#x27;  2643383279&#x27;]</span><br><span class="line"># 3.</span><br><span class="line">3.1415926535  8979323846  2643383279</span><br><span class="line">36</span><br><span class="line">3.141592653589793238462643383279</span><br><span class="line">32</span><br><span class="line"># 4.</span><br><span class="line">3.141592653589793238...</span><br></pre></td></tr></table></figure><h2 id="三、写入文件"><a href="#三、写入文件" class="headerlink" title="三、写入文件"></a>三、写入文件</h2><ol><li>方法<code>write()</code> 写入空文件。</li><li>Python只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数<code>str()</code> 将其转换为字符串格式。</li><li>函数<code>write()</code> 不会在你写入的文本末尾添加换行符，因此如果你写入多行时没有指定换行符，则不会换行。</li><li>如果你要给文件添加内容，而不是覆盖原有的内容，可以附加模式打开文件。</li><li>调用open()时提供了两个实参。第一个实参也是要打开的文件的名称；第二个实参（’w’）告诉Python，我们要以写入模式打开这个文件。<ul><li>打开文件时，可指定读取模式（’r’）、写入模式 （’w’）、附加模式 （’a’）或让你能够读取和写入文件的模式（’r+’）。如果你省略了模式实参，Python将以默认的只读模式打开文件。</li><li>如果你要写入的文件不存在，函数open()将自动创建它。然而，以写入（’w’）模式打开文件时千万要小心，因为如果指定的文件已经存在，Python将在返回文件对象前清空该文件。</li><li>方法<code>write()</code> 将一个字符串写入文件</li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、写入空文件</span></span><br><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I love programming.&quot;</span>)</span><br><span class="line"><span class="comment"># 2、写入多行</span></span><br><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I love programming.\n&quot;</span>)</span><br><span class="line">    file_object.write(<span class="string">&quot;I love creating new games.\n&quot;</span>)</span><br><span class="line"><span class="comment"># 3、附加到文件</span></span><br><span class="line"><span class="comment"># 以附加模式打开文件时，Python不会在返回文件对象前清空文件，而你写入到文件的行都将添加到文件末尾。如果指定的文件不存在，Python将为你创建一个空文件。</span></span><br><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I also love finding meaning in large datasets.\n&quot;</span>)</span><br><span class="line">    file_object.write(<span class="string">&quot;I love creating apps that can run in a browser.\n&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="四、异常"><a href="#四、异常" class="headerlink" title="四、异常"></a>四、异常</h2><ol><li>异常是使用<code>try-except</code>代码块处理的。</li><li><code>try-except-else</code>代码块。</li><li><code>ZeroDivisionError</code>异常、<code>FileNotFoundError</code>异常。</li><li>用pass语句，在程序发生异常时保持静默。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、使用try-except代码块处理ZeroDivisionError异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t divide by zero!&quot;</span>)</span><br><span class="line"><span class="comment"># 说明：如果try代码块中的代码运行起来没有问题，Python将跳过except代码块；如果try代码块中的代码导致了错误，Python将查找这样的except代码块，并运行其中的代码。</span></span><br><span class="line"><span class="comment"># 2、else代码块</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Give me two numbers, and I&#x27;ll divide them.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Enter &#x27;q&#x27; to quit.&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    first_number = <span class="built_in">input</span>(<span class="string">&quot;\nFirst number: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> first_number == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    second_number = <span class="built_in">input</span>(<span class="string">&quot;Second number: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> second_number == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        answer = <span class="built_in">int</span>(first_number) / <span class="built_in">int</span>(second_number)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t divide by 0!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(answer)  <span class="comment"># try代码块成功（try代码块中代码无异常）即执行else代码块。</span></span><br><span class="line"><span class="comment"># 3、处理FileNotFoundError异常</span></span><br><span class="line">filename = <span class="string">&#x27;alice.txt&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        contents = f.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    msg = <span class="string">f&quot;Sorry, the file <span class="subst">&#123;filename&#125;</span> does not exist.&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line"><span class="comment"># 4、发生异常时保持静默</span></span><br><span class="line">filename = <span class="string">&#x27;alice.txt&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        contents = f.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">You can&#x27;t divide by zero!</span><br><span class="line"># 3.</span><br><span class="line">Sorry, the file alice.txt does not exist.</span><br></pre></td></tr></table></figure><h2 id="五、用模块json存储数据和重构"><a href="#五、用模块json存储数据和重构" class="headerlink" title="五、用模块json存储数据和重构"></a>五、用模块json存储数据和重构</h2><ol><li>模块json让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。你还可以使用json在Python程序之间分享数据。<ul><li>更重要的是，JSON数据格式并非Python专用的，这让你能够将以JSON格式存储的数据与使用其他编程语言的人分享。</li><li>JSON（JavaScript Object Notation、JavaScript对象表示法）格式最初是为JavaScript开发的，但随后成了一种常见格式，被包括Python在内的众多语言采用。</li></ul></li><li>使用<code>json.dump()</code>和<code>json.load()</code>将数据存储，和将这些数据读取到内存中 dump：倾倒，转储，转存</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># json.dump()和json.load()</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">filename = <span class="string">&#x27;numbers.json&#x27;</span> <span class="comment"># 注意文件名一定要是字符串！！！</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(numbers, f) <span class="comment"># 函数json.dump()接受两个实参：要存储的数据以及可用于存储数据的文件对象。 注意第二个参数要是f而不是文件名！！！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">filename = <span class="string">&#x27;numbers.json&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    numbers = json.load(f)</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="comment"># 以上是一种在程序之间共享数据的简单方式。</span></span><br></pre></td></tr></table></figure><ol><li>重构 将代码划分为一系列完成具体工作的函数的过程。重构让代码更清晰、更易于理解、更容易扩展。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment">#如果以前存储了用户名，就加载它</span></span><br><span class="line"><span class="comment">#否则，就提示用户输入用户名并存储它</span></span><br><span class="line">filename = <span class="string">&#x27;username.json&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">        username = json.load(f)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&quot;What is your name? &quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(username, f)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;We&#x27;ll remember you when you come back, <span class="subst">&#123;username&#125;</span>!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Welcome back, <span class="subst">&#123;username&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure><p>将上述代码重构：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#（1）、将上面代码都放到一个名为greet_user()的函数中</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet_user</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;问候用户，并指出其名字&quot;&quot;&quot;</span></span><br><span class="line">    filename = <span class="string">&#x27;username.json&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">            username = json.load(f)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        username = <span class="built_in">input</span>(<span class="string">&quot;What is your name? &quot;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(username, f)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;We&#x27;ll remember you when you come back, <span class="subst">&#123;username&#125;</span>!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Welcome back, <span class="subst">&#123;username&#125;</span>!&quot;</span>)</span><br><span class="line">greet_user()</span><br><span class="line"><span class="comment"># 函数greet_user() 所做的不仅仅是问候用户，还在存储了用户名时获取它，而在没有存储用户名时提示用户输入一个。</span></span><br><span class="line"><span class="comment">#（2）、下面来重构greet_user() ，让它不执行这么多任务。</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_stored_username</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;如果存储了用户名，就获取它&quot;&quot;&quot;</span></span><br><span class="line">    filename = <span class="string">&#x27;username.json&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">            username = json.load(f)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet_user</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;问候用户，并指出其名字&quot;&quot;&quot;</span></span><br><span class="line">    username = get_stored_username()</span><br><span class="line">    <span class="keyword">if</span> username:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Welcome back, <span class="subst">&#123;username&#125;</span>!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        username = <span class="built_in">input</span>(<span class="string">&quot;What is your name? &quot;</span>)</span><br><span class="line">        filename = <span class="string">&#x27;username.json&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(username, f)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;We&#x27;ll remember you when you come back, <span class="subst">&#123;username&#125;</span>!&quot;</span>)</span><br><span class="line">greet_user()</span><br><span class="line"><span class="comment">#（3)、将greet_user()中的另一个代码块提取出来：将没有存储用户名时提示用户输入的代码放在一个独立的函数中：</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_stored_username</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;如果存储了用户名，就获取它&quot;&quot;&quot;</span></span><br><span class="line">    filename = <span class="string">&#x27;username.json&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">            username = json.load(f)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_new_username</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;提示用户输入用户名&quot;&quot;&quot;</span></span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&quot;What is your name? &quot;</span>)</span><br><span class="line">    filename = <span class="string">&#x27;username.json&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(username, f)</span><br><span class="line">    <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet_user</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;问候用户，并指出其名字&quot;&quot;&quot;</span></span><br><span class="line">    username = get_stored_username()</span><br><span class="line">    <span class="keyword">if</span> username:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Welcome back, <span class="subst">&#123;username&#125;</span>!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        username = get_new_username()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;We&#x27;ll remember you when you come back, <span class="subst">&#123;username&#125;</span>!&quot;</span>)</span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure><h1 id="第-11-章-测试代码"><a href="#第-11-章-测试代码" class="headerlink" title="第 11 章　测试代码"></a>第 11 章　测试代码</h1><h2 id="一、测试函数"><a href="#一、测试函数" class="headerlink" title="一、测试函数"></a>一、测试函数</h2><ol><li>Python标准库中的模块<code>unittest</code>提供了代码测试工具。<ul><li>单元测试 用于核实函数的某个方面没有问题。</li><li>测试用例 是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。</li><li>全覆盖式测试 用例包含一整套单元测试，涵盖了各种可能的函数使用方式。对于大型项目，要实现全覆盖可能很难。</li><li>通常，最初只要针对代码的重要行为编写测试即可，等项目被广泛使用时再考虑全覆盖。</li></ul></li><li>编写测试用例，可先导入模块unittest以及要测试的函数，再创建一个继承<code>unittest.TestCase</code>的类，并编写一系列方法对函数行为的不同方面进行测试。</li><li>运行测试用例时，每完成一个单元测试，Python都打印一个字符：测试通过时打印一个句点；测试引发错误时打印一个E；测试导致断言失败时打印一个F。</li></ol><ul><li><strong>示例1</strong> 被测试的函数代码(name_function.py)如下：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name_function.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_formatted_name</span>(<span class="params">first, last</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generate a neatly formatted full name.&quot;&quot;&quot;</span></span><br><span class="line">    full_name = <span class="string">f&quot;<span class="subst">&#123;first&#125;</span> <span class="subst">&#123;last&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可通过的测试</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NamesTestCase</span>(unittest.TestCase): <span class="comment"># NamesTestCase这个类可以随便命名，这个类必须继承unittest.TestCase类，注意大写</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试name_function.py&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_first_last_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;能够正确地处理像Janis Joplin这样的姓名吗？&quot;&quot;&quot;</span></span><br><span class="line">        formatted_name = get_formatted_name(<span class="string">&#x27;janis&#x27;</span>, <span class="string">&#x27;joplin&#x27;</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">&#x27;Janis Joplin&#x27;</span>) <span class="comment"># unittest类最有用的功能之一：一个★断言方法。</span></span><br><span class="line"><span class="comment"># 我们调用unittest的方法assertEqual()，并向它传递formatted_name和&#x27;Janis Joplin&#x27;。将formatted_name的值同字符串&#x27;Janis Joplin&#x27;进行比较</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><ul><li>__name__ == ‘__main__‘ 就表示在当前文件中，可以在if __name__ == ‘__main__‘:条件下写入测试代码，如此可以避免测试代码在模块被导入后执行。</li><li>Python 解释器执行代码时，有一些内建、隐含的变量，__name__就是其中之一，其意义是“模块名称”。</li><li>如果该模块是被引用，那么__name__的值会是此模块的名称；如果该模块是直接被执行，那么__name__的值是__main__。</li><li><p>简单来说就是，上面的代码如果被其他代码导入后，__name__ 就不等于 ‘__main__‘，if后面的就不执行。</p></li><li><p><strong>示例2</strong> 被测试的函数代码(name_function1.py)如下：</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name_function1.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_formatted_name</span>(<span class="params">first, middle, last</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generate a neatly formatted full name.&quot;&quot;&quot;</span></span><br><span class="line">    full_name = <span class="string">f&quot;<span class="subst">&#123;first&#125;</span> <span class="subst">&#123;middle&#125;</span> <span class="subst">&#123;last&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不能通过的测试</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> name_function_1 <span class="keyword">import</span> get_formatted_name</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NamesTestCase</span>(unittest.TestCase): </span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试name_function.py&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_first_last_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;能够正确地处理像Janis Joplin这样的姓名吗？&quot;&quot;&quot;</span></span><br><span class="line">        formatted_name = get_formatted_name(<span class="string">&#x27;janis&#x27;</span>, <span class="string">&#x27;joplin&#x27;</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">&#x27;Janis Joplin&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><ul><li><strong>示例3</strong> 被测试的函数代码(name_function2.py)如下：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_formatted_name</span>(<span class="params">first, last, middle=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generate a neatly formatted full name.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> middle:</span><br><span class="line">        full_name = <span class="string">f&quot;<span class="subst">&#123;first&#125;</span> <span class="subst">&#123;middle&#125;</span> <span class="subst">&#123;last&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        full_name = <span class="string">f&quot;<span class="subst">&#123;first&#125;</span> <span class="subst">&#123;last&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加新测试</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> name_function_2 <span class="keyword">import</span> get_formatted_name</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NamesTestCase</span>(unittest.TestCase): </span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试name_function.py&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_first_last_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;能够正确地处理像Janis Joplin这样的姓名吗？&quot;&quot;&quot;</span></span><br><span class="line">        formatted_name = get_formatted_name(<span class="string">&#x27;janis&#x27;</span>, <span class="string">&#x27;joplin&#x27;</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">&#x27;Janis Joplin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_first_last_middle_name</span>(<span class="params">self</span>): <span class="comment"># 添加第二个测试</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？&quot;&quot;&quot;</span></span><br><span class="line">        formatted_name = get_formatted_name(</span><br><span class="line">            <span class="string">&#x27;wolfgang&#x27;</span>, <span class="string">&#x27;mozart&#x27;</span>, <span class="string">&#x27;amadeus&#x27;</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">&#x27;Wolfgang Amadeus Mozart&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><h2 id="二、测试类"><a href="#二、测试类" class="headerlink" title="二、测试类"></a>二、测试类</h2><ol><li>Python在<code>unittest.TestCase</code>类中提供了很多断言方法。断言方法检查你认为应该满足的条件是否确实满足。</li><li>unittest Module中的断言方法：<ul><li><code>assertEqual(a, b)</code> 核实a == b；<code>assertNotEqual(a, b)</code> 核实a != b</li><li><code>assertTrue(x)</code> 核实x为True；<code>assertFalse(x)</code> 核实x为False；</li><li><code>assertIn(item , list)</code> 核实item在list中；<code>assertNotIn(item , list)</code> 核实item不在list中。</li></ul></li><li>unittest.TestCase类包含方法<code>setUp()</code> 创建一系列实例并设置它们的属性，再在测试方法中直接使用这些实例。</li></ol><p>以下是被测试的survey.py的代码以及相关示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># survey.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnonymousSurvey</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;收集匿名调查问卷的答案&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, question</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;存储一个问题，并为存储答案做准备&quot;&quot;&quot;</span></span><br><span class="line">        self.question = question</span><br><span class="line">        self.responses = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_question</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;显示调查问卷&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(self.question)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">store_response</span>(<span class="params">self, new_response</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;存储单份调查答卷&quot;&quot;&quot;</span></span><br><span class="line">        self.responses.append(new_response)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_results</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;显示收集到的所有答卷&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Survey results:&quot;</span>)      </span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;- <span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、测试AnonymousSurvey类</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestAnonmyousSurvey</span>(unittest.TestCase):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;针对AnonymousSurvey类的测试&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_store_single_response</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;</span></span><br><span class="line">        question = <span class="string">&quot;What language did you first learn to speak?&quot;</span></span><br><span class="line">        my_survey = AnonymousSurvey(question)</span><br><span class="line">        my_survey.store_response(<span class="string">&#x27;English&#x27;</span>)</span><br><span class="line">        self.assertIn(<span class="string">&#x27;English&#x27;</span>, my_survey.responses)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_store_three_responses</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot;</span></span><br><span class="line">        question = <span class="string">&quot;What language did you first learn to speak?&quot;</span></span><br><span class="line">        my_survey = AnonymousSurvey(question)</span><br><span class="line">        responses = [<span class="string">&#x27;English&#x27;</span>, <span class="string">&#x27;Spanish&#x27;</span>, <span class="string">&#x27;Mandarin&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">            my_survey.store_response(response)</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">            self.assertIn(response, my_survey.responses)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br><span class="line"><span class="comment"># 2、在上面的代码中，我们在每个测试方法中都创建了一个AnonymousSurvey实例，并在每个方法中都创建了答案。</span></span><br><span class="line"><span class="comment"># unittest.TestCase类包含方法setUp()，让我们只需创建这些对象一次，并在每个测试方法中使用它们。</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestAnonymousSurvey</span>(unittest.TestCase):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;针对AnonymousSurvey类的测试&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setUp</span>(<span class="params">self</span>):  <span class="comment"># 在setUp()方法中创建一系列实例并设置它们的属性，再在测试方法中直接使用这些实例。相比于在每个测试方法中都创建实例并设置其属性，这要容易得多。</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        创建一个调查对象和一组答案，供使用的测试方法使用</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        question = <span class="string">&quot;What language did you first learn to speak?&quot;</span></span><br><span class="line">        self.my_survey = AnonymousSurvey(question)</span><br><span class="line">        self.responses = [<span class="string">&#x27;English&#x27;</span>, <span class="string">&#x27;Spanish&#x27;</span>, <span class="string">&#x27;Mandarin&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_store_single_response</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;</span></span><br><span class="line">        self.my_survey.store_response(self.responses[<span class="number">0</span>])</span><br><span class="line">        self.assertIn(self.responses[<span class="number">0</span>], self.my_survey.responses)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_store_three_responses</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            self.my_survey.store_response(response)</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            self.assertIn(response, self.my_survey.responses)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python编程从入门到实践》读书笔记（一）</title>
      <link href="/2022/09/09/2022-09-09-Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/09/2022-09-09-Python%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该笔记为 <strong>《Python编程从入门到实践》</strong> 的读书笔记，由于是早期未搞熟博客系统时所写，笔记结构较为混乱；<br>该笔记涉及的内容较为基础，可能含有大量废话；<br>该书的内容不涉及对Python底层逻辑的理解，不利于巩固基础，<br>建议看完后粗略过一下 <strong>《Learning Python》</strong>（但不建议仔细阅读该书）；<br>学习完成日期为2021年12月13日。</p></blockquote><p><img src="https://s2.loli.net/2022/09/09/F45BwnLIjXxVCtT.png" alt="Python编程从入门到实践"></p><h1 id="第-1-章-起步"><a href="#第-1-章-起步" class="headerlink" title="第 1 章　起步"></a>第 1 章　起步</h1><ol><li>命令窗口<ul><li>在命令窗口中，要在文件系统中导航，可使用终端命令cd(change directory,即切换目录)</li><li>使用命令dir（表示directory，即目录）可列出当前目录中的所有文件</li></ul></li><li>在终端会话中运行Python文件hello_world.py，请执行下面的命令：<ul><li>第一步  <code>C:\&gt; cd Desktop\python_work</code></li><li>第二步  <code>C:\Desktop\python_work&gt; dir</code> 找到hello_world.py</li><li>第三步  <code>C:\Desktop\python_work&gt; python hello_world.py</code> 得到输出<code>Hello Python world!</code></li></ul></li><li>其他注意事项<ul><li>区分语句、函数、方法</li><li>语句 比如if、while、del等</li><li>函数 比如print()等</li><li>方法 比如list.pop()等  </li></ul></li></ol><h1 id="第-2-章-变量和简单数据类型"><a href="#第-2-章-变量和简单数据类型" class="headerlink" title="第 2 章　变量和简单数据类型"></a>第 2 章　变量和简单数据类型</h1><h2 id="一、变量名赋值的注意事项"><a href="#一、变量名赋值的注意事项" class="headerlink" title="一、变量名赋值的注意事项"></a>一、变量名赋值的注意事项</h2><ul><li>变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头，例如，可将变量命名为<code>message_1</code>，但不能将其命名为<code>1_message</code>。</li><li>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名<code>greeting_message</code>可行，但变量名<code>greeting message</code>会引发错误。</li><li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print。</li><li>就目前而言，应使用小写的Python变量名。在变量名中使用大写字母虽然不会导致错误，但避免使用大写字母是个不错的主意。</li><li>若变量为常量，最好将变量名全部大写：<code>MAX_CONNECTIONS= 5000</code> 。</li><li><strong>多个变量赋值：<code>x, y, z= &quot;a&quot;, 10, &quot;b&quot;</code></strong> 。  </li></ul><h2 id="二、用方法修改字符串的大小写"><a href="#二、用方法修改字符串的大小写" class="headerlink" title="二、用方法修改字符串的大小写"></a>二、用方法修改字符串的大小写</h2><ul><li>首字母大写（其他都变小写）：<code>str.title()</code> 。</li><li>总结：全部大写：<code>str.upper()</code> 。</li><li>总结：全部小写：<code>str.lower()</code> 。</li><li>说明：方法 <code>title()</code> 出现在这个变量的后面。方法是Python可对数据执行的操作。在 <code>name.title()</code> 中，name 后面的句点（. ）让Python对变量name 执行方法 <code>title()</code> 指定的操作。每个方法后面都跟着一对括号，这是因为方法通常需要额外的信息来完成其工作。这种信息是在括号内提供的。函数 <code>title()</code> 不需要额外的信息，因此它后面的括号是空的。  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name= <span class="string">&quot;aDA lovelace&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name.title()) <span class="comment"># 注：这三个方法不改变变量的值，与列表list的方法不同</span></span><br><span class="line"><span class="built_in">print</span>(name.upper())</span><br><span class="line"><span class="built_in">print</span>(name.lower())</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ada Lovelace</span><br><span class="line">ADA LOVELACE</span><br><span class="line">ada lovelace</span><br></pre></td></tr></table></figure><h2 id="三、在f字符串中使用变量"><a href="#三、在f字符串中使用变量" class="headerlink" title="三、在f字符串中使用变量"></a>三、在f字符串中使用变量</h2><ul><li><code>variate0 = f&quot;&#123;variate1&#125;&quot;</code> 这个方法主要用于在字符串中使用变量的值。</li><li>说明：这种字符串叫f字符串。f是format（设置格式）的缩写，把花括号内的变量替换为其值来设置字符串的格式。</li><li>f字符串是python3.6引入的。之前的方法是<code>format()</code>，比如：<code>full_name = &quot;&#123;&#125;&#123;&#125;&quot;.format(last_name, first_name)</code>，这2方法都可以用。  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">last_name = <span class="built_in">input</span>(<span class="string">&quot;您的姓:&quot;</span>)</span><br><span class="line">first_name = <span class="built_in">input</span>(<span class="string">&quot;您的名:&quot;</span>)</span><br><span class="line">full_name = <span class="string">f&quot;<span class="subst">&#123;last_name&#125;</span><span class="subst">&#123;first_name&#125;</span>&quot;</span>  <span class="comment"># 或者是 full_name = &quot;&#123;&#125;&#123;&#125;&quot;.format(last_name, first_name)</span></span><br><span class="line"><span class="built_in">print</span>(full_name + <span class="string">&quot;您好！&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="四、使用制表符或换行符"><a href="#四、使用制表符或换行符" class="headerlink" title="四、使用制表符或换行符"></a>四、使用制表符或换行符</h2><ul><li><code>\t</code>：制表符，t:tablet；<code>\n</code>：换行符，n:newline。  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Languages:\n\tPython\n\tC\n\tJavaScript&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Languages:</span><br><span class="line">        Python</span><br><span class="line">        C</span><br><span class="line">        JavaScript</span><br></pre></td></tr></table></figure></p><h2 id="五、用方法删除字符串中空白"><a href="#五、用方法删除字符串中空白" class="headerlink" title="五、用方法删除字符串中空白"></a>五、用方法删除字符串中空白</h2><ul><li>删除字符串末尾的空白：<code>str.rstrip()</code> 。</li><li>删除字符串开头的空白：<code>str.lstrip()</code> 。</li><li>删除字符串两边的空白：<code>str.strip()</code> 。</li><li>替换字符串中的特定字符：<code>str = str.replace(&#39;被替换字符&#39;, &#39;替换字符&#39;)</code> 。</li><li><code>str.rstrip([chars])</code> chars：指定删除的字符（默认为空白符，包括空格、换行符\n、回车符、制表符\t）。  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">random_string = <span class="string">&#x27;this is good    &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(random_string.rstrip()) <span class="comment"># 字符串末尾的空格会被删除</span></span><br><span class="line"><span class="built_in">print</span>(random_string.rstrip(<span class="string">&#x27;si oo&#x27;</span>)) <span class="comment"># &#x27;si oo&#x27; 不是尾随字符，因此不会删除任何内容</span></span><br><span class="line"><span class="built_in">print</span>(random_string.rstrip(<span class="string">&#x27;sid oo&#x27;</span>)) <span class="comment"># 在 &#x27;sid oo&#x27; 中 &#x27;d oo&#x27; 是尾随字符，&#x27;ood&#x27; 从字符串中删除</span></span><br><span class="line">website = <span class="string">&#x27;www.runoob.com/&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(website.rstrip(<span class="string">&#x27;m/.&#x27;</span>)) <span class="comment"># &#x27;m/&#x27; 是尾随字符，没有找到 &#x27;.&#x27; 号的尾随字符, &#x27;m/&#x27; 从字符串中删除</span></span><br></pre></td></tr></table></figure><p>输出结果如下：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this is good</span><br><span class="line">this is good</span><br><span class="line">this is g</span><br><span class="line">www.runoob.co</span><br></pre></td></tr></table></figure><h2 id="六、数与算术运算符"><a href="#六、数与算术运算符" class="headerlink" title="六、数与算术运算符"></a>六、数与算术运算符</h2><ul><li><code>%</code>：取模 - 返回除法的余数。</li><li><code>**</code>：幂 - 返回x的y次幂。</li><li><code>//</code>：取整除 - 返回商的整数部分（向下取整）。</li><li>相等运算符：<code>==</code>；不等运算符：<code>!=</code> 。</li><li><code>&lt;=</code> <code>&gt;=</code> 。</li><li>Python默认得到的总是浮点数，即使结果本为整数也是如此。  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c= <span class="number">8</span>/<span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p>输出结果如下：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.0</span><br></pre></td></tr></table></figure><ul><li>数中的下划线相当于平时书写的逗号，让数字更加清晰，Python不会打印其中的下划线（Python3.6以上版本）  </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d= <span class="number">14_000_000_000</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><p>输出结果如下：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14000000000</span><br></pre></td></tr></table></figure><h1 id="第-3-章-列表简介"><a href="#第-3-章-列表简介" class="headerlink" title="第 3 章　列表简介"></a>第 3 章　列表简介</h1><h2 id="一、列表与列表索引"><a href="#一、列表与列表索引" class="headerlink" title="一、列表与列表索引"></a>一、列表与列表索引</h2><ul><li>列表是可以修改的。</li><li>列表（list）用方括号（[ ]）来表示，索引即在方括号内加0、1、2……或者-1、-2、-3…….</li><li>访问列表元素：将该元素的位置或索引告诉Python。</li><li>在Python中，第一个列表元素的索引为0，而不是1。在大多数编程语言中都是如此，这与列表操作的底层实现相关。</li><li>将索引指定为-1，-2，-3…..可返回最后的元素、倒数第二个列表元素、倒数第三个列表元素，以此类推。</li><li>可以用f字符串使用列表中的各个值。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bicycles = [<span class="string">&#x27;trek&#x27;</span>, <span class="string">&#x27;cannondale&#x27;</span>, <span class="string">&#x27;redline&#x27;</span>, <span class="string">&#x27;specialized&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(bicycles[<span class="number">0</span>].title())</span><br><span class="line"><span class="built_in">print</span>(bicycles[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">message = <span class="string">f&quot;My first bicycle was a <span class="subst">&#123;bicycles[<span class="number">0</span>].title()&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><p>输出结果如下：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Trek</span><br><span class="line">specialized</span><br><span class="line">My first bicycle was a Trek</span><br></pre></td></tr></table></figure><h2 id="二、用方法修改添加列表元素"><a href="#二、用方法修改添加列表元素" class="headerlink" title="二、用方法修改添加列表元素"></a>二、用方法修改添加列表元素</h2><ol><li>修改元素 <code>list[index] = value</code></li><li>用方法在列表末尾添加元素 <code>list.append(value)</code> 注：该方法无返回值，但是会修改原来的列表。</li><li>用方法在列表中插入元素 <code>list.insert(index, value)</code> 注：该方法没有返回值，但会在列表指定位置插入对象。</li><li>使用del语句删除元素 <code>del list[index]</code> 。</li><li>使用方法pop() 弹出元素 <code>list.pop(index)</code>  注：pop是删除并且返回，默认为删除结尾的元素，pop为弹出的意思。</li><li>使用方法remove() 根据值删除元素 <code>list.remove(value)</code> 注：该方法无返回值，remove只删除第一个指定的值，需要使用循环来删除全部指定的值。  </li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 用赋值修改list元素</span></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">motorcycles[<span class="number">0</span>] = <span class="string">&#x27;ducati&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"><span class="comment"># 2. 方法append()</span></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">motorcycles.append(<span class="string">&#x27;ducati&#x27;</span>)  <span class="comment"># 因为list.append()是一个none type, 返回值为None, 所以不需要赋值，它会直接修改list</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"><span class="comment"># 3. 方法insert()</span></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">motorcycles.insert(<span class="number">0</span>, <span class="string">&#x27;ducati&#x27;</span>) <span class="comment"># 同理，无返回值</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles) </span><br><span class="line"><span class="comment"># 4. 使用del语句删除元素</span></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> motorcycles[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"><span class="comment"># 5. 方法pop() 弹出元素</span></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">popped_motorcycle = motorcycles.pop() <span class="comment"># 弹出末尾元素，并返回该元素，若为pop(0)即弹出第一个元素</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"><span class="built_in">print</span>(popped_motorcycle)</span><br><span class="line"><span class="comment"># 6. 方法remove() </span></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>, <span class="string">&#x27;ducati&#x27;</span>]</span><br><span class="line">motorcycles.remove(<span class="string">&#x27;ducati&#x27;</span>) <span class="comment"># 同理，没有返回值但是会移除列表中的某个值的第一个匹配项</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br></pre></td></tr></table></figure><p>输出结果如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. </span><br><span class="line">[&#x27;ducati&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span><br><span class="line"># 2. </span><br><span class="line">[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]</span><br><span class="line"># 3. </span><br><span class="line">[&#x27;ducati&#x27;, &#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span><br><span class="line"># 4.</span><br><span class="line">[&#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span><br><span class="line"># 5.</span><br><span class="line">[&#x27;honda&#x27;, &#x27;yamaha&#x27;]</span><br><span class="line">suzuki</span><br><span class="line"># 6.</span><br><span class="line">[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span><br></pre></td></tr></table></figure><h2 id="三、组织列表排序"><a href="#三、组织列表排序" class="headerlink" title="三、组织列表排序"></a>三、组织列表排序</h2><ol><li>使用方法sort() 对列表按字母顺序或反序排序 <code>list.sort()</code> 或 <code>list.sort(reverse=True)</code> 注：方法永久修改列表，该方法没有返回值。</li><li>使用函数sorted() 对列表进行临时按字母顺序或反序排序 <code>sorted(list)</code> 或 <code>sorted(list, reverse=True)</code> 注：函数不修改列表。</li><li>使用方法reverse() 反转列表元素的排列顺序 <code>list.reverse()</code> 注：方法永久修改列表，该方法没有返回值。</li><li>使用函数len() 确定列表的长度 <code>len(list)</code> 。</li><li>其他注意事项：上述说的都是小写情况，有大写字母可能会复杂。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、方法sort()</span></span><br><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line">cars.sort()</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line">cars.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"><span class="comment"># 2、函数sorted()</span></span><br><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here is the original list:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nHere is the sorted list:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(cars))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(cars, reverse=<span class="literal">True</span>)) <span class="comment"># 也可以用reverse=True来按字母反序打印</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nHere is the original list again:&quot;</span>) <span class="comment"># 不改变列表原始顺序</span></span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"><span class="comment"># 3、方法reverse()</span></span><br><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line">cars.reverse()</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"><span class="comment"># 4、函数len()</span></span><br><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(cars))</span><br></pre></td></tr></table></figure><p>输出结果如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">[&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]</span><br><span class="line">[&#x27;toyota&#x27;, &#x27;subaru&#x27;, &#x27;bmw&#x27;, &#x27;audi&#x27;]</span><br><span class="line"># 2.</span><br><span class="line">Here is the original list:</span><br><span class="line">[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]</span><br><span class="line"></span><br><span class="line">Here is the sorted list:</span><br><span class="line">[&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]</span><br><span class="line">[&#x27;toyota&#x27;, &#x27;subaru&#x27;, &#x27;bmw&#x27;, &#x27;audi&#x27;]</span><br><span class="line"></span><br><span class="line">Here is the original list again:</span><br><span class="line">[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]</span><br><span class="line"># 3.</span><br><span class="line">[&#x27;subaru&#x27;, &#x27;toyota&#x27;, &#x27;audi&#x27;, &#x27;bmw&#x27;]</span><br><span class="line"># 4.</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="第-4-章-操作列表"><a href="#第-4-章-操作列表" class="headerlink" title="第 4 章　操作列表"></a>第 4 章　操作列表</h1><h2 id="一、for循环语句"><a href="#一、for循环语句" class="headerlink" title="一、for循环语句"></a>一、for循环语句</h2><ul><li>for循环语句，对列表中的每个元素都执行相同的操作 <code>for variate in list:</code> 。</li><li>注意点：别忘了冒号；进入循环的语句别忘了缩进。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magicians = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;david&#x27;</span>, <span class="string">&#x27;carolina&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:  <span class="comment"># 这行代码让Python从列表magicians中取出一个名字，并将其存储在变量magician中，即赋值</span></span><br><span class="line">    <span class="built_in">print</span>(magician)</span><br></pre></td></tr></table></figure><h2 id="二、创建数值列表"><a href="#二、创建数值列表" class="headerlink" title="二、创建数值列表"></a>二、创建数值列表</h2><ol><li>使用函数range()生成一系列数字 <code>range(start,end,step)</code> 注：包括start，不包括end。</li><li>使用函数list()，range()创建数字列表 <code>list(range(start,end,step))</code> 。</li><li>使用函数min() max() sum()对数字列表进行简单统计 <code>min(list) max(list) sum(list)</code> 。</li><li>列表解析将for循环和创建新元素的代码合成一行 <code>list = [value**x for value in range(start,end,step)]</code> 。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、使用函数range()</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):  <span class="comment"># 注意，打印出来的是1-4，不打印5</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"><span class="comment"># 2、使用range()创建数字列表</span></span><br><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(even_numbers)</span><br><span class="line"><span class="comment"># 3、使用函数min() max() sum()</span></span><br><span class="line">digits = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(digits))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(digits))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(digits))</span><br><span class="line"><span class="comment"># 4、列表解析</span></span><br><span class="line">  <span class="comment">#(1) 麻烦的方法：</span></span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    squares.append(value**<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line">  <span class="comment">#(2) 列表解析合并代码：</span></span><br><span class="line">squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br></pre></td></tr></table></figure><p>输出结果如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line"># 2.</span><br><span class="line">[1, 2, 3, 4, 5]</span><br><span class="line">[2, 4, 6, 8, 10]</span><br><span class="line"># 3.</span><br><span class="line">0</span><br><span class="line">9</span><br><span class="line">45</span><br><span class="line"># 4.</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><h2 id="三、使用列表的一部分"><a href="#三、使用列表的一部分" class="headerlink" title="三、使用列表的一部分"></a>三、使用列表的一部分</h2><ol><li>切片 返回列表部分元素 <code>list[start:end:step]</code> 注：包括start，不包括end，step同之前，每隔多少元素提取一个。</li><li>用赋值复制列表的一部分 <code>list1 = list0[:]</code> 注：不能直接list1 = list0，这样赋值会导致这2个变量指向同一列表。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、切片</span></span><br><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># 包括1，不包括4</span></span><br><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[:<span class="number">4</span>]) <span class="comment"># 如果没有指定第一个索引，将自动从列表开头开始</span></span><br><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">2</span>:]) <span class="comment"># 提取从第3个元素到列表末尾的所有元素</span></span><br><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[-<span class="number">3</span>:]) <span class="comment"># 同上：输出名单上的最后三名队员</span></span><br><span class="line"><span class="keyword">for</span> player <span class="keyword">in</span> players[<span class="number">0</span>:<span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(player)</span><br><span class="line"><span class="comment"># 2、赋值复制列表</span></span><br><span class="line">  <span class="comment"># (1)list1 = list0[:]</span></span><br><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>]</span><br><span class="line">friend_foods = my_foods[:] <span class="comment"># 别忘了后面的[:]!!!</span></span><br><span class="line">my_foods.append(<span class="string">&#x27;cannoli&#x27;</span>)</span><br><span class="line">friend_foods.append(<span class="string">&#x27;ice cream&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My favorite foods are:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_foods)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMy friend&#x27;s favorite foods are:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(friend_foods)</span><br><span class="line">  <span class="comment"># (2)list1 = list0 导致逻辑错误</span></span><br><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>]</span><br><span class="line">friend_foods = my_foods <span class="comment"># ★这行不通，这种语法实际上是让Python将新变量friend_foods关联到包含在my_foods中的列表，因此这两个变量都指向同一个列表。</span></span><br><span class="line">my_foods.append(<span class="string">&#x27;cannoli&#x27;</span>)</span><br><span class="line">friend_foods.append(<span class="string">&#x27;ice cream&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My favorite foods are:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_foods)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMy friend&#x27;s favorite foods are:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(friend_foods)</span><br></pre></td></tr></table></figure><p>输出结果如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. </span><br><span class="line">[&#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;]</span><br><span class="line">[&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;, &#x27;florence&#x27;]</span><br><span class="line">[&#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]</span><br><span class="line">[&#x27;michael&#x27;, &#x27;florence&#x27;, &#x27;eli&#x27;]</span><br><span class="line">charles</span><br><span class="line">martina</span><br><span class="line">michael</span><br><span class="line"># 2.</span><br><span class="line">My favorite foods are:</span><br><span class="line">[&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;, &#x27;cannoli&#x27;]</span><br><span class="line"></span><br><span class="line">My friend&#x27;s favorite foods are:</span><br><span class="line">[&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;, &#x27;ice cream&#x27;]</span><br><span class="line">My favorite foods are:</span><br><span class="line">[&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;, &#x27;cannoli&#x27;, &#x27;ice cream&#x27;]</span><br><span class="line"></span><br><span class="line">My friend&#x27;s favorite foods are:</span><br><span class="line">[&#x27;pizza&#x27;, &#x27;falafel&#x27;, &#x27;carrot cake&#x27;, &#x27;cannoli&#x27;, &#x27;ice cream&#x27;]</span><br></pre></td></tr></table></figure><h2 id="四、元组"><a href="#四、元组" class="headerlink" title="四、元组"></a>四、元组</h2><ol><li>元组tuple即 不可变的列表 <code>tuple = (element0, element1, ...)</code> 。</li><li>使用索引访问元组元素 <code>tuple[number]</code> 注：也是中括号。</li><li>★元组中的元素不可修改、赋值。</li><li>用for循环语句，对元组中的每个元素都执行相同的操作 <code>for variate in tuple:</code> 。</li><li>元组的元素不能修改，但是可以用赋值修改整个元组变量。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、使用索引访问元组元素</span></span><br><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(dimensions[<span class="number">0</span>]) <span class="comment"># 注意也是中括号</span></span><br><span class="line"><span class="built_in">print</span>(dimensions[<span class="number">1</span>]) </span><br><span class="line"><span class="comment"># 2、给元组的元素赋值，会导致python返回类型错误消息</span></span><br><span class="line"><span class="comment"># 比如dimensions[0] = 250会导致错误</span></span><br><span class="line"><span class="comment"># 3、for循环语句</span></span><br><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    <span class="built_in">print</span>(dimension)</span><br><span class="line"><span class="comment"># 4、用赋值修改整个元组</span></span><br><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Original dimensions:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    <span class="built_in">print</span>(dimension)</span><br><span class="line">dimensions = (<span class="number">400</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nModified dimensions:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    <span class="built_in">print</span>(dimension)</span><br></pre></td></tr></table></figure><p>输出结果如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">200</span><br><span class="line">50</span><br><span class="line"># 3.</span><br><span class="line">200</span><br><span class="line">50</span><br><span class="line"># 4.</span><br><span class="line">Original dimensions:</span><br><span class="line">200</span><br><span class="line">50</span><br><span class="line"></span><br><span class="line">Modified dimensions:</span><br><span class="line">400</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h2 id="五、代码格式PEP-8"><a href="#五、代码格式PEP-8" class="headerlink" title="五、代码格式PEP 8"></a>五、代码格式PEP 8</h2><ul><li>Python程序员都遵循一些格式设置约定。</li><li>若要提出Python语言修改建议，需要编写Python改进提案（Python Enhancement Proposal，PEP）.PEP 8是最古老的PEP之一，它向Python程序员提供了代码格式设置指南。</li><li><ol><li>缩进：PEP 8建议每级缩进都使用四个空格；在字处理文档中，大家常常使用制表符而不是空格来缩进。在程序中混合使用制表符和空格可能导致极难解决的问题。</li><li>行长：每行都不要超过80字符。对你使用的编辑器进行设置，使其在第80个字符处显示一条垂直参考线。</li><li>空行：不要在程序文件中滥用空行。</li></ol></li></ul><h1 id="第-5-章-if-语句"><a href="#第-5-章-if-语句" class="headerlink" title="第 5 章　if 语句"></a>第 5 章　if 语句</h1><h2 id="一、if语句条件测试以及布尔表达式"><a href="#一、if语句条件测试以及布尔表达式" class="headerlink" title="一、if语句条件测试以及布尔表达式"></a>一、if语句条件测试以及布尔表达式</h2><ol><li>每条if语句的核心都是一个值为True或False的表达式，这种表达式被称为条件测试。Python根据条件测试的值为True还是False来决定是否执行if语句中的代码。</li><li>相等运算符：<code>==</code> ；不等运算符：<code>!=</code>  注：两个大小写不同的值会被视为不相等</li><li><code>and</code> ：两个条件都为True，则为True；有一个条件是False，则为False。 注：从左到右计算表达式，若第一个条件为False，直接返回False，不计算第二个条件</li><li><code>or</code> ：有一个条件是True，则为True；两个条件都为False，则为False。 注：从左到右计算表达式，若第一个条件为True，直接返回True，不计算第二个条件</li><li>要判断特定的值是否已包含在列表中，可使用关键字in；确定特定的值未包含在列表，可使用关键字<code>not in</code></li><li>注意：<code>False</code>和<code>True</code>的首字母必须大写，否则不是布尔表达式(bool)</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、相等运算符、不等运算符</span></span><br><span class="line">car = <span class="string">&#x27;Audi&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(car == <span class="string">&#x27;audi&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(car.lower() == <span class="string">&#x27;audi&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(car != <span class="string">&#x27;audi&#x27;</span>)</span><br><span class="line"><span class="comment"># 2、and和or</span></span><br><span class="line">age_0 = <span class="number">22</span></span><br><span class="line">age_1 = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(age_0 &gt;= <span class="number">21</span> <span class="keyword">and</span> age_1 &gt;= <span class="number">21</span>)</span><br><span class="line"><span class="built_in">print</span>(age_0 &gt;= <span class="number">21</span> <span class="keyword">or</span> age_1 &gt;= <span class="number">21</span>)</span><br><span class="line"><span class="comment"># 3、关键字in、not in</span></span><br><span class="line">requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;onions&#x27;</span>, <span class="string">&#x27;pineapple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mushrooms&#x27;</span> <span class="keyword">in</span> requested_toppings)</span><br><span class="line">banned_users = [<span class="string">&#x27;andrew&#x27;</span>, <span class="string">&#x27;carolina&#x27;</span>, <span class="string">&#x27;david&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;marie&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> banned_users)</span><br><span class="line"><span class="comment"># 4、布尔表达式bool</span></span><br><span class="line">a = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br></pre></td></tr></table></figure><p>输出结果如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line"># 2.</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line"># 3.</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line"># 4.</span><br><span class="line">&lt;class &#x27;bool&#x27;&gt;</span><br></pre></td></tr></table></figure><h2 id="二、if语句"><a href="#二、if语句" class="headerlink" title="二、if语句"></a>二、if语句</h2><ol><li>简单的if语句：<code>if conditional_test:</code> 。</li><li>if-else语句：<code>else</code>语句让你能够指定条件测试未通过时要执行的操作。</li><li>if-elif-else语句：依次检查每个条件测试，若测试通过，Python将执行紧跟在它后面的代码，并跳过余下的测试。</li><li>if-elif-else语句中可以不用else。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、简单的if语句</span></span><br><span class="line">age = <span class="number">19</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You are old enough to vote!&quot;</span>)  <span class="comment"># 在if语句中，缩进的作用与for循环中相同。如果测试通过了，将执行if语句后面所有缩进的代码行，否则将忽略它们。</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Have you registered to vote yet?&quot;</span>)</span><br><span class="line"><span class="comment"># 2、if-else语句</span></span><br><span class="line">age = <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You are old enough to vote!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Have you registered to vote yet?&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sorry, you are too young to vote.&quot;</span>) <span class="comment"># 注：else本身不缩进！后面的执行语句别忘了冒号和缩进！</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Please register to vote as soon as you turn 18!&quot;</span>)</span><br><span class="line"><span class="comment"># 3、if-elif-else语句</span></span><br><span class="line">age = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Your admission cost is $0.&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Your admission cost is $5.&quot;</span>) <span class="comment"># 注：elif本身不缩进，并且别忘了冒号和之后的执行语句的缩进</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Your admission cost is $10.&quot;</span>)</span><br><span class="line"><span class="comment"># 4、Python并不要求if-elif结构后面必须有else代码块。else是一条包罗万象的语句，只要不满足任何if或elif中的条件测试，其中的代码就会执行。</span></span><br><span class="line">age = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>: <span class="comment"># 注意：不要写成4 &lt;= age &lt; 18，这样写虽然不会错，但是没必要</span></span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">65</span>:</span><br><span class="line">    price = <span class="number">10</span></span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">65</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Your admission cost is $<span class="subst">&#123;price&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">You are old enough to vote!</span><br><span class="line">Have you registered to vote yet?</span><br><span class="line"># 2.</span><br><span class="line">Sorry, you are too young to vote.</span><br><span class="line">Please register to vote as soon as you turn 18!</span><br><span class="line"># 3.</span><br><span class="line">Your admission cost is $5.</span><br><span class="line"># 4.</span><br><span class="line">Your admission cost is $5.</span><br></pre></td></tr></table></figure><h2 id="三、if语句处理列表"><a href="#三、if语句处理列表" class="headerlink" title="三、if语句处理列表"></a>三、if语句处理列表</h2><ul><li>在if语句中将列表名用在条件表达式中时，Python将在列表至少包含一个元素时返回True，并在列表为空时返回False。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、确定列表不是空的</span></span><br><span class="line">requested_toppings = []</span><br><span class="line"><span class="keyword">if</span> requested_toppings:  <span class="comment"># 因为列表为空，返回了False，执行了else语句</span></span><br><span class="line">    <span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Adding &quot;</span> + requested_topping + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nFinished making your pizza!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Are you sure you want a plain pizza?&quot;</span>)</span><br><span class="line"><span class="comment"># 2、使用多个列表</span></span><br><span class="line">available_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;olives&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;pepperoni&#x27;</span>, <span class="string">&#x27;pineapple&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>]</span><br><span class="line">requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;french fries&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="keyword">if</span> requested_topping <span class="keyword">in</span> available_toppings:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Adding <span class="subst">&#123;requested_topping&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Sorry, we don&#x27;t have <span class="subst">&#123;requested_topping&#125;</span>.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Finished making your pizza!&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">Are you sure you want a plain pizza?</span><br><span class="line"># 2.</span><br><span class="line">Adding mushrooms.</span><br><span class="line">Sorry, we don&#x27;t have french fries.</span><br><span class="line">Adding extra cheese.</span><br><span class="line">Finished making your pizza!</span><br></pre></td></tr></table></figure><h1 id="第-6-章-字典"><a href="#第-6-章-字典" class="headerlink" title="第 6 章　字典"></a>第 6 章　字典</h1><h2 id="一、使用字典"><a href="#一、使用字典" class="headerlink" title="一、使用字典"></a>一、使用字典</h2><ol><li>字典dict类似于列表，但让你能够将不同的信息关联起来 <code>dict = &#123;key1 : value1, key2 : value2, key3 : value3&#125;</code> 。</li><li>字典是另一种可变容器模型，且可存储任意类型对象。字典是一系列键值对，每个键都有一个值相关联，使用键来访问与之关联的值。</li><li>用赋值添加键值对 <code>dict[key4] = value4</code> 。</li><li>用赋值修改字典中的值 <code>dict[key1] = value4</code> 。</li><li>使用del语句将相应的键值对彻底删除 <code>del dict[key1]</code> 。</li><li>使用方法get()在指定的键不存在时返回一个默认值 <code>dict.get(key0, value0)</code> 若不指定value0，则将返回None。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、简单的字典</span></span><br><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(alien_0[<span class="string">&#x27;color&#x27;</span>]) <span class="comment"># 调用是用键值key并且同列表也是中括号，可以把列表理解为key是0，1，2的字典。</span></span><br><span class="line"><span class="built_in">print</span>(alien_0[<span class="string">&#x27;points&#x27;</span>])</span><br><span class="line"><span class="comment"># 2、用赋值添加键值对</span></span><br><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br><span class="line">alien_0[<span class="string">&#x27;x_position&#x27;</span>] = <span class="number">0</span></span><br><span class="line">alien_0[<span class="string">&#x27;y_position&#x27;</span>] = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(alien_0) <span class="comment"># 在python3.7版本后，字典元素的顺序与定义时一致</span></span><br><span class="line"><span class="comment"># 3、用赋值修改字典中的值</span></span><br><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125;</span><br><span class="line">alien_0[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br><span class="line"><span class="comment"># 4、del语句删除键值对</span></span><br><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">del</span> alien_0[<span class="string">&#x27;points&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br><span class="line"><span class="comment"># 5、多行定义字典</span></span><br><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">print</span>(favorite_languages)</span><br><span class="line"><span class="comment"># 6、使用方法get()处理键不存在的错误</span></span><br><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125;</span><br><span class="line">point_value = alien_0.get(<span class="string">&#x27;point&#x27;</span>, <span class="string">&#x27;No point value assigned&#x27;</span>) <span class="comment"># 如果字典有键point，返回相关联的值；若没有，返回指定的默认值。</span></span><br><span class="line"><span class="built_in">print</span>(point_value)</span><br><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>, <span class="string">&#x27;point&#x27;</span>: <span class="string">&#x27;5&#x27;</span>&#125;</span><br><span class="line">point_value = alien_0.get(<span class="string">&#x27;point&#x27;</span>, <span class="string">&#x27;No point value assigned&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(point_value)</span><br></pre></td></tr></table></figure><p>输出结果如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">green</span><br><span class="line">5</span><br><span class="line"># 2.</span><br><span class="line">&#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5&#125;</span><br><span class="line">&#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5, &#x27;x_position&#x27;: 0, &#x27;y_position&#x27;: 25&#125;</span><br><span class="line"># 3.</span><br><span class="line">&#123;&#x27;color&#x27;: &#x27;yellow&#x27;&#125;</span><br><span class="line"># 4.</span><br><span class="line">&#123;&#x27;color&#x27;: &#x27;green&#x27;&#125;</span><br><span class="line"># 5.</span><br><span class="line">&#123;&#x27;jen&#x27;: &#x27;python&#x27;, &#x27;sarah&#x27;: &#x27;c&#x27;, &#x27;edward&#x27;: &#x27;ruby&#x27;, &#x27;phil&#x27;: &#x27;python&#x27;&#125;</span><br><span class="line"># 6.</span><br><span class="line">No point value assigned</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="二、遍历字典"><a href="#二、遍历字典" class="headerlink" title="二、遍历字典"></a>二、遍历字典</h2><ol><li>用for循环和方法items()来遍历字典 <code>for key, value in dict.items():</code></li><li>方法<code>items()</code>返回一个键值对列表  说明：可以print试试 注：别忘了s。</li><li>方法<code>keys()</code>遍历字典中的所有键，返回一个列表，其中包含字典中的所有键 说明：可以print试试 注：别忘了s。</li><li>用函数<code>sorted()</code>按顺序遍历字典中的所有键 sort：排序、分类的意思。</li><li>用方法<code>values()</code>遍历字典中的所有值，它返回一个值列表 注：别忘了s。</li><li>用<code>set()</code>函数删除重复数据 set集合，集合里不包括重复项。</li><li>可以用大括号创建集合 比如 <code>set = &#123;&#39;python&#39;, &#39;ruby&#39;, &#39;python&#39;, &#39;c&#39;&#125;</code> 这样打印出来只有3个元素，注意：和字典都是用大括号。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、for循环和方法items()</span></span><br><span class="line">favorite_languages = &#123;<span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,&#125;</span><br><span class="line"><span class="keyword">for</span> name, language <span class="keyword">in</span> favorite_languages.items():   <span class="comment"># 别忘了这个items</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>&#x27;s favorite language is <span class="subst">&#123;language.title()&#125;</span>.&quot;</span>)</span><br><span class="line"><span class="comment"># 2、方法keys()</span></span><br><span class="line">favorite_languages = &#123;<span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,&#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    <span class="built_in">print</span>(name.title())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages:  <span class="comment">#遍历字典时，会默认遍历所有的键，不用keys()输出将不变，但有keys()更好理解，所以可以不忽略或省略</span></span><br><span class="line">    <span class="built_in">print</span>(name.title())</span><br><span class="line"></span><br><span class="line">friends = [<span class="string">&#x27;phil&#x27;</span>, <span class="string">&#x27;sarah&#x27;</span>]  <span class="comment">#注：这个是列表</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    <span class="built_in">print</span>(name.title())</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> friends:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hi <span class="subst">&#123;name.title()&#125;</span>, I see your favorite language is <span class="subst">&#123;favorite_languages[name].title()&#125;</span>!&quot;</span>)</span><br><span class="line"><span class="comment"># 3、函数sorted()</span></span><br><span class="line">favorite_languages = &#123;<span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,&#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">sorted</span>(favorite_languages.keys()):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>, thank you for taking the poll.&quot;</span>)</span><br><span class="line"><span class="comment"># 4、方法values()</span></span><br><span class="line">favorite_languages = &#123;<span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The following languages have been mentioned:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favorite_languages.values():</span><br><span class="line">    <span class="built_in">print</span>(language.title())</span><br><span class="line"><span class="comment"># 5、set()函数</span></span><br><span class="line">favorite_languages = &#123;<span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The following languages have been mentioned:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> <span class="built_in">set</span>(favorite_languages.values()):</span><br><span class="line">    <span class="built_in">print</span>(language.title())</span><br></pre></td></tr></table></figure><p>输出结果如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">Jen&#x27;s favorite language is Python.</span><br><span class="line">Sarah&#x27;s favorite language is C.</span><br><span class="line">Edward&#x27;s favorite language is Ruby.</span><br><span class="line">Phil&#x27;s favorite language is Python.</span><br><span class="line"># 2.</span><br><span class="line">Jen</span><br><span class="line">Sarah</span><br><span class="line">Edward</span><br><span class="line">Phil</span><br><span class="line">Jen</span><br><span class="line">Sarah</span><br><span class="line">Edward</span><br><span class="line">Phil</span><br><span class="line">Jen</span><br><span class="line">Sarah</span><br><span class="line">Hi Sarah, I see your favorite language is C!</span><br><span class="line">Edward</span><br><span class="line">Phil</span><br><span class="line">Hi Phil, I see your favorite language is Python!</span><br><span class="line"># 3.</span><br><span class="line">Edward, thank you for taking the poll.</span><br><span class="line">Jen, thank you for taking the poll.</span><br><span class="line">Phil, thank you for taking the poll.</span><br><span class="line">Sarah, thank you for taking the poll.</span><br><span class="line"># 4.</span><br><span class="line">The following languages have been mentioned:</span><br><span class="line">Python</span><br><span class="line">C</span><br><span class="line">Ruby</span><br><span class="line">Python</span><br><span class="line"># 5.</span><br><span class="line">The following languages have been mentioned:</span><br><span class="line">Python</span><br><span class="line">C</span><br><span class="line">Ruby</span><br></pre></td></tr></table></figure><h2 id="三、嵌套字典列表"><a href="#三、嵌套字典列表" class="headerlink" title="三、嵌套字典列表"></a>三、嵌套字典列表</h2><ul><li>将一系列字典存储在列表中，或将列表作为值存储在字典。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、嵌套：字典列表 创造一个30个外星人的字典的列表</span></span><br><span class="line">aliens = []</span><br><span class="line"><span class="keyword">for</span> alien_number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):  <span class="comment"># ★就是遍历30次，range()函数见创建数值列表，它返回一系列数字，其唯一的用途是告诉Python我们要重复这个循环多少次</span></span><br><span class="line">    new_alien = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125;</span><br><span class="line">    aliens.append(new_alien)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Total number of aliens: <span class="subst">&#123;<span class="built_in">len</span>(aliens)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 2、嵌套：在字典中存储列表</span></span><br><span class="line"><span class="comment"># (1)、</span></span><br><span class="line">pizza = &#123;</span><br><span class="line">    <span class="string">&#x27;crust&#x27;</span>: <span class="string">&#x27;thick&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;toppings&#x27;</span>: [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>],  <span class="comment"># 在字典中将一个键关联到多个值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;You ordered a <span class="subst">&#123;pizza[<span class="string">&#x27;crust&#x27;</span>]&#125;</span>-crust pizza with the following toppings:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">&#x27;toppings&#x27;</span>]:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;\t&quot;</span> + topping)</span><br><span class="line"><span class="comment"># (2)、</span></span><br><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">&#x27;jen&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;ruby&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;sarah&#x27;</span>: [<span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;edward&#x27;</span>: [<span class="string">&#x27;ruby&#x27;</span>, <span class="string">&#x27;go&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;phil&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;haskell&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name, languages <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n<span class="subst">&#123;name.title()&#125;</span>&#x27;s favorite languages are:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> language <span class="keyword">in</span> languages:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\t<span class="subst">&#123;language.title()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 3、嵌套：在字典中存储字典</span></span><br><span class="line">users = &#123;</span><br><span class="line">    <span class="string">&#x27;aeinstein&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;albert&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;einstein&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;princeton&#x27;</span>,   <span class="comment"># 注意规范格式</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="string">&#x27;mcurie&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;marie&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;curie&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;paris&#x27;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> username, user_info <span class="keyword">in</span> users.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nUsername: &quot;</span> + username)</span><br><span class="line">    full_name = <span class="string">f&quot;<span class="subst">&#123;user_info[<span class="string">&#x27;first&#x27;</span>]&#125;</span> <span class="subst">&#123;user_info[<span class="string">&#x27;last&#x27;</span>]&#125;</span>&quot;</span></span><br><span class="line">    location = user_info[<span class="string">&#x27;location&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\tFull name: <span class="subst">&#123;full_name.title()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\tLocation: <span class="subst">&#123;location.title()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">Total number of aliens: 30</span><br><span class="line"># 2.(1).</span><br><span class="line">You ordered a thick-crust pizza with the following toppings:</span><br><span class="line">        mushrooms</span><br><span class="line">        extra cheese</span><br><span class="line"># 2.(2).</span><br><span class="line">Jen&#x27;s favorite languages are:</span><br><span class="line">        Python</span><br><span class="line">        Ruby</span><br><span class="line"></span><br><span class="line">Sarah&#x27;s favorite languages are:</span><br><span class="line">        C</span><br><span class="line"></span><br><span class="line">Edward&#x27;s favorite languages are:</span><br><span class="line">        Ruby</span><br><span class="line">        Go</span><br><span class="line"></span><br><span class="line">Phil&#x27;s favorite languages are:</span><br><span class="line">        Python</span><br><span class="line">        Haskell</span><br><span class="line"># 3.</span><br><span class="line">Username: aeinstein</span><br><span class="line">        Full name: Albert Einstein</span><br><span class="line">        Location: Princeton</span><br><span class="line"></span><br><span class="line">Username: mcurie</span><br><span class="line">        Full name: Marie Curie</span><br><span class="line">        Location: Paris</span><br></pre></td></tr></table></figure><h1 id="第-7-章-用户输入和while循环"><a href="#第-7-章-用户输入和while循环" class="headerlink" title="第 7 章　用户输入和while循环"></a>第 7 章　用户输入和while循环</h1><h2 id="一、用户输入"><a href="#一、用户输入" class="headerlink" title="一、用户输入"></a>一、用户输入</h2><ol><li>函数input()，等待用户输入一些文本，获取用户输入后，Python将其存储在一个变量中</li><li>用函数int()来将用户输入解读为字符串</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、函数input()</span></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Please enter your name: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"><span class="comment">#★有时候提示可能超过一行，可将提示存储在一个变量中，再将该变量传递给函数input()</span></span><br><span class="line">prompt = <span class="string">&quot;If you tell us who you are, we can personalize the messages you see.&quot;</span></span><br><span class="line">prompt += <span class="string">&quot;\nWhat is your first name? &quot;</span></span><br><span class="line">name = <span class="built_in">input</span>(prompt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"><span class="comment"># 2、函数int()</span></span><br><span class="line">height = <span class="built_in">input</span>(<span class="string">&quot;How tall are you, in inches? &quot;</span>)</span><br><span class="line">height = <span class="built_in">int</span>(height)</span><br><span class="line"><span class="keyword">if</span> height &gt;= <span class="number">48</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nYou&#x27;re tall enough to ride!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nYou&#x27;ll be able to ride when you&#x27;re a little older.&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="二、while循环"><a href="#二、while循环" class="headerlink" title="二、while循环"></a>二、while循环</h2><ol><li>while循环语句不断地运行，直到指定的条件不满足为止。 注意：用<kbd>Ctrl</kbd>+<kbd>C</kbd>来中止无线循环。</li><li>使用一个变量，用于判断整个程序是否处于活动状态，这个变量被称为标志flag，让程序在标志为True时继续运行，并在任何事件导致标志的值为False时让程序停止运行。</li><li>用<code>break</code>语句立即退出while循环，不再运行循环中余下的代码，也不管条件测试的结果如何</li><li>用<code>continue</code>语句忽略余下的代码返回到循环开头，并根据条件测试结果决定是否继续执行循环</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、简单while循环</span></span><br><span class="line">current_number = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> current_number &lt;= <span class="number">5</span>: </span><br><span class="line">    <span class="built_in">print</span>(current_number)</span><br><span class="line">    current_number += <span class="number">1</span></span><br><span class="line"><span class="comment"># 2、让用户选择何时退出</span></span><br><span class="line">prompt = <span class="string">&quot;\nTell me something, and I will repeat it back to you:&quot;</span></span><br><span class="line">prompt += <span class="string">&quot;\nEnter &#x27;quit&#x27; to end the program. &quot;</span></span><br><span class="line">message = <span class="string">&quot;&quot;</span>  <span class="comment"># 这样一定要先message = &quot;&quot;，不能直接message = input(prompt)，否则input函数在循环之外了，而且还会导致无限循环</span></span><br><span class="line"><span class="keyword">while</span> message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">    message = <span class="built_in">input</span>(prompt)</span><br><span class="line">    <span class="keyword">if</span> message != <span class="string">&#x27;quit&#x27;</span>:  <span class="comment"># 这里多添加个if的原因是，若不添加，我打个quit上去，会打印出quit，为了不打印出来加这个if语句</span></span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"><span class="comment"># 3、标志flag</span></span><br><span class="line">prompt = <span class="string">&quot;\nTell me something, and I will repeat it back to you:&quot;</span></span><br><span class="line">prompt += <span class="string">&quot;\nEnter &#x27;quit&#x27; to end the program. &quot;</span></span><br><span class="line">active = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> active:  <span class="comment"># 注：变量active为True ，循环就将继续运行</span></span><br><span class="line">    message = <span class="built_in">input</span>(prompt)</span><br><span class="line">    <span class="keyword">if</span> message == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        active = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"><span class="comment"># 4、break语句</span></span><br><span class="line">prompt = <span class="string">&quot;\nPlease enter the name of a city you have visited:&quot;</span></span><br><span class="line">prompt += <span class="string">&quot;\n(Enter &#x27;quit&#x27; when you are finished.) &quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    city = <span class="built_in">input</span>(prompt)</span><br><span class="line">    <span class="keyword">if</span> city == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;I&#x27;d love to go to <span class="subst">&#123;city.title()&#125;</span>!&quot;</span>)</span><br><span class="line"><span class="comment"># 5、continue语句</span></span><br><span class="line">current_number = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> current_number &lt; <span class="number">10</span>:</span><br><span class="line">    current_number += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> current_number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(current_number)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"># 5.</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="三、while循环处理列表字典"><a href="#三、while循环处理列表字典" class="headerlink" title="三、while循环处理列表字典"></a>三、while循环处理列表字典</h2><ul><li>同if语句，在while语句中将列表名用在条件表达式中时，Python将在列表至少包含一个元素时返回True，并在列表为空时返回False。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、在列表之间移动元素</span></span><br><span class="line">unconfirmed_users = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;brian&#x27;</span>, <span class="string">&#x27;candace&#x27;</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line"><span class="keyword">while</span> unconfirmed_users:</span><br><span class="line">    current_user = unconfirmed_users.pop()  <span class="comment"># pop：弹出返回末尾元素</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Verifying user: &quot;</span> + current_user.title())</span><br><span class="line">    confirmed_users.append(current_user)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nThe following users have been confirmed:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> confirmed_user <span class="keyword">in</span> confirmed_users:</span><br><span class="line">    <span class="built_in">print</span>(confirmed_user.title())</span><br><span class="line"><span class="comment"># 2、用方法remove删除列表中所有同一元素，因为remove只移除列表中的某个值的第一个匹配项</span></span><br><span class="line">pets = [<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;goldfish&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;rabbit&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]</span><br><span class="line"><span class="keyword">while</span> <span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> pets:</span><br><span class="line">    pets.remove(<span class="string">&#x27;cat&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(pets)</span><br><span class="line"><span class="comment"># 3、使用用户输入来填充字典</span></span><br><span class="line">responses = &#123;&#125;</span><br><span class="line">polling_active = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> polling_active:</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&quot;\nWhat is your name? &quot;</span>)</span><br><span class="line">    response = <span class="built_in">input</span>(<span class="string">&quot;Which mountain would you like to climb someday? &quot;</span>)</span><br><span class="line">    responses[name] = response <span class="comment"># 赋值增加键值对</span></span><br><span class="line">    repeat = <span class="built_in">input</span>(<span class="string">&quot;Would you like to let another person respond? (yes/ no) &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> repeat == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">        polling_active = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n--- Poll Results ---&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name, response <span class="keyword">in</span> responses.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> would like to climb <span class="subst">&#123;response&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.</span><br><span class="line">Verifying user: Candace</span><br><span class="line">Verifying user: Brian</span><br><span class="line">Verifying user: Alice</span><br><span class="line"></span><br><span class="line">The following users have been confirmed:</span><br><span class="line">Candace</span><br><span class="line">Brian</span><br><span class="line">Alice</span><br><span class="line"># 2.</span><br><span class="line">[&#x27;dog&#x27;, &#x27;dog&#x27;, &#x27;goldfish&#x27;, &#x27;rabbit&#x27;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> python读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown教程</title>
      <link href="/2022/09/07/2022-09-07-markdown/"/>
      <url>/2022/09/07/2022-09-07-markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode-编辑器"><a href="#VSCode-编辑器" class="headerlink" title="VSCode 编辑器"></a>VSCode 编辑器</h1><p>1、VSCode 默认集成了 Markdown 文档编辑插件，原生就支持高亮 Markdown 的语法。<br>2、VSCode 实时预览需要执行 Markdown: Open Preview to the Side 命令来实现。   </p><h1 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h1><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure></p><p>显示效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="Markdown-格式"><a href="#Markdown-格式" class="headerlink" title="Markdown 格式"></a>Markdown 格式</h1><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>Markdown 可以使用以下几种字体：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体文本_</span>__</span></span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br><em>斜体文本</em><br>_斜体文本_<br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong>_粗斜体文本_</strong></p><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>1、Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格；<br>2、或者在段落后面使用一个空行来表示重新开始一个段落。</p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> <span class="emphasis">* *</span></span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">**</span><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">- - -</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">----------</span></span></span><br></pre></td></tr></table></figure></p><p>显示效果如下：  </p><hr><hr><hr><hr><hr><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ ：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~带删除线文本~~</span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br><del>带删除线文本</del></p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>下划线可以通过 HTML 的 <code>&lt;u&gt;</code> 标签来实现：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br><u>带下划线文本</u>  </p><h1 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h1><p>Markdown 支持有序列表和无序列表。</p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="bullet">*</span> 第二项</span><br><span class="line"><span class="bullet">*</span> 第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 第一项</span><br><span class="line"><span class="bullet">+</span> 第二项</span><br><span class="line"><span class="bullet">+</span> 第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 第一项</span><br><span class="line"><span class="bullet">-</span> 第二项</span><br><span class="line"><span class="bullet">-</span> 第三项</span><br></pre></td></tr></table></figure></p><p>显示效果如下： </p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>有序列表使用数字并加上 . 号来表示：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">3.</span> 第三项</span><br></pre></td></tr></table></figure></p><p>显示效果如下： </p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p>列表嵌套只需在子列表中的选项前面添加两个或四个空格即可：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项：</span><br><span class="line"><span class="bullet">    -</span> 第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    -</span> 第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2.</span> 第二项：</span><br><span class="line"><span class="bullet">    -</span> 第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    -</span> 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure></p><p>显示效果如下： </p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h1 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h1><h2 id="区块和区块嵌套"><a href="#区块和区块嵌套" class="headerlink" title="区块和区块嵌套"></a>区块和区块嵌套</h2><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块内容</span></span><br><span class="line"></span><br><span class="line">// 区块嵌套</span><br><span class="line"><span class="quote">&gt; 第一层</span></span><br><span class="line"><span class="quote">&gt; &gt; 第二层</span></span><br><span class="line"><span class="quote">&gt; &gt; &gt; 第三层</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>显示效果如下： </p><blockquote><p>区块内容</p><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层</p></blockquote></blockquote></blockquote><h2 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h2><p>区块中使用列表：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块中使用列表</span></span><br><span class="line"><span class="quote">&gt; 1. 第一项</span></span><br><span class="line"><span class="quote">&gt; 2. 第二项</span></span><br></pre></td></tr></table></figure></p><p>显示效果如下： </p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol></blockquote><h2 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h2><p>如果要在列表项目内放进区块，最好在 &gt; 前添加四个空格的缩进：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="code">    &gt; 区块内容</span></span><br><span class="line"><span class="code">* 第二项</span></span><br><span class="line"><span class="code">&gt; 区块内容</span></span><br></pre></td></tr></table></figure></p><p>显示效果如下： </p><ul><li>第一项<blockquote><p>区块内容</p></blockquote></li><li>第二项<blockquote><p>区块内容</p></blockquote></li></ul><h1 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h1><h2 id="一个函数或片段的代码"><a href="#一个函数或片段的代码" class="headerlink" title="一个函数或片段的代码"></a>一个函数或片段的代码</h2><p>用反引号把它包起来（`）：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`printf()`</span> 函数</span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br><code>printf()</code> 函数</p><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">``` python</span></span><br><span class="line"><span class="code">s = &quot;Python hello world！&quot;</span></span><br><span class="line"><span class="code">print(s)</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;Python hello world！&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure></p><h1 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h1><p>链接使用方法如下：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">http://www.baidu.com</span>)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="language-xml">&lt;http://www.baidu.com&gt;</span></span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br><a href="http://www.baidu.com">百度</a></p><p>或者</p><p><a href="http://www.baidu.com">http://www.baidu.com</a></p><h1 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h1><p>Markdown 图片语法格式如下：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片名称</span>](<span class="link">https://s2.loli.net/2022/09/09/y8KgN7EbOkPIucL.jpg</span>)</span><br><span class="line">![<span class="string">图片名称</span>](<span class="link">https://s2.loli.net/2022/09/09/y8KgN7EbOkPIucL.jpg &quot;可选标题&quot;</span>)</span><br><span class="line">//可选标题需要鼠标悬浮在图片上，即显示</span><br></pre></td></tr></table></figure></p><p>带可选标题显示效果如下：<br><img src="https://s2.loli.net/2022/09/09/y8KgN7EbOkPIucL.jpg" alt="图片名称" title="可选标题"><br>不带可选标题显示效果如下：<br><img src="https://s2.loli.net/2022/09/09/y8KgN7EbOkPIucL.jpg" alt="图片名称"></p><p><strong>注：若需控制插入图片的大小，见Markdown高级技巧。</strong></p><h1 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h1><p>制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行，还可以通过 : 设置表格的对齐方式：  </p><ul><li>-: 冒号在右边设置内容和标题栏居右对齐</li><li>:- 冒号在左边设置内容和标题栏居左对齐</li><li>:-:冒号在两边设置内容和标题栏居中对齐  </li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :---- | ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><p>显示效果如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:right">右对齐</th><th style="text-align:center">居中对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr></tbody></table></div><h1 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h1><h2 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h2><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。<br>目前支持的 HTML 元素有：<code>&lt;kbd&gt;</code> <code>&lt;b&gt;</code> <code>&lt;i&gt;</code> <code>&lt;em&gt;</code> <code>&lt;sup&gt;</code> <code>&lt;sub&gt;</code> <code>&lt;br&gt;</code>等 ，如：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">使用 <span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Alt<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Del<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> 重启电脑</span><br></pre></td></tr></table></figure></p><p>显示效果如下：<br>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h2 id="避免转义"><a href="#避免转义" class="headerlink" title="避免转义"></a>避免转义</h2><p>用反斜杠<code>\</code>避免转义</p><h2 id="使用-HTML-方法插入图片并控制大小"><a href="#使用-HTML-方法插入图片并控制大小" class="headerlink" title="使用 HTML 方法插入图片并控制大小"></a>使用 HTML 方法插入图片并控制大小</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>  <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span>  </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s2.loli.net/2022/09/09/y8KgN7EbOkPIucL.jpg&quot;</span> <span class="attr">width</span> = <span class="string">&quot;50%&quot;</span> <span class="attr">height</span> = <span class="string">&quot;50%&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片名称&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>显示效果如下：</p><div  align="center">  <img src="https://s2.loli.net/2022/09/09/y8KgN7EbOkPIucL.jpg" width = "50%" height = "50%" alt="图片名称"/></div><h2 id="表格内换行"><a href="#表格内换行" class="headerlink" title="表格内换行"></a>表格内换行</h2><p>利用 HTML 的 <code>&lt;br&gt;</code> 标签达到换行的效果。<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 左对齐 |</span><br><span class="line">| :---- | :---- |</span><br><span class="line">| 单元格 | 单元格<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span>单元格 |</span><br><span class="line">| 单元格 | 单元格<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span>单元格 |</span><br></pre></td></tr></table></figure></p><p>显示效果如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:left">左对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:left">单元格<br>单元格</td></tr><tr><td style="text-align:left">单元格</td><td style="text-align:left">单元格<br>单元格</td></tr></tbody></table></div><h2 id="HTML-空格"><a href="#HTML-空格" class="headerlink" title="HTML 空格"></a>HTML 空格</h2><p>① <code>&amp;nbsp;</code> 为不换行空格，全称 No-Break Space 。该空格占据宽度受字体影响明显而强烈；<br>② <code>&amp;ensp;</code> 为半角空格，全称是 En Space ，en 是字体排印学的计量单位，为 em 宽度的一半。根据定义，它等同于字体度的一半（如 16px 字体中就是 8px ）。名义上是小写字母 n 的宽度。此空格占据的宽度正好是1/2个中文宽度，而且基本上不受字体影响。<br>③ <code>&amp;emsp;</code> 为全角空格，全称是 Em Space ，em 是字体排印学的计量单位，相当于当前指定的点数。1 em 在 16px 的字体中就是 16px 。此空格占据的宽度正好是1个中文宽度，而且基本上不受字体影响。</p>]]></content>
      
      
      <categories>
          
          <category> 博客教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
