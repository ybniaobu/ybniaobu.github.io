<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity Custom SRP 基础（六） | 鸟布的博客</title><meta name="author" content="鸟布"><meta name="copyright" content="鸟布"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本笔记的主要内容包含支持 HDR 渲染以及 HDR Bloom (约束闪烁问题和 Scattering Bloom)；Tone Mapping 算法的介绍；Color Grading 相关工具和 LUT Baking；Multiple Camera 和 Rendering Layers 的简单说明。"><link rel="shortcut icon" href="https://s2.loli.net/2022/09/08/Ygib4lfw6z1khnr.png"><link rel="canonical" href="https://ybniaobu.github.io/2025/03/13/2025-03-13-CustomSRP6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 鸟布","link":"链接: ","source":"来源: 鸟布的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity Custom SRP 基础（六）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-07 20:56:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/wechat%20avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/black.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鸟布的博客"><span class="site-name">鸟布的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity Custom SRP 基础（六）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-13T12:44:31.000Z" title="发表于 2025-03-13 20:44:31">2025-03-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-07T12:56:20.876Z" title="更新于 2025-04-07 20:56:20">2025-04-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/unity/">unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/unity/pipeline/">pipeline</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity Custom SRP 基础（六）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本笔记是关于 Unity 的<strong>自定义可编程渲染管线</strong>的入门基础，即 <strong>SRP (Scriptable Rendering Pipeline)</strong>，主要参考了著名的教程 <a target="_blank" rel="noopener" href="https://catlikecoding.com/">https://catlikecoding.com/</a> 的 Custom SRP Tutorial，以及知乎上各位图形学大神们的文章。  </p>
<p>笔者使用的 Unity 版本是 6000.0.27f1，Core RP Library 的版本是 17.0.3。</p>
</blockquote>
<h1 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h1><p>到目前为止，我们输出到相机的帧缓冲仍然是 LDR 格式，即 B8G8R8A8_SRGB 格式。这意味着输出的颜色都会被限制在 0.0 到 1.0 之间，任何大于 1.0 的颜色值都会被 clamp 到 1.0，相当于在片元着色器函数的结尾做了一次 <code>saturate()</code>。但是在 Shader 里计算时，部分像素的颜色值很可能会高于 1.0，特别是在多光源的情况下，这就会造成部分区域非常白，导致场景细节的丢失。</p>
<p>为了解决这一问题，我们就需要使用 <strong>HDR (High Dynamic Range，高动态范围)</strong> 的帧缓冲了，一般 HDR 会使用 R16G16B16A16_FLOAT 的格式（最大值为 65504），也有为了减少带宽的开销，而压缩成 R11G11B10_FLOAT 格式的。这样子大于 1.0 的颜色值就可以存储在纹理当中了，从而获取更大范围的黑暗或明亮值。但是大部分显示器仍然只能显示 sRGB 色彩空间的颜色（这里暂时不讨论支持 HDR 输出的显示器），即 [0, 255] 或 [0.0, 1.0] 范围的值，此时就需要将 HDR 重新映射回 LDR 值，而这个操作就叫做<strong>色调映射 Tone Mapping</strong>，该操作的主要目的就是尽可能地保留场景的黑暗与明亮细节，所以它本质上就是增强明暗的对比度。</p>
<blockquote>
<p>注意区分 Tone Mapping 和 <strong>Gamma 校正</strong>，这两个操作是相互独立的，Tonemapping 将 HDR 颜色转换到 LDR 颜色，但两者仍然都在线性空间，之后仍然需要做 Gamma 校正。  </p>
</blockquote>
<h2 id="支持-HDR-rendering"><a href="#支持-HDR-rendering" class="headerlink" title="支持 HDR rendering"></a>支持 HDR rendering</h2><p>我们可以在 RenderPipelineAsset 里面增加一个 bool 字段，用于控制 HDR 的开启。然后在创建 FrameBuffer 的地方根据该字段生成 HDR 格式：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">data.buffer.GetTemporaryRT(RenderTargetIDs.k_FrameBufferId, data.camera.pixelWidth, data.camera.pixelHeight, <span class="number">32</span>, FilterMode.Bilinear, asset.enableHDR ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);</span><br></pre></td></tr></table></figure>
<p>default HDR 格式就是 R16G16B16A16_FLOAT。这样子，我们的场景就会使用 HDR 渲染，打开 Frame Debugger，可以看到在最后输出之前渲染出来的图片颜色变深了，这就是因为渲染到了 HDR 的线性空间当中，所以看起来变暗了。但是我们不用关心最后输出时的 gamma 校正，因为在线性空间的设置下，Unity 会自动处理 gamma 校正问题。</p>
<h2 id="HDR-Bloom"><a href="#HDR-Bloom" class="headerlink" title="HDR Bloom"></a>HDR Bloom</h2><p>之前 LDR Bloom 的预过滤和采样过程中，都是将中间结果输出到 LDR 贴图当中的。那么我们首先应该将它们改为 HDR 贴图：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do bloom at half or quarter resolution</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Determine the iteration count</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Shader property and keyword setup</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HDR</span></span><br><span class="line">    RenderTextureFormat format = asset.enableHDRFrameBufferFormat ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prefilter</span></span><br><span class="line">    data.buffer.GetTemporaryRT(k_BloomPrefilterId, width, height, <span class="number">0</span>, FilterMode.Bilinear, format);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Downsample - gaussian pyramid</span></span><br><span class="line">    <span class="built_in">int</span> sourceId = k_BloomPrefilterId;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterationCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data.buffer.GetTemporaryRT(m_BloomPyramidUpIds[i], width, height, <span class="number">0</span>, FilterMode.Bilinear, format);</span><br><span class="line">        data.buffer.GetTemporaryRT(m_BloomPyramidDownIds[i], width, height, <span class="number">0</span>, FilterMode.Bilinear, format);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Upsample - bilinear or bicubic</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Final Blit</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Release RT</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子 Addictive Bloom 就可以在 HDR 下正常工作了。HDR Bloom 和 LDR Bloom 的重要区别在于，HDR Bloom 中一个特别大的值会影响到一个非常大的区域，即使是一个像素，也可能会产生非常高亮的 Bloom 区域。产生这个现象的原因就是平均值的极端值效应，本来 4 个像素平均，LDR 下无论怎么平均都是小于 1 的平均数，现在 HDR 下，4 个像素中一个像素值为 10，其他像素值再小，平均值也会被拉得很大。于是乎，就产生了 HDR Bloom 的一个最大弊端，也是必须要克服的弊端，即闪烁现象。</p>
<h3 id="Bloom-闪烁问题"><a href="#Bloom-闪烁问题" class="headerlink" title="Bloom 闪烁问题"></a>Bloom 闪烁问题</h3><p>HDR Bloom 的闪烁问题在镜头移动的情况下会格外严重，我这里 gif 就不放出来了，URP 下该现象就挺严重的（看了下 URP 的 Bloom Shader，确实没解决闪烁问题）。而解决方案是在 Prefilter 阶段做一次模糊处理，并使用以下权重做平均来降低动态范围，这个方法叫做 <strong>Karis Average</strong>：  </p>
<script type="math/tex; mode=display">weight = \cfrac {1} {1 + luminance}</script><p>在该权重下，亮度越高，权重越低。这个方法虽然损失一部分的 bloom 范围和亮度，但是能在一定程度减少 Bloom 闪烁问题，虽然做不到完全解决，完全解决可以说是不可能的。该方法的实现如下：①将 Prefilter 的 Bilinear 2 × 2 采样扩展为 6 × 6 的 box 核，在采样时（模糊平均前）应用 bloom threshold 提取较亮区域。②使用 Karis Average 在模糊时做加权平均，替代 box 核的算术平均，对颜色进行修正。</p>
<pre><code>#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl&quot;

float4 BloomPrefilterFrag(Varyings IN) : SV_TARGET
&#123;
    float3 color = float3(0.0, 0.0, 0.0);
    float2 offsets[9] = &#123; float2(0.0, 0.0), float2(-1.0, -1.0), float2(-1.0, 1.0), float2(1.0, -1.0), float2(1.0, 1.0), float2(-1.0, 0.0), float2(1.0, 0.0), float2(0.0, -1.0), float2(0.0, 1.0)&#125;;

    UNITY_UNROLL
    for (int i = 0; i &lt; 9; i++)
    &#123;
        float2 offset = offsets[i] * _BlitTexture_TexelSize.xy * 2.0;
        float3 c = ApplyBloomThreshold(SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv + offset, 0).rgb);
        float w = 1.0 / (Luminance(c) + 1.0);
        color += c * w;
        weight += w;
    &#125;
    color /= weight;

    color = max(color, 0.0);
    return float4(color, 1.0);
&#125;
</code></pre><p>亮度的计算之前《Unity Shader入门精要》读书笔记（四）中也讲过，Core RP Library 的 Color.hlsl 也提供了相关的函数。上面之所以在 offset 中乘以 2.0 是因为我们使用的是 bilinear 采样器，采样一次可以覆盖 2 × 2 个像素，这样我们使用一个 3 × 3 的像素之间距离为 2 的 box 核，就可以覆盖到 6 × 6 个像素。最后一定要将颜色 clamp 到 0 以上，否则画面有可能会出现黑块。</p>
<p>这样子就可以解决大部分的闪烁问题了。但上面代码还可以再优化一步，因为下采样阶段使用了高斯模糊，我们可以将上述代码再减少 4 次采样，即与中心点相邻的 4 个采样点：  </p>
<pre><code>float4 BloomPrefilterFrag(Varyings IN) : SV_TARGET
&#123;
    ...
    float2 offsets[5] = &#123; float2(0.0, 0.0), float2(-1.0, -1.0), float2(-1.0, 1.0), float2(1.0, -1.0), float2(1.0, 1.0)&#125;;

    for (int i = 0; i &lt; 5; i++)
    &#123;
        ...
    &#125;
    ...
&#125;
</code></pre><p>这将会使 Prefilter 阶段产生的结果中一个较亮像素变为 x 形状，可以点开 Frame Debugger 查看。但是经过一次下采样，这种图案样式就会消失。</p>
<h1 id="Scattering-Bloom"><a href="#Scattering-Bloom" class="headerlink" title="Scattering Bloom"></a>Scattering Bloom</h1><p>Scattering Bloom 和 Additive Bloom 在实现方法上是非常类似的，但是对于各自所想要呈现的效果却有所不同，这两种方法的出发点是不同的，故它们之间没有优劣之分。<strong>Addictive Bloom</strong> 更偏向艺术化的表达，相对 Scattering Bloom 更不遵守能量守恒，因为我们在上采样阶段不断叠加会导致 bloom 区域亮度超过了原本图片中的亮度。而 <strong>Scattering Bloom</strong> 考虑了能量守恒，它只模糊但不添加额外的亮度，这使得特别是在灯光或者发光物体使用物理光照单位时，能够更正确地表现出其原本拥有的亮度值。</p>
<p>Scattering Bloom 的实现步骤也比较简单，就是在上采样阶段使用 Scatter 属性在 high-resolution 和 low-resolution 的贴图之间做 lerp，而不是直接相加。这样我们上采样阶段最后得到的贴图的亮度值就不会发生变化，最后在叠加到 frame buffer 时（final blit 阶段）先将 Prefilter 阶段提取的较亮区域抠出来，再将上采样阶段得到的贴图贴上去。</p>
<h2 id="Scatter"><a href="#Scatter" class="headerlink" title="Scatter"></a>Scatter</h2><p>我们先在 Bloom 的 VolumeComponent 里增加一个 enum 用于切换 Addictive Bloom 和 Scattering Bloom，同时添加一个新的属性 scatter，其范围在 0 - 1：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> BloomMode</span><br><span class="line">&#123;</span><br><span class="line">    Additive,</span><br><span class="line">    Scattering</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">BloomDownscaleParameter</span> : <span class="title">VolumeParameter</span>&lt;<span class="title">BloomDownscaleMode</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BloomDownscaleParameter</span>(<span class="params">BloomDownscaleMode <span class="keyword">value</span>, <span class="built_in">bool</span> overrideState = <span class="literal">false</span></span>) : <span class="title">base</span>(<span class="params"><span class="keyword">value</span>, overrideState</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable, VolumeComponentMenu(<span class="string">&quot;YPipeline Post Processing/Bloom&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">SupportedOnRenderPipeline(typeof(YRenderPipelineAsset))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bloom</span> : <span class="title">VolumeComponent</span>, <span class="title">IPostProcessComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> BloomModeParameter mode = <span class="keyword">new</span> BloomModeParameter(BloomMode.Scattering, <span class="literal">true</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> ClampedFloatParameter scatter = <span class="keyword">new</span> ClampedFloatParameter(<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要为上采样阶段添加一个新的 Pass，我命名为了 BloomScatteringUpsampleFrag，我们要根据选择的模式选择对应的 Pass，同时 scatter 也通过之前说的 <code>_BloomIntensity</code> 传递：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do bloom at half or quarter resolution</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Determine the iteration count</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Shader property and keyword setup</span></span><br><span class="line">    <span class="built_in">float</span> bloomIntensity = settings.mode.<span class="keyword">value</span> == BloomMode.Additive ? <span class="number">1.0f</span> : settings.scatter.<span class="keyword">value</span>;</span><br><span class="line">    data.buffer.SetGlobalFloat(k_BloomIntensityId, bloomIntensity);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// HDR</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Prefilter</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Downsample - gaussian pyramid</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Upsample - bilinear or bicubic</span></span><br><span class="line">    <span class="built_in">int</span> upsamplePass = settings.mode.<span class="keyword">value</span> == BloomMode.Additive ? <span class="number">3</span> : <span class="number">4</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = iterationCount - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        BlitUtility.BlitTexture(data.buffer, m_BloomPyramidDownIds[i], m_BloomPyramidUpIds[i], BloomMaterial, upsamplePass);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Final Blit</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Release RT</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BloomScatteringUpsampleFrag 也只需要对原本的上采样函数做一个更改即可，即将返回值的叠加改为 lerp：  </p>
<pre><code>float4 BloomScatteringUpsampleFrag(Varyings IN) : SV_TARGET
&#123;
    #if _BLOOM_BICUBIC_UPSAMPLING
    float3 lowerTex = SampleTexture2DBicubic(_BloomLowerTexture, sampler_LinearClamp, IN.uv, _BloomLowerTexture_TexelSize.zwxy, (1.0).xx, 0.0).rgb;
    #else
    float3 lowerTex = SAMPLE_TEXTURE2D_LOD(_BloomLowerTexture, sampler_LinearClamp, IN.uv, 0).rgb;
    #endif

    float3 higherTex = SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv, 0).rgb;
    return float4(lerp(higherTex, lowerTex, _BloomIntensity), 1.0);
&#125;
</code></pre><p>可以看出 scatter 为 0 就意味着只使用金字塔最高层级的贴图，为 1 就只使用金字塔最低层级的贴图。为了确保中间层级都被使用，可以选择限制 scatter 的范围为 0.05 – 0.95。</p>
<h2 id="Final-Blit"><a href="#Final-Blit" class="headerlink" title="Final Blit"></a>Final Blit</h2><p>上面的步骤本质就是将较亮区域进行模糊，并在叠加的同时不额外增加亮度。为了保证能量守恒，我们叠加到原图时，也需要先将较亮区域从原图抠出来，再叠加上模糊后的较亮区域，从而呈现一种 Bloom 效果。创建一个新的 Pass，如下：  </p>
<pre><code>float4 BloomScatteringFinalBlitFrag(Varyings IN) : SV_TARGET
&#123;
    #if _BLOOM_BICUBIC_UPSAMPLING
    float3 lowerTex = SampleTexture2DBicubic(_BloomLowerTexture, sampler_LinearClamp, IN.uv, _BloomLowerTexture_TexelSize.zwxy, (1.0).xx, 0.0).rgb;
    #else
    float3 lowerTex = SAMPLE_TEXTURE2D_LOD(_BloomLowerTexture, sampler_LinearClamp, IN.uv, 0).rgb;
    #endif

    float3 higherTex = SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv, 0).rgb;

    lowerTex += higherTex - ApplyBloomThreshold(higherTex);
    return float4(lerp(higherTex, lowerTex, _BloomIntensity), 1.0);
&#125;
</code></pre><p>我们在原图片和有 bloom 效果的新图片使用 _BloomIntensity 做插值方便我们控制整体的 Bloom 强度。传递参数的工作如下，最好将 Scattering Bloom 和 Addictive Bloom 的 Intensity 属性分开，因为 Scattering Bloom 的 Intensity 的范围是 0 - 1 之间，而 Addictive Bloom 可以无限大：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Final Blit</span></span><br><span class="line">    bloomParams = settings.mode.<span class="keyword">value</span> == BloomMode.Additive ? <span class="keyword">new</span> Vector4(settings.intensity.<span class="keyword">value</span>, <span class="number">0.0f</span>) : <span class="keyword">new</span> Vector4(settings.finalIntensity.<span class="keyword">value</span>, <span class="number">0.0f</span>);</span><br><span class="line">    <span class="built_in">int</span> finalPass = settings.mode.<span class="keyword">value</span> == BloomMode.Additive ? <span class="number">3</span> : <span class="number">5</span>;</span><br><span class="line">    data.buffer.SetGlobalVector(k_BloomParamsId, bloomParams);</span><br><span class="line">    data.buffer.SetGlobalTexture(k_BloomLowerTextureID, <span class="keyword">new</span> RenderTargetIdentifier(lastDst));</span><br><span class="line">    BlitUtility.BlitTexture(data.buffer, RenderTargetIDs.k_FrameBufferId, BuiltinRenderTextureType.CameraTarget, BloomMaterial, finalPass);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子就实现了 Scattering Bloom，和 Addictive Bloom 的效果对比如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/19/FtsGQbrKnMxoh5q.png" width = "90%" height = "90%" alt="图94 - Scattering Bloom 和 Addictive Bloom 的效果对比"/>
</div>

<p>从上图可以看出，Scattering Bloom 的效果相对比较不易察觉的，它是一个相对更加真实的效果，没有改变场景的整体亮度，并且只有在亮度很大的时候才会展现得比较明显，它的这种特性只能在亲自体验后才能感觉到，只看上图可能感受不是很明显。Addictive Bloom 则改变了场景中的亮度，所以它看起来比 Scattering Bloom 的效果更明显，也更亮。</p>
<h1 id="Tone-Mapping"><a href="#Tone-Mapping" class="headerlink" title="Tone Mapping"></a>Tone Mapping</h1><p>Tone Mapping 经过了一个很长时间的发展，在这个过程中出现了很多的 tone mapping 算法。常见的有 <strong>Reinhard Tone Mapping</strong>、<strong>Uncharted 2 Filmic Tone Mapping</strong>、<strong>Khronos PBR Neutral Tone Mapping</strong>、<strong>ACES Tone Mapping</strong>、<strong>AgX Tone Mapping</strong>。</p>
<p>在实现上述 Tone Mapping 算法之前，先大致说一下 Tone Mapping 相关类在 CPU 端的准备工作。因为我们之前 Bloom 后处理完是直接绘制到 CameraTarget 的，我们要对 Bloom 完的结果进行 Tone Mapping，所以我们要先将 Bloom 的结果输出到一个纹理中，我命名为了 _BloomTexture。创建 RT，释放 RT 以及 BloomRenderer 中绘制代码的更改我这里就不做记录了，也比较简单。整个后处理管线的顺序问题，下面讲到 Color Grading 时再讨论。</p>
<p>Tone Mapping 的 VolumeComponent 和 PostProcessingRenderer 类，参考前面 Bloom 的写法就行，也没什么好说的，在 VolumeComponent 里创建对应的 Tone Mapping Mode，再根据选择的 mode 对应的 Shader Pass 去绘制 _BloomTexture 即可，最后输出到 CameraTarget。下面直接讲 Shader 里的处理，以及对应的效果了。为了相对更好地展示不同 Tone Mapping 算法的效果以及方便对比，一个基本的渲染图如下（这张参考图的场景颜色比较少，可能不是很能展现不同 Tone Mapping 之间的不同），场景中有一个范围较大的点光源，和台灯位置的聚光灯，聚光灯亮度较高，可以看到台灯照亮位置已经有点过曝了，并且使用了 Scattering Bloom：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/21/eXAwZqBa1fY5GxO.jpg" width = "80%" height = "80%" alt="图95 - 未做 Tone Mapping 前的基准图"/>
</div>

<h2 id="Reinhard"><a href="#Reinhard" class="headerlink" title="Reinhard"></a>Reinhard</h2><p>Reinhard Tone Mapping 来自于这篇论文：<a target="_blank" rel="noopener" href="https://www-old.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf">https://www-old.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf</a> 。从该篇论文中，可以提炼出 3 种应用：  </p>
<p><strong>①</strong>第一个是最基础的 Reinhard tone mapping，可以称为 “Simple” Reinhard：  </p>
<script type="math/tex; mode=display">L_d = \cfrac {L} {1 + L}</script><pre><code>float3 Reinhard_Simple(float3 color)
&#123;
    return color / (color + 1.0);
&#125;
</code></pre><p>在 Unity 中实现后的基准参考图效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/21/fpNIHz4c6UOKJ1j.jpg" width = "80%" height = "80%" alt="图96 - Reinhard Simple"/>
</div>

<p>可以感受到效果像是蒙了一层灰色。</p>
<p><strong>②</strong>第二个是 “Simple” Reinhard 的扩展，可以称为 “Extended” Reinhard：  </p>
<script type="math/tex; mode=display">L_d = \cfrac {L(1 + \cfrac {L} {L_{white}^2})} {1 + L}</script><pre><code>float3 Reinhard_Extended(float3 color, float minWhite)
&#123;
    float minWhite2 = minWhite * minWhite;
    float3 numerator = color * (1.0 + color / minWhite2);
    return numerator / (1.0 + color);
&#125;
</code></pre><p>上述公式中的 $\,L_{white}\,$ 是用户控制的变量，代表着在场景中纯白色的最低亮度值。当 $\,L_{white}\,$ 趋向于无穷大时，”Extended” Reinhard 就会跟 “Simple” Reinhard 一样。$\,L_{white}\,$ 设置为 2 时的基准参考图效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/21/sU2So8fgZdOL1Bb.jpg" width = "80%" height = "80%" alt="图97 - Reinhard Extended（minWhite = 2）"/>
</div>

<p>效果比 Reinhard Simple 要鲜艳一点，但整体仍然灰蒙蒙的。</p>
<p><strong>③</strong>从上面公式可以看出，理论上我们不应该直接用颜色进行计算，而应该用亮度值，因为 L 代表着 luminance。但是因为我们无法将 RGB 转化为 luminance 后，再从 luminance 转换回 RGB。所以下面代码中，使用 Tone Mapping 前的 luminance 和后的 luminance 对最后的输出颜色做了一次缩放：  </p>
<pre><code>float3 Reinhard_ExtendedLuminance(float3 color, float minWhite)
&#123;
    float l_in = Luminance(color);
    float minWhite2 = minWhite * minWhite;
    float numerator = l_in * (1.0 + l_in / minWhite2);
    float l_out = numerator / (1.0 + l_in);
    return color * l_out / l_in;
&#125;
</code></pre><p>$\,L_{white}\,$ 还是设置为 2，效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/21/dv6UhEnNG5uM7I4.jpg" width = "80%" height = "80%" alt="图98 - Reinhard Luminance"/>
</div>

<p>仍然没能解决灰蒙蒙的问题。</p>
<h2 id="Uncharted-2-Filmic"><a href="#Uncharted-2-Filmic" class="headerlink" title="Uncharted 2 Filmic"></a>Uncharted 2 Filmic</h2><p>Uncharted 2 Filmic Tone Mapping 最早来自于 GDC 2010 的一个演讲 Uncharted 2: HDR Lighting，演讲者为顽皮狗 Naughty Dog 公司的 John Hable。后来 John Hable 在自己的博客中做了总结和修改：<a target="_blank" rel="noopener" href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">http://filmicworlds.com/blog/filmic-tonemapping-operators/</a> 。之后他又提出了对 Filmic 曲线进行更多控制的手段：<a target="_blank" rel="noopener" href="http://filmicworlds.com/blog/filmic-tonemapping-with-piecewise-power-curves/">http://filmicworlds.com/blog/filmic-tonemapping-with-piecewise-power-curves/</a> 。本篇文章只涉及他第一篇文章内的 Uncharted 2 Filmic Tone Mapping，不涉及对 Filmic Tonemapping curves 进行自定义。代码如下：  </p>
<pre><code>float3 Uncharted2(float3 x)
&#123;
    const float A = 0.15;
    const float B = 0.50;
    const float C = 0.10;
    const float D = 0.20;
    const float E = 0.02;
    const float F = 0.30;
    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
&#125;

float3 Uncharted2Filmic(float3 color, float exposureBias)
&#123;
    float3 curr = Uncharted2(color * exposureBias);
    const float W = 11.2;
    float3 whiteScale = 1.0 / Uncharted2(W);
    return whiteScale * curr;
&#125;
</code></pre><p>exposureBias 在博客文章中，默认值为 2，下面实现后的基准参考图的设置也是 2：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/21/lFcvCnE7x3HZz9g.jpg" width = "80%" height = "80%" alt="图99 - Uncharted 2 Filmic"/>
</div>

<h2 id="Khronos-PBR-Neutral"><a href="#Khronos-PBR-Neutral" class="headerlink" title="Khronos PBR Neutral"></a>Khronos PBR Neutral</h2><p>Khronos PBR Neutral Tone Mapping 是由 Khronos Group 组织提出的，该组织由很多国际知名多媒体行业领导者创立，致力于发展开放标准的应用程序接口 API。Vulkan API 就是由该组织研发并发布的。该 Tone Mapping 的研发者还写了一篇文章，说明了该算法所要解决的问题：<a target="_blank" rel="noopener" href="https://modelviewer.dev/examples/tone-mapping">https://modelviewer.dev/examples/tone-mapping</a> 。顾名思义，该算法想要更好地体现 PBR 所展现出来的最真实最还原的状态，保留其色调和饱和度，代码如下：  </p>
<pre><code>float3 KhronosPBRNeutral(float3 color)
&#123;
    const float startCompression = 0.76;
    const float desaturation = 0.15;

    float x = min(color.r, min(color.g, color.b));
    float offset = x &lt; 0.08 ? x - 6.25 * x * x : 0.04;
    color -= offset;

    float peak = max(color.r, max(color.g, color.b));
    if (peak &lt; startCompression) return color;

    const float d = 0.24;
    float newPeak = 1.0 - d * d / (peak + d - startCompression);
    color *= newPeak / peak;

    float g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.);
    return lerp(color, newPeak * float3(1.0, 1.0, 1.0), g);
&#125;
</code></pre><p>实现后，基准参考图效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/21/qSl2zf1cO7V8xvG.jpg" width = "80%" height = "80%" alt="图100 - Khronos PBR Neutral"/>
</div>

<h2 id="ACES"><a href="#ACES" class="headerlink" title="ACES"></a>ACES</h2><p><strong>Academy Color Encoding System（ACES）</strong> 是由美国电影艺术与科学学院（AMPAS）和行业合作伙伴开发的开放式色彩管理和互换系统，它规范了所有不同类型的项目中的色彩科学，其创立的目的是为行业提供标准化的色彩管理系统。ACES 是开源的，具体详见 <a target="_blank" rel="noopener" href="https://github.com/ampas/aces">https://github.com/ampas/aces</a> 。整套色彩转换工作流程极其复杂，下面简单梳理一下（可能描述得不是很准确）：  </p>
<p>首先 ACES 流程有如下几个组成部分：<br><strong>①Input Device Transform (IDT)</strong>：这一步骤也称为 Input Transform，主要目的是将输入设备颜色数据转换至 ACES 色彩空间。ACES 色彩空间又包括：<br>&emsp;&emsp; - <strong>ACES2065-1</strong>：这是一个非常广域的线性色彩空间，比人眼还广，主要是为了存储归档以及部门之间传递素材使用；<br>&emsp;&emsp; - <strong>ACEScc</strong>、<strong>ACEScct</strong>：log 色彩空间，主要用于色彩校正或调色；<br>&emsp;&emsp; - <strong>ACEScg</strong>：线性色彩空间，主要用于 CG 或特效制作。  </p>
<p>下面三个组成部分又合称为 ACES viewing pipeline，其中：<br><strong>②Look Modification Transform (LMT)</strong>：这一步骤不是必需的，主要是给艺术家更方便地调色，LMT 始终在 ACES 色彩空间中工作；  </p>
<p>③ 和 ④ 又合称为 Output Transform，要将 ACES 色彩空间转换为非 ACES 色彩空间都需要有 RRT 的参与：<br><strong>③Reference Rendering Transform (RRT)</strong>：这步就是核心的一步，将 IDT 转换获得的标准的、高精度的、高动态范围的场景参考线性图像数据，使用一个 S 形曲线，映射到输出颜色编码空间以适用于参考显示设备的观看。<br><strong>④Output Device Transform (ODT)</strong> 这是 ACES 色彩管理流程中图像信号最终输出转换，就是转换成最终播出设备所需要的色彩空间，例如 Rec.709、Rec.2020、DCI-P3 等。</p>
<p>可以看到一个完整的 ACES 流程非常复杂，所幸的是 Unity 提供了相关的函数，在 Core RP Library 的 ACES.hlsl 和 Color.hlsl 文件中，调用代码如下（顺便提一下，Unity 的 <code>AcesTonemap()</code> 函数默认情况下也是使用的较为复杂的拟合函数，除非我们设置 <code>TONEMAPPING_USE_FULL_ACES</code> 为 1），先将颜色转换至 ACES 色彩空间，再映射：  </p>
<pre><code>float4 ToneMappingACESFullFrag(Varyings IN) : SV_TARGET
&#123;
    float3 color = SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv, 0).rgb;
    return float4(AcesTonemap(unity_to_ACES(color)), 1.0);
&#125;
</code></pre><p>由于完整的 ACES 流程计算量较大，所以有大佬提出了提出了拟合 ACES 曲线的代码，比较出名的有 Stephen Hill Fit 和 Krzysztof Narkowicz Fit，代码分别来源于：<a target="_blank" rel="noopener" href="https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl">https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl</a> ，<a target="_blank" rel="noopener" href="https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/">https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/</a> 。</p>
<p><strong>Stephen Hill Fit</strong>：  </p>
<pre><code>static const float3x3 ACESInputMat =
&#123;
    &#123;0.59719, 0.35458, 0.04823&#125;,
    &#123;0.07600, 0.90834, 0.01566&#125;,
    &#123;0.02840, 0.13383, 0.83777&#125;
&#125;;

static const float3x3 ACESOutputMat =
&#123;
    &#123; 1.60475, -0.53108, -0.07367&#125;,
    &#123;-0.10208,  1.10813, -0.00605&#125;,
    &#123;-0.00327, -0.07276,  1.07602&#125;
&#125;;

float3 RRTAndODTFit(float3 v)
&#123;
    float3 a = v * (v + 0.0245786f) - 0.000090537f;
    float3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;
    return a / b;
&#125;

float3 ACESStephenHillFit(float3 color)
&#123;
    color = mul(ACESInputMat, color);

    // Apply RRT and ODT
    color = RRTAndODTFit(color);

    color = mul(ACESOutputMat, color);

    // Clamp to [0, 1]
    color = saturate(color);
    return color;
&#125;
</code></pre><p><strong>Krzysztof Narkowicz Fit</strong>：</p>
<pre><code>float3 ACESApproxFit(float3 color)
&#123;
    color *= 0.6;
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return saturate(color * (a * color + b)/(color * (c * color + d) + e));
&#125;
</code></pre><p>Krzysztof Narkowicz Fit 相对来说拟合误差更大，但是计算量小很多。上述 3 种实现方式的效果就不一一展示了，效果大差不差，下面展示的是 Stephen Hill Fit 的基准参考图效果：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/21/l3PMc9TmE4oVK27.jpg" width = "80%" height = "80%" alt="图101 - ACES"/>
</div>

<h2 id="AgX"><a href="#AgX" class="headerlink" title="AgX"></a>AgX</h2><p>AgX 因为 Blender 在使用开始逐渐出名，是由 Troy Sobotka 开发的，详见 <a target="_blank" rel="noopener" href="https://github.com/sobotka">https://github.com/sobotka</a> ，最初为 OpenColorIO 编写。<strong>OpenColorIO (OCIO)</strong> 是一个开源的色彩管理框架，专为电影、视觉效果、动画和游戏等视觉创作行业设计。OCIO 包含一个配置文件：config.ocio，该配置文件包含了 LUT 文件的索引，支持多种 LUT 格式，如 .cube、.3dl、.spi1d 等。LUT 的相关知识，后面讲 Color Grading 时会详细讲解。</p>
<p>AgX 的 LUT 生成代码可以看 <a target="_blank" rel="noopener" href="https://github.com/sobotka/SB2383-Configuration-Generation/blob/main/AgX.py">https://github.com/sobotka/SB2383-Configuration-Generation/blob/main/AgX.py</a> 或 <a target="_blank" rel="noopener" href="https://github.com/EaryChow/AgX_LUT_Gen">https://github.com/EaryChow/AgX_LUT_Gen</a> 。有人将其代码转换为了 Shader 代码，见 <a target="_blank" rel="noopener" href="https://github.com/MrLixm/AgXc">https://github.com/MrLixm/AgXc</a> 或 <a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/dtSGD1">https://www.shadertoy.com/view/dtSGD1</a> 。但实现起来仍然过于复杂，我又在网上找到了近似的方案：详见 <a target="_blank" rel="noopener" href="https://iolite-engine.com/blog_posts/minimal_agx_implementation">https://iolite-engine.com/blog_posts/minimal_agx_implementation</a> 或 <a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/cd3XWr">https://www.shadertoy.com/view/cd3XWr</a> 。近似代码如下：  </p>
<pre><code>// 0: Default, 1: Golden, 2: Punchy
#define AGX_LOOK 0

float3 AgXDefaultContrastApprox(float3 x)
&#123;
    float3 x2 = x * x;
    float3 x4 = x2 * x2;

    return + 15.5     * x4 * x2
        - 40.14    * x4 * x
        + 31.96    * x4
        - 6.868    * x2 * x
        + 0.4298   * x2
        + 0.1191   * x
        - 0.00232;
&#125;

float3 AgX(float3 val)
&#123;
    const float3x3 agx_mat = float3x3( 0.842479062253094,   0.0784335999999992,  0.0792237451477643,
                                    0.0423282422610123,  0.878468636469772,   0.0791661274605434,
                                    0.0423756549057051,  0.0784336,           0.879142973793104);

    const float min_ev = -12.47393f;
    const float max_ev = 4.026069f;

    // Input transform
    val = mul(agx_mat, val);

    // Log2 space encoding
    val = clamp(log2(val), min_ev, max_ev);
    val = (val - min_ev) / (max_ev - min_ev);

    // Apply sigmoid function approximation
    val = AgXDefaultContrastApprox(val);

    return val;
&#125;

float3 AgXEotf(float3 val)
&#123;
    const float3x3 agx_mat_inv = float3x3(  1.19687900512017,    -0.0980208811401368,  -0.0990297440797205,
                                        -0.0528968517574562,   1.15190312990417,    -0.0989611768448433,
                                        -0.0529716355144438,  -0.0980434501171241,   1.15107367264116);

    // Undo input transform
    val = mul(agx_mat_inv, val);

    // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display
    // NOTE: We&#39;re linearizing the output here. Comment/adjust when not using a sRGB render target
    val = pow(val, 2.2);

    return val;
&#125;

float3 AgXLook(float3 val)
&#123;
    const float3 lw = float3(0.2126, 0.7152, 0.0722);
    float luma = dot(val, lw);

    // Default look
    float3 offset = float3(0.0, 0.0, 0.0);
    float3 slope = float3(1.0, 1.0, 1.0);
    float3 power = float3(1.0, 1.0, 1.0);
    float sat = 1.0;

    #if AGX_LOOK == 1
    // Golden
    slope = float3(1.0, 0.9, 0.5);
    power = float3(0.8, 0.8, 0.8);
    sat = 0.8;
    #elif AGX_LOOK == 2
    // Punchy
    slope = float3(1.0, 1.0, 1.0);
    power = float3(1.35, 1.35, 1.35);
    sat = 1.4;
    #endif

    // ASC CDL
    val = pow(val * slope + offset, power);
    return luma + sat * (val - luma);
&#125;

float3 AgXApprox(float3 color)
&#123;
    color = AgX(color);
    color = AgXLook(color);
    color = AgXEotf(color);
    return color;
&#125;
</code></pre><div  align="center">  
<img src="https://s2.loli.net/2025/03/21/PSK4FfIHzbQ8C7l.jpg" width = "80%" height = "80%" alt="图102 - AgX default"/>
</div>

<div  align="center">  
<img src="https://s2.loli.net/2025/03/21/dyEtIKrWqRm5P4Y.jpg" width = "80%" height = "80%" alt="图103 - AgX Punchy"/>
</div>


<h1 id="Color-Grading"><a href="#Color-Grading" class="headerlink" title="Color Grading"></a>Color Grading</h1><p>从理论上来说，调色阶段可以分为两个步骤：①<strong>色彩校正 Color Correction</strong>，该步骤的主要目的是让画面进入一个中性的基线，以便开始调色工作，其中包括调整白平衡、平衡曝光、减少高光、增加中间色调和降噪等等。色彩校正完进入 ②<strong>色彩分级 Color Grading</strong>，即风格化地调整颜色，以满足美学上的需求。但是在实际操作中，人们不会特别地区分这两个步骤，常常将它们合并称为 Color Grading 或者 Color Correction。而且对于游戏来说，我们得到的渲染图在没调色前，通常来讲就已经处于相对来说较为中性的状态，故可以直接进行 Color Grading 工作。</p>
<p>下面要讲解的 Color Grading 工具有：<strong>Color Adjustments</strong>、<strong>White Balance</strong> 和 <strong>Shadows Midtones Highlights</strong>，基本上参考的是 URP 的实现。其他 Color Grading 工具诸如 <strong>Spilt Toning</strong>、<strong>Channel Mixer</strong>、<strong>Lift Gamma Gain</strong>、<strong>Color Curves</strong> 等就不在这里一一进行阐述了，直接抄 URP 或者 HDRP 的实现就可以。而诸如 <strong>Vignette</strong>、<strong>Film Grain</strong>、<strong>Chromatic Aberration</strong>、<strong>Depth of Field</strong>、<strong>Len Distortion</strong>、<strong>Len Flare</strong>、<strong>Panini Projection</strong> 等等效果，并不属于 Color Grading 范畴，故不在文章中说明了，在 URP 或 HDRP 中，这些效果会和 <strong>Bloom</strong> 一起在名为 UberPost 或 FinalPass 的 shader 里进行混合计算。Unity 也会将所有的 Color Grading 工具（包含 <strong>Tone Mapping</strong>）烘焙进一个 LUT Texture，然后也是在 UberPost shader 中进行混合，应用至原渲染图，这个在后面讲 LUT 时会提到。</p>
<p>上述所有后处理效果的执行，其实是有个顺序的问题的，比如 Bloom 应该在 Color Grading 前还是后，不同的顺序出来的效果是不同的。但是代码中的顺序是固定的，要调整需要直接更改代码，较为麻烦，除非专门开发一个连连看的工具用于生成 Shader 代码。整个后处理流程的顺序我基本上参考了 URP 或者 HDRP 的执行顺序，而 Color Grading 各个工具的执行顺序我参考了调色的基本顺序，即先整体再局部，最后艺术风格调整，和 URP 或者 HDRP 略有不同。其实这个执行顺序是仁者见仁智者见智的，我们写 SRP 的时候应该弄一个普适的顺序，然后在具体项目当中，再根据需求去调整顺序，甚至删减未用到的后处理效果，最终都是要服务于需求的。下面介绍的工具的应用顺序，我是先 White Balance -&gt; Color Filter &amp; Hue Shift -&gt; Exposure -&gt; Saturation -&gt; Contrast -&gt; Shadows Midtones Highlights &amp; Split Toning &amp; Lift Gamma Gain 的。</p>
<p>这里额外提一下，从理论上来说 Color Grading 应该发生在 Tone Mapping 和 Gamma Correction 后的 sRGB 色彩空间上，因为这样 Color Grading 最直观也最容易使用。但是这样存在一个问题，就是对于 HDR 显示屏而言，无法统一 HDR 和 LDR 的 Color Grading 的参数，因为 HDR 不需要 Tone Mapping，这就造成了 HDR 和 LDR 的不一致性。为了统一参数，我们会将 Color Grading 发生在 Tone Mapping 之前，这样无论输出在 HDR 还是 LDR 的显示屏上，颜色是一致的。</p>
<h2 id="Color-Adjustments"><a href="#Color-Adjustments" class="headerlink" title="Color Adjustments"></a>Color Adjustments</h2><p>Color Adjustments 工具主要包括曝光度 Exposure、对比度 Contrast、饱和度 Saturation、色调改变 Hue Shift 和颜色过滤 Color Filter。这些参数的范围，可以参考如下 VolumeComponent 代码（摘自 URP）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GlobalColorCorrections</span> : <span class="title">VolumeComponent</span>, <span class="title">IPostProcessComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> FloatParameter postExposure = <span class="keyword">new</span> FloatParameter(<span class="number">0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClampedFloatParameter contrast = <span class="keyword">new</span> ClampedFloatParameter(<span class="number">0f</span>, <span class="number">-100f</span>, <span class="number">100f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ColorParameter colorFilter = <span class="keyword">new</span> ColorParameter(Color.white, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClampedFloatParameter hueShift = <span class="keyword">new</span> ClampedFloatParameter(<span class="number">0f</span>, <span class="number">-180f</span>, <span class="number">180f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClampedFloatParameter saturation = <span class="keyword">new</span> ClampedFloatParameter(<span class="number">0f</span>, <span class="number">-100f</span>, <span class="number">100f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后传递给 Shader：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">buffer.SetGlobalVector(colorAdjustmentsId, <span class="keyword">new</span> Vector4(</span><br><span class="line">        Mathf.Pow(<span class="number">2f</span>, m_ColorAdjustments.postExposure.<span class="keyword">value</span>),</span><br><span class="line">        m_ColorAdjustment.contrast.<span class="keyword">value</span> * <span class="number">0.01f</span> + <span class="number">1f</span>,</span><br><span class="line">        m_ColorAdjustment.hueShift.<span class="keyword">value</span> * (<span class="number">1f</span> / <span class="number">360f</span>),</span><br><span class="line">        m_ColorAdjustment.saturation.<span class="keyword">value</span> * <span class="number">0.01f</span> + <span class="number">1f</span></span><br><span class="line">    ));</span><br><span class="line">buffer.SetGlobalColor(colorFilterId, m_ColorAdjustment.colorFilter.<span class="keyword">value</span>.linear);</span><br></pre></td></tr></table></figure>
<h3 id="Exposure-Saturation-Contrast"><a href="#Exposure-Saturation-Contrast" class="headerlink" title="Exposure Saturation Contrast"></a>Exposure Saturation Contrast</h3><p>亮度、饱和度和对比度调整的逻辑在<a href="https://ybniaobu.github.io/2023/12/19/2023-12-19-UnityShader4/#%E8%B0%83%E6%95%B4%E5%B1%8F%E5%B9%95%E7%9A%84%E4%BA%AE%E5%BA%A6%E3%80%81%E9%A5%B1%E5%92%8C%E5%BA%A6%E5%92%8C%E5%AF%B9%E6%AF%94%E5%BA%A6">《Unity Shader入门精要》读书笔记（四）</a> 中有涉及到，可以参考里面的实现。实现的逻辑和下面要讲的是类似的。</p>
<p><strong>①Exposure</strong>：<br>最常见的表达曝光等级的参数是摄像机镜头的<strong>光圈系数 F-stop</strong>，光圈系数表达了镜头焦距除以入射瞳直径，即相对孔径的倒数。在实际使用中，通常都是用光圈系数来间接表示相对孔径的大小，如 f/1，f/1.4，f/2，f/2.8，f/4，f/5.6，f/8，f/11，f/16，f/22，f/32，f/44，f/64，可以看出每个级数之间的比为 $\,\sqrt 2\,$。而光圈 f 值愈小，在同一单位时间内的进光量便愈多，而且上一级的进光量刚是下一级的两倍。这也是为什么传递 Exposure 参数时，Exposure 作为 2 的指数。然后直接在 Shader 中使用传递过来的曝光参数做乘积即可：  </p>
<pre><code>float3 Exposure(float3 color)
&#123;
    return color * _ColorAdjustmentsParams.x;
&#125;
</code></pre><p><strong>②Saturation</strong>：<br>饱和度就是在灰色版本的图片和原图片之间进行插值，获取灰色版本的图片就是将 RGB 值转换为 3 个通道都一样的值，但保留像素原本的亮度，这样才能区分物体，否则整张图片就是统一的灰色，这将和对比度没有区别了。但是由于眼睛对红、绿、蓝的感知力是不同的，所以需要亮度转换公式，Core RP Library 的 Color.hlsl 提供了转换的函数 <code>Luminance()</code>。</p>
<pre><code>float3 Saturation(float3 color)
&#123;
    float luminance = Luminance(color);
    return lerp(float3(luminance, luminance, luminance), color, _ColorAdjustmentsParams.w);
&#125;
</code></pre><p><strong>③Contrast</strong>：<br>对比度就是在中灰度（rgb 都为 0.5）和原图片之间进行插值，但是直接插值可能会导致阴影处的值低于 0，从而丢失暗处细节，所以会先将 linear 空间颜色转换至 log 空间进行对比度调整，再转换回线性空间，以确保值不会低于 0：  </p>
<pre><code>float3 Contrast(float3 color)
&#123;
    color = LinearToLogC(color);
    color = lerp(float3(0.5, 0.5, 0.5), color, _ColorAdjustmentsParams.y);
    return LogCToLinear(color);
&#125;
</code></pre><p>Exposure Saturation Contrast 三个效果展示如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/04/01/yFCUYxaeV3Hpubw.png" width = "100%" height = "100%" alt="图104 - 左图：原图，右图：调整 Exposure 为 1，Saturation 为 50，Contrast 为 20。"/>
</div>

<h3 id="Color-Filter-amp-Hue-Shift"><a href="#Color-Filter-amp-Hue-Shift" class="headerlink" title="Color Filter &amp; Hue Shift"></a>Color Filter &amp; Hue Shift</h3><p>Color Filter 就不用讲了，直接乘上颜色就行。Hue Shift 就是将 RGB 转换至 HSV 颜色空间，然后调整色相 H 就行。之所以将 hueShift 参数设置为 -180 到 180，是为了模拟色轮 color wheel：  </p>
<pre><code>float3 HueShift(float3 color)
&#123;
    color = RgbToHsv(color);
    float hue = color.x + _ColorAdjustmentsParams.z;
    color.x = RotateHue(hue, 0.0, 1.0);
    return HsvToRgb(color);
&#125;
</code></pre><p>效果就不展示了。</p>
<h2 id="White-Balance"><a href="#White-Balance" class="headerlink" title="White Balance"></a>White Balance</h2><p>关于色温和白平衡等相关色度学知识，足以开好几篇文章进行讲解，由于篇幅所限，这里就简单介绍一下，不深入。以后 SRP 需要基于物理的灯光和摄像机时再详细处理（又挖了个坑）。</p>
<p>首先人眼具有<strong>色彩恒常性 Color Constancy</strong>，能够补偿光源变化带来的颜色变化从而使物体被视为相同的颜色，即拥有自动白平衡的能力。这种能力使我们在日光、阴天、室内照明等不同光照条件下，仍然能够识别出物体的颜色。例如，一张白纸在日光下和在钨丝灯下看起来仍然是白色，即使这两种光源的色温差异很大。但是图像传感器是没有自动白平衡这个功能的，故不同色温的光下白色物体是不同颜色的。</p>
<p>所以<strong>白平衡 White Balance</strong> 的目标是把不同光源下的白色物体都矫正成人眼认知中的白色，让图像中不存在色偏。由于白色不含任何色度信息，其显色效果最佳，因此它为被选定为基准色，即所谓的<strong>白点 White Point</strong>。每个色彩空间都有一个特定的白点，例如 sRGB 、 Adobe RGB 和 Display-P3，白点是 D65，色温约为 6500K；对于 DCI-P3 白点是 DCI 白点，色温约为 6300K。</p>
<p>白平衡的算法其实有很多种，包含<strong>完美反射算法 White Patch Algorithm</strong>、<strong>灰色世界算法 Gray World Algorithm</strong> 等等，这里先直接抄 Unity 的实现，日后有更高级的需求时，再了解算法并修改。Unity 的实现中，有两个参数 Temperature 和 Tint，我们使用 Core RP library 的 <code>ColorUtils.ColorBalanceToLMSCoeffs()</code> 函数将这两个系数转换为 LMS 色彩空间的系数：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WhiteBalance</span> : <span class="title">VolumeComponent</span>, <span class="title">IPostProcessComponent</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> ClampedFloatParameter temperature = <span class="keyword">new</span> ClampedFloatParameter(<span class="number">0f</span>, <span class="number">-100</span>, <span class="number">100f</span>);</span><br><span class="line">        <span class="keyword">public</span> ClampedFloatParameter tint = <span class="keyword">new</span> ClampedFloatParameter(<span class="number">0f</span>, <span class="number">-100</span>, <span class="number">100f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">data.buffer.SetGlobalVector(k_WhiteBalanceId, ColorUtils.ColorBalanceToLMSCoeffs(m_WhiteBalance.temperature.<span class="keyword">value</span>, m_WhiteBalance.tint.<span class="keyword">value</span>));</span><br></pre></td></tr></table></figure>
<p>然后在 Shader 中在 LMS 色彩空间乘上系数即可：  </p>
<pre><code>float3 WhiteBalance(float3 color)
&#123;
    color = LinearToLMS(color);
    color *= _WhiteBalance.rgb;
    return LMSToLinear(color);
&#125;
</code></pre><p>白平衡效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/04/01/luvLU8Z3rQmBVtJ.png" width = "100%" height = "100%" alt="图105 - 左图：画面偏冷（temperature 为 -10），右图：画面偏暖（temperature 为 20）。"/>
</div>

<h2 id="Shadows-Midtones-Highlights"><a href="#Shadows-Midtones-Highlights" class="headerlink" title="Shadows Midtones Highlights"></a>Shadows Midtones Highlights</h2><p><strong>Shadows Midtones Highlights</strong>、<strong>Split Toning</strong> 和 <strong>Lift Gamma Gain</strong> 这三个工具实现的方法和目的都是类似的，都是调整图片的<strong>亮部 Highlights</strong>、<strong>暗部 Shadows</strong> 或者<strong>灰部 Midtones</strong>。他们的区别在于 Shadows Midtones Highlights 工具对亮部暗部以及灰部的调整具有一定的截断性，相对来说不是很平滑。而 Lift Gamma Gain 工具对亮部暗部以及灰部的调整比较平滑，但是存在相互影响的问题。Split Toning 工具则是为了增加明暗对比度，调整明暗颜色，所以它只有对亮部和暗部的调整。这里只介绍 Shadows Midtones Highlights 的实现，其余的实现直接看 URP 或 HDRP。</p>
<p>Shadows Midtones Highlights 工具的参数有如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShadowsMidtonesHighlights</span> : <span class="title">VolumeComponent</span>, <span class="title">IPostProcessComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector4Parameter shadows = <span class="keyword">new</span> Vector4Parameter(<span class="keyword">new</span> Vector4(<span class="number">1f</span>, <span class="number">1f</span>, <span class="number">1f</span>, <span class="number">0f</span>));</span><br><span class="line">    <span class="keyword">public</span> Vector4Parameter midtones = <span class="keyword">new</span> Vector4Parameter(<span class="keyword">new</span> Vector4(<span class="number">1f</span>, <span class="number">1f</span>, <span class="number">1f</span>, <span class="number">0f</span>));</span><br><span class="line">    <span class="keyword">public</span> Vector4Parameter highlights = <span class="keyword">new</span> Vector4Parameter(<span class="keyword">new</span> Vector4(<span class="number">1f</span>, <span class="number">1f</span>, <span class="number">1f</span>, <span class="number">0f</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> MinFloatParameter shadowsStart = <span class="keyword">new</span> MinFloatParameter(<span class="number">0f</span>, <span class="number">0f</span>);</span><br><span class="line">    <span class="keyword">public</span> MinFloatParameter shadowsEnd = <span class="keyword">new</span> MinFloatParameter(<span class="number">0.5f</span>, <span class="number">0f</span>);</span><br><span class="line">    <span class="keyword">public</span> MinFloatParameter highlightsStart = <span class="keyword">new</span> MinFloatParameter(<span class="number">0.5f</span>, <span class="number">0f</span>);</span><br><span class="line">    <span class="keyword">public</span> MinFloatParameter highlightsEnd = <span class="keyword">new</span> MinFloatParameter(<span class="number">1f</span>, <span class="number">0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要 URP 或 HDRP 编辑器中的色轮工具对参数进行调整，抄 VolumeComponentEditor 的相关代码，因代码量比较大，就不展示了。然后还是使用 Core RP library 的 ColorUtils 内的一个函数传递参数：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (shadows, midtones, highlights) = ColorUtils.PrepareShadowsMidtonesHighlights(m_ShadowsMidtonesHighlights.shadows.<span class="keyword">value</span>, </span><br><span class="line">    m_ShadowsMidtonesHighlights.midtones.<span class="keyword">value</span>, m_ShadowsMidtonesHighlights.highlights.<span class="keyword">value</span>);</span><br><span class="line">data.buffer.SetGlobalVector(k_SMHShadowsID, shadows);</span><br><span class="line">data.buffer.SetGlobalVector(k_SMHMidtonesID, midtones);</span><br><span class="line">data.buffer.SetGlobalVector(k_SMHHighlightsID, highlights);</span><br><span class="line">data.buffer.SetGlobalVector(k_SMHRangeID, <span class="keyword">new</span> Vector4(m_ShadowsMidtonesHighlights.shadowsStart.<span class="keyword">value</span>, m_ShadowsMidtonesHighlights.shadowsEnd.<span class="keyword">value</span>, </span><br><span class="line">    m_ShadowsMidtonesHighlights.highlightsStart.<span class="keyword">value</span>, m_ShadowsMidtonesHighlights.highlightsEnd.<span class="keyword">value</span>));</span><br></pre></td></tr></table></figure>
<p>然后 Shader 中：  </p>
<pre><code>float3 ShadowsMidtonesHighlights(float3 color)
&#123;
    float luminance = Luminance(color);
    float shadowsWeight = 1.0 - smoothstep(_SMHRange.x, _SMHRange.y, luminance);
    float highlightsWeight = smoothstep(_SMHRange.z, _SMHRange.w, luminance);
    float midtonesWeight = 1.0 - shadowsWeight - highlightsWeight;
    return color * _SMHShadows.rgb * shadowsWeight + color * _SMHMidtones.rgb * midtonesWeight + color * _SMHHighlights.rgb * highlightsWeight;
&#125;
</code></pre><p>为了更好展示 Shadows Midtones Highlights 工具的作用，我将亮部暗部以及灰部的颜色调整得较为奇葩，亮部为红色，灰部为蓝色，暗部为绿色（还别有一番风味）：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/04/01/hxuJZeGcRvAEN8D.jpg" width = "60%" height = "60%" alt="图106 - Shadows Midtones Highlights 效果展示"/>
</div>

<h2 id="ACES-色彩空间下调色"><a href="#ACES-色彩空间下调色" class="headerlink" title="ACES 色彩空间下调色"></a>ACES 色彩空间下调色</h2><p>之前讲 ACES 工作流程时大致提到过，在 ACES 的工作流程下，调色最好在 ACES 色彩空间下。我们主要在 ACEScg 这个线性色彩空间下进行调色，故需要先将线性空间转换至 ACEScg 线性空间：  </p>
<pre><code>color = unity_to_ACEScg(color);
</code></pre><p>但是 WhiteBalance 除外，因为它是在 LMS 色彩空间中调整的。Color Adjustments 工具中基本都需要在 ACEScg 中进行调整，除了 Contrast，因为 Contrast 是在 log 色彩空间中进行的，而 ACES 的 log 空间为 ACEScc，故需要将 ACEScg 转换至 ACEScc：  </p>
<pre><code>float3 Contrast_ACES(float3 color)
&#123;
    color = ACES_to_ACEScc(ACEScg_to_ACES(color));
    color = lerp(ACEScc_MIDGRAY, color, _ColorAdjustmentsParams.z);
    return ACES_to_ACEScg(ACEScc_to_ACES(color));
&#125;
</code></pre><p>ACEScc 色彩空间的中灰点也是不同的，使用 Unity 提供的宏 <code>ACEScc_MIDGRAY</code>。然后 ACEScg 色彩空间中计算亮度 Luminance 也是不同的，要调用 <code>AcesLuminance()</code> 而不是 <code>Luminance()</code> 方法，故 Saturation 方法也要调整：  </p>
<pre><code>float3 Saturation_ACES(float3 color)
&#123;
    float luminance = AcesLuminance(color);
    return lerp(float3(luminance, luminance, luminance), color, _ColorAdjustmentsParams.w);
&#125;
</code></pre><p>其他工具若也计算了 Luminance 也是同样的处理方法，就不额外说明了。</p>
<h2 id="Lookup-Table-LUT"><a href="#Lookup-Table-LUT" class="headerlink" title="Lookup Table (LUT)"></a>Lookup Table (LUT)</h2><p>直接对屏幕的每个像素进行 color grading 计算相对比较消耗性能，我们可以将所有的 color grading 工具烘焙进一个 LUT 贴图，然后对其进行采样，这样子计算量会小很多。LUT 是一个 3D 纹理，可以将其转换为一个 2D 纹理，比如 32 × 32 × 32 转化为 1024 × 32。我们可以在 PipelineAsset 文件中设置一个 LUTSize 属性，用于控制 LUT 的分辨率，分辨率分别为 16、32、64，然后根据属性生成 LUT 贴图。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> lutHeight = asset.bakedLUTResolution;</span><br><span class="line"><span class="built_in">int</span> lutWidth = lutHeight * lutHeight;</span><br><span class="line">data.buffer.GetTemporaryRT(RenderTargetIDs.k_ColorGradingLutTextureId, lutWidth, lutHeight, <span class="number">0</span>, FilterMode.Bilinear, RenderTextureFormat.DefaultHDR);</span><br></pre></td></tr></table></figure>
<p>除了烘焙 color grading，tone mapping 也可以烘焙进去。代码如何更改 CPU 端就不详细展示了，下面讲一下 GPU 端，反正就是根据不同 tone mapping 算法，选择不同的 Pass，将 color grading 和 tone mapping 共同绘制进 LUT Texture，最后别忘了 <code>ReleaseTemporaryRT()</code>。</p>
<h3 id="生成-LUT-颜色"><a href="#生成-LUT-颜色" class="headerlink" title="生成 LUT 颜色"></a>生成 LUT 颜色</h3><p>首先 LUT 的基本颜色是根据 uv 去生成的，Core RP Library 的 Color.hlsl 提供了相关函数 <code>GetLutStripValue()</code>。生成颜色后再进行 Color Grading 改变颜色：  </p>
<pre><code>float3 GetColorGradedLUT(float2 uv) 
&#123;
    float3 color = GetLutStripValue(uv, _ColorGradingLUTParameters);
    return ColorGrading(color);
&#125;
</code></pre><p><code>_ColorGradingLUTParameters</code> 是 LUT Texture 的分辨率相关参数：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">data.buffer.SetGlobalVector(k_ColorGradingLUTParamsId, <span class="keyword">new</span> Vector4(lutHeight, <span class="number">0.5f</span> / lutWidth, <span class="number">0.5f</span> / lutHeight, lutHeight / (lutHeight - <span class="number">1.0f</span>)));</span><br></pre></td></tr></table></figure>
<p>然后根据 tone mapping 的设置去选择不同的 tone mapping 算法：  </p>
<pre><code>float4 ColorGradingReinhardSimpleFrag(Varyings IN) : SV_TARGET
&#123;
    float3 color = GetColorGradedLUT(IN.uv);
    return float4(Reinhard(color), 1.0);
&#125;

...

float4 ColorGradingACESFullFrag(Varyings IN) : SV_TARGET
&#123;
    float3 color = GetColorGradedLUT_ACES(IN.uv);
    return float4(AcesTonemap(ACEScg_to_ACES(color)), 1.0);
&#125;

...
</code></pre><p>这样子就可以生成 LUT 贴图了，如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/04/01/AMBCKTvOcEHh3V2.png" width = "75%" height = "75%" alt="图107 - 未做 Color Grading 的 Lut 贴图。上：None；中：Reinhard Simple；下：ACES"/>
</div>

<h3 id="Log-C-LUT"><a href="#Log-C-LUT" class="headerlink" title="Log C LUT"></a>Log C LUT</h3><p>上面的 LUT 的问题在于，<code>GetLutStripValue()</code> 函数生成的基本颜色值是在 0 - 1 的范围内的，这样子生成的 Lut 就不支持 HDR 颜色了。为了解决这个问题，我们可以假设 <code>GetLutStripValue()</code> 函数生成的基本颜色值是在 Log 颜色空间，Log 颜色空间能够更高效地存储更广的亮度范围，通过非线性对数曲线压缩了亮度信息，并且通常归一化至 0 - 1 的范围。</p>
<p>然后在 ColorGrading 前将颜色转换回线性空间即可：  </p>
<pre><code>float3 GetColorGradedLUT(float2 uv) 
&#123;
    float3 color = GetLutStripValue(uv, _ColorGradingLUTParameters);
    return ColorGrade(LogCToLinear(color));
&#125;
</code></pre><p>这样子生成的 LUT 贴图如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/04/01/PRq1jdgDY2azxQN.png" width = "75%" height = "75%" alt="图108 - log 空间 lut 贴图。上：None；中：Reinhard Simple；下：ACES"/>
</div>

<p>当然我们要根据是否使用 HDR 工作流程来选择使用 Log LUT 还是 Linear LUT。毕竟对于 LDR 流程来说，Log LUT 会损失一定的颜色精度。</p>
<h2 id="UberPost-Shader"><a href="#UberPost-Shader" class="headerlink" title="UberPost Shader"></a>UberPost Shader</h2><p>在将 Color Grading 和 Tone Mapping 烘焙进 LUT 后，我们要在另外一个 Shader 里采样 LUT 应用至渲染图中。这个 Shader 叫做 <strong>UberPost</strong>，即超级后处理，之所以叫这个名字，是因为要在该 Shader 中处理所有后处理工具以及工具产生的资源。比如 Bloom，我们之前将模糊后的渲染图叠加到原渲染图上产生泛光效果，那么我们不在 Bloom 阶段做叠加，Bloom 阶段只输出模糊后的渲染图这么一个资源，命名为 BloomTexture。然后将所有资源，包括 BloomTexture、LUT 以及其他后处理效果，一起在 UberPost 中一个一个叠加到原渲染图上。  </p>
<p>Bloom 以及其他后处理，比如 Vignette、Film Grain、Chromatic Aberration、Depth of Field、Len Distortion、Len Flare、Panini Projection 等等效果，在 UberPost 中的代码具体详见 URP 或者 HDRP，就不在这里展示了，直接抄 Unity 的就完事了，想要比 Unity 的实现更好的效果，以后可以根据需求一个一个去处理。</p>
<p>这里只展示如何应用 Baked Color Grading Lut，首先 Core RP Library 的 Color.hlsl 提供了采样 LUT 的函数叫 <code>ApplyLut2D()</code>：</p>
<pre><code>float4 UberPostProcessingFrag(Varyings IN) : SV_TARGET
&#123;
    float3 color = SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv, 0).rgb;
    color = ApplyLut2D(_ColorGradingLutTexture, sampler_LinearClamp, saturate(LinearToLogC(color)), _ColorGradingLutParams.xyz);
    ...
&#125;
</code></pre><p>别忘了将颜色从线性空间转换至 Log 空间进行采样。<code>_ColorGradingLutParams</code> 的各个参数如下：  </p>
<pre><code>data.buffer.SetGlobalVector.SetVector(k_ColorGradingLutParamsId, new Vector4(1.0f / lutWidth, 1.0f / lutHeight, lutHeight - 1.0f));
</code></pre><p>我将大部分后处理效果实现后，搞出了如下效果图：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/04/01/7REkTWumt1sSlZn.jpg" width = "90%" height = "90%" alt="图109 - 瞎几把搞出来的效果图"/>
</div>

<h2 id="Color-Banding"><a href="#Color-Banding" class="headerlink" title="Color Banding"></a>Color Banding</h2><p><strong>色彩分层/色彩断代 Color Banding</strong> 是一个非常常见的 artifact 现象。这个现象产生的原因是由于颜色位深（即精度）不够，特别是在色调调整后，很容易出现环状阶梯型的颜色带，如下图所示：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/04/01/tcXxHMRJuysiELq.png" width = "60%" height = "60%" alt="图110 - Color Banding 现象"/>
</div>

<p>我们应用 LUT 时，因为使用 bilinear 采样器，这种现象会在一定程度上缓解，就会产生如上图的相对平滑的 Color Banding。若使用 point 采样器，这种现象会格外明显。这种现象的缓解方法就是大名鼎鼎的<strong>抖动 Dither</strong>，即向图片增加噪声，随机化误差从而减少大尺度的 pattern，效果如下图：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/04/01/bXGWlEh8t6jYg4n.png" width = "75%" height = "75%" alt="图111 - 左：原图；中：转换至低位深后的图片；右：添加抖动后的图片"/>
</div>

<p>抖动除了可以缓解色带问题，也可以用于缓解阴影的噪点问题。但是在这里，先不讲解如何应用 Dither，我打算在处理 TAA 的时候一并实现。</p>
<blockquote>
<p>类似于 Dither 还有一个也叫抖动的称为 Jitter，它俩的区别在于，Dither 强调空间维度，Jitter 强调时间维度。Jitter 通常运用在体积光、雾的渲染中，以及光线跟踪的重要性采用中。</p>
</blockquote>
<h1 id="Multiple-Cameras"><a href="#Multiple-Cameras" class="headerlink" title="Multiple Cameras"></a>Multiple Cameras</h1><p>本章节讲解如何支持多相机渲染，多相机渲染的需求多种多样，有多人分屏、UI 中的 3D 人物（3D character portraits）、上帝视角游戏的全局视角、拿起物体时的物体特写等等。其实对于第二个摄像头，未必需要跟第一个摄像头具有一样的渲染流程，可以简化很多，比如为物体特写实现 MatCap。下面介绍的几种需求的特定方案，没必要在 SRP 中同时支持，故这里以摘抄翻译记录为主，之后根据项目需求选择特定方案即可。</p>
<h2 id="Split-Screen"><a href="#Split-Screen" class="headerlink" title="Split Screen"></a>Split Screen</h2><p>分屏其实很简单，只要将第一个相机的 viewport rect 的 width 设置为 0.5，第二个相机的 width 也设置为 0.5 以及 X position 设置为 0.5，就可以了。但是我们会发现，这样做不成功了，每个相机都渲染出了图片，但是拉伸覆盖了整个屏幕。产生这个现象的原因是，我们没有调用 <code>CommandBuffer.SetViewport()</code> 设置视口：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BlitCameraTarget</span>(<span class="params">CommandBuffer cmd, <span class="built_in">int</span> sourceID, Rect cameraRect, Material material, <span class="built_in">int</span> pass</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    cmd.SetGlobalTexture(k_BlitTextureId, <span class="keyword">new</span> RenderTargetIdentifier(sourceID));</span><br><span class="line">    cmd.SetRenderTarget(<span class="keyword">new</span> RenderTargetIdentifier(BuiltinRenderTextureType.CameraTarget), RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);</span><br><span class="line">    cmd.SetViewport(cameraRect);</span><br><span class="line">    cmd.DrawProcedural(Matrix4x4.identity, material, pass, MeshTopology.Triangles, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在后处理最后的输出阶段调用上述函数，并传递进 <code>camera.pixelRect</code> 即可支持分屏。  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/04/04/EJiCOMdhYqc2BT1.jpg" width = "50%" height = "50%" alt="图112 - 分屏"/>
</div>

<p>catlikecoding 教程中还提到 tile-based GPU 可能在视口边缘部分出现 artifact，解决方法如下，先判断是否视口是否有缩放，再决定 RenderBufferLoadAction：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Rect fullViewRect = <span class="keyword">new</span> Rect(<span class="number">0f</span>, <span class="number">0f</span>, <span class="number">1f</span>, <span class="number">1f</span>);</span><br><span class="line">...</span><br><span class="line">cmd.SetRenderTarget(BuiltinRenderTextureType.CameraTarget,</span><br><span class="line">			camera.rect == fullViewRect ? RenderBufferLoadAction.DontCare : RenderBufferLoadAction.Load,</span><br><span class="line">			RenderBufferStoreAction.Store);</span><br></pre></td></tr></table></figure>
<h2 id="Layering-Cameras"><a href="#Layering-Cameras" class="headerlink" title="Layering Cameras"></a>Layering Cameras</h2><p>相机叠加也是同理，可以第二个相机的 width 和 height 设置为 0.5，XY position 设置为 0.25，这样第二个相机的图片就会叠加在第一张图片的上面了。但是因为我们之前实现 Post Processing 时，直接清除了 color buffer 和 depth buffer，导致之前的 CameraClearFlags 的 Depth Only 模式失效了，即不渲染 Skybox 直接将第二张图片叠加上去，像是物体悬浮在第一张图片上面一样，如下图：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/04/07/RmMwILdXvyjNPVO.jpg" width = "50%" height = "50%" alt="图113 - Layering Cameras"/>
</div>

<p>要想实现这个效果，我们可以在最后的 blit 进 CameraTarget 的 pass 中将混合因子改为 One OneMinusSrcAlpha，为什么不是 SrcAlpha OneMinusSrcAlpha 下面会说：  </p>
<pre><code>Pass
&#123;
    Name &quot;Final Pass&quot;

    Blend One OneMinusSrcAlpha

    HLSLPROGRAM
    #pragma target 3.5
    #pragma vertex CopyVert
    #pragma fragment UberPostProcessingFrag
    ...
    ENDHLSL
&#125;
</code></pre><p>并且将 RenderBufferLoadAction 改为 Load 模式：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">cmd.SetRenderTarget(BuiltinRenderTextureType.CameraTarget, RenderBufferLoadAction.Load, RenderBufferStoreAction.Store);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其实这样理论上就应该可以实现之前 Depth Only 模式的效果了，只要我们将相机的 Background color 的 alpha 设置为 0（当然别忘了当时 ClearRenderTarget 用 data.camera.backgroundColor.linear 覆盖颜色）。但是现在背景仍然不能处于透明状态，这是因为我们没有在片元着色器中输出 Alpha 值，Alpha 值直接默认为 1 了。</p>
<p>这里注意一下，如果我们是 Bloom 完将 Bloom 模糊结果和原图叠加后，再进行 Post Processing 的，就需要在 Bloom 的最后的 pass 以及后面的 UberPost 的 pass，将 <code>_BlitTexture</code> 的 Alpha 输出。若 Bloom 模糊结果和其他 Post Processing 一起在 UberPost Shader 中做混合，则只需要在 UberPost Shader 将 <code>_BlitTexture</code> 的 Alpha 输出，类似如下：  </p>
<pre><code>float4 UberPostProcessingFrag(Varyings IN) : SV_TARGET
&#123;
    float4 inputColor = SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv, 0);
    ...
    return float4(color, inputColor.a);
&#125;
</code></pre><p>这样子就可以实现之前的 Depth Only 模式的效果了，但是若使用 SrcAlpha OneMinusSrcAlpha 的话，bloom 效果无法保留，因为 bloom 模糊的区域 Alpha 为 0，所以要使用 One OneMinusSrcAlpha。当然我觉得在 Bloom 阶段把 Alpha 也做模糊处理可能效果更好，我没试过，有需求的话可以尝试一下。</p>
<div  align="center">  
<img src="https://s2.loli.net/2025/04/07/plRy8WqO7sCPkZ1.png" width = "75%" height = "75%" alt="图114 - 左：SrcAlpha OneMinusSrcAlpha；右：One OneMinusSrcAlpha"/>
</div>

<h2 id="UI-Render-Texture"><a href="#UI-Render-Texture" class="headerlink" title="UI Render Texture"></a>UI Render Texture</h2><p>除了上述的方法外，还可以将相机渲染至 Render Texture，然后将 Render Texture 作为 UI 的 Raw Image 显示。首先通过 Assets / Create / Render Texture 创建渲染纹理，再将该渲染纹理设置为 camera 的 Target Texture。然后通过 GameObject / UI / Raw Image 创建 raw image component，将其 Texture 属性设置为我们创建的渲染纹理，即可在屏幕上显示。</p>
<blockquote>
<p>不知道为什么，我将相机的 Target Texture 设置为 Render Texture，但是打开 Frame Debugger 后发现并没有渲染至该纹理，而是渲染进了 SceneView RT 当中。我不知道是不是 BuiltinRenderTextureType.CameraTarget 的原因，打算之后使用 RTHandle API 时再解决。这里先翻译一下教程内容做个记录。</p>
</blockquote>
<p>raw image 使用默认的 UI 材质，使用的是标准的 SrcAlpha OneMinusSrcAlpha 混合，所以上面提到的 Bloom 没效果的问题也会存在。要想解决，我们需要复制下来默认的 Default-UI shader，并改变里面的混合模式。这个 Shader 里面的代码就不摘抄下来了。</p>
<h1 id="Rendering-Layers"><a href="#Rendering-Layers" class="headerlink" title="Rendering Layers"></a>Rendering Layers</h1><p>Rendering Layers 主要是用于控制物体是否受到灯光的影响，这个功能我觉得没有什么特别的应用场景，所以我不打算支持，故下面只是简单摘抄翻译原教程的内容，略微介绍如何实现，不打算详细说明。</p>
<h2 id="Culling-Masks"><a href="#Culling-Masks" class="headerlink" title="Culling Masks"></a>Culling Masks</h2><p>场景中物体都可以设置一个 Layer。在编辑模式下（场景的右上方），有个 Layers 下拉菜单可以设置，选择 Show/Hide Layer，就可以决定该物体是否显示。类似的，在 Game 模式下，我们可以设置相机的 Culling Mask 属性来限制场景中显示的物体。</p>
<p>灯光也有 Culling Mask 属性，理论上它应该可以限制物体是否受到灯光的影响。但是如果我们尝试一下就会发现，目前该属性只能限制物体是否受到阴影的影响。这是因为我们在 SRP 做过两次 Culling，一次是摄像机的 Culling，一次是阴影的 Culling。相机的 Culling Mask 属性决定了物体是否在渲染阶段被剔除，灯光的 Culling Mask 属性决定了物体是否在阴影贴图阶段被剔除。而原先 Unity 灯光的 Culling Mask 是通过 per-object light indices 实现的，而我们不支持。</p>
<p>其实 HDRP 也去除掉了 Light 的 Culling Mask 这个功能。SRP 另外提供了 rendering layers 作为该功能的替补。rendering layers 最多可以有 32 个 layers，每个 layer 对应一个 bit 值。</p>
<h2 id="Sending-Rendering-Layer-to-the-GPU"><a href="#Sending-Rendering-Layer-to-the-GPU" class="headerlink" title="Sending Rendering Layer to the GPU"></a>Sending Rendering Layer to the GPU</h2><p>首先我们需要在 UnityInput 里的 UnityPerDraw 添加 unity_RenderingLayer，注意放置的位置：  </p>
<pre><code>CBUFFER_START(UnityPerDraw)
...
real4 unity_WorldTransformParams; // w is usually 1.0, or -1.0 for odd-negative scale transforms

// Render Layer block feature
// Only the first channel (x) contains valid data and the float must be reinterpreted using asuint() to extract the original 32 bits values.
float4 unity_RenderingLayer;

half4 unity_LightData;
...
CBUFFER_END
</code></pre><p>然后我们就可以通过 <code>asuint(unity_RenderingLayer.x);</code> 获取到物体的 Rendering Layer Mask 的值了。除了物体外，我们还需要获取灯光的 Rendering Layer Mask 值，我们可以通过 <code>light.renderingLayerMask</code> 获取到，CPU 传递的工作就不再赘述了。到了 GPU 里，我们需要使用按位与 <code>&amp;</code> 来比较物体和灯光的 Rendering Layer Mask 的值，类似如下：  </p>
<pre><code>bool RenderingLayersOverlap (Surface surface, Light light) 
&#123;
    return (surface.renderingLayerMask &amp; light.renderingLayerMask) != 0;
&#125;
</code></pre><p>然后根据比较结果选择是否进行光照计算，代码类似如下：  </p>
<pre><code>for (int i = 0; i &lt; GetDirectionalLightCount(); i++) 
&#123;
    Light light = GetDirectionalLight(i, surfaceWS, shadowData);
    if (RenderingLayersOverlap(surfaceWS, light)) 
    &#123;
        color += Lighting(surfaceWS, brdf, light);
    &#125;
&#125;
</code></pre><h2 id="Reinterpreting-an-Int-as-a-Float"><a href="#Reinterpreting-an-Int-as-a-Float" class="headerlink" title="Reinterpreting an Int as a Float"></a>Reinterpreting an Int as a Float</h2><p>理论上，上面应该已经可以实现 Rendering Layers 的功能了，但是还存在一个问题。<code>light.renderingLayerMask</code> 属性获取到的是 int 值，而不是 bit 值，我们传递该 int 值至 GPU 时，会被自动转换为 float。所以我们需要在 CPU 端将 int 按位转换为 float，但是 C# 没有 asuint 函数。</p>
<p>教程中的转换方法有点复杂，C# 中的 System 的 BitConverter 类可以做类似的工作（<code>BitConverter.UInt32BitsToSingle()</code>）。我没有实现过，不知道可不可以成功，需要尝试过。</p>
<h2 id="Camera-Rendering-Layer-Mask"><a href="#Camera-Rendering-Layer-Mask" class="headerlink" title="Camera Rendering Layer Mask"></a>Camera Rendering Layer Mask</h2><p>我们也可以为 Camera 实现 rendering layer mask 功能，但是 Camera 默认不自带 rendering layer mask 属性，我们需要为它自定义一个，如何自定义这里就不写了。如何通过 FilteringSettings 的 renderingLayerMask 属性过滤掉不想渲染的物体：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.opaque, renderingLayerMask: (<span class="built_in">uint</span>) renderingLayerMask);</span><br></pre></td></tr></table></figure>
<p>这样就可以实现 Camera 的 rendering layer mask 功能了，只是这样做，物体不会渲染，但是阴影还在。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io">鸟布</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io/2025/03/13/2025-03-13-CustomSRP6/">https://ybniaobu.github.io/2025/03/13/2025-03-13-CustomSRP6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ybniaobu.github.io" target="_blank">鸟布的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/unity/">unity</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2025/03/13/LozNxAmnlEJSOyV.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src="/images/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/04/07/2025-04-07-CustomSRP7/" title="Unity Custom SRP 基础（七）"><img class="cover" src="https://s2.loli.net/2025/04/07/2zi6pj3XtAPHvmy.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unity Custom SRP 基础（七）</div></div></a></div><div class="next-post pull-right"><a href="/2025/02/26/2025-02-26-CustomSRP5/" title="Unity Custom SRP 基础（五）"><img class="cover" src="https://s2.loli.net/2025/02/26/m2zJbPd8aeGD14A.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity Custom SRP 基础（五）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/15/2023-09-15-UnityShader1/" title="《Unity Shader入门精要》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2023/09/19/cDvdURBPhjwkOsY.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-15</div><div class="title">《Unity Shader入门精要》读书笔记（一）</div></div></a></div><div><a href="/2023/12/30/2023-12-30-UnityShader5/" title="《Unity Shader入门精要》读书笔记（五）"><img class="cover" src="https://s2.loli.net/2023/12/30/hc2s7BS45l1wUdQ.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-30</div><div class="title">《Unity Shader入门精要》读书笔记（五）</div></div></a></div><div><a href="/2023/10/13/2023-10-13-UnityShader2/" title="《Unity Shader入门精要》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2023/10/15/RZftaNSscWoLH1u.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-13</div><div class="title">《Unity Shader入门精要》读书笔记（二）</div></div></a></div><div><a href="/2023/11/22/2023-11-22-UnityShader3/" title="《Unity Shader入门精要》读书笔记（三）"><img class="cover" src="https://s2.loli.net/2023/11/23/L3ts4WnThMlDN9d.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-22</div><div class="title">《Unity Shader入门精要》读书笔记（三）</div></div></a></div><div><a href="/2023/12/19/2023-12-19-UnityShader4/" title="《Unity Shader入门精要》读书笔记（四）"><img class="cover" src="https://s2.loli.net/2023/12/20/9Ah5ugiIpONK1cX.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-19</div><div class="title">《Unity Shader入门精要》读书笔记（四）</div></div></a></div><div><a href="/2024/03/20/2024-03-20-NPR_StarRail1/" title="基于星穹铁道的卡通渲染（一）"><img class="cover" src="https://s2.loli.net/2024/03/26/dZTwsApi59CSUal.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="title">基于星穹铁道的卡通渲染（一）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/wechat%20avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鸟布</div><div class="author-info__description">教练，我想学技术</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://niaobu.notion.site/787824630ea6480e944c1ae5ae7f4792"><i class="fa-solid fa-book"></i><span>My Notion</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ybniaobu/ybniaobu.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:niaobubob@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为了蒂法！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HDR"><span class="toc-number">1.</span> <span class="toc-text">HDR</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81-HDR-rendering"><span class="toc-number">1.1.</span> <span class="toc-text">支持 HDR rendering</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HDR-Bloom"><span class="toc-number">1.2.</span> <span class="toc-text">HDR Bloom</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bloom-%E9%97%AA%E7%83%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">Bloom 闪烁问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Scattering-Bloom"><span class="toc-number">2.</span> <span class="toc-text">Scattering Bloom</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Scatter"><span class="toc-number">2.1.</span> <span class="toc-text">Scatter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final-Blit"><span class="toc-number">2.2.</span> <span class="toc-text">Final Blit</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tone-Mapping"><span class="toc-number">3.</span> <span class="toc-text">Tone Mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Reinhard"><span class="toc-number">3.1.</span> <span class="toc-text">Reinhard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Uncharted-2-Filmic"><span class="toc-number">3.2.</span> <span class="toc-text">Uncharted 2 Filmic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Khronos-PBR-Neutral"><span class="toc-number">3.3.</span> <span class="toc-text">Khronos PBR Neutral</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACES"><span class="toc-number">3.4.</span> <span class="toc-text">ACES</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AgX"><span class="toc-number">3.5.</span> <span class="toc-text">AgX</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Color-Grading"><span class="toc-number">4.</span> <span class="toc-text">Color Grading</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Color-Adjustments"><span class="toc-number">4.1.</span> <span class="toc-text">Color Adjustments</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exposure-Saturation-Contrast"><span class="toc-number">4.1.1.</span> <span class="toc-text">Exposure Saturation Contrast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Color-Filter-amp-Hue-Shift"><span class="toc-number">4.1.2.</span> <span class="toc-text">Color Filter &amp; Hue Shift</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#White-Balance"><span class="toc-number">4.2.</span> <span class="toc-text">White Balance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shadows-Midtones-Highlights"><span class="toc-number">4.3.</span> <span class="toc-text">Shadows Midtones Highlights</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACES-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%B8%8B%E8%B0%83%E8%89%B2"><span class="toc-number">4.4.</span> <span class="toc-text">ACES 色彩空间下调色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lookup-Table-LUT"><span class="toc-number">4.5.</span> <span class="toc-text">Lookup Table (LUT)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90-LUT-%E9%A2%9C%E8%89%B2"><span class="toc-number">4.5.1.</span> <span class="toc-text">生成 LUT 颜色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Log-C-LUT"><span class="toc-number">4.5.2.</span> <span class="toc-text">Log C LUT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UberPost-Shader"><span class="toc-number">4.6.</span> <span class="toc-text">UberPost Shader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Color-Banding"><span class="toc-number">4.7.</span> <span class="toc-text">Color Banding</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Multiple-Cameras"><span class="toc-number">5.</span> <span class="toc-text">Multiple Cameras</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Split-Screen"><span class="toc-number">5.1.</span> <span class="toc-text">Split Screen</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Layering-Cameras"><span class="toc-number">5.2.</span> <span class="toc-text">Layering Cameras</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UI-Render-Texture"><span class="toc-number">5.3.</span> <span class="toc-text">UI Render Texture</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Rendering-Layers"><span class="toc-number">6.</span> <span class="toc-text">Rendering Layers</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Culling-Masks"><span class="toc-number">6.1.</span> <span class="toc-text">Culling Masks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sending-Rendering-Layer-to-the-GPU"><span class="toc-number">6.2.</span> <span class="toc-text">Sending Rendering Layer to the GPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reinterpreting-an-Int-as-a-Float"><span class="toc-number">6.3.</span> <span class="toc-text">Reinterpreting an Int as a Float</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Camera-Rendering-Layer-Mask"><span class="toc-number">6.4.</span> <span class="toc-text">Camera Rendering Layer Mask</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/08/2025-06-08-TileBasedLightCulling/" title="Tile-Based Light Culling"><img src="https://s2.loli.net/2025/06/08/1hF5QplnZjxBvJS.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tile-Based Light Culling"/></a><div class="content"><a class="title" href="/2025/06/08/2025-06-08-TileBasedLightCulling/" title="Tile-Based Light Culling">Tile-Based Light Culling</a><time datetime="2025-06-08T05:03:10.000Z" title="发表于 2025-06-08 13:03:10">2025-06-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/29/2025-04-29-CustomSRP8/" title="Unity Custom SRP 基础（八）"><img src="https://s2.loli.net/2025/04/29/IHYjvyKDR2uoGEt.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（八）"/></a><div class="content"><a class="title" href="/2025/04/29/2025-04-29-CustomSRP8/" title="Unity Custom SRP 基础（八）">Unity Custom SRP 基础（八）</a><time datetime="2025-04-29T12:00:38.000Z" title="发表于 2025-04-29 20:00:38">2025-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/07/2025-04-07-CustomSRP7/" title="Unity Custom SRP 基础（七）"><img src="https://s2.loli.net/2025/04/07/2zi6pj3XtAPHvmy.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（七）"/></a><div class="content"><a class="title" href="/2025/04/07/2025-04-07-CustomSRP7/" title="Unity Custom SRP 基础（七）">Unity Custom SRP 基础（七）</a><time datetime="2025-04-07T12:57:36.000Z" title="发表于 2025-04-07 20:57:36">2025-04-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/13/2025-03-13-CustomSRP6/" title="Unity Custom SRP 基础（六）"><img src="https://s2.loli.net/2025/03/13/LozNxAmnlEJSOyV.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（六）"/></a><div class="content"><a class="title" href="/2025/03/13/2025-03-13-CustomSRP6/" title="Unity Custom SRP 基础（六）">Unity Custom SRP 基础（六）</a><time datetime="2025-03-13T12:44:31.000Z" title="发表于 2025-03-13 20:44:31">2025-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/26/2025-02-26-CustomSRP5/" title="Unity Custom SRP 基础（五）"><img src="https://s2.loli.net/2025/02/26/m2zJbPd8aeGD14A.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（五）"/></a><div class="content"><a class="title" href="/2025/02/26/2025-02-26-CustomSRP5/" title="Unity Custom SRP 基础（五）">Unity Custom SRP 基础（五）</a><time datetime="2025-02-26T03:30:46.000Z" title="发表于 2025-02-26 11:30:46">2025-02-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By 鸟布</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Your time is limited, so don't waste it living someone else's life.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>