<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity Custom SRP 基础（六） | 鸟布的博客</title><meta name="author" content="鸟布"><meta name="copyright" content="鸟布"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本笔记的主要内容包含 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX。"><link rel="shortcut icon" href="https://s2.loli.net/2022/09/08/Ygib4lfw6z1khnr.png"><link rel="canonical" href="https://ybniaobu.github.io/2025/03/13/2025-03-13-CustomSRP6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 鸟布","link":"链接: ","source":"来源: 鸟布的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity Custom SRP 基础（六）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-21 20:52:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/wechat%20avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/black.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鸟布的博客"><span class="site-name">鸟布的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity Custom SRP 基础（六）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-13T12:44:31.000Z" title="发表于 2025-03-13 20:44:31">2025-03-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-21T12:52:28.049Z" title="更新于 2025-03-21 20:52:28">2025-03-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/unity/">unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/unity/pipeline/">pipeline</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity Custom SRP 基础（六）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本笔记是关于 Unity 的<strong>自定义可编程渲染管线</strong>的入门基础，即 <strong>SRP (Scriptable Rendering Pipeline)</strong>，主要参考了著名的教程 <a target="_blank" rel="noopener" href="https://catlikecoding.com/">https://catlikecoding.com/</a> 的 Custom SRP Tutorial，以及知乎上各位图形学大神们的文章。  </p>
<p>笔者使用的 Unity 版本是 6000.0.27f1，Core RP Library 的版本是 17.0.3。</p>
</blockquote>
<h1 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h1><p>到目前为止，我们输出到相机的帧缓冲仍然是 LDR 格式，即 B8G8R8A8_SRGB 格式。这意味着输出的颜色都会被限制在 0.0 到 1.0 之间，任何大于 1.0 的颜色值都会被 clamp 到 1.0，相当于在片元着色器函数的结尾做了一次 <code>saturate()</code>。但是在 Shader 里计算时，部分像素的颜色值很可能会高于 1.0，特别是在多光源的情况下，这就会造成部分区域非常白，导致场景细节的丢失。</p>
<p>为了解决这一问题，我们就需要使用 <strong>HDR (High Dynamic Range，高动态范围)</strong> 的帧缓冲了，一般 HDR 会使用 R16G16B16A16_FLOAT 的格式（最大值为 65504），也有为了减少带宽的开销，而压缩成 R11G11B10_FLOAT 格式的。这样子大于 1.0 的颜色值就可以存储在纹理当中了，从而获取更大范围的黑暗或明亮值。但是大部分显示器仍然只能显示 sRGB 色彩空间的颜色（这里暂时不讨论支持 HDR 输出的显示器），即 [0, 255] 或 [0.0, 1.0] 范围的值，此时就需要将 HDR 重新映射回 LDR 值，而这个操作就叫做<strong>色调映射 Tone Mapping</strong>，该操作的主要目的就是尽可能地保留场景的黑暗与明亮细节，所以它本质上就是增强明暗的对比度。</p>
<blockquote>
<p>注意区分 Tone Mapping 和 <strong>Gamma 校正</strong>，这两个操作是相互独立的，Tonemapping 将 HDR 颜色转换到 LDR 颜色，但两者仍然都在线性空间，之后仍然需要做 Gamma 校正。  </p>
</blockquote>
<h2 id="支持-HDR-rendering"><a href="#支持-HDR-rendering" class="headerlink" title="支持 HDR rendering"></a>支持 HDR rendering</h2><p>我们可以在 RenderPipelineAsset 里面增加一个 bool 字段，用于控制 HDR 的开启。然后在创建 FrameBuffer 的地方根据该字段生成 HDR 格式：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">data.buffer.GetTemporaryRT(RenderTargetIDs.k_FrameBufferId, data.camera.pixelWidth, data.camera.pixelHeight, <span class="number">32</span>, FilterMode.Bilinear, asset.enableHDR ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);</span><br></pre></td></tr></table></figure>
<p>default HDR 格式就是 R16G16B16A16_FLOAT。这样子，我们的场景就会使用 HDR 渲染，打开 Frame Debugger，可以看到在最后输出之前渲染出来的图片颜色变深了，这就是因为渲染到了 HDR 的线性空间当中，所以看起来变暗了。但是我们不用关心最后输出时的 gamma 校正，因为在线性空间的设置下，Unity 会自动处理 gamma 校正问题。</p>
<h2 id="HDR-Bloom"><a href="#HDR-Bloom" class="headerlink" title="HDR Bloom"></a>HDR Bloom</h2><p>之前 LDR Bloom 的预过滤和采样过程中，都是将中间结果输出到 LDR 贴图当中的。那么我们首先应该将它们改为 HDR 贴图：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do bloom at half or quarter resolution</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Determine the iteration count</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Shader property and keyword setup</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HDR</span></span><br><span class="line">    RenderTextureFormat format = asset.enableHDRFrameBufferFormat ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prefilter</span></span><br><span class="line">    data.buffer.GetTemporaryRT(k_BloomPrefilterId, width, height, <span class="number">0</span>, FilterMode.Bilinear, format);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Downsample - gaussian pyramid</span></span><br><span class="line">    <span class="built_in">int</span> sourceId = k_BloomPrefilterId;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterationCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data.buffer.GetTemporaryRT(m_BloomPyramidUpIds[i], width, height, <span class="number">0</span>, FilterMode.Bilinear, format);</span><br><span class="line">        data.buffer.GetTemporaryRT(m_BloomPyramidDownIds[i], width, height, <span class="number">0</span>, FilterMode.Bilinear, format);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Upsample - bilinear or bicubic</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Final Blit</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Release RT</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子 Addictive Bloom 就可以在 HDR 下正常工作了。HDR Bloom 和 LDR Bloom 的重要区别在于，HDR Bloom 中一个特别大的值会影响到一个非常大的区域，即使是一个像素，也可能会产生非常高亮的 Bloom 区域。产生这个现象的原因就是平均值的极端值效应，本来 4 个像素平均，LDR 下无论怎么平均都是小于 1 的平均数，现在 HDR 下，4 个像素中一个像素值为 10，其他像素值再小，平均值也会被拉得很大。于是乎，就产生了 HDR Bloom 的一个最大弊端，也是必须要克服的弊端，即闪烁现象。</p>
<h3 id="Bloom-闪烁问题"><a href="#Bloom-闪烁问题" class="headerlink" title="Bloom 闪烁问题"></a>Bloom 闪烁问题</h3><p>HDR Bloom 的闪烁问题在镜头移动的情况下会格外严重，我这里 gif 就不放出来了，URP 下该现象就挺严重的（看了下 URP 的 Bloom Shader，确实没解决闪烁问题）。而解决方案是在 Prefilter 阶段做一次模糊处理，并使用以下权重做平均来降低动态范围，这个方法叫做 <strong>Karis Average</strong>：  </p>
<script type="math/tex; mode=display">weight = \cfrac {1} {1 + luminance}</script><p>在该权重下，亮度越高，权重越低。这个方法虽然损失一部分的 bloom 范围和亮度，但是能在一定程度减少 Bloom 闪烁问题，虽然做不到完全解决，完全解决可以说是不可能的。该方法的实现如下：①将 Prefilter 的 Bilinear 2 × 2 采样扩展为 6 × 6 的 box 核，在采样时（模糊平均前）应用 bloom threshold 提取较亮区域。②使用 Karis Average 在模糊时做加权平均，替代 box 核的算术平均，对颜色进行修正。</p>
<pre><code>#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl&quot;

float4 BloomPrefilterFrag(Varyings IN) : SV_TARGET
&#123;
    float3 color = float3(0.0, 0.0, 0.0);
    float2 offsets[9] = &#123; float2(0.0, 0.0), float2(-1.0, -1.0), float2(-1.0, 1.0), float2(1.0, -1.0), float2(1.0, 1.0), float2(-1.0, 0.0), float2(1.0, 0.0), float2(0.0, -1.0), float2(0.0, 1.0)&#125;;

    UNITY_UNROLL
    for (int i = 0; i &lt; 9; i++)
    &#123;
        float2 offset = offsets[i] * _BlitTexture_TexelSize.xy * 2.0;
        float3 c = ApplyBloomThreshold(SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv + offset, 0).rgb);
        float w = 1.0 / (Luminance(c) + 1.0);
        color += c * w;
        weight += w;
    &#125;
    color /= weight;

    color = max(color, 0.0);
    return float4(color, 1.0);
&#125;
</code></pre><p>亮度的计算之前《Unity Shader入门精要》读书笔记（四）中也讲过，Core RP Library 的 Color.hlsl 也提供了相关的函数。上面之所以在 offset 中乘以 2.0 是因为我们使用的是 bilinear 采样器，采样一次可以覆盖 2 × 2 个像素，这样我们使用一个 3 × 3 的像素之间距离为 2 的 box 核，就可以覆盖到 6 × 6 个像素。最后一定要将颜色 clamp 到 0 以上，否则画面有可能会出现黑块。</p>
<p>这样子就可以解决大部分的闪烁问题了。但上面代码还可以再优化一步，因为下采样阶段使用了高斯模糊，我们可以将上述代码再减少 4 次采样，即与中心点相邻的 4 个采样点：  </p>
<pre><code>float4 BloomPrefilterFrag(Varyings IN) : SV_TARGET
&#123;
    ...
    float2 offsets[5] = &#123; float2(0.0, 0.0), float2(-1.0, -1.0), float2(-1.0, 1.0), float2(1.0, -1.0), float2(1.0, 1.0)&#125;;

    for (int i = 0; i &lt; 5; i++)
    &#123;
        ...
    &#125;
    ...
&#125;
</code></pre><p>这将会使 Prefilter 阶段产生的结果中一个较亮像素变为 x 形状，可以点开 Frame Debugger 查看。但是经过一次下采样，这种图案样式就会消失。</p>
<h1 id="Scattering-Bloom"><a href="#Scattering-Bloom" class="headerlink" title="Scattering Bloom"></a>Scattering Bloom</h1><p>Scattering Bloom 和 Additive Bloom 在实现方法上是非常类似的，但是对于各自所想要呈现的效果却有所不同，这两种方法的出发点是不同的，故它们之间没有优劣之分。<strong>Addictive Bloom</strong> 更偏向艺术化的表达，相对 Scattering Bloom 更不遵守能量守恒，因为我们在上采样阶段不断叠加会导致 bloom 区域亮度超过了原本图片中的亮度。而 <strong>Scattering Bloom</strong> 考虑了能量守恒，它只模糊但不添加额外的亮度，这使得特别是在灯光或者发光物体使用物理光照单位时，能够更正确地表现出其原本拥有的亮度值。</p>
<p>Scattering Bloom 的实现步骤也比较简单，就是在上采样阶段使用 Scatter 属性在 high-resolution 和 low-resolution 的贴图之间做 lerp，而不是直接相加。这样我们上采样阶段最后得到的贴图的亮度值就不会发生变化，最后在叠加到 frame buffer 时（final blit 阶段）先将 Prefilter 阶段提取的较亮区域抠出来，再将上采样阶段得到的贴图贴上去。</p>
<h2 id="Scatter"><a href="#Scatter" class="headerlink" title="Scatter"></a>Scatter</h2><p>我们先在 Bloom 的 VolumeComponent 里增加一个 enum 用于切换 Addictive Bloom 和 Scattering Bloom，同时添加一个新的属性 scatter，其范围在 0 - 1：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> BloomMode</span><br><span class="line">&#123;</span><br><span class="line">    Additive,</span><br><span class="line">    Scattering</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">BloomDownscaleParameter</span> : <span class="title">VolumeParameter</span>&lt;<span class="title">BloomDownscaleMode</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BloomDownscaleParameter</span>(<span class="params">BloomDownscaleMode <span class="keyword">value</span>, <span class="built_in">bool</span> overrideState = <span class="literal">false</span></span>) : <span class="title">base</span>(<span class="params"><span class="keyword">value</span>, overrideState</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable, VolumeComponentMenu(<span class="string">&quot;YPipeline Post Processing/Bloom&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">SupportedOnRenderPipeline(typeof(YRenderPipelineAsset))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bloom</span> : <span class="title">VolumeComponent</span>, <span class="title">IPostProcessComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> BloomModeParameter mode = <span class="keyword">new</span> BloomModeParameter(BloomMode.Scattering, <span class="literal">true</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> ClampedFloatParameter scatter = <span class="keyword">new</span> ClampedFloatParameter(<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要为上采样阶段添加一个新的 Pass，我命名为了 BloomScatteringUpsampleFrag，我们要根据选择的模式选择对应的 Pass，同时 scatter 也通过之前说的 <code>_BloomIntensity</code> 传递：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do bloom at half or quarter resolution</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Determine the iteration count</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Shader property and keyword setup</span></span><br><span class="line">    <span class="built_in">float</span> bloomIntensity = settings.mode.<span class="keyword">value</span> == BloomMode.Additive ? <span class="number">1.0f</span> : settings.scatter.<span class="keyword">value</span>;</span><br><span class="line">    data.buffer.SetGlobalFloat(k_BloomIntensityId, bloomIntensity);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// HDR</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Prefilter</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Downsample - gaussian pyramid</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Upsample - bilinear or bicubic</span></span><br><span class="line">    <span class="built_in">int</span> upsamplePass = settings.mode.<span class="keyword">value</span> == BloomMode.Additive ? <span class="number">3</span> : <span class="number">4</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = iterationCount - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        BlitUtility.BlitTexture(data.buffer, m_BloomPyramidDownIds[i], m_BloomPyramidUpIds[i], BloomMaterial, upsamplePass);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Final Blit</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Release RT</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BloomScatteringUpsampleFrag 也只需要对原本的上采样函数做一个更改即可，即将返回值的叠加改为 lerp：  </p>
<pre><code>float4 BloomScatteringUpsampleFrag(Varyings IN) : SV_TARGET
&#123;
    #if _BLOOM_BICUBIC_UPSAMPLING
    float3 lowerTex = SampleTexture2DBicubic(_BloomLowerTexture, sampler_LinearClamp, IN.uv, _BloomLowerTexture_TexelSize.zwxy, (1.0).xx, 0.0).rgb;
    #else
    float3 lowerTex = SAMPLE_TEXTURE2D_LOD(_BloomLowerTexture, sampler_LinearClamp, IN.uv, 0).rgb;
    #endif

    float3 higherTex = SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv, 0).rgb;
    return float4(lerp(higherTex, lowerTex, _BloomIntensity), 1.0);
&#125;
</code></pre><p>可以看出 scatter 为 0 就意味着只使用金字塔最高层级的贴图，为 1 就只使用金字塔最低层级的贴图。为了确保中间层级都被使用，可以选择限制 scatter 的范围为 0.05 – 0.95。</p>
<h2 id="Final-Blit"><a href="#Final-Blit" class="headerlink" title="Final Blit"></a>Final Blit</h2><p>上面的步骤本质就是将较亮区域进行模糊，并在叠加的同时不额外增加亮度。为了保证能量守恒，我们叠加到原图时，也需要先将较亮区域从原图抠出来，再叠加上模糊后的较亮区域，从而呈现一种 Bloom 效果。创建一个新的 Pass，如下：  </p>
<pre><code>float4 BloomScatteringFinalBlitFrag(Varyings IN) : SV_TARGET
&#123;
    #if _BLOOM_BICUBIC_UPSAMPLING
    float3 lowerTex = SampleTexture2DBicubic(_BloomLowerTexture, sampler_LinearClamp, IN.uv, _BloomLowerTexture_TexelSize.zwxy, (1.0).xx, 0.0).rgb;
    #else
    float3 lowerTex = SAMPLE_TEXTURE2D_LOD(_BloomLowerTexture, sampler_LinearClamp, IN.uv, 0).rgb;
    #endif

    float3 higherTex = SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv, 0).rgb;

    lowerTex += higherTex - ApplyBloomThreshold(higherTex);
    return float4(lerp(higherTex, lowerTex, _BloomIntensity), 1.0);
&#125;
</code></pre><p>我们在原图片和有 bloom 效果的新图片使用 _BloomIntensity 做插值方便我们控制整体的 Bloom 强度。传递参数的工作如下，最好将 Scattering Bloom 和 Addictive Bloom 的 Intensity 属性分开，因为 Scattering Bloom 的 Intensity 的范围是 0 - 1 之间，而 Addictive Bloom 可以无限大：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Final Blit</span></span><br><span class="line">    bloomParams = settings.mode.<span class="keyword">value</span> == BloomMode.Additive ? <span class="keyword">new</span> Vector4(settings.intensity.<span class="keyword">value</span>, <span class="number">0.0f</span>) : <span class="keyword">new</span> Vector4(settings.finalIntensity.<span class="keyword">value</span>, <span class="number">0.0f</span>);</span><br><span class="line">    <span class="built_in">int</span> finalPass = settings.mode.<span class="keyword">value</span> == BloomMode.Additive ? <span class="number">3</span> : <span class="number">5</span>;</span><br><span class="line">    data.buffer.SetGlobalVector(k_BloomParamsId, bloomParams);</span><br><span class="line">    data.buffer.SetGlobalTexture(k_BloomLowerTextureID, <span class="keyword">new</span> RenderTargetIdentifier(lastDst));</span><br><span class="line">    BlitUtility.BlitTexture(data.buffer, RenderTargetIDs.k_FrameBufferId, BuiltinRenderTextureType.CameraTarget, BloomMaterial, finalPass);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子就实现了 Scattering Bloom，和 Addictive Bloom 的效果对比如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/19/FtsGQbrKnMxoh5q.png" width = "90%" height = "90%" alt="图94 - Scattering Bloom 和 Addictive Bloom 的效果对比"/>
</div>

<p>从上图可以看出，Scattering Bloom 的效果相对比较不易察觉的，它是一个相对更加真实的效果，没有改变场景的整体亮度，并且只有在亮度很大的时候才会展现得比较明显，它的这种特性只能在亲自体验后才能感觉到，只看上图可能感受不是很明显。Addictive Bloom 则改变了场景中的亮度，所以它看起来比 Scattering Bloom 的效果更明显，也更亮。</p>
<h1 id="Tone-Mapping"><a href="#Tone-Mapping" class="headerlink" title="Tone Mapping"></a>Tone Mapping</h1><p>Tone Mapping 经过了一个很长时间的发展，在这个过程中出现了很多的 tone mapping 算法。常见的有 <strong>Reinhard Tone Mapping</strong>、<strong>Uncharted 2 Filmic Tone Mapping</strong>、<strong>Khronos PBR Neutral Tone Mapping</strong>、<strong>ACES Tone Mapping</strong>、<strong>AgX Tone Mapping</strong>。</p>
<h2 id="Tone-Mapping-算法代码"><a href="#Tone-Mapping-算法代码" class="headerlink" title="Tone Mapping 算法代码"></a>Tone Mapping 算法代码</h2><h3 id="Reinhard"><a href="#Reinhard" class="headerlink" title="Reinhard"></a>Reinhard</h3><p>Reinhard Tone Mapping 来自于这篇论文：<a target="_blank" rel="noopener" href="https://www-old.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf">https://www-old.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf</a> 。从该篇论文中，可以提炼出 3 种应用：  </p>
<p>①第一个是最基础的 Reinhard tone mapping，可以称为 “Simple” Reinhard：  </p>
<script type="math/tex; mode=display">L_d = \cfrac {L} {1 + L}</script><pre><code>float3 Reinhard_Simple(float3 color)
&#123;
    return color / (color + 1.0);
&#125;
</code></pre><p>②第二个是 “Simple” Reinhard 的扩展，可以称为 “Extended” Reinhard：  </p>
<script type="math/tex; mode=display">L_d = \cfrac {L(1 + \cfrac {L} {L_{white}^2})} {1 + L}</script><pre><code>float3 Reinhard_Extended(float3 color, float minWhite)
&#123;
    float minWhite2 = minWhite * minWhite;
    float3 numerator = color * (1.0 + color / minWhite2);
    return numerator / (1.0 + color);
&#125;
</code></pre><p>上述公式中的 $\,L_{white}\,$ 是用户控制的变量，代表着在场景中纯白色的最低亮度值。当 $\,L_{white}\,$ 趋向于无穷大时，”Extended” Reinhard 就会跟 “Simple” Reinhard 一样。</p>
<p>③从上面公式可以看出，我们不应该直接用颜色进行计算，而应该用亮度值，因为 L 代表着 luminance。但是因为我们无法将 RGB 转化为 luminance 后，再从 luminance 转换回 RGB。所以下面代码中，使用 Tone Mapping 前的 luminance 和后的 luminance 对最后的输出颜色做了一次缩放：  </p>
<pre><code>float3 Reinhard_ExtendedLuminance(float3 color, float minWhite)
&#123;
    float l_in = Luminance(color);
    float minWhite2 = minWhite * minWhite;
    float numerator = l_in * (1.0 + l_in / minWhite2);
    float l_out = numerator / (1.0 + l_in);
    return color * l_out / l_in;
&#125;
</code></pre><h3 id="Uncharted-2-Filmic"><a href="#Uncharted-2-Filmic" class="headerlink" title="Uncharted 2 Filmic"></a>Uncharted 2 Filmic</h3><p>Uncharted 2 Filmic Tone Mapping 最早来自于 GDC 2010 的一个演讲 Uncharted 2: HDR Lighting，演讲者为顽皮狗 Naughty Dog 公司的 John Hable。后来 John Hable 在自己的博客中做了总结和修改：<a target="_blank" rel="noopener" href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">http://filmicworlds.com/blog/filmic-tonemapping-operators/</a> 。之后他又提出了对 Filmic 曲线进行更多控制的手段：<a target="_blank" rel="noopener" href="http://filmicworlds.com/blog/filmic-tonemapping-with-piecewise-power-curves/">http://filmicworlds.com/blog/filmic-tonemapping-with-piecewise-power-curves/</a> 。本篇文章只涉及他第一篇文章内的 Uncharted 2 Filmic Tone Mapping，不涉及对 Filmic Tonemapping curves 进行自定义。代码如下：  </p>
<pre><code>float3 Uncharted2(float3 x)
&#123;
    const float A = 0.15;
    const float B = 0.50;
    const float C = 0.10;
    const float D = 0.20;
    const float E = 0.02;
    const float F = 0.30;
    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
&#125;

float3 Uncharted2Filmic(float3 color, float exposureBias)
&#123;
    float3 curr = Uncharted2(color * exposureBias);
    const float W = 11.2;
    float3 whiteScale = 1.0 / Uncharted2(W);
    return whiteScale * curr;
&#125;
</code></pre><h3 id="Khronos-PBR-Neutral"><a href="#Khronos-PBR-Neutral" class="headerlink" title="Khronos PBR Neutral"></a>Khronos PBR Neutral</h3><p>Khronos PBR Neutral Tone Mapping 是由 Khronos Group 组织提出的，该组织由很多国际知名多媒体行业领导者创立，致力于发展开放标准的应用程序接口 API。Vulkan API 就是由该组织研发并发布的。该 Tone Mapping 的研发者还写了一篇文章，说明了该算法所要解决的问题：<a target="_blank" rel="noopener" href="https://modelviewer.dev/examples/tone-mapping">https://modelviewer.dev/examples/tone-mapping</a> 。顾名思义，该算法想要更好地体现 PBR 所展现出来的最真实最还原的状态，保留其色调和饱和度，代码如下：  </p>
<pre><code>float3 KhronosPBRNeutral(float3 color)
&#123;
    const float startCompression = 0.76;
    const float desaturation = 0.15;

    float x = min(color.r, min(color.g, color.b));
    float offset = x &lt; 0.08 ? x - 6.25 * x * x : 0.04;
    color -= offset;

    float peak = max(color.r, max(color.g, color.b));
    if (peak &lt; startCompression) return color;

    const float d = 0.24;
    float newPeak = 1.0 - d * d / (peak + d - startCompression);
    color *= newPeak / peak;

    float g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.);
    return lerp(color, newPeak * float3(1.0, 1.0, 1.0), g);
&#125;
</code></pre><h3 id="ACES"><a href="#ACES" class="headerlink" title="ACES"></a>ACES</h3><p><strong>Academy Color Encoding System（ACES）</strong> 是由美国电影艺术与科学学院（AMPAS）和行业合作伙伴开发的开放式色彩管理和互换系统，它规范了所有不同类型的项目中的色彩科学，其创立的目的是为行业提供标准化的色彩管理系统。ACES 是开源的，具体详见 <a target="_blank" rel="noopener" href="https://github.com/ampas/aces">https://github.com/ampas/aces</a> 。整套色彩转换工作流程极其复杂，下面简单梳理一下（可能描述得不是很准确）：  </p>
<p>首先 ACES 流程有如下几个组成部分：<br><strong>①Input Device Transform (IDT)</strong>：这一步骤也称为 Input Transform，主要目的是将输入设备颜色数据转换至 ACES 色彩空间。ACES 色彩空间又包括：<br>&emsp;&emsp; - <strong>ACES2065-1</strong>：这是一个非常广域的线性色彩空间，比人眼还广，主要是为了存储归档以及部门之间传递素材使用；<br>&emsp;&emsp; - <strong>ACEScc</strong>、<strong>ACEScct</strong>：log 色彩空间，主要用于色彩校正或调色；<br>&emsp;&emsp; - <strong>ACEScg</strong>：线性色彩空间，主要用于 CG 或特效制作。  </p>
<p>下面三个组成部分又合称为 ACES viewing pipeline，其中：<br><strong>②Look Modification Transform (LMT)</strong>：这一步骤不是必需的，主要是给艺术家更方便地调色，LMT 始终在 ACES 色彩空间中工作；  </p>
<p>③ 和 ④ 又合称为 Output Transform，要将 ACES 色彩空间转换为非 ACES 色彩空间都需要有 RRT 的参与：<br><strong>③Reference Rendering Transform (RRT)</strong>：这步就是核心的一步，将 IDT 转换获得的标准的、高精度的、高动态范围的场景参考线性图像数据，使用一个 S 形曲线，映射到输出颜色编码空间以适用于参考显示设备的观看。<br><strong>④Output Device Transform (ODT)</strong> 这是 ACES 色彩管理流程中图像信号最终输出转换，就是转换成最终播出设备所需要的色彩空间，例如 Rec.709、Rec.2020、DCI-P3 等。</p>
<p>可以看到一个完整的 ACES 流程非常复杂，所幸的是 Unity 提供了相关的函数，在 Core RP Library 的 ACES.hlsl 和 Color.hlsl 文件中，具体会在后面的实现中进行说明。由于完整的 ACES 流程计算量较大，所以有大佬提出了提出了拟合 ACES 曲线的代码，比较出名的有 Stephen Hill Fit 和 Krzysztof Narkowicz Fit，代码分别来源于：<a target="_blank" rel="noopener" href="https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl">https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl</a> ，<a target="_blank" rel="noopener" href="https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/">https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/</a> 。</p>
<p><strong>Stephen Hill Fit</strong>：  </p>
<pre><code>static const float3x3 ACESInputMat =
&#123;
    &#123;0.59719, 0.35458, 0.04823&#125;,
    &#123;0.07600, 0.90834, 0.01566&#125;,
    &#123;0.02840, 0.13383, 0.83777&#125;
&#125;;

static const float3x3 ACESOutputMat =
&#123;
    &#123; 1.60475, -0.53108, -0.07367&#125;,
    &#123;-0.10208,  1.10813, -0.00605&#125;,
    &#123;-0.00327, -0.07276,  1.07602&#125;
&#125;;

float3 RRTAndODTFit(float3 v)
&#123;
    float3 a = v * (v + 0.0245786f) - 0.000090537f;
    float3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;
    return a / b;
&#125;

float3 ACESStephenHillFit(float3 color)
&#123;
    color = mul(ACESInputMat, color);

    // Apply RRT and ODT
    color = RRTAndODTFit(color);

    color = mul(ACESOutputMat, color);

    // Clamp to [0, 1]
    color = saturate(color);
    return color;
&#125;
</code></pre><p><strong>Krzysztof Narkowicz Fit</strong>：</p>
<pre><code>float3 ACESApproxFit(float3 color)
&#123;
    color *= 0.6;
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return saturate(color * (a * color + b)/(color * (c * color + d) + e));
&#125;
</code></pre><p>Krzysztof Narkowicz Fit 相对来说拟合误差更大，但是计算量小很多。</p>
<h3 id="AgX"><a href="#AgX" class="headerlink" title="AgX"></a>AgX</h3><p>AgX 因为 Blender 在使用开始逐渐出名，是由 Troy Sobotka 开发的，详见 <a target="_blank" rel="noopener" href="https://github.com/sobotka">https://github.com/sobotka</a> ，最初为 OpenColorIO 编写。<strong>OpenColorIO (OCIO)</strong> 是一个开源的色彩管理框架，专为电影、视觉效果、动画和游戏等视觉创作行业设计。OCIO 包含一个配置文件：config.ocio，该配置文件包含了 LUT 文件的索引，支持多种 LUT 格式，如 .cube、.3dl、.spi1d 等。LUT 的相关知识，后面讲 Color Grading 时会详细讲解。</p>
<p>AgX 的 LUT 生成代码可以看 <a target="_blank" rel="noopener" href="https://github.com/sobotka/SB2383-Configuration-Generation/blob/main/AgX.py">https://github.com/sobotka/SB2383-Configuration-Generation/blob/main/AgX.py</a> 或 <a target="_blank" rel="noopener" href="https://github.com/EaryChow/AgX_LUT_Gen">https://github.com/EaryChow/AgX_LUT_Gen</a> 。有人将其代码转换为了 Shader 代码，见 <a target="_blank" rel="noopener" href="https://github.com/MrLixm/AgXc">https://github.com/MrLixm/AgXc</a> 或 <a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/dtSGD1">https://www.shadertoy.com/view/dtSGD1</a> 。但实现起来仍然过于复杂，我又在网上找到了近似的方案：详见 <a target="_blank" rel="noopener" href="https://iolite-engine.com/blog_posts/minimal_agx_implementation">https://iolite-engine.com/blog_posts/minimal_agx_implementation</a> 或 <a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/cd3XWr">https://www.shadertoy.com/view/cd3XWr</a> 。近似代码如下：  </p>
<pre><code>// 0: Default, 1: Golden, 2: Punchy
#define AGX_LOOK 0

float3 AgXDefaultContrastApprox(float3 x)
&#123;
    float3 x2 = x * x;
    float3 x4 = x2 * x2;

    return + 15.5     * x4 * x2
        - 40.14    * x4 * x
        + 31.96    * x4
        - 6.868    * x2 * x
        + 0.4298   * x2
        + 0.1191   * x
        - 0.00232;
&#125;

float3 AgX(float3 val)
&#123;
    const float3x3 agx_mat = float3x3( 0.842479062253094,   0.0784335999999992,  0.0792237451477643,
                                    0.0423282422610123,  0.878468636469772,   0.0791661274605434,
                                    0.0423756549057051,  0.0784336,           0.879142973793104);

    const float min_ev = -12.47393f;
    const float max_ev = 4.026069f;

    // Input transform
    val = mul(agx_mat, val);

    // Log2 space encoding
    val = clamp(log2(val), min_ev, max_ev);
    val = (val - min_ev) / (max_ev - min_ev);

    // Apply sigmoid function approximation
    val = AgXDefaultContrastApprox(val);

    return val;
&#125;

float3 AgXEotf(float3 val)
&#123;
    const float3x3 agx_mat_inv = float3x3(  1.19687900512017,    -0.0980208811401368,  -0.0990297440797205,
                                        -0.0528968517574562,   1.15190312990417,    -0.0989611768448433,
                                        -0.0529716355144438,  -0.0980434501171241,   1.15107367264116);

    // Undo input transform
    val = mul(agx_mat_inv, val);

    // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display
    // NOTE: We&#39;re linearizing the output here. Comment/adjust when not using a sRGB render target
    val = pow(val, 2.2);

    return val;
&#125;

float3 AgXLook(float3 val)
&#123;
    const float3 lw = float3(0.2126, 0.7152, 0.0722);
    float luma = dot(val, lw);

    // Default look
    float3 offset = float3(0.0, 0.0, 0.0);
    float3 slope = float3(1.0, 1.0, 1.0);
    float3 power = float3(1.0, 1.0, 1.0);
    float sat = 1.0;

    #if AGX_LOOK == 1
    // Golden
    slope = float3(1.0, 0.9, 0.5);
    power = float3(0.8, 0.8, 0.8);
    sat = 0.8;
    #elif AGX_LOOK == 2
    // Punchy
    slope = float3(1.0, 1.0, 1.0);
    power = float3(1.35, 1.35, 1.35);
    sat = 1.4;
    #endif

    // ASC CDL
    val = pow(val * slope + offset, power);
    return luma + sat * (val - luma);
&#125;

float3 AgXApprox(float3 color)
&#123;
    color = AgX(color);
    color = AgXLook(color);
    color = AgXEotf(color);
    return color;
&#125;
</code></pre><h2 id="SRP-中实现"><a href="#SRP-中实现" class="headerlink" title="SRP 中实现"></a>SRP 中实现</h2><p>因为我们 Bloom 完是直接绘制到 CameraTarget 的，为了对 Bloom 完的结果进行 Tone Mapping，我们要先将 Bloom 的结果输出到一个纹理中，我命名为了 _BloomTexture。创建 RT，释放 RT 以及绘制代码的更改我这里就不做记录了，也比较简单。整个后处理管线的顺序问题，下面讲到 Color Grading 时再讨论。</p>
<p>Tone Mapping 的 VolumeComponent 和 PostProcessingRenderer 类，参考前面 Bloom 的写法就行，也没什么好说的，在 VolumeComponent 里创建对应的 Tone Mapping Mode，再根据选择的 mode 对应的 Shader Pass 去绘制 _BloomTexture 即可，最后输出到 CameraTarget。下面直接讲 Shader 里的处理，以及对应的效果了。为了相对更好地展示不同 Tone Mapping 算法的效果以及方便对比，一个基本的渲染图如下（我这张渲染图，场景颜色比较少，可能不是很能展现不同 Tone Mapping 之间的不同），场景中有一个范围较大的点光源，和台灯位置的聚光灯，聚光灯亮度较高，可以看到台灯照亮位置已经有点过曝了：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/21/eXAwZqBa1fY5GxO.jpg" width = "80%" height = "80%" alt="图95 - 未做 Tone Mapping 前的基准图"/>
</div>

<h3 id="Reinhard-1"><a href="#Reinhard-1" class="headerlink" title="Reinhard"></a>Reinhard</h3><div  align="center">  
<img src="https://s2.loli.net/2025/03/21/fpNIHz4c6UOKJ1j.jpg" width = "80%" height = "80%" alt="图96 - Reinhard Simple"/>
</div>


<div  align="center">  
<img src="https://s2.loli.net/2025/03/21/sU2So8fgZdOL1Bb.jpg" width = "80%" height = "80%" alt="图97 - Reinhard Extended"/>
</div>

<div  align="center">  
<img src="https://s2.loli.net/2025/03/21/dv6UhEnNG5uM7I4.jpg" width = "80%" height = "80%" alt="图98 - Reinhard Luminance"/>
</div>

<p>Extended 和 Luminance 的 $\,L_{white}\,$ 都为 2，越大越接近于 Reinhard Simple。</p>
<h3 id="Uncharted-2-Filmic-1"><a href="#Uncharted-2-Filmic-1" class="headerlink" title="Uncharted 2 Filmic"></a>Uncharted 2 Filmic</h3><div  align="center">  
<img src="https://s2.loli.net/2025/03/21/lFcvCnE7x3HZz9g.jpg" width = "80%" height = "80%" alt="图99 - Uncharted 2 Filmic"/>
</div>

<p>exposureBias 为默认值 2。</p>
<h3 id="Khronos-PBR-Neutral-1"><a href="#Khronos-PBR-Neutral-1" class="headerlink" title="Khronos PBR Neutral"></a>Khronos PBR Neutral</h3><div  align="center">  
<img src="https://s2.loli.net/2025/03/21/qSl2zf1cO7V8xvG.jpg" width = "80%" height = "80%" alt="图100 - Khronos PBR Neutral"/>
</div>

<h3 id="ACES-1"><a href="#ACES-1" class="headerlink" title="ACES"></a>ACES</h3><div  align="center">  
<img src="https://s2.loli.net/2025/03/21/l3PMc9TmE4oVK27.jpg" width = "80%" height = "80%" alt="图101 - ACES"/>
</div>

<h3 id="AgX-1"><a href="#AgX-1" class="headerlink" title="AgX"></a>AgX</h3><div  align="center">  
<img src="https://s2.loli.net/2025/03/21/PSK4FfIHzbQ8C7l.jpg" width = "80%" height = "80%" alt="图102 - AgX default"/>
</div>

<div  align="center">  
<img src="https://s2.loli.net/2025/03/21/dyEtIKrWqRm5P4Y.jpg" width = "80%" height = "80%" alt="图103 - AgX Punchy"/>
</div>

<p><strong>【重新整理 ToneMapping 章节的顺序】</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io">鸟布</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io/2025/03/13/2025-03-13-CustomSRP6/">https://ybniaobu.github.io/2025/03/13/2025-03-13-CustomSRP6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ybniaobu.github.io" target="_blank">鸟布的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/unity/">unity</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2025/03/13/LozNxAmnlEJSOyV.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src="/images/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2025/02/26/2025-02-26-CustomSRP5/" title="Unity Custom SRP 基础（五）"><img class="cover" src="https://s2.loli.net/2025/02/26/m2zJbPd8aeGD14A.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity Custom SRP 基础（五）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/15/2023-09-15-UnityShader1/" title="《Unity Shader入门精要》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2023/09/19/cDvdURBPhjwkOsY.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-15</div><div class="title">《Unity Shader入门精要》读书笔记（一）</div></div></a></div><div><a href="/2023/10/13/2023-10-13-UnityShader2/" title="《Unity Shader入门精要》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2023/10/15/RZftaNSscWoLH1u.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-13</div><div class="title">《Unity Shader入门精要》读书笔记（二）</div></div></a></div><div><a href="/2023/11/22/2023-11-22-UnityShader3/" title="《Unity Shader入门精要》读书笔记（三）"><img class="cover" src="https://s2.loli.net/2023/11/23/L3ts4WnThMlDN9d.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-22</div><div class="title">《Unity Shader入门精要》读书笔记（三）</div></div></a></div><div><a href="/2023/12/19/2023-12-19-UnityShader4/" title="《Unity Shader入门精要》读书笔记（四）"><img class="cover" src="https://s2.loli.net/2023/12/20/9Ah5ugiIpONK1cX.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-19</div><div class="title">《Unity Shader入门精要》读书笔记（四）</div></div></a></div><div><a href="/2023/12/30/2023-12-30-UnityShader5/" title="《Unity Shader入门精要》读书笔记（五）"><img class="cover" src="https://s2.loli.net/2023/12/30/hc2s7BS45l1wUdQ.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-30</div><div class="title">《Unity Shader入门精要》读书笔记（五）</div></div></a></div><div><a href="/2024/03/20/2024-03-20-NPR_StarRail1/" title="基于星穹铁道的卡通渲染（一）"><img class="cover" src="https://s2.loli.net/2024/03/26/dZTwsApi59CSUal.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="title">基于星穹铁道的卡通渲染（一）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/wechat%20avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鸟布</div><div class="author-info__description">教练，我想学技术</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://niaobu.notion.site/787824630ea6480e944c1ae5ae7f4792"><i class="fa-solid fa-book"></i><span>My Notion</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ybniaobu/ybniaobu.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:niaobubob@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为了蒂法！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HDR"><span class="toc-number">1.</span> <span class="toc-text">HDR</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81-HDR-rendering"><span class="toc-number">1.1.</span> <span class="toc-text">支持 HDR rendering</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HDR-Bloom"><span class="toc-number">1.2.</span> <span class="toc-text">HDR Bloom</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bloom-%E9%97%AA%E7%83%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">Bloom 闪烁问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Scattering-Bloom"><span class="toc-number">2.</span> <span class="toc-text">Scattering Bloom</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Scatter"><span class="toc-number">2.1.</span> <span class="toc-text">Scatter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final-Blit"><span class="toc-number">2.2.</span> <span class="toc-text">Final Blit</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tone-Mapping"><span class="toc-number">3.</span> <span class="toc-text">Tone Mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Tone-Mapping-%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81"><span class="toc-number">3.1.</span> <span class="toc-text">Tone Mapping 算法代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reinhard"><span class="toc-number">3.1.1.</span> <span class="toc-text">Reinhard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uncharted-2-Filmic"><span class="toc-number">3.1.2.</span> <span class="toc-text">Uncharted 2 Filmic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Khronos-PBR-Neutral"><span class="toc-number">3.1.3.</span> <span class="toc-text">Khronos PBR Neutral</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACES"><span class="toc-number">3.1.4.</span> <span class="toc-text">ACES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AgX"><span class="toc-number">3.1.5.</span> <span class="toc-text">AgX</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SRP-%E4%B8%AD%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">SRP 中实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reinhard-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">Reinhard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uncharted-2-Filmic-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">Uncharted 2 Filmic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Khronos-PBR-Neutral-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">Khronos PBR Neutral</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACES-1"><span class="toc-number">3.2.4.</span> <span class="toc-text">ACES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AgX-1"><span class="toc-number">3.2.5.</span> <span class="toc-text">AgX</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/13/2025-03-13-CustomSRP6/" title="Unity Custom SRP 基础（六）"><img src="https://s2.loli.net/2025/03/13/LozNxAmnlEJSOyV.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（六）"/></a><div class="content"><a class="title" href="/2025/03/13/2025-03-13-CustomSRP6/" title="Unity Custom SRP 基础（六）">Unity Custom SRP 基础（六）</a><time datetime="2025-03-13T12:44:31.000Z" title="发表于 2025-03-13 20:44:31">2025-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/26/2025-02-26-CustomSRP5/" title="Unity Custom SRP 基础（五）"><img src="https://s2.loli.net/2025/02/26/m2zJbPd8aeGD14A.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（五）"/></a><div class="content"><a class="title" href="/2025/02/26/2025-02-26-CustomSRP5/" title="Unity Custom SRP 基础（五）">Unity Custom SRP 基础（五）</a><time datetime="2025-02-26T03:30:46.000Z" title="发表于 2025-02-26 11:30:46">2025-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/02/2025-02-02-CustomSRP4/" title="Unity Custom SRP 基础（四）"><img src="https://s2.loli.net/2025/02/02/aLrYVUITs8tnuOw.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（四）"/></a><div class="content"><a class="title" href="/2025/02/02/2025-02-02-CustomSRP4/" title="Unity Custom SRP 基础（四）">Unity Custom SRP 基础（四）</a><time datetime="2025-02-02T06:35:41.000Z" title="发表于 2025-02-02 14:35:41">2025-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/07/2025-01-07-CustomSRP3/" title="Unity Custom SRP 基础（三）"><img src="https://s2.loli.net/2025/01/14/ELDF7wHpCPn2mKM.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（三）"/></a><div class="content"><a class="title" href="/2025/01/07/2025-01-07-CustomSRP3/" title="Unity Custom SRP 基础（三）">Unity Custom SRP 基础（三）</a><time datetime="2025-01-07T12:43:16.000Z" title="发表于 2025-01-07 20:43:16">2025-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/09/2024-12-09-CustomSRP2/" title="Unity Custom SRP 基础（二）"><img src="https://s2.loli.net/2024/12/09/paBhbkD6Vd9CIsy.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（二）"/></a><div class="content"><a class="title" href="/2024/12/09/2024-12-09-CustomSRP2/" title="Unity Custom SRP 基础（二）">Unity Custom SRP 基础（二）</a><time datetime="2024-12-09T08:00:29.000Z" title="发表于 2024-12-09 16:00:29">2024-12-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By 鸟布</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Your time is limited, so don't waste it living someone else's life.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>