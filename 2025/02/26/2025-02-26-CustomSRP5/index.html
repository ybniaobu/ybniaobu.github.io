<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity Custom SRP 基础（五） | 鸟布的博客</title><meta name="author" content="鸟布"><meta name="copyright" content="鸟布"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本笔记的主要内容包含 PCSS 的实现；如何在 SRP 中使用 Unity 提供的用于 Post Processing 的 Volume 框架；自定义比 Blit 效率更高的 Copy Shader；LDR Additive Bloom 特效的原理和实现。"><link rel="shortcut icon" href="https://s2.loli.net/2022/09/08/Ygib4lfw6z1khnr.png"><link rel="canonical" href="https://ybniaobu.github.io/2025/02/26/2025-02-26-CustomSRP5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 鸟布","link":"链接: ","source":"来源: 鸟布的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity Custom SRP 基础（五）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-18 13:56:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/wechat%20avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/black.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鸟布的博客"><span class="site-name">鸟布的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-bars"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity Custom SRP 基础（五）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-26T03:30:46.000Z" title="发表于 2025-02-26 11:30:46">2025-02-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-18T05:56:19.913Z" title="更新于 2025-03-18 13:56:19">2025-03-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/unity/">unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/unity/pipeline/">pipeline</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity Custom SRP 基础（五）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本笔记是关于 Unity 的<strong>自定义可编程渲染管线</strong>的入门基础，即 <strong>SRP (Scriptable Rendering Pipeline)</strong>，主要参考了著名的教程 <a target="_blank" rel="noopener" href="https://catlikecoding.com/">https://catlikecoding.com/</a> 的 Custom SRP Tutorial，以及知乎上各位图形学大神们的文章。  </p>
<p>笔者使用的 Unity 版本是 6000.0.27f1，Core RP Library 的版本是 17.0.3。</p>
</blockquote>
<h1 id="PCSS"><a href="#PCSS" class="headerlink" title="PCSS"></a>PCSS</h1><p>本章节讲解<strong>百分比接近软阴影 Percentage-Closer Soft Shadows (PCSS)</strong> 的实现，这部分内容是 catlikecoding 教程中没有的。PCSS 解决了 PCF 均匀相同的半影宽度问题，能够根据<strong>遮挡物 Blocker</strong> 和<strong>接受物 Receiver</strong> 之间的距离产生可变宽度的软阴影效果。该技术最早由 NVIDIA 的一篇论文提出：<a target="_blank" rel="noopener" href="https://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">Percentage-Closer Soft Shadows</a> ，本章节也是基于这篇论文书写的。 </p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p><strong>第一步：Blocker Search</strong><br>搜索阴影贴图的一定的区域，并记录下比采样点离光源更近的深度值做平均（注意这里只平均比采样点更近的遮挡物的深度值）。理论上来说，搜索区域的大小是由灯光大小和接受物离光源的距离共同决定的，如下图：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/02/27/mw86o9gnCTrKx1e.jpg" width = "50%" height = "50%" alt="图78 - Blocker Search Step"/>
</div>

<p>阴影贴图的位置是在灯光的近裁切平面，所以真实的搜索区域的大小需要通过相似三角形计算得到。但是在实际操作中，因为近裁切平面离光源非常近，我们可以假定近裁切平面就在灯光的位置。这样搜索区域的大小在世界空间下就是灯光的大小。根据灯光的大小和世界空间下阴影贴图的大小，可以计算出灯光所占阴影贴图的比例，就可以得到灯光所占阴影贴图像素的范围。</p>
<p>为什么要对遮挡距离进行平均计算，而不直接使用<strong>着色点 shading point</strong> 的采样深度。是因为一旦该点未被遮挡，遮挡距离会直接变为 0，这样就会形成一条具体的边缘，阴影将无法散开。</p>
<p><strong>第二步：Penumbra Estimation</strong><br>根据计算得到的平均遮挡距离、着色点距离（接受物距离）和灯光大小，使用相似三角形计算半影宽度，如下图：  </p>
<script type="math/tex; mode=display">\omega_{Penumbra} = \cfrac {(d_{Receiver} - d_{Blocker}) \cdot \omega_{Light}} {d_{Blocker}}</script><div  align="center">  
<img src="https://s2.loli.net/2025/02/27/6TaGFh1Hz54vmdU.jpg" width = "25%" height = "25%" alt="图79 - Penumbra Estimation Step "/>
</div>

<p><strong>第三步：Filtering</strong><br>这一步跟 PCF 是一样的，只不过滤波核大小使用的上一步估算出来的大小，可以使用一个参数乘以计算出来的半影宽度，来控制滤波核大小。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面为方向光、点光源、聚光灯的 PCSS 的具体实现，因为这三种光源的实现细节会有所不同，故一个一个讲，首先是最简单的聚光灯。</p>
<h3 id="聚光灯"><a href="#聚光灯" class="headerlink" title="聚光灯"></a>聚光灯</h3><p>首先是需要从 CPU 传递到 GPU 的可控制的参数，CPU 中具体步骤这里就不摘抄了：  </p>
<pre><code>CBUFFER_START(LightParamsPerFrame)
    ...
    float4 _SpotLightShadowBias[MAX_SHADOWING_SPOT_LIGHT_COUNT]; // x: depth bias, y: slope scaled depth bias, z: normal bias, w: slope scaled normal bias
    float4 _SpotLightShadowParams[MAX_SHADOWING_SPOT_LIGHT_COUNT]; // x: light size, y: penumbra scale, z: blocker search sample number, w: filter sample number
    float4 _SpotLightDepthParams[MAX_SHADOWING_SPOT_LIGHT_COUNT]; // x: (f + n) / (f - n), y: -2 * f * n / (f - n); [if UNITY_REVERSED_Z] x: (f + n) / (n - f), y: -2 * f * n / (n - f)
    ...
CBUFFER_END
</code></pre><p>原本我 Shadow Bias 的四个参数是全光源共用的，后来从效果体验上觉得对于点光源、聚光灯和方向光还是分开比较好。当然也可以选择所有点光源、所有聚光灯、所有方向光都分别共用一个 Shadow Bias，即三个 Shadow Bias 作为全局设置。但我最终还是选择了把 Shadow Bias 作为 per-light 设置，即一个灯光一个 Shadow Bias。<code>_SpotLightDepthParams</code> 里面的参数是用于将非线性深度转变为线性深度的，后面会提到。</p>
<h4 id="Blocker-Search"><a href="#Blocker-Search" class="headerlink" title="Blocker Search"></a>Blocker Search</h4><p>然后就是 PCSS 的第一步 Blocker Search 了，先确定搜索区域的范围，即灯光所占阴影贴图的比例，用灯光大小除以阴影贴图的大小，两者都是在世界空间下的大小。对于聚光灯来说，由于不是正交投影，阴影贴图的大小对于不同深度的着色点是不同的，这点在 PCF 中也提到过，就不再重复了：  </p>
<pre><code>float searchWidthWS = GetSpotLightSize(shadowingSpotLightIndex);
float searchWidthPercent = searchWidthWS / (2.0 * ComputeTanHalfFOV(lightIndex) * linearDepth);
</code></pre><p>拿到了搜索区域的范围，就可以利用它偏移着色点并在阴影贴图上采样，获取遮挡物深度值最后平均。这里注意一下，我们要获取的是线性深度值，而直接在阴影贴图上采样得到的是非线性深度值，后面计算半影宽度需要的是线性深度。这里可以选择用非线性深度值做平均后再转换为线性深度值，但相对来说不太准确（其实影响也不大）。我这里选择的是，每次采样后都转换为线性深度，再做平均。</p>
<p>如何将非线性深度值转换为线性深度属于基础知识了，忘了回去看《Unity Shader入门精要》。我这里直接写结论了，首先传递投影矩阵的 m22 和 m23 分量，注意如果 Reversed Z 就传递 -m22 和 -m23，这样在 Shader 里就不用判断 Reversed Z 了，计算出来都是从近到远变大的线性深度值：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">m_SpotLightDepthParams[i] = SystemInfo.usesReversedZBuffer</span><br><span class="line">                            ? <span class="keyword">new</span> Vector4(-projectionMatrix.m22, -projectionMatrix.m23)</span><br><span class="line">                            : <span class="keyword">new</span> Vector4(projectionMatrix.m22, projectionMatrix.m23);</span><br></pre></td></tr></table></figure>
<p>在 Shader 中线性深度转换代码如下：  </p>
<pre><code>float NonLinearToLinearDepth(float4 depthParams, float nonLinearDepth)
&#123;
    return depthParams.y / (2.0 * nonLinearDepth - 1.0 + depthParams.x);
&#125;
</code></pre><p>注意，在计算平均遮挡深度时，仅在发生遮挡的时候才计入平均距离，故需要做判断。这里可以选择比较非线性深度值，也可以选择比较线性深度值，但是选择比较非线性深度值需要做 Reversed Z 判断并反转大于小于符号，代码如下：  </p>
<pre><code>float2 ComputeAverageBlockerDepth(float index, TEXTURE2D_ARRAY(shadowMap), float sampleNumber, float searchWidthPercent, float3 positionSS, float4 depthParams, uint hash1, uint hash2, float2x2 rotation)
&#123;
    float d_Shading = positionSS.z;
    float ld_Shading = NonLinearToLinearDepth(depthParams, d_Shading);
    float ald_Blocker = 0.0;
    float count = 1e-8; // avoid division by zero

    for (int i = 0; i &lt; sampleNumber; i++)
    &#123;
        float2 offset = mul(rotation, InverseSampleCircle(Sobol_Scrambled(i, hash1, hash2))) * 0.5;
        offset = offset * searchWidthPercent;
        float2 uv = positionSS.xy + offset;
        float d_Blocker = SampleShadowArray_Depth(uv, index, shadowMap, SHADOW_SAMPLER);
        float ld_Blocker = NonLinearToLinearDepth(depthParams, d_Blocker);

        if (ld_Blocker &lt; ld_Shading)
        &#123;
            ald_Blocker += ld_Blocker;
            count += 1.0;
        &#125;
    &#125;
    ald_Blocker = ald_Blocker / count;
    return float2(ald_Blocker, count);
&#125;
</code></pre><p>上述代码中变量的前缀 d、ld、ald 的含义分别为 depth、linear depth、average linear depth。offset 需要乘以 0.5 是因为 Sobol 序列随机数生成的范围是 [0, 1]，圆盘化后范围变为了 [-1, 1]，这样范围就从 1 变为 2 了。这样子就可以得到平均遮挡深度了，但是仍然存在问题。我将着色点深度减去平均遮挡深度所占着色点深度的比例（d_Shading - ald_Blocker）/ d_Shading 输出如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/02/27/Ufsjnp1zAcWv5m7.jpg" width = "40%" height = "40%" alt="图80 - 自遮挡现象"/>
</div>

<p>为了方便观察，我将 Light Size 设置为了 0。可以看到有非常多的 alias，在“阴影”区域内的表现是正确的，立方体底部因为遮挡物和接受物非常接近，故输出值接近 0，接近黑色。但是在“阴影”区域外的 alias 区域从理论上来说都应该是白色，因为这些着色点并没有遮挡物，即 ald_Blocker 为 0，输出应该为 1。而且若将 Light Size 变大，alias 区域就会变为全黑色。这些 alias 产生的原因跟自阴影走样是一样的，那么解决方法自然就是 shadow bias，我选择第三步的 Filtering 和这里共用一个 shadow bias。为了节省计算，<code>ApplyShadowBias()</code> 函数我又改回了 (texelSize + penumbraWS) * shadowBias 的计算方法。</p>
<pre><code>float GetSpotLightShadowAttenuation_PCSS(int lightIndex, float3 positionWS, float3 normalWS, float3 L, float linearDepth)
&#123;
    float shadowingSpotLightIndex = GetShadowingSpotLightIndex(lightIndex);
    float texelSize = 2.0 * ComputeTanHalfFOV(lightIndex) * linearDepth / GetPunctualLightShadowArraySize();
    float searchWidthWS = GetSpotLightSize(shadowingSpotLightIndex);
    float searchWidthPercent = searchWidthWS / (2.0 * ComputeTanHalfFOV(lightIndex) * linearDepth);

    float3 positionWS_SearchBias = ApplyShadowBias(positionWS, GetSpotLightShadowBias(shadowingSpotLightIndex), texelSize, searchWidthWS, normalWS, L);
    float3 positionSS_Search = TransformWorldToSpotLightShadowCoord(positionWS_SearchBias, shadowingSpotLightIndex);

    uint hash1 = Hash_Jenkins(asuint(positionWS));
    uint hash2 = Hash_Jenkins(asuint(positionSS_Search));
    float random = floatConstruct(hash1);
    float randomRadian = random * TWO_PI;
    float2x2 rotation = float2x2(cos(randomRadian), -sin(randomRadian), sin(randomRadian), cos(randomRadian));
    float4 depthParams = GetSpotLightDepthParams(shadowingSpotLightIndex);
    float blockerSampleNumber = GetSpotLightBlockerSampleNumber(shadowingSpotLightIndex);

    float2 blocker = ComputeAverageBlockerDepth(shadowingSpotLightIndex, SPOT_LIGHT_SHADOW_MAP, blockerSampleNumber, searchWidthPercent, positionSS_Search, depthParams, hash1, hash2, rotation);
    float ald_Blocker = blocker.x;
    float blockerCount = blocker.y;

    ...
&#125;
</code></pre><h4 id="Penumbra-Estimation-amp-Filtering"><a href="#Penumbra-Estimation-amp-Filtering" class="headerlink" title="Penumbra Estimation &amp; Filtering"></a>Penumbra Estimation &amp; Filtering</h4><p>有了平均遮挡深度后，就可以计算半影宽度了，我增加了一个参数用于控制半影宽度的大小，即 penumbra scale：  </p>
<pre><code>float penumbraWS = GetSpotLightPenumbraScale(shadowingSpotLightIndex) * GetSpotLightSize(shadowingSpotLightIndex) * (linearDepth - ald_Blocker) / ald_Blocker;
float penumbraPercent = penumbraWS / (2.0 * ComputeTanHalfFOV(lightIndex) * linearDepth);
</code></pre><p>后面就跟 PCF 一模一样了，没什么好讲的，只不过要注意的是，ald_Blocker 为 0 时，即没有遮挡物时，shadow attenuation 应该设置为 1.0，代码如下（为了节省计算，<code>ApplyPCF()</code> 函数里的 offset 改为了不除以 shadowArraySize，免得一乘一除重复计算）：  </p>
<pre><code>float GetSpotLightShadowAttenuation_PCSS(int lightIndex, float3 positionWS, float3 normalWS, float3 L, float linearDepth)
&#123;
    float shadowStrength = GetSpotLightShadowStrength(lightIndex);
    float distanceFade = ComputeDistanceFade(positionWS, GetMaxShadowDistance(), GetShadowDistanceFade());

    ... // Blocker Search

    if (blockerCount &lt; 1.0) return 1.0;

    float penumbraWS = GetSpotLightPenumbraScale(shadowingSpotLightIndex) * GetSpotLightSize(shadowingSpotLightIndex) * (linearDepth - ald_Blocker) / ald_Blocker;
    float penumbraPercent = penumbraWS / (2.0 * ComputeTanHalfFOV(lightIndex) * linearDepth);
    float3 positionWS_FilterBias = ApplyShadowBias(positionWS, GetSpotLightShadowBias(shadowingSpotLightIndex), texelSize, penumbraWS, normalWS, L);
    float3 positionSS_Filter = TransformWorldToSpotLightShadowCoord(positionWS_FilterBias, shadowingSpotLightIndex);
    float filterSampleNumber = GetSpotLightFilterSampleNumber(shadowingSpotLightIndex);
    float shadowAttenuation = ApplyPCF_2DArray(shadowingSpotLightIndex, SPOT_LIGHT_SHADOW_MAP, filterSampleNumber, penumbraPercent, positionSS_Filter, hash1, hash2, rotation);

    return lerp(1.0, shadowAttenuation, shadowStrength * distanceFade);
&#125;
</code></pre><p>最终效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/02/28/9FBCeUQVX3IdlpE.jpg" width = "50%" height = "50%" alt="图81 - Spot Light PCSS（Blocker Search 和 Filtering 样本数量都为 8）"/>
</div>

<h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><p>点光源和聚光灯逻辑是一样的，只是采样的是 Cubemap，具体区别跟 PCF 那里其实差不多，没必要多讲了，这里就直接写代码了：  </p>
<pre><code>float2 ComputeAverageBlockerDepth_CubeArray(float index, float faceIndex, TEXTURECUBE_ARRAY(shadowMap), float sampleNumber,
    float searchWidthPercent, float3 sampleDir, float3 positionSS, float4 depthParams, uint hash1, uint hash2, float2x2 rotation)
&#123;
    float d_Shading = positionSS.z;
    float ld_Shading = NonLinearToLinearDepth(depthParams, d_Shading);
    float ald_Blocker = 0.0;
    float count = 1e-8; // avoid division by zero

    for (int i = 0; i &lt; sampleNumber; i++)
    &#123;
        float2 offset = mul(rotation, InverseSampleCircle(Sobol_Scrambled(i, hash1, hash2))); // don&#39;t need to divide 2, because cubemap is also [-1, 1]
        offset = offset * searchWidthPercent;
        float3 sampleDir_Offset = sampleDir + GetCubeMapOffset(faceIndex, offset);
        float d_Blocker = SampleShadowCubeArray_Depth(sampleDir_Offset, index, shadowMap, SHADOW_SAMPLER);
        float ld_Blocker = NonLinearToLinearDepth(depthParams, d_Blocker);

        if (ld_Blocker &lt; ld_Shading)
        &#123;
            ald_Blocker += ld_Blocker;
            count += 1.0;
        &#125;
    &#125;
    ald_Blocker = ald_Blocker / count;
    return float2(ald_Blocker, count);
&#125;

float GetPointLightShadowAttenuation_PCSS(int lightIndex, float faceIndex, float3 positionWS, float3 normalWS, float3 L, float linearDepth)
&#123;
    float shadowStrength = GetPointLightShadowStrength(lightIndex);
    float distanceFade = ComputeDistanceFade(positionWS, GetMaxShadowDistance(), GetShadowDistanceFade());

    float shadowingPointLightIndex = GetShadowingPointLightIndex(lightIndex);
    float texelSize = 2.0 * linearDepth / GetPunctualLightShadowArraySize();
    float searchWidthWS = GetPointLightSize(shadowingPointLightIndex);
    float searchWidthPercent = searchWidthWS / (2.0 * linearDepth);

    float3 positionWS_SearchBias = ApplyShadowBias(positionWS, GetPointLightShadowBias(shadowingPointLightIndex), texelSize, searchWidthWS, normalWS, L);
    float3 sampleDir_Search = normalize(positionWS_SearchBias - GetPointLightPosition(lightIndex));
    float3 positionSS_Search = TransformWorldToPointLightShadowCoord(positionWS_SearchBias, shadowingPointLightIndex, faceIndex);

    uint hash1 = Hash_Jenkins(asuint(positionWS));
    uint hash2 = Hash_Jenkins(asuint(positionSS_Search));
    float random = floatConstruct(hash1);
    float randomRadian = random * TWO_PI;
    float2x2 rotation = float2x2(cos(randomRadian), -sin(randomRadian), sin(randomRadian), cos(randomRadian));

    float4 depthParams = GetPointLightDepthParams(shadowingPointLightIndex);
    float blockerSampleNumber = GetPointLightBlockerSampleNumber(shadowingPointLightIndex);
    float2 blocker = ComputeAverageBlockerDepth_CubeArray(shadowingPointLightIndex,faceIndex, POINT_LIGHT_SHADOW_MAP,
        blockerSampleNumber, searchWidthPercent, sampleDir_Search, positionSS_Search, depthParams, hash1, hash2, rotation);
    float ald_Blocker = blocker.x;
    float blockerCount = blocker.y;

    if (blockerCount &lt; 1.0) return 1.0;

    float penumbraWS = GetPointLightPenumbraScale(shadowingPointLightIndex) * GetPointLightSize(shadowingPointLightIndex) * (linearDepth - ald_Blocker) / ald_Blocker;
    float penumbraPercent = penumbraWS / (2.0 * linearDepth);
    float3 positionWS_FilterBias = ApplyShadowBias(positionWS, GetPointLightShadowBias(shadowingPointLightIndex), texelSize, penumbraWS, normalWS, L);
    float3 sampleDir_Filter = normalize(positionWS_FilterBias - GetPointLightPosition(lightIndex));
    float3 positionSS_Filter = TransformWorldToPointLightShadowCoord(positionWS_FilterBias, shadowingPointLightIndex, faceIndex);
    float filterSampleNumber = GetPointLightFilterSampleNumber(shadowingPointLightIndex);
    float shadowAttenuation = ApplyPCF_CubeArray(shadowingPointLightIndex, faceIndex, POINT_LIGHT_SHADOW_MAP, filterSampleNumber,
        penumbraPercent, sampleDir_Filter, positionSS_Filter, hash1, hash2, rotation);

    return lerp(1.0, shadowAttenuation, shadowStrength * distanceFade);
&#125;
</code></pre><p>效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/02/28/IAYCaJtBgzTR9yh.jpg" width = "50%" height = "50%" alt="图82 - Point Light PCSS（Blocker Search 和 Filtering 样本数量都为 8）"/>
</div>

<h3 id="方向光"><a href="#方向光" class="headerlink" title="方向光"></a>方向光</h3><p>方向光跟精确光的主要区别就是，方向光是正交投影，并且我们不可能把摄像机放置在太阳的位置，这就对我们准确估算半影宽度产生了影响。我们回去看半影宽度估算的公式，首先采样得到的 $\,d_{Blocker}\,$、$\,d_{Receiver}\,$ 是不准的，因为我们的正交视锥体是包裹着视角范围的，而且正交视锥体是多个的，因为使用了级联阴影。我们通过采样拿到的 $\,d_{Blocker}\,$、$\,d_{Receiver}\,$ 仅仅是遮挡物离当前正交视锥体近裁切平面的距离。</p>
<p>但是 $\,d_{Receiver} - d_{Blocker}\,$ 却不会受到影响，无论当前正交视锥体近裁切平面有多远，因为这段距离是由接受物和遮挡物的位置决定的，跟光源位置无关。这样一来由于 $\,\omega_{Light}\,$，即太阳的大小，和真实的 $\,d_{Blocker}\,$ 的尺度过大，我们可以认为真实的 $\,d_{Blocker}\,$ 是不会变的，即太阳和地球的距离。那么 $\,\omega_{Light} / d_{Blocker} \,$ 是个常量，由此一来就可以估算半影宽度了。太阳的<strong>角直径 angular diameter</strong> 约为 0.5332°，太阳的直径约为 1,391,400 km，太阳距离地球的平均距离约为 149,600,000 km。那么 $\,\omega_{Light} / d_{Blocker} \,$ 约为 0.0093，我们可以四舍五入为 0.01。</p>
<p>遮挡物搜索区域的范围仍然用 light size 来控制，只不过这个 light size 没有什么具体意义（推荐还是太阳光和精确光的参数名字分开，我这里就偷懒了）。半影宽度还是可以通过 penumbra scale 控制大小。还有一点要注意的是，对于正交投影和透视投影，非线性深度值转换为线性深度的公式是不同的，代码如下：  </p>
<pre><code>float NonLinearToLinearDepth_Ortho(float4 depthParams, float nonLinearDepth)
&#123;
    return (depthParams.y - 2.0 * nonLinearDepth + 1.0) / depthParams.x;
&#125;
</code></pre><p>除了上述的不同之处之外，PCSS 实现逻辑基本和聚光灯也差不多，代码如下：  </p>
<pre><code>float3 ComputeAverageBlockerDepth_2DArray_Ortho(float index, TEXTURE2D_ARRAY(shadowMap), float sampleNumber,
    float searchWidthPercent, float3 positionSS, float4 depthParams, uint hash1, uint hash2, float2x2 rotation)
&#123;
    float d_Shading = positionSS.z;
    float ld_Shading = NonLinearToLinearDepth_Ortho(depthParams, d_Shading);
    float ald_Blocker = 0.0;
    float count = 1e-8; // avoid division by zero

    for (int i = 0; i &lt; sampleNumber; i++)
    &#123;
        float2 offset = mul(rotation, InverseSampleCircle(Sobol_Scrambled(i, hash1, hash2))) * 0.5;
        offset = offset * searchWidthPercent;
        float2 uv = positionSS.xy + offset;
        float d_Blocker = SampleShadowArray_Depth(uv, index, shadowMap, SHADOW_SAMPLER);
        float ld_Blocker = NonLinearToLinearDepth_Ortho(depthParams, d_Blocker);

        if (ld_Blocker &lt; ld_Shading)
        &#123;
            ald_Blocker += ld_Blocker;
            count += 1.0;
        &#125;
    &#125;
    ald_Blocker = ald_Blocker / count;
    return float3(ald_Blocker, count, ld_Shading);
&#125;

float GetSunLightShadowAttenuation_PCSS(float3 positionWS, float3 normalWS, float3 L)
&#123;
    float cascadeIndex = ComputeCascadeIndex(positionWS);
    if (cascadeIndex &gt;= GetSunLightCascadeCount()) return 1.0;
    float shadowStrength = GetSunLightShadowStrength();
    float shadowFade = 1.0;
    shadowFade *= ComputeDistanceFade(positionWS, GetMaxShadowDistance(), GetShadowDistanceFade());
    shadowFade *= ComputeCascadeEdgeFade(cascadeIndex, GetSunLightCascadeCount(), positionWS, GetCascadeEdgeFade(), GetCascadeCullingSphere(GetSunLightCascadeCount() - 1));

    float texelSize = GetCascadeCullingSphereRadius(cascadeIndex) * 2.0 / GetSunLightShadowArraySize();
    float searchWidthWS = GetSunLightSize();
    float searchWidthPercent = searchWidthWS / GetCascadeCullingSphereRadius(cascadeIndex) * 0.5;

    float3 positionWS_SearchBias = ApplyShadowBias(positionWS, GetSunLightShadowBias(), texelSize, searchWidthWS, normalWS, L);
    float3 positionSS_Search = TransformWorldToSunLightShadowCoord(positionWS_SearchBias, cascadeIndex);

    uint hash1 = Hash_Jenkins(asuint(positionWS));
    uint hash2 = Hash_Jenkins(asuint(positionSS_Search));
    float random = floatConstruct(hash1);
    float randomRadian = random * TWO_PI;
    float2x2 rotation = float2x2(cos(randomRadian), -sin(randomRadian), sin(randomRadian), cos(randomRadian));

    float4 depthParams = GetSunLightDepthParams(cascadeIndex);
    float blockerSampleNumber = GetSunLightBlockerSampleNumber();

    float3 blocker = ComputeAverageBlockerDepth_2DArray_Ortho(cascadeIndex, SUN_LIGHT_SHADOW_MAP, blockerSampleNumber, searchWidthPercent, positionSS_Search, depthParams, hash1, hash2, rotation);
    float ald_Blocker = blocker.x;
    float blockerCount = blocker.y;

    if (blockerCount &lt; 1.0) return 1.0;

    float penumbraWS = GetSunLightPenumbraScale() * (blocker.z - ald_Blocker) * 0.01;
    float penumbraPercent = penumbraWS / GetCascadeCullingSphereRadius(cascadeIndex) * 0.5;

    float3 positionWS_FilterBias = ApplyShadowBias(positionWS, GetSunLightShadowBias(), texelSize, penumbraWS, normalWS, L);
    float3 positionSS_Filter = TransformWorldToSunLightShadowCoord(positionWS_FilterBias, cascadeIndex);
    float filterSampleNumber = GetSunLightFilterSampleNumber();
    float shadowAttenuation = ApplyPCF_2DArray(cascadeIndex, SUN_LIGHT_SHADOW_MAP, filterSampleNumber, penumbraPercent, positionSS_Filter, hash1, hash2, rotation);
    return lerp(1.0, shadowAttenuation, shadowStrength * shadowFade);
&#125;
</code></pre><p>实现效果如下（半影宽度实在太小了，故将 penumbra scale 设置为了 5）：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/02/28/ey3Xsu2o9gvrHmJ.jpg" width = "30%" height = "30%" alt="图83 - Directional（Sun） Light PCSS（Blocker Search 和 Filtering 样本数量都为 8）"/>
</div>

<blockquote>
<p>为了更好地控制半影宽度，最好也将 light size 乘上去：<code>float penumbraWS = GetSunLightPenumbraScale() * GetSunLightSize() * (blocker.z - ald_Blocker) * 0.01 * 10;</code></p>
</blockquote>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>①循环采样问题：在动态循环或动态分支中使用 <code>Texture.Sample()</code> 会报错，解决方案是指定具体的 mipmap 去采样，即使用 <code>Texture.SampleLevel()</code>。原因是因为 sample 需要计算偏导数来决定采样哪个 level 的 mipmap，而由于偏导数的计算方式，其只有在可预测的控制流时才可以计算，即使用常量的控制流。  </p>
<p>②优化噪点问题：可以看到在上面展示的图片当中，噪点问题还是相当严重的。特别是在镜头运动的时候，噪点还会像电视机雪花一样闪烁。这个问题我打算在学习 <strong>Temporal Anti-Aliasing TAA</strong> 时处理。在上面的代码中，我已经使用低差异序列的 Sobol Sequence 做随机采样了，只不过 Sobol Sequence 是在 GPU 里计算的，要想进一步优化，可以直接用数组记录下 Sobol Sequence 的 4、8、16、32 个样本，然后根据关键字选择使用即可。至于随机旋转，可以使用一个分辨率比较小的 Blue Noise 贴图。  </p>
<p>③点光源的接缝问题：在点光源展示的图片中，能够较为明显的感受到接缝问题。但我感觉这个接缝问题并非由 cubemap 的接缝本身引起，而是由接缝两边不同 cubemap 面的半影宽度大小不均匀所产生的，而且接缝处若在面的中心位置，几乎看不到宽度差异，越接近边缘差异越明显。我推测原因是，透视投影导致的相同像素宽度但不同世界宽度的问题，之前没有考虑阴影接受平面和光源方向（阴影贴图方向）的角度问题。但目前没尝试出特别合适的解决方案，我在网上也查询了很久，只是有看到讨论和文章说传统阴影贴图技术存在这个问题，要尽量避免使用投射阴影的点光源，所以这个问题也只能先放着以后再处理了。  </p>
<p>④方向光（太阳光）的低顶点数的超长物体阴影宽度变化问题：这个问题只会在超长物体不在或部分不在摄像机视锥体的时候出现，因为部分顶点被裁切后，我们要解决 pancaking 问题，将顶点深度设置到了近裁切平面，导致了深度变化，也就导致了估算的阴影宽度也产生了变化。一个简单的解决方案就是超长物体尽量顶点多一些，顶点多了这个问题就不会很明显，其实顶点多了 pancaking 问题也不需要解决了。</p>
<h1 id="Post-Processing"><a href="#Post-Processing" class="headerlink" title="Post Processing"></a>Post Processing</h1><p>从这里就开始讲后处理了，后处理对于画面表现极为重要，个人认为重要性是比 PBR 还要高的。常见的后处理技术有：<strong>泛光 Bloom</strong>、<strong>色调映射 Tone Mapping</strong>、<strong>色彩校正 Color Correction</strong>、<strong>色彩分级 Color Grading</strong>、<strong>景深 Depth of Field</strong>、<strong>运动模糊 Motion Blur</strong>、<strong>镜头光晕 Lens Flares</strong> 等等。catlikecoding 教程中没有覆盖上述所有的后处理技术，强烈建议以后花足够的时间去学习并且优化效果。</p>
<p>另外，catlikecoding 教程没有使用 Unity 的专门用来处理后处理效果的 Volume 框架，只为后处理效果配置了一个全局的设置。而 Volume 框架不仅支持全局设置，也支持 per-scene 的设置和场景中一定范围内的局部设置。所以我后面也会使用这个 core RP library 里提供的 Volume 框架，本章节也主要讲如何在自定义管线中支持这个 Volume 框架，主要参考了 URP 的代码。</p>
<h2 id="Volume-框架"><a href="#Volume-框架" class="headerlink" title="Volume 框架"></a>Volume 框架</h2><p>首先 Volume 框架相关 API 都在 Core RP Library -&gt; Runtime -&gt; Volume 里，有问题可以直接看里面的代码。首先后处理相关参数或属性都序列化在 Volume Profile 这个 ScriptableObject 里，可以通过 Assets -&gt; Create -&gt; Rendering -&gt; Volume Profile 添加该资产。Volume Profile 又可以放置在 3 个地方，第一个叫做 the default volume for the whole project，第二个叫做 the global volume for the active quality level，第三个是 scene 里的 global 和 local volume。这三个的优先级是从低到高的，scene 里的 volume 覆盖 quality volume，quality volume 覆盖 default volume。</p>
<p>在 URP 中，default volume 是放置在 Project Settings &gt; Graphics &gt; URP &gt; Default Volume Profile 里的。quality volume 放置在 URP Asset &gt; Volumes &gt; Volume Profile 里，而每个 Quality Level 又对应一个 URP Asset，实际上 SRP 也可以这么做。但是其实 default volume 和 quality volume 都是通过 <code>VolumeManager</code> 的 <code>Initialize(VolumeProfile globalDefaultVolumeProfile = null, VolumeProfile qualityDefaultVolumeProfile = null)</code> API 设置的。default volume 我觉得存在的意义不是很大，所以不打算传递给 <code>Initialize()</code> 函数。我在 RenderPipelineAsset 中新声明了 volumeProfile 字段，以便不同的 Quality Level 对应不同的全局后处理设置。<code>Initialize()</code> 这个函数必须在 RenderPipeline 的构造函数中调用：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">YRenderPipeline</span>(<span class="params">YRenderPipelineAsset asset</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    VolumeManager.instance.Initialize(<span class="literal">null</span>, asset.volumeProfile);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="VolumeManager"><a href="#VolumeManager" class="headerlink" title="VolumeManager"></a>VolumeManager</h3><p><strong>VolumeManager</strong> 是一个对场景中 Volume 的设置进行跟踪管理的类。上面说过，场景中可以有 global volume 和 local volume，global volume 的影响范围是整个场景，local volume 的影响范围是它的 collider 组件的大小（触发器）。VolumeManager 会在运行时根据摄像机的位置对 global volume 和 local volume 的属性设置进行插值，保证不同 volume 之间的平滑过渡，而不是场景突然出现较大变化。</p>
<p>而插值的数据存储在 <strong>VolumeStack</strong> 里，这个 VolumeStack 我们一般不用去初始化，默认情况下 VolumeManager 里有一个 global volume stack，可以通过 <code>VolumeManager.instance.stack</code> 获取，它会自动管理并混合 volume 里的数据。只要调用过 <code>VolumeManager.instance.Initialize()</code>，这个 global volume stack 就会被自动创建。但是若想要对 VolumeStack 进行更多地控制，可以使用 <code>VolumeManager.instance.CreateStack()</code> 创建新的 VolumeStack，如何控制这里就不探讨了，下面还是使用默认的 global volume stack。</p>
<p>但是 VolumeStack 在我目前使用的版本中，即 Core RP Library 17.2.0，不会自动每帧更新，需要在 RenderPipeline 的 Render 函数中调用 <code>VolumeManager.instance.Update(Transform, LayerMask)</code> 方法，否则无法通过 VolumeStack 获取到序列化后的 Volume Profile 里的 VolumeComponent 的值，VolumeComponent 后面会讲。我不知道这个是不是版本的问题，因为我看网上有些老版本的自定义渲染管线中，并没有调用 Update 方法，所以一开始我以为 Unity 帮我们处理好了，然后就出现问题了，我老是获取不到序列化后的值，害得我找了老半天 bug。以后的版本中，这个 Update 方法需不需要自己调用，最好还是能留意一下。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">foreach</span>(Camera camera <span class="keyword">in</span> cameras)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        VolumeManager.instance.Update(camera.transform, <span class="number">1</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的时机自己注意一下，就不多说了。Update 方法的第一个参数 Transform 即通过位置来决定如何混合 volume 参数，所以传递进摄像机的位置属性即可，第二个 LayerMask 是用来控制 volume 的更新范围的，传递进去 1 即 Default Layer。</p>
<p>另外，别忘了在 RenderPipeline 的 <code>Dispose()</code> 函数中调用 <code>VolumeManager.instance.Deinitialize()</code> 来释放资源：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    VolumeManager.instance.Deinitialize();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="VolumeComponent"><a href="#VolumeComponent" class="headerlink" title="VolumeComponent"></a>VolumeComponent</h3><p><strong>VolumeComponent</strong> 就是我们在 Volume Profile 里通过 Add Override 添加的组件。我们可以自定义 VolumeComponent，以便存储后处理的相关属性。在 VolumeComponent 里的属性是通过 VolumeParameter 序列化的，一个基础的 VolumeComponent 如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Serializable, VolumeComponentMenu(<span class="string">&quot;Post Processing/XXXX&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">SupportedOnRenderPipeline(typeof(XXRenderPipelineAsset))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">XXXX</span> : <span class="title">VolumeComponent</span>, <span class="title">IPostProcessComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ClampedFloatParameter intensity = <span class="keyword">new</span> ClampedFloatParameter(<span class="number">0f</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsActive</span>()</span> =&gt; intensity.<span class="keyword">value</span> &gt; <span class="number">0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SupportedOnRenderPipeline 特性和 IPostProcessComponent 接口不是必需的，IPostProcessComponent 只是提供了 IsActive() 方法。ClampedFloatParameter 就是 VolumeParameter 的一种，具体查看官方文档或直接查看源代码。VolumeComponent 内的属性我们可以通过 <code>VolumeManager.instance.stack.GetComponent&lt;T&gt;()</code> 获取，然后传递给具体的后处理 Shader。</p>
<h2 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h2><p>在正式进入后处理之前，我们先处理一个简单的 Copy Shader。因为我们要先将场景渲染至一个 render texture（自定义的 frame buffer）以便我们使用后处理 shader 对这个 render texture 进行后处理，最后再 blit 回 camera 的 frame buffer 以展现在屏幕上。所以可以把 Copy Shader 当作一个最简单的后处理效果，虽然 blit 就是 copy，但是 blit 效率相对低一点，后面会提到。</p>
<h3 id="Frame-buffer"><a href="#Frame-buffer" class="headerlink" title="Frame buffer"></a>Frame buffer</h3><p>首先我们要创建一个新的 render texture，为了方便管理所有的 render texture ID，我创建了一个静态类，专门存放 ID，以便不同的渲染流程的类进行调用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">RenderTargetIDs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> k_FrameBufferId = Shader.PropertyToID(<span class="string">&quot;_CameraFrameBuffer&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在绘制几何体的类中（我的 SRP 在 ForwardGeometryNode 里）获取该 render texture 并设置为 render target：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">data.context.SetupCameraProperties(data.camera);</span><br><span class="line"></span><br><span class="line">data.buffer.GetTemporaryRT(RenderTargetIDs.k_FrameBufferId, data.camera.pixelWidth, data.camera.pixelHeight, <span class="number">32</span>, FilterMode.Bilinear, RenderTextureFormat.Default);</span><br><span class="line">data.buffer.SetRenderTarget(<span class="keyword">new</span> RenderTargetIdentifier(RenderTargetIDs.k_FrameBufferId), RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);</span><br><span class="line">data.buffer.ClearRenderTarget(<span class="literal">true</span>, <span class="literal">true</span>, Color.clear);</span><br></pre></td></tr></table></figure>
<p>然后别忘了释放资源 <code>ReleaseTemporaryRT()</code>。可以看到上面的代码中直接 ClearRenderTarget 了，而不是根据第一篇文章说过的 CameraClearFlags 来判断是否清除 color buffer 和 depth buffer，这也导致了无法支持多摄像机渲染。如何同时支持多摄像机渲染和后处理，会在后面的章节中说明。然后就需要在处理后处理渲染的类中，将上述的 render texture 复制到 CameraTarget 中（目前还没有后处理相关 shader，先只复制），我新建了名为 PostProcessingNode 的类，专门处理后处理渲染，然后在 RenderPipeline 的 Render 函数中调用该类中处理渲染的方法。这里先直接使用 <code>CommandBuffer.Blit()</code> 函数：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostProcessingNode</span> : <span class="title">PipelineNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnRender</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        data.buffer.BeginSample(<span class="string">&quot;Post Processing&quot;</span>);</span><br><span class="line"></span><br><span class="line">        data.buffer.Blit(RenderTargetIDs.k_FrameBufferId, BuiltinRenderTextureType.CameraTarget);</span><br><span class="line"></span><br><span class="line">        data.buffer.EndSample(<span class="string">&quot;Post Processing&quot;</span>);</span><br><span class="line">        data.context.ExecuteCommandBuffer(data.buffer);</span><br><span class="line">        data.buffer.Clear();</span><br><span class="line">        data.context.Submit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子就可以正常在 screen 看到画面了。</p>
<h3 id="Gizmos-和-Editor-Preview"><a href="#Gizmos-和-Editor-Preview" class="headerlink" title="Gizmos 和 Editor Preview"></a>Gizmos 和 Editor Preview</h3><p>第一篇文章绘制 Gizmos 中提到过，Gizmo 有两个子集可以绘制，一个是 PreImageEffects，一个是 PostImageEffects。我们要分别在后处理前后调用：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnRender</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    <span class="keyword">if</span> (Handles.ShouldRenderGizmos()) </span><br><span class="line">    &#123;</span><br><span class="line">        RendererList gizmosRendererList = data.context.CreateGizmoRendererList(data.camera, GizmoSubset.PreImageEffects);</span><br><span class="line">        data.buffer.DrawRendererList(gizmosRendererList);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>   </span></span><br><span class="line"></span><br><span class="line">    data.buffer.BeginSample(<span class="string">&quot;Post Processing&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    data.buffer.EndSample(<span class="string">&quot;Post Processing&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    <span class="keyword">if</span> (Handles.ShouldRenderGizmos()) </span><br><span class="line">    &#123;</span><br><span class="line">        RendererList gizmosRendererList = data.context.CreateGizmoRendererList(data.camera, GizmoSubset.PostImageEffects);</span><br><span class="line">        data.buffer.DrawRendererList(gizmosRendererList);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    data.context.ExecuteCommandBuffer(data.buffer);</span><br><span class="line">    data.buffer.Clear();</span><br><span class="line">    data.context.Submit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样子所有的 gizmos 将不会被物体遮挡，如下图所示。这是因为 gizmos 的绘制依赖于原来的 frame buffer 中的深度信息，但是我们没有将其写入。这个问题也是后面的章节再处理。</p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/11/w5PHXdvDeaEBAMR.png" width = "35%" height = "35%" alt="图84 - 左图：未被遮挡的 gizmos；右图：正确遮挡的 gizmos"/>
</div>

<p>还有就是 Editor inspector 的 Preview 的绘制，比如 Material 的预览，以及 reflection probe 的绘制（refresh）也都是通过我们的管线绘制的。但是我们不能对它们也进行后处理，特别是 reflection probe。我们可以通过 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/CameraType.html">CameraType</a> 来判断是否跳过后处理阶段，<code>CameraType.Preview</code> 就是用于绘制 preview 的摄像机，<code>CameraType.Reflection</code> 就是用于绘制 reflection probe 的摄像机。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnRender</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// GizmoSubset.PreImageEffects</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    <span class="keyword">if</span> (data.camera.cameraType &gt; CameraType.SceneView)</span><br><span class="line">    &#123;</span><br><span class="line">        data.buffer.Blit(RenderTargetIDs.k_FrameBufferId, BuiltinRenderTextureType.CameraTarget);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// Post Processing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然你也可以通过一个 IsActive 的 bool 值来控制是否激活后处理，未激活的情况下，就跳过创建一个新的 framebuffer render texture。或者单独为 preview 的绘制和 reflection probe 的绘制搞出一个渲染路径出来。</p>
<p>还有就是 scene 窗口有个按钮可以选择关闭后处理效果，如下图：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/11/bJTf51z2qxkgtRU.jpg" width = "35%" height = "35%" alt="图85 - toggle post-processing in the scene window"/>
</div>

<p>如果要支持这个功能，新增代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    <span class="keyword">if</span> (data.camera.cameraType &gt; CameraType.SceneView)</span><br><span class="line">    &#123;</span><br><span class="line">        data.buffer.Blit(RenderTargetIDs.k_FrameBufferId, BuiltinRenderTextureType.CameraTarget);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.camera.cameraType == CameraType.SceneView &amp;&amp; !SceneView.currentDrawingSceneView.sceneViewState.showImageEffects)</span><br><span class="line">    &#123;</span><br><span class="line">        data.buffer.Blit(RenderTargetIDs.k_FrameBufferId, BuiltinRenderTextureType.CameraTarget);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Copy-Shader"><a href="#Copy-Shader" class="headerlink" title="Copy Shader"></a>Copy Shader</h3><p><code>CommandBuffer.Blit()</code> 函数之所以效率相对低一点，是因为它绘制了一个屏幕的长方形，即两个三角形。Blit 本质上是传递了一个长方形 mesh 给 GPU，并将源纹理作为贴图绘制出来。而我们可以调用 <code>CommandBuffer.DrawProcedural()</code> 只绘制一个三角形进行复制，并且不用 bind vertex 或者 index buffer，而是依赖系统值（System Value，SV），如 SV_VertexID，来生成顶点数据。<code>Blit()</code> 还有一个缺点就是会重复绘制长方形对角线的像素，因为绘制了两个三角形，其使用的 shader 是 built-in shader 里面的 Internal-BlitCopy。</p>
<p>我们需要为 DrawProcedural 传递一个自己的 copy material，首先创建一个 Copy Shader，引入 CopyPass.hlsl，如下。注意所有的 pass 应该都不做背面剔除以及深度写入：  </p>
<pre><code>Shader &quot;Hidden/YPipeline/Copy&quot;
&#123;
    SubShader
    &#123;
        Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot;&#125;

        ZTest Always
        ZWrite Off
        Cull Off

        Pass
        &#123;
            Name &quot;Copy&quot;

            HLSLPROGRAM
            #pragma target 3.5

            #pragma vertex CopyVert
            #pragma fragment CopyFrag

            #include &quot;CopyPass.hlsl&quot;
            ENDHLSL
        &#125;
    &#125;
&#125;
</code></pre><p>在 Pass 中我们要利用 <code>SV_VertexID</code> 语义来生成顶点坐标和 uv 坐标，让我们的三角形覆盖整个裁切空间（后面传入的 vp 矩阵是单位矩阵，所以顶点坐标和裁切坐标是一致的），具体如下图所示：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/12/hWa843I6lSZQVjL.png" width = "25%" height = "25%" alt="图86 - Triangle covering clip space"/>
</div>

<p>三个顶点的坐标分别是 (-1, -1, z, 1)，(-1, 3, z, 1)，(3, -1, z, 1)。uv 坐标分别是 (0, 0)，(0, 2)，(2, 0)。注意顶点的<strong>绕序 winding order</strong>，顺时针方向为正面。顶点坐标的 z 要根据是否 reversed-z 来判断是 0 还是 1。教程中是通过三元运算符计算坐标的，如下：  </p>
<pre><code>OUT.positionHCS = float4(vertexID &lt;= 1 ? -1.0 : 3.0, vertexID == 1 ? 3.0 : -1.0, 0.0, 1.0);
OUT.uv = float2(vertexID &lt;= 1 ? 0.0 : 2.0, vertexID == 1 ? 2.0 : 0.0);
</code></pre><p>但是 URP 里的方式更好，通过位运算符计算出 uv 坐标，再映射回顶点坐标，整个 Pass 代码如下：  </p>
<pre><code>#ifndef YPIPELINE_SIMPLE_COPY_PASS_INCLUDED
#define YPIPELINE_SIMPLE_COPY_PASS_INCLUDED

#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;
#include &quot;../../ShaderLibrary/UnityInput.hlsl&quot;

TEXTURE2D(_BlitTexture);
SAMPLER(sampler_LinearClamp);

struct Varyings
&#123;
    float4 positionHCS  : SV_POSITION;
    float2 uv           : TEXCOORD0;
&#125;;

Varyings CopyVert(uint vertexID : SV_VertexID)
&#123;
    Varyings OUT;

    // OUT.positionHCS = float4(vertexID &lt;= 1 ? -1.0 : 3.0, vertexID == 1 ? 3.0 : -1.0, 0.0, 1.0);
    // OUT.uv = float2(vertexID &lt;= 1 ? 0.0 : 2.0, vertexID == 1 ? 2.0 : 0.0);

    OUT.uv = float2((vertexID &lt;&lt; 1) &amp; 2, vertexID &amp; 2);
    OUT.positionHCS = float4(OUT.uv * 2.0 - 1.0, UNITY_NEAR_CLIP_VALUE, 1.0);

    if (_ProjectionParams.x &lt; 0.0) OUT.uv.y = 1.0 - OUT.uv.y;

    // #if UNITY_UV_STARTS_AT_TOP
    //     OUT.uv.y = 1.0 - OUT.uv.y;
    // #endif

    return OUT;
&#125;

float4 CopyFrag(Varyings IN) : SV_TARGET
&#123;
    return SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv, 0);
&#125;

#endif
</code></pre><p>上面代码中还要注意一个 uv 坐标的平台差异问题，在 DirectX 中 uv 的原点在屏幕的左上角。一般情况下，Unity 会在背后为我们处理了这个反转问题，但是对于 render texture 并没有处理。我们可以通过 <code>_ProjectionParams</code> 的 x 分量判断是否需要手动反转，并且该向量需要定义在 UnityInput.hlsl 文件里面。URP 中是通过 <code>UNITY_UV_STARTS_AT_TOP</code> 宏来进行判断的，但是我使用的时候不知道为什么，还是会出现反转问题，而且是复制给 <code>BuiltinRenderTextureType.CameraTarget</code> 的环节出现的问题。我感觉原因是 <code>_ProjectionParams</code> 会同时判断 Unity 是否在背后处理了反转问题，而 <code>UNITY_UV_STARTS_AT_TOP</code> 不会，而 URP 使用了 RTHandle API，可以绕过 Unity 对 <code>BuiltinRenderTextureType.CameraTarget</code> 的自动反转问题处理。我不确定上述原因是否正确，打算后面全面转为使用 RTHandle API 后再回来解决这个问题。故目前先使用 <code>_ProjectionParams</code> 的 x 分量进行判断。</p>
<hr>
<p>有了 Copy Shader 后，就可以进行复制了，我们可以新建一个 BlitUtility 的静态类，专门用于存放这类函数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">BlitUtility</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> k_BlitTextureId = Shader.PropertyToID(<span class="string">&quot;_BlitTexture&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BlitTexture</span>(<span class="params">CommandBuffer cmd, <span class="built_in">int</span> sourceID, <span class="built_in">int</span> destinationID, Material material, <span class="built_in">int</span> pass</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cmd.SetGlobalTexture(k_BlitTextureId, <span class="keyword">new</span> RenderTargetIdentifier(sourceID));</span><br><span class="line">        cmd.SetRenderTarget(<span class="keyword">new</span> RenderTargetIdentifier(destinationID));</span><br><span class="line">        cmd.DrawProcedural(Matrix4x4.identity, material, pass, MeshTopology.Triangles, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BlitTexture</span>(<span class="params">CommandBuffer cmd, <span class="built_in">int</span> sourceID, BuiltinRenderTextureType destination, Material material, <span class="built_in">int</span> pass</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cmd.SetGlobalTexture(k_BlitTextureId, <span class="keyword">new</span> RenderTargetIdentifier(sourceID));</span><br><span class="line">        cmd.SetRenderTarget(<span class="keyword">new</span> RenderTargetIdentifier(destination));</span><br><span class="line">        cmd.DrawProcedural(Matrix4x4.identity, material, pass, MeshTopology.Triangles, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将 source texture 设置为 copy shader 里的 <code>_BlitTexture</code>，再将 destination texture 设置为 RenderTarget，最后使用 <code>DrawProcedural()</code> 将 source texture 绘制在 destination texture，传递的矩阵为单位矩阵，<strong>图元拓扑 primitive topology</strong> 为三角形，以及要绘制的顶点数量为 3。然后在 PostProcessingNode 的 <code>OnRender()</code> 函数中将 <code>Blit()</code> 函数改为我们的函数（Pass 传入 0）即可，就是要先初始化 copy material：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> k_Copy = <span class="string">&quot;Hidden/YPipeline/Copy&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> Material m_CopyMaterial;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_CopyMaterial = <span class="keyword">new</span> Material(Shader.Find(k_Copy));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnRender</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    data.buffer.BeginSample(<span class="string">&quot;Post Processing&quot;</span>);</span><br><span class="line">    <span class="comment">// data.buffer.Blit(RenderTargetIDs.k_FrameBufferId, BuiltinRenderTextureType.CameraTarget);</span></span><br><span class="line">    BlitUtility.BlitTexture(data.buffer, RenderTargetIDs.k_FrameBufferId, BuiltinRenderTextureType.CameraTarget, m_CopyMaterial, <span class="number">0</span>);</span><br><span class="line">    data.buffer.EndSample(<span class="string">&quot;Post Processing&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Additive-Bloom"><a href="#Additive-Bloom" class="headerlink" title="Additive Bloom"></a>Additive Bloom</h1><p>我们首先来实现一个经典的 Additive Bloom，它是一个很好的后处理效果案例，我们先在 LDR 中实现它。之后讲完 HDR 之后，再实现一个物理上相对来说更加正确的 Energy-conserving Scattering Bloom。Additive Bloom 对于 LDR 还是 HDR 都适用，但是 Scattering Bloom 只适用于 HDR，在 LDR 中几乎没有效果。但无论哪种 Bloom，其基本原理都是一样的。故接下来先讲解制作 Bloom 特效的基本原理，再实现 Additive Bloom。</p>
<h2 id="制作-Bloom-基本原理"><a href="#制作-Bloom-基本原理" class="headerlink" title="制作 Bloom 基本原理"></a>制作 Bloom 基本原理</h2><p>制作 Bloom 的流程总结起来就一句话，就是将一张图片的亮度高于一定阈值的区域拿出来，进行模糊，再叠加到原图上去，这样就可以实现 Bloom 了。这点其实<a href="https://ybniaobu.github.io/2023/12/19/2023-12-19-UnityShader4/#Bloom-%E6%95%88%E6%9E%9C">《Unity Shader入门精要》读书笔记（四）</a> 里面也提到过，下面的做法跟入门精要里面也是类似的。</p>
<p><strong>①</strong>将一张图片的亮度高于一定阈值的区域拿出来的过程，一般称为 <strong>prefilter</strong>，在该过程也可以将该区域放在一个分辨率更小的贴图当中，从而决定开始模糊的金字塔层级（详见下采样）。但是直接消除一定亮度以下的颜色会产生一个较为明显的边界，而我们希望一个逐渐变化的过渡。所以我们会给图片中的颜色乘上一个一个权重系数，这个权重系数由<strong>阈值 Threshold</strong> 与亮度计算而得：  </p>
<script type="math/tex; mode=display">\omega = \cfrac {max(0, b - t)} {max(b, 0.00001)}</script><p>b 即亮度 brightness，t 即阈值 threshold。我们一般会取 RGB 中最大的通道作为亮度值（我试了下 YUV 颜色空间的 Luminance 作为亮度，效果不是很好，特别是蓝色部分就不太会产生 bloom 效果）。上述公式的图像如下，因为形状像膝盖，称为 <strong>knee curve</strong>：</p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/12/Ysc4O7XBV5PKCDR.png" width = "25%" height = "25%" alt="图87 - knee curve，从黄色到紫色 Thresholds 分别为 0.25, 0.5, 0.75, 1"/>
</div>

<p>可以看到，亮度到达 threshold 后，权重就会逐渐变高。虽然这个曲线比直接去除 threshold 以下的颜色要平滑一些，但是仍然有一个明显的 cutoff point，故该曲线也被称为 <strong>hard knee</strong>。为了更好地平滑，需要引入另外一个参数 <strong>thresholdKnee</strong>，公式如下：  </p>
<script type="math/tex; mode=display">\omega = \cfrac {max(s, b - t)} {max(b, 0.00001)}，\text{with} \,\,\, s = \cfrac {min( max(0, b - t + tk), 2tk)^2} {4tk + 0.00001}</script><p>其中 k 即 thresholdKnee，是一个 0 - 1 区间的值。图像如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/12/UJBoN3GjQEz8dCY.png" width = "25%" height = "25%" alt="图88 - Threshold 为 1 时，从黄色到黑色 Threshold Knee 分别为 0, 0.25, 0.5, 0.75, 1"/>
</div>

<p>有了这两个参数，就可以更好地取出较亮的区域以便进行模糊处理。</p>
<p><strong>②</strong>模糊的过程称为<strong>下采样 Downsample</strong>，常用于 Bloom 的模糊算法有<strong>高斯模糊 Gaussian Blur</strong>、<strong>方框模糊 Box Blur</strong>、<strong>Kawase Blur</strong> 以及 <strong>Dual Kawase Blur</strong>。我看有些文章说 Kawase Blur 或 Dual Kawase Blur 具有更加优秀的性能优势，但另外有些文章实现出来说有特别重的方块感。而高斯模糊更加常用，并且 UE 和 Unity 都采用高斯模糊，我觉得基本上实现基于高斯模糊的 Bloom 就够用了，其他模糊可以日后有空再尝试研究，下面的讲解也是基于高斯模糊。</p>
<p>这个过程之所以称为下采样，是因为最简单的模糊方式就是将图片复制进其一半分辨率的图片（即 mipmap）当中，并采用 bilinear 的采样方式。我们会重复这个过程，迭代一定的次数，下采样到一定的级别，从而形成一个 texture 的金字塔，称为 <strong>Bloom Pyramid</strong>。当然 bilinear 的下采样的结果会导致严重的方块感，所以在下采样时会使用高斯模糊。</p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/12/DPeiWHUuMYqCaoQ.png" width = "25%" height = "25%" alt="图89 - Bloom Pyramid"/>
</div>

<p><strong>③</strong>将所有 Bloom Pyramid 中模糊后的贴图叠加到原图上去的过程称为<strong>上采样 Upsample</strong>。这部分没什么好说的，只是在上采样过程中可以选用 Bicubic 采样以获取比 Bilinear 采样更平滑的效果。</p>
<h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><p>知道了制作 Bloom 的基本流程后，我们就可以实现基于 LDR 的 Additive Bloom 了。</p>
<h3 id="配置-Bloom-属性"><a href="#配置-Bloom-属性" class="headerlink" title="配置 Bloom 属性"></a>配置 Bloom 属性</h3><p>因为使用的是 Volume 框架，直接使用 VolumeComponent 配置相关参数或者属性，代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> BloomDownscaleMode</span><br><span class="line">&#123;</span><br><span class="line">    None,</span><br><span class="line">    Half,</span><br><span class="line">    Quarter,</span><br><span class="line">    HalfQuarter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">DownscaleParameter</span> : <span class="title">VolumeParameter</span>&lt;<span class="title">BloomDownscaleMode</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownscaleParameter</span>(<span class="params">BloomDownscaleMode <span class="keyword">value</span>, <span class="built_in">bool</span> overrideState = <span class="literal">false</span></span>) : <span class="title">base</span>(<span class="params"><span class="keyword">value</span>, overrideState</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable, VolumeComponentMenu(<span class="string">&quot;YPipeline Post Processing/Bloom&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">SupportedOnRenderPipeline(typeof(YRenderPipelineAsset))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bloom</span> : <span class="title">VolumeComponent</span>, <span class="title">IPostProcessComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Tooltip(<span class="string">&quot;Strength of the bloom filter.&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> MinFloatParameter intensity = <span class="keyword">new</span> MinFloatParameter(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Tooltip(<span class="string">&quot;Filters out pixels under this level of brightness. Value is in gamma-space.&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> MinFloatParameter threshold = <span class="keyword">new</span> MinFloatParameter(<span class="number">0.9f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Tooltip(<span class="string">&quot;Smooths cutoff effect of the configured threshold. Higher value makes more transition.&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> ClampedFloatParameter thresholdKnee = <span class="keyword">new</span> ClampedFloatParameter(<span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1f</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Tooltip(<span class="string">&quot;The starting resolution that this effect begins processing.&quot;</span>), AdditionalProperty</span>]</span><br><span class="line">    <span class="keyword">public</span> DownscaleParameter downscale = <span class="keyword">new</span> DownscaleParameter(BloomDownscaleMode.Half);</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Tooltip(<span class="string">&quot;The maximum number of iterations/Pyramid Levels.&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> ClampedIntParameter maxIterations = <span class="keyword">new</span> ClampedIntParameter(<span class="number">6</span>, <span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">Tooltip(<span class="string">&quot;Use bicubic sampling instead of bilinear sampling for the upsampling passes. This is slightly more expensive but helps getting smoother visuals.&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> BoolParameter bicubicUpsampling = <span class="keyword">new</span> BoolParameter(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsActive</span>()</span> =&gt; intensity.<span class="keyword">value</span> &gt; <span class="number">0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些属性前面讲原理时基本都讲到了，就不多讲了。另外我为所有的后处理效果弄了一个 PostProcessingRenderer 基类，方便管理以及在 PostProcessingNode 里调用并渲染。然后创建一个 BloomRenderer 的类继承它：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PostProcessingRenderer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T1 <span class="title">Create</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt;() </span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> T1 : PostProcessingRenderer&lt;T2&gt;, <span class="keyword">new</span>() </span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> T2 : VolumeComponent</span></span><br><span class="line">    &#123;</span><br><span class="line">        T1 renderer = <span class="keyword">new</span> T1();</span><br><span class="line">        renderer.Initialize();</span><br><span class="line">        <span class="keyword">return</span> renderer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PostProcessingRenderer</span>&lt;<span class="title">T</span>&gt; : <span class="title">PostProcessingRenderer</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">VolumeComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T settings;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        settings = VolumeManager.instance.stack.GetComponent&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BloomRenderer</span> : <span class="title">PostProcessingRenderer</span>&lt;<span class="title">Bloom</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Initialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Downsample"><a href="#Downsample" class="headerlink" title="Downsample"></a>Downsample</h3><p>我们先从下采样开始讲起，我们要创建一个 texture 金字塔，那么第一个问题就是这个金字塔有几个级别（需要迭代几次）。而迭代次数取决于我们屏幕的分辨率，但我们最好设置一个最大迭代次数（在 BloomRenderer 里定义），我设置为了 15 次，这样最大可以把一个 32,768 × 32,768 的纹理一直迭代到 1 × 1 的纹理。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> k_MaxBloomPyramidLevels = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p>然后就是计算出真正的迭代次数，可以根据屏幕的分辨率判断出来：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    data.buffer.BeginSample(<span class="string">&quot;Bloom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> width = data.camera.pixelWidth &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span> height = data.camera.pixelHeight &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine the iteration count</span></span><br><span class="line">    <span class="built_in">int</span> minSize = Mathf.Min(width, height);</span><br><span class="line">    <span class="built_in">int</span> iterationCount = Mathf.FloorToInt(Mathf.Log(minSize, <span class="number">2.0f</span>));</span><br><span class="line">    iterationCount = Mathf.Clamp(iterationCount, <span class="number">1</span>, settings.maxIterations.<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">    data.buffer.EndSample(<span class="string">&quot;Bloom&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 texture 金字塔有多张贴图，我们就需要多个 texture identifier。又因为高斯模糊我们要分为 horizontal pass 和 vertical pass，将 N × N 的高斯核，即 N × N 次采样，拆分为两个一维高斯核，这样就只需要 N + N 次采样（《Unity Shader入门精要》读书笔记（四）中讲<a href="https://ybniaobu.github.io/2023/12/19/2023-12-19-UnityShader4/#%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A">高斯模糊</a>时有讲过）。这样每个金字塔级别我们就需要两张贴图，一张存放 horizontal pass 后的贴图，我将其 identifier 命名为 _BloomPyramidUp0、_BloomPyramidUp1 ···。另一张存放 vertical pass 后的贴图，命名为 _BloomPyramidDown0、_BloomPyramidDown1 ···。之所以名字取为 Up 和 Down 如下图所示：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/13/8nuBIv4VQWKCPpq.png" width = "25%" height = "25%" alt="图90 - Downsample"/>
</div>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>[] m_BloomPyramidUpIds;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span>[] m_BloomPyramidDownIds;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.Initialize();</span><br><span class="line">    m_BloomPyramidUpIds = <span class="keyword">new</span> <span class="built_in">int</span>[k_MaxBloomPyramidLevels];</span><br><span class="line">    m_BloomPyramidDownIds = <span class="keyword">new</span> <span class="built_in">int</span>[k_MaxBloomPyramidLevels];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k_MaxBloomPyramidLevels; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_BloomPyramidUpIds[i] = Shader.PropertyToID(<span class="string">&quot;_BloomPyramidUp&quot;</span> + i);</span><br><span class="line">        m_BloomPyramidDownIds[i] = Shader.PropertyToID(<span class="string">&quot;_BloomPyramidDown&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是高斯模糊了，首先 horizontal pass，我们新建一个 Bloom Shader，着色器函数都放在 BloomPass.hlsl 里:  </p>
<pre><code>Shader &quot;Hidden/YPipeline/Bloom&quot;
&#123;
    HLSLINCLUDE
    #include &quot;BloomPass.hlsl&quot;
    ENDHLSL

    SubShader
    &#123;
        Tags
        &#123;
            &quot;RenderType&quot; = &quot;Opaque&quot;
        &#125;

        ZTest Always
        ZWrite Off
        Cull Off

        Pass
        &#123;
            Name &quot;Bloom Gaussian Blur Horizontal&quot;

            HLSLPROGRAM
            #pragma target 3.5
            #pragma vertex BloomVert
            #pragma fragment BloomGaussianBlurHorizontalFrag
            ENDHLSL
        &#125;

        Pass
        &#123;
            Name &quot;Bloom Gaussian Blur Vertical&quot;

            HLSLPROGRAM
            #pragma target 3.5
            #pragma vertex BloomVert
            #pragma fragment BloomGaussianBlurVerticalFrag
            ENDHLSL
        &#125;
    &#125;
&#125;
</code></pre><p>顶点着色器 BloomVert 跟上面的 CopyVert 是一样的。BloomGaussianBlurHorizontalFrag 如下：  </p>
<pre><code>TEXTURE2D(_BlitTexture);
float4 _BlitTexture_TexelSize;
SAMPLER(sampler_LinearClamp);

float4 BloomGaussianBlurHorizontalFrag(Varyings IN) : SV_TARGET
&#123;
    float3 color = float3(0.0, 0.0, 0.0);
    float offsets[9] = &#123; -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0 &#125;;
    float weights[9] = &#123; 0.01621622, 0.05405405, 0.12162162, 0.19459459, 0.22702703, 0.19459459, 0.12162162, 0.05405405, 0.01621622 &#125;;

    // 9×9 Gaussian filter
    UNITY_UNROLL
    for (int i = 0; i &lt; 9; i++)
    &#123;
        float offset = offsets[i] * _BlitTexture_TexelSize.x * 2.0;
        color += SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv + float2(offset, 0), 0).rgb * weights[i];
    &#125;

    return float4(color, 1.0);
&#125;
</code></pre><p>注意代码中要对 offset 乘以 2，这是因为 Horizontal Pass 顺便做了 Downsample，如上面图 90 所示，我们先将源纹理做一次 Horizontal Blur 并放置在了其一半分辨率的贴图当中，再对做过 Horizontal Blur 的贴图做 Vertical Blur 还是放置在源纹理一半分辨率的贴图当中。所以在 Horizontal Pass 中的 _BlitTexture 的分辨率是要写入的贴图的分辨率的两倍，这就导致 offset / width 多除了一个 2，所以把 2.0 乘回去。这样配合 bilinear 采样，可以采样源贴图 18 个像素。</p>
<blockquote>
<p>{TextureName}_TexelSize 是 Unity 内置的 shader 属性，跟 {TextureName}_ST 类似。{TextureName}_TexelSize 里存储的是纹理的分辨率信息，x: 1.0 / width，y: 1.0 / height，z: width，w: height。</p>
</blockquote>
<p>Vertical Pass 跟 Horizontal 类似，BloomGaussianBlurVerticalFrag 代码如下：  </p>
<pre><code>float4 BloomGaussianBlurVerticalFrag(Varyings IN) : SV_TARGET
&#123;
    float3 color = float3(0.0, 0.0, 0.0);
    float offsets[5] = &#123; -3.23076923, -1.38461538, 0.0, 1.38461538, 3.23076923 &#125;;
    float weights[5] = &#123; 0.07027027, 0.31621622, 0.22702703, 0.31621622, 0.07027027 &#125;;

    // 5×5 Gaussian filter
    UNITY_UNROLL
    for (int i = 0; i &lt; 5; i++)
    &#123;
        float offset = offsets[i] * _BlitTexture_TexelSize.y;
        color += SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv + float2(0, offset), 0).rgb * weights[i];
    &#125;

    return float4(color, 1.0);
&#125;
</code></pre><p>这里之所以只采样 5 次，是因为我们使用的是 bilinear 采样器，这样就可以利用它做到 5 次采样达到 9 次采样的效果。只不过要修改 offset 的数值。</p>
<p>有了 Bloom Shader 后，我们可以正式做下采样了，首先根据 texture identifier 生成 render texture，再调用 Bloom Shader 的两个 pass 分别绘制：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Determine the iteration count</span></span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Downsample - gaussian pyramid</span></span><br><span class="line">    <span class="built_in">int</span> sourceId = RenderTargetIDs.k_FrameBufferId;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterationCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data.buffer.GetTemporaryRT(m_BloomPyramidUpIds[i], width, height, <span class="number">0</span>, FilterMode.Bilinear, RenderTextureFormat.Default);</span><br><span class="line">        data.buffer.GetTemporaryRT(m_BloomPyramidDownIds[i], width, height, <span class="number">0</span>, FilterMode.Bilinear, RenderTextureFormat.Default);</span><br><span class="line">        BlitUtility.BlitTexture(data.buffer, sourceId, m_BloomPyramidUpIds[i], m_BloomMaterial, <span class="number">0</span>);</span><br><span class="line">        BlitUtility.BlitTexture(data.buffer, m_BloomPyramidUpIds[i], m_BloomPyramidDownIds[i], m_BloomMaterial, <span class="number">1</span>);</span><br><span class="line">        sourceId = m_BloomPyramidDownIds[i];</span><br><span class="line">        width &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        height &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release RT</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterationCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data.buffer.ReleaseTemporaryRT(m_BloomPyramidUpIds[i]);</span><br><span class="line">        data.buffer.ReleaseTemporaryRT(m_BloomPyramidDownIds[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就有了 Bloom Texture 金字塔了，然后就是上采样阶段了。</p>
<h3 id="Upsample"><a href="#Upsample" class="headerlink" title="Upsample"></a>Upsample</h3><p>上采样阶段就是把所有的 _BloomPyramidDown 贴图混合起来，如下图所示：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/13/jkE2PBXhAYaiHcJ.png" width = "25%" height = "25%" alt="图91 - Upsample"/>
</div>

<p>我们要混合的就是上图中的 1，3，5 号贴图（_BloomPyramidDown），我们一步一步混合上去，先将 3 和 5 混合放置在 2 号贴图中（_BloomPyramidUp），再将 2 和 1 号混合放置在 0 中，最后和源纹理做混合。因为我们要混合两张贴图，所以要为 Shader 定义第二张贴图，我称为 _BloomLowerTexture：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> k_BloomLowerTextureID = Shader.PropertyToID(<span class="string">&quot;_BloomLowerTexture&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>之前提到过，混合可以使用 bilinear sample 或 bicubic sample。我们还需要定义一个 shader keyword：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> k_BloomBicubicUpsampling = <span class="string">&quot;_BLOOM_BICUBIC_UPSAMPLING&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>然后在 Bloom Shader 里添加 Upsample Pass：  </p>
<pre><code>Pass
&#123;
    Name &quot;Bloom Upsample&quot;

    HLSLPROGRAM
    #pragma target 3.5
    #pragma vertex BloomVert
    #pragma fragment BloomUpsampleFrag
    #pragma multi_compile_local_fragment _ _BLOOM_BICUBIC_UPSAMPLING
    ENDHLSL
&#125;
</code></pre><p>BloomUpsampleFrag 代码如下，bicubic 采样 Core RP Library 里面有提供，在 ShaderLibrary/Filtering.hlsl 里，需要引入该文件：  </p>
<pre><code>#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Filtering.hlsl&quot;

TEXTURE2D(_BloomLowerTexture);
float4 _BloomLowerTexture_TexelSize;

float4 BloomUpsampleFrag(Varyings IN) : SV_TARGET
&#123;
    #if _BLOOM_BICUBIC_UPSAMPLING
        float3 lowerTex = SampleTexture2DBicubic(_BloomLowerTexture, sampler_LinearClamp, IN.uv, _BloomLowerTexture_TexelSize.zwxy, (1.0).xx, 0.0).rgb;
    #else
        float3 lowerTex = SAMPLE_TEXTURE2D_LOD(_BloomLowerTexture, sampler_LinearClamp, IN.uv, 0).rgb;
    #endif

    float3 higherTex = SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv, 0).rgb;
    return float4(lowerTex + higherTex, 1.0);
&#125;
</code></pre><p>然后在 BloomRenderer 里的上采样代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Determine the iteration count</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shader property and keyword setup</span></span><br><span class="line">    CoreUtils.SetKeyword(m_BloomMaterial, k_BloomBicubicUpsampling, settings.bicubicUpsampling.<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Downsample - gaussian pyramid</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Upsample - bilinear or bicubic</span></span><br><span class="line">    <span class="built_in">int</span> lastDst = m_BloomPyramidDownIds[iterationCount - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = iterationCount - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        data.buffer.SetGlobalTexture(k_BloomLowerTextureID, <span class="keyword">new</span> RenderTargetIdentifier(lastDst));</span><br><span class="line">        BlitUtility.BlitTexture(data.buffer, m_BloomPyramidDownIds[i], m_BloomPyramidUpIds[i], m_BloomMaterial, <span class="number">2</span>);</span><br><span class="line">        lastDst = m_BloomPyramidUpIds[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Final Blit</span></span><br><span class="line">    data.buffer.SetGlobalTexture(k_BloomLowerTextureID, <span class="keyword">new</span> RenderTargetIdentifier(lastDst));</span><br><span class="line">    BlitUtility.BlitTexture(data.buffer, RenderTargetIDs.k_FrameBufferId, BuiltinRenderTextureType.CameraTarget, m_BloomMaterial, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release RT</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/13/o4zIAGfJkCceXrb.png" width = "75%" height = "75%" alt="图92 - 未做 prefilter 的整体 Bloom 效果。左图迭代 3 次，右图迭代 6 次"/>
</div>

<p>可以看到画面非常朦胧，这是因为我们没有将较亮区域提出来做模糊，而是对整张图片进行了模糊并叠加。</p>
<h3 id="Prefilter"><a href="#Prefilter" class="headerlink" title="Prefilter"></a>Prefilter</h3><p>Prefilter 可以有两个步骤，第一个就是过滤出较亮区域，公式之前都讲过。第二个步骤是将较亮区域放在 1/1 或 1/2 或 1/4 或 1/8 分辨率的贴图中（即 Downscale 属性），从而决定 Bloom 金字塔的开始的分辨率或层级。我们要新声明一个 texture 用于存放 prefilter 后的结果，并作为 Bloom 金字塔的起点，我取名为 _BloomPrefilter：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> k_BloomPrefilterId = Shader.PropertyToID(<span class="string">&quot;_BloomPrefilter&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>然后还需要传递两个参数用于过滤出较亮区域，即之前说的 threshold 和 thresholdKnee。但是为了方便计算，我们不直接传递这两个参数，而是传递一个向量，命名为 _BloomThreshold，x 分量为 $\,t\,$，y 分量为 $\,-t + tk\,$，z 分量为 $\,2tk\,$，w 分量为 $\,1/ 4tk\,$：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> k_BloomThresholdId = Shader.PropertyToID(<span class="string">&quot;_BloomThreshold&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>BloomRenderer 里面代码如下，先确定 Bloom 金字塔的起点，将分辨率右移 downscale 位，右移一位即除以 2，右移两位即除以 4。然后传递 _BloomThreshold 属性，将 threshold 作为 gamma 值使用起来更加直观，因为它是颜色相关的值，所以转为至线性空间再传递。最后做 Prefilter：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">YRenderPipelineAsset asset, <span class="keyword">ref</span> PipelinePerFrameData data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do bloom at half or quarter resolution</span></span><br><span class="line">    <span class="built_in">int</span> width = data.camera.pixelWidth &gt;&gt; (<span class="built_in">int</span>) settings.downscale.<span class="keyword">value</span>;</span><br><span class="line">    <span class="built_in">int</span> height = data.camera.pixelHeight &gt;&gt; (<span class="built_in">int</span>) settings.downscale.<span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine the iteration count</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shader property and keyword setup</span></span><br><span class="line">    <span class="built_in">float</span> threshold = Mathf.GammaToLinearSpace(settings.threshold.<span class="keyword">value</span>);</span><br><span class="line">    <span class="built_in">float</span> knee = threshold * settings.thresholdKnee.<span class="keyword">value</span> + <span class="number">1e-6</span>f;</span><br><span class="line">    data.buffer.SetGlobalVector(k_BloomThresholdId, <span class="keyword">new</span> Vector4(threshold, knee - threshold, <span class="number">2.0f</span> * knee, <span class="number">0.25f</span> / knee));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prefilter</span></span><br><span class="line">    data.buffer.GetTemporaryRT(k_BloomPrefilterId, width, height, <span class="number">0</span>, FilterMode.Bilinear, RenderTextureFormat.Default);</span><br><span class="line">    BlitUtility.BlitTexture(data.buffer, RenderTargetIDs.k_FrameBufferId, k_BloomPrefilterId, m_BloomMaterial, <span class="number">3</span>);</span><br><span class="line">    width &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    height &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Downsample - gaussian pyramid</span></span><br><span class="line">    <span class="built_in">int</span> sourceId = k_BloomPrefilterId;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterationCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Upsample - bilinear or bicubic</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Final Blit</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release RT</span></span><br><span class="line">    data.buffer.ReleaseTemporaryRT(k_BloomPrefilterId);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bloom Shader 中的 Prefilter Pass 和对应的函数如下：  </p>
<pre><code>Pass
&#123;
    Name &quot;Bloom Prefilter&quot;

    HLSLPROGRAM
    #pragma target 3.5
    #pragma vertex BloomVert
    #pragma fragment BloomPrefilterFrag
    ENDHLSL
&#125;

float3 ApplyBloomThreshold(float3 color)
&#123;
    float brightness = Max3(color.r, color.g, color.b);
    float soft = brightness + _BloomThreshold.y;
    soft = clamp(soft, 0.0, _BloomThreshold.z);
    soft = soft * soft * _BloomThreshold.w;
    float contribution = max(soft, brightness - _BloomThreshold.x);
    contribution /= max(brightness, 0.00001);
    return color * contribution;
&#125;

float4 BloomPrefilterFrag(Varyings IN) : SV_TARGET
&#123;
    float3 color = ApplyBloomThreshold(SAMPLE_TEXTURE2D_LOD(_BlitTexture, sampler_LinearClamp, IN.uv, 0).rgb);
    return float4(color, 1.0);
&#125;
</code></pre><h3 id="Intensity"><a href="#Intensity" class="headerlink" title="Intensity"></a>Intensity</h3><p>最后还有一个 Intensity 的参数没有讲到，这个参数在 Upsample Pass 里添加，如下。有一点要注意的是，由于我们希望上采样阶段和 Final Blit 阶段都使用一个 pass，并且 Intensity 只需要在最后的 Final Blit 阶段应用即可，故我们可以在上采样阶段前传递该参数为 1.0，在 Final Blit 阶段再传递该值，这样子就可以共用一个 pass 而不需要再写一个 pass 了，具体传递的代码就不放出了：  </p>
<pre><code>float4 BloomUpsampleFrag(Varyings IN) : SV_TARGET
&#123;
    ...
    return float4(lowerTex * _BloomIntensity + higherTex, 1.0);
&#125;
</code></pre><p>最终效果如下图：  </p>
<div  align="center">  
<img src="https://s2.loli.net/2025/03/13/q1NJLveIMbldtoC.png" width = "75%" height = "75%" alt="图93 - LDR Additive Bloom 效果"/>
</div>

<p>这样就实现了一个效果还算可以的 LDR Additive Bloom 了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io">鸟布</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ybniaobu.github.io/2025/02/26/2025-02-26-CustomSRP5/">https://ybniaobu.github.io/2025/02/26/2025-02-26-CustomSRP5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ybniaobu.github.io" target="_blank">鸟布的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/unity/">unity</a><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2025/02/26/m2zJbPd8aeGD14A.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src="/images/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/13/2025-03-13-CustomSRP6/" title="Unity Custom SRP 基础（六）"><img class="cover" src="https://s2.loli.net/2025/03/13/LozNxAmnlEJSOyV.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unity Custom SRP 基础（六）</div></div></a></div><div class="next-post pull-right"><a href="/2025/02/02/2025-02-02-CustomSRP4/" title="Unity Custom SRP 基础（四）"><img class="cover" src="https://s2.loli.net/2025/02/02/aLrYVUITs8tnuOw.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity Custom SRP 基础（四）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/15/2023-09-15-UnityShader1/" title="《Unity Shader入门精要》读书笔记（一）"><img class="cover" src="https://s2.loli.net/2023/09/19/cDvdURBPhjwkOsY.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-15</div><div class="title">《Unity Shader入门精要》读书笔记（一）</div></div></a></div><div><a href="/2023/10/13/2023-10-13-UnityShader2/" title="《Unity Shader入门精要》读书笔记（二）"><img class="cover" src="https://s2.loli.net/2023/10/15/RZftaNSscWoLH1u.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-13</div><div class="title">《Unity Shader入门精要》读书笔记（二）</div></div></a></div><div><a href="/2023/11/22/2023-11-22-UnityShader3/" title="《Unity Shader入门精要》读书笔记（三）"><img class="cover" src="https://s2.loli.net/2023/11/23/L3ts4WnThMlDN9d.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-22</div><div class="title">《Unity Shader入门精要》读书笔记（三）</div></div></a></div><div><a href="/2023/12/30/2023-12-30-UnityShader5/" title="《Unity Shader入门精要》读书笔记（五）"><img class="cover" src="https://s2.loli.net/2023/12/30/hc2s7BS45l1wUdQ.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-30</div><div class="title">《Unity Shader入门精要》读书笔记（五）</div></div></a></div><div><a href="/2024/02/23/2024-02-23-URP%E5%9F%BA%E7%A1%80/" title="Unity URP 基础"><img class="cover" src="https://s2.loli.net/2024/02/18/pMAzYioaFZEkS8I.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-23</div><div class="title">Unity URP 基础</div></div></a></div><div><a href="/2024/03/20/2024-03-20-NPR_StarRail1/" title="基于星穹铁道的卡通渲染（一）"><img class="cover" src="https://s2.loli.net/2024/03/26/dZTwsApi59CSUal.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-20</div><div class="title">基于星穹铁道的卡通渲染（一）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/wechat%20avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鸟布</div><div class="author-info__description">教练，我想学技术</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://niaobu.notion.site/787824630ea6480e944c1ae5ae7f4792"><i class="fa-solid fa-book"></i><span>My Notion</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ybniaobu/ybniaobu.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:niaobubob@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">为了蒂法！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PCSS"><span class="toc-number">1.</span> <span class="toc-text">PCSS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%85%89%E7%81%AF"><span class="toc-number">1.2.1.</span> <span class="toc-text">聚光灯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Blocker-Search"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Blocker Search</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Penumbra-Estimation-amp-Filtering"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">Penumbra Estimation &amp; Filtering</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%85%89%E6%BA%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">点光源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%90%91%E5%85%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">方向光</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.</span> <span class="toc-text">其他说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Post-Processing"><span class="toc-number">2.</span> <span class="toc-text">Post Processing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Volume-%E6%A1%86%E6%9E%B6"><span class="toc-number">2.1.</span> <span class="toc-text">Volume 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VolumeManager"><span class="toc-number">2.1.1.</span> <span class="toc-text">VolumeManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VolumeComponent"><span class="toc-number">2.1.2.</span> <span class="toc-text">VolumeComponent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Copy"><span class="toc-number">2.2.</span> <span class="toc-text">Copy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Frame-buffer"><span class="toc-number">2.2.1.</span> <span class="toc-text">Frame buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gizmos-%E5%92%8C-Editor-Preview"><span class="toc-number">2.2.2.</span> <span class="toc-text">Gizmos 和 Editor Preview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Copy-Shader"><span class="toc-number">2.2.3.</span> <span class="toc-text">Copy Shader</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Additive-Bloom"><span class="toc-number">3.</span> <span class="toc-text">Additive Bloom</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C-Bloom-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">制作 Bloom 基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.2.</span> <span class="toc-text">具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-Bloom-%E5%B1%9E%E6%80%A7"><span class="toc-number">3.2.1.</span> <span class="toc-text">配置 Bloom 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Downsample"><span class="toc-number">3.2.2.</span> <span class="toc-text">Downsample</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Upsample"><span class="toc-number">3.2.3.</span> <span class="toc-text">Upsample</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prefilter"><span class="toc-number">3.2.4.</span> <span class="toc-text">Prefilter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intensity"><span class="toc-number">3.2.5.</span> <span class="toc-text">Intensity</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/07/2025-04-07-CustomSRP7/" title="Unity Custom SRP 基础（七）"><img src="https://s2.loli.net/2025/04/07/2zi6pj3XtAPHvmy.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（七）"/></a><div class="content"><a class="title" href="/2025/04/07/2025-04-07-CustomSRP7/" title="Unity Custom SRP 基础（七）">Unity Custom SRP 基础（七）</a><time datetime="2025-04-07T12:57:36.000Z" title="发表于 2025-04-07 20:57:36">2025-04-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/13/2025-03-13-CustomSRP6/" title="Unity Custom SRP 基础（六）"><img src="https://s2.loli.net/2025/03/13/LozNxAmnlEJSOyV.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（六）"/></a><div class="content"><a class="title" href="/2025/03/13/2025-03-13-CustomSRP6/" title="Unity Custom SRP 基础（六）">Unity Custom SRP 基础（六）</a><time datetime="2025-03-13T12:44:31.000Z" title="发表于 2025-03-13 20:44:31">2025-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/26/2025-02-26-CustomSRP5/" title="Unity Custom SRP 基础（五）"><img src="https://s2.loli.net/2025/02/26/m2zJbPd8aeGD14A.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（五）"/></a><div class="content"><a class="title" href="/2025/02/26/2025-02-26-CustomSRP5/" title="Unity Custom SRP 基础（五）">Unity Custom SRP 基础（五）</a><time datetime="2025-02-26T03:30:46.000Z" title="发表于 2025-02-26 11:30:46">2025-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/02/2025-02-02-CustomSRP4/" title="Unity Custom SRP 基础（四）"><img src="https://s2.loli.net/2025/02/02/aLrYVUITs8tnuOw.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（四）"/></a><div class="content"><a class="title" href="/2025/02/02/2025-02-02-CustomSRP4/" title="Unity Custom SRP 基础（四）">Unity Custom SRP 基础（四）</a><time datetime="2025-02-02T06:35:41.000Z" title="发表于 2025-02-02 14:35:41">2025-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/07/2025-01-07-CustomSRP3/" title="Unity Custom SRP 基础（三）"><img src="https://s2.loli.net/2025/01/14/ELDF7wHpCPn2mKM.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity Custom SRP 基础（三）"/></a><div class="content"><a class="title" href="/2025/01/07/2025-01-07-CustomSRP3/" title="Unity Custom SRP 基础（三）">Unity Custom SRP 基础（三）</a><time datetime="2025-01-07T12:43:16.000Z" title="发表于 2025-01-07 20:43:16">2025-01-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By 鸟布</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Your time is limited, so don't waste it living someone else's life.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>